public static  http uri request   ( final  string method )  {  return arg that ( new  http uri request method matcher ( equal to ( method )  "method" "method" )  )  ;   }  
public static  http uri request   ( final  string payload )  {  return arg that ( has payload ( payload )  )  ;   }  
public static  http uri request   ( final  string query )  {  return arg that ( new  http uri request query matcher ( equal to ( query )  "query" "query" )  )  ;   }  
public static  http uri request   ( final  string query )  {  return arg that ( new  http uri request query matcher ( contains string ( query )  "query" "query" )  )  ;   }  
public static  http uri request   ( final  string path )  {  return arg that ( new  http uri request path matcher ( equal to ( path )  "path" "path" )  )  ;   }  
public static  replication instance builder   (  )  {  return new  replication instance builder (  )  ;   }  
public static  testable replication task builder   (  )  {  return new  testable replication task builder (  )  ;   }  
public void   (  )  {  transition (  download event . abandon   download null )  ;   }  
public void   (  executor executor )  throws sql exception  {  try  {   class <  ?  extends  connection >  delegate class = delegate . get class (  )  ;   class partypes[] = new  class[1] ;  partypes[0] =  executor . class ;   object args[] = new  object[1] ;  args[0] = executor ;   method method = delegate class . get method ( "abort" partypes )  ;  method . invoke ( delegate args )  ;   }  catch  (   security exception e )   {   }  catch  (   no such method exception e )   {   }  catch  (   illegal argument exception e )   {   }  catch  (   illegal access exception e )   {   }  catch  (   invocation target exception e )   {   }   }  
protected void   (  http servlet request request  http servlet response response )  throws io exception  {   security context holder . clear context (  )  ;  cookie utils . invalidate cookie ( response  session fixation protection cookie . cookie   name )  ;  if  ( blc request utils . iso kto use session ( new  servlet web request ( request )  )  )   {  request . get session (  )  . invalidate (  )  ;   }  response . send redirect ( " / " )  ;   }  
private synchronized void   (  )  {  if  ( s   connection  =  =  null )  return ;  try  {  s   connection . abort (  )  ;   }  catch  (   exception e )   {  s   logger . warn ( " failed to abort connection due to "  +  e . get message (  )  )  ;   }  s   connection = null ;   }  
public void   (  )  throws  exception  {     context . get service (  )  . http nfc lease abort (    mor null )  ;   }  
public static  money   (  money money )  {  return new  money ( money . amount . abs (  )  money . currency )  ;   }  
protected   (  abstract upload command that )  {  this ( that . name that . url that . format that . account id )  ;   }  
protected   ( final  abstract download command that )  {  super ( that )  ;  assert that . url  !  =  null ;  url = that . url . replace ( '\\' ' / ' )  ;  format = that . format ;  account id = that . account id ;  name = that . name ;   }  
public   (  palo alto method method  map <  string  string >  params )  {  this . method = method ;  this . params = params ;   }  
public   ( int x int y int width int height )  {  this . x = x ;  this . y = y ;  this . width = width ;  this . height = height ;   }  
protected   (  data center info info )  {  this . info = info ;   }  
protected   (  eureka client config client config )  {  this . client config = client config ;  populate defaultaz to region map (  )  ;   }  
protected   (  client jersey client  string service url )  {  this . jersey client = jersey client ;  this . service url = service url ;  logger . debug ( " created client for url:  {  } " service url )  ;   }  
public   (  client jersey client  string service url )  {  this . jersey client = jersey client ;  this . service url = service url ;   string local user name = null ;   string local password = null ;  try  {  uri serviceuri = new uri ( service url )  ;  if  ( serviceuri . get user info (  )   !  =  null )   {   string[] credentials = serviceuri . get user info (  )  . split ( ":" )  ;  if  ( credentials . length  =  =  2 )   {  local user name = credentials[0] ;  local password = credentials[1] ;   }   }   }  catch  (  uri syntax exception ignore )   {   }  this . user name = local user name ;  this . password = local password ;   }  
protected   (  eureka server config server config  eureka client config client config  server codecs server codecs )  {  this . server config = server config ;  this . client config = client config ;  this . server codecs = server codecs ;  this . recent canceled queue = new  circular queue <  pair <  long  string >  >  ( 1000 )  ;  this . recent registered queue = new  circular queue <  pair <  long  string >  >  ( 1000 )  ;  this . renews last min = new  measured rate ( 1000 * 60 * 1 )  ;  this . delta retention timer . schedule ( get delta retention task (  )  server config . get delta retention timer interval in ms (  )  server config . get delta retention timer interval in ms (  )  )  ;   }  
public framework util . get bundle ( get class (  )  ) ; bundle context = bundle . get bundle context (  ) ; system bundle = bundle context . get bundle ( 0 ) ; system bundle context = system bundle . get bundle context (  ) ;  }  
  (  )  {  this (  eureka server context holder . get instance (  )  . get server context (  )  )  ;   }  
  ( acl provider acl provider  list < acl >  acl list boolean apply to parents )  {  this . acl provider = acl provider ;  this . acl list =  ( acl list  !  =  null )   ?   immutable list . copy of ( acl list )  : null ;  this . apply to parents = apply to parents ;   }  
@ override public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  persistence perspective item visitor visitor )  {  visitor . visit ( this )  ;   }  
@ override public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
@ override public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  persistence perspective item visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
@ override public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  persistence perspective item visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  persistence perspective item visitor visitor )  {  visitor . visit ( this )  ;   }  
public void   (  metadata visitor visitor )  {  visitor . visit ( this )  ;   }  
@ override public boolean   (  file pathname )  {   string name = pathname . get absolute path (  )  ;  return name . starts with ( check path )  ;   }  
@ override public int   (  method method )  {   string name = method . get name (  )  ;  return  ( name . starts with ( "set" )  || name . starts with ( "incr" )  || name . starts with ( "decr" )  )   ?  1 : 0 ;   }  
@ override public boolean   ( final  file directory final  string file name )  {  return file name . ends with ( " . vhdx" )  || file name . ends with ( " . vhd" )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   vpc dao vpc dao = visitor . get virtual network appliance factory (  )  . get vpc dao (
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  return visitor . visit ( this )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   string op = "add" ;  if  (  !    is add pvlan )   {  op = "delete" ;   }   network dao 
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;     purpose =    rules . get ( 0 )  . get purpose (  )  ;  if  (    purpose  =  =   purpo
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  return visitor . visit ( this )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   load balancer dao load balancer dao = visitor . get virtual network appliance factory (
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  return visitor . visit ( this )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   pair <  map <  string  public ip address >   map <  string  public ip address >  >  nic
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  boolean result = false ;  try  {  final  network model network model = visitor . get vir
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  return visitor . visit ( this )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;  return visitor . visit ( this )  ;   }  
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;   user vm dao user vm dao = visitor . get virtual network appliance factory (  )  . get u
@ override public boolean   ( final  network topology visitor visitor final  virtual router router )  throws  resource unavailable exception  {     router = router ;     vlan mac address = new  hash map <  string  string >  (  )  ;     ips to send = new  
@ override public int   (  method method )  {  for  (   component method interceptor interceptor : get interceptors (  )  )   {  if  ( interceptor . need to intercept ( method )  )   {  return 1 ;   }   }  return 0 ;   }  
@ override public int   (  method method )  {  if  ( method . get parameter types (  )  . length  =  =  0 && method . get name (  )  . equals ( "finalize" )  )   {  return 1 ;   }  return 0 ;   }  
protected void   ( final  selection key key )  throws io exception  {  final  server socket channel server socket channel =  (  server socket channel ) key . channel (  )  ;  final  socket channel socket channel = server socket channel . accept (  )  ;  socket channel . configure blocking ( false )  ;  final  socket socket = socket channel . socket (  )  ;  socket . set keep alive ( true )  ;  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " connection accepted for "  +  socket )  ;   }  final ssl engine ssl engine ;  try  {  ssl engine =  link . init serverssl engine ( ca service socket channel . get remote address (  )  . to string (  )  )  ;  ssl engine . set use client mode ( false )  ;  ssl engine . set enabled protocols ( ssl utils . get supported protocols ( ssl engine . get enabled protocols (  )  )  )  ;  final  nio connection nio connection = this ;     ssl handshake executor . submit ( new  runnable (  )  {  @ override public void run (  )  {     selector . wakeup (  )  ;  try  {  ssl engine . begin handshake (  )  ;  if  (  !  link . do handshake ( socket channel ssl engine )  )   {  throw new io exception ( "ssl handshake timed out with "  +  socket channel . get remote address (  )  )  ;   }  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( "ssl:  handshake done" )  ;   }  final  inet socket address saddr =  (  inet socket address ) socket . get remote socket address (  )  ;  final  link link = new  link ( saddr nio connection )  ;  link . setssl engine ( ssl engine )  ;  link . set key ( socket channel . register ( key . selector (  )   selection key . op   read link )  )  ;  final  task task =    factory . create (  task .  type . connect link null )  ;  register link ( saddr link )  ;     executor . submit ( task )  ;   }  catch  (  io exception e )   {  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " connection closed due to failure: "  +  e . get message (  )  )  ;   }  close auto closeable ( socket "accepting socket" )  ;  close auto closeable ( socket channel "accepting socket channel" )  ;   }  finally  {     selector . wakeup (  )  ;   }   }   }   )  ;   }  catch  (  final  exception e )   {  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " connection closed due to failure: "  +  e . get message (  )  )  ;   }  close auto closeable ( socket "accepting socket" )  ;  close auto closeable ( socket channel "accepting socket channel" )  ;   }  finally  {     selector . wakeup (  )  ;   }   }  
@ override public boolean   (  string full path )  {  return true ;   }  
@ override public boolean   (  string full path )  {  return  ! full path . equals ( " / root / n1 - c" )  ;   }  
private void   (  modeled cache listener .  type type z path path  stat stat t model )  {  listener container . for each ( l  -  >   {  l . accept ( type path stat model )  ;  return null ;   }   )  ;   }  
@ override public void   (  type type z path path  stat stat t model )  {  if  ( is initialized )   {   modeled cache listener . this . accept ( type path stat model )  ;   }   }  
@ override public  completable future <  void >    (  completion stage <  ?  extends u >  other  consumer <  ?  super u >  action )  {  return super . accept either async ( other action executor )  ;   }  
@ override public boolean   ( int status code  request type request type )  {  return status code  >  =  200 && status code  <  300 ;   }  
@ override public boolean   (  file dir  string name )  {  return war   pattern . matcher ( name )  . matches (  )  ;   }  
  (  string id int max buffer size int max batching size long max batching delay long congestion retry delay ms long network failure retry ms )  {  this . max buffer size = max buffer size ;  this . max batching size = max batching size ;  this . max batching delay = max batching delay ;  this . traffic shaper = new  traffic shaper ( congestion retry delay ms network failure retry ms )  ;   thread group thread group = new  thread group ( "eureka task executors" )  ;  this . acceptor thread = new  thread ( thread group new  acceptor runner (  )  " task acceptor - "  +  id )  ;  this . acceptor thread . set daemon ( true )  ;  this . acceptor thread . start (  )  ;  final double[] percentiles =  { 50 . 0 95 . 0 99 . 0 99 . 5 }  ;  final  stats config stats config = new  stats config .  builder (  )  . with sample size ( 1000 )  . with percentiles ( percentiles )  . with publish std dev ( true )  . build (  )  ;  final  monitor config config =  monitor config . builder ( metric   replication   prefix  +  "batch size" )  . build (  )  ;  this . batch size metric = new  stats timer ( config stats config )  ;  try  {   monitors . register object ( id this )  ;   }  catch  (   throwable e )   {  logger . warn ( " cannot register servo monitor for this object" e )  ;   }   }  
public   (  list <  unmask range >  ranges char mask character )  {  this . ranges = ranges ;  this . mask character = mask character ;   }  
public   (  string msg  throwable cause )  {  super ( msg cause )  ;   }  
public   (  )  {   account search = create search builder (  )  ;   account search . and ( "account id"  account search . entity (  )  . get account id (  )   search criteria .  op . eq )  ;   account search . done (  )  ;   vlan search = create search builder (  )  ;   vlan search . and ( "vlan db id"  vlan search . entity (  )  . get vlan db id (  )   search criteria .  op . eq )  ;   vlan search . done (  )  ;   account vlan search = create search builder (  )  ;   account vlan search . and ( "account id"  account vlan search . entity (  )  . get account id (  )   search criteria .  op . eq )  ;   account vlan search . and ( "vlan db id"  account vlan search . entity (  )  . get vlan db id (  )   search criteria .  op . eq )  ;   account vlan search . done (  )  ;   }  
public   (  )  {  super (  )  ;   account search = create search builder (  )  ;   account search . and ( "account id"  account search . entity (  )  . get account id (  )   search criteria .  op . eq )  ;   account search . done (  )  ;   guest vlan search = create search builder (  )  ;   guest vlan search . and ( "guest vlan id"  guest vlan search . entity (  )  . get id (  )   search criteria .  op . eq )  ;   guest vlan search . done (  )  ;   physical network search = create search builder (  )  ;   physical network search . and ( "physical network id"  physical network search . entity (  )  . get id (  )   search criteria .  op . eq )  ;   physical network search . done (  )  ;   }  
protected   (  )  {  account search = create search builder (  )  ;  account search . and ( "account id" account search . entity (  )  . get account id (  )   op . eq )  ;  account search . done (  )  ;   }  
public   ( long account id  string name  string value )  {  this . account id = account id ;  this . name = name ;  this . value = value ;   }  
public   (  )  {   all fields search = create search builder (  )  ;   all fields search . and ( "account name"  all fields search . entity (  )  . get account name (  )   search criteria .  op . eq )  ;   all fields search . and ( "domain id"  all fields search . entity (  )  . get domain id (  )   search criteria .  op . eq )  ;   all fields search . and ( "state"  all fields search . entity (  )  . get state (  )   search criteria .  op . eq )  ;   all fields search . and ( "type"  all fields search . entity (  )  . get type (  )   search criteria .  op . eq )  ;   all fields search . done (  )  ;   account type search = create search builder (  )  ;   account type search . and ( "domain id"  account type search . entity (  )  . get domain id (  )   search criteria .  op . eq )  ;   account type search . and ( "type"  account type search . entity (  )  . get type (  )   search criteria .  op . eq )  ;   account type search . done (  )  ;   domain accounts search = create search builder (  )  ;   domain accounts search . and ( "domain id"  domain accounts search . entity (  )  . get domain id (  )   search criteria .  op . eq )  ;   domain accounts search . and ( "removed"  domain accounts search . entity (  )  . get removed (  )   search criteria .  op . null )  ;   domain accounts search . done (  )  ;   cleanup for removed accounts search = create search builder (  )  ;   cleanup for removed accounts search . and ( "cleanup"  cleanup for removed accounts search . entity (  )  . get needs cleanup (  )   search criteria .  op . eq )  ;   cleanup for removed accounts search . and ( "removed"  cleanup for removed accounts search . entity (  )  . get removed (  )   search criteria .  op . nnull )  ;   cleanup for removed accounts search . and ( "domainid"  cleanup for removed accounts search . entity (  )  . get domain id (  )   search criteria .  op . eq )  ;   cleanup for removed accounts search . done (  )  ;   cleanup for disabled accounts search = create search builder (  )  ;   cleanup for disabled accounts search . and ( "cleanup"  cleanup for disabled accounts search . entity (  )  . get needs cleanup (  )   search criteria .  op . eq )  ;   cleanup for disabled accounts search . and ( "removed"  cleanup for disabled accounts search . entity (  )  . get removed (  )   search criteria .  op . null )  ;   cleanup for disabled accounts search . and ( "state"  cleanup for disabled accounts search . entity (  )  . get state (  )   search criteria .  op . eq )  ;   cleanup for disabled accounts search . done (  )  ;   non project account search = create search builder (  )  ;   non project account search . and ( "account name"  non project account search . entity (  )  . get account name (  )   search criteria .  op . eq )  ;   non project account search . and ( "domain id"  non project account search . entity (  )  . get domain id (  )   search criteria .  op . eq )  ;   non project account search . and ( "state"  non project account search . entity (  )  . get state (  )   search criteria .  op . eq )  ;   non project account search . and ( "type"  non project account search . entity (  )  . get type (  )   search criteria .  op . neq )  ;   non project account search . done (  )  ;   account ids search = create search builder (  long . class )  ;   account ids search . select fields (  account ids search . entity (  )  . get id (  )  )  ;   account ids search . and ( "ids"  account ids search . entity (  )  . get domain id (  )   op . in )  ;   account ids search . done (  )  ;   account by role search = create search builder (  )  ;   account by role search . and ( "role id"  account by role search . entity (  )  . get role id (  )   search criteria .  op . eq )  ;   account by role search . done (  )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account service   (  )  {  return  mockito . mock (  account service . class )  ;   }  
@ bean public  account manager   (  )  {  return mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
protected   (  )  {  acct id search = create search builder (  )  ;  acct id search . and ( "id" acct id search . entity (  )  . get id (  )   search criteria .  op . eq )  ;  acct id search . done (  )  ;     count = "select count ( distinct id )  from account   view where " ;   }  
private  long   (  account account long user id  user vmvo vm instance check vm templatevo template  string msg )  throws  permission denied exception  {  if  ( account  !  =  null )   {  if  (  !    account mgr . is admin ( account . get id (  )  )  )   {  if  (  ( vm instance check  !  =  null )  &&  ( account . get id (  )   !  =  vm instance check . get account id (  )  )  )   {  throw new  permission denied exception ( msg  +  " .   permission denied . " )  ;   }  if  (  ( template  !  =  null )  &&  (  ! template . is public template (  )  &&  ( account . get id (  )   !  =  template . get account id (  )  )  &&  ( template . get template type (  )   !  =   template type . perhost )  )  )   {   account owner =    account mgr . get account ( template . get account id (  )  )  ;  if  ( owner . get type (  )   =  =   account . account   type   project )   {  if  (  !    project mgr . can access project account ( account owner . get id (  )  )  )   {  throw new  permission denied exception ( msg  +  " .   permission denied .   the caller can't access project's template" )  ;   }   }  else  {  throw new  permission denied exception ( msg  +  " .   permission denied . " )  ;   }   }   }  else  {  if  (  ( vm instance check  !  =  null )  &&  !    domain dao . is child domain ( account . get domain id (  )  vm instance check . get domain id (  )  )  )   {  throw new  permission denied exception ( msg  +  " .   permission denied . " )  ;   }  if  ( template  !  =  null )   {   account template owner =    account dao . find by id ( template . get account id (  )  )  ;  if  (  ( template owner  !  =  null )  &&  !    domain dao . is child domain ( account . get domain id (  )  template owner . get domain id (  )  )  )   {  throw new  permission denied exception ( msg  +  " .   permission denied . " )  ;   }   }   }   }  return user id ;   }  
private  long   (  hostvo host )  {  long host id = host . get id (  )  ;   dedicated resourcevo dedicated host =    dedicated dao . find by host id ( host id )  ;   dedicated resourcevo dedicated cluster of host =    dedicated dao . find by cluster id ( host . get cluster id (  )  )  ;   dedicated resourcevo dedicated pod of host =    dedicated dao . find by pod id ( host . get pod id (  )  )  ;  if  ( dedicated host  !  =  null )   {  return dedicated host . get account id (  )  ;   }  if  ( dedicated cluster of host  !  =  null )   {  return dedicated cluster of host . get account id (  )  ;   }  if  ( dedicated pod of host  !  =  null )   {  return dedicated pod of host . get account id (  )  ;   }  return null ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account service   (  )  {  return  mockito . mock (  account service . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account service   (  )  {  return  mockito . mock (  account service . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account details dao   (  )  {  return  mockito . mock (  account details dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account dao   (  )  {  return  mockito . mock (  account dao . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ test public void   (  )  {  iam groupvo group = new iam groupvo ( "group1" "my first group" )  ;   list <  long >  account ids = new  array list <  long >  (  )  ;  account ids . add ( 100l )  ;  when (    acl group dao . find by id ( 20l )  )  . then r
public   ( final  string account name final long domain id final  string network domain final short type final  long role id final  string uuid )  {  this ( account name domain id network domain type uuid )  ;  if  ( role id  !  =  null )   {  this . role id = role id ;   }   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
@ bean public  account manager   (  )  {  return  mockito . mock (  account manager . class )  ;   }  
public void   (  )  {  synchronized  ( this )   {  assert  (    outstanding signal requests  =  =  1 )  ;     outstanding signal requests -  -  ;   }   }  
protected   (  string cidr boolean allowed )  {  this . cidr = cidr ;  this . allowed = allowed ;   }  
public   (  )  {  this . id = null ;  this . priority = 0 ;  this . action = null ;  this . ip proto = null ;  this . source = new  acl network (  )  ;  this . destination = new  acl network (  )  ;   }  
public   ( final  string cidr final  integer port )  {  this . cidr = cidr ;  this . port = port ;   }  
public   (  string ethertype int protocol  string action  string source mac address  string destination mac address  string source ip prefix  string destination ip prefix  integer source port range min  integer source port range max  integer destination port range min  integer destination port range max int order  integer icmp protocol code  integer icmp protocol type )  {  this . ethertype = ethertype ;  this . protocol = protocol ;  this . action = action ;  this . source mac address = source mac address ;  this . destination mac address = destination mac address ;  this . source ip prefix = source ip prefix ;  this . destination ip prefix = destination ip prefix ;  this . source port range min = source port range min ;  this . source port range max = source port range max ;  this . destination port range min = destination port range min ;  this . destination port range max = destination port range max ;  this . order = order ;  this . icmp protocol code = icmp protocol code ;  this . icmp protocol type = icmp protocol type ;   }  
public   (  string uuid  acl item[] acl items )  {  this . id = uuid ;  this . acl items = acl items ;   }  
public   ( int number  string uuid  string action  string direction  string source port start  string source port end  string protocol  string[] source cidrs )  {  this . number = number ;  this . uuid = uuid ;  this . action = action ;  this . direction = direction ;  this . source cidrs = source cidrs ;  this . source port start = source port start ;  this . source port end = source port end ;  this . protocol = protocol ;   }  
@ bean public iam account policy map dao   (  )  {  return  mockito . mock ( iam account policy map dao . class )  ;   }  
@ bean public iam group account map dao   (  )  {  return  mockito . mock ( iam group account map dao . class )  ;   }  
@ bean public iam group dao   (  )  {  return  mockito . mock ( iam group dao . class )  ;   }  
@ bean public iam group policy map dao   (  )  {  return  mockito . mock ( iam group policy map dao . class )  ;   }  
@ bean public iam policy dao   (  )  {  return  mockito . mock ( iam policy dao . class )  ;   }  
@ bean public iam policy permission dao   (  )  {  return  mockito . mock ( iam policy permission dao . class )  ;   }  
public  builder   ( acl provider acl provider )  {  this . acl provider = acl provider ;  return this ;   }  
@ override public  list < acl >    (  )  {  return acl list ;   }  
@ override public boolean   (  order order )  {   string order lock key = get order lock key (  )  ;   query q = em . create named query ( "bc   order   lock   read" )  ;  q . set parameter ( "order id" order . get id (  )  )  ;  q . set parameter ( "key"
@ override @ transactional ( "bl transaction manager" )  public boolean   (  order order )  {  return order dao . acquire lock ( order )  ;   }  
@ override public  object   (  order order )  {  if  ( order  =  =  null || order instanceof  null order impl )   {  if  ( log . is debug enabled (  )  )   {  log . debug ( " thread["  +   thread . current thread (  )  . get id (  )   +  "]  attempted to 
@ override public  object   (  order order )  {  if  ( order instanceof  null order impl )   {  if  ( log . is debug enabled (  )  )   {  log . debug ( " attempted to grab a lock for a  null order impl .   not blocking" )  ;   }  return order ;   }  boole
@ override public  object   (  order order )  {   reentrant lock lock object = get session lock (  )  ;  lock object . lock (  )  ;  return lock object ;   }  
@ override public  object   (  order order )  {   reentrant lock lock object = get session lock (  )  ;  boolean locked = lock object . try lock (  )  ;  return locked  ?  lock object : null ;   }  
@ override public t   ( final id id int seconds )  {   transaction legacy txn =  transaction legacy . current txn (  )  ;  t t = null ;  boolean locked = false ;  try  {  if  (  ! txn . lock (    table  +  id . to string (  )  seconds )  )   {  return nul
public boolean   (  string key int time in seconds )  {   thread th =  thread . current thread (  )  ;   string thread name = th . get name (  )  ;  int thread id =  system . identity hash code ( th )  ;  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " acquiring lck - "  +  key  +  " with wait time of " +  time in seconds )  ;   }  long start time =  inaccurate clock . get time (  )  ;  while  (  (  inaccurate clock . get time (  )   -  start time )   <   ( time in seconds * 1000l )  )   {  int count = owns ( key )  ;  if  ( count  >  =  1 )   {  return increment ( key thread name thread id )  ;   }  else if  ( count  =  =  0 )   {  if  ( do acquire ( key thread name thread id )  )   {  return true ;   }   }  try  {  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " sleeping more time while waiting for lck - "  +  key )  ;   }   thread . sleep ( 5000 )  ;   }  catch  (   interrupted exception e )   {  s   logger . debug ( "[ignored] interupted while aquiring "  +  key )  ;   }   }   string msg = " timed out on acquiring lock "  +  key  +  "  .   waited for " +   (  (  inaccurate clock . get time (  )   -  start time )   /  1000 )  +  "seconds" ;   exception e = new  cloud runtime exception ( msg )  ;  s   logger . warn ( msg e )  ;  return false ;   }  
@ override @db public  string   (  network network  string requested ip )  {  if  ( requested ip  !  =  null && requested ip . equals ( network . get gateway (  )  )  )   {  s   logger . warn ( " requested ip address "  +  requested ip  +  " is used as a 
@ override public  storage network ip addressvo   ( long pod id )  {   list <  storage network ip rangevo >  ranges =    s nw ip range dao . list by pod id ( pod id )  ;  for  (   storage network ip rangevo r : ranges )   {  try  {   long range id = r . g
@ override public  usage eventvo   (  long id int seconds )  {  return null ;   }  
public static com . trilead . ssh2 .  connection   (  string ip int port  string username  string password )  {  com . trilead . ssh2 .  connection ssh connection = new com . trilead . ssh2 .  connection ( ip port )  ;  try  {  ssh connection . connect ( null default   connect   timeout default   kex   timeout )  ;  if  (  ! ssh connection . authenticate with password ( username password )  )   {   string[] methods = ssh connection . get remaining auth methods ( username )  ;   string buffer m str = new  string buffer (  )  ;  for  ( int i = 0 ;  i  <  methods . length ;  i +  +  )   {  m str . append ( methods[i] )  ;   }  s   logger . warn ( "ssh authorizes failed  support authorized methods are "  +  m str )  ;  return null ;   }  return ssh connection ;   }  catch  (  io exception e )   {  s   logger . warn ( " get ssh connection failed" e )  ;  return null ;   }   }  
@ override public boolean   ( long time  time unit unit )  throws  exception  {   exception exception = null ;   list <  inter process lock >  acquired =  lists . new array list (  )  ;  boolean success = true ;  for  (   inter process lock lock : locks )
@ override public boolean   ( long time  time unit unit )  throws  exception  {  return internal lock ( time unit )  ;   }  
public  collection <  lease >    ( int qty long time  time unit unit )  throws  exception  {  long start ms =  system . current time millis (  )  ;  long wait ms =  time unit . milliseconds . convert ( time unit )  ;   preconditions . check argument ( qty  >  0 "qty cannot be 0" )  ;   immutable list .  builder <  lease >  builder =  immutable list . builder (  )  ;  try  {  while  ( qty -  -   >  0 )   {  long elapsed ms =  system . current time millis (  )   -  start ms ;  long this wait ms = wait ms  -  elapsed ms ;   string path =  ( this wait ms  >  0 )   ?  internals . attempt lock ( this wait ms  time unit . milliseconds null )  : null ;  if  ( path  =  =  null )   {  return all ( builder . build (  )  )  ;  return null ;   }  builder . add ( make lease ( path )  )  ;   }   }  catch  (   exception e )   {   thread utils . check interrupted ( e )  ;  return all ( builder . build (  )  )  ;  throw e ;   }  return builder . build (  )  ;   }  
@ override public boolean   ( long time  time unit unit )  throws  exception  {   lease acquired lease = semaphore . acquire ( time unit )  ;  if  ( acquired lease  =  =  null )   {  return false ;   }  lease = acquired lease ;  return true ;   }  
public  collection <  lease >    ( int qty long time  time unit unit )  throws  exception  {  long start ms =  system . current time millis (  )  ;  boolean has wait =  ( unit  !  =  null )  ;  long wait ms = has wait  ?   time unit . milliseconds . convert ( time unit )  : 0 ;   preconditions . check argument ( qty  >  0 "qty cannot be 0" )  ;   immutable list .  builder <  lease >  builder =  immutable list . builder (  )  ;  boolean success = false ;  try  {  while  ( qty -  -   >  0 )   {  int retry count = 0 ;  long start millis =  system . current time millis (  )  ;  boolean is done = false ;  while  (  ! is done )   {  switch  ( internal acquire1 lease ( builder start ms has wait wait ms )  )   {  case continue:  {  is done = true ;  break ;   }  case return   null:  {  return null ;   }  case retry   due   to   missing   node:  {  if  (  ! client . get zookeeper client (  )  . get retry policy (  )  . allow retry ( retry count +  +   system . current time millis (  )   -  start millis  retry loop . get default retry sleeper (  )  )  )   {  throw new  keeper exception .  no node exception ( " sequential path not found  -  possible session loss" )  ;   }  break ;   }   }   }   }  success = true ;   }  finally  {  if  (  ! success )   {  return all ( builder . build (  )  )  ;   }   }  return builder . build (  )  ;   }  
protected boolean   (  inter process lock lock long timeout  time unit unit )  throws  exception  {  return lock . acquire ( timeout unit )  ;   }  
private void   (  )  throws  exception  {   inter process semaphorev2 semaphore = new  inter process semaphorev2 ( client semaphore path max   semaphore   leases )  ;   lease lease = semaphore . acquire (  )  ;  try  {  has acquired = true ;  if  ( active client . compare and set ( null this )  )   {  throw new  exception ( " multiple acquirers" )  ;   }  try  {  while  ( has acquired && should run )   {  operation . call (  )  ;   }   }  finally  {  if  ( active client . compare and set ( this null )  )   {  throw new  exception ( " bad release" )  ;   }   }   }  finally  {  semaphore . return lease ( lease )  ;   }   }  
@ override public boolean   ( long time  time unit unit )  throws  exception  {  throw new  exception ( "foo" )  ;   }  
public boolean   (  semaphore semaphore int n )  {   timing2 m = for waiting (  )  ;  try  {  return semaphore . try acquire ( n m . value m . unit )  ;   }  catch  (   interrupted exception e )   {   thread . current thread (  )  . interrupt (  )  ;   }  return false ;   }  
public boolean   (  semaphore semaphore int n )  {   timing m = for waiting (  )  ;  try  {  return semaphore . try acquire ( n m . value m . unit )  ;   }  catch  (   interrupted exception e )   {   thread . current thread (  )  . interrupt (  )  ;   }  return false ;   }  
public boolean   ( int burst size long average rate long current time millis )  {  if  ( burst size  <  =  0 || average rate  <  =  0 )   {  return true ;   }  refill token ( burst size average rate current time millis )  ;  return consume token ( burst size )  ;   }  
public string builder   (  string value )  {   string builder sb = acquire string builder (  ) ; sb . set length ( 0 ) ; sb . append ( value ) ; return sb;  }  
public   (  action type type  string subject  message subscriber subscriber )  {     type = type ;     subject = subject ;     subscriber = subscriber ;   }  
public   ( final url url final  string username final  string password )  {  this . url = url ;  this . username = username ;  this . password = password ;   }  
@ override public void   (  long param )  {  progress reporter . report progress (  ( int )  ( param * 100  /  total bytes )  )  ;   }  
@ override public void   (  long param )  {  if  ( s   logger . is trace enabled (  )  )   {  s   logger . trace ( " download progress "  +  param  +  " / " +  total bytes )  ;   }  progress reporter . report progress (  ( int )  ( param * 100  /  total b
public static  transformer <  instance info >    (  action type action type )  {  switch  ( action type )   {  case added: return add   action   setter   transformer ;  case modified: return modified   action   setter   transformer ;  case deleted: return deleted   action   setter   transformer ;   }  throw new  illegal state exception ( " unhandled  action type value "  +  action type )  ;   }  
@ override public void   (  class clazz )  {   configurator . set level ( clazz . get name (  )   level . info )  ;   }  
@ override public void   (  class clazz )  {   log manager . get logger ( clazz )  . set level (  level . info )  ;   }  
@ override public void   (  )  {  if  ( get adapter (  )   !  =  null )   {  get adapter (  )  . activate logging (  statistics service impl . class )  ;   }   }  
@ managed operation ( description = " activate debug level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j2 category to set" )  }  )  public void   (  string category )  {   configurator .
@ managed operation ( description = " activate error level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j2 category to set" )  }  )  public void   (  string category )  {   configurator .
@ managed operation ( description = " activate fatal level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j2 category to set" )  }  )  public void   (  string category )  {   configurator .
@ managed operation ( description = " activate info level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j2 category to set" )  }  )  public void   (  string category )  {   configurator . 
@ managed operation ( description = " activate warn level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j2 category to set" )  }  )  public void   (  string category )  {   configurator . 
@ managed operation ( description = " activate debug level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j category to set" )  }  )  public void   (  string category )  {   log manager . g
@ managed operation ( description = " activate error level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j category to set" )  }  )  public void   (  string category )  {   log manager . g
@ managed operation ( description = " activate fatal level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j category to set" )  }  )  public void   (  string category )  {   log manager . g
@ managed operation ( description = " activate info level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j category to set" )  }  )  public void   (  string category )  {   log manager . ge
@ managed operation ( description = " activate warn level" )  @ managed operation parameters (  { @ managed operation parameter ( name = "category" description = "the log4j category to set" )  }  )  public void   (  string category )  {   log manager . ge
private static void   (  )  {   map <  object  object >  resource map =  transaction synchronization manager . get resource map (  )  ;  for  (   map .  entry <  object  object >  entry : resource map . entry set (  )  )   {  if  ( entry . get key (  )  instanceof  entity manager factory && entry . get value (  )  instanceof  entity manager holder )   {   (  (  hibernate entity manager )  (  (  entity manager holder ) entry . get value (  )  )  . get entity manager (  )  )  . get session (  )  ;   }   }   }  
private boolean   (  port profile port profile )  throws  brocade vcs api exception  {  final  port profile global port profile global = new  port profile global (  )  ;  port profile . set vlan profile ( null )  ;  final  activate activate = new  activate (  )  ;  port profile . set activate ( activate )  ;  port profile global . set port profile ( port profile )  ;  return execute update object ( port profile global  constants . uri )  ;   }  
@ override @ action event ( event type =  event types . event   project   activate event description = "activating project" )  @db public  project   ( final long project id )  {   account caller =  call context . current (  )  . get calling account (  )  
@ override public  project   ( long project id )  {  return null ;   }  
activate void   (  map <  string  ?  >  configuration )  throws  servlet exception   namespace exception  {  http service . register servlet ( readiness check path new  readiness check servlet ( readiness checkers )  null null ) ; http service . register servlet ( health check path new  health check
activate void   (  )  {  enabled = get system property or env var (  f a b r i c8 _  c m _  b r i d g e _  e n a b l e d enabled ) ; pid label = get system property or env var (  f a b r i c8 _  p i d _  l a b e l pid label ) ; config merge = get system property or env var (  f a b r i c8 _  c o n f i g _  m e r g e config merge ) ; config meta = get system property
activate void   (  )  {  enabled = get system property or env var (  f a b r i c8 _  c o n f i g _  p l u g i n _  e n a b l e d enabled ) ;  l o g g e r . debug ( " configuration update is  {  } " enabled  ?  " e n a b l e d" : " d i s a b l e d" ) ;  }  
public   (  string message  throwable th )  {  super ( message th )  ;   }  
public   ( long job id long thread id boolean from pool thread )  {     thread id = thread id ;     job id = job id ;     from pool thread = from pool thread ;     job last heartbeat tick =  system . current time millis (  )  ;   }  
@db public boolean   ( final  project project final  long account id final  string email )  {  return  transaction . execute ( new  transaction callback <  boolean >  (  )  {  @ override public  boolean do in transaction (   transaction status status )  {
public   (  string type  integer priority  string message )  {  this . message = message ;  this . type = type ;  this . priority = priority ;   }  
public   ( final ha resource resource final ha provider < ha resource >  ha provider final ha config ha config final ha provider . ha provider config ha provider config final  executor service executor final long disconnect time )  {  super ( resource ha provider ha config ha provider config executor )  ;  this . disconnect time = disconnect time ;  this . max activity checks =  (  long ) ha provider . get config value ( ha provider config .  max activity checks resource )  ;  this . activity check failure ratio =  (  double ) ha provider . get config value ( ha provider config .  activity check failure ratio resource )  ;   }  
@ test public void   (  )  throws  xenapi exception   xml rpc exception  {  host record mock . software version . put ( "product   brand" "xcp" )  ;  host record mock . software version . put ( "product   version" "1 . 0" )  ;   string returned iso templa
@ test public void   (  )  throws  xenapi exception   xml rpc exception  {  host record mock . software version . put ( "product   brand" " xen server" )  ;  host record mock . software version . put ( "product   version" "7 . 0" )  ;   string returned is
@ test public void   (  )  throws  xenapi exception   xml rpc exception  {  host record mock . software version . put ( "product   brand" " xen server" )  ;  host record mock . software version . put ( "product   version" "7 . 1" )  ;   string returned is
@ test public void   (  )  throws  xenapi exception   xml rpc exception  {  host record mock . software version . put ( "product   brand" " xen server" )  ;  host record mock . software version . put ( "product   version" "6 . 0" )  ;   string returned is
@ override public  output stream   (  client request request  output stream out )  throws io exception  {  return new gzip output stream ( get adapter (  )  . adapt ( request out )  )  ;   }  
public   (  )  {  super (  )  ;  set run level (  component lifecycle . run   level   component )  ;   }  
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata from mapping data request add metadata from mapping data request  field metadata metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  final  tuple <  category  category >  parent and child = get child and parent categories (
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {  entity = validate paren
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
protected void   (  criteria transfer object cto )  {  if  ( is active filter && cto . get criteria map (  )  . contains key ( is   active )  )   {   filter and sort criteria filter = cto . get ( is   active )  ;  final  boolean is active =  boolean . parse boolean ( filter . get filter values (  )  . get ( 0 )  )  ;   filter mapping filter mapping = new  filter mapping (  )  . with field path ( new  field path (  )  . with target property ( "id" )  )  . with direct filter values ( new  empty filter values (  )  )  . with restriction ( new  restriction (  )  . with predicate provider ( new  predicate provider (  )  {  @ override public  predicate build predicate (   criteria builder builder   field path builder field path builder   from root   string ceiling entity   string full property name   path explicit path   list direct values )  {   date current time =  system time . as date ( true )  ;  if  ( is active )   {  return builder . and ( builder . is not null ( root . get ( "start date" )  )  builder . less than ( root . get ( "start date" )  current time )  builder . or ( builder . is null ( root . get ( "end date" )  )  builder . greater than ( root . get ( "end date" )  current time )  )  )  ;   }  else  {  return builder . or ( builder . is null ( root . get ( "start date" )  )  builder . greater than ( root . get ( "start date" )  current time )  builder . and ( builder . is not null ( root . get ( "end date" )  )  builder . less than ( root . get ( "end date" )  current time )  )  )  ;   }   }   }   )  )  ;  cto . get additional filter mappings (  )  . add ( filter mapping )  ;   }   }  
protected void   (  record helper helper  entity entity )  {  if  ( is active filter )   {  try  {  boolean is active = false ;   property start date = entity . find property ( "start date" )  ;  if  ( start date  !  =  null &&  string utils . is not blank ( start date . get value (  )  )  )   {   property end date = entity . find property ( "end date" )  ;   date end = null ;  if  ( end date  !  =  null &&  string utils . is not blank ( end date . get value (  )  )  )   {  end = helper . get simple date formatter (  )  . parse ( end date . get value (  )  )  ;   }   date date = helper . get simple date formatter (  )  . parse ( start date . get value (  )  )  ;  is active =  date util . is active ( date end true )  ;   }  entity . add property ( build is active property ( is active )  )  ;   }  catch  (   parse exception e )   {  throw  exception helper . refine exception ( e )  ;   }   }   }  
protected void   (  criteria transfer object cto )  {  boolean user sort = false ;  for  (   filter and sort criteria fasc : cto . get criteria map (  )  . values (  )  )   {  if  ( fasc . get sort direction (  )   !  =  null )   {  user sort = true ;  break ;   }   }  if  (  ! user sort )   {  for  ( int i = 0 ;  i  <  sort fields . length ;  i +  +  )   {   string string = sort fields[i] ;   filter and sort criteria fsc = cto . get criteria map (  )  . get ( string )  ;  if  ( fsc  =  =  null )   {  fsc = new  filter and sort criteria ( string i )  ;  cto . add ( fsc )  ;   }  fsc . set sort ascending ( true )  ;   }   }   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
@ override public boolean   (  string cache key  map <  string  field metadata >  metadata )  {  if  ( use cache (  )  )   {  metadata   cache . put ( cache key metadata )  ;  return true ;   }  else  {  return false ;   }   }  
protected void   (  model model  string id )  {  if  ( duplicator . validate (  offer impl . class  long . parse long ( id )  )  )   {   entity form form =  (  entity form ) model . as map (  )  . get ( "entity form" )  ;   entity form action duplicate = new  entity form action ( "duplicate" )  . with button class ( "duplicate - button" )  . with display text ( " duplicate" )  ;  form . add action ( duplicate )  ;   }   }  
@ override @ request mapping ( value = " / add" method =  request method . post )  public  string   (  http servlet request request  http servlet response response  model model @ path variable  map <  string  string >  path vars @ model attribute ( value 
@ override public  extension result status type   (  list <  field data >  fields  string rule field name  string dto class name )  {  if  ( is geolocation enabled (  )  &&  rule identifier . request . equals ( rule field name )  )   {  fields . add ( new
@ override public  extension result status type   (  list <  field data >  fields  string rule field name  string dto class name )  {  if  (  rule identifier . request . equals ( rule field name )  )   {  for  (   ruledto config field config : field confi
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  return add or update ( persistence package dynamic entity dao helper )  ;   }  
protected  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   string ceiling entity fully qualified classname = persistence package . get ceiling entity fully qualified classname (  )  ;  try  {   string page id = persistence package . get custom criteria (  ) [1] ;  if  (  string utils . is blank ( page id )  )   {  return persistence package . get entity (  )  ;   }   page page = page service . find page by id (  long . value of ( page id )  )  ;   property[] properties = dynamic field util . build dynamic property list ( get field groups ( page null )   page template . class )  ;   map <  string  field metadata >  md = new  hash map <  string  field metadata >  (  )  ;  for  (   property property : properties )   {  md . put ( property . get name (  )  property . get metadata (  )  )  ;   }  boolean validated = helper . validate ( persistence package . get entity (  )  null md )  ;  if  (  ! validated )   {  throw new  validation exception ( persistence package . get entity (  )  " page dynamic fields failed validation" )  ;   }   list <  string >  template field names = new  array list <  string >  ( 20 )  ;  for  (   field group group : get field groups ( page null )  )   {  for  (   field definition def : group . get field definitions (  )  )   {  template field names . add ( def . get name (  )  )  ;   }   }   map <  string  string >  dirty fields orig vals = new  hash map <  string  string >  (  )  ;   list <  string >  dirty fields = new  array list <  string >  (  )  ;   map <  string  page field >  page field map = page . get page fields (  )  ;  for  (   property property : persistence package . get entity (  )  . get properties (  )  )   {  if  ( property . get enabled (  )  && template field names . contains ( property . get name (  )  )  )   {   page field page field = page field map . get ( property . get name (  )  )  ;  if  ( page field  !  =  null )   {  boolean is dirty =  ( page field . get value (  )   =  =  null && property . get value (  )   !  =  null )  ||  ( page field . get value (  )   !  =  null && property . get value (  )   =  =  null )  ;  if  ( is dirty ||  ( page field . get value (  )   !  =  null && property . get value (  )   !  =  null &&  ! page field . get value (  )  . trim (  )  . equals ( property . get value (  )  . trim (  )  )  )  )   {  dirty fields . add ( property . get name (  )  )  ;  dirty fields orig vals . put ( property . get name (  )  page field . get value (  )  )  ;  page field . set value ( property . get value (  )  )  ;  page field = dynamic entity dao . merge ( page field )  ;   }   }  else  {  page field = new  page field impl (  )  ;  page field . set field key ( property . get name (  )  )  ;  page field . set value ( property . get value (  )  )  ;  page field . set page ( page )  ;  dynamic entity dao . persist ( page field )  ;  dirty fields . add ( property . get name (  )  )  ;   }   }   }   list <  string >  remove items = new  array list <  string >  (  )  ;  for  (   string key : page field map . key set (  )  )   {  if  ( persistence package . get entity (  )  . find property ( key )   =  =  null )   {  remove items . add ( key )  ;   }   }  if  ( remove items . size (  )   >  0 )   {  for  (   string remove key : remove items )   {  page field map . remove ( remove key )  ;   }   }   collections . sort ( dirty fields )  ;   entity entity = fetch entity based on id ( page id dirty fields )  ;  for  (   map .  entry <  string  string >  entry : dirty fields orig vals . entry set (  )  )   {  entity . getp map (  )  . get ( entry . get key (  )  )  . set original value ( entry . get value (  )  )  ;  entity . getp map (  )  . get ( entry . get key (  )  )  . set original display value ( entry . get value (  )  )  ;   }  return entity ;   }  catch  (   validation exception e )   {  throw e ;   }  catch  (   exception e )   {  throw new  service exception ( " unable to perform update for entity: "  +  ceiling entity fully qualified classname e )  ;   }   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  return add or update ( persistence package dynamic entity dao helper )  ;   }  
protected  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   string ceiling entity fully qualified classname = persistence package . get ceiling entity fully qualified classname (  )  ;  try  {   string structured content id = persistence package . get custom criteria (  ) [1] ;   structured content structured content = structured content service . find structured content by id (  long . value of ( structured content id )  )  ;   property[] properties = dynamic field util . build dynamic property list ( structured content . get structured content type (  )  . get structured content field template (  )  . get field groups (  )   structured content type . class )  ;   map <  string  field metadata >  md = new  hash map <  string  field metadata >  (  )  ;  for  (   property property : properties )   {  md . put ( property . get name (  )  property . get metadata (  )  )  ;   }  boolean validated = helper . validate ( persistence package . get entity (  )  null md )  ;  if  (  ! validated )   {  throw new  validation exception ( persistence package . get entity (  )  " structured  content dynamic fields failed validation" )  ;   }   list <  string >  template field names = new  array list <  string >  ( 20 )  ;  for  (   field group group : structured content . get structured content type (  )  . get structured content field template (  )  . get field groups (  )  )   {  for  (   field definition def : group . get field definitions (  )  )   {  template field names . add ( def . get name (  )  )  ;   }   }   map <  string  string >  dirty fields orig vals = new  hash map <  string  string >  (  )  ;   list <  string >  dirty fields = new  array list <  string >  (  )  ;   map <  string  structured content field xref >  structured content field map = structured content . get structured content field xrefs (  )  ;  for  (   property property : persistence package . get entity (  )  . get properties (  )  )   {  if  ( property . get enabled (  )  && template field names . contains ( property . get name (  )  )  )   {   structured content field xref sc xref = structured content field map . get ( property . get name (  )  )  ;  if  ( sc xref  !  =  null && sc xref . get structured content field (  )   !  =  null )   {   structured content field structured content field = sc xref . get structured content field (  )  ;  boolean is dirty =  ( structured content field . get value (  )   =  =  null && property . get value (  )   !  =  null )  ||  ( structured content field . get value (  )   !  =  null && property . get value (  )   =  =  null )  ;  if  ( is dirty ||  ( structured content field . get value (  )   !  =  null && property . get value (  )   !  =  null &&  ! structured content field . get value (  )  . trim (  )  . equals ( property . get value (  )  . trim (  )  )  )  )   {  dirty fields . add ( property . get name (  )  )  ;  dirty fields orig vals . put ( property . get name (  )  structured content field . get value (  )  )  ;  structured content field . set value ( property . get value (  )  )  ;  sc xref = dynamic entity dao . merge ( sc xref )  ;   }   }  else  {   structured content field structured content field = new  structured content field impl (  )  ;  structured content field . set field key ( property . get name (  )  )  ;  structured content field . set value ( property . get value (  )  )  ;   structured content field xref scfx = new  structured content field xref impl (  )  ;  scfx . set structured content ( structured content )  ;  scfx . set key ( property . get name (  )  )  ;  scfx . set strucutured content field ( structured content field )  ;  scfx = dynamic entity dao . persist ( scfx )  ;  dirty fields . add ( property . get name (  )  )  ;   }   }   }   list <  string >  remove items = new  array list <  string >  (  )  ;  for  (   string key : structured content field map . key set (  )  )   {  if  ( persistence package . get entity (  )  . find property ( key )   =  =  null )   {  remove items . add ( key )  ;   }   }  if  ( remove items . size (  )   >  0 )   {  for  (   string remove key : remove items )   {  structured content field map . remove ( remove key )  ;   }   }   collections . sort ( dirty fields )  ;   entity entity = fetch entity based on id ( structured content id dirty fields )  ;  for  (   entry <  string  string >  entry : dirty fields orig vals . entry set (  )  )   {  entity . getp map (  )  . get ( entry . get key (  )  )  . set original value ( entry . get value (  )  )  ;  entity . getp map (  )  . get ( entry . get key (  )  )  . set original display value ( entry . get value (  )  )  ;   }  return entity ;   }  catch  (   validation exception e )   {  throw e ;   }  catch  (   exception e )   {  throw new  service exception ( " unable to perform fetch for entity: "  +  ceiling entity fully qualified classname e )  ;   }   }  
protected void   (  entity form ef )  {  ef . find field ( "page template" )  . set on change trigger ( "dynamic form - page template" )  ;   }  
@ override public void   (  list grid list grid  string url field )  {  list grid . get header fields (  )  . add ( new  field (  )  . with name ( "thumbnail" )  . with friendly name ( " asset   thumbnail" )  . with field type (  supported field type . st
@ override public  static asset   (  static asset asset boolean clear level1 cache )  {  if  ( clear level1 cache )   {  em . detach ( asset )  ;   }  return em . merge ( asset )  ;   }  
@ override @ transactional (  transaction utils . default   transaction   manager )  public  static asset   (  static asset static asset )  {   static asset new asset = static asset dao . add or update static asset ( static asset true )  ;  return new ass
protected void   ( final  criteria builder builder final  root page root final  list <  predicate >  restrictions  date after start date  date before end date )  {  restrictions . add ( builder . or ( builder . is null ( page root . get ( "active start date" )  )  builder . less than or equal to ( page root . get ( "active start date" )  . as (  date . class )  after start date )  )  )  ;  restrictions . add ( builder . or ( builder . is null ( page root . get ( "active end date" )  )  builder . greater than or equal to ( page root . get ( "active end date" )  . as (  date . class )  before end date )  )  )  ;   }  
protected void   ( final  criteria builder builder final  root page root final  list <  predicate >  restrictions )  {  restrictions . add ( builder . or ( builder . is null ( page root . get ( "offline flag" )  )  builder . is false ( page root . get ( "offline flag" )  )  )  )  ;   }  
@ override public  page   (  page cloned page )  {  return em . merge ( cloned page )  ;   }  
protected void   ( final  string key )  {  if  ( get page cache (  )  . get ( key )   =  =  null )   {  get uri cached date cache (  )  . put ( new  element ( key new  date (  )  )  )  ;   }   }  
protected void   (  list <  pagedto >  page list  string identifier  locale locale boolean secure )  {   string key = build key ( identifier locale secure )  ;  get page cache (  )  . put ( new  element ( key page list )  )  ;  add page map cache entry ( identifier key )  ;   }  
protected void   (  list <  page >  page list boolean secure  list <  pagedto >  dto list )  {  if  ( page list  !  =  null )   {  for  (   page page : page list )   {   pagedto pagedto = page service utility . build pagedto ( page secure )  ;  if  (  ! dto list . contains ( pagedto )  )   {  dto list . add ( pagedto )  ;   }   }   }   }  
@ suppress warnings ( "unchecked" )  protected void   (  string identifier  string key )  {   broadleaf request context context =  broadleaf request context . get broadleaf request context (  )  ;   site site = context . get non persistent site (  )  ;   
public void   (  page page boolean secure  pagedto pagedto  string field key  string original value )  {   string cms prefix = static asset path service . get static asset url prefix (  )  ;   page field pf = page . get page fields (  )  . get ( field key )  ;  if  ( original value  =  =  null )   {  original value = pf . get value (  )  ;   }   field definition fd = get field definition ( page field key )  ;  if  ( fd  !  =  null && fd . get field type (  )   =  =   supported field type . additional   foreign   key )   {  pagedto . get page fields (  )  . put ( field key foreign   lookup  +  '|'  +  fd . get additional foreign key class (  )  +  '|' +  original value )  ;   }  else if  (  string utils . is not blank ( original value )  &&  string utils . is not blank ( cms prefix )  && original value . contains ( cms prefix )  )   {   string fld value = static asset path service . convert all asset paths in content ( original value secure )  ;  pagedto . get page fields (  )  . put ( field key fld value )  ;   }  else  {  pagedto . get page fields (  )  . put ( field key original value )  ;   }   }  
@ override public void   (  site map generator configuration smgc  site map builder site map builder )  {  int row offset = 0 ;   list <  page >  pages ;   string previous url = "" ;  do  {  pages = page dao . read online and included pages ( row limit ro
@ override public  structured content   (  structured content content )  {  return em . merge ( content )  ;   }  
protected void   (  string key  structured contentdto scdto )  {  get structured content cache (  )  . put ( new  element ( key scdto )  )  ;   }  
@ override public void   (  string key  list <  structured contentdto >  scdto list )  {  get structured content cache (  )  . put ( new  element ( key scdto list )  )  ;   }  
@ override public  extension result status type   (  string tag name  map <  string  string >  tag attributes  map <  string  object >  new model vars  broadleaf template context context )  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   (  list <  deep link >  links  string tag name  map <  string  string >  tag attributes  broadleaf template context context )  {  return  extension result status type . not   handled ;   }  
protected void   (  class tree tree  list <  class tree >  list )  {  if  (  ! tree . is exclude from polymorphism (  )  )   {  list . add ( tree )  ;   }  for  (   class tree child : tree . get children (  )  )   {  add children ( child list )  ;   }   }  
public void   (  filter and sort criteria criteria )  {  criteria map . put ( criteria . get property id (  )  criteria )  ;   }  
public void   (  collection <  filter and sort criteria >  criterias )  {  for  (   filter and sort criteria fasc : criterias )   {  add ( fasc )  ;   }   }  
public void   (  string error or error key )  {  set validation failure ( true )  ;  global validation errors . add ( error or error key )  ;   }  
public void   (  list <  string >  error or error keys )  {  set validation failure ( true )  ;  global validation errors . add all ( error or error keys )  ;   }  
public void   (  property property )  {  boolean exists = find property ( property . get name (  )  )   !  =  null ;   property[] all props = get properties (  )  ;   property[] new props = new  property[exists  ?  all props . length : all props . length  +  1] ;  int count = 0 ;  for  ( int j = 0 ;  j  <  all props . length ;  j +  +  )   {  if  (  ! all props[j] . get name (  )  . equals ( property . get name (  )  )  )   {  new props[count] = all props[j] ;  count +  +  ;   }   }  new props[new props . length  -  1] = property ;  set properties ( new props )  ;   }  
public void   (  string field name  string error or error key )  {   map <  string  list <  string >  >  field errors = get property validation errors (  )  ;   list <  string >  error messages = field errors . get ( field name )  ;  if  ( error messages  =  =  null )   {  error messages = new  array list <  string >  (  )  ;  field errors . put ( field name error messages )  ;   }  error messages . add ( error or error key )  ;  set validation failure ( true )  ;   }  
public void   (  string value )  {  filter values . add ( value )  ;   }  
public void   (  string criteria )  {  custom criteria =  array utils . add ( custom criteria criteria )  ;   }  
public void   (  change type change type  persistence package persistence package )  {   list <  persistence package >  changes ;  if  (  ! deferred operations . contains key ( change type )  )   {  changes = new  array list <  persistence package >  (  )  ;  deferred operations . put ( change type changes )  ;   }  else  {  changes = deferred operations . get ( change type )  ;   }  changes . add ( persistence package )  ;   }  
public void   (  persistence perspective item type type  persistence perspective item item )  {  persistence perspective items . put ( type item )  ;   }  
protected void   (  string field name  string message  map <  string  list <  string >  >  tab errors )  {   list <  string >  messages = tab errors . get ( field name )  ;  if  ( messages  =  =  null )   {  messages = new  array list <  >  (  )  ;  tab errors . put ( field name messages )  ;   }  messages . add ( message )  ;   }  
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for type metadata ( add metadata from field type reques
protected void   (  class <  ?  >  clazz  class tree tree )  {   class <  ?  >  test class ;  try  {  test class =  class . for name ( tree . get fully qualified classname (  )  )  ;   }  catch  (   class not found exception e )   {  throw new  runtime exception ( e )  ;   }  if  ( clazz . equals ( test class )  )   {  return ;   }  if  ( clazz . get superclass (  )  . equals ( test class )  )   {   class tree my tree = new  class tree ( clazz . get name (  )  is exclude class from polymorphism ( clazz )  )  ;  create class tree from annotation ( clazz my tree )  ;  tree . set children (  array utils . add ( tree . get children (  )  my tree )  )  ;   }  else  {  for  (   class tree child : tree . get children (  )  )   {  add class to tree ( clazz child )  ;   }   }   }  
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for configured metadata ( add metadata request metadata )  )   {  return  metadat
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for type metadata ( add metadata from field type reques
@ override public  metadata provider response   (  add metadata request add metadata request  map <  string  tab metadata >  metadata )  {   admin presentation class annot =  annotation utils . find annotation ( add metadata request . get target class (  
@ override public  metadata provider response   (  class metadata cmd  map <  string  tab metadata >  metadata )  {  for  (   property p : cmd . get properties (  )  )   {   field metadata fmd = p . get metadata (  )  ;  boolean is excluded = fmd . get ex
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for configured metadata ( add metadata request metadata )  )   {  return  metadat
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for configured metadata ( add metadata request metadata )  )   {  return  metadat
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {   map <  string  object >  id metadata = add metadata request . get dynamic entity dao (  )  . get id metada
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  ( add metadata from field type request . get presentation attribute (  )   ! 
@ override public  metadata provider response   (  add metadata from mapping data request add metadata from mapping data request  field metadata metadata )  {   basic field metadata field metadata =  (  basic field metadata ) metadata ;  field metadata . 
@ override public  metadata provider response   (  add metadata from mapping data request add metadata from mapping data request  tab metadata metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata request add metadata request  map <  string  tab metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  class metadata cmd  map <  string  tab metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add field metadata request add field metadata request  map <  string  field metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata from mapping data request add metadata from mapping data request  field metadata metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for configured metadata ( add metadata request metadata )  )   {  return  metadat
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for type metadata ( add metadata from field type reques
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  ( add metadata from field type request . get presentation attribute (  )  ins
@ override public  metadata provider response   (  add metadata from mapping data request add metadata from mapping data request  field metadata metadata )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add field metadata request add metadata request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for configured metadata ( add metadata request metadata )  )   {  return  metadat
@ override public  metadata provider response   (  add metadata from field type request add metadata from field type request  map <  string  field metadata >  metadata )  {  if  (  ! can handle field for type metadata ( add metadata from field type reques
public   (  field requested field  class <  ?  >  parent class  class <  ?  >  target class  dynamic entity dao dynamic entity dao  string prefix )  {  super ( parent class target class dynamic entity dao prefix )  ;  this . requested field = requested field ;   }  
public   (  field requested field  class <  ?  >  target class  foreign key foreign field  foreign key[] additional foreign fields  merged property type merged property type  list <  property >  component properties  string id property  string prefix  string requested property name  type type boolean property foreign key int additional foreign key index position  map <  string  field metadata >  presentation attributes  field metadata presentation attribute  supported field type explicit type  class <  ?  >  returned class  dynamic entity dao dynamic entity dao )  {  this . requested field = requested field ;  this . target class = target class ;  this . foreign field = foreign field ;  this . additional foreign fields = additional foreign fields ;  this . merged property type = merged property type ;  this . component properties = component properties ;  this . id property = id property ;  this . prefix = prefix ;  this . requested property name = requested property name ;  this . type = type ;  this . property foreign key = property foreign key ;  this . additional foreign key index position = additional foreign key index position ;  this . presentation attributes = presentation attributes ;  this . presentation attribute = presentation attribute ;  this . explicit type = explicit type ;  this . returned class = returned class ;  this . dynamic entity dao = dynamic entity dao ;   }  
public   (  class <  ?  >  parent class  class <  ?  >  target class  dynamic entity dao dynamic entity dao  string prefix )  {  this . parent class = parent class ;  this . target class = target class ;  this . dynamic entity dao = dynamic entity dao ;  this . prefix = prefix ;   }  
public  persistence package request   (  foreign key foreign key )  {  additional foreign keys . add ( foreign key )  ;  return this ;   }  
public  persistence package request   (  string[] custom criteria list )  {  if  ( custom criteria list  !  =  null && custom criteria list . length  >  0 )   {  if  ( this . custom criteria  =  =  null )   {  this . custom criteria = new  array list <  >  (  arrays . as list ( custom criteria list )  )  ;   }  else  {  this . custom criteria . add all ( new  array list <  >  (  arrays . as list ( custom criteria list )  )  )  ;   }   }  return this ;   }  
public  persistence package request   (  list <  filter and sort criteria >  filter and sort criteria )  {  this . filter and sort criteria . add all ( filter and sort criteria )  ;  return this ;   }  
public  persistence package request   (  string info property name  persistence package request sub request )  {  sub requests . put ( info property name sub request )  ;  return this ;   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  if  ( persistence package . get entity (  )  . find property ( "id" )   !  =  null &&  !  
protected void   (  criteria transfer object cto )  {  boolean user sort = false ;  for  (   filter and sort criteria fasc : cto . get criteria map (  )  . values (  )  )   {  if  ( fasc . get sort direction (  )   !  =  null )   {  user sort = true ;  break ;   }   }  if  (  ! user sort )   {   filter and sort criteria description sort = cto . get criteria map (  )  . get ( "description" )  ;  if  ( description sort  =  =  null )   {  description sort = new  filter and sort criteria ( "description" )  ;  cto . add ( description sort )  ;   }  description sort . set sort ascending ( true )  ;   }   }  
protected void   (  criteria transfer object cto )  {  cto . add ( new  filter and sort criteria ( "is friendly" "true" cto . get criteria map (  )  . size (  )  )  )  ;   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  admin remote security service . security check ( persistence package  entity operation typ
@ override public void   (  list <  simple granted authority >  granted authorities  collection <  admin permission >  admin permissions )  {  for  (   admin permission permission : admin permissions )   {  granted authorities . add ( new  simple granted 
@ override public void   (  admin user current user  string ceiling entity  list <  predicate >  restrictions  list <  order >  sorts  root entity root  criteria query criteria  criteria builder criteria builder )  {  for  (   row level security provider 
@ override public  persistence response   (  persistence package request request boolean transactional )  throws  service exception  {   persistence package pkg = persistence package factory . create ( request )  ;  try  {  if  ( request . is update looku
@ override public  persistence response   (  entity form entity form  string[] custom criteria  list <  section crumb >  section crumb )  throws  service exception  {   persistence package request ppr = get request for entity form ( entity form custom cri
@ override public  persistence response   (  entity form entity form  class metadata main metadata  property field  entity parent entity  list <  section crumb >  section crumbs )  throws  service exception   class not found exception  {   list <  propert
@ override public  persistence response   ( final  persistence package persistence package )  throws  service exception  {  final  persistence response[] response = new  persistence response[1] ;  try  {   platform transaction manager transaction manager 
@ override public  extension result status type   (  array list <  string >  custom criteria  string section class name )  {  return  extension result status type . not   handled ;   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {  throw new  service exception ( " add not supported" )  ;   }  
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
@ override public  entity   (  persistence package persistence package  dynamic entity dao dynamic entity dao  record helper helper )  throws  service exception  {   entity entity = persistence package . get entity (  )  ;  try  {   persistence perspectiv
@ override public  entity   (  persistence package persistence package )  throws  service exception  {   string[] custom criteria = persistence package . get custom criteria (  )  ;  if  ( custom criteria  !  =  null && custom criteria . length  >  0 )   
@ override public  entity result   (  persistence package persistence package boolean include real entity object )  throws  service exception  {   entity result entity result = new  entity result (  )  ;   entity entity = persistence package . get entity 
protected void   (  query response  integer first result  integer max results )  {  if  ( first result  !  =  null )   {  response . set first result ( first result )  ;   }  if  ( max results  !  =  null )   {  response . set max results ( max results )  ;   }   }  
protected void   (  string ceiling entity  list <  filter mapping >  filter mappings  criteria builder criteria builder  root original  list <  predicate >  restrictions  list <  order >  sorts  criteria query criteria )  {   collections . sort ( filter mappings new  filter mapping .  comparator by order (  )  )  ;  for  (   filter mapping filter mapping : filter mappings )   {   path explicit path = null ;  if  ( filter mapping . get field path (  )   !  =  null )   {  explicit path = filter mapping . get restriction (  )  . get field path builder (  )  . get path ( original filter mapping . get field path (  )  criteria builder )  ;   }  if  ( filter mapping . get restriction (  )   !  =  null )   {   list direct values = null ;  boolean should convert = true ;  if  (  collection utils . is not empty ( filter mapping . get filter values (  )  )  )   {  direct values = filter mapping . get filter values (  )  ;   }  else if  (  collection utils . is not empty ( filter mapping . get direct filter values (  )  )  ||  ( filter mapping . get direct filter values (  )   !  =  null && filter mapping . get direct filter values (  )  instanceof  empty filter values )  )   {  direct values = filter mapping . get direct filter values (  )  ;  should convert = false ;   }  if  ( direct values  !  =  null )   {   predicate predicate = filter mapping . get restriction (  )  . build restriction ( criteria builder original ceiling entity filter mapping . get full property name (  )  explicit path direct values should convert criteria restrictions )  ;  if  ( predicate  !  =  null )   {  restrictions . add ( predicate )  ;   }   }   }  if  ( filter mapping . get sort direction (  )   !  =  null )   {   path sort path = explicit path ;  if  ( sort path  =  =  null &&  !  string utils . is empty ( filter mapping . get full property name (  )  )  )   {   field path builder field path builder = filter mapping . get restriction (  )  . get field path builder (  )  ;  field path builder . set criteria ( criteria )  ;  field path builder . set restrictions ( restrictions )  ;  sort path = filter mapping . get restriction (  )  . get field path builder (  )  . get path ( original filter mapping . get full property name (  )  criteria builder )  ;   }  if  ( sort path  !  =  null )   {  add sorting ( criteria builder sorts filter mapping sort path )  ;   }   }   }  row security service . add fetch restrictions ( admin security service . get persistent admin user (  )  ceiling entity restrictions sorts original criteria criteria builder )  ;  for  (   criteria translator event handler event handler : event handlers )   {  event handler . add restrictions ( ceiling entity filter mappings criteria builder original restrictions sorts criteria )  ;   }   }  
protected void   (  criteria builder criteria builder  list <  order >  sorts  filter mapping filter mapping  path path )  {   expression exp = path ;  if  ( filter mapping . get nulls last (  )   !  =  null && filter mapping . get nulls last (  )  )   {   object large value = get appropriate large sorting value ( path . get java type (  )  )  ;  if  ( large value  !  =  null )   {  exp = criteria builder . coalesce ( path large value )  ;   }   }  if  (  sort direction . ascending  =  =  filter mapping . get sort direction (  )  )   {  sorts . add ( criteria builder . asc ( exp )  )  ;   }  else  {  sorts . add ( criteria builder . desc ( exp )  )  ;   }   }  
@ override public  entity   (  persistence package persistence package )  throws  service exception  {   string[] custom criteria = persistence package . get custom criteria (  )  ;  if  ( custom criteria  !  =  null && custom criteria . length  >  0 )   
@ override public  metadata provider response   (  add search mapping request add search mapping request  list <  filter mapping >  filter mappings )  {  if  (  ! can handle search mapping ( add search mapping request filter mappings )  )   {  return  met
@ override public  metadata provider response   (  add search mapping request add search mapping request  list <  filter mapping >  filter mappings )  {  return  metadata provider response . not   handled ;   }  
@ override public  metadata provider response   (  add search mapping request add search mapping request  list <  filter mapping >  filter mappings )  {  return  metadata provider response . not   handled ;   }  
public   (  entity entity )  {  this . entity = entity ;   }  
public   (  persistence perspective persistence perspective  criteria transfer object requested cto  string ceiling entity fully qualified classname  map <  string  field metadata >  merged properties  string property name  field manager field manager  data format provider data format provider  record helper record helper  restriction factory restriction factory )  {  this . persistence perspective = persistence perspective ;  this . requested cto = requested cto ;  this . ceiling entity fully qualified classname = ceiling entity fully qualified classname ;  this . merged properties = merged properties ;  this . property name = property name ;  this . field manager = field manager ;  this . data format provider = data format provider ;  this . record helper = record helper ;  this . restriction factory = restriction factory ;   }  
public void   (  persistence manager persistence manager )  {  this . persistence manager . add ( persistence manager )  ;   }  
public static void   (  persistence manager context persistence manager context )  {  broadleaf   persistence   manager   context . set ( persistence manager context )  ;   }  
@ override public  persistence response   (  persistence package persistence package )  throws  service exception  {  for  (   persistence manager event handler handler : persistence manager event handlers )   {   persistence manager event handler respons
public void   (  string error message or key )  {  error messages . add ( error message or key )  ;   }  
@ override public  extension result status type   (  string section class name  list <  entity form action >  actions )  {  return  extension result status type . not   handled ;   }  
@ request mapping ( value = " / add" method =  request method . post )  public  string   (  http servlet request request  http servlet response response  model model @ model attribute ( value = "entity form" )   entity form entity form  binding result res
protected void   (  string section class name  class metadata cmd  list <  entity form action >  main actions )  {  if  ( is add action allowed ( section class name cmd )  )   {  main actions . add (  default main actions . add )  ;   }   }  
private void   (  entity form entity form  field user field )  {   field display field = build auditable display field ( user field )  ;   admin user user = admin user dao . read admin user by id (  long . parse long ( user field . get value (  )  )  )  ;   string user name = user  =  =  null  ?  null : user . get name (  )  ;  display field . set value ( user name )  ;   field group audit group = entity form . find group ( " admin auditable    audit" )  ;  if  ( audit group  !  =  null )   {  audit group . add field ( display field )  ;   }   }  
public void   (  entity form entity form )  {   field created by = entity form . find field ( "auditable . created by" )  ;  if  ( created by  !  =  null && created by . get value (  )   !  =  null )   {  add auditable display field ( entity form created by )  ;  created by . set is visible ( false )  ;   }   field updated by = entity form . find field ( "auditable . updated by" )  ;  if  ( updated by  !  =  null && updated by . get value (  )   !  =  null )   {  add auditable display field ( entity form updated by )  ;  updated by . set is visible ( false )  ;   }   }  
@ request mapping ( value = " /  { id }  /  { collection field: . * }  / add" method =  request method . post )  public  string   (  http servlet request request  http servlet response response  model model @ path variable  map <  string  string >  path v
@ request mapping ( value = " /  { id }  /  { collection field: . * }  / add empty" method =  request method . post )  public @ response body  string   (  http servlet request request  http servlet response response  model model @ path variable  map <  st
@ request mapping ( value = " / add" method =  request method . post )  public  string   (  http servlet request request  http servlet response response  model model @ path variable  map <  string  string >  path vars @ model attribute ( value = "entity f
@ request mapping ( value = " /  { id }  /  { collection field: . * }  / selectize - add" method =  request method . post )  public @ response body  map <  string  object >    (  http servlet request request  http servlet response response  model model @ 
public void   (  list grid action action )  {  get modal row actions (  )  . add ( action )  ;   }  
public void   (  list grid action action )  {  get row actions (  )  . add ( action )  ;   }  
public void   (  list grid action group action group )  {  get row action groups (  )  . add ( action group )  ;   }  
public void   (  list grid action action )  {  get toolbar actions (  )  . add ( action )  ;   }  
public void   (  list grid action group action group )  {  get toolbar action groups (  )  . add ( action group )  ;   }  
public void   (  list grid action action )  {  get list grid actions (  )  . add ( action )  ;   }  
public void   (  entity form action action )  {  actions . add ( action )  ;   }  
public void   (  class metadata cmd  field field  string group name  integer group order  string tab name  integer tab order )  {   tab first tab = tabs . is empty (  )   ?  null : tabs . first (  )  ;   field group first group = first tab  =  =  null || first tab . get field groups (  )  . is empty (  )   ?  null :  (  (  tree set <  field group >  ) first tab . get field groups (  )  )  . first (  )  ;  tab name = tab name  =  =  null  ?   ( first tab  =  =  null || first tab . get key (  )   =  =  null  ?  default   tab   name : first tab . get key (  )  )  : tab name ;  tab order = tab order  =  =  null  ?   ( first tab  =  =  null || first tab . get order (  )   =  =  null  ?  default   tab   order : first tab . get order (  )  )  : tab order ;  group name = group name  =  =  null  ?   ( first group  =  =  null || first group . get key (  )   =  =  null  ?  default   group   name : first group . get key (  )  )  : group name ;  group order = group order  =  =  null  ?   ( first group  =  =  null || first group . get order (  )   =  =  null  ?  default   group   order : first group . get order (  )  )  : group order ;  boolean group found = false ;   map <  string  tab metadata >  tab metadata map = cmd . get tab and group metadata (  )  ;  if  ( tab metadata map  !  =  null )   {  for  (   string tab key : tab metadata map . key set (  )  )   {   map <  string  group metadata >  group metadata map = tab metadata map . get ( tab key )  . get group metadata (  )  ;  for  (   string group key : group metadata map . key set (  )  )   {  if  ( group key . equals ( group name )  || group metadata map . get ( group key )  . get group name (  )  . equals ( group name )  )   {  group name = group metadata map . get ( group key )  . get group name (  )  ;  group found = true ;  break ;   }   }  if  ( group found )   {  break ;   }  if  (  ( tab key . equals ( tab name )  )  ||  ( tab metadata map . get ( tab key )  . get tab name (  )   !  =  null && tab metadata map . get ( tab key )  . get tab name (  )  . equals ( tab name )  )  )   {  tab name = tab metadata map . get ( tab key )  . get tab name (  )  ;   }   }   }   field group field group = find group ( group name )  ;  if  ( field group  =  =  null )   {   tab tab = find tab ( tab name )  ;  if  ( tab  =  =  null )   {  tab = new  tab (  )  ;  tab . set key ( tab name )  ;  tab . set title ( blc message utils . get message ( tab name )  )  ;  tab . set order ( tab order )  ;  tabs . add ( tab )  ;   }  field group = new  field group (  )  ;  field group . set key ( group name )  ;  field group . set title ( blc message utils . get message ( group name )  )  ;  field group . set order ( group order )  ;  tab . get field groups (  )  . add ( field group )  ;   }  field group . add field ( field )  ;  if  ( fields  !  =  null )   {  fields . put ( field . get name (  )  field )  ;   }   }  
public void   (  group metadata group metadata  string unprocessed tab name )  {   field group new group = new  field group (  )  ;  new group . set key ( group metadata . get group name (  )  )  ;  new group . set title ( blc message utils . get message ( group metadata . get group name (  )  )  )  ;  new group . set order ( group metadata . get group order (  )  )  ;  new group . set column ( group metadata . get column (  )  )  ;  new group . set is untitled ( group metadata . get untitled (  )  )  ;  new group . set tool tip ( group metadata . get tooltip (  )  )  ;  new group . set collapsed ( group metadata . get collapsed (  )  )  ;  new group . set tool tip ( group metadata . get tooltip (  )  )  ;   tab tab = find tab ( unprocessed tab name )  ;  if  ( group metadata . get column (  )   !  =  default   column )   {  tab . set is multi column ( true )  ;   }  tab . get field groups (  )  . add ( new group )  ;   }  
public void   (  class metadata cmd  field field )  {  if  (  string utils . is blank ( field . get field type (  )  )  )   {  field . set field type (  supported field type . hidden . to string (  )  )  ;   }  add field ( cmd field hidden   group default   group   order default   tab   name default   tab   order )  ;   }  
public void   (  class metadata cmd  list grid list grid  string tab name  integer tab order  string group name boolean is tab present )  {  tab name = tab name  =  =  null  ?  default   tab   name : tab name ;  tab order = tab order  =  =  null  ?  default   tab   order : tab order ;  boolean group found = false ;   map <  string  tab metadata >  tab metadata map = cmd . get tab and group metadata (  )  ;  for  (   string tab key : tab metadata map . key set (  )  )   {   map <  string  group metadata >  group metadata map = tab metadata map . get ( tab key )  . get group metadata (  )  ;  for  (   string group key : group metadata map . key set (  )  )   {  if  ( group key . equals ( group name )  || group metadata map . get ( group key )  . get group name (  )  . equals ( group name )  )   {  group name = group metadata map . get ( group key )  . get group name (  )  ;  group found = true ;  break ;   }   }  if  ( group found )   {  break ;   }  if  ( tab key . equals ( tab name )  || tab metadata map . get ( tab key )  . get tab name (  )  . equals ( tab name )  )   {  tab name = tab metadata map . get ( tab key )  . get tab name (  )  ;   }   }   field group field group = find group ( group name )  ;   tab tab = find tab ( tab name )  ;  if  ( field group  !  =  null )   {  field group . add list grid ( list grid )  ;   }  else if  ( field group  =  =  null && tab  !  =  null )   {  tab . get list grids (  )  . add ( list grid )  ;   }  else  {  tab = new  tab (  )  ;  tab . set key ( tab name )  ;  tab . set title ( blc message utils . get message ( tab name )  )  ;  tab . set order ( tab order )  ;  tab . set tabs present ( is tab present )  ;  tabs . add ( tab )  ;  tab . get list grids (  )  . add ( list grid )  ;   }   }  
public void   (  class metadata cmd  field field )  {  add field ( cmd field map   key   group 0 default   tab   name default   tab   order )  ;   }  
public  string   (  tab metadata tab metadata )  {   tab new tab = new  tab (  )  ;  new tab . set key ( tab metadata . get tab name (  )  )  ;  if  ( tab metadata . get tab name (  )   !  =  null )   {  new tab . set title ( blc message utils . get message ( tab metadata . get tab name (  )  )  )  ;   }  new tab . set order ( tab metadata . get tab order (  )  )  ;  tabs . add ( new tab )  ;  return new tab . get key (  )  ;   }  
public boolean   (  field field )  {  if  ( field . get alternate ordering (  )  )   {  return alternate ordered group items . add ( new  field group item ( field )  )  ;   }  else  {  return group items . add ( new  field group item ( field )  )  ;   }   }  
public void   (  set <  field >  fields )  {  for  (   field field : fields )   {  add field ( field )  ;   }   }  
public void   (  list grid list grid )  {  group items . add ( new  field group item ( list grid )  )  ;   }  
@ override public  extension result status type   (  list <  field data >  fields  string name  string dto class name )  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   (  entity form entity form )  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   (  entity form entity form )  {  return  extension result status type . not   handled ;   }  
protected void   (  entity form entity form  class metadata cmd  entity entity )  {  boolean can delete = true ;  try  {   string security entity classname = get security classname ( entity form cmd )  ;  admin remote security service . security check ( security entity classname  entity operation type . remove )  ;   }  catch  (   service exception e )   {  if  ( e instanceof  security service exception )   {  can delete = false ;   }   }  if  ( can delete )   {  can delete = row level security service . can update ( admin remote security service . get persistent admin user (  )  entity )  ;   }  if  ( can delete )   {  can delete = row level security service . can remove ( admin remote security service . get persistent admin user (  )  entity )  ;   }  if  ( can delete )   {  entity form . add action (  default entity form actions . delete )  ;   }   }  
@ override public void   (  string cache region  string cache name  serializable element key  string element item name  object element value )  {   string heap key = cache region  +  '   '  +  cache name +  '   ' +  element item name +  '   ' +  element k
public void   (  string cache region  string cache name  serializable key  object value )  {   string my key = cache region  +  "   "  +  cache name +  "   " +  key ;  put ( my key value )  ;   }  
@ override public void   (  string cache region  string cache name  serializable element key  string element item name  object element value )  {   string heap key = cache region  +  '   '  +  cache name +  '   ' +  element item name +  '   ' +  element k
public void   ( final  hydrated cache cache )  {  hydrated cache container . put ( cache . get cache region (  )   +  "   "  +  cache . get cache name (  )  cache )  ;   }  
public void   (  string cache region  string cache name  serializable element key  string element item name  object element value )  {   hydrated cache hydrated cache = get hydrated cache ( cache region cache name )  ;   hydrated cache element element = hydrated cache . get cache element ( cache region cache name element key )  ;  if  ( element  =  =  null )   {  element = new  hydrated cache element (  )  ;  hydrated cache . add cache element ( cache region cache name element key element )  ;   }  element . put cache element item ( element item name element key element value )  ;   }  
public static void   (  string cache region  string cache name  serializable element key  string element item name  object element value )  {   hydrated cache manager manager =  hydrated cache event listener factory . get configured manager (  )  ;  manager . add hydrated cache element item ( cache region cache name element key element item name element value )  ;   }  
@ override public void   (  string key boolean is hit )  {   cache stat my stat = get cache stat ( key )  ;  if  ( is hit )   {  my stat . increment hit (  )  ;   }  my stat . increment request (  )  ;  if  ( my stat . get last log time (  )   +  log reso
public static void   (  thread local thread local )  {   long position ;  synchronized  ( thread lock )   {  count +  +  ;  position = count ;   }  thread   local   manager . get (  )  . thread locals . put ( position thread local )  ;   }  
protected void   (  configurable environment environment  list <  resource >  resources  string composite source name  string add before source name )  {  try  {  for  (   resource resource : resources )   {  if  (  ! resource . exists (  )  )   {  log . debug ( resource . get description (  )   +  " does not exist  skipping adding to the  environment" )  ;  continue ;   }   property source <  ?  >  props = new  resource property source ( resource )  ;   composite property source composite source =  (  composite property source ) environment . get property sources (  )  . get ( composite source name )  ;  if  ( composite source  =  =  null )   {  composite source = new  composite property source ( composite source name )  ;  if  ( add before source name  =  =  null )   {  environment . get property sources (  )  . add last ( composite source )  ;   }  else  {  environment . get property sources (  )  . add before ( add before source name composite source )  ;   }  log . debug ( " added new composite property source source "  +  composite source . get name (  )   +  " to the environment" )  ;   }  composite source . add first property source ( props )  ;  log . debug (  string . format ( " added property source %s at the beginning of the composite source " props . get name (  )  composite source . get name (  )  )  )  ;   }   }  catch  (  io exception e )   {  throw new  runtime exception ( e )  ;   }   }  
protected void   (  string property name  string property value )  {   string key = build key ( property name )  ;  if  ( system property cache timeout  <  0 )   {  get system property cache (  )  . put ( new  element ( key property value )  )  ;   }  else  {  get system property cache (  )  . put ( new  element ( key property value system property cache timeout system property cache timeout )  )  ;   }   }  
public void   (  deferred operation operation )  {  deferred operations . add ( operation )  ;   }  
public void   (  list <  deferred operation >  operations )  {  deferred operations . add all ( operations )  ;   }  
protected void   (  object bean  object source item  placement placement int position )  throws  no such field exception   illegal access exception  {   list target list ;  if  ( bean instanceof  list factory bean )   {   field field =  list factory bean . class . get declared field ( "source list" )  ;  field . set accessible ( true )  ;  target list =  (  list ) field . get ( bean )  ;   }  else  {  target list =  (  list ) bean ;   }  switch  ( placement )   {  case append: target list . add ( source item )  ;  break ;  case prepend: target list . add ( 0 source item )  ;  break ;  case specific: target list . add ( position source item )  ;  break ;   }   }  
protected void   (  object bean  object source item  placement placement int position )  throws  no such field exception   illegal access exception  {   set target set ;  if  ( bean instanceof  set factory bean )   {   field field =  set factory bean . class . get declared field ( "source set" )  ;  field . set accessible ( true )  ;  target set =  (  set ) field . get ( bean )  ;   }  else  {  target set =  (  set ) bean ;   }   list temp list = new  array list ( target set )  ;  switch  ( placement )   {  case append: temp list . add ( source item )  ;  break ;  case prepend: temp list . add ( 0 source item )  ;  break ;  case specific: temp list . add ( position source item )  ;  break ;   }  target set . clear (  )  ;  target set . add all ( temp list )  ;   }  
protected void   (  object bean  object source item  placement placement int position )  throws  no such field exception   illegal access exception  {   list source list =  (  list ) source item ;   list target list ;  if  ( bean instanceof  list factory bean )   {   field field =  list factory bean . class . get declared field ( "source list" )  ;  field . set accessible ( true )  ;  target list =  (  list ) field . get ( bean )  ;   }  else  {  target list =  (  list ) bean ;   }  switch  ( placement )   {  case append: target list . add all ( source list )  ;  break ;  case prepend: target list . add all ( 0 source list )  ;  break ;  case specific: target list . add all ( position source list )  ;  break ;   }   }  
protected void   (  object bean  map source item  placement placement int position )  throws  no such field exception   illegal access exception  {   map sourcer map = source item ;   map target map ;  if  ( bean instanceof  map factory bean )   {   field field =  map factory bean . class . get declared field ( "source map" )  ;  field . set accessible ( true )  ;  target map =  (  map ) field . get ( bean )  ;   }  else  {  target map =  (  map ) bean ;   }   linked hash map temp map = new  linked hash map (  )  ;  switch  ( placement )   {  case append: temp map . put all ( target map )  ;  temp map . put all ( sourcer map )  ;  break ;  case prepend: temp map . put all ( sourcer map )  ;  temp map . put all ( target map )  ;  break ;  case specific: boolean added = false ;  int j = 0 ;  for  (  object key : target map . key set (  )  )   {  if  ( j  =  =  position )   {  temp map . put all ( sourcer map )  ;  added = true ;   }  temp map . put ( key target map . get ( key )  )  ;  j +  +  ;   }  if  (  ! added )   {  temp map . put all ( sourcer map )  ;   }  break ;   }  target map . clear (  )  ;  target map . put all ( temp map )  ;   }  
protected void   (  object bean  object source item  placement placement int position )  throws  no such field exception   illegal access exception  {   set source set =  (  set ) source item ;   set target set ;  if  ( bean instanceof  set factory bean )   {   field field =  set factory bean . class . get declared field ( "source set" )  ;  field . set accessible ( true )  ;  target set =  (  set ) field . get ( bean )  ;   }  else  {  target set =  (  set ) bean ;   }   list temp list = new  array list ( target set )  ;  switch  ( placement )   {  case append: temp list . add all ( source set )  ;  break ;  case prepend: temp list . add all ( 0 source set )  ;  break ;  case specific: temp list . add all ( position source set )  ;  break ;   }  target set . clear (  )  ;  target set . add all ( temp list )  ;   }  
@ override public void   ( int index  resource input stream resource input stream )  {  byte[] source array ;  try  {  source array = build array from stream ( resource input stream )  ;   }  catch  (  io exception e )   {  throw new  runtime exception ( 
@ override public boolean   (  collection <  ?  extends  resource input stream >  c )  {  for  (   resource input stream ris : c )   {  if  (  ! add ( ris )  )   {  return false ;   }   }  return true ;   }  
public void   (  resource input stream ris )  {  if  ( embedded insert position  =  =  size (  )  )   {  add ( ris )  ;   }  else  {  add ( embedded insert position ris )  ;   }  embedded insert position +  +  ;   }  
public  direct copy class transformer   (  string class to transform  string contributing class )  {  xform templates . put ( class to transform contributing class )  ;  return this ;   }  
public orm config dto   (  string class name )  {  this . class names . add ( class name )  ;  return this ;   }  
public orm config dto   (  string mapping file )  {  this . mapping files . add ( mapping file )  ;  return this ;   }  
protected boolean   ( boolean weaver registered )  throws  exception  {  for  (   persistence unit info pui : merged pus . values (  )  )   {   list <  named query >  named queries = new  array list <  >  (  )  ;   list <  named native query >  native queries = new  array list <  >  (  )  ;  for  (   query configuration config : query configurations )   {  if  ( pui . get persistence unit name (  )  . equals ( config . get persistence unit (  )  )  )   {   named queries annotation = config . get class (  )  . get annotation (  named queries . class )  ;  if  ( annotation  !  =  null )   {  named queries . add all (  arrays . as list ( annotation . value (  )  )  )  ;   }   named native queries annotation2 = config . get class (  )  . get annotation (  named native queries . class )  ;  if  ( annotation2  !  =  null )   {  native queries . add all (  arrays . as list ( annotation2 . value (  )  )  )  ;   }   }   }  if  (  ! named queries . is empty (  )  ||  ! native queries . is empty (  )  )   {   query configuration class transformer transformer = new  query configuration class transformer ( named queries native queries pui . get managed class names (  )  )  ;  try  {  pui . add transformer ( transformer )  ;   }  catch  (   exception e )   {  weaver registered = handle class transformer registration problem ( transformer e )  ;   }   }   }  return weaver registered ;   }  
protected boolean   (  )  throws  exception  {  boolean weaver registered = true ;  for  (   persistence unit info pui : merged pus . values (  )  )   {  if  ( pui . get properties (  )  . contains key (  available settings . use   class   enhancer )  && "true" . equals ignore case ( pui . get properties (  )  . get property (  available settings . use   class   enhancer )  )  )   {  pui . add transformer ( new  intercept field class file transformer ( pui . get managed class names (  )  )  )  ;   }  for  (   broadleaf class transformer transformer : class transformers )   {  try  {  boolean is transformer qualified =  !  ( transformer instanceof  null class transformer )  &&  ( pui . get persistence unit name (  )  . equals ( "blpu" )  &&  !  ( transformer instanceof  broadleaf persistence unit declaring class transformer )  )  ||  (  ( transformer instanceof  broadleaf persistence unit declaring class transformer )  && pui . get persistence unit name (  )  . equals (  (  (  broadleaf persistence unit declaring class transformer ) transformer )  . get persistence unit name (  )  )  )  ;  if  ( is transformer qualified )   {  pui . add transformer ( transformer )  ;   }   }  catch  (   exception e )   {  weaver registered = handle class transformer registration problem ( transformer e )  ;   }   }   }  weaver registered = add named queries to persistence units ( weaver registered )  ;  return weaver registered ;   }  
@ override public void   (  file work area work area  file file boolean remove files from work area )  {  add or update resources for paths ( work area remove files from work area )  ;   }  
@ override public  string   (  file work area work area  file file boolean remove files from work area )  {   list <  file >  files = new  array list <  file >  (  )  ;  files . add ( file )  ;  return add or update resources for paths ( work area files r
@ override public void   (  file work area work area  list <  file >  files boolean remove files from work area )  {  add or update resources for paths ( work area files remove files from work area )  ;   }  
@ override public  list <  string >    (  file work area work area  list <  file >  files boolean remove files from work area )  {  check files ( work area files )  ;  return select file service provider (  )  . add or update resources for paths ( work ar
@ deprecated public static  string   (  string file name )  {  return add leading unix slash ( file name )  ;   }  
public static  string   (  string file name )  {  if  ( file name . starts with ( " / " )  )   {  return file name ;   }  return " / "  +  file name ;   }  
@ override @ deprecated public void   (  file work area work area  list <  file >  files boolean remove files from work area )  {  add or update resources for paths ( work area files remove files from work area )  ;   }  
@ override public  list <  string >    (  file work area work area  list <  file >  files boolean remove files from work area )  {   list <  string >  result = new  array list <  string >  (  )  ;  for  (   file src file : files )   {  if  (  ! src file .
public static void   (  list <  translation >  translations )  {  long thread id =  thread . current thread (  )  . get id (  )  ;   map <  string  translation >  threadlocal cache = get threadlocal cache (  )  ;  if  ( threadlocal cache  =  =  null )   {  threadlocal cache = new  hash map <  string  translation >  (  )  ;   }   map <  string  translation >  additional translations = blc map utils . keyed map ( translations new  typed closure <  string  translation >  (  )  {  @ override public  string get key (   translation translation )  {  return build cache key ( translation )  ;   }   }   )  ;  threadlocal cache . put all ( additional translations )  ;  get cache (  )  . put ( new  element ( thread id threadlocal cache )  )  ;   }  
public  money   (  money other )  {  if  (  ! other . get currency (  )  . equals ( get currency (  )  )  )   {  if  (  currency conversion context . get currency conversion context (  )   !  =  null &&  currency conversion context . get currency conversion context (  )  . size (  )   >  0 &&  currency conversion context . get currency conversion service (  )   !  =  null )   {  other =  currency conversion context . get currency conversion service (  )  . convert currency ( other get currency (  )  amount . scale (  )  )  ;   }  else  {  if  ( this  =  =   money . zero )   {  return new  money ( amount . add ( other . amount )  other . currency amount . scale (  )   =  =  0  ?   bankers rounding . get scale for currency ( other . currency )  : amount . scale (  )  )  ;   }  else if  ( other  =  =   money . zero )   {  return this ;   }  throw new  unsupported operation exception ( " no currency conversion service is registered  cannot add different currency "  +  "types together  ( "  +  get currency (  )  . get currency code (  )   +  " " +  other . get currency (  )  . get currency code (  )  +  " ) " )  ;   }   }  return new  money ( amount . add ( other . amount )  currency amount . scale (  )   =  =  0  ?   bankers rounding . get scale for currency ( currency )  : amount . scale (  )  )  ;   }  
protected  string   (  string request path  string version )  {   string base filename =  string utils . strip filename extension ( request path )  ;   string extension =  string utils . get filename extension ( request path )  ;  return base filename  +  version  +  " . " +  extension ;   }  
public void   (  string error code  list <  string >  arguments )  {  error codes . add ( error code )  ;  error code map . put ( error code arguments )  ;   }  
@ override public void   (  site map generator configuration smgc  site map builder site map builder )  {  for  (   site map url entry url entry :  (  (  custom url site map generator configuration ) smgc )  . get customurl entries (  )  )   {  if  (  str
public void   (  site mapurl wrapper url wrapper )  {  if  ( currenturl set wrapper . get site map url wrappers (  )  . size (  )   >  =  site map config . get maximum url entries per file (  )  )   {  persist indexedurl set wrapper ( currenturl set wrapper )  ;  currenturl set wrapper = new  site mapurl set wrapper (  )  ;   }  currenturl set wrapper . get site map url wrappers (  )  . add ( url wrapper )  ;   }  
public void   (  site map image wrapper site map image )  {  get site map image wrappers (  )  . add ( site map image )  ;   }  
public tq restriction   ( tq restriction r )  {  restrictions . add ( r )  ;  return this ;   }  
public  typed query builder < t >    ( tq join join )  {  joins . add ( join )  ;  return this ;   }  
public  typed query builder < t >    ( tq order order )  {  orders . add ( order )  ;  return this ;   }  
public  typed query builder < t >    ( tq restriction restriction )  {  restrictions . add ( restriction )  ;  return this ;   }  
public void   (  resource collection res )  {  super . add ( res )  ;  rcs . add ( res )  ;   }  
public  table creator   (  string row header  object row data )  {   string trimmed =  string utils . left ( row header global row header width )  ;  sb . append ( "| " )  . append (  string utils . right pad ( trimmed global row header width )  )  . append (  string utils . right pad (  string . value of ( row data )  row width  -  global row header width  -  3 )  )  . append ( "|\r\n" )  ;  return this ;   }  
public  table creator   (  )  {  sb . append (  string utils . left pad ( "" row width ' - ' )  )  . append ( "\r\n" )  ;  return this ;   }  
@ override public void   (  interceptor registry registry )  {   locale change interceptor locale interceptor = new  locale change interceptor (  )  ;  locale interceptor . set param name ( "bl locale code" )  ;  registry . add interceptor ( locale interc
protected  < t > void   (  model and view model  deep link service < t >  service t item )  {  if  ( service  =  =  null )   {  return ;   }   broadleaf request context brc =  broadleaf request context . get broadleaf request context (  )  ;  if  ( brc . get sand box (  )   !  =  null )   {   list <  deep link >  links = service . get links ( item )  ;  if  ( links . size (  )   =  =  1 )   {  model . add object ( "admin deep link" links . get ( 0 )  )  ;   }  else  {  model . add object ( "admin deep link" links )  ;   }   }   }  
protected  string   (  string request path  string version )  {   string base filename =  string utils . strip filename extension ( request path )  ;   string extension =  string utils . get filename extension ( request path )  ;  return base filename  +  version  +  " . " +  extension ;   }  
protected void   (  string src boolean async boolean defer  string dependency event  broadleaf template context context  broadleaf template model model )  {   string method name = src ;  if  ( method name . contains ( " / " )  )   {  method name = method name . substring ( method name . last index of ( " / " )   +  1 method name . length (  )  )  ;   }  method name = method name . replace all ( " - " "   " )  ;  method name = method name . replace all ( "\\ . " "   " )  ;   string builder sb = new  string builder (  )  ;  sb . append ( " < script > \n" )  ;  sb . append ( "if  ( typeof ( "  +  dependency event  +  " event )   !  =  =  'undefined' )  { " )  ;  sb . append ( "$ ( function (  )   { " )  ;  sb . append ( "handle"  +  method name  +  " (  )  ; " )  ;  sb . append ( " }  )  ; " )  ;  sb . append ( " }  else  { " )  ;  sb . append ( "document . body . add event listener ( '"  +  dependency event  +  "' " )  ;  sb . append ( "function  ( elem )   { " )  ;  sb . append ( "$ ( function (  )   { " )  ;  sb . append ( "handle"  +  method name  +  " (  )  ; " )  ;  sb . append ( " }  )  ; " )  ;  sb . append ( " }   false" )  ;  sb . append ( " )  ; " )  ;  sb . append ( " } " )  ;  sb . append ( "function handle"  +  method name  +  " (  )   { " )  ;  sb . append ( "var script =  document . create element ( 'script' )  ; " )  ;  sb . append ( "script . type =  'text / javascript' ; " )  ;  sb . append ( "script . src =  '"  +  src  +  "' ; " )  ;  sb . append ( "document . body . append ( script )  ; " )  ;  sb . append ( " } " )  ;  sb . append ( "\n <  / script > " )  ;   broadleaf template element linked data = context . create text element ( sb . to string (  )  )  ;  model . add element ( linked data )  ;   }  
protected void   (  string src boolean async boolean defer  string dependency event  broadleaf template context context  broadleaf template model model )  {  if  ( src . contains ( " ; " )  )   {  src = src . substring ( 0 src . index of ( ' ; ' )  )  ;   }  if  ( src . ends with ( " . js" )  )   {  if  (  !  string utils . is empty ( dependency event )  )   {  add dependent bundle restriction to model ( src async defer dependency event context model )  ;   }  else  {  model . add element ( context . create non void element ( "script" get script attributes ( src async defer )  true )  )  ;   }   }  else if  ( src . ends with ( " . css" )  )   {  model . add element ( context . create non void element ( "link" get link attributes ( src )  true )  )  ;   }  else  {  throw new  illegal argument exception ( " unknown extension for: "  +  src  +  "  -  only  . js and  . css are supported" )  ;   }   }  
protected  string   (  string request path  string version )  {   string base filename =  string utils . strip filename extension ( request path )  ;   string extension =  string utils . get filename extension ( request path )  ;  return base filename  +  version  +  " . " +  extension ;   }  
protected  string   (  string request path  string version )  {   string base filename =  string utils . strip filename extension ( request path )  ;   string extension =  string utils . get filename extension ( request path )  ;  return base filename  +  version  +  " . " +  extension ;   }  
public static  string   (  string url  string pagination param name  integer page number )  {  try  {  if  ( page number  >  1 )   {  return new uri builder ( url )  . add parameter ( pagination param name  string . value of ( page number )  )  . build (  )  . to string (  )  ;   }   }  catch  (  uri syntax exception e )   {   }  return url ;   }  
protected void   (  category parent category int current depth  category site map generator configuration categorysmgc  site map builder site map builder )  {  if  ( current depth  >  categorysmgc . get ending depth (  )  )   {  return ;   }  if  ( current depth  >  =  categorysmgc . get starting depth (  )  )   {  construct site mapur ls ( categorysmgc site map builder parent category )  ;   }  int row offset = 0 ;   list <  category >  categories ;  do  {  categories = category dao . read active sub categories by category ( parent category row limit row offset )  ;  row offset +  = categories . size (  )  ;  for  (   category category : categories )   {  if  (  string utils . is not empty ( category . get url (  )  )  )   {  add category site map entries ( category current depth  +  1 categorysmgc site map builder )  ;   }  else  {  log . debug ( " skipping empty category url: "  +  category . get id (  )  )  ;   }   }   }  while  ( categories . size (  )   =  =  row limit )  ;   }  
@ override public void   (  site map generator configuration smgc  site map builder site map builder )  {  if  (  category site map generator configuration . class . is assignable from ( smgc . get class (  )  )  )   {   category site map generator config
@ override public void   (  site map generator configuration smgc  site map builder site map builder )  {  int page num = 0 ;   list <  product >  products ;  do  {  products = product dao . read all active products ( page num +  +  page size )  ;  for  (
@ override public void   (  site map generator configuration smgc  site map builder site map builder )  {  int page num = 0 ;   list <  sku >  skus ;  do  {  skus = sku dao . read all active skus ( page num +  +  page size )  ;  for  (   sku sku : skus ) 
@ override public  extension result status type   (  list <  offer >  offers  offer code offer code )  {  return  extension result status type . not   handled ;   }  
public void   (  offer item criteria criteria  promotable order item item )  {   list <  promotable order item >  item list = candidate qualifiers map . get ( criteria )  ;  if  ( item list  =  =  null )   {  item list = new  array list <  promotable order item >  (  )  ;  candidate qualifiers map . put ( criteria item list )  ;   }  item list . add ( item )  ;   }  
public void   (  offer item criteria criteria  promotable order item item )  {   list <  promotable order item >  item list = candidate targets map . get ( criteria )  ;  if  ( item list  =  =  null )   {  item list = new  array list <  promotable order item >  (  )  ;  candidate targets map . put ( criteria item list )  ;   }  item list . add ( item )  ;   }  
@ override public void   (  )  {  uses +  +  ;   }  
@ override public void   (  promotable fulfillment group adjustment adjustment )  {  candidate fulfillment group adjustments . add ( adjustment )  ;   }  
@ override public void   (  promotable order adjustment order adjustment )  {  candidate order offer adjustments . add ( order adjustment )  ;   }  
protected void   (  order item order item  list <  promotable order item >  discountable order items )  {   promotable order item item = item factory . create promotable order item ( order item  promotable order impl . this include order and item adjustments )  ;  discountable order items . add ( item )  ;   }  
@ override public void   (  promotable order item price detail adjustment item adjustment )  {  promotable order item price detail adjustments . add ( item adjustment )  ;   }  
@ override public void   (  promotable candidate item offer item offer  offer item criteria item criteria int qty to mark as target )  {   promotion discount pd = lookup or create promotion discount ( item offer )  ;  if  ( pd  =  =  null )   {  return ; 
@ override public  promotion qualifier   (  promotable candidate item offer item offer  offer item criteria item criteria int qty to mark as qualifier )  {   promotion qualifier pq = lookup or create promotion qualifier ( item offer )  ;  pq . increment q
public void   (  promotable order item price detail adjustment item adjustment )  {  detail . add candidate item price detail adjustment ( item adjustment )  ;   }  
public void   (  promotable candidate item offer item offer  offer item criteria item criteria int qty to mark as target )  {  detail . add promotion discount ( item offer item criteria qty to mark as target )  ;   }  
public  promotion qualifier   (  promotable candidate item offer item offer  offer item criteria item criteria int qty to mark as qualifier )  {  return detail . add promotion qualifier ( item offer item criteria qty to mark as qualifier )  ;   }  
@ override public  extension result status type   (  list <  offer >  offers  offer code offer code )  {  return execute ( add additional offers for code offers offer code )  ;   }  
protected void   (  offer offer  candidate promotion items candidates  offer item criteria criteria  list <  promotable order item >  promotable order items  promotable order item item )  {  if  ( offer . get apply to child items (  )  )   {  final  list <  order item >  child items = item . get order item (  )  . get child order items (  )  ;  if  (  collection utils . is empty ( child items )  )   {  return ;   }   list <  promotable order item >  filtered items = new  array list <  >  (  )  ;  filtered items . add all ( promotable order items )  ;   collection utils . filter ( filtered items new  typed predicate <  promotable order item >  (  )  {  @ override public boolean eval (   promotable order item promotable order item )  {  return child items . contains ( promotable order item . get order item (  )  )  ;   }   }   )  ;  for  (   promotable order item promotable order item : filtered items )   {  candidates . add target ( criteria promotable order item )  ;   }   }   }  
@ override public void   (  candidate fulfillment group offer candidate offer )  {  candidate offers . add ( candidate offer )  ;   }  
@ override public void   (  fulfillment group fee fulfillment group fee )  {  if  ( fulfillment group fees  =  =  null )   {  fulfillment group fees = new  array list <  fulfillment group fee >  (  )  ;   }  fulfillment group fees . add ( fulfillment grou
@ override public void   (  fulfillment group item fulfillment group item )  {  if  ( this . fulfillment group items  =  =  null )   {  this . fulfillment group items = new  vector <  fulfillment group item >  (  )  ;   }  this . fulfillment group items .
@ override public void   (  offer code offer code )  {  throw new  unsupported operation exception ( " null order does not support any modification operations . " )  ;   }  
@ override public void   (  offer code added offer code )  {  throw new  unsupported operation exception ( " null order does not support any modification operations . " )  ;   }  
@ override public void   (  order item order item )  {  throw new  unsupported operation exception ( " null order does not support any modification operations . " )  ;   }  
@ override @ deprecated public void   (  offer code offer code )  {  add offer code ( offer code )  ;   }  
@ override public void   (  offer code offer code )  {  get added offer codes (  )  . add ( offer code )  ;   }  
@ override public void   (  order item order item )  {  order items . add ( order item )  ;   }  
@ override public void   (  candidate item offer candidate item offer )  {  get candidate item offers (  )  . add ( candidate item offer )  ;   }  
@ override public  extension result status type   (  order order  list <  offer code >  offer codes boolean price order )  {  return  extension result status type . not   handled ;   }  
protected void   (  list <  promotion messagedto >  messagedt os  list <  promotion messagedto >  messages )  {  if  (  collection utils . is not empty ( messages )  )   {  messagedt os . add all ( messages )  ;   }   }  
@ override @ transactional ( "bl transaction manager" )  public  fulfillment group   (  fulfillment group request fulfillment group request boolean price order )  throws  pricing exception  {   fulfillment group fg = fulfillment group dao . create (  )  ;
@ override public  fulfillment group   (  fulfillment group item request fulfillment group item request boolean price order boolean save )  throws  pricing exception  {  if  ( price order &&  ! save )   {  throw new  illegal argument exception ( " pricing
public  order   (  order named order boolean price order )  throws  pricing exception  {   order cart order = order dao . read cart for customer ( named order . get customer (  )  )  ;  if  ( cart order  =  =  null )   {  cart order = create new cart for customer ( named order . get customer (  )  )  ;   }   list <  order item >  items = new  array list <  order item >  ( named order . get order items (  )  )  ;  for  ( int i = 0 ;  i  <  items . size (  )  ;  i +  +  )   {   order item order item = items . get ( i )  ;  boolean should price order =  ( price order &&  ( i  =  =  items . size (  )   -  1 )  )  ;  if  ( move named order items )   {  move item to order ( named order cart order order item should price order )  ;   }  else  {  add order item to order ( cart order order item should price order )  ;   }   }  return cart order ;   }  
@ override public  order   (  long order id  order item requestdto order item requestdto boolean price order )  throws  add to cart exception  {  try  {  return add item to order ( order id order item requestdto price order )  ;   }  catch  (   pricing ex
protected  order item   (  order order  order item new order item  boolean price order )  throws  pricing exception  {   list <  order item >  order items = order . get order items (  )  ;  new order item . set order ( order )  ;  new order item = order item service . save order item ( new order item )  ;  order items . add ( new order item )  ;  order = order service . save ( order price order )  ;  return new order item ;   }  
@ override public  order item   (  order order  bundle order item request item request boolean price order )  throws  pricing exception  {  item request . set order ( order )  ;   bundle order item item = order item service . create bundle order item ( it
@ override @ deprecated public  order item   (  order order  discrete order item request item request boolean price order )  throws  pricing exception  {  item request . set order ( order )  ;   discrete order item item = order item service . create discr
@ override @ deprecated public  order item   (  order order  discrete order item request item request @ suppress warnings ( "rawtypes" )   hash map sku pricing considerations boolean price order )  throws  pricing exception  {   discrete order item item =
@ override public  fulfillment group   (  order order  fulfillment group fulfillment group boolean price order )  throws  pricing exception  {   fulfillment group dfg = find default fulfillment group for order ( order )  ;  if  ( dfg  =  =  null )   {  fu
@ override public  order item   (  order order  gift wrap order item request item request )  throws  pricing exception  {  item request . set order ( order )  ;  return add gift wrap item to order ( order item request true )  ;   }  
@ override public  fulfillment group   (  order item item  fulfillment group fulfillment group boolean price order )  throws  pricing exception  {  return add item to fulfillment group ( item fulfillment group item . get quantity (  )  price order )  ;   
@ override public  order   (  long order id  order item requestdto order item requestdto boolean price order )  throws  pricing exception  {  if  ( order item requestdto . get quantity (  )   =  =  null || order item requestdto . get quantity (  )   =  = 
@ override public  order   (  order order  order item item  map <  string  string >  attribute values boolean price order )  throws  item not found exception   pricing exception  {  if  (  ! order . get order items (  )  . contains ( item )  )   {  throw 
@ override public  order item   (  order order  bundle order item bundle  discrete order item new order item boolean price order )  throws  pricing exception  {   list <  discrete order item >  order items = bundle . get discrete order items (  )  ;  orde
@ override @ deprecated public  order item   (  order order  order item new order item )  throws  pricing exception  {  return add order item to order ( order new order item true )  ;   }  
@ override public  order payment   (  order order  order payment payment )  {  return add payment to order ( order payment null )  ;   }  
@ override @ deprecated public  order item   (  long order id  long sku id  long product id  long category id  integer quantity boolean price order  map <  string  string >  item attributes )  throws  pricing exception  {  if  ( order id  =  =  null ||  (
@ override public  extension result status type   (  order order  list <  offer code >  offer codes boolean price order )  {  return execute ( add offer codes order offer codes price order )  ;   }  
@ override @ transactional ( "bl transaction manager" )  public  order   (  order named order boolean price order )  throws  remove from cart exception   add to cart exception  {   order cart order = order dao . read cart for customer ( named order . get 
@ override public void   (  order item requestdto order item requestdto int num addition requests int current addition  process context <  cart operation request >  context  list <  activity messagedto >  order messages )  throws  workflow exception  {  i
@ override public void   (  order item requestdto parent order item request  order item requestdto dependent order item )  {  parent order item request . get child order items (  )  . add ( dependent order item )  ;   }  
@ override @ transactional ( "bl transaction manager" )  public  order item   (  order order  gift wrap order item request item request boolean price order )  throws  pricing exception  {   gift wrap order item item = order item service . create gift wrap
@ override @ transactional ( value = "bl transaction manager" rollback for =  {  add to cart exception . class }  )  public  order   (  long order id  order item requestdto order item requestdto boolean price order )  throws  add to cart exception  {  ord
@ override @ transactional ( "bl transaction manager" )  public  order   (  order named order  order item item int quantity boolean price order )  throws  remove from cart exception   add to cart exception   update cart exception  {  if  ( quantity  <  1 
@ override @ transactional ( value = "bl transaction manager" rollback for =  {  add to cart exception . class }  )  public  order   (  long order id  order item requestdto order item requestdto boolean price order )  throws  add to cart exception  {   or
@ override @ transactional ( "bl transaction manager" )  public  order   (  order order  offer code offer code boolean price order )  throws  pricing exception   offer exception  {   array list <  offer code >  offer codes = new  array list <  offer code 
@ override @ transactional ( "bl transaction manager" )  public  order   (  order order  list <  offer code >  offer codes boolean price order )  throws  pricing exception   offer exception  {  pre validate cart operation ( order )  ;   set <  offer >  ad
@ override @ transactional ( "bl transaction manager" )  public  order payment   (  order order  order payment payment  referenced secure payment info )  {  payment . set order ( order )  ;  order . get payments (  )  . add ( payment )  ;  order = persist
public   (  )  {  set order ( order )  ;   }  
public   (  )  {  set order ( order )  ;   }  
protected void   (  sku sku  order item requestdto order item requestdto  product product  cart operation request request )  {  if  (  ! has sku or is non discreteoi ( sku order item requestdto )  )   {  handle if no sku ( order item requestdto product )  ;   }  else if  ( sku  =  =  null )   {  handle if non discreteoi ( order item requestdto )  ;   }  else if  (  ! sku . is active (  )  )   {  throw new  illegal argument exception ( " the requested sku id  ( "  +  sku . get id (  )   +  " )  is no longer active" )  ;   }  else  {  request . get item request (  )  . set sku id ( sku . get id (  )  )  ;   }   }  
public   (  )  {  set order ( order )  ;   }  
public   (  )  {  set order ( order )  ;   }  
protected  fulfillment group   (  order order  order item order item int quantity  fulfillment group fulfillment group )  throws  pricing exception  {   fulfillment group item request fulfillment group item request = new  fulfillment group item request (  )  ;  fulfillment group item request . set order ( order )  ;  fulfillment group item request . set order item ( order item )  ;  fulfillment group item request . set quantity ( quantity )  ;  fulfillment group item request . set fulfillment group ( fulfillment group )  ;  return fulfillment group service . add item to fulfillment group ( fulfillment group item request false false )  ;   }  
@ override public void   (  payment transaction transaction )  {  get transactions (  )  . add ( transaction )  ;   }  
public void   (  string additional lookup type )  {  if  ( additional lookup types  =  =  null )   {  additional lookup types = new  array list <  >  (  )  ;   }  additional lookup types . add ( additional lookup type )  ;   }  
@ override public  extension result status type   (  category category  search criteria search criteria  list <  long >  category ids )  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   (  indexable indexable  field field  field type field type  map <  string  object >  values  string property name  list <  locale >  locales )  throws  illegal access exception   invocation target exceptio
protected void   (  list <  string >  entity ids  translated entity translated entity )  {   list <  translation >  translations = translation service . find all translation entries ( translated entity  result type . standard entity ids )  ;   translation batch read cache . add to cache ( translations )  ;   }  
@ override public  extension result status type   (  indexable indexable  field field  field type field type  map <  string  object >  values  string property name  list <  locale >  locales )  throws  no such method exception   invocation target exceptio
public synchronized void   (  long event id  integer event retry count  date event created date )  {   index status info status = get index status (  )  ;  if  ( status  !  =  null )   {   integer retry count = status . get index errors (  )  . get ( event id )  ;  if  ( retry count  !  =  null )   {   integer allowed retry attempts = event retry count  !  =  null && event retry count  >  0  ?  event retry count : solr index status error retry count ;  if  ( retry count  >  =  allowed retry attempts )   {  status . get dead index events (  )  . put ( event id new  date (  )  )  ;  status . set last index date ( event created date )  ;  status . get additional info (  )  . put (  string . format ( " system event id%s" event id )   string . value of ( event id )  )  ;  status . get index errors (  )  . remove ( event id )  ;   }  else  {  status . get index errors (  )  . put ( event id retry count  +  1 )  ;   }   }  else  {  status . set last index date ( event created date )  ;  status . get index errors (  )  . put ( event id 0 )  ;   }   }  update index status ( status )  ;   }  
@ override public void   (  long event id  date event created date )  {   index status info status info = get seed status instance (  )  ;  status info . set last index date ( event created date )  ;  status info . get additional info (  )  . put (  strin
@ override public void   (  collection <  solr input document >  documents )  throws io exception   solr server exception  {  solr configuration . get server (  )  . add ( documents )  ;  log documents ( documents )  ;   }  
public  long   (  long entry )  {  if  (  ! cache . contains key ( entry )  )   {  return cache . put ( entry new  long (  system . current time millis (  )  )  )  ;   }  return null ;   }  
protected void   (  list <  breadcrumbdto >  parent crumbs  category category  string url  map <  string  string[] >  params )  {   category parent category = category . get parent category (  )  ;  if  ( parent category  !  =  null &&  ! parent crumbs . contains ( parent category )  )   {   breadcrumbdto dto = build crumb for category ( parent category url params )  ;  parent crumbs . add ( 0 dto )  ;  add parent crumbs ( parent crumbs parent category url params )  ;   }   }  
@ override public void   (  cookie arg0 )  {  esapi . http utilities (  )  . add cookie ( response arg0 )  ;   }  
@ override public void   (  string arg0 long arg1 )  {  response . add date header ( arg0 arg1 )  ;   }  
@ override public void   (  string arg0  string arg1 )  {  esapi . http utilities (  )  . add header ( response arg0 arg1 )  ;   }  
@ override public void   (  string arg0 int arg1 )  {  response . add int header ( arg0 arg1 )  ;   }  
public  string   (  http servlet request request  model model  payment info form payment info form  binding result binding result )  {   customer customer =  customer state . get customer (  )  ;  address service . populate addressiso country sub ( payment info form . get address (  )  )  ;  payment info form validator . validate ( payment info form binding result )  ;  if  (  ! binding result . has errors (  )  )   {  if  (  ( payment info form . get address (  )  . get phone primary (  )   !  =  null )  &&  (  string utils . is empty ( payment info form . get address (  )  . get phone primary (  )  . get phone number (  )  )  )  )   {  payment info form . get address (  )  . set phone primary ( null )  ;   }  if  (  ( payment info form . get address (  )  . get phone secondary (  )   !  =  null )  &&  (  string utils . is empty ( payment info form . get address (  )  . get phone secondary (  )  . get phone number (  )  )  )  )   {  payment info form . get address (  )  . set phone secondary ( null )  ;   }  if  (  ( payment info form . get address (  )  . get phone fax (  )   !  =  null )  &&  (  string utils . is empty ( payment info form . get address (  )  . get phone fax (  )  . get phone number (  )  )  )  )   {  payment info form . get address (  )  . set phone fax ( null )  ;   }  saved payment service . add saved payment ( customer payment info form )  ;  return get customer payment redirect (  )  ;   }  return get customer payment view (  )  ;   }  
public  string   (  http servlet request request  http servlet response response  model model  add to cart item item request  string wishlist name )  throws io exception   add to cart exception   pricing exception  {   order wishlist = order service . find named order for customer ( wishlist name  customer state . get customer ( request )  )  ;  if  ( wishlist  =  =  null )   {  wishlist = order service . create named order for customer ( wishlist name  customer state . get customer ( request )  )  ;   }  wishlist = order service . add item ( wishlist . get id (  )  item request false )  ;  wishlist = order service . save ( wishlist true )  ;  return get account wishlist redirect (  )  ;   }  
public  string   (  http servlet request request  model model  customer address form form  binding result result  redirect attributes redirect attributes )  throws  service exception  {  address service . populate addressiso country sub ( form . get address (  )  )  ;  customer address validator . validate ( form result )  ;  if  ( result . has errors (  )  )   {  return get customer addresses view (  )  ;   }  remove unused phones ( form )  ;   address address = address service . save address ( form . get address (  )  )  ;   customer address customer address = customer address service . create (  )  ;  customer address . set address ( address )  ;  customer address . set address name ( form . get address name (  )  )  ;  customer address . set customer (  customer state . get customer (  )  )  ;  customer address = customer address service . save customer address ( customer address )  ;  if  ( form . get address (  )  . is default (  )  )   {  customer address service . make customer address default ( customer address . get id (  )  customer address . get customer (  )  . get id (  )  )  ;   }  form . set customer address id ( customer address . get id (  )  )  ;  if  (  ! is ajax request ( request )  )   {   list <  customer address >  addresses = customer address service . read active customer addresses by customer id (  customer state . get customer (  )  . get id (  )  )  ;  model . add attribute ( "addresses" addresses )  ;   }  redirect attributes . add flash attribute ( "success message" get address added message (  )  )  ;  return get customer addresses redirect (  )  ;   }  
public  string   (  http servlet request request  http servlet response response  model model  order item requestdto item request )  throws io exception   add to cart exception   pricing exception   number format exception   remove from cart exception   illegal argument exception  {   order cart =  cart state . get cart (  )  ;  if  ( cart  =  =  null || cart instanceof  null order impl )   {  cart = order service . create new cart for customer (  customer state . get customer ( request )  )  ;   }  update cart service . validate add to cart request ( item request cart )  ;  if  ( is update request ( request )  )   {   string original order item = request . get parameter ( "original order item" )  ;  if  (  string utils . is not empty ( original order item )  )   {   long original order item id =  long . parse long ( original order item )  ;  update add request quantities ( item request original order item id )  ;  cart = order service . remove item ( cart . get id (  )  original order item id false )  ;  cart = order service . save ( cart true )  ;   }   }  cart = order service . add item ( cart . get id (  )  item request false )  ;  cart = order service . save ( cart true )  ;  return is ajax request ( request )   ?  get cart view (  )  : get cart page redirect (  )  ;   }  
public  string   (  http servlet request request  http servlet response response  model model  string customer offer )  throws io exception   pricing exception  {   order cart =  cart state . get cart (  )  ;   boolean promo added = false ;   string exception = "" ;  if  ( cart  !  =  null &&  !  ( cart instanceof  null order impl )  )   {   list <  offer code >  offer codes = offer service . lookup all offer codes by code ( customer offer )  ;  if  (  collection utils . is not empty ( offer codes )  )   {  for  (   offer code offer code : offer codes )   {  if  ( offer code  !  =  null )   {  try  {  order service . add offer code ( cart offer code false )  ;  promo added = true ;   }  catch  (   offer exception e )   {  if  ( e instanceof  offer max use exceeded exception )   {  exception = " use  limit  exceeded" ;   }  else if  ( e instanceof  offer expired exception )   {  exception = " offer  has  expired" ;   }  else if  ( e instanceof  offer already added exception )   {  exception = " offer  has  already  been  added" ;   }  else  {  exception = " an  unknown  offer  error  has  occurred" ;   }   }   }  else  {  exception = " invalid  code" ;   }   }  cart = order service . save ( cart true )  ;   }  else  {  exception = " unknown  code" ;   }   }  else  {  exception = " invalid  cart" ;   }  if  ( is ajax request ( request )  )   {   map <  string  object >  extra data = new  hash map <  >  (  )  ;  extra data . put ( "promo added" promo added )  ;  extra data . put ( "exception" exception )  ;  model . add attribute ( "blcextradata" new  object mapper (  )  . write value as string ( extra data )  )  ;   }  else  {  model . add attribute ( "exception" exception )  ;   }  return is checkout context ( request )   ?  get checkout view (  )  : get cart view (  )  ;   }  
@ deprecated public  string   (  http servlet request request  http servlet response response  model model  add to cart item item request )  throws io exception   add to cart exception   pricing exception  {  return add with price override ( request respo
@ override public  extension result status type   (  model model )  {  return  extension result status type . not   handled ;   }  
protected void   (  payment info form payment form  order cart )  {   order payment temp order payment = order payment service . create (  )  ;  temp order payment . set type (  payment type . credit   card )  ;  temp order payment . set payment gateway type (  payment gateway type . temporary )  ;  temp order payment . set billing address ( payment form . get address (  )  )  ;  temp order payment . set order ( cart )  ;  cart . get payments (  )  . add ( temp order payment )  ;   }  
@ override public  extension result status type   ( final  http servlet request request final  product product final json object review data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final  product product final json object sku data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object breadcrumb data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object breadcrumb data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object breadcrumb data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object category data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object category data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json array default data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json array homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final  product product final json object product data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final  product product final json object review data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final  product product final json object sku data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json array homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
@ override public  extension result status type   ( final  http servlet request request final json object homepage data )  throws json exception  {  return  extension result status type . not   handled ;   }  
protected void   ( final  http servlet request request final json object category data )  throws json exception  {  final  list <  product >  products = get products ( request )  ;  final json array item list = new json array (  )  ;  for  ( int i = 0 ;  i  <  products . size (  )  ;  i +  +  )   {  json object item = new json object (  )  ;  item . put ( "@type" " list item" )  ;  item . put ( "position" i  +  1 )  ;  item . put ( "url" products . get ( i )  . get url (  )  )  ;  item list . put ( item )  ;  extension manager . get proxy (  )  . add category product data ( request category data )  ;   }  category data . put ( "item list element" item list )  ;   }  
protected json object   ( final  http servlet request request )  throws json exception  {  final json object breadcrumb objects = new json object (  )  ;  breadcrumb objects . put ( "@context" get structured data context (  )  )  ;  breadcrumb objects . put ( "@type" " breadcrumb list" )  ;  final  string request uri = get request uri (  )  ;  final  map <  string  string[] >  params = get request params (  )  ;  final  list <  breadcrumbdto >  breadcrumbs = breadcrumb service . build breadcrumbdt os ( request uri params )  ;  final json array breadcrumb list = new json array (  )  ;  int index = 1 ;  for  (  final  breadcrumbdto breadcrumb : breadcrumbs )   {  final json object list item = new json object (  )  ;  list item . put ( "@type" " list item" )  ;  list item . put ( "position" index )  ;  final json object item = new json object (  )  ;  item . put ( "@id" get site base url (  )   +  breadcrumb . get link (  )  )  ;  item . put ( "name" breadcrumb . get text (  )  )  ;  extension manager . get proxy (  )  . add breadcrumb item data ( request item )  ;  list item . put ( "item" item )  ;  extension manager . get proxy (  )  . add breadcrumb list item data ( request list item )  ;  breadcrumb list . put ( list item )  ;  index +  +  ;   }  extension manager . get proxy (  )  . add breadcrumb data ( request breadcrumb objects )  ;  breadcrumb objects . put ( "item list element" breadcrumb list )  ;  return breadcrumb objects ;   }  
protected json array   ( final  http servlet request request )  throws json exception  {  final json array contact list = new json array (  )  ;  final json object contact = new json object (  )  ;  contact . put ( "@type" " contact point" )  ;  contact . put ( "telephone" get site customer service number (  )  )  ;  contact . put ( "contact type" "customer service" )  ;  extension manager . get proxy (  )  . add contact data ( request contact )  ;  contact list . put ( contact )  ;  return contact list ;   }  
protected json object   ( final  http servlet request request )  throws json exception  {  final json object organization = new json object (  )  ;  organization . put ( "@context" get structured data context (  )  )  ;  organization . put ( "@type" " organization" )  ;  organization . put ( "name" get site name (  )  )  ;  organization . put ( "url" get site base url (  )  )  ;  organization . put ( "logo" get logo url (  )  )  ;  if  ( site has customer service number (  )  )   {  organization . put ( "contact point" add contact data ( request )  )  ;   }  if  ( site has social links (  )  )   {  organization . put ( "same as" add social media data ( request )  )  ;   }  extension manager . get proxy (  )  . add organization data ( request organization )  ;  return organization ;   }  
protected json object   ( final  http servlet request request )  throws json exception  {  final json object potential action = new json object (  )  ;  potential action . put ( "@type" " search action" )  ;  potential action . put ( "target" get site base url (  )   +  get site search uri (  )  )  ;  potential action . put ( "query - input" "required name = query" )  ;  extension manager . get proxy (  )  . add potential actions data ( request potential action )  ;  return potential action ;   }  
protected json array   ( final  http servlet request request )  throws json exception  {  final  string site social accounts = get site social accounts (  )  ;  final json array social media data = new json array (  arrays . as list ( site social accounts . split ( " " )  )  )  ;  extension manager . get proxy (  )  . add social media data ( request social media data )  ;  return social media data ;   }  
protected json object   ( final  http servlet request request )  throws json exception  {  json object web site = new json object (  )  ;  web site . put ( "@context" default   structured   content   context )  ;  web site . put ( "@type" " web site" )  ;  web site . put ( "name" get site name (  )  )  ;  web site . put ( "url" get site base url (  )  )  ;  web site . put ( "potential action" add potential actions ( request )  )  ;  extension manager . get proxy (  )  . add web site data ( request web site )  ;  return web site ;   }  
protected void   ( final  product product final json object product data )  throws json exception  {  final  map <  string  media >  media = product . get media (  )  ;  if  ( media . size (  )   >  0 )   {  final  string url ;  final  string url prefix = get image url prefix (  )  ;  if  ( media . get ( "primary" )   !  =  null )   {  url = media . get ( "primary" )  . get url (  )  ;   }  else  {  url = media . entry set (  )  . iterator (  )  . next (  )  . get value (  )  . get url (  )  ;   }  if  ( url prefix . contains ( " / cmsstatic / " )  && url . contains ( " / cmsstatic / " )  )   {  product data . put ( "image" url . replace ( " / cmsstatic / " url prefix )  )  ;   }  else  {  product data . put ( "image" url prefix  +  url )  ;   }   }   }  
protected json object   ( final  http servlet request request final  product product final  string url )  throws json exception  {  final json object product data = new json object (  )  ;  product data . put ( "@context" default   structured   content   context )  ;  product data . put ( "@type" " product" )  ;  product data . put ( "name" product . get name (  )  )  ;  add image url ( product product data )  ;  product data . put ( "description" product . get long description (  )  )  ;  product data . put ( "brand" product . get manufacturer (  )  )  ;  product data . put ( "url" url )  ;  product data . put ( "sku" product . get default sku (  )  . get id (  )  )  ;  product data . put ( "category" product . get category (  )  . get name (  )  )  ;  add skus ( request product product data url )  ;  extension manager . get proxy (  )  . add product data ( request product product data )  ;  return product data ;   }  
protected void   ( final  http servlet request request final  product product final json object product data )  throws json exception  {  final  rating summary rating summary = rating service . read rating summary ( product . get id (  )  . to string (  )   rating type . product )  ;  if  ( rating summary  !  =  null && rating summary . get number of ratings (  )   >  0 )   {  final json object aggregate rating = new json object (  )  ;  aggregate rating . put ( "rating count" rating summary . get number of ratings (  )  )  ;  aggregate rating . put ( "rating value" rating summary . get average rating (  )  )  ;  extension manager . get proxy (  )  . add aggregate review data ( request product aggregate rating )  ;  product data . put ( "aggregate rating" aggregate rating )  ;  final json array reviews = new json array (  )  ;  for  (  final  review detail review detail : rating summary . get reviews (  )  )   {  final json object review = new json object (  )  ;  review . put ( "review body" review detail . get review text (  )  )  ;  review . put ( "review rating" new json object (  )  . put ( "rating value" review detail . get rating detail (  )  . get rating (  )  )  )  ;  review . put ( "author" review detail . get customer (  )  . get first name (  )  )  ;  review . put ( "date published" iso   8601   format . format ( review detail . get review submitted date (  )  )  )  ;  extension manager . get proxy (  )  . add review data ( request product review )  ;  reviews . put ( review )  ;   }  product data . put ( "review" reviews )  ;   }   }  
protected void   ( final  http servlet request request final  product product final json object product data final  string url )  throws json exception  {  final json array offers = new json array (  )  ;  final  string currency = product . get retail price (  )  . get currency (  )  . get currency code (  )  ;   big decimal high price =  big decimal . zero ;   big decimal low price = null ;  for  (  final  sku sku : product . get all sellable skus (  )  )   {  final json object offer = new json object (  )  ;  offer . put ( "@type" " offer" )  ;  offer . put ( "sku" sku . get id (  )  )  ;  offer . put ( "price currency" currency )  ;  offer . put ( "availability" determine availability ( sku )  )  ;  offer . put ( "url" url )  ;  offer . put ( "category" product . get category (  )  . get name (  )  )  ;  if  ( sku . get active end date (  )   !  =  null )   {  offer . put ( "price valid until" iso   8601   format . format ( sku . get active end date (  )  )  )  ;   }  final  money price = sku . get price data (  )  . get price (  )  ;  offer . put ( "price" price . get amount (  )  )  ;  if  ( price . greater than ( high price )  )   {  high price = price . get amount (  )  ;   }  if  ( low price  =  =  null || price . less than ( low price )  )   {  low price = price . get amount (  )  ;   }  extension manager . get proxy (  )  . add sku data ( request product offer )  ;  offers . put ( offer )  ;   }  if  ( offers . length (  )   >  1 )   {  final json object aggregate offer = new json object (  )  ;  aggregate offer . put ( "@type" " aggregate offer" )  ;  aggregate offer . put ( "high price" high price . double value (  )  )  ;  aggregate offer . put ( "low price" low price . double value (  )  )  ;  aggregate offer . put ( "price currency" currency )  ;  aggregate offer . put ( "offer count" offers . length (  )  )  ;  aggregate offer . put ( "offers" offers )  ;  extension manager . get proxy (  )  . add aggregate sku data ( request product aggregate offer )  ;  product data . put ( "offers" aggregate offer )  ;   }  else  {  product data . put ( "offers" offers )  ;   }   }  
@ override public void   (  string order attribute key  string order attribute value )  throws  payment exception  {  add order attribute to order ( null order attribute key order attribute value )  ;   }  
@ override public void   (  long order id  string order attribute key  string order attribute value )  throws  payment exception  {   order current cart =  cart state . get cart (  )  ;   long current cart id = current cart . get id (  )  ;  if  ( order i
protected void   (  map <  string  object >  new model vars  product product )  {   list <  product option >  product options = product . get product options (  )  ;   list <  product optiondto >  dtos = new  array list <  >  (  )  ;  for  (   product option option : product options )   {   product optiondto dto = new  product optiondto (  )  ;  dto . set id ( option . get id (  )  )  ;  dto . set type ( option . get type (  )  . get type (  )  )  ;   map <  long  string >  values = new  hash map <  >  (  )  ;  for  (   product option value value : option . get allowed values (  )  )   {  values . put ( value . get id (  )  value . get attribute value (  )  )  ;   }  dto . set values ( values )  ;  dtos . add ( dto )  ;   }  writejson to model ( new model vars "all product options" dtos )  ;   }  
protected void   (  map <  string  object >  new model vars  product product  broadleaf template context context  map <  string  string >  tag attributes )  {   list <  sku >  skus = product . get skus (  )  ;   list <  product option pricingdto >  sku pricing = new  array list <  >  (  )  ;  for  (   sku sku : skus )   {   list <  long >  product option value ids = new  array list <  >  (  )  ;   list <  product option value >  product option values = sku . get product option values (  )  ;  for  (   product option value product option value : product option values )   {  product option value ids . add ( product option value . get id (  )  )  ;   }   product option pricingdto pricing dto = create pricing dto ( sku product option value ids tag attributes context )  ;  sku pricing . add ( pricing dto )  ;   }  writejson to model ( new model vars "sku pricing" sku pricing )  ;   }  
protected void   (  map <  string  object >  attr map )  {   order cart =  cart state . get cart (  )  ;  int cart qty = 0 ;   list <  long >  cart item ids with options = new  array list <  >  (  )  ;   list <  long >  cart item ids without options = new  array list <  >  (  )  ;  if  ( cart  !  =  null && cart . get order items (  )   !  =  null )   {  cart qty = cart . get item count (  )  ;  for  (   order item item : cart . get order items (  )  )   {  if  ( item instanceof  sku accessor )   {   sku sku =  (  (  sku accessor ) item )  . get sku (  )  ;  if  ( sku  !  =  null && sku . get product (  )   !  =  null && item . get parent order item (  )   =  =  null )   {  if  ( use sku )   {  cart item ids without options . add ( sku . get id (  )  )  ;   }  else  {   product product = sku . get product (  )  ;   list <  product option xref >  option xrefs = product . get product option xrefs (  )  ;  if  ( option xrefs  =  =  null || option xrefs . is empty (  )  )   {  cart item ids without options . add ( product . get id (  )  )  ;   }  else  {  cart item ids with options . add ( product . get id (  )  )  ;   }   }   }   }   }   }  attr map . put ( "cart item count" cart qty )  ;  attr map . put ( "cart item ids with options" cart item ids with options )  ;  attr map . put ( "cart item ids without options" cart item ids without options )  ;   }  
protected void   (  map <  string  object >  attr map )  {   customer customer =  customer state . get customer (  )  ;   string first name = "" ;   string last name = "" ;  boolean anonymous = false ;  if  ( customer  !  =  null )   {  if  (  !  string utils . is empty ( customer . get first name (  )  )  )   {  first name = customer . get first name (  )  ;   }  if  (  !  string utils . is empty ( customer . get last name (  )  )  )   {  last name = customer . get last name (  )  ;   }  if  ( customer . is anonymous (  )  )   {  anonymous = true ;   }   }  attr map . put ( "first name" first name )  ;  attr map . put ( "last name" last name )  ;  attr map . put ( "anonymous" anonymous )  ;   }  
protected void   (  map <  string  object >  attr map  broadleaf template context context )  {   list <  long >  out of stock products = new  array list <  >  (  )  ;   list <  long >  out of stock skus = new  array list <  >  (  )  ;   set <  product >  all products = new  hash set <  >  (  )  ;   set <  sku >  all skus = new  hash set <  >  (  )  ;   set <  product >  products =  (  set <  product >  ) context . get variable ( "blc all displayed products" )  ;   set <  sku >  skus =  (  set <  sku >  ) context . get variable ( "blc all displayed skus" )  ;  if  (  !  collection utils . is empty ( products )  )   {  all products . add all ( products )  ;   }  if  (  !  collection utils . is empty ( skus )  )   {  all skus . add all ( skus )  ;   }  extension manager . get proxy (  )  . modify product list for inventory check ( context all products all skus )  ;  if  (  ! all products . is empty (  )  )   {  for  (   product product : all products )   {  if  ( product . get default sku (  )   !  =  null )   {   boolean qty available = inventory service . is available ( product . get default sku (  )  1 )  ;  if  ( qty available  !  =  null &&  ! qty available )   {  out of stock products . add ( product . get id (  )  )  ;   }  else  {   inventory service extension handler handler = inventory service extension manager . get proxy (  )  ;   extension result holder <  boolean >  holder = new  extension result holder <  >  (  )  ;  handler . is product bundle available ( product 1 holder )  ;   boolean available = holder . get result (  )  ;  if  ( available  !  =  null &&  ! available )   {  out of stock products . add ( product . get id (  )  )  ;   }   }   }   }   }  else  {  if  (  ! all skus . is empty (  )  )   {   map <  sku  integer >  inventory available = inventory service . retrieve quantities available ( all skus )  ;  for  (   map .  entry <  sku  integer >  entry : inventory available . entry set (  )  )   {  if  ( entry . get value (  )   =  =  null || entry . get value (  )   <  1 )   {  out of stock skus . add ( entry . get key (  )  . get id (  )  )  ;   }   }   }   }  attr map . put ( "out of stock products" out of stock products )  ;  attr map . put ( "out of stock skus" out of stock skus )  ;   }  
protected void   (  map <  string  string >  properties  string default description )  {  if  (  ! properties . contains key ( "meta description" )  )   {  properties . put ( "meta description" default description )  ;   }   }  
protected void   (  map <  string  string >  properties  string default title )  {  if  (  ! properties . contains key ( "title" )  )   {  properties . put ( "title" default title )  ;   }   }  
public void   (  customer role customer role )  {  em . persist ( customer role )  ;   }  
@ override public void   (  post registration observer post register listeners )  {  this . post register listeners . add ( post register listeners )  ;   }  
@ override public void   (  register customer form register customer form )  {   http servlet request request =  broadleaf request context . get broadleaf request context (  )  . get request (  )  ;   string redirect url = request . get parameter ( "succe
private  order payment   (  order order  address address )  {   order payment payment = new  order payment impl (  )  ;  payment . set billing address ( address )  ;  payment . set amount ( new  money ( 15d  +   ( 15d * 0 . 05d )  )  )  ;  payment . set reference number ( "1234" )  ;  payment . set type (  payment type . credit   card )  ;  payment . set payment gateway type (  null integration gateway type . null   integration   gateway )  ;  payment . set order ( order )  ;   payment transaction tx = new  payment transaction impl (  )  ;  tx . set amount ( payment . get amount (  )  )  ;  tx . set type (  payment transaction type . authorize   and   capture )  ;  tx . set order payment ( payment )  ;  payment . get transactions (  )  . add ( tx )  ;   credit card payment cc = new  credit card payment (  )  {  private static final long serial versionuid = 1l ;  private  string reference number = "1234" ;  @ override public  string get cvv code (  )  {  return "123" ;   }  @ override public  integer get expiration month (  )  {  return 11 ;   }  @ override public  integer get expiration year (  )  {  return 2011 ;   }  @ override public  long get id (  )  {  return null ;   }  @ override public  string get pan (  )  {  return "1111111111111111" ;   }  @ override public  string get name on card (  )  {  return " cardholder  name" ;   }  @ override public void set cvv code (   string cvv code )  {   }  @ override public void set expiration month (   integer expiration month )  {   }  @ override public void set expiration year (   integer expiration year )  {   }  @ override public void set id (   long id )  {   }  @ override public void set name on card (   string name on card )  {   }  @ override public void set pan (   string pan )  {   }  @ override public  encryption module get encryption module (  )  {  return encryption module ;   }  @ override public  string get reference number (  )  {  return reference number ;   }  @ override public void set encryption module (   encryption module encryption module )  {   }  @ override public void set reference number (   string reference number )  {  this . reference number = reference number ;   }   }   ;  order . get payments (  )  . add ( payment )  ;  return payment ;   }  
private void   (  order order  fulfillment group group )  {   discrete order item item = new  discrete order item impl (  )  ;  item . set order ( order )  ;  item . set quantity ( 1 )  ;   sku new sku = new  sku impl (  )  ;  new sku . set name ( " under  armor t -  shirt  -  -   red" )  ;  new sku . set retail price ( new  money ( 14 . 99 )  )  ;  new sku . set active start date (  system time . as date (  )  )  ;  new sku . set discountable ( false )  ;  new sku = catalog service . save sku ( new sku )  ;  item . set sku ( new sku )  ;  item =  (  discrete order item ) order item service . save order item ( item )  ;   list <  order item >  items = new  array list <  >  (  )  ;  items . add ( item )  ;  order . set order items ( items )  ;   fulfillment group item fg item = new  fulfillment group item impl (  )  ;  fg item . set fulfillment group ( group )  ;  fg item . set order item ( item )  ;  fg item . set quantity ( 1 )  ;  group . add fulfillment group item ( fg item )  ;   }  
@ test ( groups =  { " " }  depends on groups =  { "add item to order" }  )  @ rollback ( false )  @ transactional public void add another item to order (  )  throws  add to cart exception   pricing exception   remove from cart exception  {   sku sku = ge
@ test ( groups =  { " " }  depends on groups =  { "add another item to order" }  )  @ rollback ( false )  @ transactional public void add bundle to order (  )  throws  add to cart exception  {  num order items +  +  ;   sku sku = sku dao . read first sku
@ test ( groups =  { " " }  depends on groups =  { "find current cart for customer" "create sku" "test catalog" }  )  @ rollback ( false )  @ transactional ( propagation =  propagation . requires   new )  public void add item to order (  )  throws  add to
@ test ( groups =  { " " }  data provider = "basic payment info" data provider class =  payment info data provider . class depends on groups =  { "check order items" }  )  @ rollback ( false )  @ transactional public void add payment to order (  order pay
public  product bundle   (  )  {   product p = add test product ( "bundleproduct1" "bundlecat1" )  ;   sku bundle sku = catalog service . create sku (  )  ;  bundle sku . set name ( p . get name (  )  )  ;  bundle sku . set retail price ( new  money ( 44 . 99 )  )  ;  bundle sku . set active start date ( p . get active start date (  )  )  ;  bundle sku . set active end date ( p . get active end date (  )  )  ;  bundle sku . set discountable ( true )  ;   product bundle bundle =  (  product bundle ) catalog service . create product (  product type . bundle )  ;  bundle . set default category ( p . get default category (  )  )  ;  bundle . set default sku ( bundle sku )  ;  bundle =  (  product bundle ) catalog service . save product ( bundle )  ;   sku bundle item sku bundle item = new  sku bundle item impl (  )  ;  sku bundle item . set bundle ( bundle )  ;  sku bundle item . set quantity ( 1 )  ;  sku bundle item . set sku ( p . get default sku (  )  )  ;  bundle . get sku bundle items (  )  . add ( sku bundle item )  ;  bundle =  (  product bundle ) catalog service . save product ( bundle )  ;  return bundle ;   }  
public  product   (  string product name  string category name boolean active )  {   calendar active start cal =  calendar . get instance (  )  ;  active start cal . add (  calendar . day   of   year  - 2 )  ;   calendar active end cal =  calendar . get instance (  )  ;  active end cal . add (  calendar . day   of   year  - 1 )  ;   category category = new  category impl (  )  ;  category . set name ( category name )  ;  category . set active start date ( active start cal . get time (  )  )  ;  category = catalog service . save category ( category )  ;   sku new sku = new  sku impl (  )  ;  new sku . set name ( product name )  ;  new sku . set retail price ( new  money ( 44 . 99 )  )  ;  new sku . set active start date ( active start cal . get time (  )  )  ;  if  (  ! active )   {  new sku . set active end date ( active end cal . get time (  )  )  ;   }  new sku . set discountable ( true )  ;  new sku = catalog service . save sku ( new sku )  ;   product new product = new  product impl (  )  ;  new product . set default category ( category )  ;  new product . set default sku ( new sku )  ;  new product = catalog service . save product ( new product )  ;  return new product ;   }  
private void   (  string localgw  string eth1ip  string eth1mask  string dest ip or cidr )  {  s   logger . debug ( "add route to internal ip: localgw = "  +  localgw  +  "  eth1ip = " +  eth1ip +  "  eth1mask = " +  eth1mask +  " dest ip = " +  dest ip or cidr )  ;  if  ( dest ip or cidr  =  =  null )   {  s   logger . debug ( "add route to internal ip: dest ip is null" )  ;  return ;   }  if  (  !  net utils . is valid ip4 ( dest ip or cidr )  &&  !  net utils . is valid ip4 cidr ( dest ip or cidr )  )   {  s   logger . warn ( " dest ip is not a valid ip address or cidr dest ip = "  +  dest ip or cidr )  ;  return ;   }  boolean in same subnet = false ;  if  (  net utils . is valid ip4 ( dest ip or cidr )  )   {  if  ( eth1ip  !  =  null && eth1mask  !  =  null )   {  in same subnet =  net utils . same subnet ( eth1ip dest ip or cidr eth1mask )  ;   }  else  {  s   logger . warn ( "add route to internal ip: unable to determine same subnet:    eth1ip = "  +  eth1ip  +  "  dest ip = " +  dest ip or cidr +  "     eth1mask = " +  eth1mask )  ;   }   }  else  {  in same subnet =  net utils . is networka within networkb ( dest ip or cidr  net utils . ip and net mask to cidr ( eth1ip eth1mask )  )  ;   }  if  ( in same subnet )   {  s   logger . debug ( "add route to internal ip: dest ip "  +  dest ip or cidr  +  " is in the same subnet as eth1 ip " +  eth1ip )  ;  return ;   }   script command = new  script ( " / bin / bash" s   logger )  ;  command . add ( " - c" )  ;  command . add ( "ip route delete "  +  dest ip or cidr )  ;  command . execute (  )  ;  command = new  script ( " / bin / bash" s   logger )  ;  command . add ( " - c" )  ;  command . add ( "ip route add "  +  dest ip or cidr  +  " via " +  localgw )  ;   string result = command . execute (  )  ;  if  ( result  !  =  null )   {  s   logger . warn ( " error in configuring route to internal ip err = "  +  result )  ;   }  else  {  s   logger . debug ( "add route to internal ip: added route to internal ip = "  +  dest ip or cidr  +  " via " +  localgw )  ;   }   }  
public boolean   (  resource unavailable exception e )  {   class <  ?  >  scope = e . get scope (  )  ;  if  ( scope  =  =  null )   {  return false ;   }  if  (  host . class . is assignable from ( scope )  )   {  add host ( e . get resource id (  )  )  ;   }  else if  (  pod . class . is assignable from ( scope )  )   {  add pod ( e . get resource id (  )  )  ;   }  else if  (  data center . class . is assignable from ( scope )  )   {  add data center ( e . get resource id (  )  )  ;   }  else if  (  cluster . class . is assignable from ( scope )  )   {  add cluster ( e . get resource id (  )  )  ;   }  else if  (  storage pool . class . is assignable from ( scope )  )   {  add pool ( e . get resource id (  )  )  ;   }  else  {  return false ;   }  return true ;   }  
public void   ( long cluster id )  {  if  (    cluster ids  =  =  null )   {     cluster ids = new  hash set <  long >  (  )  ;   }     cluster ids . add ( cluster id )  ;   }  
public void   (  collection <  long >  cluster list )  {  if  (    cluster ids  =  =  null )   {     cluster ids = new  hash set <  long >  (  )  ;   }     cluster ids . add all ( cluster list )  ;   }  
public void   ( long data center id )  {  if  (    dc ids  =  =  null )   {     dc ids = new  hash set <  long >  (  )  ;   }     dc ids . add ( data center id )  ;   }  
public void   ( long host id )  {  if  (    host ids  =  =  null )   {     host ids = new  hash set <  long >  (  )  ;   }     host ids . add ( host id )  ;   }  
public void   (  collection <  long >  host list )  {  if  (    host ids  =  =  null )   {     host ids = new  hash set <  long >  (  )  ;   }     host ids . add all ( host list )  ;   }  
public void   ( long pod id )  {  if  (    pod ids  =  =  null )   {     pod ids = new  hash set <  long >  (  )  ;   }     pod ids . add ( pod id )  ;   }  
public void   (  collection <  long >  pod list )  {  if  (    pod ids  =  =  null )   {     pod ids = new  hash set <  long >  (  )  ;   }     pod ids . add all ( pod list )  ;   }  
public void   ( long pool id )  {  if  (    pool ids  =  =  null )   {     pool ids = new  hash set <  long >  (  )  ;   }     pool ids . add ( pool id )  ;   }  
public void   (  string uuid )  {  id list . add ( uuid )  ;  return ;   }  
public void   (  account account  list <  ?  extends  controlled entity >  violations )  {  this . account = account ;  this . violations = violations ;   }  
public void   (  list <  ?  extends  controlled entity >  violations )  {  this . violations = violations ;   }  
public void   (  string name  boolean required  string description  boolean is flag )  {   auto scale counter param param = new  auto scale counter param ( name required description is flag )  ;     param list . add ( param )  ;  return ;   }  
public void   (  string name  boolean required  string description  boolean is flag )  {   lb stickiness method param param = new  lb stickiness method param ( name required " " is flag )  ;     param list . add ( param )  ;  return ;   }  
public void   (  resource tag response tag )  {  this . tags . add ( tag )  ;   }  
public void   (  nic response nic )  {  this . nics . add ( nic )  ;   }  
public void   (  exception proxy object id )  {  id list . add ( id )  ;  return ;   }  
public void   (  resource tag response tag )  {  tags . add ( tag )  ;   }  
public void   (  security group rule response rule )  {  this . egress rules . add ( rule )  ;   }  
public void   (  security group rule response rule )  {  this . ingress rules . add ( rule )  ;   }  
public void   (  resource tag response tag )  {  this . tags . add ( tag )  ;   }  
public void   (  string virtual machine id )  {  this . virtual machine ids . add ( virtual machine id )  ;   }  
public void   (  resource tag response tag )  {  this . tags . add ( tag )  ;   }  
public void   (  affinity group response affinity group )  {  this . affinity group list . add ( affinity group )  ;   }  
public void   (  nic response nic )  {  this . nics . add ( nic )  ;   }  
public void   (  security group response security group )  {  this . security group list . add ( security group )  ;   }  
public void   (  resource tag response tag )  {  this . tags . add ( tag )  ;   }  
public void   (  string folder  string file  string contents )  {  vm data . add ( new  string[] { folder file contents }  )  ;   }  
public void   (  string source ip  string port boolean add  string intf )  {   port config pc = new  port config ( source ip port add intf )  ;  this . port configs . add ( pc )  ;   }  
public boolean   (  format info new info )  {  delete format ( new info . format )  ;  if  (  ! check format validity ( new info )  )   {  s   logger . warn ( " format is invalid" )  ;  s   logger . debug ( " format: "  +  new info . format  +  " size: " +  new info . size +  " virtualsize: " +  new info . virtual size +  " filename: " +  new info . filename )  ;  s   logger . debug ( "format  filename cannot be null and size  virtual size should be  >  0 " )  ;  return false ;   }     props . set property ( "virtualsize"  long . to string ( new info . virtual size )  )  ;     props . set property ( "size"  long . to string ( new info . size )  )  ;     formats . add ( new info )  ;  return true ;   }  
@ override public void   (  string .  .  .  args )  {  for  (   string arg : args )   {     boot args . append ( arg )  . append ( " " )  ;   }   }  
@ override public void   (  diskto disk )  {     disks . add ( disk )  ;   }  
@ override public void   (  nic profile nic )  {     nics . add ( nic )  ;   }  
protected synchronized void   ( final  request req )  {  int index = find request ( req )  ;  assert  ( index  <  0 )  : " how can we get index again ?  "  +  index  +  ":" +  req . to string (  )  ;     requests . add (  - index  -  1 req )  ;   }  
protected synchronized void   ( final  request req )  {  int index = find transfer request ( req )  ;  assert  ( index  <  0 )  : " how can we get index again ?  "  +  index  +  ":" +  req . to string (  )  ;     transfer requests . add (  - index  -  1 req )  ;   }  
@ override public void   (  string name  string value )  {  vm entityvo . set detail ( name value )  ;   }  
@ override public  nic profile   ( final  virtual machine vm final  network network final  nic profile requested )  throws  concurrent operation exception   resource unavailable exception   insufficient capacity exception  {  final  async job execution co
public  outcome <  virtual machine >    ( final  virtual machine vm final  network network final  nic profile requested )  {  final  call context context =  call context . current (  )  ;  final  user user = context . get calling user (  )  ;  final  account account = context . get calling account (  )  ;  final  list <  vm work jobvo >  pending work jobs =    work job dao . list pending work jobs (  virtual machine .  type .  instance vm . get id (  )   vm work add vm to network . class . get name (  )  )  ;   vm work jobvo work job = null ;  if  ( pending work jobs  !  =  null && pending work jobs . size (  )   >  0 )   {  assert pending work jobs . size (  )   =  =  1 ;  work job = pending work jobs . get ( 0 )  ;   }  else  {  work job = new  vm work jobvo ( context . get context id (  )  )  ;  work job . set dispatcher (  vm work constants . vm   work   job   dispatcher )  ;  work job . set cmd (  vm work add vm to network . class . get name (  )  )  ;  work job . set account id ( account . get id (  )  )  ;  work job . set user id ( user . get id (  )  )  ;  work job . set vm type (  virtual machine .  type .  instance )  ;  work job . set vm instance id ( vm . get id (  )  )  ;  work job . set related (  async job execution context . get origin job id (  )  )  ;  final  vm work add vm to network work info = new  vm work add vm to network ( user . get id (  )  account . get id (  )  vm . get id (  )   virtual machine manager impl . vm   work   job   handler network . get id (  )  requested )  ;  work job . set cmd info (  vm work serializer . serialize ( work info )  )  ;     job mgr . submit async job ( work job  vm work constants . vm   work   queue vm . get id (  )  )  ;   }   async job execution context . get current execution context (  )  . join job ( work job . get id (  )  )  ;  return new  vm job virtual machine outcome ( work job vm . get id (  )  )  ;   }  
@ override public void   (  string name  string value )  {  data centervo . set detail ( name value )  ;   }  
@ override public void   ( long dc id long pod id  string start  string end )  {     link local ip alloc dao . add ip range ( dc id pod id start end )  ;   }  
@ override public void   ( long dc id long pod id  string start  string end boolean for system vms  integer vlan )  {     ip alloc dao . add ip range ( dc id pod id start end for system vms vlan )  ;   }  
@ override public void   ( long dc id long physical network id  list <  string >  vnets )  {     vnet alloc dao . add ( dc id physical network id vnets )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  data center detailvo ( resource id key value display )  )  ;   }  
@ override @db public void   ( long dc id long pod id  string start  string end boolean for system vms  integer vlan )  {   transaction legacy txn =  transaction legacy . current txn (  )  ;   string insert sql = "insert into `cloud` . `op   dc   ip   add
@ override @db public void   ( long dc id long pod id  string start  string end )  {   string insert sql = "insert into `cloud` . `op   dc   link   local   ip   address   alloc`  ( ip   address  data   center   id  pod   id )  values  (  ?    ?    ?  ) " 
@ override @db public void   ( long dc id long physical network id  list <  string >  vnets )  {   string insert vnet = "insert into `cloud` . `op   dc   vnet   alloc`  ( vnet  data   center   id  physical   network   id )  values  (   ?    ?    ?  ) " ; 
@ override public void   ( long pod id int start int end )  {   string insert vnet = "insert into `cloud` . `op   pod   vlan   alloc`  ( vlan  pod   id )  values  (   ?    ?  ) " ;   transaction legacy txn =  transaction legacy . current txn (  )  ;  try 
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  vlan detailsvo ( resource id key value display )  )  ;   }  
@ override public void   ( long pod id long vlan db id )  {   pod vlan mapvo pvmvo = new  pod vlan mapvo ( pod id vlan db id )  ;     pod vlan map dao . persist ( pvmvo )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  network detailvo ( resource id key value display )  )  ;   }  
protected void   ( final long network id final long account id final boolean is owner )  {  final  network accountvo account = new  network accountvo ( network id account id is owner )  ;     accounts dao . persist ( account )  ;   }  
@ override public void   ( final long network id final long domain id final  boolean subdomain access )  {  add domain to networknetwork ( network id domain id subdomain access )  ;   }  
protected void   ( final long network id final long domain id final  boolean subdomain access )  {  final  network domainvo domain = new  network domainvo ( network id domain id subdomain access )  ;     domains dao . persist ( domain )  ;   }  
public void   (  string isolation method )  {  if  ( isolation methods  =  =  null )   {  isolation methods = new  array list <  string >  (  )  ;   }  isolation methods . add ( isolation method )  ;   }  
public void   (  string tag )  {  if  ( tags  =  =  null )   {  tags = new  array list <  string >  (  )  ;   }  tags . add ( tag )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  persist ( new  network offering detailsvo ( resource id  detail . value of ( key )  value )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  service offering detailsvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  snapshot detailsvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  storage pool detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new vm template detailvo ( resource id key value display )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ override @db public long   ( vm templatevo tmplt long zone id )  {   transaction legacy txn =  transaction legacy . current txn (  )  ;  txn . start (  )  ;  vm templatevo tmplt2 = find by id ( tmplt . get id (  )  )
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  volume detailvo ( resource id key value display )  )  ;   }  
private void   (  connection conn )  {   prepared statement pstmt = null ;  try  {  s   logger . debug ( " adding missing foreign keys" )  ;   hash map <  string  string >  key to table map = new  hash map <  string  string >  (  )  ;  key to table map . put ( "fk   console   proxy      id" "console   proxy" )  ;  key to table map . put ( "fk   secondary   storage   vm      id" "secondary   storage   vm" )  ;  key to table map . put ( "fk   template   spool   ref      template   id" "template   spool   ref" )  ;  key to table map . put ( "fk   template   spool   ref      pool   id" "template   spool   ref" )  ;  key to table map . put ( "fk   user   vm   details      vm   id" "user   vm   details" )  ;  key to table map . put ( "fk   op   ha   work      instance   id" "op   ha   work" )  ;  key to table map . put ( "fk   op   ha   work      mgmt   server   id" "op   ha   work" )  ;  key to table map . put ( "fk   op   ha   work      host   id" "op   ha   work" )  ;   hash map <  string  string >  key to statement map = new  hash map <  string  string >  (  )  ;  key to statement map . put ( "fk   console   proxy      id" " ( `id` )  references `vm   instance`  ( `id` )  on delete cascade" )  ;  key to statement map . put ( "fk   secondary   storage   vm      id" " ( `id` )  references `vm   instance`  ( `id` )  on delete cascade" )  ;  key to statement map . put ( "fk   template   spool   ref      template   id" " ( `template   id` )  references `vm   template`  ( `id` ) " )  ;  key to statement map . put ( "fk   template   spool   ref      pool   id" " ( `pool   id` )  references `storage   pool`  ( `id` )  on delete cascade" )  ;  key to statement map . put ( "fk   user   vm   details      vm   id" " ( `vm   id` )  references `user   vm`  ( `id` )  on delete cascade" )  ;  key to statement map . put ( "fk   op   ha   work      instance   id" " ( `instance   id` )  references `vm   instance`  ( `id` )  on delete cascade" )  ;  key to statement map . put ( "fk   op   ha   work      mgmt   server   id" " ( `mgmt   server   id` )  references `mshost` ( `msid` ) " )  ;  key to statement map . put ( "fk   op   ha   work      host   id" " ( `host   id` )  references `host`  ( `id` ) " )  ;  for  (   string key : key to table map . key set (  )  )   {   string table name = key to table map . get ( key )  ;  pstmt = conn . prepare statement ( "select * from information   schema . table   constraints a join information   schema . key   column   usage b on a . table   schema  =  b . table   schema and a . constraint   name  =  b . constraint   name where a . table   schema = database (  )  and a . constraint   type = 'foreign key' and a . constraint   name =  ? " )  ;  pstmt . set string ( 1 key )  ;   result set rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  continue ;   }  pstmt = conn . prepare statement ( "alter table "  +  table name  +  " add constraint " +  key +  " foreign key " +  key to statement map . get ( key )  )  ;  pstmt . execute update (  )  ;  s   logger . debug ( " added missing key "  +  key  +  " to table " +  table name )  ;  rs . close (  )  ;   }  s   logger . debug ( " missing keys were added successfully as a part of 224 to 225 upgrade" )  ;  pstmt . close (  )  ;   }  catch  (  sql exception e )   {  s   logger . error ( " unable to add missing foreign key ;  following statement was executed:"  +  pstmt )  ;  throw new  cloud runtime exception ( " unable to add missign keys due to exception" e )  ;   }   }  
private void   (  connection conn )  {  try  {   prepared statement pstmt = conn . prepare statement ( "select * from ovs   tunnel   account" )  ;   result set rs = pstmt . execute query (  )  ;  if  (  ! rs . next (  )  )   {  s   logger . debug ( " adding missing ovs tunnel account" )  ;  pstmt = conn . prepare statement ( "insert into `cloud` . `ovs   tunnel   account`  ( `from`  `to`  `account`  `key`  `port   name`  `state` )  values  ( 0  0  0  0  'lock'  'success' ) " )  ;  pstmt . execute update (  )  ;   }   }  catch  (  sql exception e )   {  s   logger . error ( " unable to add missing ovs tunnel account due to " e )  ;  throw new  cloud runtime exception ( " unable to add missign ovs tunnel account due to " e )  ;   }   }  
private void   (  connection conn )  {  s   logger . debug ( " checking if host   details unique key exists  if not we will add it" )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "show index from `cloud` . `host   details` where key   name  =  'uk   host   id   name'" )  ;  result set rs = pstmt . execute query (  )  )  {  if  ( rs . next (  )  )   {  s   logger . debug ( " unique key already exists on host   details  -  not adding new one" )  ;   }  else  {   prepared statement pstmt update = conn . prepare statement ( "alter ignore table `cloud` . `host   details` add constraint unique key `uk   host   id   name`  ( `host   id`  `name` ) " )  ;  pstmt update . execute update (  )  ;  s   logger . debug ( " unique key did not exist on host   details  -  added new one" )  ;  pstmt update . close (  )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " failed to check / update the host   details unique key " e )  ;   }   }  
private void   (  connection conn long host id long physical network id )  {  s   logger . debug ( " adding srx firewall device with host id "  +  host id  +  " in to physical network" +  physical network id )  ;   string insert srx = "insert into `cloud` . `external   firewall   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insert srx )  )  {  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " junipersrx firewall" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set string ( 9 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding srx firewall device " e )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {  s   logger . debug ( " adding  physical network service provider  junipersrx" )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 1 1 1 0 1 1 0 0 ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertpnsp )  )  {  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider  junipersrx" e )  ;   }   }  
private void   (  connection conn )  {  s   logger . debug ( " adding vpc provider to all physical networks in the system" )  ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  pstmt = conn . prepare statement ( "select id from `cloud` . `physical   network` where removed is null" )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   long p ntwk id = rs . get long ( 1 )  ;  pstmt = conn . prepare statement ( "insert into `cloud` . `physical   network   service   providers` "  +  " ( `physical   network   id`  `provider   name`  `state`  `vpn   service   provided`  `dhcp   service   provided`  "  +  "`dns   service   provided`  `gateway   service   provided`  `firewall   service   provided`  `source   nat   service   provided` " +  " `load   balance   service   provided`  `static   nat   service   provided`  `port   forwarding   service   provided` " +  " `user   data   service   provided`  `security   group   service   provided` )  " +  "values  (  ?   ' vpc virtual router'  ' enabled'  1  1  1  1  1  1  1  1  1  1  0 ) " )  ;  pstmt . set long ( 1 p ntwk id )  ;  pstmt . execute update (  )  ;  pstmt = conn . prepare statement ( "select id from `cloud` . `physical   network   service   providers` "  +  "where physical   network   id =  ?  and provider   name = ' vpc virtual router'" )  ;  pstmt . set long ( 1 p ntwk id )  ;   result set rs1 = pstmt . execute query (  )  ;  rs1 . next (  )  ;  long provider id = rs1 . get long ( 1 )  ;  pstmt = conn . prepare statement ( "insert into `cloud` . `virtual   router   providers`  ( `nsp   id`  `type`  `enabled` )  "  +  "values  (  ?   'vpc virtual router'  1 ) " )  ;  pstmt . set long ( 1 provider id )  ;  pstmt . execute update (  )  ;  s   logger . debug ( " added vpc  virtual router provider for physical network id = "  +  p ntwk id )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable add vpc physical network service provider " e )  ;   }  finally  {  close auto closeable ( rs )  ;  close auto closeable ( pstmt )  ;   }  s   logger . debug ( " done adding vpc physical network service providers to all physical networks" )  ;   }  
private void   (  connection conn )  {  s   logger . debug ( " adding network i ds to user stats .  .  . " )  ;  try  {   string stmt = "select distinct public   ip   address from `cloud` . `user   statistics` where public   ip   address is not null" ;   prepared statement pstmt = conn . prepare statement ( stmt )  ;   result set rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   string public ip address = rs . get string ( 1 )  ;  stmt = "select network   id from `cloud` . `user   ip   address` where public   ip   address  =   ? " ;  pstmt = conn . prepare statement ( stmt )  ;  pstmt . set string ( 1 public ip address )  ;   result set rs2 = pstmt . execute query (  )  ;  if  ( rs2 . next (  )  )   {   long network id = rs2 . get long ( 1 )  ;   string[] dbs =  { "cloud" "cloud   usage" }  ;  for  (   string db : dbs )   {  stmt = "update `"  +  db  +  "` . `user   statistics` set network   id  =   ?  where public   ip   address  =   ? " ;  pstmt = conn . prepare statement ( stmt )  ;  pstmt . set long ( 1 network id )  ;  pstmt . set string ( 2 public ip address )  ;  pstmt . execute update (  )  ;   }   }  rs2 . close (  )  ;   }  rs . close (  )  ;  pstmt . close (  )  ;  s   logger . debug ( " successfully added network i ds to user stats . " )  ;   }  catch  (  sql exception e )   {   string error msg = " failed to add network i ds to user stats . " ;  s   logger . error ( error msg e )  ;  throw new  cloud runtime exception ( error msg e )  ;   }   }  
private void   (  connection conn )  {  boolean insert field = false ;  try  {   prepared statement pstmt ;  try  {  pstmt = conn . prepare statement ( "select source   id from `cloud   usage` . `usage   storage`" )  ;   result set rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  s   logger . info ( " the source id field already exist  not adding it" )  ;   }   }  catch  (   exception e )   {  insert field = true ;   }  if  ( insert field )   {  s   logger . debug ( " adding source   id to usage   storage .  .  . " )  ;  pstmt = conn . prepare statement ( "alter table `cloud   usage` . `usage   storage` add column `source   id` bigint unsigned" )  ;  pstmt . execute update (  )  ;  s   logger . debug ( " column source   id was added successfully to usage   storage table" )  ;  pstmt . close (  )  ;   }   }  catch  (  sql exception e )   {  s   logger . error ( " failed to add source   id to usage   storage due to " e )  ;  throw new  cloud runtime exception ( " failed to add source   id to usage   storage due to " e )  ;   }   }  
private void   (  connection conn )  {  s   logger . debug ( " checking if host   details unique key exists  if not we will add it" )  ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  pstmt = conn . prepare statement ( "show index from `cloud` . `host   details` where key   name  =  'uk   host   id   name'" )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  s   logger . debug ( " unique key already exists on host   details  -  not adding new one" )  ;   }  else  {   prepared statement pstmt update = conn . prepare statement ( "alter ignore table `cloud` . `host   details` add constraint unique key `uk   host   id   name`  ( `host   id`  `name` ) " )  ;  pstmt update . execute update (  )  ;  s   logger . debug ( " unique key did not exist on host   details  -  added new one" )  ;  pstmt update . close (  )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " failed to check / update the host   details unique key " e )  ;   }  finally  {  close auto closeable ( rs )  ;  close auto closeable ( pstmt )  ;   }   }  
private void   (  connection conn )  {  s   logger . debug ( " adding vpc provider to all physical networks in the system" )  ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  pstmt = conn . prepare statement ( "select id from `cloud` . `physical   network` where removed is null" )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   long p ntwk id = rs . get long ( 1 )  ;  pstmt = conn . prepare statement ( "insert into `cloud` . `physical   network   service   providers` "  +  " ( `physical   network   id`  `provider   name`  `state`  `vpn   service   provided`  `dhcp   service   provided`  "  +  "`dns   service   provided`  `gateway   service   provided`  `firewall   service   provided`  `source   nat   service   provided` " +  " `load   balance   service   provided`  `static   nat   service   provided`  `port   forwarding   service   provided` " +  " `user   data   service   provided`  `security   group   service   provided` )  " +  "values  (  ?   ' vpc virtual router'  ' enabled'  1  1  1  1  1  1  1  1  1  1  0 ) " )  ;  pstmt . set long ( 1 p ntwk id )  ;  pstmt . execute update (  )  ;  pstmt = conn . prepare statement ( "select id from `cloud` . `physical   network   service   providers` "  +  "where physical   network   id =  ?  and provider   name = ' vpc virtual router'" )  ;  pstmt . set long ( 1 p ntwk id )  ;   result set rs1 = pstmt . execute query (  )  ;  rs1 . next (  )  ;  long provider id = rs1 . get long ( 1 )  ;  pstmt = conn . prepare statement ( "insert into `cloud` . `virtual   router   providers`  ( `nsp   id`  `type`  `enabled` )  "  +  "values  (  ?   'vpc virtual router'  1 ) " )  ;  pstmt . set long ( 1 provider id )  ;  pstmt . execute update (  )  ;  s   logger . debug ( " added vpc  virtual router provider for physical network id = "  +  p ntwk id )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable add vpc physical network service provider " e )  ;   }  finally  {  close auto closeable ( rs )  ;  close auto closeable ( pstmt )  ;   }  s   logger . debug ( " done adding vpc physical network service providers to all physical networks" )  ;   }  
private void   (  connection conn long host id long physical network id )  {   prepared statement pstmt update = null ;  try  {  s   logger . debug ( " adding srx firewall device with host id "  +  host id  +  " in to physical network" +  physical network id )  ;   string insert srx = "insert into `cloud` . `external   firewall   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  pstmt update = conn . prepare statement ( insert srx )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " junipersrx firewall" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set string ( 9 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding srx firewall device " e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {   prepared statement pstmt update = null ;  try  {  s   logger . debug ( " adding  physical network service provider  junipersrx" )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 1 1 1 0 1 1 0 0 ) " ;  pstmt update = conn . prepare statement ( insertpnsp )  ;  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider  junipersrx" e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
private void   (  connection conn )  {   list <  string >  index list = new  array list <  string >  (  )  ;  s   logger . debug ( " dropping index i   alert      last   sent if it exists" )  ;  index list . add ( "i   alert      last   sent" )  ;   db upgrade utils . drop keys if exist ( conn "alert" index list false )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "alter table `cloud` . `alert` add index `i   alert      last   sent` ( `last   sent` ) " )  )  {  pstmt . execute update (  )  ;  s   logger . debug ( " added index i   alert      last   sent for table alert" )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to add index i   alert      last   sent to alert table for the column last   sent" e )  ;   }   }  
private void   (  connection conn )  {   list <  string >  index list = new  array list <  string >  (  )  ;  s   logger . debug ( " dropping index fk   host   details      host   id if it exists" )  ;  index list . add ( "fk   host   details      host   id" )  ;   db upgrade utils . drop keys if exist ( conn "host   details" index list false )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "alter table `cloud` . `host   details` add index `fk   host   details      host   id` ( `host   id` ) " )  )  {  pstmt . execute update (  )  ;  s   logger . debug ( " added index fk   host   details      host   id for table host   details" )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to add index fk   host   details      host   id to host   details table for the column host   id" e )  ;   }   }  
protected void   (  connection conn long physical network id long zone id  string network type boolean is304 )  {   prepared statement pstmt update = null  pstmt2 = null ;  try  {  boolean issg service enabled = false ;   string selectsg = "" ;  if  ( is304 )   {  selectsg = "select nm . * from `cloud` . `ntwk   service   map` nm join `cloud` . `networks` n on nm . network   id  =  n . id where n . data   center   id  =   ?  and nm . service = ' security group'" ;   }  else  {  selectsg = "select * from `cloud` . `networks` where is   security   group   enabled = 1 and data   center   id =  ? " ;   }  pstmt2 = conn . prepare statement ( selectsg )  ;  pstmt2 . set long ( 1 zone id )  ;   result set sg dc set = pstmt2 . execute query (  )  ;  if  ( sg dc set . next (  )  )   {  issg service enabled = true ;   }  sg dc set . close (  )  ;  pstmt2 . close (  )  ;  if  ( issg service enabled )   {  s   logger . debug ( " adding  physical network service provider  security group provider to the physical network id = "  +  physical network id )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 0 0 0 0 0 0 0 1 ) " ;  pstmt update = conn . prepare statement ( insertpnsp )  ;  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 " security group provider" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding default  security  group  provider" e )  ;   }  finally  {  close auto closeable ( pstmt2 )  ;  close auto closeable ( pstmt update )  ;   }   }  
protected void   (  connection conn long physical network id long zone id )  {   prepared statement pstmt update = null  pstmt2 = null ;  try  {  s   logger . debug ( " adding  physical network service provider  virtual router" )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 1 1 1 1 1 1 1 1 1 1 0 ) " ;   string routeruuid = uuid . randomuuid (  )  . to string (  )  ;  pstmt update = conn . prepare statement ( insertpnsp )  ;  pstmt update . set string ( 1 routeruuid )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 " virtual router" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   string fetchns pid = "select id from `cloud` . `physical   network   service   providers` where physical   network   id = "  +  physical network id  +  " and provider   name  =  ' virtual router' and uuid  =   ? " ;  pstmt2 = conn . prepare statement ( fetchns pid )  ;  pstmt2 . set string ( 1 routeruuid )  ;   result set rsns pid = pstmt2 . execute query (  )  ;  rsns pid . next (  )  ;  long nsp id = rsns pid . get long ( 1 )  ;  pstmt2 . close (  )  ;   string insert router = "insert into `cloud` . `virtual   router   providers`  ( `nsp   id`  `uuid`   `type`   `enabled` )  "  +  "values  (  ?   ?   ?   ?  ) " ;  pstmt update = conn . prepare statement ( insert router )  ;  pstmt update . set long ( 1 nsp id )  ;  pstmt update . set string ( 2 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set string ( 3 " virtual router" )  ;  pstmt update . set int ( 4 1 )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical networks" e )  ;   }  finally  {  close auto closeable ( pstmt2 )  ;  close auto closeable ( pstmt update )  ;   }   }  
protected long   (  connection conn long zone id  string zone name  string network type  string vnet  long domain id )  {   string get next network sequence sql = "select value from `cloud` . `sequence` where name = 'physical   networks   seq'" ;   string advance network sequence sql = "update `cloud` . `sequence` set value = value + 1 where name = 'physical   networks   seq'" ;   prepared statement pstmt update = null  pstmt2 = null ;  try  {  pstmt2 = conn . prepare statement ( get next network sequence sql )  ;   result set rs seq = pstmt2 . execute query (  )  ;  rs seq . next (  )  ;  long physical network id = rs seq . get long ( 1 )  ;  rs seq . close (  )  ;  pstmt2 . close (  )  ;  pstmt2 = conn . prepare statement ( advance network sequence sql )  ;  pstmt2 . execute update (  )  ;  pstmt2 . close (  )  ;   string uuid = uuid . randomuuid (  )  . to string (  )  ;   string broadcast domain range = "pod" ;  if  ( " advanced" . equals ( network type )  )   {  broadcast domain range = "zone" ;   }  s   logger . debug ( " adding  physical network "  +  physical network id  +  " for  zone id " +  zone id )  ;   string sql = "insert into `cloud` . `physical   network`  ( id  uuid  data   center   id  vnet  broadcast   domain   range  state  name )  values  (  ?   ?   ?   ?   ?   ?   ?  ) " ;  pstmt update = conn . prepare statement ( sql )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set string ( 2 uuid )  ;  pstmt update . set long ( 3 zone id )  ;  pstmt update . set string ( 4 vnet )  ;  pstmt update . set string ( 5 broadcast domain range )  ;  pstmt update . set string ( 6 " enabled" )  ;  zone name = zone name  +  " - p ntwk"  +  physical network id ;  pstmt update . set string ( 7 zone name )  ;  s   logger . warn ( " statement is "  +  pstmt update . to string (  )  )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;  if  ( domain id  !  =  null && domain id . long value (  )   !  =  0 )   {  s   logger . debug ( " updating domain   id for physical network id = "  +  physical network id )  ;  sql = "update `cloud` . `physical   network` set domain   id =  ?  where id =  ? " ;  pstmt update = conn . prepare statement ( sql )  ;  pstmt update . set long ( 1 domain id )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   }  return physical network id ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical networks" e )  ;   }  finally  {  close auto closeable ( pstmt2 )  ;  close auto closeable ( pstmt update )  ;   }   }  
protected void   (  connection conn long physical network id long network id )  {   prepared statement pstmt update = null ;  try  {   string updatevlan = "update `cloud` . `vlan` set physical   network   id  =  "  +  physical network id  +  " where network   id  =  " +  network id ;  pstmt update = conn . prepare statement ( updatevlan )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   string update usr ip = "update `cloud` . `user   ip   address` set physical   network   id  =  "  +  physical network id  +  " where source   network   id  =  " +  network id ;  pstmt update = conn . prepare statement ( update usr ip )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   string update net = "update `cloud` . `networks` set physical   network   id  =  "  +  physical network id  +  " where id  =  " +  network id +  " and traffic   type  =  ' guest'" ;  pstmt update = conn . prepare statement ( update net )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical networks" e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
protected void   (  connection conn long physical network id  string traffic type  string xen public label  string kvm public label  string vmware public label )  {   prepared statement pstmt update = null ;  try  {  s   logger . debug ( " adding  physical network traffic types" )  ;   string insert trafic type = "insert into `cloud` . `physical   network   traffic   types`  ( physical   network   id  traffic   type  xen   network   label  kvm   network   label  vmware   network   label  uuid )  values  (   ?    ?    ?    ?    ?    ?  ) " ;  pstmt update = conn . prepare statement ( insert trafic type )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set string ( 2 traffic type )  ;  pstmt update . set string ( 3 xen public label )  ;  pstmt update . set string ( 4 kvm public label )  ;  pstmt update . set string ( 5 vmware public label )  ;  pstmt update . set string ( 6 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;  pstmt update . close (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical networks" e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
private void   (  connection conn )  {   result set rs = null ;  try  (  prepared statement pstmt = conn . prepare statement ( "select network   id from `cloud` . `ntwk   service   map` where service = ' firewall' and provider = ' junipersrx' " )  )  {  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  long net id = rs . get long ( 1 )  ;  try  (  prepared statement sel   net   pstmt = conn . prepare statement ( "select account   id  domain   id from `cloud` . `networks` where  ( guest   type = ' isolated' or guest   type = ' virtual' )  and traffic   type = ' guest' and vpc   id is null and  ( state = 'implemented' or state = ' shutdown' )  and id =  ?  " )  )  {  sel   net   pstmt . set long ( 1 net id )  ;  s   logger . debug ( " getting account   id  domain   id from networks table: " )  ;  try  (  result set rs nw = pstmt . execute query (  )  )  {  if  ( rs nw . next (  )  )   {  long account id = rs nw . get long ( 1 )  ;  long domain id = rs nw . get long ( 2 )  ;  s   logger . debug ( " adding default egress firewall rule for network "  +  net id )  ;  try  (  prepared statement insert   pstmt = conn . prepare statement ( "insert into firewall   rules  ( uuid  state  protocol  purpose  account   id  domain   id  network   id  xid  created  traffic   type )  values  (  ?   ' active'  'all'  ' firewall'   ?    ?    ?    ?   now (  )   ' egress' ) " )  )  {  insert   pstmt . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  insert   pstmt . set long ( 2 account id )  ;  insert   pstmt . set long ( 3 domain id )  ;  insert   pstmt . set long ( 4 net id )  ;  insert   pstmt . set string ( 5 uuid . randomuuid (  )  . to string (  )  )  ;  s   logger . debug ( " inserting default egress firewall rule "  +  insert   pstmt )  ;  insert   pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to set egress firewall rules " e )  ;   }  try  (  prepared statement sel   firewall   pstmt = conn . prepare statement ( "select id from firewall   rules where protocol = 'all' and network   id =  ? " )  )  {  sel   firewall   pstmt . set long ( 1 net id )  ;  try  (  result set rs id = sel   firewall   pstmt . execute query (  )  )  {  long firewall rule id ;  if  ( rs id . next (  )  )   {  firewall rule id = rs id . get long ( 1 )  ;  try  (  prepared statement insert   pstmt = conn . prepare statement ( "insert into firewall   rules   cidrs  ( firewall   rule   id source   cidr )  values  (  ?   '0 . 0 . 0 . 0 / 0' ) " )  )  {  insert   pstmt . set long ( 1 firewall rule id )  ;  s   logger . debug ( " inserting rule for cidr 0 . 0 . 0 . 0 / 0 for the new  firewall rule id = "  +  firewall rule id  +  " with statement " +  insert   pstmt )  ;  insert   pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to set egress firewall rules " e )  ;   }   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to set egress firewall rules " e )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to set egress firewall rules " e )  ;   }   }   }   }   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to set egress firewall rules " e )  ;   }   }  
private void   (  connection conn )  {  s   logger . debug ( " checking if host   details index exists  if not we will add it" )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "show index from `cloud` . `host   details` where key   name  =  'fk   host   details      host   id'" )  )  {  try  (  result set rs = pstmt . execute query (  )  )  {  if  ( rs . next (  )  )   {  s   logger . debug ( " index already exists on host   details  -  not adding new one" )  ;   }  else  {  try  (  prepared statement pstmt update = conn . prepare statement ( "alter table `cloud` . `host   details` add index `fk   host   details      host   id`  ( `host   id` ) " )  )  {  pstmt update . execute update (  )  ;  s   logger . debug ( " index did not exist on host   details  -  added new one" )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " failed to check / update the host   details index " e )  ;   }   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " failed to check / update the host   details index " e )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " failed to check / update the host   details index " e )  ;   }   }  
private void   (  connection conn )  {   list <  string >  index list = new  array list <  string >  (  )  ;  s   logger . debug ( " dropping index i   alert      last   sent if it exists" )  ;  index list . add ( "last   sent" )  ;  index list . add ( "i   alert      last   sent" )  ;   db upgrade utils . drop keys if exist ( conn "alert" index list false )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "alter table `cloud` . `alert` add index `i   alert      last   sent` ( `last   sent` ) " )  )  {  pstmt . execute update (  )  ;  s   logger . debug ( " added index i   alert      last   sent for table alert" )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " unable to add index i   alert      last   sent to alert table for the column last   sent" e )  ;   }   }  
private void   (  connection conn long host id long physical network id )  {   string insert srx = "insert into `cloud` . `external   firewall   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insert srx )  )  {  s   logger . debug ( " adding srx firewall device with host id "  +  host id  +  " in to physical network" +  physical network id )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " junipersrx firewall" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set string ( 9 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding srx firewall device " e )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 1 1 1 0 1 1 0 0 ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertpnsp )  )  {  s   logger . debug ( " adding  physical network service provider  junipersrx" )  ;  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 " junipersrx" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider  junipersrx" e )  ;   }   }  
private void   (  connection conn )  {  try  (  prepared statement select template infostmt = conn . prepare statement ( "select * from information   schema . columns where table   schema  =  'cloud' and table   name  =  'template   store   ref' and column   name  =  'download   url   created'" )  ;  result set template info results = select template infostmt . execute query (  )  ;  prepared statement add download url created to template storerefstatement = conn . prepare statement ( "alter table `cloud` . `template   store   ref` add column `download   url   created` datetime" )  ;  prepared statement add download url to template storerefstatement = conn . prepare statement ( "alter table `cloud` . `template   store   ref` add column `download   url` varchar ( 255 ) " )  ;  prepared statement select volume infostmt = conn . prepare statement ( "select * from information   schema . columns where table   schema  =  'cloud' and table   name  =  'volume   store   ref' and column   name  =  'download   url   created'" )  ;  result set volume info results = select volume infostmt . execute query (  )  ;  prepared statement add download url created to volume storerefstatement = conn . prepare statement ( "alter table `cloud` . `volume   store   ref` add column `download   url   created` datetime" )  )  {  if  (  ! template info results . next (  )  )   {  add download url created to template storerefstatement . execute update (  )  ;  add download url to template storerefstatement . execute update (  )  ;   }  if  (  ! volume info results . next (  )  )   {  add download url created to volume storerefstatement . execute update (  )  ;   }   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " adding columns for  extract  template  and  volume functionality failed" )  ;   }   }  
private void   ( final  connection conn )  {  final  list <  string >  index list = new  array list <  string >  (  )  ;  s   logger . debug ( " dropping index i   vm   instance      instance   name from vm   instance table if it exists" )  ;  index list . add ( "i   vm   instance      instance   name" )  ;   db upgrade utils . drop keys if exist ( conn "vm   instance" index list false )  ;  try  (  prepared statement pstmt = conn . prepare statement ( "alter table `cloud` . `vm   instance` add index `i   vm   instance      instance   name` ( `instance   name` ) " )  )  {  pstmt . execute update (  )  ;  s   logger . debug ( " added index i   vm   instance      instance   name to vm   instance table" )  ;   }  catch  (  final sql exception e )   {  throw new  cloud runtime exception ( " unable to add index i   vm   instance      instance   name to vm   instance table for the column instance   name" e )  ;   }   }  
private void   ( final  connection conn )  {   result set rs = null ;  try  (  prepared statement add redundant col to vpc offering pstmt = conn . prepare statement ( "alter table `cloud` . `vpc   offerings` add column `redundant   router   service` tinyint ( 1 )  default 0" )  ;  prepared statement add redundant col to vpc pstmt = conn . prepare statement ( "alter table `cloud` . `vpc` add column `redundant` tinyint ( 1 )  default 0" )  ;  prepared statement add redundant col to nw pstmt = conn . prepare statement ( "alter table `cloud` . `networks` add column `redundant` tinyint ( 1 )  default 0" )  ;  prepared statement redundancy per nw pstmt = conn . prepare statement ( "select distinct nw . network   offering   id from networks nw join network   offerings off "  +  "on nw . network   offering   id  =  off . id where off . redundant   router   service  =  1" )  ;  prepared statement update nw redundancy pstmt = conn . prepare statement ( "update networks set redundant  =  1 where network   offering   id  =   ? " )  )  {  add redundant col to vpc pstmt . execute update (  )  ;  add redundant col to vpc offering pstmt . execute update (  )  ;  add redundant col to nw pstmt . execute update (  )  ;  rs = redundancy per nw pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  final long nw offering id = rs . get long ( "nw . network   offering   id" )  ;  update nw redundancy pstmt . set long ( 1 nw offering id )  ;  update nw redundancy pstmt . execute update (  )  ;   }   }  catch  (  final sql exception e )   {  e . print stack trace (  )  ;  throw new  cloud runtime exception ( " adding redundancy to vpc  networks and vpc   offerings failed" e )  ;   }   }  
@ override @db public void   ( final  virtual router router final  network guest network )  {  if  (    router network dao . find by router and network ( router . get id (  )  guest network . get id (  )  )   =  =  null )   {  final  network offering off 
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  nic detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  user vm detailvo ( resource id key value display )  )  ;   }  
public void   (  nic data nics )  {  this . nics . add ( nics )  ;   }  
public void   (  security group data security groups )  {  this . security group list . add ( security groups )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new vm snapshot detailsvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  auto scale vm group detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  auto scale vm profile detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  disk offering detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  firewall rule detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  guest os detailvo ( resource id key value )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new lb health check policy detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  networkacl item detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  networkacl list detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  remote access vpn detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  site2 site customer gateway detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  site2 site vpn connection detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  site2 site vpn gateway detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  snapshot policy detailvo ( resource id key value )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  user detailvo ( resource id key value )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  vpc gateway detailvo ( resource id key value display )  )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  vpc detailvo ( resource id key value display )  )  ;   }  
protected void   ( r detail )  {  if  ( detail  =  =  null )   {  return ;   }  r existing detail = find detail ( detail . get resource id (  )  detail . get name (  )  )  ;  if  ( existing detail  !  =  null )   {  remove ( existing detail . get id (  )  )  ;   }  persist ( detail )  ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  image store detailvo ( resource id key value display )  )  ;   }  
protected  datato   (  datato datato )  {  if  ( datato  !  =  null && datato . get hypervisor type (  )  . equals (  hypervisor .  hypervisor type . v mware )  )   {   data storeto data storeto = datato . get data store (  )  ;  if  ( data storeto  !  =  null && data storeto instanceof  primary data storeto )   {   primary data storeto primary data storeto =  (  primary data storeto ) data storeto ;   boolean value =  capacity manager .  vmware create clone full . value in ( primary data storeto . get id (  )  )  ;  primary data storeto . set full clone flag ( value )  ;   }   }  return datato ;   }  
@ override public void   (  data store store )  {  long store id = store . get id (  )  ;   list < vm templatevo >  rtng tmplts =    template dao . list all systemvm templates (  )  ;  for  (  vm templatevo tmplt : rtng tmplts )   {   template data storev
public void   (  data store store  hostvo host )  {   storage pool hostvo storage pool hostvo = new  storage pool hostvo ( store . get id (  )  host . get id (  )  uuid . randomuuid (  )  . to string (  )  )  ;  storage pool host dao . persist ( storage pool hostvo )  ;   }  
@ override public void   (  object data )  {  payload = data ;   }  
@ override public void   ( long resource id  string key  string value boolean display )  {  super . add detail ( new  primary data store detailvo ( resource id key value display )  )  ;   }  
@ override public void   (  object data )  {  payload = data ;   }  
private void   ( final  cluster service pdu pdu )  {  synchronized  (    cluster pdu incoming queue )   {     cluster pdu incoming queue . add ( pdu )  ;     cluster pdu incoming queue . notify all (  )  ;   }   }  
private void   ( final  cluster service pdu pdu )  {  synchronized  (    cluster pdu outgoing queue )   {     cluster pdu outgoing queue . add ( pdu )  ;     cluster pdu outgoing queue . notify all (  )  ;   }   }  
public void   (  class <  ?  >  clazz  string field boolean ascending )  {  if  ( field  =  =  null )   {  return ;   }   field f ;   pair <  class <  ?  >   field >  pair =  reflect util . get any field ( clazz field )  ;  assert  ( pair  !  =  null )  : " can't find field "  +  field  +  " in " +  clazz . get name (  )  ;  clazz = pair . first (  )  ;  f = pair . second (  )  ;   column column = f . get annotation (  column . class )  ;   string name = column  !  =  null  ?  column . name (  )  : field ;   string builder order = new  string builder (  )  ;  if  ( column  =  =  null || column . table (  )   =  =  null || column . table (  )  . length (  )   =  =  0 )   {  order . append (  db util . get table name ( clazz )  )  ;   }  else  {  order . append ( column . table (  )  )  ;   }  order . append ( " . " )  . append ( name )  . append ( ascending  ?  " asc " : " desc " )  ;  if  (    order by  =  =  null )   {     order by = order . insert ( 0 " order by " )  . to string (  )  ;   }  else  {     order by = order . insert ( 0    order by  +  "  " )  . to string (  )  ;   }   }  
public int   (  )  {  synchronized  ( this )   {  reference count +  +  ;  return reference count ;   }   }  
@db (  )  protected void   ( final  string builder sql final  filter filter )  {  if  ( filter  !  =  null )   {  if  ( filter . get order by (  )   !  =  null )   {  sql . append ( filter . get order by (  )  )  ;   }  if  ( filter . get offset (  )   ! 
@db (  )  protected  list <  object >    ( final  string builder sql  search criteria <  ?  >  sc )  {  if  ( sc  =  =  null )  return null ;   pair <  group by <  ?   ?   ?  >   list <  object >  >  group bys = sc . get group by (  )  ;  if  ( group bys 
@db (  )  protected int   ( int count  prepared statement pstmt  collection <  join builder <  search criteria <  ?  >  >  >  joins )  throws sql exception  {  for  (   join builder <  search criteria <  ?  >  >  join : joins )   {  for  (  final  pair < 
@db (  )  protected void   (  string builder str  collection <  join builder <  search criteria <  ?  >  >  >  joins )  {  int from index = str . last index of ( "where" )  ;  if  ( from index  =  =   - 1 )   {  from index = str . length (  )  ;  str . ap
@ deprecated public void   (  attribute attr  op op  object .  .  .  values )  {   string name =  integer . to string (    counter +  +  )  ;  add condition ( name " and " attr op )  ;  set parameters ( name values )  ;   }  
protected void   (  string condition name  string cond  attribute attr  op op )  {   condition condition = new  condition ( condition name cond attr op )  ;     additionals . add ( condition )  ;   }  
@ deprecated public void   (  string field  op op  object .  .  .  values )  {   string name =  integer . to string (    counter +  +  )  ;  add condition ( name " or " field op )  ;  set parameters ( name values )  ;   }  
protected static void   (  string builder sql  string from table  string to table  string join type  primary key join column[] pkjcs )  {  if  ( "right" . equals ignore case ( join type )  )   {  sql . append ( " right join " )  . append ( to table )  . append ( " on " )  ;   }  else if  ( "left" . equals ignore case ( join type )  )   {  sql . append ( " left join " )  . append ( to table )  . append ( " on " )  ;   }  else  {  sql . append ( " inner join " )  . append ( to table )  . append ( " on " )  ;   }  for  (   primary key join column pkjc : pkjcs )   {  sql . append ( from table )  . append ( " . " )  . append ( pkjc . name (  )  )  ;   string ref column =  db util . get reference column ( pkjc )  ;  sql . append ( " = " )  . append ( to table )  . append ( " . " )  . append ( ref column )  . append ( " " )  ;   }   }  
public void   (  transaction legacy txn )  {     txns . put ( txn . get id (  )  txn )  ;   }  
public void   ( int index  command cmd )  {     cmds . add ( index cmd )  ;   }  
public void   (  list <  command >  cmds )  {  int i = 0 ;  for  (   command cmd : cmds )   {  add command (  integer . to string ( i +  +  )  cmd )  ;   }   }  
public void   (  string key  subscription node child node )  {     children . put ( key child node )  ;   }  
public void   (  message subscriber subscriber )  {  if  (  !    subscribers . contains ( subscriber )  )     subscribers . add ( subscriber )  ;   }  
@ override public  < t >  rpc client call   (  rpc callback listener < t >  listener )  {  assert  ( listener  !  =  null )  ;     callback listeners . add ( listener )  ;  return this ;   }  
public void   (  string package name )  {  packages . add ( package name )  ;   }  
public void   (  transport pdu pdu )  {  synchronized  ( this )   {     output queue . add ( pdu )  ;   }  signal output process request (  )  ;   }  
@ override public  quota tariffvo   ( final  quota tariffvo plan )  {  if  ( plan . get id obj (  )   !  =  null )   {  throw new  illegal state exception ( " the  quota tariffvo being added should not have an  id set " )  ;   }  return  transaction . exe
public void   (  string name  string value )  {  details . put ( name value )  ;   }  
@ override public void   (  module definition def )  {  children . put ( def . get name (  )  def )  ;   }  
public void   ( final  role type role type final  string command name )  {  if  ( role type  =  =  null ||  strings . is null or empty ( command name )  )   {  return ;   }  final  set <  string >  commands = annotation role based apis map . get ( role type )  ;  if  ( commands  !  =  null &&  ! commands . contains ( command name )  )   {  commands . add ( command name )  ;   }   }  
public void   (  api response response api response )  {  this . api response . add ( api response )  ;   }  
public void   (  api parameter response param )  {  this . params . add ( param )  ;   }  
public void   (  api response response child api response )  {  if  ( this . api response  =  =  null )   {  this . api response = new  hash set <  api response response >  (  )  ;   }  this . api response . add ( child api response )  ;   }  
private void   ( final  rootca provider provider final  string name final  object o )  throws  illegal access exception   no such field exception  {   field f =  rootca provider . class . get declared field ( name )  ;  f . set accessible ( true )  ;  f . set ( provider o )  ;   }  
public void   (  quota balancevo credit )  {   quota credits response cr = new  quota credits response (  )  ;  cr . set credits ( credit . get credit balance (  )  )  ;  cr . set updated on ( credit . get updated on (  )   =  =  null  ?  null : new  date ( credit . get updated on (  )  . get time (  )  )  )  ;  credits . add ( 0 cr )  ;   }  
@ override public  quota credits response   (  long account id  long domain id  double amount  long updated by  boolean enforce )  {   date desposited on =    quota service . compute adjusted time ( new  date (  )  )  ;   quota balancevo qb =    quota bal
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
@ override public  baremetal rct response   (  add baremetal rct cmd cmd )  {  try  {   list <  baremetal rctvo >  existings = rct dao . list all (  )  ;  if  (  ! existings . is empty (  )  )   {  throw new  cloud runtime exception (  string . format ( "
@ override @db public  baremetal dhcpvo   (  add baremetal dhcp cmd cmd )  {   physical networkvo p network = null ;  long zone id ;  if  ( cmd . get physical network id (  )   =  =  null || cmd . get url (  )   =  =  null || cmd . get username (  )   =  
@ override public boolean   (  network network  nic profile nic  virtual machine profile profile  deploy destination dest  reservation context context )  throws  resource unavailable exception  {   long zone id = profile . get virtual machine (  )  . get 
@ override @db public  baremetal pxevo   (  add baremetal pxe cmd cmd )  {   add baremetal kick start pxe cmd kcmd =  (  add baremetal kick start pxe cmd ) cmd ;   physical networkvo p network = null ;  long zone id ;  if  ( cmd . get physical network id 
@ override @db public  baremetal pxevo   (  add baremetal pxe cmd cmd )  {   add baremetal pxe ping server cmd pcmd =  (  add baremetal pxe ping server cmd ) cmd ;   physical networkvo p network = null ;  long zone id ;  if  ( cmd . get physical network i
@ override public  baremetal pxevo   (  add baremetal pxe cmd cmd )  {  return get service by type ( cmd . get device type (  )  )  . add pxe server ( cmd )  ;   }  
@ override public boolean   (  nic profile nic  virtual machine profile profile )  {   user vmvo vm =    vm dao . find by id ( profile . get virtual machine (  )  . get id (  )  )  ;     vm dao . load details ( vm )  ;   string service offering =    servi
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
public void   (  nfs storage pool pool )  {  synchronized  (    storage pool )   {     storage pool . put ( pool .    pooluuid pool )  ;   }   }  
public boolean   ( final  string vm name final  string vm id final  string guestip final  string guestip6 final  string sig final  string seq final  string mac final  string rules final  string vif final  string brname final  string sec ips )  {  if  (  !    can bridge firewall )   {  return false ;   }  final  string new rules = rules . replace ( " " " ; " )  ;  final  script cmd = new  script (    security group path    timeout s   logger )  ;  cmd . add ( "add   network   rules" )  ;  cmd . add ( " -  - vmname" vm name )  ;  cmd . add ( " -  - vmid" vm id )  ;  cmd . add ( " -  - vmip" guestip )  ;  if  (  string utils . is not blank ( guestip6 )  )   {  cmd . add ( " -  - vmip6" guestip6 )  ;   }  cmd . add ( " -  - sig" sig )  ;  cmd . add ( " -  - seq" seq )  ;  cmd . add ( " -  - vmmac" mac )  ;  cmd . add ( " -  - vif" vif )  ;  cmd . add ( " -  - brname" brname )  ;  cmd . add ( " -  - nicsecips" sec ips )  ;  if  ( new rules  !  =  null &&  ! new rules . is empty (  )  )   {  cmd . add ( " -  - rules" new rules )  ;   }  final  string result = cmd . execute (  )  ;  if  ( result  !  =  null )   {  return false ;   }  return true ;   }  
public void   (  object comp )  {  components . put ( comp . get class (  )  . to string (  )  comp )  ;   }  
public boolean   (  object device )  {   object dev = devices . get ( device . get class (  )  . to string (  )  )  ;  if  ( dev  =  =  null )   {   list <  object >  devs = new  array list <  object >  (  )  ;  devs . add ( device )  ;  devices . put ( device . get class (  )  . to string (  )  devs )  ;   }  else  {   list <  object >  devs =  (  list <  object >  ) dev ;  devs . add ( device )  ;   }  return true ;   }  
public void   (  string feature )  {     features . add ( feature )  ;   }  
public void   (  hyperv enlightenment feature def hyperv enlightenment feature def )  {  this . hyperv enlightenment feature def = hyperv enlightenment feature def ;   }  
public void   (  string mac address  string vr ip )  {  addresses . put ( mac address vr ip )  ;   }  
private void   (  string uuid  storage pool information pool )  {  synchronized  (    storage pools )   {  if  (  !    storage pools . contains key ( uuid )  )   {     storage pools . put ( uuid pool )  ;   }   }   }  
protected boolean   (  string vm name  string vm id  string guest ip  string signature  string seqno  string vif mac address  string rules  string vif device name  string bridge name )  throws  xml rpc exception  {  if  (  !    can bridge firewall )   {  return false ;   }   string new rules = rules . replace ( " " " ; " )  ;  return  ovm security group . add network rules (    conn vm name vm id guest ip signature seqno vif mac address new rules vif device name bridge name )  ;   }  
public static boolean   (  connection c  string vm name  string vm id  string guest ip  string signature  string seqno  string vif mac address  string new rules  string vif device name  string bridge name )  throws  xml rpc exception  {   object[] params =  { vm name vm id guest ip signature seqno vif mac address new rules vif device name bridge name }  ;  return  (  boolean ) c . call ( " ovm security group . add   network   rules" params )  ;   }  
public  list <  string >    (  string server )  {  if  (  ! ntp hosts . contains ( server )  )   {  ntp hosts . add ( server )  ;   }  return ntp hosts ;   }  
public  boolean   (  string host )  throws  ovm3 resource exception  {  get pool member list (  )  ;  pool hosts . add ( host )  ;  return set pool member list (  )  ;   }  
public  boolean   (  string remote  string local )  throws  ovm3 resource exception  {  return null is true call wrapper ( "add   repository" remote local )  ;   }  
public  boolean   (  string image )  {  return add disk ( image "w ! " )  ;   }  
private  boolean   (  string image  string mode )  {   string dev name = null ;  disk count = disk zero  +  vm disks . size (  )  ;  if  ( get vm domain type (  )  . contains ( "hvm" )  )   {  disk count +  = 2 ;  dev name =  character . to string (  ( char ) disk count )  ;   }  else  {  dev name = "xvd"  +   character . to string (  ( char ) disk count )  ;   }  if  ( image . ends with ( " . iso" )  )   {  dev name = dev name  +  ":cdrom" ;  mode = "r" ;   }  return add disk to disks ( image dev name mode )  ;   }  
private  boolean   (  string image  string dev name  string mode )  {  for  (   string disk : vm disks )   {  if  ( disk . contains ( image )  )   {  logger . debug ( vm name  +  " already has disk "  +  image +  ":" +  dev name +  ":" +  mode )  ;  return true ;   }   }  vm disks . add ( "file:"  +  image  +  " " +  dev name +  " " +  mode )  ;  vm params . put ( "disk" vm disks )  ;  return true ;   }  
public  boolean   (  string image )  {  return add disk ( image "r ! " )  ;   }  
public  boolean   (  string image )  {   boolean ret = false ;  if  ( disk count  >  disk zero )   {   integer o vm disk = disk count ;  disk count = disk zero ;  ret = add disk ( image "w" )  ;  disk count = o vm disk ;   }  else  {  ret = add disk ( image "w" )  ;   }  return ret ;   }  
public  boolean   (  integer id  string bridge  string mac )  {  if  ( get vif id by mac ( mac )   >  0 )   {  logger . debug ( " already nic with mac present: "  +  mac )  ;  return false ;   }   string vif = "mac = "  +  mac  +  " bridge = " +  bridge ;  xvm vifs[id] = vif ;  return true ;   }  
private  boolean   (  )  throws  ovm3 resource exception  {   list <  string >  members = new  array list <  string >  (  )  ;  try  {   connection m = new  connection ( config . get ovm3 pool vip (  )  c . get port (  )  c . get user name (  )  c . get password (  )  )  ;   pool pool master = new  pool ( m )  ;  if  ( pool master . is ina pool (  )  )   {  members . add all ( pool master . get pool member list (  )  )  ;  if  (  ! pool master . get pool member list (  )  . contains ( c . get ip (  )  )  && c . get ip (  )  . equals ( config . get ovm3 pool vip (  )  )  )   {  members . add ( c . get ip (  )  )  ;   }   }  else  {  logger . warn ( c . get ip (  )   +  " noticed master "  +  config . get ovm3 pool vip (  )  +  " is not part of pool" )  ;  return false ;   }  for  (   string member : members )   {   connection x = new  connection ( member c . get port (  )  c . get user name (  )  c . get password (  )  )  ;   pool poolm = new  pool ( x )  ;  if  ( poolm . is ina pool (  )  )   {  poolm . set pool member list ( members )  ;  logger . debug ( " added "  +  members  +  " to pool " +  poolm . get pool id (  )  +  " on member " +  member )  ;   }  else  {  logger . warn ( member  +  " unable to be member of a pool it's not in" )  ;  return false ;   }   }   }  catch  (   exception e )   {  throw new  ovm3 resource exception ( " unable to add members: "  +  e . get message (  )  e )  ;   }  return true ;   }  
public void   (  )  {  multi res . add ( null )  ;   }  
public void   (  string e )  {  multi res . add ( e )  ;   }  
public void   (  virtual machineto vmspec  string uuid  string dsuuid  string path )  {   array list <  diskto >  disks ;  if  ( vmspec . get disks (  )   !  =  null )   {  disks = new  array list <  diskto >  (  arrays . as list ( vmspec . get disks (  )  )  )  ;   }  else  {  disks = new  array list <  diskto >  (  )  ;   }   diskto disk = new  diskto (  )  ;   volume objectto volume = new  volume objectto (  )  ;   nfsto nfs data store = new  nfsto (  )  ;  nfs data store . set uuid ( dsuuid )  ;  volume . set data store ( nfs data store )  ;  volume . set path ( path )  ;  volume . set uuid ( uuid )  ;  disk . set data ( volume )  ;  disk . set type (  volume .  type . root )  ;  disks . add ( disk )  ;  vmspec . set disks ( disks . to array ( new  diskto[disks . size (  ) ] )  )  ;   }  
public void   (  virtual machineto vmspec  list <  string >  list )  {  for  (   string disk : list )   {   string parts[] = disk . split ( "[:  . ] + " )  ;   string partdeux[] = parts[1] . split ( " / " )  ;   string diskuuid = partdeux[partdeux . length  -  1] ;   string dsuuid = partdeux[3] ;   string path = parts[1] . replace ( " / "  +  diskuuid "" )  ;  add disk to spec ( vmspec diskuuid dsuuid path )  ;   }   }  
public void   (  virtual machineto vmspec  string mac  string bridge  string vlan )  {   array list <  nicto >  nics ;  if  ( vmspec . get nics (  )   !  =  null )   {  nics = new  array list <  nicto >  (  arrays . as list ( vmspec . get nics (  )  )  )  ;   }  else  {  nics = new  array list <  nicto >  (  )  ;   }   nicto nic = new  nicto (  )  ;  nic . set type (  networks .  traffic type .  guest )  ;  nic . set mac ( mac )  ;  nic . set device id ( nics . size (  )  )  ;  nics . add ( nic )  ;  vmspec . set nics ( nics . to array ( new  nicto[nics . size (  ) ] )  )  ;   }  
public void   (  virtual machineto vmspec  list <  string >  list )  {  for  (   string vif : list )   {   string parts[] = vif . split ( "[  =  . ] + " )  ;  add nic to spec ( vmspec parts[1] parts[3] parts[4] )  ;   }   }  
@ override public  answer   (  dhcp entry command cmd )  {  return new  answer ( cmd )  ;   }  
@ override public  security group rule answer   ( final  security group rules cmd cmd final  simulator info info )  {  if  (  ! info . is enabled (  )  )   {  return new  security group rule answer ( cmd false " disabled"  security group rule answer .  fa
public boolean   ( final ha config . ha state new ha state final ha config . ha state old ha state final ha config .  event event final ha resource counter counter )  {  final  simulatorha state response state response = new  simulatorha state response (  )  ;  state response . set ha state ( new ha state )  ;  state response . set previous ha state ( old ha state )  ;  state response . set ha event ( event )  ;  if  ( counter  !  =  null )   {  state response . set activity counter ( counter . get activity check counter (  )  )  ;  state response . set recovery counter ( counter . get recovery counter (  )  )  ;   }  state response . set object name ( "hastatetransition" )  ;  return state transitions . add ( state response )  ;   }  
private boolean   ( final ha config vo final boolean status final ha config . ha state old state final ha config . ha state new state final ha config .  event event )  {  if  ( vo . get resource type (  )   !  =  ha resource .  resource type .  host )   {  return false ;   }  final  simulatorha state ha state = hostha state map . get ( vo . get resource id (  )  )  ;  if  ( ha state  =  =  null ||  ! status )   {  return false ;   }  final ha resource counter counter = ha manager . getha counter ( vo . get resource id (  )  vo . get resource type (  )  )  ;  return ha state . add state transition ( new state old state event counter )  ;   }  
@ override @db public  ucs manager response   (  add ucs manager cmd cmd )  {   query builder <  ucs managervo >  q =  query builder . create (  ucs managervo . class )  ;  q . and ( q . entity (  )  . get url (  )   op . eq cmd . get url (  )  )  ;   ucs
@ override public  list <  managed object reference >    (  vmware context service context long dc id  long pod id  long cluster id  string host inventory path )  throws  exception  {  if  ( service context  =  =  null )   {  throw new  cloud runtime exce
@ override @db public  vmware datacentervo   (  add vmware dc cmd cmd )  throws  resource in use exception  {   vmware datacentervo vmware dc = null ;   long zone id = cmd . get zone id (  )  ;   string user name = cmd . get username (  )  ;   string pass
@db public  cisco nexusvsm devicevo   ( long cluster id  string ipaddress  string username  string password  string v center ipaddr  string v center dc name )  {   clustervo cluster =    cluster dao . find by id ( cluster id )  ;  if  ( cluster  =  =  nul
private void   ( boolean add  list <  host internet scsi hba static target >  targets  list <  hostmo >  hosts )  throws  exception  {   executor service executor service =  executors . new fixed thread pool ( hosts . size (  )  )  ;  final  list <  exception >  exceptions = new  array list <  >  (  )  ;  for  (   hostmo host : hosts )   {   host storage systemmo host storage system = host . get host storage systemmo (  )  ;  boolean i scsi hba configured = false ;  for  (   host host bus adapter hba : host storage system . get storage device info (  )  . get host bus adapter (  )  )   {  if  ( hba instanceof  host internet scsi hba &&  (  (  host internet scsi hba ) hba )  . is is software based (  )  )   {  i scsi hba configured = true ;  final  string i scsi hba device = hba . get device (  )  ;  final  host storage systemmo hss = host storage system ;  executor service . submit ( new  thread (  (  )   -  >   {  try  {  if  ( add )   {  hss . add internet scsi static targets ( i scsi hba device targets )  ;   }  else  {  hss . remove internet scsi static targets ( i scsi hba device targets )  ;   }   }  catch  (   exception ex )   {  synchronized  ( exceptions )   {  exceptions . add ( ex )  ;   }   }   }   )  )  ;   }   }  if  (  ! i scsi hba configured )   {  throw new  exception ( " an iscsi hba must be configured before a host can use iscsi storage . " )  ;   }   }  executor service . shutdown (  )  ;  if  (  ! executor service . await termination (  long . max   value  time unit . minutes )  )   {  throw new  exception ( " the system timed out before completing the task 'add remove internet scsi targets to all hosts' . " )  ;   }  if  ( exceptions . size (  )   >  0 )   {  throw new  exception ( exceptions . get ( 0 )  . get message (  )  )  ;   }   }  
public  add vmware dc cmd   (  )  {  return  mockito . mock (  add vmware dc cmd . class )  ;   }  
protected void   (  connection conn  map <  citrix resource base  map <  string  string >  >  resources )  throws  xenapi exception   xml rpc exception  {   map <  pool  pool .  record >  hps =  pool . get all records ( conn )  ;  assert  ( hps . size (  )   =  =  1 )  : " how can it be more than one but it's actually "  +  hps . size (  )  ;   string pool uuid = hps . values (  )  . iterator (  )  . next (  )  . uuid ;  for  (   map <  string  string >  details : resources . values (  )  )   {  details . put ( "pool" pool uuid )  ;   }   }  
private void   (  string pool uuid  xen server connection conn )  {  if  ( pool uuid  =  =  null )  return ;  if  ( s   logger . is debug enabled (  )  )   {  s   logger . debug ( " add master connection through "  +  conn . get ip (  )   +  " for pool ( " +  conn . get pool uuid (  )  +  " ) " )  ;   }  synchronized  (    conns )   {     conns . put ( pool uuid conn )  ;   }   }  
public boolean   ( final  cloudian group group )  {  if  ( group  =  =  null )   {  return false ;   }  log . debug ( " adding  cloudian group: "  +  group )  ;  try  {  final  http response response = put ( " / group" group )  ;  return response . get status line (  )  . get status code (  )   =  =   http status . sc   ok ;   }  catch  (  final io exception e )   {  log . error ( " failed to add  cloudian group due to:" e )  ;  check response time out ( e )  ;   }  return false ;   }  
public boolean   ( final  cloudian user user )  {  if  ( user  =  =  null )   {  return false ;   }  log . debug ( " adding  cloudian user: "  +  user )  ;  try  {  final  http response response = put ( " / user" user )  ;  return response . get status line (  )  . get status code (  )   =  =   http status . sc   ok ;   }  catch  (  final io exception e )   {  log . error ( " failed to add  cloudian user due to:" e )  ;  check response time out ( e )  ;   }  return false ;   }  
private boolean   ( final  domain domain )  {  if  ( domain  =  =  null ||  ! is enabled (  )  )   {  return false ;   }  final  cloudian client client = get client (  )  ;  final  cloudian group group = new  cloudian group (  )  ;  group . set group id ( domain . get uuid (  )  )  ;  group . set group name ( domain . get path (  )  )  ;  group . set active ( true )  ;  return client . add group ( group )  ;   }  
private boolean   ( final  account account final  domain domain )  {  if  ( account  =  =  null || domain  =  =  null ||  ! is enabled (  )  )   {  return false ;   }  final  user account user = user dao . list by account ( account . get id (  )  )  . get ( 0 )  ;  final  cloudian client client = get client (  )  ;  final  string full name =  string . format ( "%s %s  ( %s ) " account user . get firstname (  )  account user . get lastname (  )  account . get account name (  )  )  ;  final  cloudian user user = new  cloudian user (  )  ;  user . set user id ( account . get uuid (  )  )  ;  user . set group id ( domain . get uuid (  )  )  ;  user . set full name ( full name )  ;  user . set email addr ( account user . get email (  )  )  ;  user . set user type (  cloudian user . user )  ;  user . set active ( true )  ;  return client . add user ( user )  ;   }  
@ test public void   (  )  {  wire mock rule . stub for ( put ( url equal to ( " / group" )  )  . will return ( a response (  )  . with status ( 200 )  . with body ( "" )  )  )  ;  final  cloudian group group = get test group (  )  ;  boolean result = cli
@ test public void   (  )  throws  exception  {  wire mock rule . stub for ( put ( url equal to ( " / group" )  )  . will return ( a response (  )  . with status ( 400 )  . with body ( "" )  )  )  ;  final  cloudian group group = get test group (  )  ;  b
@ test public void   (  )  {  wire mock rule . stub for ( put ( url equal to ( " / user" )  )  . will return ( a response (  )  . with status ( 200 )  . with body ( "" )  )  )  ;  final  cloudian user user = get test user (  )  ;  boolean result = client 
@ test public void   (  )  {  wire mock rule . stub for ( put ( url equal to ( " / user" )  )  . will return ( a response (  )  . with status ( 400 )  . with body ( "" )  )  )  ;  final  cloudian user user = get test user (  )  ;  boolean result = client 
private void   ( final  list <  item >  metrics list )  {   long total cpu limit = 0l ;   long total memory limit = 0l ;  for  (  final  domain joinvo domain : domain dao . list all (  )  )   {  if  ( domain  =  =  null || domain . get level (  )   !  =  1 )   {  continue ;   }  long cpu limit =  apidb utils . find correct resource limit for domain ( domain . get cpu limit (  )  false  resource .  resource type . cpu domain . get id (  )  )  ;  if  ( cpu limit  >  0 )   {  total cpu limit +  = cpu limit ;   }  long memory limit =  apidb utils . find correct resource limit for domain ( domain . get memory limit (  )  false  resource .  resource type . memory domain . get id (  )  )  ;  if  ( memory limit  >  0 )   {  total memory limit +  = memory limit ;   }   }  metrics list . add ( new  item domain limit cpu ( total cpu limit )  )  ;  metrics list . add ( new  item domain limit memory ( total memory limit )  )  ;   }  
private void   ( final  list <  item >  metrics list final long dc id final  string zone name final  string zone uuid )  {  int total = 0 ;  int up = 0 ;  int down = 0 ;  for  (  final  host joinvo host : host join dao . list all (  )  )   {  if  ( host  =  =  null || host . get type (  )   !  =   host .  type .  routing || host . get zone id (  )   !  =  dc id )   {  continue ;   }  total +  +  ;  if  ( host . get status (  )   =  =   status .  up )   {  up +  +  ;   }  else if  ( host . get status (  )   =  =   status .  disconnected || host . get status (  )   =  =   status .  down )   {  down +  +  ;   }  final  string cpu factor =  string . value of (  capacity manager .  cpu overprovisioning factor . value in ( host . get cluster id (  )  )  )  ;  final  capacityvo cpu capacity = capacity dao . find by host id type ( host . get id (  )   capacity . capacity   type   cpu )  ;  if  ( cpu capacity  !  =  null )   {  metrics list . add ( new  item host cpu ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  cpu factor used cpu capacity . get used capacity (  )  )  )  ;  metrics list . add ( new  item host cpu ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  cpu factor total cpu capacity . get total capacity (  )  )  )  ;   }  else  {  metrics list . add ( new  item host cpu ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  cpu factor used 0l )  )  ;  metrics list . add ( new  item host cpu ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  cpu factor total 0l )  )  ;   }  final  string memory factor =  string . value of (  capacity manager .  mem overprovisioning factor . value in ( host . get cluster id (  )  )  )  ;  final  capacityvo mem capacity = capacity dao . find by host id type ( host . get id (  )   capacity . capacity   type   memory )  ;  if  ( mem capacity  !  =  null )   {  metrics list . add ( new  item host memory ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  memory factor used mem capacity . get used capacity (  )  )  )  ;  metrics list . add ( new  item host memory ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  memory factor total mem capacity . get total capacity (  )  )  )  ;   }  else  {  metrics list . add ( new  item host memory ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  memory factor used 0l )  )  ;  metrics list . add ( new  item host memory ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  memory factor total 0l )  )  ;   }  metrics list . add ( new  item hostvm ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  vm dao . list by host id ( host . get id (  )  )  . size (  )  )  )  ;  final  capacityvo core capacity = capacity dao . find by host id type ( host . get id (  )   capacity . capacity   type   cpu   core )  ;  if  ( core capacity  !  =  null )   {  metrics list . add ( new  itemvm core ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  used core capacity . get used capacity (  )  )  )  ;  metrics list . add ( new  itemvm core ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  total core capacity . get total capacity (  )  )  )  ;   }  else  {  metrics list . add ( new  itemvm core ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  used 0l )  )  ;  metrics list . add ( new  itemvm core ( zone name zone uuid host . get name (  )  host . get uuid (  )  host . get private ip address (  )  total 0l )  )  ;   }   }  final  list <  capacity dao impl .  summed capacity >  cpu capacity = capacity dao . find capacity by (  ( int )  capacity . capacity   type   cpu dc id null null )  ;  if  ( cpu capacity  !  =  null && cpu capacity . size (  )   >  0 )   {  metrics list . add ( new  item host cpu ( zone name zone uuid null null null null allocated cpu capacity . get ( 0 )  . get allocated capacity (  )   !  =  null  ?  cpu capacity . get ( 0 )  . get allocated capacity (  )  : 0 )  )  ;   }  final  list <  capacity dao impl .  summed capacity >  mem capacity = capacity dao . find capacity by (  ( int )  capacity . capacity   type   memory dc id null null )  ;  if  ( mem capacity  !  =  null && mem capacity . size (  )   >  0 )   {  metrics list . add ( new  item host memory ( zone name zone uuid null null null null allocated mem capacity . get ( 0 )  . get allocated capacity (  )   !  =  null  ?  mem capacity . get ( 0 )  . get allocated capacity (  )  : 0 )  )  ;   }  final  list <  capacity dao impl .  summed capacity >  core capacity = capacity dao . find capacity by (  ( int )  capacity . capacity   type   cpu   core dc id null null )  ;  if  ( core capacity  !  =  null && core capacity . size (  )   >  0 )   {  metrics list . add ( new  itemvm core ( zone name zone uuid null null null allocated core capacity . get ( 0 )  . get allocated capacity (  )   !  =  null  ?  core capacity . get ( 0 )  . get allocated capacity (  )  : 0 )  )  ;   }  metrics list . add ( new  item host ( zone name zone uuid online up )  )  ;  metrics list . add ( new  item host ( zone name zone uuid offline down )  )  ;  metrics list . add ( new  item host ( zone name zone uuid total total )  )  ;   }  
private void   ( final  list <  item >  metrics list final long dc id final  string zone name final  string zone uuid )  {  metrics list . add ( new  item private ip ( zone name zone uuid allocated private ip address dao . counti ps ( dc id true )  )  )  ;  metrics list . add ( new  item private ip ( zone name zone uuid total private ip address dao . counti ps ( dc id false )  )  )  ;  metrics list . add ( new  item public ip ( zone name zone uuid allocated public ip address dao . counti ps for network ( dc id true  vlan .  vlan type .  virtual network )  )  )  ;  metrics list . add ( new  item public ip ( zone name zone uuid total public ip address dao . counti ps for network ( dc id false  vlan .  vlan type .  virtual network )  )  )  ;  metrics list . add ( new  item shared network ip ( zone name zone uuid allocated public ip address dao . counti ps for network ( dc id true  vlan .  vlan type .  direct attached )  )  )  ;  metrics list . add ( new  item shared network ip ( zone name zone uuid total public ip address dao . counti ps for network ( dc id false  vlan .  vlan type .  direct attached )  )  )  ;   }  
private void   ( final  list <  item >  metrics list final long dc id final  string zone name final  string zone uuid )  {  for  (  final  storage pool joinvo pool : storage pool join dao . list all (  )  )   {  if  ( pool  =  =  null || pool . get zone id (  )   !  =  dc id )   {  continue ;   }  final  string pool name = pool . get name (  )  ;  final  string pool path = pool . get host address (  )   +  ":"  +  pool . get path (  )  ;  long used capacity = 0l ;  long allocated capacity = pool . get used capacity (  )   +  pool . get reserved capacity (  )  ;  final long total capacity = pool . get capacity bytes (  )  ;  final  storage stats stats =  apidb utils . get storage pool statistics ( pool . get id (  )  )  ;  if  ( stats  !  =  null )   {  used capacity = stats . get byte used (  )  ;   }  final  big decimal pool over provisioning factor =  big decimal . value of (  capacity manager .  storage overprovisioning factor . value in ( pool . get id (  )  )  )  ;  final  string pool factor = pool over provisioning factor . to string (  )  ;  metrics list . add ( new  item pool ( zone name zone uuid pool name pool path "primary" pool factor used used capacity )  )  ;  metrics list . add ( new  item pool ( zone name zone uuid pool name pool path "primary" pool factor allocated allocated capacity )  )  ;  metrics list . add ( new  item pool ( zone name zone uuid pool name pool path "primary" pool factor unallocated pool over provisioning factor . multiply (  big decimal . value of ( total capacity )  )  . long value (  )   -  allocated capacity )  )  ;  metrics list . add ( new  item pool ( zone name zone uuid pool name pool path "primary" pool factor total total capacity )  )  ;   }  for  (  final  image store image store : image store dao . find by scope ( new  zone scope ( dc id )  )  )   {  final  storage stats stats =  apidb utils . get secondary storage statistics ( image store . get id (  )  )  ;  metrics list . add ( new  item pool ( zone name zone uuid image store . get name (  )  image store . get url (  )  "secondary" null used stats  !  =  null  ?  stats . get byte used (  )  : 0 )  )  ;  metrics list . add ( new  item pool ( zone name zone uuid image store . get name (  )  image store . get url (  )  "secondary" null total stats  !  =  null  ?  stats . get capacity bytes (  )  : 0 )  )  ;   }   }  
private void   ( final  list <  item >  metrics list final long dc id final  string zone name final  string zone uuid )  {  metrics list . add ( new  item vlan ( zone name zone uuid allocated dc dao . count zone vlans ( dc id true )  )  )  ;  metrics list . add ( new  item vlan ( zone name zone uuid total dc dao . count zone vlans ( dc id false )  )  )  ;   }  
private void   ( final  list <  item >  metrics list final long dc id final  string zone name final  string zone uuid )  {  int total = 0 ;  int ready = 0 ;  int destroyed = 0 ;  for  (  final  volumevo volume : volume dao . find by dc ( dc id )  )   {  if  ( volume  =  =  null )   {  continue ;   }  total +  +  ;  if  ( volume . get state (  )   =  =   volume .  state .  ready )   {  ready +  +  ;   }  else if  ( volume . get state (  )   =  =   volume .  state .  destroy )   {  destroyed +  +  ;   }   }  metrics list . add ( new  item volume ( zone name zone uuid  volume .  state .  ready . name (  )  . to lower case (  )  ready )  )  ;  metrics list . add ( new  item volume ( zone name zone uuid  volume .  state .  destroy . name (  )  . to lower case (  )  destroyed )  )  ;  metrics list . add ( new  item volume ( zone name zone uuid total total )  )  ;   }  
public void   (  long cpu allocated )  {  this . cpu allocated +  = cpu allocated ;   }  
public void   (  double cpu used percentage )  {  this . cpu used percentage +  = cpu used percentage ;   }  
public void   (  long memory allocated )  {  this . memory allocated +  = memory allocated ;   }  
public void   (  long memory used )  {  this . memory used +  = memory used ;   }  
public void   ( final  acl data acl )  {  this . acls . add ( acl )  ;   }  
public void   ( final  string ipv4 )  {  this . fixed ips . add ( new  ip address ( ipv4 )  )  ;   }  
public void   (  string gateway ip )  {  if  ( gateway ip  !  =  null )   {  this . external gateway = new  external gateway ( gateway ip )  ;   }   }  
public void   (  router interface data intf )  {  if  ( this . interfaces  =  =  null )   {  this . interfaces = new  array list <  router interface data .  router interface >  (  )  ;   }  this . interfaces . add ( intf . get router interface (  )  )  ;   }  
public void   (  network network )  {  networks . add ( network )  ;   }  
public void   (  router router )  {  routers . add ( router )  ;   }  
@ override @db public  big switch bcf devicevo   (  add big switch bcf device cmd cmd )  {   big switch bcf devicevo new bcf device ;  bcf utils init (  )  ;   server resource resource = new  big switch bcf resource (  )  ;  final  string device name =  b
@ override @db public  brocade vcs devicevo   (  add brocade vcs device cmd cmd )  {   server resource resource = new  brocade vcs resource (  )  ;  final  string device name =  network .  provider .  brocade vcs . get name (  )  ;   network device networ
@ override public  cisco asa1000v device   (  add cisco asa1000v resource cmd cmd )  {   long physical network id = cmd . get physical network id (  )  ;   cisco asa1000v device cisco asa1000v resource = null ;   physical networkvo physical network =    p
@ override public  cisco vnmc controller   (  add cisco vnmc resource cmd cmd )  {  final  string device name =  provider .  cisco vnmc . get name (  )  ;   network device network device =  network device . get network device ( device name )  ;  final  lo
protected static void   ( final  domain routervo candidate vm final  long pod id for direct ip final  list <  domain routervo >  candidate vms )  {  if  ( candidate vm . get pod id to deploy in (  )  . equals ( pod id for direct ip )  )   {  candidate vms . add ( candidate vm )  ;   }   }  
@ override @ deprecated public  host   (  add external load balancer cmd cmd )  {   long zone id = cmd . get zone id (  )  ;   data centervo zone = null ;   physical networkvo p network = null ;   external load balancer devicevo lb devicevo = null ;   hos
private void   ( long vlan tag  string vlan self ip  string vlan netmask boolean inline )  throws  execution exception  {  try  {   string vlan name = gen vlan name ( vlan tag )  ;   list <  string >  all vlans = get stripped vlans (  )  ;  if  (  ! all vlans . contains ( vlan name )  )   {   string[] vlan names = gen string array ( vlan name )  ;  long[] vlan tags = gen long array ( vlan tag )  ;   common enabled state[] common enabled state =  {  common enabled state . state   disabled }  ;   networkingvlan member entry[][] vlan member entries =  {  { new  networkingvlan member entry (  )  }  }  ;  vlan member entries[0][0] . set member   type (  networking member type . member   interface )  ;  vlan member entries[0][0] . set tag   state (  networking member tag type . member   tagged )  ;  vlan member entries[0][0] . set member   name (    private interface )  ;  s   logger . debug ( " creating a guest vlan with tag "  +  vlan tag )  ;     vlan api . create ( vlan names vlan tags vlan member entries common enabled state new long[] { 10l }  new  string[] { "00:00:00:00:00:00" }  )  ;  s   logger . debug ( "vlan name "  +  vlan name )  ;  s   logger . debug ( "get stripped vlans "  +  get stripped vlans (  )  )  ;  if  (  ! get stripped vlans (  )  . contains ( vlan name )  )   {  throw new  execution exception ( " failed to create vlan with tag "  +  vlan tag )  ;   }   }  if  ( inline )   {   list <  long >  all route domains = get route domains (  )  ;  if  (  ! all route domains . contains ( vlan tag )  )   {  long[] route domain ids = gen long array ( vlan tag )  ;   string[][] vlan names = new  string[][] { gen string array ( gen vlan name ( vlan tag )  )  }  ;  s   logger . debug ( " creating route domain "  +  vlan tag )  ;     route domain api . create ( route domain ids vlan names )  ;  if  (  ! get route domains (  )  . contains ( vlan tag )  )   {  throw new  execution exception ( " failed to create route domain "  +  vlan tag )  ;   }   }   }   list <  string >  all self ips = get self ips (  )  ;  if  (  ! all self ips . contains ( vlan self ip )  )   {   string[] self ips to create = gen string array ( vlan self ip )  ;   string[] vlans = gen string array ( vlan name )  ;   string[] netmasks = gen string array ( vlan netmask )  ;  long[] unit ids = gen long array ( 0l )  ;   common enabled state[] enabled states = new  common enabled state[] {  common enabled state . state   disabled }  ;  s   logger . debug ( " creating self ip "  +  vlan self ip )  ;     self ip api . create ( self ips to create vlans netmasks unit ids enabled states )  ;  if  (  ! get self ips (  )  . contains ( vlan self ip )  )   {  throw new  execution exception ( " failed to create self ip "  +  vlan self ip )  ;   }   }   }  catch  (   remote exception e )   {  s   logger . error ( e )  ;  throw new  execution exception ( e . get message (  )  )  ;   }   }  
private void   (  string virtual server name  lb algorithm algorithm )  throws  execution exception  {  try  {  if  (  ! pool exists ( virtual server name )  )   {  if  ( algorithm . get persistence profile name (  )   !  =  null )   {  algorithm =  lb algorithm .  round robin ;   }  s   logger . debug ( " adding pool for virtual server "  +  virtual server name  +  " with algorithm " +  algorithm )  ;     loadbalancer api . create ( gen string array ( virtual server name )  gen lb method ( algorithm )  gen empty members array (  )  )  ;  if  (  ! pool exists ( virtual server name )  )   {  throw new  execution exception ( " failed to create new pool for virtual server "  +  virtual server name )  ;   }   }   }  catch  (   remote exception e )   {  throw new  execution exception ( e . get message (  )  )  ;   }   }  
private void   (  string virtual server name  string dest ip int dest port )  throws  execution exception  {  try  {   string member identifier = dest ip  +  " - "  +  dest port ;  if  ( pool exists ( virtual server name )  &&  ! member exists ( virtual server name member identifier )  )   {  s   logger . debug ( " adding member "  +  member identifier  +  " into pool for virtual server " +  virtual server name )  ;     loadbalancer api . add   member ( gen string array ( virtual server name )  gen members ( dest ip dest port )  )  ;  if  (  ! member exists ( virtual server name member identifier )  )   {  throw new  execution exception ( " failed to add new member "  +  member identifier  +  " into pool for virtual server " +  virtual server name )  ;   }   }   }  catch  (   remote exception e )   {  throw new  execution exception ( e . get message (  )  )  ;   }   }  
private void   (  string virtual server name  lb protocol protocol  string src ip int src port  stickiness policyto[] sticky policies )  throws  execution exception  {  try  {  if  (  ! virtual server exists ( virtual server name )  )   {  s   logger . debug ( " adding virtual server "  +  virtual server name )  ;     virtual server api . create ( gen virtual server definition ( virtual server name protocol src ip src port )  new  string[] { "255 . 255 . 255 . 255" }  gen virtual server resource ( virtual server name )  gen virtual server profile ( protocol )  )  ;     virtual server api . set   snat   automap ( gen string array ( virtual server name )  )  ;  if  (  ! virtual server exists ( virtual server name )  )   {  throw new  execution exception ( " failed to add virtual server "  +  virtual server name )  ;   }   }  if  (  ( sticky policies  !  =  null )  &&  ( sticky policies . length  >  0 )  &&  ( sticky policies[0]  !  =  null )  )   {   stickiness policyto stickiness policy = sticky policies[0] ;  if  (  stickiness method type . lb cookie based . get name (  )  . equals ignore case ( stickiness policy . get method name (  )  )  )   {   string[] profile names = gen string array ( " cookie - profile - "  +  virtual server name )  ;  if  (  ! persistence profile exists ( profile names[0] )  )   {   locallb persistence mode[] lb persistence mode = new i control .  locallb persistence mode[1] ;  lb persistence mode[0] = i control .  locallb persistence mode . persistence   mode   cookie ;     persistence profile api . create ( profile names lb persistence mode )  ;     virtual server api . add   persistence   profile ( gen string array ( virtual server name )  gen persistence profile ( profile names[0] )  )  ;   }   list <  pair <  string  string >  >  params list = stickiness policy . get params (  )  ;  for  (   pair <  string  string >  param : params list )   {  if  ( "holdtime" . equals ignore case ( param . first (  )  )  )   {  long timeout = 180 ;  if  ( param . second (  )   !  =  null )   {  timeout =  long . parse long ( param . second (  )  )  ;   }   locallb profileu long[] cookie timeout = new  locallb profileu long[1] ;  cookie timeout[0] = new  locallb profileu long (  )  ;  cookie timeout[0] . set value ( timeout )  ;     persistence profile api . set   cookie   expiration ( profile names cookie timeout )  ;   }   }   }   }  else  {     virtual server api . remove   all   persistence   profiles ( gen string array ( virtual server name )  )  ;   }   }  catch  (   remote exception e )   {  throw new  execution exception ( e . get message (  )  )  ;   }   }  
@ override @db public  host   (  long physical network id final  string username final  string password  string url )  {  if  ( username  =  =  null || username . trim (  )  . is empty (  )  )   {  throw new  invalid parameter value exception ( " invalid 
@ override public  virtual router provider   ( long ntwk svc provider id )  {   virtual router providervo element =    vr provider dao . find by nsp id and type ( ntwk svc provider id  type .  internal lb vm )  ;  if  ( element  !  =  null )   {  s   logg
@ test public void   (  )  {     lb el svc . add internal load balancer element ( valid provider id )  ;   }  
public void   (  )  {     lb el svc . add internal load balancer element ( invalid provider id )  ;   }  
@ test ( expected =  invalid parameter value exception . class )  public void   (  )  {     lb el svc . add internal load balancer element ( non existing provider id )  ;   }  
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
public void   (  virtual network model vn model )  {     vn model = vn model ;  if  ( vn model  !  =  null )   {  vn model . add successor ( this )  ;   }   }  
public void   (  floating ip pool model fip pool model )  {     fip pool model = fip pool model ;  if  ( fip pool model  !  =  null )   {  fip pool model . add successor ( this )  ;   }   }  
public void   ( vm interface model vmi model )  {  if  ( vmi model  !  =  null )   {  vmi model . add successor ( this )  ;   }   }  
public void   ( vm interface model vmi model )  {     vmi model = vmi model ;  if  ( vmi model  !  =  null )   {  vmi model . add successor ( this )  ;  s   logger . debug ( "vmi model has "  +  vmi model . successors (  )  . size (  )   +  " ip addresses" )  ;   }   }  
@ override public void   (  model object child )  {     successors . add ( child )  ;   model object base base =  (  model object base ) child ;  base .    ancestors . add ( new  model reference ( this )  )  ;   }  
public void   (  network policy model policy model )  {  if  (    policy model  !  =  null )   {     policy model . remove successor ( this )  ;   }     policy model = policy model ;  if  (    policy model  !  =  null )   {     policy model . add successor ( this )  ;   }   }  
public void   (  virtual machine model vm model )  {     vm model = vm model ;  if  ( vm model  !  =  null )   {  vm model . add successor ( this )  ;   }   }  
public void   (  virtual network model vn model )  {     vn model = vn model ;  if  ( vn model  !  =  null )   {  vn model . add successor ( this )  ;   }   }  
@ override @ deprecated public  host   (  add external firewall cmd cmd )  {   long zone id = cmd . get zone id (  )  ;   data centervo zone = null ;   physical networkvo p network = null ;   hostvo fw host = null ;  zone =    dc dao . find by id ( zone i
@ override public  external firewall devicevo   (  add srx firewall cmd cmd )  {   string device name = cmd . get device type (  )  ;  if  (  ! device name . equals ignore case (  network device .  junipersrx firewall . get name (  )  )  )   {  throw new 
private void   (  protocol protocol  long public vlan tag  string public ip  string private ip int src port start int src port end int dest port start int dest port end )  throws  execution exception  {  int offset = 0 ;  for  ( int src port = src port start ;  src port  <  =  src port end ;  src port +  +  )   {  int dest port = dest port start  +  offset ;  manage destination nat pool (  srx command . add private ip dest port )  ;  manage destination nat rule (  srx command . add public ip private ip src port dest port )  ;  offset +  = 1 ;   }  manage address book entry (  srx command . add    private zone private ip null )  ;   list <  object[] >  applications = new  array list <  object[] >  (  )  ;  applications . add ( new  object[] { protocol dest port start dest port end }  )  ;  add security policy and applications (  security policy type . destination   nat private ip applications )  ;  manage proxy arp (  srx command . add public vlan tag public ip )  ;   string src port range = src port start  +  " - "  +  src port end ;   string dest port range = dest port start  +  " - "  +  dest port end ;  s   logger . debug ( " added destination nat rule for protocol "  +  protocol  +  "  public ip " +  public ip +  "  private ip " +  private ip +  "  source port range " +  src port range +  "  and dest port range " +  dest port range )  ;   }  
private boolean   (  security policy type type  string guest vlan  list <  object[] >  applications  list <  string >  cidrs boolean default egress action )  throws  execution exception  {   list <  string >  application names = new  array list <  string >  (  )  ;  for  (   object[] application : applications )   {   protocol protocol =  (  protocol ) application[0] ;  if  (  ! protocol . equals (  protocol . all )  )   {  int start port = application[1]  !  =  null  ?   (  (  integer ) application[1] )  : 0 ;  int end port = application[2]  !  =  null  ?   (  (  integer ) application[2] )  : 65535 ;   string application name = gen application name ( type protocol start port end port )  ;  if  (  ! application names . contains ( application name )  )   {  application names . add ( application name )  ;   }  manage application ( type  srx command . add protocol start port end port )  ;   }   }  for  (   string cidr : cidrs )   {  manage address book entry (  srx command . add    private zone cidr null )  ;   }  manage security policy ( type  srx command . add null null guest vlan application names cidrs null default egress action )  ;  s   logger . debug ( " added  egress firewall rule for guest network "  +  guest vlan )  ;  return true ;   }  
private void   (  list <  string[] >  nat rules  list <  string >  public ips )  {  for  (   string[] nat rule : nat rules )   {  if  (  ! public ips . contains ( nat rule[0] )  )   {  public ips . add ( nat rule[0] )  ;   }   }   }  
private boolean   (  security policy type type  string private ip  list <  object[] >  applications )  throws  execution exception  {   list <  string >  application names = new  array list <  string >  (  )  ;  for  (   object[] application : applications )   {   protocol protocol =  (  protocol ) application[0] ;  int start port = application[1]  !  =  null  ?   (  (  integer ) application[1] )  :  - 1 ;  int end port = application[2]  !  =  null  ?   (  (  integer ) application[2] )  :  - 1 ;   string application name = gen application name ( type protocol start port end port )  ;  if  (  ! application names . contains ( application name )  )   {  application names . add ( application name )  ;   }  manage application ( type  srx command . add protocol start port end port )  ;   }  manage security policy ( type  srx command . add null null private ip application names null null false )  ;  return true ;   }  
private void   (  long public vlan tag  string public ip  string private ip  list <  firewall ruleto >  rules )  throws  execution exception  {  manage static nat rule (  srx command . add public ip private ip )  ;  manage address book entry (  srx command . add    private zone private ip null )  ;  manage proxy arp (  srx command . add public vlan tag public ip )  ;  add security policy and applications (  security policy type . static   nat private ip extract applications ( rules )  )  ;  s   logger . debug ( " added static nat rule for public ip "  +  public ip  +  "  and private ip " +  private ip )  ;   }  
@ override public  external load balancer devicevo   (  add netscaler load balancer cmd cmd )  {   string device name = cmd . get device type (  )  ;  if  (  ! is netscaler device ( device name )  )   {  throw new  invalid parameter value exception ( " in
public  virtual router provider   ( long ntwk svc provider id )  {   virtual router providervo element =    vr provider dao . find by nsp id and type ( ntwk svc provider id com . cloud . network .  virtual router provider .  type .  net scaler vm )  ;  if  ( element  !  =  null )   {  s   logger . debug ( " there is already an "  +  get name (  )   +  " with service provider id " +  ntwk svc provider id )  ;  return element ;   }   physical network service provider provider =    physical provider dao . find by id ( ntwk svc provider id )  ;  if  ( provider  =  =  null ||  ! provider . get provider name (  )  . equals ignore case ( get name (  )  )  )   {  throw new  invalid parameter value exception ( " invalid network service provider is specified" )  ;   }  element = new  virtual router providervo ( ntwk svc provider id com . cloud . network .  virtual router provider .  type .  net scaler vm )  ;  element . set enabled ( true )  ;  element =    vr provider dao . persist ( element )  ;  return element ;   }  
private synchronized void   ( final  string timer name final  string policy name final long priority final  string policy expression final  string action final int duration final int interval final boolean is clean up )  throws  exception  {  final autoscalepolicy timer policy = new autoscalepolicy (  )  ;  try  {  timer policy . set   name ( policy name )  ;  timer policy . set   action ( action )  ;  timer policy . set   rule ( policy expression )  ;  autoscalepolicy . add (    netscaler service timer policy )  ;   }  catch  (  final  exception e )   {  if  (  ! is clean up )   {  throw e ;   }   }  final nstimer   autoscalepolicy   binding timer   policy   binding = new nstimer   autoscalepolicy   binding (  )  ;  final int sample size = duration  /  interval ;  try  {  timer   policy   binding . set   name ( timer name )  ;  timer   policy   binding . set   policyname ( policy name )  ;  timer   policy   binding . set   samplesize ( sample size )  ;  timer   policy   binding . set   threshold ( sample size )  ;  timer   policy   binding . set   priority ( priority )  ;  nstimer   autoscalepolicy   binding . add (    netscaler service timer   policy   binding )  ;   }  catch  (  final  exception e )   {  if  (  ! is clean up )   {  throw e ;   }   }   }  
private void   ( final long vlan tag final  string vlan self ip final  string vlan netmask final boolean guest vlan )  throws  execution exception  {  try  {  if  (  ! ns vlan exists ( vlan tag )  )   {  try  {  final vlan vlan obj = new vlan (  )  ;  vlan obj . set   id ( vlan tag )  ;  api call result = vlan . add (    netscaler service vlan obj )  ;  if  ( api call result . errorcode  !  =  0 )   {  throw new  execution exception ( " failed to add new vlan with tag:"  +  vlan tag  +  "on the  net scaler device due to " +  api call result . message )  ;   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to add new vlan with tag:"  +  vlan tag  +  "on the  net scaler device due to " +  e . get message (  )  )  ;   }   }  if  (  ! ns snip exists ( vlan self ip )  )   {  try  {  final nsip self ip = new nsip (  )  ;  self ip . set   ipaddress ( vlan self ip )  ;  self ip . set   netmask ( vlan netmask )  ;  self ip . set   type ( "snip" )  ;  api call result = nsip . add (    netscaler service self ip )  ;  if  ( api call result . errorcode  !  =  0 )   {  throw new  execution exception ( " failed to add snip object for the guest network on the  netscaler device due to "  +  api call result . message )  ;   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to add snip object for the guest network on the  netscaler device due to "  +  e . get message (  )  )  ;   }   }  if  (  ! ns vlan nsip binding exists ( vlan tag vlan self ip )  )   {  try  {  final vlan   nsip   binding ip vlan binding = new vlan   nsip   binding (  )  ;  ip vlan binding . set   id ( vlan tag )  ;  ip vlan binding . set   ipaddress ( vlan self ip )  ;  ip vlan binding . set   netmask ( vlan netmask )  ;  api call result = vlan   nsip   binding . add (    netscaler service ip vlan binding )  ;  if  ( api call result . errorcode  !  =  0 )   {  throw new  execution exception ( " failed to bind vlan with tag:"  +  vlan tag  +  " to the subnet due to " +  api call result . message )  ;   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to bind vlan with tage:"  +  vlan tag  +  " to the subnet due to " +  e . get message (  )  )  ;   }   }  try  {  final vlan   interface   binding vlan binding = new vlan   interface   binding (  )  ;  if  ( guest vlan )   {  vlan binding . set   ifnum (    private interface )  ;   }  else  {  vlan binding . set   ifnum (    public interface )  ;   }  vlan binding . set   tagged ( true )  ;  vlan binding . set   id ( vlan tag )  ;  api call result = vlan   interface   binding . add (    netscaler service vlan binding )  ;  if  ( api call result . errorcode  !  =  0 )   {  final  string vlan interface = guest vlan  ?     private interface :    public interface ;  throw new  execution exception ( " failed to bind vlan with tag:"  +  vlan tag  +  " with the interface " +  vlan interface +  " due to " +  api call result . message )  ;   }   }  catch  (  final nitro   exception e )   {  if  (  !  ( e . get error code (  )   =  =   nitro error . ns   interface   already   bound   to   vlan )  )   {  throw new  execution exception ( " failed to bind vlan "  +  vlan tag  +  " with interface on the  netscaler device due to " +  e . get message (  )  )  ;   }   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to implement guest network on the  netscaler device due to "  +  e . get message (  )  )  ;   }  catch  (  final  exception e )   {  throw new  execution exception ( " failed to implement guest network on the  netscaler device due to "  +  e . get message (  )  )  ;   }   }  
private void   ( final  string snip final  string netmask )  throws  execution exception  {  try  {  final nsip self ip = new nsip (  )  ;  self ip . set   ipaddress ( snip )  ;  self ip . set   netmask ( netmask )  ;  self ip . set   type ( "snip" )  ;  api call result = nsip . add (    netscaler service self ip )  ;  if  ( api call result . errorcode  !  =  0 )   {  throw new  execution exception ( " failed to add snip object on the  netscaler device due to "  +  api call result . message )  ;   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to add snip object on the  netscaler device due to "  +  e . get message (  )  )  ;   }  catch  (  final  exception e )   {  throw new  execution exception ( " failed to add snip object on the  netscaler device due to "  +  e . get message (  )  )  ;   }   }  
@ override @db public  nicira nvp devicevo   (  add nicira nvp device cmd cmd )  {   server resource resource = new  nicira nvp resource (  )  ;  final  string device name =  network .  provider .  nicira nvp . get name (  )  ;   network device network de
public boolean   ( final  command command final int retries )  {  if  ( commands to retry . contains key ( command )  )   {  return false ;   }  commands to retry . put ( command retries )  ;  return true ;   }  
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
@ override public  nuage vsp devicevo   (  add nuage vsp device cmd cmd )  {  final  nuage vsp resource resource = new  nuage vsp resource (  )  ;  final  string device name =  network .  provider .  nuage vsp . get name (  )  ;   external network device 
private  < t extends  command > void   (  class < t >  clazz )  throws  illegal access exception   invocation target exception   instantiation exception  {   command a = fill object ( clazz )  ;   command b = fill object ( clazz )  ;  tester . add equality group ( a b )  ;   }  
private  < t extends  command > void   (  command command )  throws  illegal access exception   invocation target exception   instantiation exception  {   command[] forwarded commands = s   gson . from json ( s   gson . to json ( new  command[] { command }  )   command[] . class )  ;   assert . assert equals ( command forwarded commands[0] )  ;  tester . add equality group ( command forwarded commands[0] )  ;   }  
public   (  string host id  string ip address )  {  this . host id = host id ;  this . ip address = ip address ;   }  
public   (  command command  exception e )  {  super ( command e )  ;   }  
@ override public  open daylight controllervo   (  add open daylight controller cmd cmd )  {   server resource odl controller = new  open daylight controller resource (  )  ;  final  string device name =  network device .  open daylight controller . get n
public void   ( final  neutron rest api api )  {  flyweight . put ( api . get http clazz (  )  . get name (  )  api )  ;   }  
@ override public  external firewall devicevo   (  add palo alto firewall cmd cmd )  {   string device name = cmd . get device type (  )  ;  if  (  ! device name . equals ignore case (  network device .  palo alto firewall . get name (  )  )  )   {  throw
@ test public void   (  )  throws  configuration exception   exception  {  if  (    context . contains key ( "enable   console   output" )  &&    context . get ( "enable   console   output" )  . equals ( "true" )  )   {   system . out . println ( "\ntest:
@ test public void   (  )  throws  configuration exception   exception  {  if  (    context . contains key ( "enable   console   output" )  &&    context . get ( "enable   console   output" )  . equals ( "true" )  )   {   system . out . println ( "\ntest:
@ test public void   (  )  throws  configuration exception   exception  {  if  (    context . contains key ( "enable   console   output" )  &&    context . get ( "enable   console   output" )  . equals ( "true" )  )   {   system . out . println ( "\ntest:
@ test public void   (  )  throws  configuration exception   exception  {  if  (    context . contains key ( "enable   console   output" )  &&    context . get ( "enable   console   output" )  . equals ( "true" )  )   {   system . out . println ( "\ntest:
@ override public  host   (  add ssp cmd cmd )  {   ssp client client = new  ssp client ( cmd . get url (  )  cmd . get username (  )  cmd . get password (  )  )  ;  if  (  ! client . login (  )  )   {  throw new  cloud runtime exception ( " ssp login fai
public   (  )  {  super ( "add qos group" new  add qos group cmd response (  )  )  ;   }  
void   (  string lu name  string target group name )  {   mapping entry mapping entry = new  mapping entry ( target group name "0" )  ;  try  {  client . execute (  add mapping entry nms response . class "scsidisk" "add   lun   mapping   entry" lu name mapping entry )  ;   }  catch  (   cloud runtime exception ex )   {  if  (  ! ex . get message (  )  . contains ( "view already exists" )  )   {  throw ex ;   }  logger . debug ( " ignored lu mapping entry addition error "  +  ex )  ;   }   }  
void   (  string target group name  string target name )  {  try  {  client . execute (  nms response . class "stmf" "add   targetgroup   member" target group name target name )  ;   }  catch  (   cloud runtime exception ex )   {  if  (  ! ex . get message (  )  . contains ( "already exists" )  &&  ! ex . get message (  )  . contains ( "target must be offline" )  )   {  throw ex ;   }  logger . debug ( " ignored target group member addition error: "  +  ex )  ;   }   }  
private void   ( long volume id  solid fire util .  solid fire volume sf volume )  {   volume detailvo volume detail vo = new  volume detailvo ( volume id basic   sf   id  string . value of ( sf volume . get id (  )  )  false )  ;  volume details dao . persist ( volume detail vo )  ;  volume detail vo = new  volume detailvo ( volume id basic   iqn sf volume . get iqn (  )  false )  ;  volume details dao . persist ( volume detail vo )  ;   }  
private void   ( long cs snapshot id  string temp volume id )  {   snapshot detailsvo snapshot details = snapshot details dao . find detail ( cs snapshot id  solid fire util . volume   id )  ;  if  ( snapshot details  =  =  null || snapshot details . get value (  )   =  =  null )   {  throw new  cloud runtime exception ( "'add temp volume id' should not be invoked unless "  +   solid fire util . volume   id  +  " exists . " )  ;   }   string original volume id = snapshot details . get value (  )  ;  handle snapshot details ( cs snapshot id  solid fire util . temp   volume   id original volume id )  ;  handle snapshot details ( cs snapshot id  solid fire util . volume   id temp volume id )  ;   }  
@ override public  ldap configuration response   ( final  string hostname int port final  long domain id )  throws  invalid parameter value exception  {  return add configuration internal ( hostname port domain id )  ;   }  
private  ldap configuration response   ( final  string hostname int port final  long domain id )  throws  invalid parameter value exception  {  if  ( port  <  =  0 )   {  port = 389 ;   }   ldap configurationvo configuration =    ldap configuration dao . find ( hostname port domain id )  ;  if  ( configuration  =  =  null )   {   ldap context context = null ;  try  {  final  string provider url = "ldap: /  / "  +  hostname  +  ":" +  port ;  context =    ldap context factory . create bind context ( provider url domain id )  ;  configuration = new  ldap configurationvo ( hostname port domain id )  ;     ldap configuration dao . persist ( configuration )  ;  s   logger . info ( " added new ldap server with url: "  +  provider url  +   ( domain id  =  =  null  ?  "" : " for domain "  +  domain id )  )  ;  return create ldap configuration response ( configuration )  ;   }  catch  (   naming exception|io exception e )   {  s   logger . debug ( " naming exception while doing an ldap bind" e )  ;  throw new  invalid parameter value exception ( " unable to bind to the given ldap server" )  ;   }  finally  {  close context ( context )  ;   }   }  else  {  throw new  invalid parameter value exception ( " duplicate configuration" )  ;   }   }  
private void   (  entity descriptor descriptor  map <  string saml provider metadata >  idp map )  {  saml provider metadata idp metadata = new saml provider metadata (  )  ;  idp metadata . set entity id ( descriptor . get entityid (  )  )  ;  s   logger . debug ( " adding  idp to the list of discovered  id ps: "  +  descriptor . get entityid (  )  )  ;  if  ( descriptor . get organization (  )   !  =  null )   {  if  ( descriptor . get organization (  )  . get display names (  )   !  =  null )   {  for  (   organization display name org name : descriptor . get organization (  )  . get display names (  )  )   {  if  ( org name  !  =  null && org name . get name (  )   !  =  null )   {  idp metadata . set organization name ( org name . get name (  )  . get local string (  )  )  ;  break ;   }   }   }  if  ( idp metadata . get organization name (  )   =  =  null && descriptor . get organization (  )  . get organization names (  )   !  =  null )   {  for  (   organization name org name : descriptor . get organization (  )  . get organization names (  )  )   {  if  ( org name  !  =  null && org name . get name (  )   !  =  null )   {  idp metadata . set organization name ( org name . get name (  )  . get local string (  )  )  ;  break ;   }   }   }  if  ( descriptor . get organization (  )  . getur ls (  )   !  =  null )   {  for  (   organizationurl organizationurl : descriptor . get organization (  )  . getur ls (  )  )   {  if  ( organizationurl  !  =  null && organizationurl . geturl (  )   !  =  null )   {  idp metadata . set organization url ( organizationurl . geturl (  )  . get local string (  )  )  ;  break ;   }   }   }   }  if  ( descriptor . get contact persons (  )   !  =  null )   {  for  (   contact person person : descriptor . get contact persons (  )  )   {  if  ( person  =  =  null ||  ( person . get given name (  )   =  =  null && person . get sur name (  )   =  =  null )  || person . get email addresses (  )   =  =  null )   {  continue ;   }  if  ( person . get given name (  )   !  =  null )   {  idp metadata . set contact person name ( person . get given name (  )  . get name (  )  )  ;   }  else if  ( person . get sur name (  )   !  =  null )   {  idp metadata . set contact person name ( person . get sur name (  )  . get name (  )  )  ;   }  for  (   email address email address : person . get email addresses (  )  )   {  if  ( email address  !  =  null && email address . get address (  )   !  =  null )   {  idp metadata . set contact person email ( email address . get address (  )  )  ;   }   }  if  ( idp metadata . get contact person name (  )   !  =  null && idp metadata . get contact person email (  )   !  =  null )   {  break ;   }   }   }  idpsso descriptor idp descriptor = descriptor . getidpsso descriptor ( saml constants . saml20p   ns )  ;  if  ( idp descriptor  !  =  null )   {  if  ( idp descriptor . get single sign on services (  )   !  =  null )   {  for  (   single sign on service ssos : idp descriptor . get single sign on services (  )  )   {  if  ( ssos . get binding (  )  . equals ( saml constants . saml2   redirect   binding   uri )  )   {  idp metadata . set sso url ( ssos . get location (  )  )  ;   }   }   }  if  ( idp descriptor . get single logout services (  )   !  =  null )   {  for  (   single logout service slos : idp descriptor . get single logout services (  )  )   {  if  ( slos . get binding (  )  . equals ( saml constants . saml2   redirect   binding   uri )  )   {  idp metadata . set slo url ( slos . get location (  )  )  ;   }   }   }  x509 certificate unspecified key = null ;  if  ( idp descriptor . get key descriptors (  )   !  =  null )   {  for  (   key descriptor kd : idp descriptor . get key descriptors (  )  )   {  if  ( kd . get use (  )   =  =   usage type . signing )   {  try  {  idp metadata . set signing certificate (  key info helper . get certificates ( kd . get key info (  )  )  . get ( 0 )  )  ;   }  catch  (   certificate exception ignored )   {  s   logger . info ( "[ignored] encountered invalid certificate signing . " ignored )  ;   }   }  if  ( kd . get use (  )   =  =   usage type . encryption )   {  try  {  idp metadata . set encryption certificate (  key info helper . get certificates ( kd . get key info (  )  )  . get ( 0 )  )  ;   }  catch  (   certificate exception ignored )   {  s   logger . info ( "[ignored] encountered invalid certificate encryption . " ignored )  ;   }   }  if  ( kd . get use (  )   =  =   usage type . unspecified )   {  try  {  unspecified key =  key info helper . get certificates ( kd . get key info (  )  )  . get ( 0 )  ;   }  catch  (   certificate exception ignored )   {  s   logger . info ( "[ignored] encountered invalid certificate . " ignored )  ;   }   }   }   }  if  ( idp metadata . get signing certificate (  )   =  =  null && unspecified key  !  =  null )   {  idp metadata . set signing certificate ( unspecified key )  ;   }  if  ( idp metadata . get encryption certificate (  )   =  =  null && unspecified key  !  =  null )   {  idp metadata . set encryption certificate ( unspecified key )  ;   }  if  ( idp map . contains key ( idp metadata . get entity id (  )  )  )   {  s   logger . warn ( " duplicate  idp metadata found with entity  id: "  +  idp metadata . get entity id (  )  )  ;   }  idp map . put ( idp metadata . get entity id (  )  idp metadata )  ;   }   }  
private static synchronized void   (  class <  ?  >  authenticator api command command )  {  s   authenticators . put ( command . name (  )  . to lower case (  )  authenticator )  ;   }  
public  dispatch chain   ( final  dispatch worker worker )  {  workers . add ( worker )  ;  return this ;   }  
static void   (  file dir obj  zip output stream out )  throws io exception  {   file[] files = dir obj . list files (  )  ;  byte[] tmp buf = new byte[1024] ;   string path to dir = s   dir name ;  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {  if  ( files[i] . is directory (  )  )   {  add dir ( files[i] out )  ;  continue ;   }  try  (  file input stream in = new  file input stream ( files[i] . get path (  )  )  )  {  out . put next entry ( new  zip entry ( files[i] . get path (  )  . substring ( path to dir . length (  )  )  )  )  ;  int len ;  while  (  ( len = in . read ( tmp buf )  )   >  0 )   {  out . write ( tmp buf 0 len )  ;   }  out . close entry (  )  ;   }  catch  (  io exception ex )   {  s   logger . error ( "add dir: exception:"  +  ex . get message (  )  ex )  ;   }   }   }  
protected void   ( t base view z base response )  {   resource tag joinvo vtag = new  resource tag joinvo (  )  ;  vtag . set id ( base view . get tag id (  )  )  ;  vtag . set uuid ( base view . get tag uuid (  )  )  ;  vtag . set key ( base view . get tag key (  )  )  ;  vtag . set value ( base view . get tag value (  )  )  ;  vtag . set domain id ( base view . get tag domain id (  )  )  ;  vtag . set account id ( base view . get tag account id (  )  )  ;  vtag . set resource id ( base view . get tag resource id (  )  )  ;  vtag . set resource uuid ( base view . get tag resource uuid (  )  )  ;  vtag . set resource type ( base view . get tag resource type (  )  )  ;  vtag . set customer ( base view . get tag customer (  )  )  ;  vtag . set account name ( base view . get tag account name (  )  )  ;  vtag . set domain name ( base view . get tag domain name (  )  )  ;  vtag . set domain uuid ( base view . get tag domain uuid (  )  )  ;  base response . add tag (  apidb utils . new resource tag response ( vtag false )  )  ;   }  
private void   ( long resource id  string key  string value boolean for display )  {  dao . add detail ( resource id key value for display )  ;   }  
@ override @db @ action event ( event type =  event types . event   resource   details   create event description = "creating resource meta data" )  public boolean   ( final  string resource id final  resource object type resource type final  map <  strin
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
@ override public boolean   (  network network  nic profile nic  virtual machine profile profile  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable excep
@ override public boolean   ( final  network network final  nic profile nic final  virtual machine profile vm final  deploy destination dest final  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   r
@ override public boolean   (  network network  nic profile nic  virtual machine profile vm  deploy destination dest  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   resource unavailable exception 
@ override public  virtual router provider   ( final  long nsp id final  type provider type )  {  if  (  !  ( provider type  =  =   type .  virtual router || provider type  =  =   type . vpc virtual router )  )   {  throw new  invalid parameter value exce
@ override public boolean   ( final  network network final  nic profile nic final  virtual machine profile vm final  deploy destination dest final  reservation context context )  throws  concurrent operation exception   insufficient capacity exception   r
@ override @db public  external firewall devicevo   ( long physical network id  string url  string username  string password final  string device name  server resource resource )  {   string guid ;   physical networkvo p network = null ;   network device 
@ override @db public  external load balancer devicevo   ( long physical network id  string url  string username  string password final  string device name  server resource resource final boolean gslb provider final boolean exclusive gslb proivider final 
@ override public  host   (  add network device cmd cmd )  {   map param list = cmd . get param list (  )  ;  if  ( param list  =  =  null )   {  throw new  cloud runtime exception ( " parameter list is null" )  ;   }   collection params collection = para
@ override @ action event ( event type =  event types . event   firewall   open event description = "creating firewall rule" create = true )  public boolean   ( ip addressvo ip  account acct )  {   list <  firewall rulevo >  system rules =    firewall dao
private  physical network service provider   ( long physical network id )  {   physical networkvo pvo =    physical network dao . find by id ( physical network id )  ;   data centervo dvo =    dc dao . find by id ( pvo . get data center id (  )  )  ;  if  ( dvo . get network type (  )   =  =   network type .  advanced )   {   provider provider =  network .  provider . get provider ( " config drive" )  ;  if  ( provider  =  =  null )   {  return null ;   }  add provider to physical network ( physical network id  provider .  config drive . get name (  )  null null )  ;  enable provider (  provider .  config drive . get name (  )  )  ;   }  return null ;   }  
private  physical network service provider   ( long physical network id )  {   physical networkvo pvo =    physical network dao . find by id ( physical network id )  ;   data centervo dvo =    dc dao . find by id ( pvo . get data center id (  )  )  ;  if  ( dvo . get network type (  )   =  =   network type .  basic )   {   provider provider =  network .  provider . get provider ( " baremetal dhcp provider" )  ;  if  ( provider  =  =  null )   {  return null ;   }  add provider to physical network ( physical network id " baremetal dhcp provider" null null )  ;  add provider to physical network ( physical network id " baremetal pxe provider" null null )  ;  add provider to physical network ( physical network id " baremetal userdata provider" null null )  ;   }  else if  ( dvo . get network type (  )   =  =   network type .  advanced )   {  add provider to physical network ( physical network id " baremetal pxe provider" null null )  ;  enable provider ( " baremetal pxe provider" )  ;   }  return null ;   }  
protected  physical network service provider   ( long physical network id )  {   physical network service provider nsp = add provider to physical network ( physical network id  network .  provider .  internal lb vm . get name (  )  null null )  ;   network element network element =    network model . get element implementing provider (  network .  provider .  internal lb vm . get name (  )  )  ;  if  ( network element  =  =  null )   {  throw new  cloud runtime exception ( " unable to find the  network  element implementing the "  +   network .  provider .  internal lb vm . get name (  )   +  "  provider" )  ;   }     internal lb element svc . add internal load balancer element ( nsp . get id (  )  )  ;  return nsp ;   }  
private  physical network service provider   ( long physical network id )  {   physical network service provider nsp = add provider to physical network ( physical network id  network .  provider .  ovs . get name (  )  null null )  ;   network element network element =    network model . get element implementing provider (  network .  provider .  ovs . get name (  )  )  ;  if  ( network element  =  =  null )   {  throw new  cloud runtime exception ( " unable to find the  network  element implementing the  ovs  provider" )  ;   }   ovs providervo element =    ovs provider dao . find by nsp id ( nsp . get id (  )  )  ;  if  ( element  !  =  null )   {  s   logger . debug ( " there is already a  ovs element with service provider id "  +  nsp . get id (  )  )  ;  return nsp ;   }  element = new  ovs providervo ( nsp . get id (  )  )  ;     ovs provider dao . persist ( element )  ;  return nsp ;   }  
protected  physical network service provider   ( long physical network id )  {   physical network service provider nsp = add provider to physical network ( physical network id  network .  provider .  security group provider . get name (  )  null null )  ;  return nsp ;   }  
protected  physical network service provider   ( long physical network id )  {   physical network service provider nsp = add provider to physical network ( physical network id  network .  provider .  virtual router . get name (  )  null null )  ;   network element network element =    network model . get element implementing provider (  network .  provider .  virtual router . get name (  )  )  ;  if  ( network element  =  =  null )   {  throw new  cloud runtime exception ( " unable to find the  network  element implementing the  virtual router  provider" )  ;   }   virtual router element element =  (  virtual router element ) network element ;  element . add element ( nsp . get id (  )   type .  virtual router )  ;  return nsp ;   }  
protected  physical network service provider   ( long physical network id )  {   physical network service provider nsp = add provider to physical network ( physical network id  network .  provider . vpc virtual router . get name (  )  null null )  ;   network element network element =    network model . get element implementing provider (  network .  provider . vpc virtual router . get name (  )  )  ;  if  ( network element  =  =  null )   {  throw new  cloud runtime exception ( " unable to find the  network  element implementing the vpc virtual router  provider" )  ;   }   vpc virtual router element element =  (  vpc virtual router element ) network element ;  element . add element ( nsp . get id (  )   type . vpc virtual router )  ;  return nsp ;   }  
@db public void   (  string[] list of ranges final  physical networkvo network )  {   list <  string >  add vnets = null ;   list <  string >  remove vnets = null ;   hash set <  string >  temp vnets = new  hash set <  string >  (  )  ;   hash set <  stri
@ override @db @ action event ( event type =  event types . event   service   provider   create event description = " creating  physical  network  service provider" create = true )  public  physical network service provider   (  long physical network id  
@ override @db @ action event ( event type =  event types . event   traffic   type   create event description = " creating  physical  network  traffic type" create = true )  public  physical network traffic type   (  long physical network id  string traff
@ override public  host   (  add traffic monitor cmd cmd )  {  long zone id = cmd . get zone id (  )  ;   data centervo zone =    dc dao . find by id ( zone id )  ;   string zone name ;  if  ( zone  =  =  null )   {  throw new  invalid parameter value exc
@db public  port profilevo   (  string port prof name long vsm id int low vlan id int high vlan id  port type p type  binding type b type )  {   port profilevo port profile obj ;  port profile obj =    port profile dao . find by name ( port prof name )  ;
@ override public boolean   ( final  virtual router router final  network network final  map <  virtual machine profile .  param  object >  params )  throws  concurrent operation exception   resource unavailable exception   insufficient capacity exception
@ override @db public boolean   ( final  long user vm id final  list <  long >  groups )  {  if  (  ! is vm security group enabled ( user vm id )  )   {  s   logger . trace ( " user vm "  +  user vm id  +  " is not security group enabled  not adding it to
@ override @db public  vpn user   ( final long vpn owner id final  string username final  string password )  {  final  account caller =  call context . current (  )  . get calling account (  )  ;  if  (  ! username . matches ( "^[a - za - z0 - 9][a - za -
@ override @ action event ( event type =  event types . event   project   account   add event description = "adding account to project" async = true )  public boolean   ( long project id  string account name  string email )  {   account caller =  call con
@ override public  host   ( final long zone id final  server resource resource final  type host type final  map <  string  string >  host details )  {  if  (    dc dao . find by id ( zone id )   =  =  null )   {  throw new  invalid parameter value excepti
public void   (  string name  object val )  {  criteria . put ( name val )  ;   }  
@ override @db @ action event ( event type =  event types . event   guest   os   add event description = " adding new guest os type" create = true )  public  guestos   ( final  add guest os cmd cmd )  {  final  long category id = cmd . get os category id 
@ override @db @ action event ( event type =  event types . event   guest   os   mapping   add event description = " adding new guest os to hypervisor name mapping" create = true )  public  guestos hypervisor   ( final  add guest os mapping cmd cmd )  {  
private boolean   ( vm templatevo template long dst zone id long source zoneid )  throws  resource allocation exception  {  long tmplt id = template . get id (  )  ;   data centervo dst zone =    dc dao . find by id ( dst zone id )  ;   data centervo source zone =    dc dao . find by id ( source zoneid )  ;   accountvo account =    account dao . find by id ( template . get account id (  )  )  ;     resource limit mgr . check resource limit ( account  resource type . template )  ;  try  {     tmplt dao . add template to zone ( template dst zone id )  ;  return true ;   }  catch  (   exception ex )   {  s   logger . debug ( "failed to copy template from  zone: "  +  source zone . get uuid (  )   +  " to  zone: " +  dst zone . get uuid (  )  )  ;   }  return false ;   }  
public  test appender builder   ( final  level level final  string pattern )  {  check argument ( level  !  =  null "add expected pattern requires a non - null level" )  ;  check argument (  ! is null or empty ( pattern )  "add expected pattern requires a non - blank pattern" )  ;  check state ( expected patterns . contains key ( level )  "level "  +  level  +  " is not supported by " +  get class (  )  . get name (  )  )  ;  expected patterns . get ( level )  . add ( new  pattern result (  pattern . compile ( pattern )  )  )  ;  return this ;   }  
protected void   ( long vm id long service offering id long vm snapshot id )  {   service offeringvo service offeringvo =    service offering dao . find by id ( service offering id )  ;  if  ( service offeringvo . is dynamic (  )  )   {   list <  user vm detailvo >  vm details =    user vm details dao . list details ( vm id )  ;   list < vm snapshot detailsvo >  vm snapshot details = new  array list < vm snapshot detailsvo >  (  )  ;  for  (   user vm detailvo detail : vm details )   {  if  ( detail . get name (  )  . equals ignore case (  vm detail constants . cpu   number )  || detail . get name (  )  . equals ignore case (  vm detail constants . cpu   speed )  || detail . get name (  )  . equals ignore case (  vm detail constants . memory )  )   {  vm snapshot details . add ( new vm snapshot detailsvo ( vm snapshot id detail . get name (  )  detail . get value (  )  detail . is display (  )  )  )  ;   }   }     vm snapshot details dao . save details ( vm snapshot details )  ;   }   }  
@ override @db public boolean   ( final long user vm id  string group name )  {   user vmvo vm =    vm dao . find by id ( user vm id )  ;   instance groupvo group =    vm group dao . find by account and name ( vm . get account id (  )  group name )  ;  if
@ override @ action event ( event type =  event types . event   nic   create event description = " creating  nic" async = true )  public  user vm   (  add nic tovm cmd cmd )  throws  invalid parameter value exception   permission denied exception   cloud 
public  annotation response   (  string text  entity type type  string uuid )  {   call context ctx =  call context . current (  )  ;   string user uuid = ctx . get calling user uuid (  )  ;   annotationvo annotation = new  annotationvo ( text type uuid )  ;  annotation . set user uuid ( user uuid )  ;  annotation = annotation dao . persist ( annotation )  ;  return create annotation response ( annotation )  ;   }  
@ override public  region   ( int id  string name  string end point )  {  if  (    region dao . find by id ( id )   !  =  null )   {  throw new  invalid parameter value exception ( " region with id: "  +  id  +  " already exists" )  ;   }  if  (    region
@ override public  region   ( int id  string name  string end point )  {  return    region mgr . add region ( id name end point )  ;   }  
@ override public boolean   ( ip addressvo ip  account acct )  {  return false ;   }  
@ override public boolean   ( long project id  string account name  string email )  {  return false ;   }  
@ override public  host   ( final long zone id final  server resource resource final  type host type final  map <  string  string >  host details )  {  return null ;   }  
@ override public  physical network service provider   (  long physical network id  string provider name  long destination physical network id  list <  string >  enabled services )  {  return null ;   }  
@ override public  physical network traffic type   (  long physical network id  string traffic type  string isolation method  string xen label  string kvm label  string vmware label  string simulator label  string vlan  string hyperv label  string ovm3 la
@ override public boolean   ( final  virtual router router final  network network final  map <  virtual machine profile .  param  object >  params )  throws  concurrent operation exception   resource unavailable exception   insufficient capacity exception
private void   ( final ca manager impl provider final  string name final  object o )  throws  illegal access exception   no such field exception  {   field f = ca manager impl . class . get declared field ( name )  ;  f . set accessible ( true )  ;  f . set ( provider o )  ;   }  
private void   ( final  indirect agentlb service impl provider final  string name final  object o )  throws  illegal access exception   no such field exception  {   field f =  indirect agentlb service impl . class . get declared field ( name )  ;  f . set accessible ( true )  ;  f . set ( provider o )  ;   }  
public boolean   (  rectangle rect )  {  if  ( bound . is empty (  )  )   {  assert  ( rect list . size (  )   =  =  0 )  ;  bound . x = rect . x ;  bound . y = rect . y ;  bound . width = rect . width ;  bound . height = rect . height ;  rect list . add ( rect )  ;  return true ;   }   rectangle rc inflated = new  rectangle ( rect . x  -  1 rect . y  -  1 rect . width  +  2 rect . height  +  2 )  ;  if  (  ! bound . intersects ( rc inflated )  )  return false ;  for  (   rectangle r : rect list )   {  if  ( r . intersects ( rc inflated )  )   {  if  (  ! r . contains ( rect )  )   {  enlarge bound ( rect )  ;  rect list . add ( rect )  ;  return true ;   }   }   }  return false ;   }  
public void   (  rectangle rect )  {  boolean new region = true ;   rectangle rc inflated = new  rectangle ( rect . x  -  1 rect . y  -  1 rect . width  +  2 rect . height  +  2 )  ;  for  (   region region : region list )   {  if  ( region . get bound (  )  . intersects ( rc inflated )  )   {  new region = false ;  break ;   }   }  if  ( new region )   {  region list . add ( new  region ( rect )  )  ;   }  else  {  for  (   region region : region list )   {  if  ( region . add ( rect )  )  return ;   }  region list . add ( new  region ( rect )  )  ;   }   }  
public void   (  size change listener size change listener )  {  size change listeners . add ( size change listener )  ;   }  
protected int   (  string builder builder )  {  int i = 0 ;  for  (  ;  i  <  length ;  i +  +  )   {  if  ( i % 16  =  =  0 )   {  builder . append (  string . format ( "%04x" i )  )  ;   }  builder . append ( ' ' )  ;  int b = data[offset  +  i] & 0xff ;  builder . append (  string . format ( "%02x" b )  )  ;  if  ( i % 16  =  =  15 )   {  builder . append ( ' ' )  ;  builder . append ( toascii string ( i  -  15 i )  )  ;  builder . append ( '\n' )  ;   }   }  return i ;   }  
@ override public void   (  element .  .  .  elements )  {  for  (   element element : elements )   {   string id = element . get id (  )  ;  if  ( this . elements . contains key ( id )  )  throw new  runtime exception ( " this pipeline already contains e
@ override public void   (  element .  .  .  elements )  {  add ( elements )  ;  link ( elements )  ;   }  
public void   (  string acct )  {  account name list . add ( acct )  ;   }  
public void   (  string policy )  {  policy name list . add ( policy )  ;   }  
public void   ( iam permission response perm )  {  permission list . add ( perm )  ;   }  
private void   (  string api name  class <  ?  >  cmd class  role type role )  {   access type access type = null ;   class <  ?  > [] entity types = null ;   permission scope permission scope =  permission scope . account ;   long policy id = get default policy id ( role )  ;  switch  ( role )   {  case  user: permission scope =  permission scope . account ;  break ;  case  admin: permission scope =  permission scope . all ;  break ;  case  domain admin: permission scope =  permission scope . domain ;  break ;  case  resource admin: permission scope =  permission scope . domain ;  break ;   }  boolean add account scoped use entry = false ;  if  ( cmd class  !  =  null )   {   base cmd cmd obj ;  try  {  cmd obj =  (  base cmd ) cmd class . new instance (  )  ;  if  ( cmd obj instanceof  base list cmd )   {  if  ( permission scope  =  =   permission scope . account )   {  access type =  access type .  use entry ;   }  else  {  access type =  access type .  list entry ;  add account scoped use entry = true ;   }   }  else  {  access type =  access type .  operate entry ;   }   }  catch  (  exception e )   {  throw new  cloud runtime exception (  string . format ( "%s is claimed as an api command  but it cannot be instantiated" cmd class . get name (  )  )  )  ;   }  api command at = cmd class . get annotation ( api command . class )  ;  entity types = at . entity type (  )  ;   }  if  ( entity types  =  =  null || entity types . length  =  =  0 )   {     iam srv . addiam permission toiam policy ( policy id null permission scope . to string (  )  new  long ( iam policy permission . permission   scope   id   current   caller )  api name  ( access type  =  =  null )   ?  null : access type . to string (  )   permission .  allow false )  ;  if  ( add account scoped use entry )   {     iam srv . addiam permission toiam policy ( policy id null  permission scope . account . to string (  )  new  long ( iam policy permission . permission   scope   id   current   caller )  api name  access type .  use entry . to string (  )   permission .  allow false )  ;   }   }  else  {  for  (  class <  ?  >  entity type : entity types )   {     iam srv . addiam permission toiam policy ( policy id entity type . get simple name (  )  permission scope . to string (  )  new  long ( iam policy permission . permission   scope   id   current   caller )  api name  ( access type  =  =  null )   ?  null : access type . to string (  )   permission .  allow false )  ;  if  ( add account scoped use entry )   {     iam srv . addiam permission toiam policy ( policy id entity type . get simple name (  )   permission scope . account . to string (  )  new  long ( iam policy permission . permission   scope   id   current   caller )  api name  access type .  use entry . to string (  )   permission .  allow false )  ;   }   }   }   }  
private void   ( long account id long group id )  {   list <  long >  accts = new  array list <  long >  (  )  ;  accts . add ( account id )  ;  add accounts to group ( accts group id )  ;   }  
@db @ override @ action event ( event type =  event types . event   iam   group   update event description = " adding accounts to acl group" )  public iam group   ( final  list <  long >  acct ids final  long group id )  {  return    iam srv . add account
private void   (  map <  string  object >  params )  {   class <  ?  >  entity type =  (  class <  ?  >  ) params . get (  api constants . entity   type )  ;   long entity id =  (  long ) params . get (  api constants . entity   id )  ;   long domain id =  (  long ) params . get (  api constants . domain   id )  ;   boolean is recursive =  (  boolean ) params . get (  api constants . subdomain   access )  ;  if  ( entity type  =  =   network . class )   {  create policy and add to domain group ( " domain wide network - "  +  entity id "domain wide network" entity type . to string (  )  entity id "list networks"  access type .  use entry domain id is recursive )  ;   }  else if  ( entity type  =  =   affinity group . class )   {  create policy and add to domain group ( " domain wide network - "  +  entity id "domain wide affinity group" entity type . to string (  )  entity id "list affinity groups"  access type .  use entry domain id is recursive )  ;   }   }  
@ test public void   (  )  {  iam group group = new iam groupvo ( "group1" "tester group1" )  ;   list < iam group >  groups = new  array list < iam group >  (  )  ;  groups . add ( group )  ;   long group id = group . get id (  )  ;   list <  long >  acc
@ test public void   (  )  {  iam policy policy = new iam policyvo ( "policy1" "tester policy1" )  ;   list < iam policy >  policies = new  array list < iam policy >  (  )  ;  policies . add ( policy )  ;   long policy id = policy . get id (  )  ;   long 
@ test public void   (  )  {  iam group group = new iam groupvo ( "group1" "tester group1" )  ;   list < iam group >  groups = new  array list < iam group >  (  )  ;  groups . add ( group )  ;   long group id = group . get id (  )  ;   list <  long >  pol
@db @ override public iam group   ( final  list <  long >  acct ids final  long group id )  {  iam group group =    acl group dao . find by id ( group id )  ;  if  ( group  =  =  null )   {  throw new  invalid parameter value exception ( " unable to find 
@ override public void   (  object access key  object allow deny )  {  if  (    iam cache  !  =  null )   {  try  {  s   logger . debug ( " put iam access check for "  +  access key  +  " in cache" )  ;     iam cache . put ( new  element ( access key allo
private void   (  string localgw  string eth1ip  string eth1mask  string dest ip or cidr )  {  if  (  !    in systemvm )   {  return ;   }  s   logger . debug ( "add route to internal ip: localgw = "  +  localgw  +  "  eth1ip = " +  eth1ip +  "  eth1mask = " +  eth1mask +  " dest ip = " +  dest ip or cidr )  ;  if  ( dest ip or cidr  =  =  null )   {  s   logger . debug ( "add route to internal ip: dest ip is null" )  ;  return ;   }  if  (  !  net utils . is valid ip4 ( dest ip or cidr )  &&  !  net utils . is valid ip4 cidr ( dest ip or cidr )  )   {  s   logger . warn ( " dest ip is not a valid ip address or cidr dest ip = "  +  dest ip or cidr )  ;  return ;   }  boolean in same subnet = false ;  if  (  net utils . is valid ip4 ( dest ip or cidr )  )   {  if  ( eth1ip  !  =  null && eth1mask  !  =  null )   {  in same subnet =  net utils . same subnet ( eth1ip dest ip or cidr eth1mask )  ;   }  else  {  s   logger . warn ( "add route to internal ip: unable to determine same subnet:    eth1ip = "  +  eth1ip  +  "  dest ip = " +  dest ip or cidr +  "     eth1mask = " +  eth1mask )  ;   }   }  else  {  in same subnet =  net utils . is networka within networkb ( dest ip or cidr  net utils . ip and net mask to cidr ( eth1ip eth1mask )  )  ;   }  if  ( in same subnet )   {  s   logger . debug ( "add route to internal ip: dest ip "  +  dest ip or cidr  +  " is in the same subnet as eth1 ip " +  eth1ip )  ;  return ;   }   script command = new  script ( " / bin / bash" s   logger )  ;  command . add ( " - c" )  ;  command . add ( "ip route delete "  +  dest ip or cidr )  ;  command . execute (  )  ;  command = new  script ( " / bin / bash" s   logger )  ;  command . add ( " - c" )  ;  command . add ( "ip route add "  +  dest ip or cidr  +  " via " +  localgw )  ;   string result = command . execute (  )  ;  if  ( result  !  =  null )   {  s   logger . warn ( " error in configuring route to internal ip err = "  +  result )  ;   }  else  {  s   logger . debug ( "add route to internal ip: added route to internal ip = "  +  dest ip or cidr  +  " via " +  localgw )  ;   }   }  
protected void   (  string sql template  string item name )  {  check cases . add ( new  check case ( sql template item name )  )  ;   }  
public void   (  string name int average rate int max rate int burst rate )  throws  cloud runtime exception  {   string command =  vsm command . get add policy map ( name average rate max rate burst rate )  ;  if  ( command  !  =  null )   {  command = command . concat ( ssh   netconf   terminator )  ;  parse ok reply ( send and receive ( command )  )  ;   }  else  {  throw new  cloud runtime exception ( " error generating rpc request for adding / updating policy map . " )  ;   }   }  
public void   (  string name  port profile type type  binding type binding  switch port mode mode int vlanid )  throws  cloud runtime exception  {   string command =  vsm command . get add port profile ( name type binding mode vlanid )  ;  if  ( command  !  =  null )   {  command = command . concat ( ssh   netconf   terminator )  ;  parse ok reply ( send and receive ( command )  )  ;   }  else  {  throw new  cloud runtime exception ( " error generating rpc request for adding port profile . " )  ;   }   }  
public static synchronized void   (  class <  ?  >  clazz  application context context )  {  if  ( s   app context delegates  =  =  null )   {  s   app context delegates = new  hash map <  class <  ?  >   application context >  (  )  ;   }  s   app context delegates . put ( clazz context )  ;   }  
private void   ( char c )  {  safe characters . set ( c )  ;   }  
@ override public  cloud runtime exception   (  class <  ?  >  entity  string uuid )  {  uuid list . add ( new  pair <  class <  ?  >   string >  ( entity uuid )  )  ;  return this ;   }  
public void   (  string vo obj uuid  string description )  {   exception proxy object proxy = new  exception proxy object ( vo obj uuid description )  ;  id list . add ( proxy )  ;   }  
public void   ( e e s s )  {   list < s >  l = prev states . get ( e )  ;  if  ( l  =  =  null )   {  l = new  array list < s >  (  )  ;  prev states . put ( e l )  ;   }  assert  ! l . contains ( s )  : " already contains the from transition "  +  e . to string (  )   +  " from state " +  s . to string (  )  +  " to " +  get state str (  )  ;  l . add ( s )  ;   }  
public void   ( e event s to state )  {  add transition ( null event to state )  ;   }  
public void   ( e e s s  transition < s e >  transition )  {  assert  ! next states . contains key ( e )  : " state "  +  get state str (  )   +  " already contains a transition to state " +  next states . get ( e )  . to string (  )  +  " via event " +  e . to string (  )  +  " .   please revisit the rule you're adding to state " +  s . to string (  )  ;  next states . put ( e transition )  ;   }  
@ safe varargs public final void   ( e event s to state s .  .  .  from states )  {  for  (  s from state : from states )   {  add transition ( from state event to state )  ;   }   }  
public static void   ( final  http servlet response resp )  {  if  ( resp . contains header ( "x -  content -  type -  options" )  )   {  resp . set header ( "x -  content -  type -  options" "nosniff" )  ;   }  else  {  resp . add header ( "x -  content -  type -  options" "nosniff" )  ;   }  if  ( resp . contains header ( "x - xss -  protection" )  )   {  resp . set header ( "x - xss -  protection" "1 ; mode = block" )  ;   }  else  {  resp . add header ( "x - xss -  protection" "1 ; mode = block" )  ;   }  if  ( resp . contains header ( "content - security - policy" )  )   {  resp . set int header ( "content - security - policy" 1 )  ;   }  else  {  resp . add int header ( "content - security - policy" 1 )  ;   }  resp . add header ( "content - security - policy" "default - src = none" )  ;  resp . add header ( "content - security - policy" "script - src = self" )  ;  resp . add header ( "content - security - policy" "connect - src = self" )  ;  resp . add header ( "content - security - policy" "img - src = self" )  ;  resp . add header ( "content - security - policy" "style - src = self" )  ;   }  
public void   ( e e s s )  {   list < s >  l = prev states . get ( e )  ;  if  ( l  =  =  null )   {  l = new  array list < s >  (  )  ;  prev states . put ( e l )  ;   }  assert  ! l . contains ( s )  : " already contains the from transition "  +  e . to string (  )   +  " from state " +  s . to string (  )  +  " to " +  get state str (  )  ;  l . add ( s )  ;   }  
public void   ( e e s s )  {  assert  ! next states . contains key ( e )  : " state "  +  get state str (  )   +  " already contains a transition to state " +  next states . get ( e )  . to string (  )  +  " via event " +  e . to string (  )  +  " .   please revisit the rule you're adding to state " +  s . to string (  )  ;  next states . put ( e s )  ;   }  
private void   (  throwable th  list <  string >  lines int max number of stack )  {   stack trace element[] elements = th . get stack trace (  )  ;  if  ( max number of stack  =  =  0 || max number of stack  >  elements . length )   {  max number of stack = elements . length ;   }  for  ( int i = 0 ;  i  <  max number of stack ;  i +  +  )   {   stack trace element element = elements[i] ;  if  (  string utils . contains ( element . get class name (  )  "net . sf . cglib . proxy" )  )   {  continue ;   }  lines . add ( "\tat "  +  element . to string (  )  )  ;   }  if  ( max number of stack  <  elements . length )   {  lines . add ( "\t .  .  .  "  +   ( elements . length  -  max number of stack )   +  " more" )  ;   }   }  
public synchronized void   (  string name  object value )  {     prop map . put ( name value )  ;   }  
@ override public void   (  string param )  {  add ( param  param type . normal )  ;   }  
public void   (  string param )  {     command . add ( param )  ;   }  
protected static void   (  string tag name  node node  list <  pair <  string  integer >  >  priority list )  {   integer priority =  integer . max   value ;   string first = node . get text content (  )  ;  if  ( node . has attributes (  )  )   {   named node map attributes = node . get attributes (  )  ;  for  ( int k = 0 ;  k  <  attributes . get length (  )  ;  k +  +  )   {   node attr = attributes . item ( k )  ;  if  ( tag name . equals ( "url" )  && attr . get node name (  )  . equals ( "priority" )  )   {   string prio = attr . get node value (  )  . replace ( "\"" "" )  ;  priority =  integer . parse int ( prio )  ;  break ;   }  else if  ( tag name . equals ( "hash" )  && attr . get node name (  )  . equals ( "type" )  )   {  first = " { "  +  attr . get node value (  )   +  " } " +  first ;  break ;   }   }   }  priority list . add ( new  pair <  >  ( first priority )  )  ;   }  
public  custom field def   (  string field name  string mor type  privilege policy def field def policy  privilege policy def field policy )  throws  exception  {  return    context . get service (  )  . add custom field def ( get mor (  )  field name mor type field def policy field policy )  ;   }  
public void   (  host port group spec spec )  throws  exception  {     context . get service (  )  . add port group (    mor spec )  ;   }  
public void   (  string v switch name  host virtual switch spec spec )  throws  exception  {     context . get service (  )  . add virtual switch (    mor v switch name spec )  ;   }  
public void   (  string i scsi hba device  list <  host internet scsi hba static target >  lst targets )  throws  exception  {     context . get service (  )  . add internet scsi static targets (    mor i scsi hba device lst targets )  ;   }  
public void   (  string disk device bus name  string disk backing file path )  {   list <  string >  chain = get disk chain container ( disk device bus name )  ;  chain . add ( disk backing file path )  ;   }  
void   (  watcher watcher )  {  parent watchers . offer ( watcher )  ;   }  
void   (  watcher watcher )  {  state . add parent watcher ( watcher )  ;   }  
@ override public void   (  string name int increment )  {  if  ( log . is trace enabled (  )  )   {  log . trace ( " counter "  +  name  +  ": " +  increment )  ;   }   }  
@ override public void   (  string name long time  time unit unit )  {  if  ( log . is trace enabled (  )  )   {  log . trace ( " trace: "  +  name  +  "  -  " +   time unit . milliseconds . convert ( time unit )  +  " ms" )  ;   }   }  
public void   (  throwable e )  {  if  ( e instanceof  interrupted exception )   {  if  ( main ex  !  =  null )   {  e . add suppressed ( main ex )  ;   }   thread . current thread (  )  . interrupt (  )  ;   }  if  ( main ex  =  =  null )   {  main ex = e ;   }  else  {  main ex . add suppressed ( e )  ;   }   }  
private static void   (  path children cache cache )  {   path children cache listener listener = new  path children cache listener (  )  {  @ override public void child event (   curator framework client   path children cache event event )  throws  exception  {  switch  ( event . get type (  )  )   {  case child   added:  {   system . out . println ( " node added: "  +  zk paths . get node from path ( event . get data (  )  . get path (  )  )  )  ;  break ;   }  case child   updated:  {   system . out . println ( " node changed: "  +  zk paths . get node from path ( event . get data (  )  . get path (  )  )  )  ;  break ;   }  case child   removed:  {   system . out . println ( " node removed: "  +  zk paths . get node from path ( event . get data (  )  . get path (  )  )  )  ;  break ;   }   }   }   }   ;  cache . get listenable (  )  . add listener ( listener )  ;   }  
private static void   (  string[] args  curator framework client  string command  list <  example server >  servers )  throws  exception  {  if  ( args . length  <  2 )   {   system . err . println ( "syntax error  ( expected add  < name >   < description >  ) : "  +  command )  ;  return ;   }   string builder description = new  string builder (  )  ;  for  ( int i = 1 ;  i  <  args . length ;   +  + i )   {  if  ( i  >  1 )   {  description . append ( ' ' )  ;   }  description . append ( args[i] )  ;   }   string service name = args[0] ;   example server server = new  example server ( client path service name description . to string (  )  )  ;  servers . add ( server )  ;  server . start (  )  ;   system . out . println ( service name  +  " added" )  ;   }  
void   (  connection state new connection state )  {  connection state manager . add state change ( new connection state )  ;   }  
void   (  op op  operation type type  string for path )  {  super . add ( op )  ;  metadata . add ( new  type and path ( type for path )  )  ;   }  
void   (  message digest digest )  {  for  (   op op : this )   {  digest . update ( op . get path (  )  . get bytes (  )  )  ;  digest . update (  integer . to string ( op . get type (  )  )  . get bytes (  )  )  ;  digest . update ( op . to request record (  )  . to string (  )  . get bytes (  )  )  ;   }   }  
public void   (  message digest digest )  {  record . add to digest ( digest )  ;   }  
void   ( t details )  {  if  ( debug listener  !  =  null )   {  debug listener . path added for guaranteed operation ( details )  ;   }  if  ( client . get state (  )   =  =   curator framework state . started )   {  log . debug ( " details being added to guaranteed operation set: "  +  details )  ;  try  {  execute guaranteed operation in background ( details )  ;   }  catch  (   exception e )   {   thread utils . check interrupted ( e )  ;  add failed operation ( details )  ;   }   }   }  
void   (  namespace watcher watcher )  {  watcher =  preconditions . check not null ( watcher "watcher cannot be null" )  ;  entries . add ( watcher )  ;   }  
@ override public void   ( t listener  executor executor )  {  listeners . put ( listener new  listener entry < t >  ( listener executor )  )  ;   }  
public synchronized boolean   (  connection state new connection state )  {  if  ( state . get (  )   !  =   state . started )   {  return false ;   }   connection state previous state = current connection state ;  if  ( previous state  =  =  new connection state )   {  return false ;   }  set current connection state ( new connection state )  ;   connection state local state = new connection state ;  boolean is negative message =  (  ( new connection state  =  =   connection state . lost )  ||  ( new connection state  =  =   connection state . suspended )  ||  ( new connection state  =  =   connection state . read   only )  )  ;  if  (  ! is negative message && initial connect message sent . compare and set ( false true )  )   {  local state =  connection state . connected ;   }  post state ( local state )  ;  return true ;   }  
@ override public  atomic value <  long >    (  long delta )  throws  exception  {  return worker ( delta )  ;   }  
@ override public  atomic value <  integer >    (  integer delta )  throws  exception  {  return worker ( delta )  ;   }  
public void   (  leader latch listener listener  executor executor )  {  listeners . add listener ( listener executor )  ;   }  
public  child reaper   (  string path )  {  paths . add (  path utils . validate path ( path )  )  ;  return this ;   }  
private void   (  string path )  throws  exception  {   stat stat = client . check exists (  )  . for path ( path )  ;  if  (  ( stat  !  =  null )  &&  ( stat . get num children (  )   =  =  0 )  )   {  log . info ( " adding "  +  path )  ;  reaper . add path ( path mode )  ;   }   }  
private void   (  leader latch leader latch )  {   leader latch listener listener = new  leader latch listener (  )  {  @ override public void is leader (  )  {  reaping is active . set ( true )  ;  for  (   path holder holder : active paths . values (  )  )   {  schedule ( holder reaping threshold ms )  ;   }   }  @ override public void not leader (  )  {  reaping is active . set ( false )  ;   }   }   ;  leader latch . add listener ( listener )  ;  reaping is active . set ( leader latch . has leadership (  )  )  ;   }  
public void   (  string path  mode mode )  {   path holder path holder = new  path holder ( path mode 0 )  ;  active paths . put ( path path holder )  ;  schedule ( path holder reaping threshold ms )  ;   }  
private void   (  string new queue path )  throws  exception  {  if  ( new queue path  =  =  null )   {  new queue path = zk paths . make path ( queue path queue   prefix  +  uuid . randomuuid (  )  . to string (  )  )  ;   }  if  (  ! queues . contains key ( new queue path )  )   {  t queue = queue allocator . allocate queue ( client new queue path )  ;  if  ( queues . put if absent ( new queue path queue )   =  =  null )   {  queue . start (  )  ;  preferred queues . add ( new queue path )  ;   }   }   }  
@ override public void   ( final  shared count listener listener  executor executor )  {   shared value listener value listener = new  shared value listener (  )  {  @ override public void value has changed (   shared value reader shared value  byte[] new
@ override public  atomic value <  long >    (  long delta )  throws  exception  {  return fake value ref . get (  )  ;   }  
private void   (  test queue item message  set <  test queue item >  taken items int item qty )  {  synchronized  ( taken items )   {  taken items . add ( message )  ;  if  ( taken items . size (  )   >  item qty )   {  taken items . notify all (  )  ;   }   }   }  
void   (  service instance <  ?  >  instance )  {  purge (  )  ;   status new status = new  status (  )  ;   status old status = statuses . put if absent ( instance new status )  ;   status use status =  ( old status  !  =  null )   ?  old status : new status ;  use status . error count . increment and get (  )  ;   }  
private void   (  child data child data boolean only if absent )  throws  exception  {   string instance id = instance id from data ( child data )  ;   service instance < t >  service instance = discovery . get serializer (  )  . deserialize ( child data . get data (  )  )  ;  if  ( only if absent )   {  instances . put if absent ( instance id service instance )  ;   }  else  {  instances . put ( instance id service instance )  ;   }  cache . clear data bytes ( child data . get path (  )  child data . get stat (  )  . get version (  )  )  ;   }  
@ override public void   (  service cache listener listener  executor executor )  {  listener container . add listener ( listener executor )  ;  discovery . get client (  )  . get connection state listenable (  )  . add listener ( listener executor )  ;  
public void   (  part part )  {  parts . add ( part )  ;   }  
public  builder   (  meta data key key  string value )  {  result . metadata . put ( key . get name (  )  value )  ;  return this ;   }  
public  builder   (  string key  string val )  {  result . metadata . put ( key val )  ;  return this ;   }  
protected void   (  object mapper mapper )  {  mapper . add mix in (  instance info . class  mini instance info mix in . class )  ;  bind amazon info filter ( mapper )  ;   }  
public void   (  application app )  {  app name application map . put ( app . get name (  )  . to upper case (  locale . root )  app )  ;  add instances tovip maps ( app this . virtual host name app map this . secure virtual host name app map )  ;  applications . add ( app )  ;   }  
private void   (  instance info info  string vip addresses  map <  string  vip index support >  vip map )  {  if  ( vip addresses  !  =  null )   {   string[] vip address array = vip addresses . to upper case (  locale . root )  . split ( " " )  ;  for  (   string vip address : vip address array )   {   vip index support vis = vip map . compute if absent ( vip address k  -  >  new  vip index support (  )  )  ;  vis . instances . add ( info )  ;   }   }   }  
private void   (  application app  map <  string  vip index support >  virtual host name app map  map <  string  vip index support >  secure virtual host name app map )  {  for  (   instance info info : app . get instances (  )  )   {   string vip addresses = info . getvip address (  )  ;  if  ( vip addresses  !  =  null )   {  add instance to map ( info vip addresses virtual host name app map )  ;   }   string secure vip addresses = info . get secure vip address (  )  ;  if  ( secure vip addresses  !  =  null )   {  add instance to map ( info secure vip addresses secure virtual host name app map )  ;   }   }   }  
public void   (  instance info i )  {  instances map . put ( i . get id (  )  i )  ;  synchronized  ( instances )   {  instances . remove ( i )  ;  instances . add ( i )  ;  is dirty = true ;   }   }  
@ override protected void   (  builder web resource )  {  if  ( additional headers  !  =  null )   {  for  (   string key : additional headers . key set (  )  )   {  web resource . header ( key additional headers . get ( key )  )  ;   }   }   }  
private void   (  monitored connection manager cm )  {  if  ( proxy user name  !  =  null && proxy password  !  =  null )   {  get properties (  )  . put (  apache http client4 config . property   proxy   username proxy user name )  ;  get properties (  )  . put (  apache http client4 config . property   proxy   password proxy password )  ;   }  else  {  get properties (  )  . put (  apache http client4 config . property   proxy   username "guest" )  ;  get properties (  )  . put (  apache http client4 config . property   proxy   password "guest" )  ;   }  get properties (  )  . put (  default apache http client4 config . property   proxy   uri "http: /  / "  +  proxy host  +  ":" +  proxy port )  ;   }  
private void   (  apache http client4 discovery apache client )  {  discovery apache client . add filter ( new gzip content encoding filter ( false )  )  ;   string ip = my instance info  =  =  null  ?  null : my instance info . getip addr (  )  ;   abstract eureka identity identity = client identity  =  =  null  ?  new  eureka client identity ( ip )  : client identity ;  discovery apache client . add filter ( new  eureka identity header filter ( identity )  )  ;  if  ( additional filters  !  =  null )   {  for  (   client filter filter : additional filters )   {  if  ( filter  !  =  null )   {  discovery apache client . add filter ( filter )  ;   }   }   }   }  
private void   (  client config client config )  {  if  ( proxy user name  !  =  null && proxy password  !  =  null )   {  client config . get properties (  )  . put (  apache http client4 config . property   proxy   username proxy user name )  ;  client config . get properties (  )  . put (  apache http client4 config . property   proxy   password proxy password )  ;   }  else  {  client config . get properties (  )  . put (  apache http client4 config . property   proxy   username "guest" )  ;  client config . get properties (  )  . put (  apache http client4 config . property   proxy   password "guest" )  ;   }  client config . get properties (  )  . put (  default apache http client4 config . property   proxy   uri "http: /  / "  +  proxy host  +  ':' +  proxy port )  ;   }  
protected void   (  )  {   application myapp delta = new  application ( local   region   app3   name )  ;   instance info instance info = create instance ( local   region   app3   name all   regions   vip3   addr local   region   app3   instance1   hostname null )  ;  instance info . set action type (  instance info .  action type . added )  ;  myapp delta . add instance ( instance info )  ;  mock local eureka server . add local region apps delta ( local   region   app3   name myapp delta )  ;   }  
protected void   ( boolean include remote  applications apps )  {  for  (   application application : application delta map . values (  )  )   {  apps . add application ( application )  ;   }  if  ( include remote )   {  for  (   application application : remote region apps delta . values (  )  )   {  apps . add application ( application )  ;   }   }   }  
public void   (  string app name  application app )  {  application map . put ( app name app )  ;   }  
public void   (  string app name  application app )  {  application delta map . put ( app name app )  ;   }  
public void   (  string app name  application app )  {  remote region apps . put ( app name app )  ;   }  
public void   (  string app name  application app )  {  remote region apps delta . put ( app name app )  ;   }  
private void   (  )  {  if  ( proxy user name  !  =  null && proxy password  !  =  null )   {  property (  client properties . proxy   username proxy user name )  ;  property (  client properties . proxy   password proxy password )  ;   }  else  {  property (  client properties . proxy   username "guest" )  ;  property (  client properties . proxy   password "guest" )  ;   }  property (  client properties . proxy   uri "http: /  / "  +  proxy host  +  ":" +  proxy port )  ;   }  
private void   (  client config client config )  {   discovery jersey provider discovery jersey provider = new  discovery jersey provider ( encoder wrapper decoder wrapper )  ;  client config . register ( discovery jersey provider )  ;   }  
private void   (  client config client config )  {  if  ( proxy host  !  =  null )   {   string proxy address = proxy host ;  if  ( proxy port  >  0 )   {  proxy address +  = ':'  +  proxy port ;   }  client config . property (  client properties . proxy   uri proxy address )  ;  if  ( proxy user name  !  =  null )   {  if  ( proxy password  =  =  null )   {  throw new  illegal argument exception ( " proxy user name provided but not password" )  ;   }  client config . property (  client properties . proxy   username proxy user name )  ;  client config . property (  client properties . proxy   password proxy password )  ;   }   }   }  
@ override protected void   (  builder web resource )  {  if  ( additional headers  !  =  null )   {  for  (   map .  entry <  string  list <  object >  >  entry : additional headers . entry set (  )  )   {  web resource . header ( entry . get key (  )  e
public void   (  replication instance instance )  {  replication list . add ( instance )  ;   }  
public void   (  replication instance response single response )  {  response list . add ( single response )  ;   }  
private static  http servlet request   (  http servlet request request )  {  return new  http servlet request wrapper ( request )  {  @ override public  enumeration <  string >  get headers (   string name )  {  if  (  http headers . accept   encoding . equals ( name )  )   {  return new  enum wrapper <  string >  ( "gzip" )  ;   }  return new  enum wrapper <  string >  ( super . get headers ( name )   http headers . accept   encoding )  ;   }  @ override public  enumeration <  string >  get header names (  )  {  return new  enum wrapper <  string >  ( super . get header names (  )   http headers . accept   encoding )  ;   }  @ override public  string get header (   string name )  {  if  (  http headers . accept   encoding . equals ( name )  )   {  return "gzip" ;   }  return super . get header ( name )  ;   }   }   ;   }  
@ override public boolean   ( e e )  {  this . make space if not available (  )  ;  return super . add ( e )  ;   }  
@post @ consumes (  { "application / json" "application / xml" }  )  public  response   (  instance info info @ header param (  peer eureka node . header   replication )   string is replication )  {  logger . debug ( " registering instance  {  }   ( repli
@ override protected void   (  builder web resource )  {  web resource . header (  peer eureka node . header   replication "true" )  ;   }  
public  builder   (  string key  string value )  {  if  ( result . application stats  =  =  null )   {  result . application stats = new  hash map <  string  string >  (  )  ;   }  result . application stats . put ( key value )  ;  return this ;   }  
@ override protected void   (  builder web resource )  {  web resource . header (  peer eureka node . header   replication "true" )  ;   }  
public apm configuration change listener change listener )  {  change listeners . add ( change listener ) ;  }  
override public void   (  string s )  {   filter item filter item = new  filter item (  ) ;  string[] class and method = s . split ( "@" ) ; filter item . set class name ( class and method[0] ) ; if  ( class and method . length  >  1 )   {  filter item . set method name ( class and method[1] ) ;  }  black filter list . ad
override public void   (  string s )  {   filter item filter item = new  filter item (  ) ;  string[] class and method = s . split ( "@" ) ; filter item . set class name ( class and method[0] ) ; if  ( class and method . length  >  1 )   {  filter item . set method name ( class and method[1] ) ;  }  white filter list . ad
public string name  string description )  {   method description method description = new  method description ( get class name (  )  name description ) ; all methods . put if absent ( method description . get method signature (  )  method description ) ;  }  
public string   (  string name  string description )  {   string key =  method description . get method signature ( name description ) ;  method description method description = all methods . get ( key ) ; assert  ( method description  !  =  null ) ; transformed methods . put if absent ( key method description ) ; return key;  }  
private thread thread  stack trace element[] stack trace elements )  {  if  ( thread  !  =  null && thread . is alive (  )  && stack trace elements  !  =  null && stack trace elements . length  >  0 )   {   stack trace element top of stack = stack trace elements[0];  string current method = get current method ( top of stack ) ; if  ( configuration . is audit ( top of stack . get class name (  )  top of stack . get method name (  )  )  )   {   string last method = current methods . put ( thread . get id (  )  current method ) ; if  ( last method  =  =  null )   {  context . enter method ( thread current method true ) ;  }  else if  (  ! last method . equals ( current method )  )   {  context . exit method ( thread last method true ) ;  }  else  {   }   }   }   }  
private object target  class start class  class <  object >  stop class  linked hash map <  string  object >  map )  {  if  ( start class  !  =  stop class )   {  add fields ( target start class . get superclass (  )  stop class map ) ;  }   field[] fields = start class . get declared fields (  ) ; for  (   field field : fields )   {  if  (  modifier . is static ( field . get modifiers (  )  )  ||  modifier . is transient ( field . get modifiers (  )  )  ||  modifier . is private ( field . get modifiers (  )  )  )   {  continue;  }  try  {  field . set accessible ( true ) ;  object o = field . get ( target ) ; if  ( o  !  =  null && o . get class (  )  . is array (  )  )   {  try  {  o =  arrays . as list (  (  object[] ) o ) ;  }  catch  (   exception e )   {   }   }  map . put ( field . get name (  )  o ) ;  }  catch  (   exception e )   {  e . print stack trace (  ) ;  }   }   }  
protected list <  kubernetes list >  kube configs  object dto  controller controller  configuration configuration  logger log  string namespace  string source name )  {  dto = expand template ( controller configuration log namespace source name dto ) ; if  ( dto instanceof  kubernetes list )   {  kube configs . add (  (  kubernetes list ) dto ) ;  }  else if  ( dto instanceof  has metadata )   {   kubernetes list wrapped item = new  kubernetes list builder (  )  . with items (  (  has metadata ) dto )  . build (  ) ; kube configs . add ( wrapped item ) ;  }  else  {  throw new  illegal argument exception ( " unsupported object type in "  +  source name  +  " .   class: " +   ( dto  !  =  null  ?  dto . get class (  )  . get name (  )  : "null object" )  ) ;  }   }  
public iterable <  has metadata >  items  string registry )  throws  exception  {  if  ( items  !  =  null )   {  for  (   has metadata item : items )   {  if  ( item instanceof  kubernetes list )   {   kubernetes list list =  (  kubernetes list ) item; add registry to image name if not present ( list . get items (  )  registry ) ;  }  else if  ( item instanceof  template )   {   template template =  (  template ) item; add registry to image name if not present ( template . get objects (  )  registry ) ;  }  else if  ( item instanceof  pod )   {   list <  container >  containers =  (  (  pod ) item )  . get spec (  )  . get containers (  ) ; prefix registry if not present ( containers registry ) ;  }  else if  ( item instanceof  replication controller )   {   list <  container >  containers =  (  (  replication controller ) item )  . get spec (  )  . get template (  )  . get spec (  )  . get containers (  ) ; prefix registry if not present ( containers registry ) ;  }  else if  ( item instanceof  replica set )   {   list <  container >  containers =  (  (  replica set ) item )  . get spec (  )  . get template (  )  . get spec (  )  . get containers (  ) ; prefix registry if not present ( containers registry ) ;  }  else if  ( item instanceof  deployment config )   {   list <  container >  containers =  (  (  deployment config ) item )  . get spec (  )  . get template (  )  . get spec (  )  . get containers (  ) ; prefix registry if not present ( containers registry ) ;  }  else if  ( item instanceof  deployment )   {   list <  container >  containers =  (  (  deployment ) item )  . get spec (  )  . get template (  )  . get spec (  )  . get containers (  ) ; prefix registry if not present ( containers registry ) ;  }   }   }   }  
p o s t @ path ( " / binarybooks" )  @ produces ( "text / xml" )  @ consumes ( "application / octet - stream" )  public  response   ( long[] book )  {  return  response . ok ( book )  . build (  ) ;  }  
p o s t @ path ( " / booksinfo" )  @ produces ( "text / xml" )  @ consumes ( "application / xml" )  public  response   ( @ xml java type adapter (  book info adapter . class )   book info book info )  {  return  response . ok ( book info . as book (  )  )  . build (  ) ;  }  
p o s t @ path ( " / books2" )  @ produces ( "text / xml" )  @ consumes ( "application / xml" )  public  book   (  book book )  {  return new  book ( " book echo" book . get id (  )   +  1 ) ;  }  
p o s t @ path ( " / books / customstatus" )  @ produces ( "application / xml" )  @ consumes ( "text / xml" )  public  book   (  book book @ context  http servlet response response )  {  response . set status ( 233 ) ; response . add header ( " custom header" " custom value" ) ; book . set id ( 888 ) ; return book; 
public string name  string url )  {  if  ( links  =  =  null )   {  links = new  tree map <  >  (  ) ;  }  links . put ( name url ) ;  }  
public string   (  logger log  string template  string parameter name  string parameter value  string description )  {  try  {   document doc = parse xml text ( template ) ;  element root element = doc . get document element (  ) ;  node list parameter defs = root element . get elements by tag name ( "parameter definitions" ) ; if  ( parameter defs  !  =  null && parameter defs . get length (  )   >  0 )   {   node param def node = parameter defs . item ( 0 ) ;  element string param def =  dom helper . add child element ( param def node "hudson . model .  string parameter definition" ) ;  dom helper . add child element ( string param def "name" parameter name ) ;  dom helper . add child element ( string param def "default value" parameter value ) ; if  (  strings . is not blank ( description )  )   {   dom helper . add child element ( string param def "description" description ) ;  }  return  dom helper . to xml ( doc ) ;  }  else  {  log . warn ( " could not find the  < parameter definitions >  to add the build parameter name "  +  parameter name  +  " with value: " +  parameter value ) ;  }   }  catch  (   exception e )   {  log . error ( " failed to add the build parameter from the  jenkins  x m l .  "  +  e e ) ;  }  return template;  }  
protected string jenkins job url )  {  if  (  strings . is null or blank ( jenkins job template )  )   {  get log (  )  . warn ( " cannot add  s c m trigger to jenkins job at "  +  jenkins job url  +  " as there is no cached template" ) ;  }  else if  (  ! local jenkins flow )   {  get log (  )  . info ( " not adding an  s c m trigger to jenkins job at "  +  jenkins job url  +  " as it is not using a local  jenkinsfile" ) ;  }  else  {  get log (  )  . info ( " adding adding an  s c m trigger to jenkins job at "  +  jenkins job url ) ;  string template = null; try  {  template = jenkins job template;  document doc = parse xml text ( template ) ;  element root element = doc . get document element (  ) ;  element trigger element = null;  node list triggers = root element . get elements by tag name ( "triggers" ) ; if  ( triggers  =  =  null || triggers . get length (  )   =  =  0 )   {  trigger element =  dom helper . add child element ( root element "triggers" ) ;  }  else  {  trigger element =  (  element ) triggers . item ( 0 ) ;  }   string host name =  git utils . get git host name ( git url ) ; get log (  )  . info ( "using git host: "  +  host name ) ; if  (  objects . equal ( "github . com" host name )  )   {   element github trigger =  dom helper . first child ( trigger element "com . cloudbees . jenkins .  git hub push trigger" ) ; if  ( github trigger  =  =  null )   {  github trigger =  dom helper . add child element ( trigger element "com . cloudbees . jenkins .  git hub push trigger" ) ; github trigger . set attribute ( "plugin" "github@1 . 14 . 0" ) ;  dom helper . add child element ( github trigger "spec" ) ;  }   }   element scm trigger =  dom helper . add child element ( trigger element "hudson . triggers .  s c m trigger" ) ;  dom helper . add child element ( scm trigger "spec" "* * * * * " ) ;  dom helper . add child element ( scm trigger "ignore post commit hooks" "false" ) ; template =  dom helper . to xml ( doc ) ;  }  catch  (   exception e )   {  get log (  )  . warn ( " failed to add the  s c m trigger to jenkins job at "  +  jenkins job url  +  " .   reason: " +  e e ) ; template = null;  }  if  (  strings . is not blank ( template )  )   {  post jenkins build ( jenkins job name template false ) ;  }   }   }  
public string label  string url )  {  if  ( project config  =  =  null )   {  project config = new  project config (  ) ;  }  project config . add link ( label url ) ; modified config = true;  }  
public file dir )  {  if  ( dir  !  =  null && dir . is directory (  )  )   {   file[] children = dir . list files (  ) ; if  ( children  =  =  null || children . length  =  =  0 )   {   file dummy file = new  file ( dir " . gitkeep" ) ; try  {   i o helpers . write fully ( dummy file " this file is only here to avoid git removing empty folders\n once there are files in this folder feel free to delete this file ! " ) ;  }  catch  (   i o exception e )   {   l o g . warn ( " failed to write file "  +  dummy file  +  " .  " +  e e ) ;  }   }  else  {  for  (   file child : children )   {  if  ( child . is directory (  )  )   {  add dummy file to empty folders ( child ) ;  }   }   }   }   }  
public git git  file .  .  .  files )  throws  git a p i exception   i o exception  {   file root dir = get root git directory ( git ) ; for  (   file file : files )   {   string relative path = get file pattern ( root dir file ) ; git . add (  )  . add filepattern ( relative path )  . call (  ) ;  }   }  
public collection <  t >  items )  {  collectors . add ( new  collector <  t >  (  )  {  @ override public  collection <  t >  get collection (  )  {  return items;  }   }   ) ;  }  
public collector <  t >  collector )  {  collectors . add ( collector ) ;  }  
public element   (  node parent  string element name  string text content )  {   element element = add child element ( parent element name ) ; element . set text content ( text content ) ; return element;  }  
public throwable e )  {  causes . add ( e ) ;  }  
public template template  has metadata object )  {   list <  has metadata >  objects = template . get objects (  ) ; objects . add ( object ) ; template . set objects ( objects ) ;  }  
suppress warnings ( "unchecked" )  protected static void   (  list destination list  object object )  throws  i o exception  {  if  ( object instanceof  kubernetes list )   {   kubernetes list kubernetes list =  (  kubernetes list ) object;  list <  has metadata >  items = kubernetes list . get items (  ) 
public project d t o project  user d t o user )  {  if  ( user  !  =  null )   {   objects . not null ( project "project" ) ;  list <  user d t o >  users = project . get users (  ) ; if  ( users  =  =  null )   {  users = new  array list <  >  (  ) ;  }  users . add ( user ) ; project . set users ( users ) ;  }   }  
protected string json schema type  string .  .  .  java type names )  {  for  (   string java type name : java type names )   {  java to json schema types . put ( java type name json schema type ) ;  }   }  
private path child  object content )  {   string par = " / "  +  path . relativize ( child . get parent (  )  )  . to string (  ) ;  string str = " / "  +  path . relativize ( child )  . to string (  ) ; if  (  ! " / " . equals ( str )  )   {  if  ( str . ends with ( " / " )  )   {  str = str . substring ( 0 str . length (  )   -  1 ) ;  }   (  (  list <  string >  ) contents . get ( par )  )  . add ( str ) ;  }  contents . put ( str content ) ;  }  
public void   (  string mac  string host  string ip )  {   dhcp mapping map = new  dhcp mapping ( mac host ip )  ;  dhcp maps . add ( map )  ;   }  
public void   (  string start  string end )  {  ip range ipr = new ip range ( start end )  ;  ipranges . add ( ipr )  ;   }  
private void   (  connection conn long host id long physical network id )  {  s   logger . debug ( " adding f5  big ip load balancer with host id "  +  host id  +  " in to physical network" +  physical network id )  ;   string insertf5 = "insert into `cloud` . `external   load   balancer   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  is   inline  is   managed  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertf5 )  )  {  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 "f5 big ip load balancer" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set boolean ( 9 false )  ;  pstmt update . set boolean ( 10 false )  ;  pstmt update . set string ( 11 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding f5 load balancer device" e )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {  s   logger . debug ( " adding  physical network service provider f5 big ip"  +  " in to physical network"  +  physical network id )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 0 0 0 1 0 0 0 0 ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertpnsp )  )  {  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider f5 big ip" e )  ;   }   }  
private void   (  connection conn long host id long physical network id )  {   prepared statement pstmt update = null ;  try  {  s   logger . debug ( " adding f5  big ip load balancer with host id "  +  host id  +  " in to physical network" +  physical network id )  ;   string insertf5 = "insert into `cloud` . `external   load   balancer   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  is   inline  is   managed  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  pstmt update = conn . prepare statement ( insertf5 )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 "f5 big ip load balancer" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set boolean ( 9 false )  ;  pstmt update . set boolean ( 10 false )  ;  pstmt update . set string ( 11 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding f5 load balancer device" e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {   prepared statement pstmt update = null ;  try  {  s   logger . debug ( " adding  physical network service provider f5 big ip"  +  " in to physical network"  +  physical network id )  ;   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 0 0 0 1 0 0 0 0 ) " ;  pstmt update = conn . prepare statement ( insertpnsp )  ;  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider f5 big ip" e )  ;   }  finally  {  close auto closeable ( pstmt update )  ;   }   }  
private void   (  connection conn long host id long physical network id )  {   string insertf5 = "insert into `cloud` . `external   load   balancer   devices`  ( physical   network   id  host   id  provider   name  "  +  "device   name  capacity  is   dedicated  device   state  allocation   state  is   managed  uuid )  values  (   ?    ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertf5 )  )  {  s   logger . debug ( " adding f5  big ip load balancer with host id "  +  host id  +  " in to physical network" +  physical network id )  ;  pstmt update . set long ( 1 physical network id )  ;  pstmt update . set long ( 2 host id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 "f5 big ip load balancer" )  ;  pstmt update . set long ( 5 0 )  ;  pstmt update . set boolean ( 6 false )  ;  pstmt update . set string ( 7 " enabled" )  ;  pstmt update . set string ( 8 " shared" )  ;  pstmt update . set boolean ( 9 false )  ;  pstmt update . set string ( 10 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding f5 load balancer device" e )  ;   }   }  
private void   (  connection conn long physical network id long zone id )  {   string insertpnsp = "insert into `cloud` . `physical   network   service   providers`  ( `uuid`  `physical   network   id`   `provider   name`  `state`  "  +  "`destination   physical   network   id`  `vpn   service   provided`  `dhcp   service   provided`  `dns   service   provided`  `gateway   service   provided` "  +  "`firewall   service   provided`  `source   nat   service   provided`  `load   balance   service   provided`  `static   nat   service   provided` " +  "`port   forwarding   service   provided`  `user   data   service   provided`  `security   group   service   provided` )  values  (  ?   ?   ?   ?  0 0 0 0 0 0 0 1 0 0 0 0 ) " ;  try  (  prepared statement pstmt update = conn . prepare statement ( insertpnsp )  )  {  s   logger . debug ( " adding  physical network service provider f5 big ip"  +  " in to physical network"  +  physical network id )  ;  pstmt update . set string ( 1 uuid . randomuuid (  )  . to string (  )  )  ;  pstmt update . set long ( 2 physical network id )  ;  pstmt update . set string ( 3 "f5 big ip" )  ;  pstmt update . set string ( 4 " enabled" )  ;  pstmt update . execute update (  )  ;   }  catch  (  sql exception e )   {  throw new  cloud runtime exception ( " exception while adding  physical network service provider f5 big ip" e )  ;   }   }  
@ override public  external load balancer devicevo   (  addf5 load balancer cmd cmd )  {   string device name = cmd . get device type (  )  ;  if  (  ! device name . equals ignore case (  network device . f5 big ip load balancer . get name (  )  )  )   { 
@db @ override @ action event ( event type =  event types . event   iam   policy   grant event description = " granting acl permission to iam  policy" )  public iam policy   ( long iam policy id  string entity type  permission scope scope  long scope id  
@db @ override public iam policy   ( long iam policy id  string entity type  string scope  long scope id  string action  string access type  permission perm  boolean recursive )  {  iam policy policy =    acl policy dao . find by id ( iam policy id )  ;  
public  addressdto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  customer creditdto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  credit carddto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  gateway customerdto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  gift carddto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  payment requestdto   (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  line itemdto   (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
public  subscriptiondto < t >    (  string key  object value )  {  additional fields . put ( key value )  ;  return this ;   }  
@ override public  service provider builder < t >    (  instance filter < t >  filter )  {  filters . add ( filter )  ;  return this ;   }  
private void   ( final  string ns monitor name final  string lb protocol final  health check policyto hcp )  throws  execution exception  {  try  {  boolean cs monitor exisis = false ;  final lbmonitor cs monitor = get monitor if exisits ( ns monitor name )  ;  if  ( cs monitor  !  =  null )   {  if  (  ! cs monitor . get   type (  )  . equals ignore case ( lb protocol )  )   {  throw new  execution exception ( " can not update monitor :"  +  ns monitor name  +  " as current protocol:" +  cs monitor . get   type (  )  +  " of monitor is different from the " +  " intended protocol:" +  lb protocol )  ;   }  cs monitor exisis = true ;   }  if  (  ! cs monitor exisis )   {  final lbmonitor cs mon = new lbmonitor (  )  ;  cs mon . set   monitorname ( ns monitor name )  ;  cs mon . set   type ( lb protocol )  ;  if  ( lb protocol . equals ignore case ( "http" )  )   {  cs mon . set   httprequest ( hcp . getping path (  )  )  ;  s   logger . trace ( "lb  protocol is http   applying ping path on  health check  policy" )  ;   }  else  {  s   logger . debug ( "lb  protocol is not http   skipping to apply ping path on  health check  policy" )  ;   }  cs mon . set   interval ( hcp . get healthcheck interval (  )  )  ;  cs mon . set   retries (  math . max ( hcp . get healthcheck thresshold (  )  hcp . get unhealth thresshold (  )  )   +  1 )  ;  cs mon . set   resptimeout ( hcp . get response time (  )  )  ;  cs mon . set   failureretries ( hcp . get unhealth thresshold (  )  )  ;  cs mon . set   successretries ( hcp . get healthcheck thresshold (  )  )  ;  s   logger . debug ( " monitor properites going to get created :interval :: "  +  cs mon . get   interval (  )   +  "resp timeo ut:: " +  cs mon . get   resptimeout (  )  +  "failure retires ( unhealththresshold )  :: " +  cs mon . get   failureretries (  )  +  "successtries ( healththresshold )  ::" +  cs mon . get   successretries (  )  )  ;  lbmonitor . add (    netscaler service cs mon )  ;   }  else  {  s   logger . debug ( " monitor :"  +  ns monitor name  +  " is already existing .   skipping to delete and create it" )  ;   }   }  catch  (  final nitro   exception e )   {  throw new  execution exception ( " failed to create new monitor :"  +  ns monitor name  +  " due to " +  e . get message (  )  )  ;   }  catch  (  final  exception e )   {  throw new  execution exception ( " failed to create new monitor :"  +  ns monitor name  +  " due to " +  e . get message (  )  )  ;   }   }  
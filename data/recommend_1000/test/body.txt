@ override public int   ( int mode )  {  return transitive boundary fusion ( mode )  ;   }  
@ test public void   (  )  {   flowable <  long >  w =  flowable . interval ( 1  time unit . seconds scheduler )  ;   test subscriber <  long >  ts1 = new  test subscriber <  long >  (  )  ;  w . subscribe ( ts1 )  ;  ts1 . assert no errors (  )  ;  sched
public   ( i2p app context ctx )  {  super ( ctx )  ;   }  
public  string   (  )  {  return email ;   }  
@ override public void   (  )  {  queue . clear (  )  ;   }  
@ test public void   (  )  {   flowable <  movie >  o1 =  flowable . just ( new  horror movie (  )  new  movie (  )  )  ;   flowable <  media >  o2 =  flowable . just ( new  media (  )  new  horror movie (  )  )  ;   list <  media >  values =  flowable . 
public  bundle   (  )  {  if  ( m results  !  =  null )   {  return m results ;   }  final  bundle results = new  bundle ( 2 )  ;  results . put string ( extra   password get password (  )  )  ;  results . put string ( extra   client   cert get client certificate (  )  )  ;  return results ;   }  
public void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "stop datagram receiving (  )  invoked" )  ;  if  ( datagram session  =  =  null )   {     log . error ( "bug !   got datagram receiving stop  but session is null ! " )  ;  return ;   }  try  {  close client socket (  )  ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error closing socket" e )  ;   }   }  
public long   (  )  {  return    highest acked through ;   }  
void   ( final  interval list targets final  interval list baits )  {  this . target   territory =  ( int ) targets . get unique base count (  )  ;  this . target   count = targets . size (  )  ;  this . bait   territory =  ( int ) baits . get unique base count (  )  ;  this . bait   count = baits . size (  )  ;  this . design   efficiency = this . target   territory  /   ( double ) this . bait   territory ;  final  interval list tmp = new  interval list ( targets . get header (  )  )  ;  final  overlap detector <  interval >  detector = new  overlap detector <  interval >  ( 0 0 )  ;  detector . add all ( baits . get intervals (  )  baits . get intervals (  )  )  ;  for  (  final  interval target : targets )   {  final  collection <  interval >  overlaps = detector . get overlaps ( target )  ;  if  ( overlaps . is empty (  )  )   {  this . zero   bait   targets +  +  ;   }  else  {  for  (  final  interval i : overlaps )  tmp . add ( target . intersect ( i )  )  ;   }   }  tmp . uniqued (  )  ;  this . bait   target   territory   intersection =  ( int ) tmp . get base count (  )  ;   }  
private void   ( iq packet  session session  query request query request )  {  iq result = iq . create resultiq ( packet )  ;   element fin = result . set child element ( "fin" namespace )  ;  complete fin element ( query request fin )  ;  session . process ( result )  ;   }  
public boolean   (  )  {  return done ;   }  
@ test ( expected exceptions =  picard exception . class data provider = "invalid files" )  public void   ( final  string file name )  {  final  locs file reader reader = new  locs file reader ( new  file (  test dir file name )  )  ;   }  
  (  subscriber <  ?  super t >  actual  predicate <  ?  super t >  predicate )  {  this . actual = actual ;  this . predicate = predicate ;   }  
public synchronized void   (  )  {     filter = new  decaying hash set (    context  ( int )  router . clock   fudge   factor * 2 8 " routermv" )  ;   }  
@ override protected  disposable   (  worker actual worker  completable observer action completable )  {  count . increment and get (  )  ;  dispose (  )  ;  return  disposables . empty (  )  ;   }  
public void   (  )  {  if  (    closed )  return ;     closed = true ;  long lifetime =    context . clock (  )  . now (  )   -     started ;     context . stat manager (  )  . add rate data ( "sink . "  +     connection id  +  " . lifetime" lifetime lifetime )  ;  try  {     out . close (  )  ;   }  catch  (  io exception ioe )   {     log . info ( " error closing" ioe )  ;   }   }  
@get @ path ( " /  { room name } " )  @ produces (  {  media type . application   xml  media type . application   json }  )  public muc room entity   ( @ path param ( "room name" )   string room name @ default value ( "conference" )  @ query param ( "serv
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  single < r >    ( final  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper )  {   object helper . require non null ( mapper "mapper i
  (  sequential disposable serial  observer <  ?  super t >  child )  {  this . serial = serial ;  this . child = child ;   }  
public void   (  observable source <  ?  extends t > [] sources int buffer size )  {   zip observer < t r > [] s = observers ;  int len = s . length ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  s[i] = new  zip observer < t r >  ( this buffer size )  ;   }  this . lazy set ( 0 )  ;  actual . on subscribe ( this )  ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  if  ( cancelled )   {  return ;   }  sources[i] . subscribe ( s[i] )  ;   }   }  
void   ( int digest frequency )  {  this . digest frequency = digest frequency ;   }  
@ override public int   (  )  {  return this . start ;   }  
public double   (  )  {  return xff ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe <  integer >  error =  maybe . error ( new  runtime exception (  )  )  ;   maybe . amb array (  maybe . just ( 1 )  error )  . test (  )  . assert value ( 1 )  ;   }  
protected void   (  string property  map <  string  object >  params )  {  switch  ( property )   {  case  directory watcher . property   enabled: case  directory watcher . property   watched   path: directory watcher . stop (  )  ;  directory watcher . start (  )  ;  break ;   }   }  
public synchronized double   (  )  {  if  (  (    extreme event count  >  0 )  &&  (    extreme total event time  >  0 )  )   {  double event time =  ( double )    extreme total event time  /   ( double )    extreme event count ;  double max events =    period  /  event time ;  return    extreme event count  /  max events ;   }  return 0 . 0d ;   }  
  (  string .  .  .  values )  {  this . values = values ;   }  
public static  email service info   (  context context  string protocol )  {  return get service map ( context )  . get ( protocol )  ;   }  
@ override public void   (  )  {  source . subscribe ( parent )  ;   }  
private void   ( boolean dispose eagerly )  {   callable <  resource >  resource factory = new  callable <  resource >  (  )  {  @ override public  resource call (  )  {  return new  resource (  )  {  boolean first = true ;  @ override public  string get text from web (  )  {  if  ( first )   {  first = false ;  return " hello world ! " ;   }  return " nothing" ;   }  @ override public void dispose (  )  {   }   }   ;   }   }   ;   function <  resource  observable <  string >  >  observable factory = new  function <  resource  observable <  string >  >  (  )  {  @ override public  observable <  string >  apply (   resource res )  {  return  observable . from array ( res . get text from web (  )  . split ( " " )  )  ;   }   }   ;   observer <  string >  observer =  test helper . mock observer (  )  ;   observable <  string >  o =  observable . using ( resource factory observable factory new  dispose action (  )  dispose eagerly )  ;  o . subscribe ( observer )  ;  o . subscribe ( observer )  ;   in order in order = in order ( observer )  ;  in order . verify ( observer times ( 1 )  )  . on next ( " hello" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "world ! " )  ;  in order . verify ( observer times ( 1 )  )  . on complete (  )  ;  in order . verify ( observer times ( 1 )  )  . on next ( " hello" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "world ! " )  ;  in order . verify ( observer times ( 1 )  )  . on complete (  )  ;  in order . verify no more interactions (  )  ;   }  
public   (  string mod path )  throws io exception  {  super ( new url[0] )  ;  load modules ( mod path )  ;  initialize modules (  )  ;   }  
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 5 )  . concat with (  single . just ( 100 )  )  . take ( 3 )  . subscribe ( to )  ;  to . assert result ( 1 2 3 )  ;   
@ override public  string   (  )  {  return get service name (  )  ;   }  
public boolean   (  )  {  return false ;   }  
void   ( i2cp message msg )  {  try  {  msg . write message (    out )  ;     out . flush (  )  ;   }  catch  (  i2cp message exception ime )   {     log . error ( " error sending i2cp message to client" ime )  ;  stop running (  )  ;   }  catch  (  eof exception eofe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error sending i2cp message  -  client went away" eofe )  ;  stop running (  )  ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . error )  )     log . error ( "io  error sending i2cp message to client" ioe )  ;  stop running (  )  ;   }  catch  (   throwable t )   {     log . log (  log . crit " unhandled exception sending i2cp message to client" t )  ;  stop running (  )  ;   }   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  open =  publish subject . create (  )  ;  final  publish subject <  integer >  close =  publish subject . create (  )  
private void   (  call handler handler )  {   log . info ( " rayo component kill speaker" )  ;  try  {  handler . cancel request ( " speaker is destroyed" )  ;   call participant cp = handler . get call participant (  )  ;   string conf id = cp . get conference id (  )  ;  handler = null ;   conference manager conference manager =  conference manager . find conference manager ( conf id )  ;   array list member list = conference manager . get member list (  )  ;  synchronized  ( member list )   {  for  ( int i = 0 ;  i  <  member list . size (  )  ;  i +  +  )   {   call handler participant =  (  (  conference member ) member list . get ( i )  )  . get call handler (  )  ;  if  ( participant  !  =  null )   {  participant . cancel request ( " speaker is destroyed" )  ;  participant = null ;   }   }   }   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer ( 2 )  ;  final  atomic integer number of subscribe calls = new  atomic integer ( 0 )  ;   completable . from action ( new  action (  )  {  @ override public void run
public   (  )  {  super ( " session  manager" )  ;  if  (  jive globals . get boolean property ( "xmpp . audit . active" )  )   {  streamid factory = new  audit streamid factory (  )  ;   }  else  {  streamid factory = new  basic streamid factory (  )  ;   }  local session manager = new  local session manager (  )  ;  conflict limit =  jive globals . get int property ( "xmpp . session . conflict - limit" 0 )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . filter (  functions . always true (  )  )  . rebatch requests ( 1 )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
@ override protected void   (  )  throws  throwable  {  try  {  destroy (  )  ;   }  finally  {  super . finalize (  )  ;   }   }  
public void   ( double total value long event count double total event time long period )  {  long now = now (  )  ;  long when = now  /  1000 ;  if  (    db  !  =  null )   {  try  {     sample . set time ( when )  ;  double val = event count  >  0  ?   ( total value  /  event count )  : 0d ;     sample . set value (    name val )  ;     sample . set value (    event name event count )  ;     sample . update (  )  ;   }  catch  (   illegal argument exception iae )   {     log . error ( " error adding" iae )  ;   string path =    is persistent  ?     db . get path (  )  : null ;  stop listening (  )  ;  if  ( path  !  =  null )   ( new  file ( path )  )  . delete (  )  ;   }  catch  (  io exception ioe )   {     log . error ( " error adding" ioe )  ;  stop listening (  )  ;   }  catch  (   rrd exception re )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error adding" re )  ;   }   }   }  
@ test public void   (  )  throws  exception  {  fo . on complete (  )  ;  fo . on error ( new  test exception ( " one" )  )  ;  try  {  assert null ( fo . get ( 5  time unit . milliseconds )  )  ;   }  catch  (   execution exception ex )   {  assert true
@ jdbi constructor public   ( long id  string title  string content )  {  set id ( id )  ;  set title ( title )  ;  set content ( content )  ;   }  
protected void   (  string text )  throws io exception  {  if  ( format . is newlines (  )  )   {  println (  )  ;  indent (  )  ;   }  writer . write ( " <  !  -  - " )  ;  writer . write ( text )  ;  writer . write ( " -  -  > " )  ;  last output node type =  node . comment   node ;   }  
public void   (  string contact )  {  violation contact = contact ;   jive globals . set property ( violation   notification   contact   property contact )  ;   }  
@ test public void   (  )  {  final  atomic boolean unsub = new  atomic boolean (  )  ;   observable . range ( 1 10 )  . concat with (  observable .  <  integer > never (  )  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  {  un
@ override public  observable source <  object >    (  single <  object >  s )  throws  exception  {  return s . to observable (  )  ;   }  
public static  queued tasks manager   (  )  {  return instance ;   }  
private  string   (  statistic .  type type )  {  switch  ( type )   {  case count: return  consol funs . cf   last ;  default : return  consol funs . cf   average ;   }   }  
@ test public void   (  )  {   replay processor <  integer >  source =  replay processor . create with size ( 1 )  ;  source . on next ( 1 )  ;  source . on next ( 2 )  ;  source . on error ( new  test exception (  )  )  ;   size bound replay buffer <  in
public  < k extends  comparable <  ?  super k >  v > b skip list < k v >    (  string name  serializer < k >  key  serializer < v >  val )  throws io exception  {  if  ( meta index . get ( name )   !  =  null )   {  throw new io exception ( " index already exists" )  ;   }  int page = alloc page (  )  ;  meta index . put ( name  integer . value of ( page )  )  ;  b skip list . init ( this page span size )  ;  b skip list < k v >  bsl = new b skip list < k v >  ( span size this page key val true )  ;  open indices . put ( name bsl )  ;  return bsl ;   }  
public void   (  packet packet )  {  if  ( is activated (  )  )   {  get session (  )  . get transport (  )  . send packet ( packet )  ;   }   }  
public void   ( long len )  {  set long header ( http . content   length len )  ;   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  setup open folder ( mock )  ;  m folder . open (  open mode . read   write )  ;   imap message message = prepare for append test ( mock "no  no space left on the server . " )  ;  assert equals ( "initial uid" message . get uid (  )  )  ;  mock . expect literally ( get next tag ( false )   +  " uid search header message - id  < message . id@test . com > " new  string[] { "* search" get next tag ( true )   +  " ok  search completed . " }  )  ;  mock . expect literally ( get next tag ( false )   +  " uid search  ( header message - id  < message . id@test . com >  ) " new  string[] { "* search" get next tag ( true )   +  " ok  search completed . " }  )  ;  m folder . append message ( get instrumentation (  )  . get target context (  )  message false )  ;  assert equals ( "initial uid" message . get uid (  )  )  ;   }  
boolean   (  inner disposable < t >  producer )  {  for  (  ;   ;   )   {   inner disposable < t > [] c = observers . get (  )  ;  if  ( c  =  =  terminated )   {  return false ;   }  int len = c . length ;  @ suppress warnings ( "unchecked" )   inner disposable < t > [] u = new  inner disposable[len  +  1] ;   system . arraycopy ( c 0 u 0 len )  ;  u[len] = producer ;  if  ( observers . compare and set ( c u )  )   {  return true ;   }   }   }  
public void   (  google mail thread thread )  {  mail threads . add ( thread )  ;   }  
@ override public int   (  )  throws io exception  {  int num bytes = 0 ;  synchronized  (    data lock )   {  if  (    locally closed )  throw new io exception ( " input stream closed" )  ;  throw any error (  )  ;  for  ( int i = 0 ;  i  <     ready dat
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable . just ( 1 )  . hide (  )  . flat map ( new  function <  integer  publisher <  ?  extends  object >  >  (  )  {  @ override public  publisher <  ?  extends  object >  apply (   integer
public void   ( int number of calls )  {  this . number of calls = number of calls ;   }  
public void   (  string host )  {     proxy host = host ;   }  
public void   (  query parameters params )  {  this . params = params ;   }  
public void   ( int[] contribution boolean do not record )  {  if  ( do not record )   {  if  ( do not record mix  =  =  null )   {  do not record mix = new int[contribution . length] ;   system . arraycopy ( contribution 0 do not record mix 0 contribution . length )  ;  return ;   }  mix data ( contribution do not record mix true )  ;  return ;   }  if  ( linear mix buffer  =  =  null )   {  linear mix buffer = new int[contribution . length] ;   system . arraycopy ( contribution 0 linear mix buffer 0 contribution . length )  ;  return ;   }  mix data ( contribution linear mix buffer true )  ;   }  
@ override public boolean   ( int index  collection <  ?  extends t >  c )  {  boolean changed = super . add all ( index c )  ;  if  ( changed )   {  synchronized  ( this )   {  known group names in list = null ;   }   }  return changed ;   }  
@ test public void   (  )  {   flowable . just ( 1 2 3 )  . scan ( sum )  . test (  )  . assert values ( 1 3 6 )  . assert complete (  )  ;   }  
public  inet socket address   (  )  {  return address ;   }  
 genericgf poly   (  genericgf poly other )  {  if  (  ! field . equals ( other . field )  )   {  throw new  illegal argument exception ( " genericgf polys do not have same  genericgf field" )  ;   }  if  ( is zero (  )  )   {  return other ;   }  if  ( other . is zero (  )  )   {  return this ;   }  int[] smaller coefficients = this . coefficients ;  int[] larger coefficients = other . coefficients ;  if  ( smaller coefficients . length  >  larger coefficients . length )   {  int[] temp = smaller coefficients ;  smaller coefficients = larger coefficients ;  larger coefficients = temp ;   }  int[] sum diff = new int[larger coefficients . length] ;  int length diff = larger coefficients . length  -  smaller coefficients . length ;   system . arraycopy ( larger coefficients 0 sum diff 0 length diff )  ;  for  ( int i = length diff ;  i  <  larger coefficients . length ;  i +  +  )   {  sum diff[i] =  genericgf . add or subtract ( smaller coefficients[i  -  length diff] larger coefficients[i] )  ;   }  return new  genericgf poly ( field sum diff )  ;   }  
@ override public  string   (  )  {  return description ;   }  
@ test public void   (  )  {   destination dest = new  destination (  )  ;  i2p socket address addr = new i2p socket address ( dest 1234 )  ;  assert that ( addr . get port (  )  is ( 1234 )  )  ;  assert that ( addr . get address (  )  is ( dest )  )  ; 
 linked queue node < t >    (  )  {  return consumer node . get (  )  ;   }  
public int   (  string b32 int port  string type )  {  dcc client manager tracker ;  synchronized  ( this )   {  if  (    dcc client manager  =  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( " starting dcc  client" )  ;     dcc client manager = new dcc client manager ( sock mgr l i2p tunnelirc client . this get tunnel (  )  )  ;   }  tracker =    dcc client manager ;   }  int rv = tracker . new incoming ( b32 port type )  ;  if  (    log . should log (  log . info )  )     log . info ( " new incoming "  +  type  +  ' ' +  b32 +  ' ' +  port +  " returns " +  rv )  ;  return rv ;   }  
public int   (  conversation c1  conversation c2 )  {  return c1 . get start date (  )  . compare to ( c2 . get start date (  )  )  ;   }  
@ test public void   (  )  {   observable . create ( new  observable on subscribe <  object >  (  )  {  @ override public void subscribe (   observable emitter <  object >  e )  throws  exception  {   disposable d =  disposables . empty (  )  ;  e . set d
@ test public void   (  )  {   completable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  throw new  test exception (  )  ;   }   }   new  function <  object  completable source >  (  )  {  @ overr
@ override public void   (  subscriber <  ?  super t >  child )  {  for  (  ;   ;   )   {   replay subscriber < t >  r = curr . get (  )  ;  if  ( r  =  =  null )   {   replay buffer < t >  buf ;  try  {  buf = buffer factory . call (  )  ;   }  catch  ( 
public static  < t >  action   (  observer < t >  observer )  {  return new  observer on complete < t >  ( observer )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  observable < r >    (  function <  ?  super t  ?  extends  observable source <  ?  extends r >  >  mapper )  {  return to observable (  )  . flat map ( mapper )  
@ override public void   (  )  {  cancelled = true ;   }  
public void   ( byte[] data )  {  if  (    data  !  =  null )  throw new  illegal state exception (  )  ;     data = data ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   publisher <  object >  >  (  )  {  @ override public  publisher <  object >  apply (   flowable <  object >  f )  throws  exception  
private static synchronized  blowfish   (  )  {  if  ( cipher  !  =  null )   {  return cipher ;   }   string key string ;  try  {  key string =  jive globals . get property ( "password key" )  ;  if  ( key string  =  =  null )   {  key string =  string utils . random string ( 15 )  ;   jive globals . set property ( "password key" key string )  ;  if  (  ! key string . equals (  jive globals . get property ( "password key" )  )  )   {  return null ;   }   }  cipher = new  blowfish ( key string )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  return cipher ;   }  
public boolean   ( long period )  {  return get rate ( period )   !  =  null ;   }  
public int   (  )  {  return state ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . replay ( new  function <  observable <  integer >   observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   observable <  integer >  v )  throws  exception  {  retu
@ test public void   (  )  {   maybe . just ( 1 )  . flat map ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . empty (  )  ;   }  
private boolean   (  )  {  i2p client client = i2p client factory . create client (  )  ;   file key file = get private key file (  )  ;  if  ( key file  =  =  null )   {  log ( " no filename specified for the private key" )  ;  return false ;   }  if  ( key file . exists (  )  )   {  return true ;   }  else  {   file parent = key file . get parent file (  )  ;  if  (  ( parent  !  =  null )  &&  (  ! parent . exists (  )  )  )  parent . mkdirs (  )  ;   }   file output stream fos = null ;  try  {  fos = new  secure file output stream ( key file )  ;   sig type stype = preferred   sigtype ;   string st =    config . get property ( opt   sig   type )  ;  if  ( st  !  =  null )   {   sig type type =  sig type . parse sig type ( st )  ;  if  ( type  !  =  null && type . is available (  )  )  stype = type ;  else log ( " unsupported sig type "  +  st  +  "  reverting to " +  stype )  ;   }   destination dest = client . create destination ( fos stype )  ;   string dest str = dest . to base64 (  )  ;  log ( " private key created and saved in "  +  key file . get absolute path (  )  )  ;  log ( " you should backup this file in a secure place . " )  ;  log ( " new destination: "  +  dest str )  ;   string b32 = dest . to base32 (  )  ;  log ( " base32: "  +  b32 )  ;   file backup dir = new  secure file ( i2p app context . get global context (  )  . get config dir (  )  key   backup   dir )  ;  if  ( backup dir . is directory (  )  || backup dir . mkdir (  )  )   {   string name = b32  +  ' - '  +  i2p app context . get global context (  )  . clock (  )  . now (  )  +  " . dat" ;   file backup = new  file ( backup dir name )  ;  if  (  file util . copy ( key file backup false true )  )   {   secure file output stream . set perms ( backup )  ;  log ( " private key backup saved to "  +  backup . get absolute path (  )  )  ;   }   }   }  catch  (  i2p exception ie )   {  if  (    log . should log (  log . error )  )     log . error ( " error creating new destination" ie )  ;  log ( " error creating new destination: "  +  ie . get message (  )  )  ;  return false ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . error )  )     log . error ( " error creating writing the destination to "  +  key file . get absolute path (  )  ioe )  ;  log ( " error writing the keys to "  +  key file . get absolute path (  )  )  ;  return false ;   }  finally  {  if  ( fos  !  =  null )  try  {  fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  return true ;   }  
private static void   ( final  file db snp file final sam sequence dictionary sequence dictionary final  map <  db snp bit set util  set <  variant type >  >  bit sets to variant types final  interval list intervals final  optional <  log >  log )  {  final  optional <  progress logger >  progress = log . map ( l  -  >  new  progress logger ( l  ( int ) 1e5 " read" "variants" )  )  ;  final vcf file reader variant reader = new vcf file reader ( db snp file intervals  !  =  null )  ;  final  iterator <  variant context >  variant iterator ;  if  ( intervals  !  =  null )   {  variant iterator = new  by interval list variant context iterator ( variant reader intervals )  ;   }  else  {  variant iterator = variant reader . iterator (  )  ;   }  while  ( variant iterator . has next (  )  )   {  final  variant context kv = variant iterator . next (  )  ;  for  (  final  map .  entry <  db snp bit set util  set <  variant type >  >  tuple : bit sets to variant types . entry set (  )  )   {  final  db snp bit set util bitset = tuple . get key (  )  ;  final  set <  variant type >  variants to match = tuple . get value (  )  ;   bit set bits = bitset . sequence to bit set . get ( kv . get contig (  )  )  ;  if  ( bits  =  =  null )   {  final int n bits ;  if  ( sequence dictionary  =  =  null )  n bits = kv . get end (  )   +  1 ;  else n bits = sequence dictionary . get sequence ( kv . get contig (  )  )  . get sequence length (  )   +  1 ;  bits = new  bit set ( n bits )  ;  bitset . sequence to bit set . put ( kv . get contig (  )  bits )  ;   }  if  ( variants to match . is empty (  )  ||  ( kv . issnp (  )  && variants to match . contains (  variant type . snp )  )  ||  ( kv . is indel (  )  && variants to match . contains (  variant type . insertion )  ) ||  ( kv . is indel (  )  && variants to match . contains (  variant type . deletion )  )  )   {  for  ( int i = kv . get start (  )  ;  i  <  =  kv . get end (  )  ;  i +  +  )  bits . set ( i true )  ;   }   }  progress . map ( p  -  >  p . record ( kv . get contig (  )  kv . get start (  )  )  )  ;   }   closer util . close ( variant reader )  ;   }  
public i channel   (  )  {  return channel ;   }  
private float   (  )  {  return  ( float )  integration calculator . calc ( this )  ;   }  
protected i2p session   (  )  throws  exception  {  i2p client client = i2p client factory . create client (  )  ;   byte array output stream baos = new  byte array output stream ( 512 )  ;  client . create destination ( baos )  ;   properties p = get properties (  )  ;  i2p session sess = client . create session ( new  byte array input stream ( baos . to byte array (  )  )  p )  ;  sess . connect (  )  ;  return sess ;   }  
@ override public void   (  )  {   compression filter io filter =  (  compression filter ) io session . get filter chain (  )  . get ( compression   filter   name )  ;  io filter . set compress outbound ( true )  ;   }  
@ override public void   (  )  {  ms . on success ( 3 )  ;   }  
private void   (  string entry )  {  if  ( entry  =  =  null )  return ;     unwritten entries . offer ( entry )  ;  int sz =    unwritten entries . size (  )  ;  if  ( sz  >  flush   size )  flush entries (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . combine latest delay error ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] v )  {
public void   ( byte[] key int off int len int[] bit offset int[] word offset )  {  bit sel . get bit selectors ( key off len bit offset )  ;  word sel . get word selectors ( key off len word offset )  ;   }  
private void   (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set result = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   dates )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  result = pstmt . execute query (  )  ;  while  ( result . next (  )  )   {  last updated = new  date (  long . parse long ( result . get string ( 1 )  )  )  ;  last optimization = new  date (  long . parse long ( result . get string ( 2 )  )  )  ;  last execution = last updated ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {  try  {  if  ( pstmt  !  =  null )   {  pstmt . close (  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  if  ( result  !  =  null )   {  result . close (  )  ;   }   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  if  ( con  !  =  null )   {  con . close (  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable plain . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as flowable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable ( 
public static  bi consumer <  object  object >    ( final  runtime exception e )  {  return new  bi consumer <  object  object >  (  )  {  @ override public void accept (   object t1   object t2 )  {  throw e ;   }   }   ;   }  
@ override protected void   ( final  completable observer s )  {  final  composite disposable set = new  composite disposable (  )  ;  source . subscribe ( new  delay ( set s )  )  ;   }  
@ override public void   (  )  {  try  {  cb . await (  )  ;   }  catch  (   interrupted exception e )   {  return ;   }  catch  (   broken barrier exception e )   {  return ;   }  for  ( int i = 0 ;  i  <  1000000 ;  i +  +  )   {  rs . on next ( i )  ; 
@ override public void   (  )  throws  throwable  {   throwable caught throwable = null ;  for  ( int i = 0 ;  i  <  retry count ;  i +  +  )   {  try  {  base . evaluate (  )  ;  return ;   }  catch  (   throwable t )   {  caught throwable = t ;   system
@ test public void   (  )  throws  exception  {  fs . cancel ( true )  ;  fs . on error ( new  test exception ( " one" )  )  ;  try  {  fs . get ( 5  time unit . milliseconds )  ;  fail ( " should have thrown" )  ;   }  catch  (   cancellation exception e
private void   (  date value )  {     timestamp = value ;   }  
public int   (  )  {  return    option delay ;   }  
@ test public void   (  )  {  s1 . on next ( "a" )  ;  s1 . on next ( "b" )  ;  s1 . on complete (  )  ;  s2 . on next ( "1" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s2 . on next ( "2" )  ;  in order . verify ( observer
public void   (  )  {  stop tunnel (  )  ;  start tunnel (  )  ;   }  
@ test public void   (  )  {   test helper . double on subscribe ( new  blocking first subscriber <  integer >  (  )  )  ;   }  
@ test public void   (  )  {  final  header value impl header value = new  header value impl ( null  collections .  <  string  string > empty map (  )  )  ;  assert equals ( " header value should be blank when passed null . " "" header value . to string (
@ override public void   (  )  {  reader . clear (  )  ;  reader . close (  )  ;   }  
@ override public void   (  )  {  done = true ;  if  ( enter (  )  )   {  drain loop (  )  ;   }  actual . on complete (  )  ;  dispose worker (  )  ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c = normal . completable . lift ( new  completable operator swap (  )  )  ;  c . blocking await (  )  ;   }  
public  character   (  )  {  return wrapped char ;   }  
@ override protected void   (  )  throws  xml pull parser exception  io exception  {   xml pull parser xpp = socket reader . reader . getxpp parser (  )  ;  xpp . set input ( new  input stream reader ( socket reader . connection . gettls stream handler ( 
public  list <  chat setting >    (  chat settings .  setting type type )  {  final  list <  chat setting >  return list = new  array list <  chat setting >  (  )  ;  for  (   chat setting setting : settings list . values (  )  )   {  if  ( setting . get type (  )   =  =  type )   {  return list . add ( setting )  ;   }   }   collections . sort ( return list chat setting comparator )  ;  return return list ;   }  
public int   (  )  {  return    last congestion seen at ;   }  
@ override public long   ( boolean reset after )  {  if  ( reset after )   {  return out messages . get and set ( 0 )  ;   }  else  {  return out messages . get (  )  ;   }   }  
public  icon   (  )  {   icon smallest icon = null ;   icon list icon list = get icon list (  )  ;  int icon count = icon list . size (  )  ;  for  ( int n = 0 ;  n  <  icon count ;  n +  +  )   {   icon icon = icon list . get icon ( n )  ;  if  ( null  =  =  smallest icon )   {  smallest icon = icon ;  continue ;   }  if  ( icon . get width (  )   <  smallest icon . get width (  )  )  smallest icon = icon ;   }  return smallest icon ;   }  
private static void   (  writer writer  string name  string value )  throws io exception  {  if  ( value  !  =  null && value . length (  )   >  0 )   {  writer . append ( name )  ;  writer . append ( ": " )  ;  writer . append (  mime utility . fold and encode2 ( value name . length (  )   +  2 )  )  ;  writer . append ( "\r\n" )  ;   }   }  
public int   (  )  {  int found = 0 ;  for  ( int i = 0 ;  i  <     fragments . length ;  i +  +  )  if  (    fragments[i]  !  =  null )  found +  +  ;  return found ;   }  
public static  map <  integer  file >    (  file illumina run directory )  {   file[] cycle dirs = io util . get files matching regexp ( new  file ( illumina run directory interop   subdirectory   name )   illumina file util . cycle   subdirectory   pattern )  ;   map <  integer  file >  phasing metrics = new  hash map <  >  (  )  ;   arrays . as list ( cycle dirs )  . for each ( cycle dir  -  >   {   file[] files matching regexp = io util . get files matching regexp ( cycle dir " empirical phasing metrics out . bin" )  ;  if  ( files matching regexp . length  >  0 )   {  phasing metrics . put (  per tile per cycle file util . get cycle from dir ( cycle dir )  files matching regexp[0] )  ;   }   }   )  ;  return phasing metrics ;   }  
@ test public void   (  )  throws  exception  {   system . out . println ( "read" )  ;  byte[] b = null ;   byte buffer input stream instance = null ;  int exp result = 0 ;  int result = instance . read ( b )  ;  assert equals ( exp result result )  ;  fa
public void   (  request request )  {  final  offer offer = new  offer ( request queue get agent rejection timeout (  )  )  ;  offer . set timeout ( info . get offer timeout (  )  )  ;  offers . add ( offer )  ;   thread offer thread = new  thread ( " dispatch offer  -  queue: "  +  queue . get name (  )  )  {  @ override public void run (  )  {  dispatch ( offer )  ;  offers . remove ( offer )  ;   }   }   ;  offer thread . start (  )  ;   }  
@ test public void   (  )  throws  exception  {  fo . cancel ( true )  ;  fo . on error ( new  test exception ( " one" )  )  ;  try  {  fo . get ( 5  time unit . milliseconds )  ;  fail ( " should have thrown" )  ;   }  catch  (   cancellation exception e
public sax transformer factory   (  )  {  return factory ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  maybe subject <  integer >  cs =  maybe subject . create (  )  ;  final  test subscribe
@ override public void   (  dialog interface dialog )  {  super . on cancel ( dialog )  ;  final  callback callback =  (  callback ) get activity (  )  ;  callback . on check settings error dialog edit settings (  )  ;   }  
public void   (  packet packet  session session boolean incoming boolean processed )  throws  packet rejected exception  {  if  ( frozen )  return ;   string from = "" ;   string to = "" ;  if  (  ! processed ||  ( incoming && processed )  )   {  try  {  if  ( packet . get from (  )   !  =  null )  from = packet . get from (  )  . to string (  )  ;  if  ( packet . get to (  )   !  =  null )  to = packet . get to (  )  . to string (  )  ;   }  catch  (   illegal argument exception e )   {   log . debug ( " there was an illegal jid while intercepting  message for  go jara .   not  intercepting it !  "  +  e . get message (  )  )  ;  return ;   }   }  if  ( incoming &&  ! processed )   {  if  ( packet instanceof iq )   {  iq iq packet =  ( iq ) packet ;   element query = iq packet . get child element (  )  ;  if  ( query  =  =  null )  return ;  else if  ( query . get namespaceuri (  )  . equals ( "jabber:iq:roster" )  )   {  if  (  ! active transports . contains ( from )  && to . length (  )   =  =  0 && iq packet . get type (  )  . equals ( iq .  type . set )  )  packet processors . get ( "client to component update" )  . process ( packet "" to from )  ;  else if  ( from . length (  )   >  0 && active transports . contains ( from )  )  packet processors . get ( "iq roster payload" )  . process ( packet from to from )  ;   }  else if  ( query . get namespaceuri (  )  . equals ( "http: /  / jabber . org / protocol / disco#info" )  && to . length (  )   >  0 && active transports . contains ( to )  && iq packet . get type (  )  . equals ( iq .  type . get )  )   {  packet processors . get ( "sparkiq registered" )  . process ( packet to to from )  ;   }  else if  (  jive globals . get boolean property ( "plugin . remoteroster . iq last filter" false )  && query . get namespaceuri (  )  . equals ( "jabber:iq:last" )  )   {   string to   s = searchji dfor subdomain ( to )  ;  if  ( to   s . length (  )   >  0 && iq packet . get type (  )  . equals ( iq .  type . get )  )  throw new  packet rejected exception (  )  ;   }   }  else if  ( packet instanceof  message && active transports . contains ( from )  && to . contains ( "gojaraadmin" )  )   {  packet processors . get ( "gojara admin processor" )  . process ( packet from to from )  ;   }  else  {  if  (  !  jive globals . get boolean property ( "plugin . remoteroster . persistent" false )  )   {  if  ( packet instanceof  presence && active transports . contains ( from )  )  packet processors . get ( "handle non persistant" )  . process ( packet from to from )  ;   }   }   }  else if  ( incoming && processed )   {   string from   searched = searchji dfor subdomain ( from )  ;   string to   searched = searchji dfor subdomain ( to )  ;   string subdomain = from   searched . length (  )   =  =  0  ?  to   searched : from   searched ;  if  (  ! from . equals ( to )  && subdomain . length (  )   >  0 )  packet processors . get ( "statistics processor" )  . process ( packet subdomain to from )  ;  if  ( packet instanceof  presence && active transports . contains ( from )  )   {   presence presence   packet =  (  presence ) packet ;  if  ( presence   packet . get type (  )   =  =  null )   {  t session manager . connect user to ( from packet . get to (  )  . get node (  )  . to string (  )  )  ;   }  else if  ( presence   packet . get type (  )   !  =  null && presence   packet . get type (  )  . equals (  presence .  type . unavailable )  )   {  t session manager . disconnect user from ( from packet . get to (  )  . get node (  )  . to string (  )  )  ;   }   }  else if  ( packet instanceof iq && active transports . contains ( to )  )   {  iq iq packet =  ( iq ) packet ;   element query = iq packet . get child element (  )  ;  if  ( query  =  =  null )  return ;  if  ( query . get namespaceuri (  )  . equals ( "jabber:iq:register" )  && iq packet . get type (  )  . equals ( iq .  type . set )  )   {  if  ( query . element ( "remove" )   !  =  null )  t session manager . remove registration of user fromdb ( to iq packet . get from (  )  . get node (  )  . to string (  )  )  ;  else if  ( query . element ( "x" )   !  =  null )   {   element x elem = query . element ( "x" )  ;   string x namespace = x elem . get namespaceuri (  )  ;  if  ( x namespace . equals ( "jabber:iq:gateway:register" )  )  t session manager . register user to ( to iq packet . get from (  )  . get node (  )  . to string (  )  )  ;  else if  ( x namespace . equals ( "jabber:x:data" )  && x elem . attribute ( "type" )  . get text (  )  . equals ( "submit" )  )   {  t session manager . register user to ( to iq packet . get from (  )  . get node (  )  . to string (  )  )  ;  presence push ( packet . get to (  )  packet . get from (  )  150 )  ;   }   }   }   }   }  else if  (  ! incoming &&  ! processed )   {  if  ( packet instanceof iq )   {  iq iq packet =  ( iq ) packet ;   element query = iq packet . get child element (  )  ;  if  ( query  =  =  null )  return ;  if  ( query . get namespaceuri (  )  . equals ( "http: /  / jabber . org / protocol / disco#items" )  )  packet processors . get ( "whitelist processor" )  . process ( packet "" to from )  ;  else if  (  jive globals . get boolean property ( "plugin . remoteroster . muc filter" false )  && query . get namespaceuri (  )  . equals ( "http: /  / jabber . org / protocol / disco#info" )  && from . length (  )   >  0 && active transports . contains ( from )  )  packet processors . get ( "mucfilter processor" )  . process ( packet from to from )  ;  else if  (  jive globals . get boolean property ( "plugin . remoteroster . gajim broadcast" false )  )   {  if  ( to . contains ( " gajim" )  && query . get namespaceuri (  )  . equals ( "jabber:iq:roster" )  && iq packet . get type (  )  . equals ( iq .  type . result )  )   {   list <  node >  nodes =  xpath helper . find nodes in document ( iq packet . get element (  )  . get document (  )  " /  / roster:item" )  ;  for  (   node n : nodes )   {   string jid = n . value of ( "@jid" )  ;  if  ( active transports . contains ( jid )  )   {  jid push to = new jid ( jid )  ;  presence push ( push to iq packet . get to (  )  3000 )  ;   }   }   }   }   }  else if  (  jive globals . get boolean property ( "plugin . remoteroster . block presences" true )  && packet instanceof  presence )   {   string to   s = searchji dfor subdomain ( to )  ;  if  ( to   s . length (  )   >  0 &&  ! active transports . contains ( to )  )  throw new  packet rejected exception (  )  ;   }   }   }  
@ test public void   (  )  {   observable . merge delay error (  observable . just (  observable . just ( 1 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )   observable . just ( 2 )  )  )  . test (  )  . assert failur
@ test public void   (  )  {   test helper . assert bad request reported (  flowable . never (  )  . cache (  )  )  ;   }  
@ override public boolean   (  )  {  return disposed ;   }  
protected  hronized void sync (  )  {  if  ( m   byte buffer  !  =  null )   {  m   byte buffer . force (  )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . window ( new  callable <  publisher <  object >  >  (  )  {  @ override public  publisher <  object >  call (  )  {  return null ;   }   }   )  . blocking subscribe (  )
public static  string[]   (  string args )  {   list <  string >  arg list = new  array list <  string >  ( 4 )  ;  if  ( args  !  =  null )   {   string builder buf = new  string builder ( 32 )  ;  boolean is quoted = false ;  for  ( int i = 0 ;  i  <  args . length (  )  ;  i +  +  )   {  char c = args . char at ( i )  ;  switch  ( c )   {  case '\'': case '"': if  ( is quoted )   {   string str = buf . to string (  )  . trim (  )  ;  if  ( str . length (  )   >  0 )  arg list . add ( str )  ;  buf . set length ( 0 )  ;   }  is quoted =  ! is quoted ;  break ;  case ' ': case '\t': if  ( is quoted )   {  buf . append ( c )  ;   }  else  {   string str = buf . to string (  )  . trim (  )  ;  if  ( str . length (  )   >  0 )  arg list . add ( str )  ;  buf . set length ( 0 )  ;   }  break ;  default : buf . append ( c )  ;  break ;   }   }  if  ( buf . length (  )   >  0 )   {   string str = buf . to string (  )  . trim (  )  ;  if  ( str . length (  )   >  0 )  arg list . add ( str )  ;   }   }   string rv[] = new  string[arg list . size (  ) ] ;  for  ( int i = 0 ;  i  <  arg list . size (  )  ;  i +  +  )   {  rv[i] = arg list . get ( i )  ;   }  return rv ;   }  
@ override public void   (  )  throws  exception  {  to . on next ( 100 )  ;   }  
@ override public void   (  )  {  if  ( wip . increment and get (  )   =  =  2 )   {  emit (  )  ;  if  ( wip . decrement and get (  )   =  =  0 )   {  actual . on complete (  )  ;   }   }   }  
@ override public void   (  observer <  ?  super  observable < t >  >  t )  {  if  ( count  =  =  skip )   {  source . subscribe ( new  window exact observer < t >  ( t count capacity hint )  )  ;   }  else  {  source . subscribe ( new  window skip observ
@ deprecated public static void   ( boolean enabled )  throws  modification not allowed exception  {  for  (   external component manager listener listener : listeners )   {  listener . service enabled ( enabled )  ;   }   connection manager connection ma
public synchronized io exception   (  )  {  return    failure ;   }  
public void   (  destination to byte[] data )  {     i2p sink . send ( to data )  ;   }  
void   (  )  {  t value = get and set ( null )  ;  if  ( value  !  =  null )   {  long r = requested . get (  )  ;  if  ( r  !  =  0l )   {  actual . on next ( value )  ;   backpressure helper . produced ( requested 1 )  ;   }  else  {  cancel (  )  ;  actual . on error ( new  missing backpressure exception ( " couldn't emit value due to lack of requests ! " )  )  ;   }   }   }  
public void   ( i2cp message reader reader i2cp message message )  {  if  (    runner . is dead (  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " received but runner dead: \n"  +  message )  ;  return ;   }  if  (    log . should log (  log . debug )  )     log . debug ( " message received: \n"  +  message )  ;  int type = message . get type (  )  ;  if  (  !    authorized )   {  boolean strict =    context . get boolean property default true ( prop   auth   strict )  ;  if  (  ( strict && type  !  =   get date message . message   type )  ||  ( type  !  =   create session message . message   type && type  !  =   get date message . message   type && type  !  =   dest lookup message . message   type && type  !  =   get bandwidth limits message . message   type )  )   {     log . error ( " received message type "  +  type  +  " without required authentication" )  ;     runner . disconnect client ( " authorization required" )  ;  return ;   }   }  switch  ( message . get type (  )  )   {  case  get date message . message   type: handle get date (  (  get date message ) message )  ;  break ;  case  set date message . message   type: handle set date (  (  set date message ) message )  ;  break ;  case  create session message . message   type: handle create session (  (  create session message ) message )  ;  break ;  case  send message message . message   type: handle send message (  (  send message message ) message )  ;  break ;  case  send message expires message . message   type: handle send message (  (  send message expires message ) message )  ;  break ;  case  receive message begin message . message   type: handle receive begin (  (  receive message begin message ) message )  ;  break ;  case  receive message end message . message   type: handle receive end (  (  receive message end message ) message )  ;  break ;  case  create lease set message . message   type: handle create lease set (  (  create lease set message ) message )  ;  break ;  case  destroy session message . message   type: handle destroy session (  (  destroy session message ) message )  ;  break ;  case  dest lookup message . message   type: handle dest lookup (  (  dest lookup message ) message )  ;  break ;  case  host lookup message . message   type: handle host lookup (  (  host lookup message ) message )  ;  break ;  case  reconfigure session message . message   type: handle reconfigure session (  (  reconfigure session message ) message )  ;  break ;  case  get bandwidth limits message . message   type: handle getbw limits (  (  get bandwidth limits message ) message )  ;  break ;  default : if  (    log . should log (  log . error )  )     log . error ( " unhandled i2cp type received: "  +  message . get type (  )  )  ;   }   }  
@ override public muc room   (  )  {  return room ;   }  
public   (  registration registration jid jid  yahoo transport transport  integer priority )  {  super ( registration jid transport priority )  ;  set supported feature (  supported feature . attention )  ;  set supported feature (  supported feature . chatstates )  ;  pseudo roster =  pseudo roster manager . get instance (  )  . get pseudo roster ( registration )  ;   }  
private boolean   ( final  file expected base final  file actual base final  string extension )  {  return  metrics file . are metrics equal ( new  file ( expected base  +  extension )  new  file ( actual base  +  extension )  )  ;   }  
public int   ( int port )  {  i2p tunneldcc server server =    dcc server ;  if  ( server  !  =  null )  return server . accept outgoing ( port )  ;  return  - 1 ;   }  
@ test public void   (  )  {   flowable <  string >  observable =  flowable . from iterable (  arrays . as list ( "one" "two" )  )  . skip last ( 2 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  observable . subscribe ( 
@ override public boolean   (  throwable e )  throws  exception  {  return e instanceof  test exception || e instanceof  composite exception ;   }  
void   (  )  {  cursor = 0 ;  last ret =  - 1 ;  expected mod count = mod count ;   }  
@ test public void   (  )  {   behavior subject <  integer >  bs =  behavior subject . create (  )  ;  bs . on next ( 1 )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   behavior disposable <  integer >  bd = new  behavior
public static boolean   (  )  {  return  ! get addresses ( true false false )  . is empty (  )  ;   }  
@ test public void   (  )  {  assert that (  group element . p2 ( curve zero one one )  is ( equal to ( p2   zero )  )  )  ;   }  
@ test public void   (  )  {   unicast subject <  integer >  us =  unicast subject . create ( false )  ;   test observer <  integer >  to = us . to (  observer fusion .  <  integer > test (  queue fuseable . any false )  )  ;  us . done = true ;  us . dra
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  try  {  ts . assert error ( new  test exception (  )  )  ;   }  catch  (   assertion error ex )   {  return ;   }  fail ( " no present but no ass
public synchronized static int   (  string name int default value )  {  int result = default value ;   string str = get property ( name )  ;  if  ( str  !  =  null )   {  try  {  result =  integer . parse int ( str )  ;   }  catch  (   number format exception nfe )   {  result = default value ;   }   }  return result ;   }  
public  socket   (  )  {  return socket ;   }  
public void   (  event dispatcher ev )  {  if  ( ev  =  =  null )  return ;     attached . remove ( ev )  ;   }  
public   (  )  {     context = i2p app context . get global context (  )  ;   }  
 < t >  function <  integer t >    ( t dummy )  {  return new  function <  integer t >  (  )  {  @ override public t apply (   integer t1 )  {  throw new  runtime exception ( " forced failure" )  ;   }   }   ;   }  
public   (  flowable < t >  source  publisher <  ?  extends  open >  buffer open  function <  ?  super  open  ?  extends  publisher <  ?  extends  close >  >  buffer close  callable < u >  buffer supplier )  {  super ( source )  ;  this . buffer open = buffer open ;  this . buffer close = buffer close ;  this . buffer supplier = buffer supplier ;   }  
@ override protected void   (  completable observer observer )  {  source . subscribe ( new  hide completable observer ( observer )  )  ;   }  
public void   ( int bytes )  {     inbound buffer size = bytes ;   }  
@ test public void   (  )  throws  exception  {   test struct struct = new  test struct (  )  ;  struct . set data ( new byte[3] )  ;  try  {  struct . read bytes ( null )  ;  fail ( "blah blah blah .  . " )  ;   }  catch  (   runtime exception exc )   { 
void   (  observer <  ?  >  a )  {   throwable ex =  exception helper . terminate ( error )  ;  lefts . clear (  )  ;  rights . clear (  )  ;  a . on error ( ex )  ;   }  
public  tuple status   (  )  {  return this . tuple status ;   }  
@ test public void   (  )  {   deferred scalar subscription <  integer >  ds = new  deferred scalar subscription <  integer >  ( new  test subscriber <  integer >  (  )  )  ;  assert equals (  queue fuseable . none ds . request fusion (  queue fuseable . 
public void   ( int id byte data[] int offset int length )  {   flooder flooder = null ;  synchronized  (    remote peers )   {  flooder =  (  flooder )    remote peers . get ( new  integer ( id )  )  ;   }  long value =  data helper . from long ( data 0 4 )  ;  if  ( flooder  !  =  null )   {  flooder . received ( length value )  ;   }  else  {     log . error ( "not connected to "  +  id  +  " but we received " +  value +  " ? " )  ;   }   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  object >  to = ps . concat map single ( new  function <  integer  single source <  ?  extends  object >  >  (  )  {  @ override pu
public static void   ( final  string[] args )  {  final  gather bam files gatherer = new  gather bam files (  )  ;  gatherer . create   index = true ;  gatherer . instance main with exit ( args )  ;   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer (  )  ;   callable <  object >  callable = new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  atomic integer . increment a
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
void   (  hash h )  {     verifies in progress . remove ( h )  ;   }  
public long   (  )  {  return    last store failed ;   }  
public  string   (  )  {  return presence message ;   }  
public  range[]   (  )  {  return output substructure . get cycle index ranges (  )  ;   }  
@ test public void   (  )  {   test multi threaded observable on subscribe = new  test multi threaded observable ( "one" "two" "three" )  ;   observable <  string >  w =  observable . unsafe create ( on subscribe )  ;   busy observer busy subscriber = new
public muc event delegate   (  )  {  return muc event delegate ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < u r >  maybe < r >    (  function <  ?  super t  ?  extends  maybe source <  ?  extends u >  >  mapper  bi function <  ?  super t  ?  super u  ?  extends r >  result s
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {  final  disposable[] disposable =  { null }  ;   observable . concat array delay error (  observable . just ( 1 )   observable .  <  integer > error ( new  test exception (  )  )  )  . subs
private   (  context context )  {  m context = context . get application context (  )  ;  mdpm = null ;  m admin name = new  component name ( context  policy admin . class )  ;  m aggregate policy = null ;   }  
public int   ( int tunnel )  {  return 23 ;   }  
@ override public  string   ( byte[] hash )  {  final byte[] buffer = new byte[uuid   buffer   size] ;   system . arraycopy ( hash 0 buffer 0 byte   bit   length )  ;  final long msb = qword to long ( buffer )  ;   system . arraycopy ( hash byte   bit   l
public boolean   (  string addr int port )  {  if  ( server sock  !  =  null )  return true ;  try  {  bind addr =  inet address . get by name ( addr )  ;  bind port = port ;  server sock = new  server socket ( bind port 0 bind addr )  ;   }  catch  (  io exception e )   {   debug . warning ( "http server open failed "  +  addr  +  " " +  port e )  ;  return false ;   }  return true ;   }  
  (  single observer <  ?  super r >  t  function <  ?  super t  ?  extends r >  mapper )  {  this . t = t ;  this . mapper = mapper ;   }  
public synchronized void   ( long size )  {  if  ( body  !  =  null )  return ;  this . size = size ;   }  
@ test public void   (  )  {   test observer <  string >  to =  maybe . just ( 1 )  . of type (  string . class )  . test (  )  ;  to . assert result (  )  ;   }  
private void   ( long id )  {  notifyui ( uiprovider   conversation   notifier  long . to string ( id )  )  ;   mailbox mailbox =  mailbox . restore mailbox with id ( get context (  )  id )  ;  if  ( mailbox  =  =  null )   {   log utils . w ( tag " no mailbox for notification: "  +  id )  ;  return ;   }  if  ( mailbox . m type  =  =   mailbox . type   inbox )   {  notifyui ( uiprovider   conversation   notifier  email provider . combined mailbox id (  mailbox . type   inbox )  )  ;   }  notify widgets ( id )  ;   }  
void   (  )  {   disposable helper . dispose ( d )  ;   half serializer . on complete ( actual this error )  ;   }  
@ override public int   (  )  {  return request . hash code (  )  ;   }  
private boolean   ( uri uri  string actual version  file f boolean issu3 )  {   string url = uri . to string (  )  ;  update status ( " < b > "  +     t ( " update downloaded" )   +  " <  / b > " )  ;   file to = new  file (    context . get router dir (  )   router . update   file )  ;   string err ;  if  ( issu3 )   {  su3 file up = new su3 file (    context f )  ;   file temp = new  file (    context . get temp dir (  )  "su3out - "  +     context . random (  )  . next long (  )   +  " . zip" )  ;  try  {  if  ( up . verify and migrate ( temp )  )   {   string ver = up . get version string (  )  ;  int type = up . get content type (  )  ;  if  ( ver  =  =  null ||  version comparator . comp (  router version . version ver )   >  =  0 )  err = " old version "  +  ver ;  else if  ( type  !  =  su3 file . content   router )  err = " bad su3 content type "  +  type ;  else if  (  !  file util . copy ( temp to true false )  )  err = " failed copy to "  +  to ;  else err = null ;   }  else  {  err = " signature failed  signer "  +   data helper . striphtml ( up . get signer string (  )  )   +  ' ' +  up . get sig type (  )  ;   }   }  catch  (  io exception ioe )   {     log . error ( "su3 extract error" ioe )  ;  err =  data helper . striphtml ( ioe . to string (  )  )  ;   }  finally  {  temp . delete (  )  ;   }   }  else  {   trusted update up = new  trusted update (    context )  ;  err = up . migrate verified (  router version . version f to )  ;   }  if  ( err  =  =  null )   {   string policy =    context . get property (  config update handler . prop   update   policy )  ;  long modtime =    context . clock (  )  . now (  )  ;     context . router (  )  . save config (  news helper . prop   last   update   time  long . to string ( modtime )  )  ;  if  ( "install" . equals ( policy )  )   {     log . log (  log . crit " update was downloaded and verified  restarting to install it" )  ;  update status ( " < b > "  +     t ( " update verified" )   +  " <  / b >  < br > " +     t ( " restarting" )  )  ;  restart (  )  ;   }  else  {     log . log always (  log . warn " update was downloaded and verified  will be installed at next restart" )  ;  update status ( "" )  ;   }   }  else  {     log . log (  log . crit err  +  " from "  +  url )  ;  update status ( " < b > "  +  err  +  ' ' +     t ( "from  { 0 } " linkify ( url )  )  +  "  <  / b > " )  ;   }  return err  =  =  null ;   }  
@ override public int   (  node o1  node o2 )  {  try  {  final int p1 = o1 instanceof  element  ?   integer . value of (  (  (  element ) o1 )  . attribute value ( "order" "0" )  )  : 0 ;  final int p2 = o2 instanceof  element  ?   integer . value of (  
@ override public  string   (  )  {  return name ;   }  
@ override public void   ( final sam records for cluster val )  {  if  ( val . records . length  !  =  num records )   {  throw new  illegal state exception (  string . format ( " expected number of clusters %d  !  =  actual %d" num records val . records 
@ override public  uri   (  uri uri  content values values )  {  return null ;   }  
@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts0 =  subscriber fusion . new test (  queue fuseable . async )  ;   unicast processor <  integer >  up =  unicast processor . create (  )  ;   test helper . emit ( up 1 2 3 4 5 )  ;  up . do af
private static  string   (  string[] ui projection final boolean unseen only )  {   string builder sb = gen select ( get message list map (  )  ui projection )  ;  append conversation info columns ( sb )  ;  sb . append ( " from "  +   message . table   name  +  " where " +   message . flag   loaded   selection +  " and " +   message columns . mailbox   key +  " =  ?  " )  ;  if  ( unseen only )   {  sb . append ( "and " )  . append (  message columns . flag   seen )  . append ( "  =  0 " )  ;  sb . append ( "and " )  . append (  message columns . flag   read )  . append ( "  =  0 " )  ;   }  sb . append ( "order by "  +   message columns . timestamp  +  " desc " )  ;  sb . append ( "limit "  +  ui provider . conversation   projection   query   cursor   window   limit )  ;  return sb . to string (  )  ;   }  
@ override public boolean   (  disposable d )  {  if  ( delete ( d )  )   {  d . dispose (  )  ;  return true ;   }  return false ;   }  
@ override public boolean   (  )  {  return disposed ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts = new  test subscriber <  object >  (  )  ;  ts . dispose (  )  ;   flowable . just ( 1 )  . blocking subscribe ( ts )  ;  ts . assert empty (  )  ;   }  
public  < r x extends  exception > r   (  transaction isolation level level  handle callback < r x >  callback )  throws x  {  try  (  transaction resetter tr = new  transaction resetter ( get transaction isolation level (  )  )  )  {  set transaction isolation ( level )  ;  return transactions . in transaction ( this level callback )  ;   }   }  
public void   (  string plc class name )  {  jitter manager . set plc class name ( plc class name )  ;   }  
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
public jid   (  )  {  return userjid ;   }  
@ override public  string   (  )  {  return user id ;   }  
public synchronized void   (  )  {   string group =  ( null  =  =     peer  ?  "profile unknown" :    peer . to base64 (  )  . substring ( 0 6 )  )  ;  if  (    tunnel create response time  =  =  null )     tunnel create response time = new  rate stat ( "tunnel create response time" "how long it takes to get a tunnel create response from the peer  ( in milliseconds ) " group new long[] { 10 * 60 * 1000l 30 * 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000 }  )  ;  if  (    tunnel test response time  =  =  null )     tunnel test response time = new  rate stat ( "tunnel test response time" "how long it takes to successfully test a tunnel this peer participates in  ( in milliseconds ) " group new long[] { 10 * 60 * 1000l 30 * 60 * 1000l 60 * 60 * 1000l 3 * 60 * 60* 1000l 24 * 60 * 60* 1000 }  )  ;  if  (    tunnel history  =  =  null )     tunnel history = new  tunnel history (    context group )  ;     tunnel create response time . set stat log (    context . stat manager (  )  . get stat log (  )  )  ;     tunnel test response time . set stat log (    context . stat manager (  )  . get stat log (  )  )  ;     expanded = true ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . group by ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   null )  ;   }  
@ check return value @ non null public final  parallel flowable < t >    ( @ non null  action on complete )  {   object helper . require non null ( on complete "on complete is null" )  ;  return  rx java plugins . on assembly ( new  parallel peek < t >  (
public static  < t >  builder < t >    ( t .  .  .  items )  {  return new  builder < t >  (  arrays . as list ( items )  )  ;   }  
public void   (  )  {  if  ( size  >  0 )  size -  -  ;   }  
public boolean   (  )  {  return is sandy compatible ;   }  
public static  object   (  )  {  return complete ;   }  
public synchronized void   ( boolean fast )  {   tracker client tc = trackerclient ;  if  ( tc  !  =  null )  tc . halt ( fast )  ;   peer coordinator pc = coordinator ;  if  ( pc  !  =  null )  pc . halt (  )  ;   storage st = storage ;  if  (  ! fast )  stopped = true ;  if  ( st  !  =  null )   {  long now uploaded = get uploaded (  )  ;  boolean changed = storage . is changed (  )  || now uploaded  !  =  saved uploaded ;  try  {  storage . close (  )  ;   }  catch  (  io exception ioe )   {   system . out . println ( " error closing "  +  torrent )  ;  ioe . print stack trace (  )  ;   }  saved uploaded = now uploaded ;  if  ( changed && complete listener  !  =  null )  complete listener . update status ( this )  ;  if  ( complete listener  !  =  null )   {  synchronized  (    comment lock )   {  if  (    comments  !  =  null )   {  synchronized  (    comments )   {  if  (    comments . is modified (  )  )  complete listener . locked   save comments ( this    comments )  ;   }   }   }   }   }  if  ( fast )  stopped = true ;  if  ( pc  !  =  null &&    peer coordinator set  !  =  null )     peer coordinator set . remove ( pc )  ;  if  (    peer coordinator set  =  =  null )     util . disconnect (  )  ;   }  
private void   (  print writer out  http servlet request req )  throws io exception  {   string builder buf = new  string builder ( 1024 )  ;  buf . append ( " < form action = \""  +     context path  +  " / configure\" method = \"post\" > \n" +  " < div class = \"configsectionpanel\" >  < div class = \"snark config\" > \n" )  ;  write hidden inputs ( buf req " save2" )  ;  buf . append ( " < span class = \"snark config title\" > " )  ;  to theme img ( buf "config" )  ;  buf . append ( ' ' )  ;  buf . append (    t ( " trackers" )  )  ;  buf . append ( " <  / span >  < hr > \n"  +  " < table class = \"trackerconfig\" >  < tr >  < th title = \"" )  . append (    t ( " select trackers for removal from i2p snark's known list" )  )  . append ( "\" >  <  / th >  < th > " )  . append (    t ( " name" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " website url" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " standard" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " open" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " private" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " announce url" )  )  . append ( " <  / th >  <  / tr > \n" )  ;   list <  string >  open trackers =    manager . util (  )  . get open trackers (  )  ;   list <  string >  private trackers =    manager . get private trackers (  )  ;  for  (   tracker t :    manager . get sorted trackers (  )  )   {   string name = t . name ;   string homeurl = t . baseurl ;   string announceurl = t . announceurl . replace ( "&#61 ; " " = " )  ;  boolean is private = private trackers . contains ( t . announceurl )  ;  boolean is known open =    manager . util (  )  . is known open tracker ( t . announceurl )  ;  boolean is open = is known open || open trackers . contains ( t . announceurl )  ;  buf . append ( " < tr class = \"known tracker\" >  < td >  < input type = \"checkbox\" class = \"optbox\" id = \"" )  . append ( name )  . append ( "\" name = \"delete   " )  . append ( name )  . append ( "\" title = \"" )  . append (    t ( " mark tracker for deletion" )  )  . append ( "\" > "  +  " <  / td >  < td >  < label for = \"" )  . append ( name )  . append ( "\" > " )  . append ( name )  . append ( " <  / label >  <  / td >  < td > " )  . append ( urlify ( homeurl 35 )  )  . append ( " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"0\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  (  !  ( is open || is private )  )  buf . append ( " checked = \"checked\"" )  ;  else if  ( is known open )  buf . append ( " disabled = \"disabled\"" )  ;  buf . append ( " > "  +  " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"1\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  ( is open )  buf . append ( " checked = \"checked\"" )  ;  else if  ( t . announceurl . equals ( "http: /  / diftracker . i2p / announce . php" )  || t . announceurl . equals ( "http: /  / tracker2 . postman . i2p / announce . php" )  )  buf . append ( " disabled = \"disabled\"" )  ;  buf . append ( " > "  +  " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"2\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  ( is private )   {  buf . append ( " checked = \"checked\"" )  ;   }  else if  ( is known open || t . announceurl . equals ( "http: /  / diftracker . i2p / announce . php" )  || t . announceurl . equals ( "http: /  / tracker2 . postman . i2p / announce . php" )  )   {  buf . append ( " disabled = \"disabled\"" )  ;   }  buf . append ( " > "  +  " <  / td >  < td > " )  . append ( urlify ( announceurl 35 )  )  . append ( " <  / td >  <  / tr > \n" )  ;   }  buf . append ( " < tr >  < td >  < b > " )  . append (    t ( " add" )  )  . append ( ": <  / b >  <  / td > "  +  " < td >  < input type = \"text\" class = \"trackername\" name = \"tname\" spellcheck = \"false\" >  <  / td > "  +  " < td >  < input type = \"text\" class = \"trackerhome\" name = \"thurl\" spellcheck = \"false\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"0\" name = \"add   tracker   type\" checked = \"checked\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"1\" name = \"add   tracker   type\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"2\" name = \"add   tracker   type\" >  <  / td > " +  " < td >  < input type = \"text\" class = \"trackerannounce\" name = \"taurl\" spellcheck = \"false\" >  <  / td >  <  / tr > \n" +  " < tr class = \"spacer\" >  < td colspan = \"7\" > &nbsp ;  <  / td >  <  / tr > \n" +  " < tr >  < td colspan = \"7\" > \n" +  " < input type = \"submit\" name = \"taction\" class = \"default\" value = \"" )  . append (    t ( " add tracker" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"delete\" value = \"" )  . append (    t ( " delete selected" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"add\" value = \"" )  . append (    t ( " add tracker" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"accept\" value = \"" )  . append (    t ( " save tracker configuration" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"reload\" value = \"" )  . append (    t ( " restore defaults" )  )  . append ( "\" > \n"  +  " <  / td >  <  / tr > "  +  " < tr class = \"spacer\" >  < td colspan = \"7\" > &nbsp ;  <  / td >  <  / tr > \n" +  " <  / table >  <  / div >  <  / div >  <  / form > \n" )  ;  out . write ( buf . to string (  )  )  ;   }  
public int   (  )  {  return offset ;   }  
@ test public void   (  )  {   group element b = ed25519 . getb (  )  ;  for  ( int i = 0 ;  i  <  32 ;  i +  +  )   {  assert that ( i  +  " 0" b . select ( i 0 )  is ( equal to (  group element . precomp ( curve one one zero )  )  )  )  ;  for  ( int j 
public long   (  )  {  final  default connection provider default connection provider = get default connection provider (  )  ;  return default connection provider  =  =  null  ?  0l :  ( long )  ( default connection provider . get connection timeout (  )  *  jive constants . day )  ;   }  
 input stats callback   (  stats field field )  {  switch  ( field )   {  case request   input   bytes: return request input stats callback ;  case request   compressed   bytes: return request compressed stats callback ;  default : throw new  illegal argument exception (  )  ;   }   }  
public   (  )  {  this . create   index = true ;   }  
public long   (  snark snark )  {  return    smgr . get saved torrent time ( snark )  ;   }  
@ test public void   (  )  throws  exception  {  assert false ( fs . is done (  )  )  ;  assert false ( fs . is cancelled (  )  )  ;  fs . cancel (  )  ;  fs . cancel (  )  ;  fs . request ( 10 )  ;  fs . request (  - 99 )  ;  fs . cancel ( false )  ;  as
private static  string   ( long base int mod )  {  if  ( mod  !  =  0 )   {  base +  = mod *  ( 5 * 256 * 256l )  ;   }  if  ( base  >  0xffffff || base  <  0 )  base& = 0xffffff ;  return  string . format ( "%06x" base )  ;   }  
public void   (  )  {  synchronized  (    state lock )   {  if  (    state  =  =   state . starting   3 )  change state (  state . expl   tunnels   ready )  ;  else if  (    state  =  =   state . netdb   ready )  change state (  state . running )  ;   }   }  
public  collection <  service version mapping >    (  )  {  return service mappings . values (  )  ;   }  
@ test public void   (  )  {   observable . concat delay error (  observable . just (  observable . just ( 1 )   observable . just ( 2 )   observable . just ( 3 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )   observ
@ test public void   (  )  {   maybe . concat (  maybe . just ( 1 )   maybe . just ( 2 )   maybe . just ( 3 )  )  . test (  )  . assert result ( 1 2 3 )  ;   }  
private void   (  hash key  file dir )  throws io exception  {   string ri name = get router info name ( key )  ;   file f = new  file ( dir ri name )  ;  if  ( f . exists (  )  )   {  boolean removed = f . delete (  )  ;  if  (  ! removed )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to remove router info at "  +  f . get absolute path (  )  )  ;   }  else if  (    log . should log (  log . info )  )   {     log . info ( " removed router info at "  +  f . get absolute path (  )  )  ;   }  return ;   }   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . rebatch requests ( 2 )  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  pp . on error ( new  test exception ( " first" )  )  ;   }   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   observable . never (  )  . buffer ( new  callable <  observable source <  long >  >  (  )  {  int count ;  @ override public  observable source <  long >  call (  )  throws  exception  { 
private void   ( final  route packet )  {  if  ( session . get status (  )   !  =   session . status   authenticated )   {   route reply = new  route ( packet . get streamid (  )  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( packet . get from (  )  )  ;  reply . set from ( packet . get to (  )  )  ;  reply . set error (  packet error .  condition . not   authorized )  ;  session . process ( reply )  ;  return ;   }  packet handler . route ( packet )  ;   }  
@ small test public void   (  )  {   account account1 =  provider test utils . setup account ( "account - hostauth" false m mock context )  ;  account1 . m host auth recv =  provider test utils . setup host auth ( "account - hostauth - recv"  - 1 false m 
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . any ( null )  ;   }  
public   (  context context  cursor folders  set <  string >  initially selected int layout )  {  super ( context folders initially selected layout )  ;   }  
private  < t >  consumer <  flowable < t >  >    ( final  list < t >  list final  list <  list < t >  >  lists )  {  return new  consumer <  flowable < t >  >  (  )  {  @ override public void accept (   flowable < t >  string flowable )  {  string flowable . subscribe ( new  default subscriber < t >  (  )  {  @ override public void on complete (  )  {  lists . add ( new  array list < t >  ( list )  )  ;  list . clear (  )  ;   }  @ override public void on error (   throwable e )  {   assert . fail ( e . get message (  )  )  ;   }  @ override public void on next (  t args )  {  list . add ( args )  ;   }   }   )  ;   }   }   ;   }  
public static void   (  string name byte[] arr )  {     binary . put ( name arr )  ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return 1  /  v  >  0 ;   }   }   new  bi function <  long  th
public static void   (  )  {   file log file = new  file (  log . get log directory (  )  "all . log" )  ;  empty file ( log file )  ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . just ( 1 )  . flat map ( new  function <  integer  observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (
public static boolean   (  string subdomain )  {  return get configuration ( subdomain true )   !  =  null ;   }  
@ override public  string   (  )  {  return "scram - sha - 1" ;   }  
@ override public void   (  object t )  {  if  (  subscription helper . cancel ( this )  )   {  parent . other error ( new  cancellation exception (  )  )  ;   }   }  
@ test public void   (  )  {   observable . just ( 1 )  . zip with (  observable . just ( 2 )  new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  exception  {  return a  +  b ;  
@ suppress warnings ( "unchecked" )  public  < s > void   ( s state  bi predicate <  ?  super s  ?  super t >  consumer )  throws  exception  {   object[] a = head ;  final int c = capacity ;  for  (  ;   ;   )   {  for  ( int i = 0 ;  i  <  c ;  i +  +  
@ test public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  intege
public static boolean   (  keyed stack lock test thread .  .  .  threads )  {  for  (   keyed stack lock test thread t : threads )   {  if  (  ! t . finished (  )  )   {  return false ;   }   }  return true ;   }  
public short   (  )  {  throw new  picard exception ( " not  implemented" )  ;   }  
@ test ( data provider = "left align alleles data" )  public void   ( final  variant context source final  reference sequence reference final  variant context result )  {   variant context builder vcb = new  variant context builder ( source )  ;   liftove
public   ( final int min gq )  {  this . min gq = min gq ;   }  
@ override public boolean   (  )  {  return current  =  =  null && queue . is empty (  )  ;   }  
public static final boolean   (  string current version  string new version )  {  return  version comparator . comp ( current version new version )   <  0 ;   }  
public   (  )  {  super (  account setup final . class )  ;   }  
@ override public void   (  string id byte data[] int offset int length )  {   sink sink ;  synchronized  (    remote peers )   {  sink =    remote peers . get ( id )  ;   }  if  ( sink  !  =  null )   {  sink . received ( data offset length )  ;   }  els
@ override public  iterable <  integer >    (  integer v )  throws  exception  {  return list ;   }  
  (  subscriber <  ?  super t >  child )  {  this . child = child ;   }  
public long   (  )  {  return    context . clock (  )  . now (  )   -     started on ;   }  
public   ( int ssrc )  {  super ( ssrc true )  ;  setssrc   1 ( ssrc )  ;   }  
@ test public void   (  )  {   test helper . assert bad request reported (  flowable . never (  )  . debounce ( 1  time unit . seconds )  )  ;   }  
@ override public  observable <  integer >    (  integer t )  {  return  observable . just ( t )  . hide (  )  ;   }  
public void   (  list <  agent history model >  list  element chat sessions iq reply  workgroup workgroup int max sessions )  {  for  (   agent history model model : get new list ( list max sessions )  )   {   element session = chat sessions . add element ( "chat - session" )  ;  session . add element ( "sessionid" )  . set text ( model . get sessionid (  )  )  ;  session . add element ( "date" )  . set text ( model . get join time (  )  )  ;  session . add element ( "duration" )  . set text ( model . get duration (  )  )  ;  session . add element ( "visitors name" )  . set text ( model . get name (  )   =  =  null  ?  "" : model . get name (  )  )  ;  session . add element ( "visitors email" )  . set text ( model . get email (  )   =  =  null  ?  "" : model . get email (  )  )  ;  session . add element ( "question" )  . set text ( model . get question (  )   =  =  null  ?  "" : model . get question (  )  )  ;   }  workgroup . send ( reply )  ;   }  
@ override public  completable source   (  throwable e )  throws  exception  {  call[0] +  +  ;  return  completable . complete (  )  ;   }  
public void   (  string sn  string nickname )  {  try  {   transport buddy buddy = get buddy manager (  )  . get buddy ( get transport (  )  . convertid tojid ( sn )  )  ;  buddy . set nickname ( nickname )  ;  try  {  get transport (  )  . add or update roster item ( getjid (  )  buddy . get name (  )  buddy . get nickname (  )  buddy . get groups (  )  )  ;   }  catch  (   user not found exception e )   {   }   }  catch  (   not found exception e )   {   }   }  
public static boolean   ( byte[] data to encode  string filename )  {  boolean success = false ;   base64 .  output stream bos = null ;  try  {  bos = new  base64 .  output stream ( new java . io .  file output stream ( filename )   base64 . encode )  ;  bos . write ( data to encode )  ;  success = true ;   }  catch  (  java . io . io exception e )   {  success = false ;   }  finally  {  try  {  bos . close (  )  ;   }  catch  (   exception e )   {   }   }  return success ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . hide (  )  . flat map ( new  function <  integer  observable source <  ?  extends  object >  >  (  )  {  @ override public  observable source <  ?  extends  object >  apply (   integer v )  throws 
@ test public void   (  )  throws io exception  {  writer . write limits response ( readable contents  media type . application   xml out )  ;  verify ( out times ( 1 )  )  . write ( readable contents )  ;   }  
@ override public void   (  throwable e )  {  inner error ( this e )  ;   }  
public static void   (  )  {  synchronized  ( conference list )   {  if  ( lone conference sender  !  =  null )   {  lone conference sender . print statistics (  )  ;   }  for  ( int i = 0 ;  i  <  conference list . size (  )  ;  i +  +  )   {   conference manager conference manager =  (  conference manager ) conference list . get ( i )  ;   conference sender conference sender = conference manager . get conference sender (  )  ;  if  ( lone conference sender  =  =  null )   {  conference sender . print statistics (  )  ;   }   array list member list = conference manager . get member list (  )  ;  for  ( int n = 0 ;  n  <  member list . size (  )  ;  n +  +  )   {   conference member member =  (  conference member ) member list . get ( n )  ;  member . print statistics (  )  ;   }   }   }   logger . flush (  )  ;   }  
public static  string   (  date date )  {  if  ( time format  =  =  null )   {  if  ( properties  !  =  null )   {  time format =  date format . get time instance (  date format . short get locale (  )  )  ;  time format . set time zone ( get time zone (  )  )  ;   }  else  {   date format instance =  date format . get time instance (  date format . short get locale (  )  )  ;  instance . set time zone ( get time zone (  )  )  ;  return instance . format ( date )  ;   }   }  return time format . format ( date )  ;   }  
public   ( int id  string phone )  {  this . id = id ;  this . phone = phone ;   }  
static void   ( sq lite database db int old version int new version )  {  try  {  db . execsql ( "drop table "  +   account . table   name )  ;   }  catch  (  sql exception e )   {   }  create account table ( db )  ;   }  
public  string   (  )  {  return resource ;   }  
@ override public int   (  )  throws  jsp exception  {  parent =  (  sidebar tag ) find ancestor with class ( this  sidebar tag . class )  ;  if  ( parent  =  =  null )   {  throw new  jsp tag exception ( " sub sidebar tag with out a parent which is expec
public boolean   (  rate rate  output stream out )  throws io exception  {  try  {  try  {     sem . acquire (  )  ;   }  catch  (   interrupted exception ie )   {   }  return locked   getxml ( rate out )  ;   }  finally  {     sem . release (  )  ;   }   }  
public   (  list <  string >  log )  {  this . log = log ;   }  
@ override public void   ( jid sender jid receiver )  {  final  chat state change event event = new  chat state change event ( sender receiver  chat state type . inactive )  ;  listener . chat state change ( event )  ;   }  
@ test public void   (  )  {  try  {  final  list <  throwable >  list = new  copy on write array list <  throwable >  (  )  ;   rx java plugins . set error handler ( add to list ( list )  )  ;  final  runtime exception e1 = new  runtime exception (  )  ;
public  string   (  )  {   calendar cal = get calendar (  )  ;  return to date string ( cal . get (  calendar . hour   of   day )  )   +   (  (  ( cal . get (  calendar . second )  % 2 )   =  =  0 )   ?  ":" : " " )   +  to date string ( cal . get (  calendar . minute )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . window ( 1 null  schedulers . single (  )  1 )  ;   }  
public void   (  string phone number )  {  this . phone number = phone number ;   }  
protected i2np message   (  tunnel id reply tunnel id  hash reply gateway long expiration  router info peer )  {  throw new  unsupported operation exception ( "see  explore job" )  ;   }  
public static  class <  ?  >    ( final  class loader class loader final  string class name )  throws  class not found exception  {  if  ( class name  =  =  null )   {  throw new  illegal argument exception ( " class name cannot be null ! " )  ;   }  if  ( class name . length (  )   <  =  max   prim   classname   length &&  character . is lower case ( class name . char at ( 0 )  )  )   {  for  ( int i = 0 ;  i  <  primitive   classes   array . length ;  i +  +  )   {  if  ( class name . equals ( primitive   classes   array[i] . get name (  )  )  )   {  return primitive   classes   array[i] ;   }   }   }   class loader the class loader = class loader ;  if  ( class name . starts with ( "com . hazelcast . " )  || class name . starts with ( "[ lcom . hazelcast . " )  )   {  the class loader =  hazelcast instance . class . get class loader (  )  ;   }  if  ( the class loader  =  =  null )   {  the class loader =  thread . current thread (  )  . get context class loader (  )  ;   }  if  ( the class loader  !  =  null )   {  if  ( class name . starts with ( "[" )  )   {  return  class . for name ( class name true the class loader )  ;   }  else  {  return the class loader . load class ( class name )  ;   }   }  return  class . for name ( class name )  ;   }  
private static void   ( int[] grouping final int node id1 final int node id2 )  {  final int rep node1 = find rep node ( grouping node id1 )  ;  final int rep node2 = find rep node ( grouping node id2 )  ;  if  ( rep node1  =  =  rep node2 )  return ;  grouping[rep node1] = rep node2 ;   }  
public  list < t >    ( t key int max  collection < t >  to ignore )  {  if  ( key . equals (    us )  )  return get closest ( max to ignore )  ;   list < t >  rv = new  array list < t >  ( max )  ;  int count = 0 ;  get read lock (  )  ;  try  {  int start = pick bucket ( key )  ;  for  ( int i = start ;  i  >  =  0 && count  <  max ;  i -  -  )   {   set < t >  entries =    buckets . get ( i )  . get entries (  )  ;  for  (  t e : entries )   {  if  (  ! to ignore . contains ( e )  )   {  rv . add ( e )  ;  count +  +  ;   }   }   }  for  ( int i = start  +  1 ;  i  <     buckets . size (  )  && count  <  max ;  i +  +  )   {   set < t >  entries =    buckets . get ( i )  . get entries (  )  ;  for  (  t e : entries )   {  if  (  ! to ignore . contains ( e )  )   {  rv . add ( e )  ;  count +  +  ;   }   }   }   }  finally  {  release read lock (  )  ;   }   comparator < t >  comp = new xor comparator < t >  ( key )  ;   collections . sort ( rv comp )  ;  int sz = rv . size (  )  ;  for  ( int i = sz  -  1 ;  i  >  =  max ;  i -  -  )   {  rv . remove ( i )  ;   }  return rv ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  2 )   {  bs . on next ( 2 )  ;   }   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  drain loop (  )  ;   }   }  
public   (  callable <  ?  extends d >  resource supplier  function <  ?  super d  ?  extends  publisher <  ?  extends t >  >  source supplier  consumer <  ?  super d >  disposer boolean eager )  {  this . resource supplier = resource supplier ;  this . source supplier = source supplier ;  this . disposer = disposer ;  this . eager = eager ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private boolean   (  print writer out  http servlet request req boolean can write )  throws io exception  {  final long stats[] =  { 0 0 0 0 0 0 }  ;   string peer param = req . get parameter ( "p" )  ;   string st param = req . get parameter ( "st" )  ;   list <  snark >  snarks = get sorted snarks ( req )  ;  boolean is form =    manager . util (  )  . connected (  )  ||  ! snarks . is empty (  )  ;  if  ( is form )   {  out . write ( " < form action = \"   post\" method = \"post\" > \n" )  ;  write hidden inputs ( out req null )  ;   }  out . write ( table   header )  ;   string ua = req . get header ( " user -  agent" )  ;  boolean is degraded = ua  !  =  null &&  servlet util . is text browser ( ua )  ;  boolean no thinsp = is degraded ||  ( ua  !  =  null && ua . starts with ( " opera" )  )  ;  int start = 0 ;  int total = snarks . size (  )  ;  if  ( st param  !  =  null )   {  try  {  start =  math . max ( 0  math . min ( total  -  1  integer . parse int ( st param )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }  int page size =  math . max (    manager . get page size (  )  5 )  ;   string current sort = req . get parameter ( "sort" )  ;  boolean show sort = total  >  1 ;  out . write ( " < tr >  < th class = \"snark graphic status\" > " )  ;   string sort =  ( "2" . equals ( current sort )  )   ?  " - 2" : "2" ;  if  ( show sort )   {  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }   string tx =    t ( " status" )  ;  out . write ( to theme img ( "status" tx show sort  ?     t ( " sort by  { 0 } " tx )  : tx )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;  out . write ( " <  / th > \n < th class = \"snark torrent status\" > " )  ;  if  (    manager . util (  )  . connected (  )  &&  ! snarks . is empty (  )  )   {  out . write ( "  < a href = \""  +     context path  +  ' / ' )  ;  if  ( peer param  !  =  null )   {  out . write ( get query string ( req "" null null )  )  ;  out . write ( "\" > " )  ;  tx =    t ( " hide  peers" )  ;  out . write ( to theme img ( "hidepeers" tx tx )  )  ;   }  else  {  out . write ( get query string ( req "1" null null )  )  ;  out . write ( "\" > " )  ;  tx =    t ( " show  peers" )  ;  out . write ( to theme img ( "showpeers" tx tx )  )  ;   }  out . write ( " <  / a > \n" )  ;   }  out . write ( " <  / th > \n < th colspan = \"2\" align = \"left\" > " )  ;  boolean is type sort = false ;  if  ( show sort )   {  if  ( current sort  =  =  null || "0" . equals ( current sort )  || "1" . equals ( current sort )  )   {  sort = " - 1" ;   }  else if  ( " - 1" . equals ( current sort )  )   {  sort = "12" ;  is type sort = true ;   }  else if  ( "12" . equals ( current sort )  )   {  sort = " - 12" ;  is type sort = true ;   }  else  {  sort = "" ;   }  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( " torrent" )  ;  out . write ( to theme img ( "torrent" tx show sort  ?     t ( " sort by  { 0 } "  ( is type sort  ?     t ( " file type" )  : tx )  )  : tx )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;  out . write ( " <  / th > \n < th id = \"pagenav\" align = \"center\" > " )  ;  if  ( total  >  0 &&  ( start  >  0 || total  >  page size )  )   {  write page nav ( out req start page size total no thinsp )  ;   }  out . write ( " <  / th > \n < th class = \"snark torrenteta\" align = \"right\" > " )  ;  if  (    manager . util (  )  . connected (  )  &&  ! snarks . is empty (  )  )   {  if  ( show sort )   {  sort =  ( " - 4" . equals ( current sort )  )   ?  "4" : " - 4" ;  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( "eta" )  ;  out . write ( to theme img ( "eta" tx show sort  ?     t ( " sort by  { 0 } "    t ( " estimated time remaining" )  )  :    t ( " estimated time remaining" )  )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;   }  out . write ( " <  / th > \n < th class = \"snark torrent downloaded\" align = \"right\" > " )  ;  boolean is dl sort = false ;  if  ( show sort )   {  if  ( " - 5" . equals ( current sort )  )   {  sort = "5" ;   }  else if  ( "5" . equals ( current sort )  )   {  sort = " - 6" ;  is dl sort = true ;   }  else if  ( " - 6" . equals ( current sort )  )   {  sort = "6" ;  is dl sort = true ;   }  else  {  sort = " - 5" ;   }  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( "rx" )  ;  out . write ( to theme img ( "head   rx" tx show sort  ?     t ( " sort by  { 0 } "  ( is dl sort  ?     t ( " downloaded" )  :    t ( " size" )  )  )  :    t ( " downloaded" )  )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;  out . write ( " <  / th > \n < th class = \"snark torrent uploaded\" align = \"right\" > " )  ;  boolean is rat sort = false ;  if  (  ! snarks . is empty (  )  )   {  boolean next rat sort = false ;  if  ( show sort )   {  if  ( " - 7" . equals ( current sort )  )   {  sort = "7" ;   }  else if  ( "7" . equals ( current sort )  )   {  sort = " - 11" ;  next rat sort = true ;   }  else if  ( " - 11" . equals ( current sort )  )   {  sort = "11" ;  next rat sort = true ;  is rat sort = true ;   }  else if  ( "11" . equals ( current sort )  )   {  sort = " - 7" ;  is rat sort = true ;   }  else  {  sort = " - 7" ;   }  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( "tx" )  ;  out . write ( to theme img ( "head   tx" tx show sort  ?     t ( " sort by  { 0 } "  ( next rat sort  ?     t ( " upload ratio" )  :    t ( " uploaded" )  )  )  :    t ( " uploaded" )  )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;   }  out . write ( " <  / th > \n < th class = \"snark torrent rate down\" align = \"right\" > " )  ;  if  (    manager . util (  )  . connected (  )  &&  ! snarks . is empty (  )  )   {  if  ( show sort )   {  sort =  ( " - 8" . equals ( current sort )  )   ?  "8" : " - 8" ;  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( "rx  rate" )  ;  out . write ( to theme img ( "head   rxspeed" tx show sort  ?     t ( " sort by  { 0 } "    t ( " down  rate" )  )  :    t ( " down  rate" )  )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;   }  out . write ( " <  / th > \n < th class = \"snark torrent rate up\" align = \"right\" > " )  ;  if  (    manager . util (  )  . connected (  )  &&  ! snarks . is empty (  )  )   {  if  ( show sort )   {  sort =  ( " - 9" . equals ( current sort )  )   ?  "9" : " - 9" ;  out . write ( " < a href = \""  +     context path  +  ' / ' +  get query string ( req null null sort )  )  ;  out . write ( "\" > " )  ;   }  tx =    t ( "tx  rate" )  ;  out . write ( to theme img ( "head   txspeed" tx show sort  ?     t ( " sort by  { 0 } "    t ( " up  rate" )  )  :    t ( " up  rate" )  )  )  ;  if  ( show sort )  out . write ( " <  / a > " )  ;   }  out . write ( " <  / th > \n < th class = \"snark torrent action\" align = \"center\" > " )  ;  if  (    manager . is stopping (  )  )   {  out . write ( "&nbsp ; " )  ;   }  else if  (    manager . util (  )  . connected (  )  )   {  if  ( is degraded )  out . write ( " < a href = \""  +     context path  +  " /  ? action =  stop all&amp ; nonce = " +     nonce +  "\" >  < img title = \"" )  ;  else  {  out . write ( " < input type = \"image\" name = \"action    stop all\" value = \"foo\" title = \"" )  ;   }  out . write (    t ( " stop all torrents and the i2p tunnel" )  )  ;  out . write ( "\" src = \""  +     img path  +  "stop   all . png\" alt = \"" )  ;  out . write (    t ( " stop  all" )  )  ;  out . write ( "\" > " )  ;  if  ( is degraded )  out . write ( " <  / a > " )  ;  for  (   snark s : snarks )   {  if  ( s . is stopped (  )  )   {  if  ( is degraded )  out . write ( " < a href = \""  +     context path  +  " /  ? action =  start all&amp ; nonce = " +     nonce +  "\" >  < img title = \"" )  ;  else out . write ( " < input type = \"image\" name = \"action    start all\" value = \"foo\" title = \"" )  ;  out . write (    t ( " start all stopped torrents" )  )  ;  out . write ( "\" src = \""  +     img path  +  "start   all . png\" alt = \"" )  ;  out . write (    t ( " start  all" )  )  ;  out . write ( "\" > " )  ;  if  ( is degraded )  out . write ( " <  / a > " )  ;  break ;   }   }   }  else if  (  (  !    manager . util (  )  . is connecting (  )  )  &&  ! snarks . is empty (  )  )   {  if  ( is degraded )  out . write ( " < a href = \""  +     context path  +  " /  ? action =  start all&amp ; nonce = " +     nonce +  "\" >  < img title = \"" )  ;  else out . write ( " < input type = \"image\" name = \"action    start all\" value = \"foo\" title = \"" )  ;  out . write (    t ( " start all torrents and the i2p tunnel" )  )  ;  out . write ( "\" src = \""  +     img path  +  "start   all . png\" alt = \"" )  ;  out . write (    t ( " start  all" )  )  ;  out . write ( "\" > " )  ;  if  ( is degraded )  out . write ( " <  / a > " )  ;   }  else  {  out . write ( "&nbsp ; " )  ;   }  out . write ( " <  / th >  <  / tr > \n" )  ;  out . write ( " <  / thead > \n" )  ;   string uri =    context path  +  ' / ' ;  boolean show debug = "2" . equals ( peer param )  ;  for  ( int i = 0 ;  i  <  total ;  i +  +  )   {   snark snark = snarks . get ( i )  ;  boolean show peers = show debug || "1" . equals ( peer param )  ||  base64 . encode ( snark . get info hash (  )  )  . equals ( peer param )  ;  boolean hide = i  <  start || i  >  =  start  +  page size ;  display snark ( out req snark uri i stats show peers is degraded no thinsp show debug hide is rat sort can write )  ;   }  if  ( total  =  =  0 )   {  out . write ( " < tr class = \"snark torrent none loaded\" > "  +  " < td colspan = \"11\" > " )  ;  synchronized  ( this )   {   file dd =    resource base ;  if  (  ! dd . exists (  )  &&  ! dd . mkdirs (  )  )   {  out . write (    t ( " data directory cannot be created" )   +  ": "  +   data helper . escapehtml ( dd . to string (  )  )  )  ;   }  else if  (  ! dd . is directory (  )  )   {  out . write (    t ( " not a directory" )   +  ": "  +   data helper . escapehtml ( dd . to string (  )  )  )  ;   }  else if  (  ! dd . can read (  )  )   {  out . write (    t ( " unreadable" )   +  ": "  +   data helper . escapehtml ( dd . to string (  )  )  )  ;   }  else if  (  ! can write )   {  out . write (    t ( " no write permissions for data directory" )   +  ": "  +   data helper . escapehtml ( dd . to string (  )  )  )  ;   }  else  {  out . write (    t ( " no torrents loaded . " )  )  ;   }   }  out . write ( " <  / td >  <  / tr > \n" )  ;   }  else  {  out . write ( " < tfoot >  < tr > \n"  +  "  < th id = \"snark torrent totals\" align = \"left\" colspan = \"6\" > " )  ;  out . write ( " < span id = \"totals\" > " )  ;  out . write (    t ( " totals" )  )  ;  out . write ( ":&nbsp ; " )  ;  out . write ( ngettext ( "1 torrent" " { 0 }  torrents" total )  )  ;  out . write ( "  " )  ;  out . write ( format size ( stats[5] )  )  ;  if  (    manager . util (  )  . connected (  )  && total  >  0 )   {  out . write ( "  " )  ;  out . write ( ngettext ( "1 connected peer" " { 0 }  connected peers"  ( int ) stats[4] )  )  ;   }  dht dht =    manager . util (  )  . getdht (  )  ;  if  ( dht  !  =  null )   {  int dhts = dht . size (  )  ;  if  ( dhts  >  0 )   {  out . write ( "   < span > " )  ;  out . write ( ngettext ( "1 dht peer" " { 0 }  dht peers" dhts )  )  ;  out . write ( " <  / span > " )  ;   }   }   string ip string =    manager . util (  )  . get ourip string (  )  ;  if  (  ! ip string . equals ( "unknown" )  )   {  out . write ( " ; &nbsp ;  < span id = \"our dest\" > " )  ;  out . write (    t ( " dest" )  )  ;  out . write ( ":&nbsp ;  < tt title = \"" )  ;  out . write (    t ( " our destination  ( identity )  for this session" )  )  ;  out . write ( "\" > " )  ;  out . write ( ip string . substring ( 0 4 )  )  ;  out . write ( " <  / tt >  <  / span > " )  ;   }  out . write ( " <  / span > " )  ;  out . write ( " <  / th > \n" )  ;  if  (    manager . util (  )  . connected (  )  && total  >  0 )   {  out . write ( "  < th class = \"snark torrent downloaded\" align = \"right\" > "  +  format size ( stats[0] )   +  " <  / th > \n" +  "  < th class = \"snark torrent uploaded\" align = \"right\" > " +  format size ( stats[1] )  +  " <  / th > \n" +  "  < th class = \"snark torrent rate down\" align = \"right\" > " +  format size dec ( stats[2] )  +  "ps <  / th > \n" +  "  < th class = \"snark torrent rate up\" align = \"right\" > " +  format size dec ( stats[3] )  +  "ps <  / th > \n" +  "  < th class = \"snark torrent action\" >  <  / th > " )  ;   }  else  {  out . write ( " < th colspan = \"5\" >  <  / th > " )  ;   }  if  ( dht  !  =  null )   {  if  ( show debug )   {  out . write ( " <  / tr > \n < tr class = \"dht debug\" > " )  ;  out . write ( " < th colspan = \"11\" > " )  ;  out . write ( " < div id = \"dht debug panel\" > " )  ;  out . write ( " < input class = \"toggle   input\" id = \"toggle   debug\" type = \"checkbox\" >  < label class = \"toggleview\" for = \"toggle   debug\" > " )  ;  out . write ( to theme img ( "debug" )  )  ;  out . write ( ' ' )  ;  out . write (    t ( " dht  debug" )  )  ;  out . write ( " <  / label >  < div id = \"dht debug inner\" > " )  ;  out . write ( dht . render statushtml (  )  )  ;  out . write ( " <  / div >  <  / div >  <  / th > " )  ;   }   }  out . write ( " <  / tr >  <  / tfoot > \n" )  ;   }  out . write ( " <  / table > " )  ;  if  ( is form )  out . write ( " <  / form > \n" )  ;  return start  =  =  0 ;   }  
public void   (  http connection pool config config )  {   hash map <  string  http client >  new pool map = new  hash map <  >  (  )  ;  for  (   pool type pool type : config . get pool (  )  )   {  if  ( pool type . is default (  )  )   {  default client id = pool type . get id (  )  ;   }  new pool map . put ( pool type . get id (  )  client generator ( config root pool type )  )  ;   }  if  (  ! pool map . is empty (  )  )   {  decommission manager . decommission client ( pool map )  ;   }  pool map = new pool map ;   }  
@ override public void   (  )  throws  interrupted exception  {  if  (  ! started )   {  throw new  illegal state exception ( " this method can be called only after the executor has been started . " )  ;   }  else  {  executor . await termination (  long 
private static final  string   (  string pattern int num )  {  char c[] = pattern . to char array (  )  ;   string builder buf = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  c . length ;  i +  +  )   {  if  (  ( c[i]  !  =  '#' )  &&  ( c[i]  !  =  '@' )  )  buf . append ( c[i] )  ;  else buf . append ( num )  ;   }  return buf . to string (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  list <  integer >  >  ts = pp . buff
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( 1l 1l null )  ;   }  
@ non null public static  runtime exception   ( @ non null  throwable t )  {  throw  exception helper . wrap or throw ( t )  ;   }  
  (  subscriber <  ?  super r >  downstream  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper int prefetch  error mode error mode )  {  this . downstream = downstream ;  this . mapper = mapper ;  this . prefetch = prefetch ;  this . error mode = error mode ;  this . requested = new  atomic long (  )  ;  this . errors = new  atomic throwable (  )  ;  this . inner = new  concat map maybe observer < r >  ( this )  ;  this . queue = new  spsc array queue < t >  ( prefetch )  ;   }  
public  agent   ( long agentid )  throws  agent not found exception  {  for  (   agent agent : agents . values (  )  )   {  if  ( agent . getid (  )   =  =  agentid )   {  return agent ;   }   }  throw new  agent not found exception (  long . to hex string ( agentid )  )  ;   }  
@ override public  string   (  )  {  return "[ abuse severity: "  +     severity id  +  "]" ;   }  
public   (  local client session session )  throws  sasl exception  {  this . session = session ;   }  
public   (  iterable <  ?  extends t >  source )  {  this . source = source ;   }  
@ deprecated public synchronized  handler job builder   ( int i2np message type )  {   handler job builder old =    handler job builders[i2np message type] ;     handler job builders[i2np message type] = null ;  return old ;   }  
@ override protected void   (  )  {  int i = 60 ;  do  {  pad[i] =  ( byte ) 0x00 ;  pad[i  +  1] =  ( byte ) 0x00 ;  pad[i  +  2] =  ( byte ) 0x00 ;  pad[i  +  3] =  ( byte ) 0x00 ;   }  while  (  ( i -  = 4 )   >  =  0 )  ;  padding = 0 ;  bytes = 0 ;  
public boolean   ( int tunnel )  {  return get boolean property ( tunnel i2p tunnelhttp client base . prop   use   outproxy   plugin true )  ;   }  
@ test public void   (  )  throws  exception  {  final dns util .  weighted host address host = new dns util .  weighted host address ( "host" 5222 0 1 )  ;  final  list < dns util .  weighted host address >  result = dns util . prioritize ( new dns util 
@ test public void   (  )  {   worker w =  schedulers . io (  )  . create worker (  )  ;  assert false (  (  (  disposable ) w )  . is disposed (  )  )  ;  w . dispose (  )  ;  assert true (  (  (  disposable ) w )  . is disposed (  )  )  ;   }  
public void   ( i2p session session int severity )  {  if  (    log . should log (  log . error )  )     log . error ( " abuse reported with severity "  +  severity )  ;     manager . disconnect all hard (  )  ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . start with array (  )  . test (  )  . assert result ( 1 )  ;   }  
public int   (  )  {  int tags = 0 ;  long now =    context . clock (  )  . now (  )  ;  synchronized  (    tag sets )   {  for  ( int i = 0 ;  i  <     tag sets . size (  )  ;  i +  +  )   {   tag set set =    tag sets . get ( i )  ;  if  ( set . get date (  )   +  session   tag   duration   ms  >  now )   {  int sz = set . get tags (  )  . size (  )  ;  if  (  ! set . get acked (  )  )  sz =  ( sz  +  2 )   /  3 ;  tags +  = sz ;   }   }   }  return tags ;   }  
@ test public void   (  )  {  test map collector (  immutable map . class new  generic type <  immutable map <  long  string >  >  (  )  {   }   )  ;  test map collector (  bi map . class new  generic type <  bi map <  long  string >  >  (  )  {   }   )  
public  string   (  )  {   string s ;  switch  ( event )   {  case conference   started: s = "conference   started ( "  +  event  +  " ) " +  "  conference id " +  conference id ;  break ;  case conference   ended: s = "conference   ended ( "  +  event  +  " ) " +  "  conference id " +  conference id ;  break ;  case member   joined: s = "member   joined ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  count " +  member count +  "  member address " +  member address ;  break ;  case member   left: s = "member   left ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  count " +  member count +  "  member address " +  member address ;  break ;  default : s = "unknown  conference eevent ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  member address " +  member address ;  break ;   }  return s ;   }  
@ test public void   (  )  throws  exception  {  i2p socket manager full mgr =  ( i2p socket manager full ) i2p socket manager factory . create disconnected manager ( null "example . com" 3333 null )  ;  assert that ( mgr is ( not ( null value (  )  )  ) 
public boolean   (  )  {  final byte[] s = to byte array (  )  ;  return  utils . equal ( s zero )   =  =  0 ;   }  
public   (  router context ctx  client message msg )  {     context = ctx ;     msg = msg ;     clove = null ;     lease set = null ;     sent = new  hash set <  tunnel >  ( 4 )  ;     success = false ;     failure = false ;     num lookups = 0 ;     previous sent = 0 ;     start = ctx . clock (  )  . now (  )  ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;   }  
private int   (  file bl file )  {  if  (  (  ! bl file . exists (  )  )  ||  ( bl file . length (  )   <  =  0 )  )  return 0 ;  int lines = 0 ;   buffered reader br = null ;  try  {  br = new  buffered reader ( new  input stream reader ( new  file input stream ( bl file )  "iso - 8859 - 1" )  )  ;   string s ;  while  (  ( s = br . read line (  )  )   !  =  null )   {  if  ( s . length (  )   >  0 &&  ! s . starts with ( "#" )  )  lines +  +  ;   }   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error reading the blocklist file" ioe )  ;  return 0 ;   }  finally  {  if  ( br  !  =  null )  try  {  br . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  return lines ;   }  
@ override public boolean   (  )  {  return initialized ;   }  
private static void   (  string host int port  string con options  string dest name )  {     log . info ( "\n\n testing creating a new destination  ( should come back with 'session status result = ok destination = some name ) \n\n\n" )  ;  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;     log . debug ( "line read for valid version: "  +  line )  ;   string req = "session create style = stream destination = "  +  dest name  +  " " +  con options +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . info ( " response to creating the session with destination "  +  dest name  +  ": " +  line )  ;     log . debug ( " the above should contain session status result = ok\n\n\n" )  ;  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  s . close (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
public void   ( boolean auto answer )  {  this . auto answer = auto answer ;   }  
public  class   (  )  {  return packet class ;   }  
@ test public void   (  )  throws  exception  {   properties opts = new  properties (  )  ;  opts . set property ( i2p client . prop   reliability i2p client . prop   reliability   best   effort )  ;  opts . set property ( "foo" "bar" )  ;  i2p socket man
public   (  input stream is )  {  this . is = is ;   }  
@ test @ ignore ( "take ( 0 )  is now empty (  )  and doesn't even subscribe to the original source" )  public void   (  )  {  final  atomic boolean subscribed = new  atomic boolean ( false )  ;  final  boolean subscription bs = new  boolean subscription 
public void   ( byte payload )  {  byte mark =  ( byte )  ( buffer[1] & mark   bit )  ;  buffer[1] =  ( byte )  ( payload | mark )  ;   }  
private static byte[]   ( byte[] d )  throws  invalid key spec exception  {  try  {  int idx = 0 ;  if  ( d[idx +  + ]  !  =  0x30 || d[idx +  + ]  !  =  47 || d[idx +  + ]  !  =  0x02 || d[idx +  + ]  !  =  1 || d[idx +  + ]  !  =  0 || d[idx +  + ]  !  =  0x30 || d[idx +  + ]  !  =  8 || d[idx +  + ]  !  =  0x06 || d[idx +  + ]  !  =  3 || d[idx +  + ]  !  =   ( 1 * 40 )   +  3 || d[idx +  + ]  !  =  101 || d[idx +  + ]  !  =  100 || d[idx +  + ]  !  =  0x0a || d[idx +  + ]  !  =  1 || d[idx +  + ]  !  =  1 || d[idx +  + ]  !  =  0x04 || d[idx +  + ]  !  =  32 )   {  throw new  invalid key spec exception ( "unsupported key spec" )  ;   }  byte[] rv = new byte[32] ;   system . arraycopy ( d idx rv 0 32 )  ;  return rv ;   }  catch  (   index out of bounds exception ioobe )   {  throw new  invalid key spec exception ( ioobe )  ;   }   }  
@ test ( timeout = 2000 )  public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;  final  publish subject <  integer >  timeout =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >
  ( t value  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper )  {  this . value = value ;  this . mapper = mapper ;   }  
public static void   ( final  string[] argv )  {  new  merge vcfs (  )  . instance main with exit ( argv )  ;   }  
public  map .  entry <  string  host txt entry >    (  )  {  if  (  ! has next (  )  )  throw new  no such element exception (  )  ;   map .  entry <  string  host txt entry >  rv = next ;  next = null ;  return rv ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber < 
@ test public void   (  )  throws io exception  {  long expected = stream   data1 . length (  )   -  1 ;  long actual = combined stream . skip ( expected )  ;  assert equals ( expected actual )  ;   }  
public   (  string s )  {  g = false ;  h = new  hash map (  )  ;  d = new g (  )  ;  c = new g (  )  ;  b = new    a (  )  ;  b . start (  )  ;  f . info (  ( new  string builder (  )  )  . append ( " new publication " )  . append ( s )  . to string (  )  )  ;  j = s ;   }  
@ test public final void   (  )  throws  interrupted exception  {   scheduler test helper . test handled error is not delivered to thread handler ( get scheduler (  )  )  ;   }  
public void   ( final  string font tag final  font font final boolean set all final boolean keep sizes )  throws  rrd exception  {  this . set font ( get font tag by name ( font tag )  font set all keep sizes )  ;   }  
public synchronized boolean   (  )  {  return is new ;   }  
public void   (  )  {  muc event dispatcher . remove listener ( this )  ;  conversation manager = null ;   }  
private  signature   ( byte[] data int offset int len  signing private key private key )  throws  general security exception  {   sig type type = private key . get type (  )  ;  if  ( type  =  =   sig type . dsa   sha1 )  return alt signsha1 ( data offset len private key )  ;   private key priv key =  sig util . to java key ( private key )  ;  byte[] sigbytes ;  if  ( type . get base algorithm (  )   =  =   sig algo .  eddsa )   {   eddsa engine jsig = new  eddsa engine ( type . get digest instance (  )  )  ;  jsig . init sign ( priv key )  ;  sigbytes = jsig . sign one shot ( data offset len )  ;   }  else  {  java . security .  signature jsig = java . security .  signature . get instance ( type . get algorithm name (  )  )  ;  jsig . init sign ( priv key    context . random (  )  )  ;  jsig . update ( data offset len )  ;  sigbytes = jsig . sign (  )  ;   }  return  sig util . from java sig ( sigbytes type )  ;   }  
 string   (  )  {  return path ;   }  
@ override void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  if  (  ! active )   {  boolean d = done ;  if  ( d &&  ! very end )   {   throwable ex = errors . get (  )  ;  if  ( ex  !
@ override public  command result   (  string[] arguments )  {  if  ( arguments . length  !  =  2 )   {  return new  invalid arguments ( " the limits remover expects two string arguments . " )  ;   }   command result result ;  try  {  final  repose local 
static  interval list   (  )  {  return new  interval list ( new sam file header (  )  )  ;   }  
public  string   (  )  {  if  ( email notify list  =  =  null || email notify list . is empty (  )  )   {  return "" ;   }   string builder buf = new  string builder (  )  ;  buf . append ( email notify list . get ( 0 )  )  ;  for  ( int i = 1 ;  i  <  email notify list . size (  )  ;  i +  +  )   {  buf . append ( "  " )  ;  buf . append ( email notify list . get ( i )  )  ;   }  return buf . to string (  )  ;   }  
public void   (  user request request )  {  this . request = request ;   }  
@ override public  observable source <  object >    (  observable <  object >  o )  throws  exception  {  return o . take while (  functions . always true (  )  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  observable < r >    (  function <  ?  super  observable < t >   ?  extends  observable source < r >  >  selector )  {   object helper . require non null ( selecto
public static boolean   (  )  {  return    is linux service ;   }  
@ override public  string   ( final  variant context ctx )  {  final double fs = ctx . get attribute as double ( "fs" 0 )  ;  return  ( fs  >  max phred scalep value )   ?  " strand bias" : null ;   }  
public   (  )  {  super ( prc )  ;   }  
public void   (  string value )  {  get device node (  )  . set node ( manufacture value )  ;   }  
void   (  )  {  for  (  ;   ;   )   {   append only linked array list <  object >  q ;  synchronized  ( this )   {  q = queue ;  if  ( q  =  =  null )   {  emitting = false ;  return ;   }  queue = null ;   }  q . for each while ( this )  ;   }   }  
@ override public void   (  )  {  m pre configured failed = false ;  m password failed = false ;  dismiss check settings fragment (  )  ;  proceed (  )  ;   }  
  (  string name  string path  string ds name  string consol func  string backend )  {  super ( name )  ;  this . path = path ;  this . ds name = ds name ;  this . consol fun = consol func ;  this . backend = backend ;   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends  iterable <  ?  extends r >  >  mapper )  {  this . actual = actual ;  this . mapper = mapper ;  this . requested = new  atomic long (  )  ;   }  
public void   (  )  {     comm system facades . remove (    context . router hash (  )  )  ;   }  
@ after class public static void   (  )  {   system . clear property (  configuration factory . configuration   file   property )  ;  ctx . reconfigure (  )  ;   status logger . get logger (  )  . reset (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . combine latest delay error (  arrays . as list ( just1 )  new  function <  object[]  object >  (  )  {  @ override public  objec
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
public void   ( final  match results match results )  {  this . match results . add ( match results )  ;   }  
@ deprecated public void   (  )  {   ( new  synchronize keys job (  )  )  . run job (  )  ;   }  
public void   (  string value )  {  get device node (  )  . set node ( serial   number value )  ;   }  
@ override public void   (  subscription s )  {  s . request (  long . max   value )  ;   }  
public void   (  )  {     banlist . remove (    dest )  ;   }  
@ suppress warnings ( "rawtypes" )  @ test public void   (  )  {  try  {   rx java plugins . set on connectable flowable assembly ( new  function <  connectable flowable  connectable flowable >  (  )  {  @ override public  connectable flowable apply (   c
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  integer >   object >  (  )  {  @ override public  object apply (   flowable <  integer >  f )  throws  exception  {  return f . reduce ( sum )  . to flow
@ override public  list < t >    ( int from index int to index )  {  return list . sub list ( from index to index )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . filter (  functions . always false (  )  )  . filter (  functions . always false (  )  )  . test (  )  . assert result (  )  ;   }  
int   (  )  {  return num clusters in tile ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on error return ( null )  ;   }  
public synchronized int   (  string message )  {     messages . offer ( new  message (    count +  +  message )  )  ;  while  (    messages . size (  )   >     max size )   {     messages . poll (  )  ;   }  return    count ;   }  
public void   (  string cmd )  throws  interrupted exception  io exception  {  long timeout = ping   timeout ;  int count = ping   count ;  boolean count ping = false ;  boolean report times = true ;   string host list file = null ;  int local port = 0 ;  int remote port = 0 ;  boolean error = false ;   string[] argv =  data helper . split ( cmd " " )  ;   getopt g = new  getopt ( "ping" argv "t:m:n:chl:f:p:" )  ;  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 't': timeout =  long . parse long ( g . get optarg (  )  )  ;  if  ( timeout  <  100 )  timeout* = 1000 ;  break ;  case 'm': max   simul   pings =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'n': count =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'c': count ping = true ;  count = cping   count ;  break ;  case 'h': if  ( host list file  !  =  null )  error = true ;  else host list file = "hosts . txt" ;  break ;  case 'l': if  ( host list file  !  =  null )  error = true ;  else host list file = g . get optarg (  )  ;  break ;  case 'f': local port =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'p': remote port =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case ' ? ': case ':': default : error = true ;   }   }  int remaining = argv . length  -  g . get optind (  )  ;  if  ( error || remaining  >  1 ||  ( remaining  <  =  0 && host list file  =  =  null )  ||  ( remaining  >  0 && host list file  !  =  null )  )   {   system . out . println ( usage (  )  )  ;  return ;   }  if  ( host list file  !  =  null )   {   buffered reader br = null ;  try  {  br = new  buffered reader ( new  input stream reader ( new  file input stream ( host list file )  "utf - 8" )  )  ;   string line ;   list <  ping handler >  ping handlers = new  array list <  ping handler >  (  )  ;  int i = 0 ;  while  (  ( line = br . read line (  )  )   !  =  null )   {  if  ( line . starts with ( "#" )  )  continue ;  if  ( line . starts with ( " ; " )  )  continue ;  if  ( line . starts with ( " ! " )  )  continue ;  if  ( line . index of ( ' = ' )   !  =   - 1 )   {  line = line . substring ( 0 line . index of ( ' = ' )  )  ;   }   ping handler ph = new  ping handler ( line count local port remote port timeout count ping report times )  ;  ph . start (  )  ;  ping handlers . add ( ph )  ;  if  (  +  + i  >  1 )  report times = false ;   }  br . close (  )  ;  for  (  thread t : ping handlers )  t . join (  )  ;  return ;   }  finally  {  if  ( br  !  =  null )  try  {  br . close (  )  ;   }  catch  ( io exception ioe )   {   }   }   }   string host = argv[g . get optind (  ) ] ;   thread t = new  ping handler ( host count local port remote port timeout count ping report times )  ;  t . start (  )  ;  t . join (  )  ;   }  
@ test public void   (  )  {  set mocks ( 10 * 60 * 1000 0 0 0 0 )  ;  assert false ( scheduler . accept ( con )  )  ;   }  
@ override protected void   (  subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  observer . on next ( 1 )  ;  observer . on complete (  )  ;  observer . on next ( 2 )  ;  observer . on error 
public long   (  )  {  return  - 1 ;   }  
@ override public boolean   ( final android . os .  message message )  {   log utils . d ( log   tag " delayed notification processing" )  ;  synchronized  ( s notification delayed message lock )   {  s notification delayed message pending = false ;  fina
public  data structure   (  )  {  return new  destination (  )  ;   }  
public void   (  string username  privacy list list )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( update   privacy   list )  ;  pstmt . set int ( 1  ( list . is default (  )   ?  1 : 0 )  )  ;  pstmt . set string ( 2 list . as element (  )  . asxml (  )  )  ;  pstmt . set string ( 3 username )  ;  pstmt . set string ( 4 list . get name (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (   exception e )   {   log . error ( " error updating privacy list: "  +  list . get name (  )   +  " of username: " +  username e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  database contains privacy lists . set ( true )  ;   }  
@ benchmark public void   (  blackhole bh )  {  flowable . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ override public final void   (  )  {  cancelled = true ;   }  
@ test public void   (  )  {   maybe . concat (  flowable . from callable ( new  callable <  maybe <  integer >  >  (  )  {  @ override public  maybe <  integer >  call (  )  throws  exception  {  return  maybe . just ( 1 )  ;   }   }   )  )  . test (  ) 
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is enum (  )   ?   optional . o
@ test public void   (  )  {  assert equals ( 1  ( int )  flowable .  <  integer > empty (  )  . concat with (  flowable . just ( 1 )  )  . take ( 1 )  . blocking single (  )  )  ;   }  
void   (  publish observer < t >  p )  {  if  (  ! compare and set ( null p )  )   {  p . remove ( this )  ;   }   }  
private void   ( final  list <  string >  sample list sam sequence dictionary sam sequence dictionary )  {  for  (  final  file input : input )   {  final vcf file reader in = new vcf file reader ( input false )  ;  final vcf header header = in . get file header (  )  ;  final sam sequence dictionary dict = in . get file header (  )  . get sequence dictionary (  )  ;  if  ( dict  =  =  null || dict . is empty (  )  )   {  if  ( null  =  =  sam sequence dictionary )   {  throw new  illegal argument exception ( " sequence dictionary was missing or empty for the vcf: "  +  input . get absolute path (  )   +  "  please add a sequence dictionary to this vcf or specify sequence   dictionary . " )  ;   }  header . set sequence dictionary ( sam sequence dictionary )  ;   }  else  {  if  ( null  =  =  sam sequence dictionary )   {  sam sequence dictionary = dict ;   }  else  {  try  {  sam sequence dictionary . assert same dictionary ( dict )  ;   }  catch  (  final  assertion error e )   {  throw new  illegal argument exception ( e )  ;   }   }   }  if  ( sample list . is empty (  )  )   {  sample list . add all ( header . get sample names in order (  )  )  ;   }  else  {  if  (  ! sample list . equals ( header . get sample names in order (  )  )  )   {  throw new  illegal argument exception ( " input file "  +  input . get absolute path (  )   +  " has sample names that don't match the other files . " )  ;   }   }  input readers . add ( in )  ;  input headers . add ( header )  ;   }   }  
@ override public int   (  )  {  return hp of tumor . get total obs (  )  ;   }  
@ override public void   (  )  throws io exception  {  synchronized  ( this )   {  if  (    current request  !  =  null )     current request . abort (  )  ;   }  super . close (  )  ;   }  
private static void   (  file dbdir  file[] files )  {  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {   file from = files[i] ;  if  (  ! from . is file (  )  )  continue ;   file dir = new  file ( dbdir dir   prefix  +  from . get name (  )  . char at ( routerinfo   prefix . length (  )  )  )  ;   file to = new  file ( dir from . get name (  )  )  ;   file util . rename ( from to )  ;   }   }  
private static void   (  string dir )  {  if  (  system version . has wrapper (  )  )  return ;  if  (  system . get property ( "i2p   disable   output   override" )   !  =  null )  return ;   string path =  system . get property ( prop   wrapper   log )  ;   file logfile ;  if  ( path  !  =  null )   {  logfile = new  file ( path )  ;   }  else  {  logfile = new  file ( default   wrapper   log )  ;  if  (  ! logfile . exists (  )  )   {  if  ( dir  =  =  null )  dir =  system . get property ( "java . io . tmpdir" )  ;  logfile = new  file ( dir default   wrapper   log )  ;   }   }   system . set property ( prop   wrapper   log logfile . get absolute path (  )  )  ;  try  {   print stream ps = new  print stream ( new  secure file output stream ( logfile true )  true "utf - 8" )  ;   system . set out ( ps )  ;   system . set err ( ps )  ;   }  catch  (  io exception ioe )   {  ioe . print stack trace (  )  ;   }   }  
public void   (  workgroup workgroup )  {  boolean added = false ;  boolean already joined = workgroups . contains ( workgroup )  ;  if  (  ! already joined )   {  added = workgroups . add ( workgroup )  ;   }  for  (   request queue request queue : workgroup . get request queues (  )  )   {  if  ( request queue . is member ( get agent (  )  )  )   {  if  ( added )   {  request queue . get agent session list (  )  . add agent session ( this )  ;   }  request queue . send status ( getjid (  )  )  ;  request queue . send detailed status ( getjid (  )  )  ;   }   }  update status ( workgroup )  ;  if  ( added )   {  workgroup . agent joined ( this )  ;  chat infos . put ( workgroup new  concurrent linked queue <  chat info >  (  )  )  ;   }   }  
public void   ( final  file output )  {  this . output = output ;   }  
public   (  router context ctx  database store message received message  router identity from  hash from hash  floodfill network database facade facade )  {  super ( ctx )  ;     log = ctx . log manager (  )  . get log ( get class (  )  )  ;     message = received message ;     from = from ;     from hash = from hash ;     facade = facade ;   }  
public void   (  outbound message state state )  {  if  (    dead )   {     transport . failed ( state false )  ;  return ;   }  if  ( state . get peer (  )   !  =  this )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not for me ! " new  exception ( "i did it" )  )  ;     transport . failed ( state false )  ;  return ;   }  if  (    log . should log (  log . debug )  )     log . debug ( " adding to "  +     remote peer  +  ": " +  state . get message id (  )  )  ;  int rv = 0 ;  boolean fail =  !    outbound queue . offer ( state )  ;  if  ( fail )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping msg  ob queue full for "  +  to string (  )  )  ;     transport . failed ( state false )  ;   }   }  
@ test ( timeout = 2000 )  public void   (  )  {   observable <  long >  start =  observable . interval ( 61 61  time unit . milliseconds scheduler )  ;   function <  long  observable <  long >  >  end = new  function <  long  observable <  long >  >  (  
public  read structure   (  )  {  return output read structure ;   }  
public  string   (  )  {  return display name ;   }  
@ override public void   (  observer <  ?  super  movie >  o )  {  o . on next ( horror movie1 )  ;  o . on next ( movie )  ;  o . on complete (  )  ;   }  
private void   (  )  {  use fast mix = false ;  if  ( mix descriptors . size (  )   !  =  2 )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " call "  +  member  +  "  can't use fast mix  must have exactly 2 descriptors" )  ;   }  return ;   }  for  ( int i = 0 ;  i  <  2 ;  i +  +  )   {   mix descriptor mix descriptor =  (  mix descriptor ) mix descriptors . get ( i )  ;  if  ( mix descriptor . is muted (  )  )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " call "  +  member  +  "  can't use fast mix  md muted " +  mix descriptor )  ;   }  return ;   }   mix data source mix data source = mix descriptor . get mix data source (  )  ;  if  ( mix data source instanceof  member receiver )   {  if  ( mix data source  !  =  member . get member receiver (  )  )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " call "  +  member  +  "  can't use fast mix  have private mix" )  ;   }  return ;   }  if  ( mix descriptor . get effective volume (  )   !  =   - 1 . 0 )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " call "  +  member  +  "  can't use fast mix  no mix minus" )  ;   }  return ;   }  continue ;   }  else if  ( mix data source instanceof  whisper group  =  =  false )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " call "  +  member  +  "  can't use fast mix  not simple mix" )  ;   }  return ;   }  if  ( mix descriptor . is nop (  )   =  =  false )   {  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( "  call "  +  member  +  " can't use fast mix  not spatially neutral" )  ;   }  return ;   }   }   mix descriptor mix descriptor =  (  mix descriptor ) mix descriptors . get ( 0 )  ;  if  ( mix descriptor . get mix data source (  )  instanceof  member receiver )   {  mix descriptors . add ( mix descriptor )  ;  mix descriptors . remove ( 0 )  ;   }  if  (  logger . log level  >  =   logger . log   moredetail )   {   logger . println ( " using fast mix" )  ;   }  use fast mix = true ;   }  
public synchronized void   ( boolean yes )  {  if  ( yes  !  =     floodfill enabled )   {     context . job queue (  )  . remove job (    ff monitor )  ;     ff monitor . get timing (  )  . set start after (    context . clock (  )  . now (  )   +  1000 )  ;     context . job queue (  )  . add job (    ff monitor )  ;   }   }  
public   (  )  {  super ( " offline  message  store" )  ;  size cache =  cache factory . create cache ( " offline  message  size" )  ;   }  
public int   (  )  {  return executor . get maximum pool size (  )  ;   }  
@ test public void   (  )  throws  interrupted exception  {   flowable <  integer >  source =  flowable . just ( 1 2 3 4 5 6 )  ;   maybe <  integer >  reduced = source . reduce ( sum )  ;   integer r = reduced . blocking get (  )  ;  assert equals ( 21 r
void   (  observer <  ?  >  a )  {   throwable ex =  exception helper . terminate ( error )  ;  for  (   unicast subject < t right >  up : lefts . values (  )  )   {  up . on error ( ex )  ;   }  lefts . clear (  )  ;  rights . clear (  )  ;  a . on error ( ex )  ;   }  
public int   (  )  {  return groups . size (  )  ;   }  
@ test public void   (  )  {   single <  boolean >  o =  observable . just ( "a" "b" )  . contains ( "c" )  ;   single observer <  object >  observer =  test helper . mock single observer (  )  ;  o . subscribe ( observer )  ;  verify ( observer times ( 1
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ test public void   (  )  throws  exception  {   flowable <  integer >  source =  flowable . just ( 1 )  ;  try  {   flowable . just ( source source source )  . concat map eager (  (  function )  func
@ before class public void   (  )  throws io exception  {  na12891   r1 =  sam test utils . create indexed bam ( na12891   r1   sam na12891   r1   sam )  ;  na12891   r2 =  sam test utils . create indexed bam ( na12891   r2   sam na12891   r2   sam )  ;  
public boolean   (  )  {  return provider . is read only (  )  ;   }  
@ override public void   ( boolean recurse )  {  throw new  error ( " imap store . delete (  )  not yet implemented" )  ;   }  
public static  string   ( final int lane )  {  final  string builder lstr = new  string builder (  string . value of ( lane )  )  ;  final int zeros to add = 3  -  lstr . length (  )  ;  for  ( int i = 0 ;  i  <  zeros to add ;  i +  +  )   {  lstr . insert ( 0 "0" )  ;   }  return "l"  +  lstr ;   }  
public synchronized void   (  string id  sort order direction )  {  sorting direction = direction ;  current sorter = sorter . get ( id )  ;  if  ( current sorter  !  =  null )   {  if  ( sorting direction  =  =   sort order . up )  current sorter =  collections . reverse order ( current sorter )  ;  current sortid = id ;   }  else  {  current sortid = null ;   }   }  
public   ( final boolean ignore classes and fields hints )  {  super (  )  ;  final  list <  buffer >  buffers to delete = new  array list <  >  (  )  ;  final  map <  string  string >  attachment or byte buffer field name map = new  hash map <  >  (  )  ;  final  string java vendor =  system . get property ( "java . vendor" )  ;  final  string java version =  system . get property ( "java . version" )  ;  if  (  ! ignore classes and fields hints )   {  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  )   {  final  string java14to16 direct buffer attachment field name = "viewed buffer" ;  final  string java17to19 direct buffer attachment field name = "att" ;  final  string byte buffer as non byte buffer byte buffer field name = "bb" ;  final  string[] direct buffer classnames = new  string[] { "java . nio .  direct byte buffer" "java . nio .  direct byte bufferr" "java . nio .  direct char bufferrs" "java . nio .  direct char bufferru" "java . nio .  direct char buffers" "java . nio .  direct char bufferu" "java . nio .  direct double bufferrs" "java . nio .  direct double bufferru" "java . nio .  direct double buffers" "java . nio .  direct double bufferu" "java . nio .  direct float bufferrs" "java . nio .  direct float bufferru" "java . nio .  direct float buffers" "java . nio .  direct float bufferu" "java . nio .  direct int bufferrs" "java . nio .  direct int bufferru" "java . nio .  direct int buffers" "java . nio .  direct int bufferu" "java . nio .  direct long bufferrs" "java . nio .  direct long bufferru" "java . nio .  direct long buffers" "java . nio .  direct long bufferu" "java . nio .  direct short bufferrs" "java . nio .  direct short bufferru" "java . nio .  direct short buffers" "java . nio .  direct short bufferu" }  ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  byte buffer as char bufferb" "java . nio .  byte buffer as char bufferl" "java . nio .  byte buffer as char bufferrb" "java . nio .  byte buffer as char bufferrl" "java . nio .  byte buffer as double bufferb" "java . nio .  byte buffer as double bufferl" "java . nio .  byte buffer as double bufferrb" "java . nio .  byte buffer as double bufferrl" "java . nio .  byte buffer as float bufferb" "java . nio .  byte buffer as float bufferl" "java . nio .  byte buffer as float bufferrb" "java . nio .  byte buffer as float bufferrl" "java . nio .  byte buffer as int bufferb" "java . nio .  byte buffer as int bufferl" "java . nio .  byte buffer as int bufferrb" "java . nio .  byte buffer as int bufferrl" "java . nio .  byte buffer as long bufferb" "java . nio .  byte buffer as long bufferl" "java . nio .  byte buffer as long bufferrb" "java . nio .  byte buffer as long bufferrl" "java . nio .  byte buffer as short bufferb" "java . nio .  byte buffer as short bufferl" "java . nio .  byte buffer as short bufferrb" "java . nio .  byte buffer as short bufferrl" }  ;  final  string[] java version elements =  system . get property ( "java . version" )  . split ( "\\ . " )  ;  int index of early access suffix = java version elements[0] . last index of ( " - ea" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }  else  {  index of early access suffix = java version elements[0] . last index of ( " - internal" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }  else  {  index of early access suffix = java version elements[0] . last index of ( " -  ubuntu" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }   }   }  final int major  minor ;  if  ( java version elements . length  >  =  2 )   {  major =  integer . parse int ( java version elements[0] )  ;  int min ;  try  {  min =  integer . parse int ( java version elements[1] )  ;   }  catch  (   number format exception nfe )   {  min = 7 ;   }  minor = min ;   }  else  {  major = 1 ;  int min ;  try  {  min =  integer . parse int ( java version elements[0] )  ;   }  catch  (   number format exception nfe )   {  min = 7 ;   }  minor = min ;   }  final  string direct buffer attachment field name ;  if  ( minor  =  =  1 && major  <  =  6 )  direct buffer attachment field name = java14to16 direct buffer attachment field name ;  else direct buffer attachment field name = java17to19 direct buffer attachment field name ;  for  (  final  string direct buffer classname : direct buffer classnames )  attachment or byte buffer field name map . put ( direct buffer classname direct buffer attachment field name )  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " the  android  project" )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "byte buffer" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  byte buffer as char buffer" "java . nio .  byte buffer as double buffer" "java . nio .  byte buffer as float buffer" "java . nio .  byte buffer as int buffer" "java . nio .  byte buffer as long buffer" "java . nio .  byte buffer as short buffer" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "bb" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  char view buffer impl" "java . nio .  double view buffer impl" "java . nio .  float view buffer impl" "java . nio .  int view buffer impl" "java . nio .  long view buffer impl" "java . nio .  short view buffer impl" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . contains ( " apache" )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "byte buffer" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  char to byte buffer adapter" "java . nio .  double to byte buffer adapter" "java . nio .  float to byte buffer adapter" "java . nio .  int to byte buffer adapter" "java . nio .  long to byte buffer adapter" "java . nio .  short to byte buffer adapter" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {   }  else if  ( java vendor . contains ( "ibm" )  )   {   }   }  if  (  ! attachment or byte buffer field name map . is empty (  )  )   {  final  list <  string >  classnames to remove = new  array list <  >  (  )  ;  for  (  final  string classname : attachment or byte buffer field name map . key set (  )  )  try  {   class . for name ( classname )  ;   }  catch  (   class not found exception cnfe )   {  classnames to remove . add ( classname )  ;   }  for  (  final  string classname to remove : classnames to remove )  attachment or byte buffer field name map . remove ( classname to remove )  ;   }  attachment or byte buffer field map = new  hash map <  >  (  )  ;  if  (  ! attachment or byte buffer field name map . is empty (  )  )  for  (  final  entry <  string  string >  attachment or byte buffer field name entry : attachment or byte buffer field name map . entry set (  )  )   {  final  string classname = attachment or byte buffer field name entry . get key (  )  ;  final  string fieldname = attachment or byte buffer field name entry . get value (  )  ;  try  {  final  class <  ?  >  buffer class =  class . for name ( classname )  ;   field buffer field = null ;   class <  ?  >  buffer intermediary class = buffer class ;  final  list <  class <  ?  >  >  intermediary class without buffer list = new  array list <  >  (  )  ;  while  ( buffer intermediary class  !  =  null )   {  try  {  buffer field = buffer intermediary class . get declared field ( fieldname )  ;   }  catch  (   no such field exception nsfe )   {  if  (  ! buffer intermediary class . equals (  object . class )  &&  ! buffer intermediary class . equals (  buffer . class )  )  intermediary class without buffer list . add ( buffer intermediary class )  ;   }  buffer intermediary class = buffer intermediary class . get superclass (  )  ;   }  if  ( buffer field  =  =  null )   {  final  string super classes msg ;  if  ( intermediary class without buffer list . is empty (  )  )  super classes msg = "" ;  else if  ( intermediary class without buffer list . size (  )   =  =  1 )  super classes msg = " and in its super class "  +  intermediary class without buffer list . get ( 0 )  . get name (  )  ;  else  {  final  string builder builder = new  string builder (  )  ;  builder . append ( " and in its super classes" )  ;  int class index = 0 ;  for  (  final  class <  ?  >  intermediary class without buffer : intermediary class without buffer list )   {  builder . append ( ' ' )  ;  builder . append ( intermediary class without buffer . get name (  )  )  ;  if  ( class index  <  intermediary class without buffer list . size (  )   -  1 )  builder . append ( ' ' )  ;  class index +  +  ;   }  super classes msg = builder . to string (  )  ;   }  logger . warn ( " the field "  +  fieldname  +  " hasn't been found in the class " +  classname +  super classes msg )  ;   }  else  {  attachment or byte buffer field map . put ( buffer class buffer field )  ;   }   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  classname  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }   }  if  ( attachment or byte buffer field name map . is empty (  )  )   {  final  byte buffer sliced big endian read only direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . big   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  . as read only buffer (  )  ;  final  byte buffer sliced big endian read write direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . big   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  ;  final  char buffer big endian read only direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as char buffer (  )  ;  final  char buffer big endian read write direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as char buffer (  )  ;  final  double buffer big endian read only direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as double buffer (  )  ;  final  double buffer big endian read write direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as double buffer (  )  ;  final  float buffer big endian read only direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as float buffer (  )  ;  final  float buffer big endian read write direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as float buffer (  )  ;  final  int buffer big endian read only direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as int buffer (  )  ;  final  int buffer big endian read write direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as int buffer (  )  ;  final  long buffer big endian read only direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as long buffer (  )  ;  final  long buffer big endian read write direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as long buffer (  )  ;  final  short buffer big endian read only direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as short buffer (  )  ;  final  short buffer big endian read write direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as short buffer (  )  ;  final  byte buffer sliced little endian read only direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . little   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  . as read only buffer (  )  ;  final  byte buffer sliced little endian read write direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . little   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  ;  final  char buffer little endian read only direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as char buffer (  )  ;  final  char buffer little endian read write direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as char buffer (  )  ;  final  double buffer little endian read only direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as double buffer (  )  ;  final  double buffer little endian read write direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as double buffer (  )  ;  final  float buffer little endian read only direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as float buffer (  )  ;  final  float buffer little endian read write direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as float buffer (  )  ;  final  int buffer little endian read only direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as int buffer (  )  ;  final  int buffer little endian read write direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as int buffer (  )  ;  final  long buffer little endian read only direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as long buffer (  )  ;  final  long buffer little endian read write direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as long buffer (  )  ;  final  short buffer little endian read only direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as short buffer (  )  ;  final  short buffer little endian read write direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as short buffer (  )  ;  final  list <  buffer >  buffers = new  array list <  >  (  )  ;  buffers . add ( sliced big endian read only direct byte buffer )  ;  buffers . add ( sliced big endian read write direct byte buffer )  ;  buffers . add ( big endian read only direct char buffer )  ;  buffers . add ( big endian read write direct char buffer )  ;  buffers . add ( big endian read only direct double buffer )  ;  buffers . add ( big endian read write direct double buffer )  ;  buffers . add ( big endian read only direct float buffer )  ;  buffers . add ( big endian read write direct float buffer )  ;  buffers . add ( big endian read only direct int buffer )  ;  buffers . add ( big endian read write direct int buffer )  ;  buffers . add ( big endian read only direct long buffer )  ;  buffers . add ( big endian read write direct long buffer )  ;  buffers . add ( big endian read only direct short buffer )  ;  buffers . add ( big endian read write direct short buffer )  ;  buffers . add ( sliced little endian read only direct byte buffer )  ;  buffers . add ( sliced little endian read write direct byte buffer )  ;  buffers . add ( little endian read only direct char buffer )  ;  buffers . add ( little endian read write direct char buffer )  ;  buffers . add ( little endian read only direct double buffer )  ;  buffers . add ( little endian read write direct double buffer )  ;  buffers . add ( little endian read only direct float buffer )  ;  buffers . add ( little endian read write direct float buffer )  ;  buffers . add ( little endian read only direct int buffer )  ;  buffers . add ( little endian read write direct int buffer )  ;  buffers . add ( little endian read only direct long buffer )  ;  buffers . add ( little endian read write direct long buffer )  ;  buffers . add ( little endian read only direct short buffer )  ;  buffers . add ( little endian read write direct short buffer )  ;  for  (   buffer buffer : buffers )   {  final  class <  ?  >  buffer class = buffer . get class (  )  ;  if  (  ! attachment or byte buffer field map . contains key ( buffer class )  )   {   field buffer field = null ;   class <  ?  >  buffer intermediary class = buffer class ;  while  ( buffer intermediary class  !  =  null && buffer field  =  =  null )   {  for  (  final  field field : buffer intermediary class . get declared fields (  )  )   {  final boolean field was accessible = field . is accessible (  )  ;  try  {  field . set accessible ( true )  ;  final  object field value = field . get ( buffer )  ;  if  ( field value  !  =  null && field value instanceof  buffer )   {  buffer field = field ;  break ;   }   }  catch  (   illegal access exception iae )   {  logger . warn ( " cannot access the field "  +  field . get name (  )   +  " of the class " +  buffer intermediary class . get name (  )  iae )  ;   }  finally  {  field . set accessible ( field was accessible )  ;   }   }  buffer intermediary class = buffer intermediary class . get superclass (  )  ;   }  if  ( buffer field  !  =  null )  attachment or byte buffer field map . put ( buffer class buffer field )  ;   }   }  buffers to delete . add all ( buffers )  ;   }  deallocatable buffer class set = new  hash set <  >  (  )  ;  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  || java vendor . equals ( " the  android  project" )  )   {   class <  ?  >  direct byte buffer class = null ;  final  string direct byte buffer class name = "java . nio .  direct byte buffer" ;  try  {  direct byte buffer class =  class . for name ( direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( direct byte buffer class )  ;   }  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )   {   class <  ?  >  read only direct byte buffer class = null ;  final  string read only direct byte buffer class name = "java . nio .  direct byte buffer impl .  read only" ;  try  {  read only direct byte buffer class =  class . for name ( read only direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read only direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read only direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read only direct byte buffer class )  ;   class <  ?  >  read write direct byte buffer class = null ;  final  string read write direct byte buffer class name = "java . nio .  direct byte buffer impl .  read write" ;  try  {  read write direct byte buffer class =  class . for name ( read write direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read write direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read write direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read write direct byte buffer class )  ;   }  else if  ( java vendor . contains ( " apache" )  )   {   class <  ?  >  read only direct byte buffer class = null ;  final  string read only direct byte buffer class name = "java . nio .  read only direct byte buffer" ;  try  {  read only direct byte buffer class =  class . for name ( read only direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read only direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read only direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read only direct byte buffer class )  ;   class <  ?  >  read write direct byte buffer class = null ;  final  string read write direct byte buffer class name = "java . nio .  read write direct byte buffer" ;  try  {  read write direct byte buffer class =  class . for name ( read write direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read write direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read write direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read write direct byte buffer class )  ;   }  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {   }  else if  ( java vendor . contains ( "ibm" )  )   {   }  if  ( deallocatable buffer class set . is empty (  )  )   {  final  byte buffer dummy read write direct byte buffer =  byte buffer . allocate direct ( 1 )  ;  final  class <  ?  >  read write direct byte buffer class = dummy read write direct byte buffer . get class (  )  ;  deallocatable buffer class set . add ( read write direct byte buffer class )  ;  buffers to delete . add ( dummy read write direct byte buffer )  ;  final  byte buffer dummy read only direct byte buffer =  byte buffer . allocate direct ( 1 )  . as read only buffer (  )  ;  final  class <  ?  >  read only direct byte buffer class = dummy read only direct byte buffer . get class (  )  ;  deallocatable buffer class set . add ( read only direct byte buffer class )  ;  buffers to delete . add ( dummy read only direct byte buffer )  ;   }  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  )  deallocator = new  oracle sun open jdk deallocator (  )  ;  else if  ( java vendor . equals ( " the  android  project" )  )  deallocator = new  android deallocator (  )  ;  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )  deallocator = new  gnu classpath deallocator (  )  ;  else if  ( java vendor . contains ( " apache" )  )  deallocator = new  apache harmony deallocator (  )  ;  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {  deallocator = null ;   }  else if  ( java vendor . contains ( "ibm" )  )   {  deallocator = null ;   }  else deallocator = null ;  for  (  final  buffer buffer to delete : buffers to delete )  deallocate ( buffer to delete )  ;   }  
@ override public void   (  single observer <  ?  super  integer >  s2 )  {  throw new  illegal argument exception ( "original exception" )  ;   }  
double[]   (  )  throws  rrd exception  {  return fetch data . get values ( ds name )  ;   }  
int   (  )  {  return coefficients . length  -  1 ;   }  
@ override protected void   (  single observer <  ?  super  boolean >  s )  {  source . subscribe ( new  all subscriber < t >  ( s predicate )  )  ;   }  
public   ( jaxb context jc )  {  super ( jc )  ;   }  
public boolean   (  )  {  return decoder . dtmf detected (  )  ;   }  
public  optional <  column mapper <  ?  >  >    (  type type )  {  return get config (  column mappers . class )  . find for ( type )  ;   }  
protected  string   (  )  {  return auth   realm ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   observable <  integer >  source =  observable . create ( new  observable on subscribe <  integer >  (  )  {  @ override public void subscribe (   observable
@ test public void   (  )  {  final  publish subject <  integer >  ps1 =  publish subject . create (  )  ;  final  publish subject <  integer >  ps2 =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  ( 
  (  string .  .  .  values )  {  this . values = values ;  this . thread pool =  executors . new cached thread pool (  )  ;   }  
@ test public void   (  )  {   atomic integer generateda = new  atomic integer (  )  ;   atomic integer generatedb = new  atomic integer (  )  ;   flowable <  integer >  o1 = create infinite flowable ( generateda )  ;   flowable <  integer >  o2 = create 
@ test public void   (  )  {   async processor <  string >  processor =  async processor . create (  )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  ( o
@ test public void   (  )  {   test helper . check disposed (  flowable . generate ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  bi consumer <  object  emitter <  object >  >  ( 
@ override public boolean   (  string username  string authenid )  {  boolean authorized = false ;   string user user = username ;   string user realm = null ;   string authen user = authenid ;   string authen realm = null ;  if  ( username . contains ( "
@ override protected void   ( final  byte buffer buffer )  {  buffer . put (  ( byte ) 1 )  ;  buffer . put int ( 1 )  ;  buffer . put (  ( byte )  ( 0xff & 1 )  )  ;  buffer . put (  ( byte )  ( 0xff & 5 )  )  ;  buffer . put (  ( byte )  ( 0xff & 5 )  )
public void   (  print stream s  number format number format )  {  s . print ( "filename  =  \"" )  ;  s . print ( name )  ;  s . println ( "\"" )  ;  s . print ( "rrd   version  =  \"" )  ;  s . print ( header . version )  ;  s . println ( "\"" )  ;  s . print ( "step  =  " )  ;  s . println ( header . pdp step )  ;  s . print ( "last   update  =  " )  ;  s . println ( last update . get time (  )   /  1000 )  ;  for  (  iterator <  data source >  i = data sources . iterator (  )  ;  i . has next (  )  ;   )   {   data source ds = i . next (  )  ;  ds . print info ( s number format )  ;   }  int index = 0 ;  for  (  iterator <  archive >  i = archives . iterator (  )  ;  i . has next (  )  ;   )   {   archive archive = i . next (  )  ;  archive . print info ( s number format index +  +  )  ;   }   }  
@ benchmark public void   (  blackhole bh )  {  nbp range . subscribe ( new  perf observer ( bh )  )  ;   }  
private   (  )  {  super (  )  ;  for  ( int i = 0 ;  i  <  pool   size ;  i +  +  )   {  sax reader xml reader = new sax reader (  )  ;  xml reader . set encoding ( "utf - 8" )  ;  xml readers . add ( xml reader )  ;   }  database contains privacy lists = new  atomic boolean ( false )  ;  load database contains privacy lists (  )  ;   }  
public boolean   (  client app app  string[] args )  {  if  (    log . should log (  log . info )  )     log . info ( " client "  +  app . get display name (  )   +  " added" )  ;   string[] old =    clients . put if absent ( app args )  ;  if  ( old  !  =  null )  throw new  illegal argument exception ( "already added" )  ;  try  {  app . startup (  )  ;  return true ;   }  catch  (   throwable t )   {     clients . remove ( app )  ;     log . error ( " client "  +  app  +  " failed to start" t )  ;  return false ;   }   }  
public  string   (  http servlet request request  string body )  {   string builder resp = new  string builder ( "" )  ;  try  {  resp = resp . append (  request util . servlet request to xml ( request body )  )  ;   }  catch  (  io exception|jaxb exception e )   {  log . trace ( "" e )  ;   }  return resp . to string (  )  ;   }  
@ suppress warnings ( "rawtypes" )  @ test public void   (  )  {  try  {   rx java plugins . set on flowable assembly ( new  function <  flowable  flowable >  (  )  {  @ override public  flowable apply (   flowable t )  {  return new  flowable range ( 1 2
@ override public boolean   (  object object )  {  if  ( this  =  =  object )   {  return true ;   }  if  ( object  !  =  null && object instanceof  user )   {  return username . equals (  (  (  user ) object )  . get username (  )  )  ;   }  else  {  ret
@ override public t   ( long timeout  time unit unit )  throws  interrupted exception   execution exception   timeout exception  {  if  ( get count (  )   !  =  0 )   {   blocking helper . verify non blocking (  )  ;  if  (  ! await ( timeout unit )  )   
@ test public void   (  )  {   completable . create ( new  completable on subscribe (  )  {  @ override public void subscribe (   completable emitter e )  throws  exception  {  try  {  e . on error ( new io exception (  )  )  ;  fail ( " should have throw
public   (  string name  channel handler < t >  channel handler )  {  this . name = name ;  this . channel handler = channel handler ;  executor = new  thread pool executor ( 1 8 15  time unit . seconds new  linked blocking queue <  runnable >  (  )  )  ;   }  
@ override public boolean   (  )  {  return io session . get filter chain (  )  . contains ( tls   filter   name )  ;   }  
public static  string   ( int level )  {  switch  ( level )   {  case debug: return str   debug ;  case info: return str   info ;  case warn: return str   warn ;  case error: return str   error ;  case crit: return str   crit ;   }  return  ( level  >  crit  ?  str   crit : str   debug )  ;   }  
public  string   (  )  {  return body ;   }  
protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;   ;  reader . get file header (  )  . set sort order ( sort   order . get sort order (  )  )  ;  final sam file writer writer = new sam file writer factory (  )  . makesam orbam writer ( reader . get file header (  )  false output )  ;  writer . set progress logger ( new  progress logger ( log  ( int ) 1e7 " wrote" "records from a sorting collection" )  )  ;  final  progress logger progress = new  progress logger ( log  ( int ) 1e7 " read" )  ;  for  (  final sam record rec : reader )   {  writer . add alignment ( rec )  ;  progress . record ( rec )  ;   }  log . info ( " finished reading inputs  merging and writing to output now . " )  ;   closer util . close ( reader )  ;  writer . close (  )  ;  return 0 ;   }  
@ override protected void   (  handle handle )  {  handle . execute ( "create table something  ( id serial  name varchar ( 50 )   create   time timestamp default now (  )  ) " )  ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  throwable e )  {  this . error = e ;  for  (   cache disposable < t >  d : observers . get and set ( terminated )  )   {  if  (  ! d . is disposed (  )  )   {  d . actual . on error ( e )  ;
@ test public void   (  )  {  final  replay processor <  integer >  source =  replay processor . create with time ( 1  time unit . minutes  schedulers . single (  )  )  ;  source . on complete (  )  ;  source . test ( 0 )  . assert result (  )  ;   }  
public static  session event   (  session session )  {  return new  session event ( session session   connect null )  ;   }  
@ check return value @ non null public final  < r >  parallel flowable < r >    ( @ non null  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper int prefetch boolean till the end )  {   object helper . require non null ( mapper "ma
@ override public boolean   (  string hostname  destination d  properties options )  {  if  (    services . is empty (  )  )  return false ;  boolean rv =    services . get (    services . size (  )   -  1 )  . put if absent ( hostname d options )  ;  if 
public void   ( byte[] dest )  {  long to byte array ( m   lcbciv dest 0 )  ;   }  
public void   ( ntcp connection con )  {  synchronized  (    pending connections )   {     read after live . remove ( con )  ;     pending connections . remove ( con )  ;     pending connections . notify (  )  ;   }   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   completable . complete (  )  . do finally ( new  action (  )  {  @ override public void run (  )  throws  exception  {  throw new  test excep
public static  < t >  collector < t  ?   optional < t >  >    (  )  {  return  optional collectors . to optional (  optional::absent  optional::of )  ;   }  
public void   (  )  {   connection con = null ;   prepared statement pstmt = null ;  if  ( history days  >  0 )   {  final  date delete before ;  delete before = new  date (  system . current time millis (  )   -  history days * 24l * 60l* 60l* 1000l )  ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( delete   old   user   status   history )  ;  pstmt . set string ( 1  string utils . date to millis ( delete before )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( " unable to delete old user status history" e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }   }  
@ override public  long   (  long v )  throws  exception  {  try  {   thread . sleep ( 3000 )  ;   }  catch  (   interrupted exception ex )   {  interrupted . set ( true )  ;   }  return v ;   }  
public void   ( int boot id )  {  set header ( http . bootid   upnp   org boot id )  ;   }  
@ override public void   (  throwable t )  {  if  ( error  =  =  null )   {  error = t ;  for  (  ;   ;   )   {   disposable a = s . get (  )  ;  if  ( a  =  =  this || a  =  =   disposable helper . disposed )   {   rx java plugins . on error ( t )  ;  re
public boolean   (  )  {  return    allow zero hop ;   }  
public void   (  string type )  {     type =  ( type  !  =  null  ?  type . trim (  )  : null )  ;   }  
public   ( final double length final int observed unique umis final int inferred unique umis final int observed base errors final int duplicate sets without umi final int duplicate sets with umi final double effective length of inferred umis final double effective length of observed umis final double estimated base quality of umis final double percent umi withn )  {  mean   umi   length = length ;  observed   unique   umis = observed unique umis ;  inferred   unique   umis = inferred unique umis ;  observed   base   errors = observed base errors ;  duplicate   sets   ignoring   umi = duplicate sets without umi ;  duplicate   sets   with   umi = duplicate sets with umi ;  inferred   umi   entropy = effective length of inferred umis ;  observed   umi   entropy = effective length of observed umis ;  umi   base   qualities = estimated base quality of umis ;  pct   umi   with   n = percent umi withn ;   }  
@ override public void   (  )  {  get room (  )  . update configuration ( room )  ;   }  
protected  kademlia network database facade   (  )  {  return    facade ;   }  
@ override public void   (  loader <  cursor >  loader )  {  adapter . swap cursor ( null )  ;   }  
@ test public void   (  )  {   unicast processor <  integer >  ap =  unicast processor . create (  )  ;  ap . on next ( 1 )  ;  ap . on complete (  )  ;   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;  ap . 
@ test public void   (  )  {  assert same (  observable . empty (  )   observable .  <  object > empty (  )  . switch map ( new  function <  object  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   o
public   (  timer task task )  {  this . task = task ;   }  
public  string   (  )  {  return get device node (  )  . get node value ( presentationurl )  ;   }  
@ test public void   (  )  throws  exception  {  final  file output dict =  file . create temp file ( " create sequence dictionary test . " " . dict" )  ;  output dict . delete (  )  ;  output dict . delete on exit (  )  ;  final  string[] argv =  { "refe
public boolean   (  )  {  return  ( cpuid . getedxcpu flags (  )  &  ( 1  <  <  25 )  )   !  =  0 ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on error return item ( null )  ;   }  
public  node affiliate   (  )  {  return node . get affiliate ( get owner (  )  )  ;   }  
public synchronized void   (  )  {  if  (    pumper . is alive (  )  )  return ;  if  (    log . should log (  log . warn )  )     log . warn ( " starting ntcp transport listening" )  ;  start it (  )  ;   router address addr = configure local address (  )  ;  int port ;  if  ( addr  !  =  null )  port = addr . get port (  )  ;  else port =    ssu port ;   router address my address = bind address ( port )  ;  if  ( my address  !  =  null )   {  replace address ( my address )  ;   }  else if  ( addr  !  =  null )   {  replace address ( addr )  ;   }  else if  ( port  >  0 )   {  for  (   inet address ia : get saved local addresses (  )  )   {   ordered properties props = new  ordered properties (  )  ;  props . set property (  router address . prop   host ia . get host address (  )  )  ;  props . set property (  router address . prop   port  integer . to string ( port )  )  ;  int cost = get default cost ( ia instanceof  inet6 address )  ;  my address = new  router address ( style props cost )  ;  replace address ( my address )  ;   }   }   }  
@ override public void   (  )  {  request ( 2 )  ;   }  
public void   (  device dev )  {   string udn = dev . getudn (  )  ;  if  (    log . should log (  log . warn )  )     log . warn ( "up&p device removed : "  +  dev . get friendly name (  )   +  " udn: " +  udn )  ;   forward port callback fpc = null ;   map <  forward port  forward port status >  remove map = null ;  synchronized  ( lock )   {  if  ( udn  !  =  null )     otherud ns . remove ( udn )  ;  else    otherud ns . remove ( " ?  ?  ? " )  ;  if  (    router  =  =  null )  return ;   string type = dev . get device type (  )  ;  if  (  ( router   device . equals ( type )  || router   device   2 . equals ( type )  )  && dev . is root device (  )  && string equals (    router . get friendly name (  )  dev . get friendly name (  )  ) && string equals (    router . getudn (  )  udn )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( "up&p igd device removed : "  +  dev . get friendly name (  )  )  ;     otherud ns . clear (  )  ;     router = null ;     service = null ;     event vars . clear (  )  ;     service lacksapm = false ;  if  (  ! ports forwarded . is empty (  )  )   {  fpc = forward callback ;  remove map = new  hash map <  forward port  forward port status >  ( ports forwarded . size (  )  )  ;  for  (   forward port port : ports forwarded )   {   forward port status fps = new  forward port status (  forward port status . definite   failure "u pnp device removed" port . port number )  ;   }   }  ports forwarded . clear (  )  ;   }   }  if  ( fpc  !  =  null )   {  fpc . port forward status ( remove map )  ;   }   }  
public   ( final  string barcode final  string barcode name final  integer lane number )  {  this . tile to cluster histogram = new  histogram <  >  (  )  ;  this . tile to pf cluster histogram = new  histogram <  >  (  )  ;  this . metrics = new  illumina basecalling metrics (  )  ;  this . metrics . molecular   barcode   sequence   1 = barcode ;  this . metrics . molecular   barcode   name = barcode name ;  this . metrics . lane =  integer . to string ( lane number )  ;   }  
@ test public void   (  )  throws  exception  {   mock http servlet request mock request = new  mock http servlet request (  )  ;   mock http servlet response mock response = new  mock http servlet response (  )  ;   filter chain mock filter chain = mock 
public void   ( boolean val )  {  if  ( val )     boolean options . add ( i2p tunnel server . prop   unique   local )  ;  else    boolean options . remove ( i2p tunnel server . prop   unique   local )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ request variable lease set message: " )  ;  buf . append ( "\n\t session id: " )  . append ( get session id (  )  )  ;  buf . append ( "\n\t tunnels:
@ test public void   (  )  {  final  replay processor <  integer >  source =  replay processor . create (  )  ;  source . on complete (  )  ;  source . test ( 0 )  . assert result (  )  ;   }  
@ override public  file   (  )  {  return reference   sequence ;   }  
public synchronized double   (  )  {  long duration = now (  )   -     start ;  if  (  ( duration  <  =  0 )  ||  (    count  <  =  0 )  )  return  double . max   value ;  return duration  /   ( double )    count ;   }  
  (  single observer <  ?  super u >  actual u collection )  {  this . actual = actual ;  this . collection = collection ;   }  
@ override public  string   (  )  {  return name ;   }  
public boolean   (  )  {  return ssl enabled ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c =  completable . merge array delay error ( error . completable )  ;  c . blocking await (  )  ;   }  
public void   (  session listener session listener )  {  session listeners . add ( session listener )  ;   }  
@ test public void   (  )  {  assert equals ( 1  single . just ( 1 )  . subscribe with ( new  observer impl (  )  )  . value )  ;   }  
@ test public void   (  )  {   flowable . concat delay error (  flowable . just (  flowable . just ( 1 )   flowable . just ( 2 )   flowable . just ( 3 )   flowable . just ( 4 )  )  )  . test (  )  . assert result ( 1 2 3 4 )  ;   }  
public   (  connection connection )  {  super ( connection )  ;   }  
public i2p session   (  )  {  return    session ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ host lookup message: " )  ;  buf . append ( "\n\t" )  . append (    session id )  ;  buf . append ( "\n\t reqid: " )  . append (    reqid )  ;  buf .
public static boolean   (  )  {  return fetch size supported ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return true ;   }  
public void   (  string group name )  {  this . group name = group name ;   }  
@ override public boolean   (  object o )  {  if  ( o instanceof  pop3 folder )   {  return  (  (  pop3 folder ) o )  . m name . equals ( m name )  ;   }  return super . equals ( o )  ;   }  
private void   (  set <  forward port >  ports to forward now )  {  if  (    service lacksapm )   {  if  (    log . should log (  log . warn )  )     log . warn ( "u pnp device does not support port forwarding" )  ;   map <  forward port  forward port status >  map = new  hash map <  forward port  forward port status >  ( ports to forward now . size (  )  )  ;  for  (   forward port port : ports to forward now )   {   forward port status fps = new  forward port status (  forward port status . definite   failure "u pnp device does not support port forwarding" port . port number )  ;  map . put ( port fps )  ;   }  forward callback . port forward status ( map )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " starting thread to forward "  +  ports to forward now . size (  )   +  " ports" )  ;   thread t = new i2p thread ( new  register ports thread ( ports to forward now )  )  ;  t . set name ( "u pnp  port  opener "  +        id . increment and get (  )  )  ;  t . set daemon ( true )  ;  t . start (  )  ;   }  
void   ( long new index )  {  producer index . lazy set ( new index )  ;   }  
@ test public void   (  )  throws  exception  {  h . execute ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  ;  h . execute ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  ;   list <  map <  string  object >  >  r = 
@ override public void   (  certificate store store )  {  restart needed = true ;   }  
@ test public void   (  )  {   test scheduler sch = new  test scheduler (  )  ;   test subscriber <  list <  object >  >  ts =  flowable . never (  )  . buffer ( 1  time unit . milliseconds sch )  . test ( 1l true )  ;  sch . advance time by ( 1  time uni
public static  garlic message   (  router context ctx i2np message m  session key encrypt key  session tag encrypt tag )  {   payload garlic config payload = new  payload garlic config (  )  ;  payload . set certificate (  certificate . null   cert )  ;  payload . set id ( ctx . random (  )  . next long ( i2np message . max   id   value )  )  ;  payload . set payload ( m )  ;  payload . set delivery instructions (  delivery instructions . local )  ;  payload . set expiration ( m . get message expiration (  )  )  ;   garlic message msg =  garlic message builder . build message ( ctx payload null null null encrypt key encrypt tag )  ;  return msg ;   }  
@ before public void   (  )  {  stream1 = mock (  output stream . class )  ;  stream2 = mock (  output stream . class )  ;  stream3 = mock (  output stream . class )  ;  splitter = new  output stream splitter ( stream1 stream2 stream3 )  ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   string value = h . in transaction ( handle  -  >   {  handle . execute ( "insert into something  ( id  name )  values  ( 1  ' brian' ) " )  ;  return handle . cre
@ test public void   (  )  {   flowable <  integer >  source =  flowable . merge delay error (  flowable . just (  flowable . just ( 1 )  )  )  ;   test subscriber <  integer >  subscriber = new  test subscriber <  integer >  ( 0l )  ;  source . subscribe
@ xml element ( name = "message" )  public  string   (  )  {  return message ;   }  
public  string   (  )  {  return uri ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    ( t default item )  {   object helper . require non null ( default item "default item is null" )  ;  return switch if empty ( just ( default item )  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    (  callable <  ?  extends  observable source <  ?  extends t >  >  supplier )  {   object helper . require non null ( supplier "supplier is n
@ test public void   (  )  {   observable . merge (  observable . just (  observable . just ( 1 )  )  )  . test (  )  . assert result ( 1 )  ;   }  
public void   (  )  {     is running = true ;  while  (    is running &&  !    manager . is shutdown (  )  )   {  try  {  handle inbound request (  )  ;   }  catch  (   runtime exception e )   {     log . log (  log . crit "b0rked in the tunnel handler" e )  ;   }   }  if  (    log . should log (  log . warn )  )     log . warn ( " done handling" )  ;     is running = false ;   }  
public   ( long id  offset date time created on )  {  this . id = id ;  this . created on = created on ;   }  
private boolean   (  )  {  return get context (  )  . get property ( prop   publish   unreachable default   publish   unreachable )  ;   }  
@ override public void   (  )  {  dismiss check settings fragment (  )  ;  final  account server base fragment f = get account server fragment (  )  ;  if  ( f  !  =  null )   {  f . save settings (  )  ;   }   }  
  (  equal coordinator helper parent int prefetch )  {  this . parent = parent ;  this . limit = prefetch  -   ( prefetch  >  >  2 )  ;  this . prefetch = prefetch ;   }  
public   (  message digest digest )  {  this . digest = digest ;   }  
private static  string   ( boolean disable )  {  if  ( disable )  return "  /  " ;  return  ( "&thinsp ;  / &thinsp ; " )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  composite disposable cd = new  composite disposable (  )  ;  final  disposable d1 =  disposables . empty (  )  ;  cd . add ( d1 )  ;   r
@ override public void   (  )  throws io exception  {  is . reset (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . switch if empty ( null )  ;   }  
public long   (  )  {  return poison   id ;   }  
public int   (  )  {  return fusion mode ;   }  
@ test public void   (  )  {  final  atomic boolean did run on terminate = new  atomic boolean (  )  ;   unicast subject <  integer >  us =  unicast subject . create (  observable . buffer size (  )  new  runnable (  )  {  @ override public void run (  ) 
@ test public void   (  )  {   flowable . from array ( new  integer[] { 1 2 3 4 5 }  )  . filter (  functions . always true (  )  )  . subscribe with ( new  test subscriber <  integer >  ( 5l )  {  @ override public void on next (   integer t )  {  super 
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 3 )  ;   single <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1  <  1 ;   }   }   )  
@ override public void   ( u t )  {  if  ( fusion mode  =  =   queue disposable . none )   {  parent . try emit ( t this )  ;   }  else  {  parent . drain (  )  ;   }   }  
@ override public void   (  )  {  if  ( m is processing )   {  return ;   }  if  ( m state  =  =  state   names )   {  finish (  )  ;   }  else  {  super . on back pressed (  )  ;   }  reset state from current fragment (  )  ;   }  
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
public  group   (  string name boolean force lookup )  throws  group not found exception  {   group group = null ;  if  ( force lookup )   {  group cache . remove ( name )  ;   }  else  {  group = group cache . get ( name )  ;   }  if  ( group  =  =  null )   {  synchronized  ( name . intern (  )  )   {  group = group cache . get ( name )  ;  if  ( group  =  =  null )   {  group = provider . get group ( name )  ;  group cache . put ( name group )  ;   }   }   }  return group ;   }  
public long   (  )  {  return time ;   }  
public int   (  )  {  return    max total conns per hour ;   }  
public static void   (  )  {  clustered cache factory strategy . stop cluster (  )  ;  clustered cache factory strategy = null ;  cache factory strategy = local cache factory strategy ;   }  
@ override public void   ( final  disposable d )  {  try  {  on subscribe . accept ( d )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  d . dispose (  )  ;  this . d =  disposable helper . disposed ;   empty disposable . er
void   (  collection < jid >  users )  {  jid userjid = get userjid (  )  ;  for  (  jid user : users )   {  if  ( userjid . equals ( user )  )   {  continue ;   }   roster item item ;  try  {  item = get roster item ( user )  ;  broadcast ( item true )  ;   }  catch  (   user not found exception e )   {   log . warn ( " unexpected error while broadcasting shared group rename for user ' {  } ' ! " user e )  ;   }   }   }  
  (  subscriber <  ?  super t >  actual long remaining )  {  this . actual = actual ;  this . remaining = remaining ;  lazy set ( remaining )  ;   }  
@ override public void   (  )  {  r p ;  try  {  p =  object helper . require non null ( on complete supplier . call (  )  " the on complete publisher returned is null" )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  actual 
public synchronized double   (  )  {  return    avg interval ;   }  
public void   (  string entity )  {  this . entity = entity ;   }  
@ test public void   (  )  {   replay subject <  integer >  rp =  replay subject . create with time and size ( 1  time unit . days  schedulers . single (  )  2 )  ;  rp . on next ( 1 )  ;  rp . on next ( 2 )  ;  rp . on next ( 3 )  ;  rp . on next ( 4 )  
public synchronized int   (  )  {  return    rtt deviation ;   }  
private void   (  )  throws io exception  {  done (  )  ;  in = get input stream ( path )  ;  int bytes available = 0 ;  try  {  bytes available = in . available (  )  ;   }  catch  (  io exception ioe )   {  throw new io exception ( "available (  )  failed "  +  path )  ;   }  if  ( bytes available  <  audio   file   header   size )   {  throw new io exception ( "audiofile "  +  path  +  " is too small " +  bytes available )  ;   }  byte[] audio file header = new byte[audio   file   header   size] ;  try  {  in . read ( audio file header 0 audio   file   header   size )  ;   }  catch  (   exception e )   {  throw new io exception ( "error reading "  +  path  +  " " +  e . get message (  )  )  ;   }  encoding = audio file header[15] ;  channels = audio file header[23] ;  if  ( audio file header[0]  !  =  0x2e || audio file header[1]  !  =  0x73 || audio file header[2]  !  =  0x6e || audio file header[3]  !  =  0x64 ||  ( encoding  !  =  ulaw && encoding  !  =  linear )  || channels  >  16 )   {  throw new io exception ( "bad audio file header "  +  path )  ;   }  sample rate =  (  (  (  ( int ) audio file header[16] )   <  <  24 )  & 0xff000000 )   +   (  (  (  ( int ) audio file header[17] )   <  <  16 )  & 0x00ff0000 )   +   (  (  (  ( int ) audio file header[18] )   <  <  8 )  & 0x0000ff00 )  +   (  (  ( int ) audio file header[19] )  & 0xff )  ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " audio file is "  +  path  +  " .   resource is " +   dot au audio source . class . get resource ( path )  +  " .  size " +  in . available (  )  +  " encoding " +  encoding +  " channels " +  channels +  " sample rate " +  sample rate )  ;   }  try  {  bytes available = in . available (  )  ;  int hdr   size =  (  ( audio file header[4]  <  <  24 )  & 0xff0000 )  |  (  ( audio file header[5]  <  <  16 )  & 0xff0000 )  |  (  ( audio file header[6]  <  <  8 )  & 0xff00 ) |  ( audio file header[7] & 0xff )  ;  if  ( hdr   size  >  audio   file   header   size )   {  int excess   hdr   size = hdr   size  -  audio   file   header   size ;  byte[] data = new byte[excess   hdr   size] ;  in . read ( data 0 excess   hdr   size )  ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " reading excess header "  +  " hdr size "  +  hdr   size  +  " excess " +  excess   hdr   size )  ;   }   }   }  catch  (   exception e )   {  throw new io exception ( " can't read data !  "  +  path  +  " " +  e . get message (  )  )  ;   }   }  
@ override public void   (  )  {  ts1 . dispose (  )  ;   }  
public static short[]   ( int[] int data )  {  short[] short data = new short[int data . length] ;  for  ( int i = 0 ;  i  <  int data . length ;  i +  +  )   {  short data[i] =  ( short ) int data[i] ;   }  return short data ;   }  
@ override public  string   (  string username )  throws  user not found exception  {  return get user info ( username )  . stored key ;   }  
public void   ( ssdp packet ssdp packet )  {  int listener size = device search listener list . size (  )  ;  for  ( int n = 0 ;  n  <  listener size ;  n +  +  )   {   search listener listener =  (  search listener ) device search listener list . get ( n )  ;  listener . device search received ( ssdp packet )  ;   }   }  
public long   (  )  {  return idle time ;   }  
@ test public void   (  )  {   single <  boolean >  observable =  flowable .  <  string > empty (  )  . contains ( "a" )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  observable . subscribe ( observer )  ;  ver
@ test public void   (  )  {  final  atomic boolean is unsubscribed = new  atomic boolean (  )  ;   observable . switch on next (  observable . unsafe create ( new  observable source <  observable <  integer >  >  (  )  {  @ override public void subscribe
public static  insert quick response dialog   (  fragment callback fragment  account account )  {  final  insert quick response dialog dialog = new  insert quick response dialog (  )  ;  if  ( callback fragment  !  =  null )   {  if  (  !  ( callback fragment instanceof  callback )  )   {  throw new  class cast exception ( callback fragment . to string (  )   +  " must implement  callback" )  ;   }  dialog . set target fragment ( callback fragment 0 )  ;   }   bundle args = new  bundle (  )  ;  args . put parcelable ( account   key account )  ;  dialog . set arguments ( args )  ;  return dialog ;   }  
public   ( soap response soap res )  {  super ( soap res )  ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;  dispose resource after (  )  ;   }  
public byte[]   (  )  throws  invalidb encoding exception  {  try  {  return  ( byte[] ) value ;   }  catch  (   class cast exception cce )   {  throw new  invalidb encoding exception ( cce . to string (  )  )  ;   }   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   crash dummy cd = new  crash dummy ( true 1 false false false false )  ;   safe subscriber <  object >  so = cd . to safe (  )  ;  so . on next 
private final  session key   (  big integer my private value  big integer public peer value )  {  long start =  system . current time millis (  )  ;   session key key = new  session key (  )  ;   big integer exchanged key = public peer value . mod pow ( my private value  crypto constants . elgp )  ;  byte buf[] = exchanged key . to byte array (  )  ;  byte val[] = new byte[ session key . keysize   bytes] ;  if  ( buf . length  <  2 *  session key . keysize   bytes )   {   system . arraycopy ( buf 0 val 0  math . min ( buf . length  session key . keysize   bytes )  )  ;  byte remaining[] = new byte[ session key . keysize   bytes] ;  sha256 generator . get instance (  )  . calculate hash ( buf 0 buf . length remaining 0 )  ;     extra exchanged bytes . set data ( remaining )  ;   }  else  {   system . arraycopy ( buf 0 val 0  session key . keysize   bytes )  ;   random source . get instance (  )  . harvester (  )  . feed entropy ( "dh" buf val . length buf . length  -  val . length )  ;  byte remaining[] = new byte[buf . length  -  val . length] ;   system . arraycopy ( buf val . length remaining 0 remaining . length )  ;     extra exchanged bytes . set data ( remaining )  ;   }  key . set data ( val )  ;  long end =  system . current time millis (  )  ;  long diff = end  -  start ;  i2p app context . get global context (  )  . stat manager (  )  . add rate data ( "crypto . dh calculate session time" diff )  ;  return key ;   }  
protected  cycle illumina file map   (  )  {  final  cycle illumina file map cycled map = new  cycle illumina file map (  )  ;  final  file lane dir = base ;  final  file[] temp cycle dirs ;  temp cycle dirs = io util . get files matching regexp ( lane dir  illumina file util . cycle   subdirectory   pattern )  ;  if  ( temp cycle dirs  =  =  null || temp cycle dirs . length  =  =  0 )   {  return cycled map ;   }  for  (  final  file temp cycle dir : temp cycle dirs )   {  detected cycles . add ( get cycle from dir ( temp cycle dir )  )  ;   }  final  set <  integer >  unique tiles = new  hash set <  integer >  (  )  ;  for  (  final  file cycle dir : temp cycle dirs )   {  final  illumina file map file map = get tiled files ( cycle dir match pattern )  ;  unique tiles . add all ( file map . key set (  )  )  ;  cycled map . put ( get cycle from dir ( cycle dir )  file map )  ;   }  this . tiles = new  array list <  >  ( unique tiles )  ;  return cycled map ;   }  
public static  context   (  context context )  throws  exception  {   mock content resolver resolver = new  mock content resolver (  )  ;  final  string filename prefix = "test . " ;   renaming delegating context target context wrapper = new  renaming delegating context ( new  mock context2 ( context )  context filename prefix )  ;  final  context provider context = new  my isolated context ( resolver target context wrapper context )  ;  provider context . get content resolver (  )  ;  final  email provider ep = new  email provider (  )  ;  ep . attach info ( provider context null )  ;  resolver . add provider (  email content . authority ep )  ;  final  attachment provider ap = new  attachment provider (  )  ;  ap . attach info ( provider context null )  ;  resolver . add provider (  attachment . attachment   provider   legacy   uri   prefix ap )  ;   content cache . invalidate all caches (  )  ;  return provider context ;   }  
  (  string .  .  .  values )  {  this . values = values ;   }  
@ override public void   ( t t )  {  if  ( fast enter (  )  )   {  for  (   unicast processor < t >  w : windows )   {  w . on next ( t )  ;   }  if  ( leave (  - 1 )   =  =  0 )   {  return ;   }   }  else  {  queue . offer ( t )  ;  if  (  ! enter (  ) 
public  string   (  )  {  return id ;   }  
@ override public  string   (  )  {  return "[ abuse reason: "  +     reason  +  "]" ;   }  
public  presence   (  )  {  return presence ;   }  
public int   (  )  {  return code ;   }  
@ override public  throwable   (  )  {  return subscribers . get (  )   =  =  terminated  ?  error : null ;   }  
@ override @ suppress warnings ( "unchecked" )  public boolean   ( boolean fix int width  skip levels < k v > [] prev levels )  {  bf . log . warn ( "  skip level at width "  +  width )  ;  bf . log . warn ( " levels "  +  this . levels . length )  ;  bf 
private void   ( final  string existing account name )  {  final  duplicate account dialog fragment dialog fragment =  duplicate account dialog fragment . new instance ( existing account name )  ;  dialog fragment . show ( get fragment manager (  )   duplicate account dialog fragment . tag )  ;   }  
public   (  )  {  super ( " rayo: xep 0327  -   accept" )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  final  single subject <  integer >  ms1 =  single subject . create (  )  ;  final  single subject <  integer >  ms2 =  single subject . create (  )  ;   t
public   (  transport buddy manager <  same time buddy >  manager  string uin  string nickname  string group )  {  super ( manager uin nickname null )  ;  if  ( group  !  =  null )   {  this . set groups (  arrays . as list ( group )  )  ;   }   }  
public long   (  )  {  return    running time ;   }  
@ test public void   (  )  {   list <  user >  users = handle . create query ( "select id  name from user order by id asc" )  . map ( new  user mapper (  )  )  . list (  )  ;  assert that ( users )  . has size ( 4 )  ;  assert that ( users . get ( 3 )  . 
@ override public boolean   (  )  {  return  log . is warn enabled (  )  ;   }  
public   (  router context context )  {     context = context ;     log = context . log manager (  )  . get log (  job queue . class )  ;     context . stat manager (  )  . create rate stat ( "job queue . ready jobs" " how many ready and waiting jobs there are ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . dropped jobs" " how many jobs do we drop due to insane overload ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . queued jobs" " how many scheduled jobs are there ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job run" " how long jobs take" " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job run slow" " how long jobs that take over a second take" " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create required rate stat ( "job queue . job lag" " job run delay  ( ms ) " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job wait" " how long does a job sit on the job queue ? " " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     ready jobs = new  linked blocking queue <  job >  (  )  ;     timed jobs = new  tree set <  job >  ( new  job comparator (  )  )  ;     job lock = new  object (  )  ;     queue runners = new  concurrent hash map <  integer  job queue runner >  ( runners )  ;     job stats = new  concurrent hash map <  string  job stats >  (  )  ;     pumper = new  queue pumper (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  @ experimental public final  observable < t >    ( @ non null  completable source other )  {   object helper . require non null ( other "other is null" )  ;  return  rx java plugins .
public   (  flowable < t >  source  bi function < t t t >  accumulator )  {  super ( source )  ;  this . accumulator = accumulator ;   }  
@ override public boolean   (  object o )  {  if  ( o  =  =  this )  return true ;  if  (  !  ( o instanceof  eddsa public key )  )  return false ;   eddsa public key pk =  (  eddsa public key ) o ;  return  arrays . equals (  abyte pk . get abyte (  )  )
  (  observer <  ?  super t >  actual  iterator <  ?  extends t >  it )  {  this . actual = actual ;  this . it = it ;   }  
@ override public void   (  subscription s )  {  s . cancel (  )  ;   }  
public  presence type   (  msn user status msn status )  {  if  ( msn status . equals (  msn user status . online )  )   {  return  presence type . available ;   }  else if  ( msn status . equals (  msn user status . away )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . be   right   back )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . busy )  )   {  return  presence type . dnd ;   }  else if  ( msn status . equals (  msn user status . idle )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . offline )  )   {  return  presence type . unavailable ;   }  else if  ( msn status . equals (  msn user status . on   the   phone )  )   {  return  presence type . dnd ;   }  else if  ( msn status . equals (  msn user status . out   to   lunch )  )   {  return  presence type . xa ;   }  else  {  return  presence type . unknown ;   }   }  
  (  async subject <  string >  subject )  {  this . subject = subject ;   }  
public static boolean   (  )  {  return bc   available ;   }  
private void   (  )  {     inbound queue . clear (  )  ;  for  ( int i = 0 ;  i  <     handlers . length ;  i +  +  )   {  udp packet poison = udp packet . acquire (    context false )  ;  poison . set message type ( type   poison )  ;     inbound queue . offer ( poison )  ;   }  for  ( int i = 1 ;  i  <  =  5 &&  !    inbound queue . is empty (  )  ;  i +  +  )   {  try  {   thread . sleep ( i * 50 )  ;   }  catch  (   interrupted exception ie )   {   }   }     inbound queue . clear (  )  ;   }  
private void   (  )  {   proxy credentials sip account = new  proxy credentials (  )  ;  try  {   string name = default proxy ;   string username =  jive globals . get property ( "voicebridge . default . proxy . username" "admin" )  ;   string sipusername =  jive globals . get property ( "voicebridge . default . proxy . sipusername" name )  ;   string authusername =  jive globals . get property ( "voicebridge . default . proxy . sipauthuser" null )  ;   string displayname =  jive globals . get property ( "voicebridge . default . proxy . sipdisplayname" name )  ;   string password =  jive globals . get property ( "voicebridge . default . proxy . sippassword" name )  ;   string server =  jive globals . get property ( "voicebridge . default . proxy . sipserver" )  ;   string stun server =  jive globals . get property ( "voicebridge . default . proxy . stunserver" server )  ;   string stun port =  jive globals . get property ( "voicebridge . default . proxy . stunport" )  ;   string voicemail =  jive globals . get property ( "voicebridge . default . proxy . voicemail" name )  ;   string outboundproxy =  jive globals . get property ( "voicebridge . default . proxy . outboundproxy" server )  ;  sip account . set name ( name )  ;  sip account . set xmpp user name ( username )  ;  sip account . set user name ( sipusername )  ;  sip account . set auth user name ( authusername )  ;  sip account . set user display ( displayname )  ;  sip account . set password ( password . to char array (  )  )  ;  sip account . set host ( server )  ;  sip account . set proxy ( outboundproxy )  ;  sip account . set realm ( server )  ;  sip extensions . put ( username sip account )  ;   inet address inet address =  inet address . get by name ( sip account . get host (  )  )  ;  registrars . add ( sip account . get host (  )  )  ;  registrations . add ( sip account )  ;   log . info (  string . format ( " voice bridge adding sip registration: %s with user %s host %s" sip account . get xmpp user name (  )  sip account . get user name (  )  sip account . get host (  )  )  )  ;   }  catch  (   exception e )   {   log . info ( "register with default proxy "  +  e )  ;   }   }  
public void   (  string domain )  {  validated domains . remove ( domain )  ;   session manager . get instance (  )  . unregister incoming server session ( domain this )  ;   }  
public  presence   (  )  {  return presence ;   }  
private int   (  uri uri  content values values boolean force sync )  {   context context = get context (  )  ;   message msg = get message from last segment ( uri )  ;  if  ( msg  =  =  null )  return 0 ;   mailbox mailbox =  mailbox . restore mailbox with id ( context msg . m mailbox key )  ;  if  ( mailbox  =  =  null )  return 0 ;   uri our base uri =  ( force sync || uploads to server ( context mailbox )  )   ?   message . synced   content   uri :  message . content   uri ;   uri our uri = convert to email provider uri ( uri our base uri true )  ;  if  ( our uri  =  =  null )  return 0 ;  if  ( values . contains key ( ui provider .  message operations . respond   column )  )   {  final  email service proxy service =  email service utils . get service for account ( context mailbox . m account key )  ;  try  {  service . send meeting response ( msg . m id values . get as integer ( ui provider .  message operations . respond   column )  )  ;  ui delete message ( uri )  ;   utility . show toast ( context r . string . confirm   response )  ;  notifyui conversation mailbox ( mailbox . m id )  ;   }  catch  (   remote exception e )   {   log utils . d ( tag " remote exception while sending meeting response" )  ;   }  return 1 ;   }  final  string operation = values . get as string ( ui provider .  conversation operations . operation   key )  ;  if  ( ui provider .  conversation operations . discard   drafts . equals ( operation )  || ui provider .  conversation operations . move   failed   to   drafts . equals ( operation )  )   {  ui delete message ( uri )  ;  return 1 ;   }   content values undo values = new  content values (  )  ;   content values our values = convert ui message values ( msg values )  ;  for  (   string column name : our values . key set (  )  )   {  if  ( column name . equals (  message columns . mailbox   key )  )   {  undo values . put (  message columns . mailbox   key msg . m mailbox key )  ;   }  else if  ( column name . equals (  message columns . flag   read )  )   {  undo values . put (  message columns . flag   read msg . m flag read )  ;   }  else if  ( column name . equals (  message columns . flag   seen )  )   {  undo values . put (  message columns . flag   seen msg . m flag seen )  ;   }  else if  ( column name . equals (  message columns . flag   favorite )  )   {  undo values . put (  message columns . flag   favorite msg . m flag favorite )  ;   }   }  if  ( undo values . size (  )   =  =  0 )   {  return  - 1 ;   }  final  boolean suppress undo = values . get as boolean ( ui provider .  conversation operations .  parameters . suppress   undo )  ;  if  ( suppress undo  =  =  null ||  ! suppress undo )   {  final  content provider operation op =  content provider operation . new update ( convert to email provider uri ( uri our base uri false )  )  . with values ( undo values )  . build (  )  ;  add to sequence ( uri op )  ;   }  return update ( our uri our values null null )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . sync |  queue fuseable . boundary )  ;   flowable . range ( 1 5 )  . do finally ( this )  . subscribe ( ts )  ;   subscriber fusion . asser
public void   (  )  {   log . info ( " freezing  go jara  maininterceptor . " )  ;  frozen = true ;   }  
@ override public void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  if  ( i  <  500 )   {  try  {   thread . sleep ( 1 )  ;   }  catch  (   interrupted exception e )   {  e . print stack trace ( 
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . just ( 1 )  . map ( null )  ;   }  
void   (  node child )  {   message message = new  message (  )  ;   element event = message . add child element ( "event" "http: /  / jabber . org / protocol / pubsub#event" )  ;   element item = event . add element ( "items" )  . add element ( "item" )  ;  item . add attribute ( "id" child . get nodeid (  )  )  ;  if  ( deliver payloads )   {  item . add ( child . get metadata form (  )  . get element (  )  )  ;   }  broadcast collection node event ( child message )  ;   }  
public static  conversation event   ( jid roomjid jid user  string new nickname  date date )  {   conversation event event = new  conversation event (  )  ;  event . type =  type . nickname changed ;  event . roomjid = roomjid ;  event . user = user ;  event . nickname = new nickname ;  event . date = date ;  return event ;   }  
public void   (  string username )  throws  service exception  {   user user = get and check user ( username )  ;  user manager . delete user ( user )  ;  roster manager . delete roster ( server . createjid ( username null )  )  ;   }  
public void   (  )  {     is running = false ;  if  (    snark  !  =  null )   {   }   }  
public  set <  rate >    (  string specs )  {  if  ( specs  =  =  null )  return  collections . empty set (  )  ;   string tokenizer tok = new  string tokenizer ( specs " " )  ;   set <  rate >  rv = new  hash set <  rate >  (  )  ;  while  ( tok . has more tokens (  )  )   {   string spec = tok . next token (  )  ;  int split = spec . last index of ( ' . ' )  ;  if  (  ( split  <  =  0 )  ||  ( split  +  1  >  =  spec . length (  )  )  )  continue ;   string name = spec . substring ( 0 split )  ;   string per = spec . substring ( split  +  1 )  ;  long period =  - 1 ;  try  {  period =  long . parse long ( per )  ;   rate stat rs =    context . stat manager (  )  . get rate ( name )  ;  if  ( rs  !  =  null )   {   rate r = rs . get rate ( period )  ;  if  ( r  !  =  null )  rv . add ( r )  ;   }   }  catch  (   number format exception nfe )   {   }   }  return rv ;   }  
public static  request url tokenizer   (  string request url  set <  string >  version ids )  {  if  ( version ids  =  =  null )   {  throw new  illegal argument exception ( "version ids must be provided ! " )  ;   }   string service root href = "" ;   string version id = "" ;   string resource = "" ;   matcher matcher ;  matcher = service   root   href   pattern . matcher ( request url )  ;  if  ( matcher . find (  )  )   {  service root href = matcher . group ( 0 )  ;   }  boolean has version info = false ;  matcher = version   id   pattern . matcher ( request url )  ;  if  ( matcher . find (  )  && has version info ( matcher . group ( 1 )  version ids )  )   {  version id = matcher . group ( 1 )  ;  has version info = true ;   }  matcher = has version info  ?  resource   pattern . matcher ( request url )  : resource   without   version   pattern . matcher ( request url )  ;  if  ( matcher . find (  )  &&  ! " / " . equals ( matcher . group ( 1 )  )  )   {  resource = matcher . group ( 1 )  ;   }  return new  request url tokenizer ( service root href version id resource )  ;   }  
@ test public void   (  )  {  final  string read name1 = "000000000 - zzzzz:1:1105:17981:23325" ;  final  string read name2 = "000000000 - zzzzz:1:1109:22981:17995" ;  final int[] tokens = new int[3] ;   assert . assert equals (  read name parser . get la
@ override public  string   (  )  {  return "xmlns:db = \"jabber:server:dialback\"" ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . collect (  (  callable <  integer >  ) null new  bi consumer <  integer  integer >  (  )  {  @ override public void accept (   integer a   integer b )  {   }   }   )  ; 
public   ( final int tile final  file barcode file final  map <  string  barcode metric >  barcode to metrics final  barcode metric no match metric final  illumina data provider factory factory final int minimum base quality final int max no calls final int max mismatches final int min mismatch delta )  {  this . tile = tile ;  this . barcode file = barcode file ;  this . using quality scores = minimum base quality  >  0 ;  this . max no calls = max no calls ;  this . max mismatches = max mismatches ;  this . min mismatch delta = min mismatch delta ;  this . minimum base quality = minimum base quality ;  this . metrics = new  linked hash map <  >  ( barcode to metrics . size (  )  )  ;  for  (  final  string key : barcode to metrics . key set (  )  )   {  this . metrics . put ( key  barcode metric . copy ( barcode to metrics . get ( key )  )  )  ;   }  this . no match =  barcode metric . copy ( no match metric )  ;  this . provider = factory . make data provider (  arrays . as list ( tile )  )  ;  this . output read structure = factory . get output read structure (  )  ;   }  
@ override public void   (  throwable e )  {  throw new  test exception (  )  ;   }  
public boolean   (  output stream out  string template filename )  throws io exception  {   summary renderer . render (    context out template filename )  ;  return true ;   }  
public   (  callable statement cstmt  string sql )  {  super ( cstmt )  ;  this . sql = sql ;   string sqll = sql . to lower case (  )  . trim (  )  ;  if  ( sqll . starts with ( "insert" )  )   {  type =  type . insert ;   }  else if  ( sqll . starts with ( "update" )  )   {  type =  type . update ;   }  else if  ( sqll . starts with ( "delete" )  )   {  type =  type . delete ;   }  else  {  type =  type . select ;   }   }  
@ test public void   (  )  {   flowable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe .  <  
private void   (  element list element boolean notify )  {  items = new  array list <  >  (  )  ;   list <  element >  items elements = list element . elements ( "item" )  ;  for  (   element item element : items elements )   {   privacy item new item = new  privacy item ( item element )  ;  items . add ( new item )  ;  if  ( new item . is roster required (  )  )   {   roster roster = get roster (  )  ;  if  ( roster  =  =  null )   {   log . warn ( " privacy item removed since roster of user was not found: "  +  userjid . get node (  )  )  ;  items . remove ( new item )  ;   }   }   }   collections . sort ( items )  ;  if  ( notify )   {   privacy list manager . get instance (  )  . dispatch modified event ( this )  ;   }   }  
@ test public void   (  )  {   single . error ( new  test exception (  )  )  . filter (  functions . always true (  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   crash dummy cd = new  crash dummy ( false 1 true false false )  ;   safe observer <  object >  so = cd . to safe (  )  ;  so . on subscribe ( c
@ test public void   (  )  {   observable . empty (  )  . timeout ( 1  time unit . days  observable . just ( 1 )  )  . test (  )  . assert result (  )  ;   }  
public void   (  )  {  room cache . clear (  )  ;   }  
@ override public  source   (  string href  string base )  throws  transformer exception  {  if  ( href  !  =  null )   {  if  ( href . starts with ( headers   prefix )  )   {  return new  stream source ( marshaller . marshall ( get headers (  )  )  )  ; 
@ test public void   (  )  {   test observer <  void >  to =  flowable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  r
public synchronized boolean   (  )  {  return    current state  =  =   inbound state . ib   state   complete ||    current state  =  =   inbound state . ib   state   failed ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( 1l 1l  time unit . seconds  schedulers . single (  )  new  callable <  collection <  integer >  >  (  )  {  @ override public  collection <  integer >  call (  
private  < t > boolean   ( final t v1 final t v2 final  string label )  {  if  ( v1  =  =  null )   {  if  ( v2  =  =  null )   {  return true ;   }  report difference ( v1 v2 label )  ;  return false ;   }  if  ( v2  =  =  null )   {  report difference ( v1 v2 label )  ;  return false ;   }  if  (  ! v1 . equals ( v2 )  )   {  report difference ( v1 v2 label )  ;  return false ;   }  return true ;   }  
public int   (  )  {  return rows ;   }  
private boolean   (  )  {  final sam file header h1 = sam readers[0] . get file header (  )  ;  final sam file header h2 = sam readers[1] . get file header (  )  ;  boolean ret = compare values ( h1 . get version (  )  h2 . get version (  )  " file format version" )  ;  ret = compare values ( h1 . get creator (  )  h2 . get creator (  )  " file creator" )  && ret ;  ret = compare values ( h1 . get attribute ( "so" )  h2 . get attribute ( "so" )  " sort order" )  && ret ;  if  (  ! compare sequence dictionaries ( h1 h2 )  )   {  ret = false ;  sequence dictionaries differ = true ;   }  ret = compare read groups ( h1 h2 )  && ret ;  ret = compare program records ( h1 h2 )  && ret ;  return ret ;   }  
@ test public void   (  )  {   subscription arbiter sa = new  subscription arbiter (  )  ;  sa . get and increment (  )  ;  sa . requested = 0 ;  sa . missed requested . set (  long . max   value )  ;  sa . missed produced . set ( 1 )  ;  sa . drain loop 
public long   (  )  {  return    last agreed to ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    ( final  observer <  ?  super t >  observer )  {   object helper . require non null ( observer "observer is null" )  ;  return do on each (  observab
@ override public  integer   (  integer a  integer b )  throws  exception  {  return a  +  b ;   }  
@ override protected void   (  )  {  if  (    should save )   {  save changes (  )  ;   }  else  {   }   }  
@ override public  string   (  )  {  return type ;   }  
@ data provider ( name = "check fingerprints sam data provider" )  public  object[][]   (  )  {  final  file na12891   r1 = new  file ( test   data   dir "na12891 . over . fingerprints . r1 . sam" )  ;  final  file na12891   r2 = new  file ( test   data  
@ override protected  ad hoc command .  action   (  session data data )  {  return  ad hoc command .  action . complete ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final  subject <  integer >  ps =  publish subject .  <  integer > create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ overrid
public  hash   (  )  {  byte data[] = to byte array (  )  ;  if  ( data  !  =  null )  return sha256 generator . get instance (  )  . calculate hash ( data )  ;  return null ;   }  
@ test public void   (  )  {   flowable <  string >  source =  flowable . just ( "one" "two" "three" "four" "five" )  ;   flowable <  list <  string >  >  buffered = source . buffer ( 3 3 )  ;  buffered . subscribe ( observer )  ;   in order in order =  m
@ test public void   (  )  {  final  list <  long >  requests = new  array list <  long >  (  )  ;   flowable <  integer >  source =  flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . do on request 
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create ( 0 )  ;   testing deferred scalar subscriber ds = new  testing deferred scalar subscriber ( ts )  ;  ds . subscribe to (  flowable . range ( 1 10 )  )  ;  ts . as
@ override public  publisher <  object >    (  )  {  return null ;   }  
@ override public void   (  )  {  for  (   configuration resource resource : watch map . values (  )  )   {  try  {  if  ( resource . updated (  )  )   {  event manager . new event (  configuration event . update resource )  ;  log . info ( " updated "  +
@ xml element public boolean   (  )  {  return can occupants invite ;   }  
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  try  {  parent . on complete . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  actual . on error ( ex )  ;  return ;   }  actual . on complete ( 
private void   ( iq packet )  {   workgroup settings settings = new  workgroup settings (  )  ;  iq reply packet = null ;   element child = packet . get child element (  )  ;   element data element =  (  element ) child . element iterator (  )  . next (  )  ;  if  ( data element  !  =  null )   {  if  ( iq .  type . get . equals ( packet . get type (  )  )  )   {  reply packet = iq . create resultiq ( packet )  ;   element data stored = settings . get ( workgroup . getjid (  )  . to barejid (  )  data element )  ;  data stored . set parent ( null )  ;  child . remove ( data element )  ;  child . set parent ( null )  ;  reply packet . set child element ( child )  ;  child . add ( data stored )  ;   }   }  else  {  reply packet = iq . create resultiq ( packet )  ;  reply packet . set child element ( "query" "jabber:iq:private" )  ;   }  workgroup . send ( reply packet )  ;   }  
public void   ( boolean private call )  {  this . private call = private call ;   }  
public  string   (  )  {  return this . dm note ;   }  
@ test public void   (  )  {  double predict ;  double error ;  prepare limiter (  - 1  - 1  - 1  - 1 )  ;  long ms = test inbound throttle ( num   kb * 1024 1 * 1024 )  ;  prepare limiter ( 32  - 1 32 * 1024  - 1 )  ;  ms = test inbound throttle ( num   
  (  publisher < t >  source )  {  this . source = source ;  this . subscription = new  atomic reference <  subscription >  (  )  ;  this . requested = new  atomic long (  )  ;   }  
public void   (  login event login event )  {   log . debug ( " same time:  successful login: "  +  login event )  ;  get session (  )  . set login status (  transport login status . logged   in )  ;   }  
@ override public boolean   (  )  {  return is cancelled (  )  || is done . get (  )  ;   }  
public void   (  )  {  try  {  t . join (  )  ;   }  catch  (   interrupted exception e )   {  throw new  runtime exception ( e )  ;   }   }  
public  collection <  string >    (  )  {  return component map . values (  )  ;   }  
@ test public void   (  )  {   async subscription as = new  async subscription (  )  ;   disposable r = mock (  disposable . class )  ;  assert true ( as . replace resource ( r )  )  ;   disposable r2 = mock (  disposable . class )  ;  as . replace resour
@ override public  element   (  )  {  return  document helper . create element ( q name . get ( "not - subscribed" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;   }  
static  optional <  result returner >    (  class <  ?  >  extension type  method method )  {  final  class <  ?  > [] param types = method . get parameter types (  )  ;  for  ( int i = 0 ;  i  <  param types . length ;  i +  +  )   {  if  ( param types[i]  =  =   consumer . class )   {  return  optional . of ( new  consumer result returner ( method i )  )  ;   }   }  return  optional . empty (  )  ;   }  
@ override public  session id   (  )  {  return    session id ;   }  
@ test public void   (  )  {   observable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe .  <
private static  string   (  string[] ui projection  list <  string >  content type query parameters )  {   content values values = new  content values ( 1 )  ;  values . put ( ui provider .  attachment columns . supports   download   again 1 )  ;   string builder sb = gen select ( get attachment map (  )  ui projection values )  ;  sb . append ( " from " )  . append (  attachment . table   name )  . append ( " where " )  . append (  attachment columns . message   key )  . append ( "  =  ?  " )  ;  if  ( content type query parameters  !  =  null &&  ! content type query parameters . is empty (  )  )   {  final int size = content type query parameters . size (  )  ;  sb . append ( "and  ( " )  ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  final  string content type = content type query parameters . get ( i )  ;  sb . append (  attachment columns . mime   type )  . append ( " like '" )  . append ( content type )  . append ( "%'" )  ;  if  ( i  !  =  size  -  1 )   {  sb . append ( " or " )  ;   }   }  sb . append ( " ) " )  ;   }  return sb . to string (  )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  try  {   flowable . never (  )  . test (  )  . await done ( 1  time unit . milliseconds )  . assert result ( 1 )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   assertion error ex )   {
public long   (  byte buffer[] srcs int offset int length )  {  throw new  unsupported operation exception (  )  ;   }  
@ nullable @ override public final  integer   (  )  {  int i = index ;  if  ( i  =  =  end )   {  return null ;   }  index = i  +  1 ;  return i ;   }  
@ test ( timeout = 10000 )  public void   (  )  {  for  ( int i = 0 ;  i  <  50 ;  i +  +  )   {  final  replay processor <  string >  processor =  replay processor . create unbounded (  )  ;  final  atomic reference <  string >  value1 = new  atomic refe
private static byte[]   ( long l )  {  final byte[] q word = new byte[qword   byte   length] ;  for  ( int p = 0  shift = 0 ;  p  <  qword   byte   length ;  p +  +   shift +  = byte   bit   length )   {  q word[p] =  ( byte )  (  ( l  >  >  shift )  & mask )  ;   }  return q word ;   }  
public   (  socket channel s int ver major int ver minor  properties i2cp props sam bridge parent )  throws sam exception  io exception  {  super ( s ver major ver minor i2cp props parent )  ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  )  {  d =  disposable helper . disposed ;  if  ( eager )   {   object resource = get and set ( this )  ;  if  ( resource  !  =  this )   {  try  {  disposer . accept (  ( r ) resource )  ;  
public  job timing   (  )  {  return null ;   }  
@ override public  string   (  )  {  return " gateway session [username = "  +  username  +  "  transport = " +  transport +  "  last activity = " +  last activity +  "]" ;   }  
public  number   (  )  throws  invalidb encoding exception  {  try  {  return  (  number ) value ;   }  catch  (   class cast exception cce )   {  throw new  invalidb encoding exception ( cce . to string (  )  )  ;   }   }  
protected void   (  string msg )  {   log log =    context . log manager (  )  . get log ( get class (  )  )  ;  if  ( log . should log (  log . debug )  )  log . debug ( msg )  ;   }  
private boolean   (  string recipient )  {  boolean host   unknown =  ! server name . equals ( recipient )  ;  if  ( host   unknown && recipient . contains ( server name )  )   {  host   unknown =  ! routing table . has component route ( new jid ( recipient )  )  ;   }  return host   unknown ;   }  
@ test public void   (  )  throws  exception  {  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  final  map <  string  object >  result = h . create query ( "select * from something order by id" )  .
public void   (  signing private key spk )  {  sign it ( spk prop   oldsig )  ;   }  
public void   (  )  {  final  host auth before = new  host auth (  )  ;  before . m protocol = "imap" ;  before . m address = "dhoff@example . com" ;  before . m port = 1337 ;  before . m flags = 293847 ;  before . set login ( "dhoff" "daknightrida" )  ;  before . m domain = "example . com" ;  before . m client cert alias = "i'm a client cert alias" ;  before . m server cert = new byte[] {  ( byte ) 0xff  ( byte ) 0xaa }  ;  before . m credential key = 9873425 ;  before . m credential =  credential . empty ;  before . ensure loaded ( get context (  )  )  ;  final  host auth after =  host auth . from json ( before . to json (  )  )  ;  assert equals ( before . m protocol after . m protocol )  ;  assert equals ( before . m address after . m address )  ;  assert equals ( before . m port after . m port )  ;  assert equals ( before . m flags after . m flags )  ;  assert true (  arrays . equals ( before . get login (  )  after . get login (  )  )  )  ;  assert equals ( before . m domain after . m domain )  ;  assert equals ( before . m client cert alias after . m client cert alias )  ;  assert equals ( before . m credential after . m credential )  ;  assert null ( after . m server cert )  ;  assert equals (  - 1 after . m credential key )  ;   }  
@ test public void   (  )  {   single subject <  integer >  ss =  single subject . create (  )  ;   observable . empty (  )  . switch map single (  functions . just function ( ss )  )  . test (  )  . assert result (  )  ;  assert false ( ss . has observer
void   (  subscriber <  ?  super r >  a  iterator <  ?  extends r >  iterator )  {  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  r v ;  try  {  v = iterator . next (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  a . on error ( ex )  ;  return ;   }  a . on next ( v )  ;  if  ( cancelled )   {  return ;   }  boolean b ;  try  {  b = iterator . has next (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  a . on error ( ex )  ;  return ;   }  if  (  ! b )   {  a . on complete (  )  ;  return ;   }   }   }  
@ override public  completable   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test ( expected =  no such element exception . class )  public void   (  )  {  final  object invoked = new  object (  )  ;   collection <  flowable <  object >  >  observables =  collections . empty list (  )  ;   flowable <  object >  result =  flowabl
@ override protected void   ( final  byte buffer buffer )  {  buffer . put int ( 0 )  ;  buffer . put int ( 3 )  ;  buffer . put int ( 1 )  ;  buffer . put (  ( byte ) 0 )  ;   }  
public int   (  )  {  return proxy port ;   }  
@ test public void   (  )  {   observable . range (  integer . max   value 0 )  ;   }  
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . gadugadu . username" "kraken" )  ;   }  
public void   (  destination from byte[] data )  {   sink s = this . cache . get ( from )  ;  if  ( s  =  =  null )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  multi sink . class )  ;  log . error ( " no where to go for "  +  from . calculate hash (  )  . to base64 (  )  . substring ( 0 6 )  )  ;  return ;   }  s . send ( from data )  ;   }  
public  string   (  )  {  return name ;   }  
private void   (  string app )  {   console update manager mgr =  update handler . update manager (    context )  ;  if  ( mgr  =  =  null )   {  add form error ( " update manager not registered  cannot check" )  ;  return ;   }  if  (  ! verify proxy (  )  )  return ;  mgr . check ( plugin app )  ;  add form notice (    t ( " checking plugin  { 0 }  for updates" app )  )  ;  try  {   thread . sleep ( 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  
public  string   (  )  {  if  (  security . get property ( security   negative   ttl )   !  =  null )   {  if  (  system . get property ( system   negative   ttl )   !  =  null )   {  return both ;   }  return security ;   }  if  (  system . get property ( system   negative   ttl )   !  =  null )   {  return system ;   }  return default ;   }  
@ test public void   (  )  throws  malformed object name exception   attribute not found exception  m bean exception   reflection exception   instance not found exception  {  metrics service . set enabled ( false )  ;  assert false ( metrics service . is 
@ test public void   (  )  {  assert true (  flowable . just ( 1 2 3 )  . ignore elements (  )  . to flowable (  )  . is empty (  )  . blocking get (  )  )  ;   }  
@ override public void   (  string column label  ref x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public  flag[]   (  )  {  return permanent   flags ;   }  
@ override public  string   (  )  {  return proxy . get servlet context name (  )  ;   }  
@ override public void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "run (  )  called for socket sender "  +     id )  ;   byte array data = null ;  while  (    still running )   {  data = null ;  try  {  synchronized  (    d
@ override public  map <  string  map <  string  string >  >    (  )  {  return bare presences ;   }  
public void   (  )  throws  exception  {   byte array output stream out = new  byte array output stream (  )  ;  i2p client client = i2p client factory . create client (  )  ;   destination d = client . create destination ( out )  ;  i2p session session = client . create session ( new  byte array input stream ( out . to byte array (  )  )  null )  ;  dsa engine dsa eng = dsa engine . get instance (  )  ;   byte array output stream dout = new  byte array output stream (  )  ;  d . write bytes ( dout )  ;  dsa eng . sign (  hash . fake   hash . to byte array (  )  session . get private key (  )  )  . write bytes ( dout )  ;  dout . write (  data helper . getascii ( "blah" )  )  ;  byte[] data = dout . to byte array (  )  ;  i2p datagram dissector dd = new i2p datagram dissector (  )  ;  dd . loadi2p datagram ( data )  ;  boolean error = false ;  try  {  dd . get payload (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;  error = false ;  try  {  dd . get sender (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;  error = false ;  try  {  dd . get hash (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  observable .  <  integer > error ( new  test exception ( " outer" )  )  . flat map (  functions . just function (  observable . just ( 1 )  )  new  function <  throwable  observable <  integ
@ test public void   (  )  {   single <  object >  cache =  single . error ( new  test exception (  )  )  . cache (  )  ;  cache . test (  )  . assert failure (  test exception . class )  ;  cache . test (  )  . assert failure (  test exception . class ) 
public void   ( int profile )  {  if  ( profile  !  =  profile   bulk )  throw new  illegal argument exception ( " only bulk is supported so far" )  ;     profile = profile ;   }  
@ override public  content values   (  )  {   content values values = new  content values (  )  ;  values . put (  attachment columns . filename m file name )  ;  values . put (  attachment columns . mime   type m mime type )  ;  values . put (  attachmen
private void   ( iq iq boolean target all  group group boolean can proceed )  {  iq reply = iq . create resultiq ( iq )  ;   element child element = iq . get child element (  )  ;   string namespace = child element . get namespaceuri (  )  ;   element child element copy = iq . get child element (  )  . create copy (  )  ;  reply . set child element ( child element copy )  ;  if  ( "http: /  / jabber . org / protocol / disco#info" . equals ( namespace )  )   {  if  ( iq . get to (  )  . get node (  )   =  =  null )   {   element identity = child element copy . add element ( "identity" )  ;  identity . add attribute ( "category" "component" )  ;  identity . add attribute ( "type" "generic" )  ;  identity . add attribute ( "name" " broadcast service" )  ;  child element copy . add element ( "feature" )  . add attribute ( "var" "http: /  / jabber . org / protocol / disco#info" )  ;  child element copy . add element ( "feature" )  . add attribute ( "var" "http: /  / jabber . org / protocol / disco#items" )  ;   }  else  {  if  ( target all )   {   element identity = child element copy . add element ( "identity" )  ;  identity . add attribute ( "category" "component" )  ;  identity . add attribute ( "type" "generic" )  ;  identity . add attribute ( "name" " broadcast all connected users" )  ;  child element copy . add element ( "feature" )  . add attribute ( "var" "http: /  / jabber . org / protocol / disco#info" )  ;   }  else if  ( group  !  =  null && can proceed )   {   element identity = child element copy . add element ( "identity" )  ;  identity . add attribute ( "category" "component" )  ;  identity . add attribute ( "type" "generic" )  ;  identity . add attribute ( "name" " broadcast "  +  group . get name (  )  )  ;  child element copy . add element ( "feature" )  . add attribute ( "var" "http: /  / jabber . org / protocol / disco#info" )  ;   }  else  {  reply . set error (  packet error .  condition . item   not   found )  ;   }   }   }  else if  ( "http: /  / jabber . org / protocol / disco#items" . equals ( namespace )  )   {  if  ( iq . get to (  )  . get node (  )   =  =  null )   {   collection <  group >  groups ;  jid address = new jid ( iq . get from (  )  . to barejid (  )  )  ;  if  ( allowed users . contains ( address )  )   {  groups = group manager . get groups (  )  ;   }  else  {  groups = group manager . get groups ( iq . get from (  )  )  ;   }  for  (   group user group : groups )   {  try  {  jid groupjid = new jid ( user group . get name (  )   +  "@"  +  service name +  " . " +  component manager . get server name (  )  )  ;  child element copy . add element ( "item" )  . add attribute ( "jid" groupjid . to string (  )  )  ;   }  catch  (   exception e )   {   }   }  if  ( allowed users . is empty (  )  || allowed users . contains ( address )  )   {  child element copy . add element ( "item" )  . add attribute ( "jid" "all@"  +  service name  +  " . " +  component manager . get server name (  )  )  ;   }   }   }  else  {  reply . set error (  packet error .  condition . service   unavailable )  ;   }  try  {  component manager . send packet ( this reply )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
public boolean   (  )  {  if  ( 0  <  getn attributes (  )  )  return true ;  return false ;   }  
private dh session key builder   (  )  {  long start =  system . current time millis (  )  ;  dh session key builder builder = new dh session key builder (    context )  ;  long end =  system . current time millis (  )  ;  long diff = end  -  start ;     context . stat manager (  )  . add rate data ( "crypto . dh generate public time" diff )  ;  if  ( diff  >  1000 )   {  if  (    log . should log (  log . warn )  )     log . warn ( " took more than a second  ( "  +  diff  +  "ms )  to generate local dh value" )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " took "  +  diff  +  "ms to generate local dh value" )  ;   }  return builder ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 5 )  . parallel (  )  . concat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publi
public int   (  )  {  return  ( has   arg )  ;   }  
private boolean   (  )  {   peer test state state =    current test ;  if  ( state  !  =  null )  return state . get begin time (  )   +  max   test   time  <     context . clock (  )  . now (  )  ;  else return true ;   }  
public int   (  )  {  return portb ;   }  
public int   (  )  {  return  ( start  /  range )   +  1 ;   }  
@ override public  flowable <  boolean >    (  )  {  return  rx java plugins . on assembly ( new  flowable sequence equal < t >  ( first second comparer prefetch )  )  ;   }  
public void   ( int drop packets )  {  this . drop packets = drop packets ;   }  
public   (  string key  string value )  {  this . key = key ;  this . value = value ;   }  
@ override public  thread   (  runnable r )  {   string builder name builder = new  string builder ( prefix )  . append ( ' - ' )  . append ( increment and get (  )  )  ;   string name = name builder . to string (  )  ;   thread t = non blocking  ?  new  
public  string   (  )  {  return conference id ;   }  
public void   ( byte[] leaving nodeid )  {   kraken plugin plugin = get plugin (  )  ;  for  (   map .  entry <  string byte[] >  entry : session locations . entry set (  )  )   {  if  (  arrays . equals ( entry . get value (  )  leaving nodeid )  )   {   lock l =  cache factory . get lock ( entry . get key (  )   +  "lc" session locations )  ;  try  {  l . lock (  )  ;   string jid = entry . get key (  )  . substring ( 0 entry . get key (  )  . last index of ( "@" )  )  ;   string tr type = entry . get key (  )  . substring ( entry . get key (  )  . last index of ( "@" )   +  1 )  ;   log . debug ( " kraken:  node handling session "  +  jid  +  " on " +  tr type +  " lost  taking over session .  .  . " )  ;  session locations . remove ( jid  +  "@"  +  tr type )  ;   transport instance tr instance = plugin . get transport instance ( tr type )  ;  if  ( tr instance  !  =  null )   {   base transport <  ?  extends  transport buddy >  transport = tr instance . get transport (  )  ;  if  ( transport  !  =  null )   {   collection <  client session >  sessions = xmpp server . get instance (  )  . get session manager (  )  . get sessions ( new jid ( jid )  . get node (  )  )  ;  for  (   client session session : sessions )   {  transport . process packet ( session . get presence (  )  )  ;   }   }   }   }  finally  {  l . unlock (  )  ;   }   }   }   }  
public boolean   (  )  {  return private torrent ;   }  
public  hash   (  )  {  return    peers[0] ;   }  
public static int   ( i2p app context ctx )  {  return ctx . get property ( prop   proxy   port ctx . port mapper (  )  . get port (  port mapper . svc   http   proxy default   proxy   port   int )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . replay (  (  function <  flowable <  integer >   flowable <  integer >  >  ) null 1 1  time unit . seconds )  ;   }  
public static  version   ( int version number )  {  if  ( version number  <  1 || version number  >  40 )   {  throw new  illegal argument exception (  )  ;   }  return versions[version number  -  1] ;   }  
@ override protected void   (  single observer <  ?  super  boolean >  observer )  {  source . subscribe ( new  is empty maybe observer < t >  ( observer )  )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
protected static int   ( int check mode )  {  switch  ( check mode )   {  case  setup data fragment . check   incoming: return state   check   incoming ;  case  setup data fragment . check   outgoing: return state   check   outgoing ;  case  setup data fragment . check   autodiscover: return state   check   autodiscover ;   }  return state   start ;   }  
private void   ( double value )  {  this . m   value = value ;  long[] times = get timestamps (  )  ;  if  ( times  !  =  null )   {  int count = times . length ;  double[] values = new double[count] ;  for  ( int i = 0 ;  i  <  count ;  i +  +  )   {  values[i] = m   value ;   }  set values ( values )  ;   }   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "b" "cc" "dd" )  ;   function <  string  integer >  length func err = new  function <  string  integer >  (  )  {  @ override public  integer apply (   string t1 )  {
public void   (  hash router ident hash )  {     us = router ident hash ;   }  
public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {  final jaxb element jaxb element = xml transformer . transform (  content transformer test . class . get resource as stream ( xml   versions )  )  ;  assert true ( jaxb element . get declar
private void   (  )  {  admin list = provider . get admins (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish subject <  integer >  ps1 =  publish subject . c
@ test public void   (  )  {   test helper . check disposed (  publish subject .  <  integer > create (  )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer
@ override public int   ( final long account id final  search params search params final long dest mailbox id )  throws  remote exception  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m return = m se
private int   (  )  {  if  (    debug )  return 5 ;  if  (    lease )  return 6 ;  if  ( " . " . equals (    router prefix )  )  return 1 ;  if  (    router prefix  !  =  null ||    version  !  =  null ||    country  !  =  null ||    family  !  =  null ||    caps  !  =  null ||    ip  !  =  null ||    sybil  !  =  null ||    port  !  =  0 ||    type  !  =  null ||    mtu  !  =  null ||    ipv6  !  =  null ||    ssucaps  !  =  null ||    cost  !  =  0 )  return 2 ;  if  (    full  =  =  2 )  return 3 ;  if  (    full  =  =  1 )  return 4 ;  if  (    full  =  =  3 )  return 7 ;  if  (    full  =  =  4 )  return 8 ;  return 0 ;   }  
public void   (  )  {  synchronized  (    wait lock )   {     quit = true ;     wait lock . notify all (  )  ;   }   }  
public boolean   ( byte iv data[] int iv offset byte payload[] int payload offset )  {  return true ;   }  
public void   (  )  {     i2p source . start (  )  ;   }  
public synchronized void   (  string[] args )  {  if  (    state  =  =  stopped )  return ;  change state ( stopping )  ;  if  (    tray manager  !  =  null )     tray manager . stop manager (  )  ;  change state ( stopped )  ;   }  
@ override public  type   (  )  {  return raw type ;   }  
public void   (  publisher <  integer >  p )  {  p . subscribe ( this )  ;   }  
public   (  flowable < t >  source  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper boolean delay errors )  {  this . source = source ;  this . mapper = mapper ;  this . delay errors = delay errors ;   }  
@ override public void   (  )  {  cancelled = true ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write safeutf ( out username )  ;   externalizable util . get instance (  )  . write safeutf ( out get name (  )  )  ;   externalizable ut
public  collection < jid >    (  )  {   set < jid >  everybody = new  hash set <  >  ( administrators )  ;  everybody . add all ( members )  ;  return  collections . unmodifiable set ( everybody )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic integer count = new  atomic integer (  )  ;  final int size = 2000 ;   flowable <  long >  timer =  flowable . inter
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;   properties p = new  properties (  )  ;  write to properties ( p )  ;  buf . append ( " client tunnel settings:\n" )  ;  buf . append ( " =  =  =  =  =  =  =  =  =  = 
  (  subscriber <  ?  super t >  actual  boolean supplier until  subscription arbiter sa  publisher <  ?  extends t >  source )  {  this . actual = actual ;  this . sa = sa ;  this . source = source ;  this . stop = until ;   }  
public   (  string msg  throwable nested throwable )  {  super ( msg )  ;  this . nested throwable = nested throwable ;   }  
public void   (  string base )  {     url base = base ;   }  
public int   (  )  {  return    mtu receive ;   }  
@ test public void   (  )  {   flowable <  string >  one item =  flowable . just ( " hello" )  . merge with (  flowable .  <  string > never (  )  )  ;   flowable <  string >  src = one item . switch map ( new  function <  string  flowable <  string >  > 
public boolean   (  )  {  return is pentiumm compatible ;   }  
@ override public void   (  throwable e )  {  errors . add ( e )  ;   }  
public  destination   (  )  {   string name = get host (  )  ;  if  ( name  =  =  null )  return null ;  return i2p app context . get global context (  )  . naming service (  )  . lookup ( name )  ;   }  
private void   (  )  {  try  {  final  class loader parent = find parent class loader (  )  ;   string lib dir string =  system . get property ( "openfire . lib . dir" )  ;   file lib dir ;  if  ( lib dir string  !  =  null )   {  lib dir = new  file ( lib dir string )  ;  if  (  ! lib dir . exists (  )  )   {   log . warn ( " lib directory "  +  lib dir string  +  " does not exist .   using default " +  default   lib   dir )  ;  lib dir = new  file ( default   lib   dir )  ;   }   }  else  {  lib dir = new  file ( default   lib   dir )  ;   }   string admin lib dir string =  system . get property ( "openfire home" )  ;  if  ( admin lib dir string  =  =  null )   {  admin lib dir string = default   admin   lib   dir ;   }  else  {  admin lib dir string = admin lib dir string  +  " / plugins / admin / webapp / web - inf / lib" ;   }   file admin lib dir = new  file ( admin lib dir string )  ;  if  (  ! admin lib dir . exists (  )  )   {   log . warn ( " admin  lib  directory "  +  admin lib dir string  +  " does not exist .   web admin console may not work . " )  ;   }   class loader loader = new  jive class loader ( parent lib dir )  ;   thread . current thread (  )  . set context class loader ( loader )  ;   class container class = loader . load class ( "org . jivesoftware . openfire . xmpp server" )  ;  container class . new instance (  )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public  tunnel info   (  hash destination  hash closest to )  {  return null ;   }  
public  string   (  )  {  return get icon node (  )  . get node value ( mime   type )  ;   }  
public long   (  )  {  long ack = last requestid ;   collections . sort ( connection queue connection comparator )  ;  synchronized  ( connection queue )   {  for  (   http connection connection : connection queue )   {  if  ( connection . get request id (  )   =  =  ack  +  1 )   {  ack +  +  ;   }   }   }  return ack ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <
private void   (  )  {  synchronized  ( member list )   {  for  ( int i = 0 ;  i  <  member list . size (  )  ;  i +  +  )   {   conference member member =  (  conference member ) member list . get ( i )  ;  member . cancel request ( " end of  distributed  conference" )  ;   }   }   }  
private boolean   ( long objectid  object data )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( delete   queue )  ;  if  (  (  boolean ) data )   {  pstmt . set int ( 1 group   type )  ;   }  else  {  pstmt . set int ( 1 agent   type )  ;   }  pstmt . set long ( 2 objectid )  ;  pstmt . set long ( 3 id )  ;  pstmt . execute update (  )  ;  return true ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return false ;   }  
void   (  )  {  throw new  unsupported operation exception ( "use override" )  ;   }  
private  node   (  )  {   service data data = get service data (  )  ;   node scpd node = data . getscpd node (  )  ;  if  ( scpd node  !  =  null )  return scpd node ;   device root dev = get root device (  )  ;  if  ( root dev  =  =  null )  return null ;   string scpdurl str = getscpdurl (  )  ;  try  {  url scpd url = new url ( root dev . get absoluteurl ( scpdurl str )  )  ;  scpd node = getscpd node ( scpd url )  ;  if  ( scpd node  !  =  null )   {  data . setscpd node ( scpd node )  ;  return scpd node ;   }   }  catch  (   exception e )   {   debug . warning ( e )  ;   }  return null ;   }  
public int[]   (  )  throws sql exception  {  return stmt . execute batch (  )  ;   }  
private boolean   (  file ks )  {   string ks pass =    context . get property ( prop   keystore   password  key store util . default   keystore   password )  ;   string key pass =    context . get property ( prop   key   password )  ;  if  ( key pass  =  =  null )   {     log . error ( " no key password  set "  +  prop   key   password  +  " in " +   ( new  file (    context . get config dir (  )  "router . config" )  )  . get absolute path (  )  )  ;  return false ;   }   input stream fis = null ;  try  {  ssl context sslc = ssl context . get instance ( "tls" )  ;   key store key store =  key store . get instance (  key store . get default type (  )  )  ;  fis = new  file input stream ( ks )  ;  key store . load ( fis ks pass . to char array (  )  )  ;   key store util . log cert expiration ( key store ks . get absolute path (  )  180 * 24 * 60* 60* 1000l )  ;   key manager factory kmf =  key manager factory . get instance (  key manager factory . get default algorithm (  )  )  ;  kmf . init ( key store key pass . to char array (  )  )  ;  sslc . init ( kmf . get key managers (  )  null    context . random (  )  )  ;     factory = sslc . get server socket factory (  )  ;  return true ;   }  catch  (   general security exception gse )   {     log . error ( " error loading ssl keys" gse )  ;   }  catch  (  io exception ioe )   {     log . error ( " error loading ssl keys" ioe )  ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  return false ;   }  
public void   (  string call id )  {  this . call id = call id ;   }  
void   (  )  {  if  ( sd . is disposed (  )  )   {  return ;   }  if  ( get and increment (  )   !  =  0 )   {  return ;   }   completable source[] a = sources ;  do  {  if  ( sd . is disposed (  )  )   {  return ;   }  int idx = index +  +  ;  if  ( idx  =  =  a . length )   {  actual . on complete (  )  ;  return ;   }  a[idx] . subscribe ( this )  ;   }  while  ( decrement and get (  )   !  =  0 )  ;   }  
public boolean   (  )  {  return ssl enabled ;   }  
  (  maybe observer <  ?  super t >  actual  function <  ?  super  throwable  ?  extends t >  value supplier )  {  this . actual = actual ;  this . value supplier = value supplier ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
public static void   (  http servlet request request  http servlet response response  string name  string value int max age )  {  if  ( value  =  =  null )   {  value = "" ;   }   string path = request . get context path (  )   =  =  null  ?  " / " : request . get context path (  )  ;  if  ( "" . equals ( path )  )   {  path = " / " ;   }   cookie cookie = new  cookie ( name value )  ;  cookie . set max age ( max age )  ;  cookie . set path ( path )  ;  cookie . set http only ( true )  ;  response . add cookie ( cookie )  ;   }  
public  string   (  )  {  return " bases and quals (  "  +  bases to string (  )   +  "  " +  quals to string ( quals )  +  "  " +  quals to string ( masked quals )  +  " ) " ;   }  
public int[]   (  file zip )  throws io exception  {  int fetched = 0 ;  int errors = 0 ;   file tmp dir = null ;  try  {  tmp dir = new  file (    context . get temp dir (  )  "reseeds - "  +     context . random (  )  . next int (  )  )  ;  if  (  !  file util . extract zip ( zip tmp dir )  )  throw new io exception ( " bad zip file" )  ;   hash our hash =    context . router hash (  )  ;   string ourb64 = our hash  !  =  null  ?  routerinfo   prefix  +  our hash . to base64 (  )   +  routerinfo   suffix : "" ;   file[] files = tmp dir . list files (  )  ;  if  ( files  =  =  null || files . length  =  =  0 )  throw new io exception ( " no files in zip" )  ;   list <  file >  f list =  arrays . as list ( files )  ;   collections . shuffle ( f list    context . random (  )  )  ;  long min time =    context . clock (  )  . now (  )   -  max   file   age ;   file net db dir = new  secure directory (    context . get router dir (  )  "net db" )  ;  if  (  ! net db dir . exists (  )  )  net db dir . mkdirs (  )  ;  for  (  iterator <  file >  iter = f list . iterator (  )  ;  iter . has next (  )  && fetched  <  400 ;   )   {   file f = iter . next (  )  ;   string name = f . get name (  )  ;  if  ( name . length (  )   !  =  routerinfo   prefix . length (  )   +  44  +  routerinfo   suffix . length (  )  || name . equals ( ourb64 )  || f . length (  )   >  10 * 1024 || f . last modified (  )   <  min time ||  ! name . starts with ( routerinfo   prefix )  ||  ! name . ends with ( routerinfo   suffix )  ||  ! f . is file (  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " skipping "  +  f )  ;  f . delete (  )  ;  errors +  +  ;  continue ;   }   file to = new  file ( net db dir name )  ;  if  (  file util . rename ( f to )  )   {  fetched +  +  ;   }  else  {  f . delete (  )  ;  errors +  +  ;   }  if  ( errors  >  =  5 )  break ;   }   }  finally  {  if  ( tmp dir  !  =  null )   file util . rmdir ( tmp dir false )  ;   }  if  ( fetched  >  0 )     context . net db (  )  . rescan (  )  ;  int[] rv = new int[2] ;  rv[0] = fetched ;  rv[1] = errors ;  return rv ;   }  
@ override public void   (  )  {  request ( 1 )  ;   }  
void   ( int x int y int width int height )  {  gd . set clip ( x y width height )  ;   }  
@ test public void   (  )  {   single . from callable ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   )  . to observable (  )  . take ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
public  string   (  )  {  return title ;   }  
@ override public  persistable map <  string  string >    (  group group )  {   string name = group . get name (  )  ;   persistable map <  string  string >  result = new  default group property map <  >  ( group )  ;   connection con = null ;   prepared 
public jid   (  )  {  return with jid ;   }  
@ test public void   (  )  {  assert that (  log format argument . percent is ( equal to ignoring case ( "%" )  )  )  ;   }  
public   (  limits entity stream transformer response transformer )  {  this . response transformer = response transformer ;   }  
public void   (  call handler other call )  {  this . other call = other call ;   }  
public void   (  macro group group )  {  macro groups . add ( group )  ;   }  
@ override public  result set meta data   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public  string   (  )  {  return file name ;   }  
public  inet socket address   (  )  {  return addressa ;   }  
protected final int   ( int mode )  {   queue subscription < t >  qs = this . qs ;  if  ( qs  !  =  null )   {  if  (  ( mode & boundary )   =  =  0 )   {  int m = qs . request fusion ( mode )  ;  if  ( m  !  =  none )   {  source mode = m ;   }  return m ;   }   }  return none ;   }  
static boolean   (  string content encoding )  {  return no   encoding . equals ( content encoding )  || factory   map . contains key ( content encoding )  ;   }  
@ override public  observable < t >    (  )  {  return  rx java plugins . on assembly ( new  observable element at < t >  ( source index default value true )  )  ;   }  
@ override public void   (  throwable e )  {  subscriber . on error ( e )  ;   }  
@ override public void   (  throwable t )  {  if  (  ! try on error ( t )  )   {   rx java plugins . on error ( t )  ;   }   }  
  ( int eax int ebx int ecx int edx )  {  this . eax = eax ;  this . ebx = ebx ;  this . ecx = ecx ;  this . edx = edx ;   }  
@ override public void   (  subscriber <  ?  super  completable >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next (  completable . never (  )  )  ;  s . on next (  completable . never (  )  )  ;  s . on next (  completable . 
public   (  garlic clove[] cloves  certificate cert long msg id long expiration )  {     cloves = cloves ;     cert = cert ;     msg id = msg id ;     expiration = expiration ;   }  
  (  subscriber <  ?  super  flowable < t >  >  actual long size int buffer size )  {  super ( 1 )  ;  this . actual = actual ;  this . size = size ;  this . once = new  atomic boolean (  )  ;  this . buffer size = buffer size ;   }  
void   (  )  {   simple queue < u >  q = queue ;  if  ( q  !  =  null )   {  q . clear (  )  ;   }   }  
public void   (  string b )  {     show events =  ! "false" . equals ( b )  ;   }  
public  string   (  )  {  return host ;   }  
  ( long timestamp  paint color  legend text legend float width )  {  super ( color legend width )  ;  this . timestamp = timestamp ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 0 100000 )  . on error resume next ( new  function <  throwable  observable <  integer >  >  (  )  {  @ override public  observ
@ test @ ignore ( "null values are not allowed" )  public void   (  )  {   single <  boolean >  observable =  flowable . just ( "a" "b" null )  . contains ( null )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;   element packet element =  (  element )  externalizable util . get instance (  )  . read serializable ( in )  ;  presence =
@ test public void   (  )  {   observable . just ( 1 )  . window ( 1 1  time unit . minutes  schedulers . io (  )  )  . flat map (  functions .  <  observable <  integer >  > identity (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert
public   (  )  {  super ( " message  archiving  list  handler" "list" namespace )  ;   }  
@ test public void   (  )  {   observable <  string >  base =  observable . just ( "a" "b" "c" )  ;   observable <  string >  do on each = base . do on each ( side effect observer )  ;  do on each . subscribe ( subscribed observer )  ;  verify ( subscribe
synchronized  fetch data   (  fetch request request )  throws io exception   rrd exception  {  if  ( closed )   {  throw new  rrd exception ( "rrd already closed  cannot fetch data" )  ;   }   archive archive = find matching archive ( request )  ;  return archive . fetch data ( request )  ;   }  
@ transaction default  something   ( int id  string name )  throws io exception  {  insert ( id name )  ;  throw new io exception ( "woof" )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout ( 1  time unit . seconds  schedulers . single (  )  null )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 2 )  . flat map iterable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer t )  throws  exception  {  return  arrays . as list ( t 
@ override public void   (  )  {  cancelled = true ;   subscription helper . cancel ( main subscription )  ;   disposable helper . dispose ( other observer )  ;  if  ( get and increment (  )   =  =  0 )   {  queue = null ;  single item = null ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  maybe observer <  ?  > [] o =  { null }  ;   maybe . concat array delay error (  maybe . just ( 1 
public long   (  )  {  return    expiration ;   }  
@ override public void   (  )  {  executor . submit ( task )  ;   }  
public  string   (  )  {  return payload ;   }  
public  map <  hash  tunnel pool >    (  )  {  return null ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   behavior processor . create default ( 1 )  . window (  flowable . error ( new  test exception (  )  )  )  . test ( 0 )  . assert failure (  missing backpressure exception . class )  ;   }
public  call participant   (  )  {  return far party ;   }  
public static void   (  user event listener listener )  {  if  ( listener  =  =  null )   {  throw new  null pointer exception (  )  ;   }  listeners . add ( listener )  ;   }  
@ test ( timeout = 30000 )  public void   (  )  {  check class (  parallel flowable . class )  ;   }  
@ test public void   (  )  {   single <  boolean >  o =  observable .  <  string > empty (  )  . contains ( "a" )  ;   single observer <  object >  observer =  test helper . mock single observer (  )  ;  o . subscribe ( observer )  ;  verify ( observer ti
public long   (  )  {  int offset = read body offset (  )  ;  offset +  =    message[offset] & 0xff ;  offset +  = 1  +  2 ;  int sz =    message[offset] & 0xff ;  offset +  = 1  +  2 ;  offset +  = sz ;  return  data helper . from long (    message offset 4 )  ;   }  
public void   (  )  {   imap list list = new  imap list (  )  ;  assert true ( list . is list (  )  )  ;  assert false ( list . is string (  )  )  ;  assert true ( list . is empty (  )  )  ;  assert equals ( 0 list . size (  )  )  ;  list . add ( string   1 )  ;  assert false ( list . is empty (  )  )  ;  assert equals ( 1 list . size (  )  )  ;  list . add ( string   2 )  ;  assert equals ( 2 list . size (  )  )  ;  list . add ( list   1 )  ;  assert equals ( 3 list . size (  )  )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return observable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
public boolean   (  string hostname  destination d  properties options )  {   destination old = lookup ( hostname options null )  ;  if  (  ! d . equals ( old )  )  return false ;  return remove ( hostname options )  ;   }  
@ test public void   (  )  {   observable . empty (  )  . do finally ( this )  . test (  )  . assert result (  )  ;  assert equals ( 1 calls )  ;   }  
public  integer   (  integer registrationid )  {  try  {   plugin manager plugin manager = xmpp server . get instance (  )  . get plugin manager (  )  ;   kraken plugin plugin =  (  kraken plugin ) plugin manager . get plugin ( "kraken" )  ;   registration registration = new  registration ( registrationid )  ;  if  (  ! plugin . get transport instance ( registration . get transport type (  )  . to string (  )  )  . is enabled (  )  )   {  return  - 1 ;   }  jid jid = registration . getjid (  )  ;   transport session session = plugin . get transport instance ( registration . get transport type (  )  . to string (  )  )  . get transport (  )  . get session manager (  )  . get session ( jid )  ;  plugin . get transport instance ( registration . get transport type (  )  . to string (  )  )  . get transport (  )  . registration logged out ( session )  ;  return registrationid ;   }  catch  (   not found exception e )   {  return  - 1 ;   }   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  open folder with message ( mock transport )  ;  setup uidl sequence ( mock transport 1 )  ;   message[] messages = m folder . get messages ( 1 1 null )  ;  assert equals ( 1 messages . length )  ;  assert equals ( get single messageuid ( 1 )  messages[0] . get uid (  )  )  ;  mock transport . close input stream (  )  ;  try  {  mock transport . expect ( "dele 1" " + ok message deleted" )  ;  m folder . set flags ( messages new  flag[] {  flag . deleted }  true )  ;  fail ( " broken stream should cause fetch (  )  to throw . " )  ;   }  catch  (   messaging exception me )   {   }  assert false ( "folder should be 'closed' after an io error" m folder . is open (  )  )  ;  check one unread ( mock transport )  ;   }  
@ override public void   (  )  {  s . cancel (  )  ;  s =  subscription helper . cancelled ;   }  
@ override public void   ( final t t )  {  w . schedule ( new  on next ( t )  delay unit )  ;   }  
public  string   (  )  {  return local addr ;   }  
@ override public  string   (  )  {  return null ;   }  
@ override public void   ( jid recipientjid jid userjid )  {  if  ( xmpp server . get instance (  )  . is local ( userjid )  && user manager . is registered user ( userjid . get node (  )  )  )   {  for  (   client session session : session manager . get 
@ test public void   (  )  {   flowable . from array ( new  string[] { "1" "a" "2" }  )  . flat map maybe ( new  function <  string  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (  final  string s )  throws  n
public static  file   (  string filename )  {  if  (  environment . get external storage state (  )  . equals (  environment . media   mounted )  )   {   file directory =  environment . get external storage directory (  )  ;   file file = new  file ( directory filename )  ;  if  (  ! file . exists (  )  )   {  return file ;   }  int index = filename . last index of ( ' . ' )  ;   string name = filename ;   string extension = "" ;  if  ( index  !  =   - 1 )   {  name = filename . substring ( 0 index )  ;  extension = filename . substring ( index )  ;   }  for  ( int i = 2 ;  i  <   integer . max   value ;  i +  +  )   {  file = new  file ( directory name  +  ' - '  +  i +  extension )  ;  if  (  ! file . exists (  )  )   {  return file ;   }   }  return null ;   }  return null ;   }  
public void   (  writer out )  throws io exception  {   tunnel pool ei =    context . tunnel manager (  )  . get inbound exploratory pool (  )  ;   tunnel pool eo =    context . tunnel manager (  )  . get outbound exploratory pool (  )  ;  out . write ( " < h3 class = \"tabletitle\" id = \"exploratorytunnels\" >  < a name = \"exploratory\"  >  <  / a > "  +     t ( " exploratory tunnels" )  )  ;  out . write ( "  < a href = \" / configtunnels#exploratory\" title = \""  +     t ( " configure tunnels" )   +  "\" > [" +     t ( "configure" )  +  "] <  / a > " )  ;  write graph links ( out ei eo )  ;  out . write ( " <  / h3 > \n" )  ;  render pool ( out ei eo )  ;   list <  hash >  destinations = null ;   map <  hash  tunnel pool >  client inbound pools =    context . tunnel manager (  )  . get inbound client pools (  )  ;   map <  hash  tunnel pool >  client outbound pools =    context . tunnel manager (  )  . get outbound client pools (  )  ;  destinations = new  array list <  hash >  ( client inbound pools . key set (  )  )  ;  boolean debug =    context . get boolean property (  helper base . prop   advanced )  ;  for  ( int i = 0 ;  i  <  destinations . size (  )  ;  i +  +  )   {   hash client = destinations . get ( i )  ;  boolean is local =    context . client manager (  )  . is local ( client )  ;  if  (  (  ! is local )  &&  (  ! debug )  )  continue ;   tunnel pool in = client inbound pools . get ( client )  ;   tunnel pool out pool = client outbound pools . get ( client )  ;  if  (  ( in  !  =  null && in . get settings (  )  . get alias of (  )   !  =  null )  ||  ( out pool  !  =  null && out pool . get settings (  )  . get alias of (  )   !  =  null )  )   {  continue ;   }   string name =  ( in  !  =  null )   ?  in . get settings (  )  . get destination nickname (  )  : null ;  if  (  ( name  =  =  null )  &&  ( out pool  !  =  null )  )  name = out pool . get settings (  )  . get destination nickname (  )  ;  if  ( name  =  =  null )  name = client . to base64 (  )  . substring ( 0 4 )  ;  out . write ( " < h3 class = \"tabletitle\" id = \""  +  client . to base64 (  )  . substring ( 0 4 )   +  "\"  > " +     t ( " client tunnels for" )  +  ' ' +   data helper . escapehtml (    t ( name )  )  )  ;  if  ( is local )   {  out . write ( "  < a href = \" / configtunnels#"  +  client . to base64 (  )  . substring ( 0 4 )   +  "\" title = \"" +     t ( " configure tunnels for session" )  +  "\" > [" +     t ( "configure" )  +  "] <  / a > " )  ;  write graph links ( out in out pool )  ;  out . write ( " <  / h3 > \n" )  ;   }  else  {  out . write ( "  ( "  +     t ( "dead" )   +  " )  <  / h3 > \n" )  ;   }  if  ( in  !  =  null )   {   set <  hash >  aliases = in . get settings (  )  . get aliases (  )  ;  if  ( aliases  !  =  null )   {  for  (   hash a : aliases )   {   tunnel pool ain = client inbound pools . get ( a )  ;  if  ( ain  !  =  null )   {   string aname = ain . get settings (  )  . get destination nickname (  )  ;  if  ( aname  =  =  null )  aname = a . to base64 (  )  . substring ( 0 4 )  ;  out . write ( " < h3 class = \"tabletitle\" id = \""  +  a . to base64 (  )  . substring ( 0 4 )   +  "\"  > " +     t ( " client tunnels for" )  +  ' ' +   data helper . escapehtml (    t ( aname )  )  )  ;  if  ( is local )  out . write ( "  < a href = \" / configtunnels#"  +  client . to base64 (  )  . substring ( 0 4 )   +  "\" title = \"" +     t ( " configure tunnels for session" )  +  "\" > [" +     t ( "configure" )  +  "] <  / a >  <  / h3 > \n" )  ;  else out . write ( "  ( "  +     t ( "dead" )   +  " )  <  / h3 > \n" )  ;   }   }   }   }  render pool ( out in out pool )  ;   }   list <  hop config >  participating =    context . tunnel dispatcher (  )  . list participating tunnels (  )  ;  out . write ( " < h3 class = \"tabletitle\" id = \"participating\" > "  +     t ( " participating tunnels" )   +  " <  / h3 > \n" )  ;  int bw share = get share bandwidth (  )  ;  if  ( bw share  >  12 )   {  if  (  ! participating . is empty (  )  )   {   collections . sort ( participating new  tunnel comparator (  )  )  ;  out . write ( " < table class = \"tunneldisplay tunnels   participating\" >  < tr >  < th > "  +     t ( " receive on" )   +  " <  / th >  < th > " +     t ( " from" )  +  " <  / th >  < th > " +     t ( " send on" )  +  " <  / th >  < th > " +     t ( " to" )  +  " <  / th >  < th > " +     t ( " expiration" )  +  " <  / th > " +  " < th > " +     t ( " usage" )  +  " <  / th >  < th > " +     t ( " rate" )  +  " <  / th >  < th > " +     t ( " role" )  +  " <  / th >  <  / tr > \n" )  ;   }  long processed = 0 ;   rate stat rs =    context . stat manager (  )  . get rate ( "tunnel . participating message count" )  ;  if  ( rs  !  =  null )  processed =  ( long ) rs . get rate ( 10 * 60 * 1000 )  . get lifetime total value (  )  ;  int inactive = 0 ;  int displayed = 0 ;  for  ( int i = 0 ;  i  <  participating . size (  )  ;  i +  +  )   {   hop config cfg = participating . get ( i )  ;  int count = cfg . get processed messages count (  )  ;  if  ( count  <  =  0 )   {  inactive +  +  ;  continue ;   }  processed +  = cfg . get recent messages count (  )  ;  if  (  +  + displayed  >  display   limit )  continue ;  out . write ( " < tr > " )  ;  if  ( cfg . get receive tunnel (  )   !  =  null )  out . write ( " < td class = \"cells\" align = \"center\" title = \""  +     t ( " tunnel identity" )   +  "\" >  < span class = \"tunnel   id\" > " +  cfg . get receive tunnel (  )  . get tunnel id (  )  +  " <  / span >  <  / td > " )  ;  else out . write ( " < td class = \"cells\" align = \"center\" > n / a <  / td > " )  ;  if  ( cfg . get receive from (  )   !  =  null )  out . write ( " < td class = \"cells\" align = \"center\" >  < span class = \"tunnel   peer\" > "  +  net db link ( cfg . get receive from (  )  )   +  " <  / span >  <  / td > " )  ;  else out . write ( " < td class = \"cells\" > &nbsp ;  <  / td > " )  ;  if  ( cfg . get send tunnel (  )   !  =  null )  out . write ( " < td class = \"cells\" align = \"center\" title = \""  +     t ( " tunnel identity" )   +  "\" >  < span class = \"tunnel   id\" > " +  cfg . get send tunnel (  )  . get tunnel id (  )  +  " <  / span >  <  / td > " )  ;  else out . write ( " < td class = \"cells\" > &nbsp ;  <  / td > " )  ;  if  ( cfg . get send to (  )   !  =  null )  out . write ( " < td class = \"cells\" align = \"center\" >  < span class = \"tunnel   peer\" > "  +  net db link ( cfg . get send to (  )  )   +  " <  / span >  <  / td > " )  ;  else out . write ( " < td class = \"cells\" > &nbsp ;  <  / td > " )  ;  long time left = cfg . get expiration (  )   -     context . clock (  )  . now (  )  ;  if  ( time left  >  0 )  out . write ( " < td class = \"cells\" align = \"center\" > "  +   data helper . format duration2 ( time left )   +  " <  / td > " )  ;  else out . write ( " < td class = \"cells\" align = \"center\" >  ( "  +     t ( "grace period" )   +  " )  <  / td > " )  ;  out . write ( " < td class = \"cells\" align = \"center\" > "  +   ( count * 1024  /  1000 )   +  " kb <  / td > " )  ;  int lifetime =  ( int )  (  (    context . clock (  )  . now (  )   -  cfg . get creation (  )  )   /  1000 )  ;  if  ( lifetime  <  =  0 )  lifetime = 1 ;  if  ( lifetime  >  10 * 60 )  lifetime = 10 * 60 ;  int bps = 1024 * count  /  lifetime ;  out . write ( " < td class = \"cells\" align = \"center\" > "  +  bps  +  "  bps <  / td > " )  ;  if  ( cfg . get send to (  )   =  =  null )  out . write ( " < td class = \"cells\" align = \"center\" > "  +     t ( " outbound  endpoint" )   +  " <  / td > " )  ;  else if  ( cfg . get receive from (  )   =  =  null )  out . write ( " < td class = \"cells\" align = \"center\" > "  +     t ( " inbound  gateway" )   +  " <  / td > " )  ;  else out . write ( " < td class = \"cells\" align = \"center\" > "  +     t ( " participant" )   +  " <  / td > " )  ;  out . write ( " <  / tr > \n" )  ;   }  if  (  ! participating . is empty (  )  )  out . write ( " <  / table > \n" )  ;  if  ( displayed  >  display   limit )  out . write ( " < div class = \"statusnotes\" >  < b > "  +     t ( " limited display to the  { 0 }  tunnels with the highest usage" display   limit )   +  " <  / b >  <  / div > \n" )  ;  if  ( inactive  >  0 )  out . write ( " < div class = \"statusnotes\" >  < b > "  +     t ( " inactive participating tunnels" )   +  ":&nbsp ; &nbsp ; " +  inactive +  " <  / b >  <  / div > \n" )  ;  else if  ( displayed  <  =  0 )  out . write ( " < div class = \"statusnotes\" >  < b > "  +     t ( "none" )   +  " <  / b >  <  / div > \n" )  ;  out . write ( " < div class = \"statusnotes\" >  < b > "  +     t ( " lifetime bandwidth usage" )   +  ":&nbsp ; &nbsp ; " +   data helper . format size2 decimal ( processed * 1024 )  +  "b <  / b >  <  / div > \n" )  ;   }  else  {  out . write ( " < div class = \"statusnotes noparticipate\" >  < b > "  +     t ( " not enough shared bandwidth to build participating tunnels . " )   +  " <  / b >   < a href = \"config\" > [" +     t ( " configure" )  +  "] <  / a >  <  / div > \n" )  ;   }  out . write ( " < h3 class = \"tabletitle\" > "  +     t ( " bandwidth  tiers" )   +  " <  / h3 > \n" )  ;  out . write ( " < table id = \"tunnel   defs\" >  < tbody > " )  ;  out . write ( " < tr >  < td > &nbsp ;  <  / td > "  +  " < td >  < span class = \"tunnel   cap\" >  < b > l <  / b >  <  / span >  <  / td >  < td > "  +     t ( " { 0 }  shared bandwidth" range (  router . min   bw   l  router . min   bw   m )  )   +  " <  / td > " +  " < td >  < span class = \"tunnel   cap\" >  < b > m <  / b >  <  / span >  <  / td >  < td > " +     t ( " { 0 }  shared bandwidth" range (  router . min   bw   m  router . min   bw   n )  )  +  " <  / td > " +  " < td > &nbsp ;  <  / td >  <  / tr > " )  ;  out . write ( " < tr >  < td > &nbsp ;  <  / td > "  +  " < td >  < span class = \"tunnel   cap\" >  < b > n <  / b >  <  / span >  <  / td >  < td > "  +     t ( " { 0 }  shared bandwidth" range (  router . min   bw   n  router . min   bw   o )  )   +  " <  / td > " +  " < td >  < span class = \"tunnel   cap\" >  < b > o <  / b >  <  / span >  <  / td >  < td > " +     t ( " { 0 }  shared bandwidth" range (  router . min   bw   o  router . min   bw   p )  )  +  " <  / td > " +  " < td > &nbsp ;  <  / td >  <  / tr > " )  ;  out . write ( " < tr >  < td > &nbsp ;  <  / td > "  +  " < td >  < span class = \"tunnel   cap\" >  < b > p <  / b >  <  / span >  <  / td >  < td > "  +     t ( " { 0 }  shared bandwidth" range (  router . min   bw   p  router . min   bw   x )  )   +  " <  / td > " +  " < td >  < span class = \"tunnel   cap\" >  < b > x <  / b >  <  / span >  <  / td >  < td > " +     t ( " over  { 0 }  shared bandwidth"  math . round (  router . min   bw   x * 1 . 024f )   +  " k bps" )  +  " <  / td > " +  " < td > &nbsp ;  <  / td >  <  / tr > " )  ;  out . write ( " <  / tbody >  <  / table > " )  ;   }  
boolean   (  peer state peer )  {  if  (    log . should log (  log . info )  )     log . info ( " add remote peer state: "  +  peer )  ;  synchronized  (    add drop lock )   {  return locked   add remote peer state ( peer )  ;   }   }  
@ test public void   (  )  throws  exception  {  assert equals ( 1  single . just ( 1 )  . to future (  )  . get (  )  . int value (  )  )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   replay processor <  integer >  rp =  replay processor . create with time and size ( 1  time unit . seconds scheduler 2 )  ;  rp . on next ( 1 )  ;  scheduler . advance
@ override protected void   ( final sam file header header final  file sam file )  {  io util . assert file is writable ( chart   output )  ;  io util . assert file is writable ( summary   output )  ;  io util . assert file is readable ( reference   seque
@ test ( expected =  missing backpressure exception . class )  public void   (  )  {   iterator <  integer >  it = new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  s )  {  s . on subscr
public void   (  string description )  {     config . set description ( description )  ;   }  
public static void   (  time zone new time zone )  {  time zone = new time zone ;  if  ( time format  !  =  null )   {  time format . set time zone ( time zone )  ;   }  if  ( date format  !  =  null )   {  date format . set time zone ( time zone )  ;   }  if  ( date time format  !  =  null )   {  date time format . set time zone ( time zone )  ;   }  set property ( "locale . time zone" time zone . getid (  )  )  ;   }  
public int   (  )  {  return echo port ;   }  
@ before public void   (  )  {  h = db rule . get shared handle (  )  ;   }  
@ test public void   (  )  {   optional <  integer >  should be present = db rule . get shared handle (  )  . create query ( "select int value from something where int value  =  1" )  . collect into ( new  generic type <  optional <  integer >  >  (  )  {
public   (  boolean auto accept suggestions  boolean mail notifications  boolean archiving enabled )  {  this . auto accept suggestions = auto accept suggestions ;  this . mail notifications = mail notifications ;  this . archiving enabled = archiving enabled ;   }  
public   (  string xml string )  throws io exception   rrd exception  {  super ( xml string )  ;   }  
public void   (  )  {  starting = true ;   }  
public  string   (  )  {  if  ( credentials  =  =  null )   {  return null ;   }  return credentials . get username (  )  ;   }  
@ override public boolean   (  )  {  if  ( count +  +   =  =  2 )   {  ts . cancel (  )  ;   }  return true ;   }  
@ test public void   (  )  throws  exception  {  org . springframework . jmx . export . metadata .  managed resource managed resource = mock ( org . springframework . jmx . export . metadata .  managed resource . class )  ;  when ( managed resource . get 
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 5 )  . merge with (  completable . from action ( new  action (  )  {  @ override public void run (  )  throws  exceptio
@ override protected void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  subscriber . set ( s )  ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   single . just ( 1 )  . subscribe ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer t )  throws  exception  {  th
public void   (  simple timer .  timed event event long ms to wait )  {     timer . add event ( event ms to wait )  ;   }  
public static void   ( @ nullable  function <  ?  super  callable <  scheduler >   ?  extends  scheduler >  handler )  {  if  ( lockdown )   {  throw new  illegal state exception ( " plugins can't be changed anymore" )  ;   }  on init new thread handler = handler ;   }  
@ override public  string   (  )  {  return " failed establish state: " ;   }  
@ override public  integer   (  )  {  if  (  -  - crash on next  <  =  0 )   {  throw new  test exception ( "next (  ) " )  ;   }  return count +  +  ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable . just ( 1 2 3 4 5 6 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . first element (  )  ;  
static  string   ( int mode )  {  switch  ( mode )   {  case  queue subscription . none: return "none" ;  case  queue subscription . sync: return "sync" ;  case  queue subscription . async: return "async" ;  default : return " unknown ( "  +  mode  +  " ) " ;   }   }  
  (  subscriber < t >  subscriber )  {  this . subscriber = subscriber ;   }  
int   (  hash peer )  {  synchronized  (    unheard from )   {     unheard from . remove ( peer )  ;  return decrement remaining (  )  ;   }   }  
public void   ( com . android . mail . providers .  account account )  {  final  bundle args =  account settings edit quick responses fragment . create args ( account )  ;  final  preference activity activity =  (  preference activity ) get activity (  )  ;  activity . start preference panel (  account settings edit quick responses fragment . class . get name (  )  args r . string . account   settings   edit   quick   responses   label null null 0 )  ;   }  
public static void   (  )  {   array list <  private mix >  mixes = new  array list (  )  ;  synchronized  ( mix map )   {   set <  conference member >  key set = mix map . key set (  )  ;  for  (   conference member member with mix : key set )   {   hash map <  conference member double[] >  mixes to apply = mix map . get ( member with mix )  ;   set <  conference member >  member set = mixes to apply . key set (  )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " applying "  +  member set . size (  )   +  " private mixes for " +  member with mix )  ;   }  for  (   conference member member : member set )   {  double[] spatial values =  ( double[] ) mixes to apply . get ( member )  ;  mixes . add ( new  private mix ( member with mix member spatial values )  )  ;  pm count +  +  ;   }   }  mix map . clear (  )  ;   }  for  (   private mix mix : mixes )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " applying pm for "  +  mix . member with mix  +  " from " +  mix . member +  " " +  mix . spatial values[0] +  ":" +  mix . spatial values[1] +  ":" +  mix . spatial values[2] +  ":" +  mix . spatial values[3] )  ;   }  synchronized  ( mix . member . get conference manager (  )  )   {  mix . member with mix . apply private mix ( mix . member mix . spatial values )  ;   }   }   }  
private boolean   (  )  {   string url =    context . get property (  config update handler . prop   dev   su3   url )  ;  return url  !  =  null && url . length (  )   >  0 &&    context . get boolean property (  config update handler . prop   update   dev   su3 )  &&  !  news helper . dont install (    context )  ;   }  
public static  string   (  string base url  string .  .  .  paths )  {   string path = concat uris ( paths )  ;  if  (  string utils . is blank ( path )  )   {  return base url ;   }   string builder url ;  if  ( base url . ends with ( " / " )  )   {  url = new  string builder ( base url . substring ( 0 base url . length (  )   -  1 )  )  ;   }  else  {  url = new  string builder ( base url )  ;   }  return url . append ( path )  . to string (  )  ;   }  
@ test public void   (  )  {  assert equals ( "v1 . 1" tokenizer . get version id (  )  )  ;   }  
@ override public void   ( final  throwable e )  {  set . add ( scheduler . schedule direct ( new  on error ( e )  delay error  ?  delay : 0 unit )  )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  throws  interrupted exception  {  final  atomic reference <  string >  name = new  atomic reference <  string >  (  )  ;  final  count down latch cdl = new  count down latch ( 1 )  ;  normal . completable . d
public   (  published item item )  {  this . item = item ;   }  
public static  plugin manager   (  )  {  return plugin manager ;   }  
@ override public void   (  servlet config servlet config )  throws  servlet exception  {  super . init ( servlet config )  ;   auth check filter . add exclude ( servlet   url )  ;   }  
public void   (  string username )  {  this . username = username ;  save properties (  )  ;   }  
public static int   (  )  {  return sip config . local port ;   }  
public  map <  string  string >    (  string method  string uri )  throws io exception  {   map <  string  string >  rv = new  hash map <  string  string >  ( 12 )  ;   string realm = args . get ( "realm" )  ;   string nonce = args . get ( "nonce" )  ;   string qop = args . get ( "qop" )  ;   string opaque = args . get ( "opaque" )  ;  if  ( realm  =  =  null || nonce  =  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( " bad digest request: "  +   data helper . to string ( args )  )  ;  throw new io exception ( " bad auth response" )  ;   }  rv . put ( "username" '"'  +  username  +  '"' )  ;  rv . put ( "realm" '"'  +  realm  +  '"' )  ;  rv . put ( "nonce" '"'  +  nonce  +  '"' )  ;  rv . put ( "uri" '"'  +  uri  +  '"' )  ;  if  ( opaque  !  =  null )  rv . put ( "opaque" '"'  +  opaque  +  '"' )  ;   string kd middle ;  if  ( "auth" . equals ( qop )  )   {  rv . put ( "qop" "\"auth\"" )  ;  if  ( cnonce  =  =  null )   {  byte[] rand = new byte[5] ;     context . random (  )  . next bytes ( rand )  ;  cnonce =  base32 . encode ( rand )  ;   }  rv . put ( "cnonce" '"'  +  cnonce  +  '"' )  ;   string nc = lc8hex (  +  + nonce count )  ;  rv . put ( "nc" nc )  ;  kd middle = ':'  +  nc  +  ':' +  cnonce +  ':' +  qop ;   }  else  {  kd middle = "" ;   }   string ha1 =  password manager . md5 hex ( username  +  ':'  +  realm +  ':' +  password )  ;   string a2 = method  +  ':'  +  uri ;   string ha2 =  password manager . md5 hex ( a2 )  ;   string kd = ha1  +  ':'  +  nonce +  kd middle +  ':' +  ha2 ;  rv . put ( "response" '"'  +   password manager . md5 hex ( kd )   +  '"' )  ;  return rv ;   }  
public void   (  )  {   property event dispatcher . remove listener ( this )  ;   connection manager impl conn manager =  (  connection manager impl ) xmpp server . get instance (  )  . get connection manager (  )  ;  remove filter from chain ( conn manager . get socket acceptor (  )   raw print filter . filter   name )  ;  remove filter from chain ( conn manager . getssl socket acceptor (  )   raw print filter . filter   name )  ;  remove filter from chain ( conn manager . get component acceptor (  )   raw print filter . filter   name )  ;  remove filter from chain ( conn manager . get multiplexer socket acceptor (  )   raw print filter . filter   name )  ;  if  ( default port filter  !  =  null )   {  default port filter . shutdown (  )  ;   }  if  ( old port filter  !  =  null )   {  old port filter . shutdown (  )  ;   }  if  ( component port filter  !  =  null )   {  component port filter . shutdown (  )  ;   }  if  ( multiplexer port filter  !  =  null )   {  multiplexer port filter . shutdown (  )  ;   }   interceptor manager . get instance (  )  . remove interceptor ( interpreted printer )  ;  default port filter = null ;  old port filter = null ;  component port filter = null ;  interpreted printer = null ;  multiplexer port filter = null ;   }  
  (  completable observer actual  atomic boolean once  composite disposable set int n )  {  this . actual = actual ;  this . once = once ;  this . set = set ;  this . lazy set ( n )  ;   }  
@ test public void   (  )  throws io exception  {  final  file output file =  file . create temp file ( "test" " . oxo   g   metrics" test   data   dir )  ;  output file . delete on exit (  )  ;  final  string[] args = new  string[] { "input = "  +  sam  
public  string   (  )  {  return name ;   }  
@ override public void   (  string column label float x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  )  {  if  ( compare and set ( false true )  )   {  parent . remove ( this )  ;   }   }  
@ test public void   (  )  {   single . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable
public long   (  )  {  return rtp timestamp  -  previous rtp timestamp ;   }  
public  proxy credentials   (  )  {  return proxy credentials ;   }  
public final static  string   (  )  {  int addr cnt = getn host addresses (  )  ;  for  ( int n = 0 ;  n  <  addr cnt ;  n +  +  )   {   string addr = get host address ( n )  ;  if  ( isi pv4 address ( addr )   =  =  true )  return addr ;   }  return "" ;   }  
public static void   (  string domain )  {  delete configuration ( domain )  ;   remote server configuration config = new  remote server configuration ( domain )  ;  config . set permission (  permission . blocked )  ;  add configuration ( config )  ;  for  (   session session :  session manager . get instance (  )  . get incoming server sessions ( domain )  )   {   log . debug ( " closing session for domain ' {  } ' as the domain is being blocked .   affected session:  {  } " domain session )  ;  session . close (  )  ;   }  for  (   domain pair domain pair :  session manager . get instance (  )  . get outgoing domain pairs (  )  )   {  if  ( domain pair . get remote (  )  . equals ( domain )  )   {   session session =  session manager . get instance (  )  . get outgoing server session ( domain pair )  ;   log . debug ( " closing  ( domain - pair )  session for domain ' {  } ' as the domain is being blocked .   affected session:  {  } " domain session )  ;  session . close (  )  ;   }   }   }  
void   ( double minval double maxval boolean force legend )  {  legend . enabled& =  ( force legend ||  ( value  >  =  minval && value  <  =  maxval )  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable flowable <  integer >  cf =  flowable .  <  integer > empty (  )  . publish (  )  ;   runnable r1 = new  runnable (  )  {  @
public int   (  )  {  return status code ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts =  flowable . just ( 1 )  . switch map (  functions . just function ( pp )  )  . test (  )  ;  assert true ( pp . ha
@ suppress warnings ( "deprecation" )  static void   ( sq lite database db )  {   string s = "  ( "  +   body columns .    id  +  " integer primary key autoincrement  " +   body columns . message   key +  " integer  " +   body columns . html   content +  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   single . concat (  arrays . as list ( just1 null )  )  . blocking subscribe (  )  ;   }  
public void   ( boolean append )  {     append = append ;   }  
public boolean   (  )  {  return restart needed ;   }  
private void   ( final int check firstn records final  file replacement header final boolean enforce sample samples )  throws io exception  {  final  fix vcf header program = new  fix vcf header (  )  ;  final  file output vcf =  vcf test utils . create temporary indexed file ( "output . " " . vcf" )  ;  program . input = input   vcf ;  program . output = output vcf ;  if  ( replacement header  =  =  null )   {  program . check   first   n   records = check firstn records ;   }  else  {  program . header = replacement header ;  program . enforce   same   samples = enforce sample samples ;   }   assert . assert equals ( program . instance main ( new  string[0] )  0 )  ;  io util . assert files equal ( output   vcf output vcf )  ;   }  
public int[]   (  )  {  if  ( parts . size (  )   =  =  0 )   {  return new int[] {  }  ;   }   statement stmt ;  try  {  try  {  stmt = get handle (  )  . get statement builder (  )  . create ( get handle (  )  . get connection (  )  get context (  )  )  ;  add cleanable ( stmt::close )  ;   }  catch  (  sql exception e )   {  throw new  unable to create statement exception ( e get context (  )  )  ;   }  log . trace ( " execute batch [" )  ;  try  {  for  (   string part : parts )   {  final  string sql = get config (  sql statements . class )  . get template engine (  )  . render ( part get context (  )  )  ;  log . trace ( "  {  } " sql )  ;  stmt . add batch ( sql )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( " unable to configure jdbc statement" e get context (  )  )  ;   }  try  {  final long start =  system . nano time (  )  ;  final int[] rs = stmt . execute batch (  )  ;  final long elapsed time =  system . nano time (  )   -  start ;  log . trace ( "] executed in  {  } ms" elapsed time  /  1000000l )  ;  get config (  sql statements . class )  . get timing collector (  )  . collect ( elapsed time get context (  )  )  ;  return rs ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( munge batch exception ( e )  get context (  )  )  ;   }   }  finally  {  close (  )  ;   }   }  
public void   ( long delta )  {  if  ( delta  >   - 60 * 1000 && delta  <  60 * 1000 )  return ;  synchronized  (    state lock )   {  if  ( graceful shutdown in progress (  )  ||  ! is alive (  )  )  return ;   }     event log . add event (  event log . clock   shift  long . to string ( delta )  )  ;     context . router key generator (  )  . generate date based mod data (  )  ;  if  ( delta  >  0 )     log . error ( " restarting after large clock shift forward by "  +   data helper . format duration ( delta )  )  ;  else    log . error ( " restarting after large clock shift backward by "  +   data helper . format duration ( 0  -  delta )  )  ;  restart (  )  ;   }  
public static void   (  string caller  account expect  account actual )  {  if  ( expect  =  =  actual )   {  return ;   }  assert email content equal ( caller expect actual )  ;  assert equals ( caller  +  " m display name" expect . m display name actual . m display name )  ;  assert equals ( caller  +  " m email address" expect . m email address actual . m email address )  ;  assert equals ( caller  +  " m sync key" expect . m sync key actual . m sync key )  ;  assert equals ( caller  +  " m sync lookback" expect . m sync lookback actual . m sync lookback )  ;  assert equals ( caller  +  " m sync interval" expect . m sync interval actual . m sync interval )  ;  assert equals ( caller  +  " m host auth key recv" expect . m host auth key recv actual . m host auth key recv )  ;  assert equals ( caller  +  " m host auth key send" expect . m host auth key send actual . m host auth key send )  ;  assert equals ( caller  +  " m flags" expect . m flags actual . m flags )  ;  assert equals ( caller  +  " m sender name" expect . m sender name actual . m sender name )  ;  assert equals ( caller  +  " m protocol version" expect . m protocol version actual . m protocol version )  ;  assert equals ( caller  +  " m security sync key" expect . m security sync key actual . m security sync key )  ;  assert equals ( caller  +  " m signature" expect . m signature actual . m signature )  ;  assert equals ( caller  +  " m policy key" expect . m policy key actual . m policy key )  ;  assert equals ( caller  +  " m ping duration" expect . m ping duration actual . m ping duration )  ;   }  
@ override public  input source   (  string public id  string system id )  throws sax exception  io exception  {  log . warn (  ( allow entities  ?  " resolving" : " removing" )   +  "  entity[public id = '"  +   ( public id  !  =  null  ?  public id : ""
@ override protected void   (  maybe observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  mo ref . set ( observer )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  if  ( s instanceof  conditional subscriber )   {  source . subscribe ( new  do after conditional subscriber < t >  (  (  conditional subscriber <  ?  super t >  ) s on after next )  )  ;  
public  string   (  )  {  return clean ( currentcss )  ;   }  
@ override public  string   (  http servlet request request  http servlet response response )  {   string message = null ;  if  ( response instanceof  http servlet response wrapper )   {  message =  (  (  http servlet response wrapper ) response )  . get 
@ test public void   (  )  {   subject <  string >  obs =  publish subject . create (  )  ;   iterator <  string >  it = next ( obs )  . iterator (  )  ;  fire on next in new thread ( obs "one" )  ;  assert equals ( "one" it . next (  )  )  ;  fire on nex
@ test public void   (  )  {   publish processor <  integer >  source1 =  publish processor . create (  )  ;   publish processor <  integer >  source2 =  publish processor . create (  )  ;   flowable <  flowable <  integer >  >  m = source1 . group join (
  (  subscriber <  ?  super  long >  actual )  {  this . actual = actual ;   }  
boolean   (  )  {  return coefficients[0]  =  =  0 ;   }  
private void   (  reconfigure session message message )  {   session id id = message . get session id (  )  ;   session config cfg =    runner . get config ( id )  ;  if  ( cfg  =  =  null )   {   list <  session id >  current =    runner . get session ids (  )  ;   string msg = " reconfigure session invalid session: "  +  id  +  " current: " +  current ;  if  (    log . should log (  log . error )  )     log . error ( msg )  ;     runner . disconnect client ( msg )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " updating options  -  old: "  +  cfg  +  " new: " +  message . get session config (  )  )  ;  if  (  ! message . get session config (  )  . get destination (  )  . equals ( cfg . get destination (  )  )  )   {     log . error ( " dest mismatch" )  ;  send status message ( id  session status message . status   invalid )  ;     runner . stop running (  )  ;  return ;   }   hash dest = cfg . get destination (  )  . calculate hash (  )  ;  cfg . get options (  )  . put all ( message . get session config (  )  . get options (  )  )  ;   client tunnel settings settings = new  client tunnel settings ( dest )  ;   properties props = new  properties (  )  ;  props . put all ( cfg . get options (  )  )  ;  settings . read from properties ( props )  ;     context . tunnel manager (  )  . set inbound settings ( dest settings . get inbound settings (  )  )  ;     context . tunnel manager (  )  . set outbound settings ( dest settings . get outbound settings (  )  )  ;  send status message ( id  session status message . status   updated )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . take last ( 1 1  time unit . seconds null )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . combine latest delay error (  arrays . as list (  observable . never (  )  null )  new  function <  object[]  object >  (  )  
private void   ( int max cached entries )  {  if  (    max cached  >  =  max cached entries )  return ;     max cached = max cached entries ;   queue <  byte array >  newlbq = new  linked blocking queue <  byte array >  ( max cached entries )  ;   byte array ba ;  while  (  ( ba =    available . poll (  )  )   !  =  null )  newlbq . offer ( ba )  ;     available = newlbq ;   }  
public static void   (  uri .  builder b  string account name )  {  if  ( account name  !  =  null )   {  b . append query parameter ( account   name   param account name )  ;   }   }  
@ override public void   (  jdbi db )  {  db . register argument ( new  typed enum argument factory (  )  )  ;  db . register argument ( new  java time argument factory (  )  )  ;  db . register argument ( new  duration argument factory (  )  )  ;  db . r
@ override public  flowable <  integer >    (  integer v )  throws  exception  {  return  flowable . never (  )  ;   }  
@ test public void   (  )  {   mime type media type =  mime type . get matching mime type ( "application / vnd . rackspace . services . a - v1 . 0 + xml" )  ;   media type one media range = new  media type ( "application / vnd . rackspace . services . a -
static  hash set <  integer >    (  integer .  .  .  values )  {  return new  hash set <  integer >  (  arrays . as list ( values )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . merge array ( new  maybe <  integer >  (  )  {  @ override protected void subscribe actual (   maybe observer <  ?  super  integer >  observer )  {  observer . on subscribe (  dis
@ override public int   (  )  {  lock . read lock (  )  . lock (  )  ;  try  {  return users cache . size (  )  ;   }  finally  {  lock . read lock (  )  . unlock (  )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . sequence equal (  flowable . just ( 1 )   flowable . just ( 2 )  )  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   completable subject cs =  completable subject . create (  )  ;   test observer <  void >  to = ps . concat map completable delay error (  functions . jus
@ test public void   (  )  {  new  parallel flowable <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  integer > [] subscribers )  {  subscribers[0] . on subscribe ( new  boolean subscription (  )  )  ;  subscribers[0] . 
public   ( i2p app context ctx  log log  list <  simple timer .  timed event >  events  simple store x )  {     context = ctx ;     log = log ;     ready events = events ;  runn = x ;   }  
private synchronized void   (  string stat group )  {  if  (    failed lookup rate  =  =  null )     failed lookup rate = new  rate stat ( "db history . failed lookup rate" " how often does this peer to respond to a lookup ? " stat group new long[] { 10 * 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;  if  (    invalid reply rate  =  =  null )     invalid reply rate = new  rate stat ( "db history . invalid reply rate" " how often does this peer give us a bad  ( nonexistant  forged  etc )  peer ? " stat group new long[] { 30 * 60 * 1000l }  )  ;     failed lookup rate . set stat log (    context . stat manager (  )  . get stat log (  )  )  ;     invalid reply rate . set stat log (    context . stat manager (  )  . get stat log (  )  )  ;   }  
public   (  flowable < t >  source  predicate <  ?  super t >  predicate )  {  this . source = source ;  this . predicate = predicate ;   }  
public void   (  account account )  {  final  intent intent =  account server settings activity . get intent for outgoing ( get activity (  )  account )  ;  get activity (  )  . start activity ( intent )  ;   }  
public static  string builder   (  string builder sb int b )  {  b& = 0xff ;  sb . append ( "0123456789abcdef" . char at ( b  >  >  4 )  )  ;  sb . append ( "0123456789abcdef" . char at ( b & 0xf )  )  ;  return sb ;   }  
  (  string username )  {  final  roster manager roster manager = xmpp server . get instance (  )  . get roster manager (  )  ;  this . username = username ;   collection <  group >  shared groups = roster manager . get shared groups ( username )  ;   iterator <  roster item >  items =  roster manager . get roster item provider (  )  . get items ( username )  ;  while  ( items . has next (  )  )   {   roster item item = items . next (  )  ;  for  (   group group : shared groups )   {  if  ( group . is user ( item . get jid (  )  )  )   {  item . add shared group ( group )  ;  item . set sub status (  roster item . sub   both )  ;   }   }  roster items . put ( item . get jid (  )  . to barejid (  )  item )  ;   }   map < jid  list <  group >  >  shared users = get shared users ( shared groups )  ;  for  (   map .  entry < jid  list <  group >  >  entry : shared users . entry set (  )  )   {  jid jid = entry . get key (  )  ;   list <  group >  groups = entry . get value (  )  ;  try  {   collection <  group >  item groups = new  array list <  >  (  )  ;   string nickname = "" ;   roster item item = new  roster item ( jid  roster item . sub   to  roster item . ask   none  roster item . recv   none nickname null )  ;  for  (   group group : groups )   {  if  ( group . is user ( jid )  )   {  item . add shared group ( group )  ;  item groups . add ( group )  ;   }  else  {  item . add invisible shared group ( group )  ;   }   }  if  ( roster manager . has mutual visibility ( username shared groups jid item groups )  )   {  item . set sub status (  roster item . sub   both )  ;   }  else  {  boolean belongs to group = false ;  for  (   group group : groups )   {  if  ( group . is user ( jid )  )   {  belongs to group = true ;   }   }  if  (  ! belongs to group )   {  item . set sub status (  roster item . sub   from )  ;   }   }  if  ( item . get sub status (  )   !  =   roster item . sub   from )   {  item . set nickname (  user name manager . get user name ( jid )  )  ;  roster items . put ( item . get jid (  )  . to barejid (  )  item )  ;   }  else  {  implicit from . put ( item . get jid (  )  . to barejid (  )  item . get invisible shared groups names (  )  )  ;   }   }  catch  (   user not found exception e )   {   log . error ( " groups  ( "  +  groups  +  " )  include non - existent username  ( " +  jid . get node (  )  +  " ) " )  ;   }   }   roster event dispatcher . roster loaded ( this )  ;   }  
public int   (  )  {  return lane number ;   }  
@ override public boolean   (  node node jid owner jid subscriber )  {  if  ( node . is admin ( owner )  )   {  return true ;   }   node affiliate node affiliate = node . get affiliate ( owner )  ;  if  ( node affiliate  =  =  null )   {  return false ;  
@ test public void   (  )  {  test helper ( "genomic   sorted   5 . sam" "genomic   sorted   5   plus . sam" 3 2 0 0 0 3 0 false )  ;   }  
@ test public void   (  )  {  final  blocking multi observer <  integer >  bmo = new  blocking multi observer <  integer >  (  )  ;   schedulers . single (  )  . schedule direct ( new  runnable (  )  {  @ override public void run (  )  {  bmo . on error (
synchronized boolean   ( t object )  {  return m map . contains key ( object )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  {  return just1 ;   }   }   ne
@ test public void   (  )  {  final  object[] result =  { null null }  ;   disposable d =  single .  <  integer > error ( new io exception (  )  )  . subscribe ( new  bi consumer <  integer  throwable >  (  )  {  @ override public void accept (   integer 
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ override public void on next (   integer t )  {  if  ( t  =  =  1 )   
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  ex
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  long i = index ;  if  ( i  =  =  0 )   {  if  (  ! cancelled )   {  get and increment (  )  ;   unicast processor < t >  w =  unicast processor .  < t > create ( buffer size this )  ;  w
public  page view   (  )  {  if  ( views . size (  )   >  0 )   {  return views . get ( views . size (  )   -  1 )  ;   }  return null ;   }  
int   (  )  {  return m tasks . size (  )  ;   }  
@ test public void   (  )  {   publish subject <  string >  r1 =  publish subject . create (  )  ;   observer <  string >  o =  test helper . mock observer (  )  ;   in order io = in order ( o )  ;   iterable <  string >  r2 =  arrays . as list (  )  ;  r
@ override public  type[]   (  )  {  return to array ( upper bounds )  ;   }  
  ( t[] array )  {  this . array = array ;   }  
private int   (  string t )  {   string pfx = "tunnel . build"  +  t ;  int timeout = get events ( pfx  +  " expire" 10 * 60 * 1000 )  ;  int reject = get events ( pfx  +  " reject" 10 * 60 * 1000 )  ;  int accept = get events ( pfx  +  " success" 10 * 60 * 1000 )  ;  if  ( accept  +  reject  +  timeout  <  =  0 )  return 0 ;  double pct =  ( double )  ( reject  +  timeout )   /   ( accept  +  reject  +  timeout )  ;  return  ( int )  ( 100 * pct )  ;   }  
private  fastq writer   (  )  {  return first of pair ;   }  
void   (  workgroup workgroup )  {   workgroup .  status new status = workgroup . get status (  )  ;   workgroup .  status old status = workgroup open status . put ( workgroup . getid (  )  new status )  ;  if  (  workgroup .  status . open  !  =  old status &&  workgroup .  status . open  =  =  new status )   {  workgroup . notify opened (  )  ;   }  else if  (  workgroup .  status . open  =  =  old status &&  workgroup .  status . open  !  =  new status )   {  workgroup . notify closed (  )  ;   }   }  
@ override public synchronized  set <  group >    (  )  {   set <  group >  result = new  hash set <  >  (  )  ;  for  (   string group name : get known group names from keys (  )  )   {   group resolved =  group . resolve from ( group name )  ;  if  ( re
@ override public synchronized boolean   (  )  {  return socket accept thread  !  =  null ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  ts . on subscribe ( new  boolean subscription (  )  )  ;  ts . assert not fuseable (  )  ;  try  {  ts . assert fuseable (  )  ;  throw new  runtime excep
@ override public boolean   (  integer v )  {  return true ;   }  
public void   (  string title )  {  this . title = title ;   }  
@ test public void   (  )  {   completable subject cs =  completable subject . create (  )  ;   test observer <  void >  to = cs . test (  )  ;  cs . on complete (  )  ;   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  c
public boolean   (  )  {  return  ( ver major  =  =  1 )  ;   }  
public  string   (  )  {  return to recording file ;   }  
@ test public void   (  )  throws sql exception  {  assert that ( unit . build (  tuple0 . class null )  )  . is empty (  )  ;   }  
public  string   (  )  throws  rrd exception  {   string[] names = get source names (  )  ;  double[][] values = get values (  )  ;   string builder buffer = new  string builder (  )  ;  buffer . append ( format ( "timestamp" 12 )  )  ;  for  (   string name : names )   {  buffer . append ( format ( name 20 )  )  ;   }  buffer . append ( "\n" )  ;  for  ( int i = 0 ;  i  <  timestamps . length ;  i +  +  )   {  buffer . append ( format ( ""  +  timestamps[i] 12 )  )  ;  for  ( int j = 0 ;  j  <  names . length ;  j +  +  )   {  buffer . append ( format (  util . format double ( values[j][i] )  20 )  )  ;   }  buffer . append ( "\n" )  ;   }  return buffer . to string (  )  ;   }  
@ deprecated public  long   (  string event name )  {  if  (    log . should log (  log . info )  )   {  synchronized  ( this )   {  locked   init timestamps (  )  ;  return    timestamps . get ( event name )  ;   }   }  return  long . value of ( 0 )  ;  
@ test public void   (  )  {   single <  integer >  result =  observable . just ( 1 2 3 4 5 )  . reduce ( 0 sum )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )  {  return v ;   }   }   )  ;  result
@ override public void   (  )  {  it = null ;   }  
@ override public void   (  )  {  pp2 . on error ( ex2 )  ;   }  
@ override public  maybe <  boolean >    (  maybe <  object >  f )  throws  exception  {  return f . is empty (  )  . to maybe (  )  ;   }  
public static void   (  string username  string status )  throws sql exception  {  if  ( sip plugin )   {   string sql = "update of sip user set status  =   ?   enabled  =   ?  where username  =   ? " ;   connection con = null ;   prepared statement psmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  psmt = con . prepare statement ( sql )  ;  psmt . set string ( 1 status )  ;  psmt . set int ( 2 1 )  ;  psmt . set string ( 3 username )  ;  psmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . info ( "update status "  +  e )  ;   }  finally  {   db connection manager . close connection ( psmt con )  ;   }   }   }  
public void   (  long registrationid )  throws sql exception  {   connection con = null ;   prepared statement pstmt = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;  pstmt = con . prepare statement ( remove   roster )  ;  pstmt . set long ( 1 registrationid )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {  abort transaction = true ;  throw sqle ;   }  finally  {   db connection manager . close transaction connection ( pstmt con abort transaction )  ;   }   }  
public  boolean   (  )  {  return    padding ;   }  
public   (  big integer x  el gamal parameter spec spec )  {  super ( spec )  ;  this . x = x ;   }  
@ xml element public  string   (  )  {  return description ;   }  
@ test public void   (  )  {   assert . assert true ( r executor . execute from classpath ( "failing . r" )   !  =  0 )  ;   }  
private void   ( boolean can proceed  presence presence )  {  try  {  if  (  presence .  type . subscribe  =  =  presence . get type (  )  )   {   presence reply = new  presence (  )  ;  reply . set to ( presence . get from (  )  )  ;  reply . set from ( presence . get to (  )  )  ;  reply . set type ( can proceed  ?   presence .  type . subscribed :  presence .  type . unsubscribed )  ;  component manager . send packet ( this reply )  ;   }  else if  (  presence .  type . unsubscribe  =  =  presence . get type (  )  )   {   presence reply = new  presence (  )  ;  reply . set to ( presence . get from (  )  )  ;  reply . set from ( presence . get to (  )  )  ;  reply . set type (  presence .  type . unsubscribed )  ;  component manager . send packet ( this reply )  ;  if  (  ! can proceed )   {  reply = new  presence (  )  ;  reply . set to ( presence . get from (  )  )  ;  reply . set from ( presence . get to (  )  )  ;  reply . set type (  presence .  type . unavailable )  ;  component manager . send packet ( this reply )  ;   }   }  else if  (  presence .  type . probe  =  =  presence . get type (  )  )   {   presence reply = new  presence (  )  ;  reply . set to ( presence . get from (  )  )  ;  reply . set from ( presence . get to (  )  )  ;  if  (  ! can proceed )   {  reply . set error (  packet error .  condition . forbidden )  ;   }  component manager . send packet ( this reply )  ;   }   }  catch  (   component exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
public   ( i2p session sess  destination dest boolean raw )  {  this . sess = sess ;  this . dest = dest ;  this . raw = raw ;  if  ( raw )   {  this . maker = null ;   }  else  {  this . maker = new i2p datagram maker (  )  ;  this . maker . seti2p datagram maker ( this . sess )  ;   }   }  
public int   (  )  {  return count (    failing peers )  ;   }  
@ test ( data provider = "targeted interval data provider" )  public void   ( final  file input final  file outfile final  file per target outfile final  string reference file final  string target intervals final int sample size )  throws io exception  { 
public   (  string message )  {  super ( message )  ;   }  
private void   (  string subdomain )  {  subdomains . add ( subdomain )  ;   }  
  (  subscriber < t >  subscriber )  {  this . subscriber = subscriber ;   }  
public void   (  string message )  {   jive globals . set property ( subject message )  ;   }  
@ override public void   ( byte data[] )  throws  data format exception  {  if  ( data  =  =  null )  throw new  data format exception ( " null data passed in" )  ;  if  ( data . length  !  =  length (  )  )  throw new  data format exception ( " bad data 
public void   ( final  metrics file <  quality yield metrics  integer >  metrics file )  {  metrics file . add metric ( metrics )  ;   }  
protected static  string   (  async context context )  {   string remote address = null ;  if  ( context . get request (  )   !  =  null && context . get request (  )  . get remote addr (  )   !  =  null )   {  remote address = context . get request (  )  . get remote addr (  )  ;   }  if  ( remote address  =  =  null || remote address . trim (  )  . length (  )   =  =  0 )   {  remote address = " < unknown address > " ;   }  return remote address ;   }  
public void   (  )  throws io exception   rrd exception  {  extract defs (  )  ;  fetch rrd data (  )  ;  fix zero ending timestamp (  )  ;  choose optimal step (  )  ;  create timestamps (  )  ;  assign timestamps to sources (  )  ;  normalize rrd values (  )  ;  calculate non rrd sources (  )  ;   }  
private void   (  user user )  {  if  (  log . is debug enabled (  )  )   {   log . debug ( " registration plugin : adding default privacy list . " )  ;   log . debug ( "\t name  =  "  +  get privacy list name (  )  )  ;   log . debug ( "\t content  =  "  +  get privacy list (  )  )  ;   }  if  (  ! privacy list cache is set )   {  privacy list cache is set = true ;  try  {   document document =  document helper . parse text ( get privacy list (  )  )  ;  privacy list cache = document . get root element (  )  ;   }  catch  (   document exception e )   {   log . error ( e . get message (  )  e )  ;   }  if  ( privacy list cache  =  =  null )   {   log . error ( "registration . privacylist can not be parsed into a valid privacy list" )  ;   }   }  if  ( privacy list cache  !  =  null )   {   privacy list manager privacy list manager =  privacy list manager . get instance (  )  ;   privacy list new privacy list = privacy list manager . create privacy list ( user . get username (  )  get privacy list name (  )  privacy list cache )  ;  privacy list manager . change default list ( user . get username (  )  new privacy list null )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ check return value @ scheduler support (  scheduler support . none )  public final  < r >  single < r >    (  single transformer <  ?  super t  ?  extends r >  transformer )  {  return wrap (  (  (  single transforme
public   (  )  {  super (    context . simple timer2 (  )  verify   usage   time )  ;   }  
  (  replay processor <  string >  processor )  {  this . processor = processor ;   }  
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . contains ( 2 )  . test (  )  . assert result ( false )  ;   }  
protected void   ( long request size )  {  this . accumulated request size +  = request size ;  if  ( request size  <  min request size || min request size  =  =  0 )   {  min request size = request size ;   }  if  ( request size  >  max request size )   {  max request size = request size ;   }   }  
public int   (  )  {  return    port ;   }  
@ override public void   (  )  {  main done = true ;  drain (  )  ;   }  
@ test public void   (  )  {   signing private key signing private key = new  signing private key (  )  ;  byte data[] = new byte[ signing private key . keysize   bytes] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )  data[i] =  ( byte )  ( i % 5
@ test public void   (  )  throws  exception  {   test subscriber <  string >  s = new  test subscriber <  string >  ( 10l )  ;  final  atomic long innerr = new  atomic long (  )  ;   flowable operator <  string  string >  o = new  flowable operator <  st
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  )  {  return  rx java plugins . on assembly ( new  completable hide ( this )  )  ;   }  
private void   (  inbound establish state state )  {  if  (    log . should log (  log . debug )  )     log . debug ( " send created to: "  +  state )  ;  try  {  state . generate session key (  )  ;   }  catch  (  dh session key builder .  invalid public parameter exception ippe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " peer "  +  state  +  " sent us an invalid dh parameter" ippe )  ;     inbound states . remove ( state . get remote host id (  )  )  ;  state . fail (  )  ;  return ;   }  udp packet pkt =    builder . build session created packet ( state    transport . get external port ( state . get sentip (  )  . length  =  =  16 )     transport . get intro key (  )  )  ;  if  ( pkt  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " peer "  +  state  +  " sent us an invalid ip ? " )  ;     inbound states . remove ( state . get remote host id (  )  )  ;  state . fail (  )  ;  return ;   }     transport . send ( pkt )  ;  state . created packet sent (  )  ;   }  
@ test public void   (  )  {  assert same (  maybe . empty (  )   maybe . wrap (  maybe . empty (  )  )  )  ;   }  
public static void   (  )  {  content   uri =  uri . parse (  email content . content   uri  +  " / credential" )  ;   }  
@ override protected void   ( final  maybe observer <  ?  super  long >  observer )  {   timer disposable parent = new  timer disposable ( observer )  ;  observer . on subscribe ( parent )  ;  parent . set future ( scheduler . schedule direct ( parent del
public synchronized boolean   (  hash h )  {  if  (    total max  >  0 )   {  if  (    total throttle until  >  0 )   {  if  (    total throttle until  >   clock . get instance (  )  . now (  )  )  return true ;     total throttle until = 0 ;   }   }  if  (    max  >  0 )   {   record rec =    peers . get ( h )  ;  if  ( rec  !  =  null )   {  if  ( rec . get until (  )   >  0 )  return true ;  rec . increment (  )  ;  long now =  clock . get instance (  )  . now (  )  ;  if  ( rec . count since ( now  -     check period )   >     max )   {  long until = now  +     throttle period ;   string date =    fmt . format ( new  date ( until )  )  ;     log . log always (  log . warn " throttling "  +     action  +  " until " +  date +  " after exceeding max of " +     max +  " in " +   data helper . format duration (    check period )  +  ": " +  h . to base64 (  )  )  ;  rec . ban ( until )  ;  return true ;   }   }  else  {     peers . put ( h new  record (  )  )  ;   }   }  if  (    total max  >  0 &&  +  +    current total  >     total max )   {  if  (    total throttle until  =  =  0 )   {     total throttle until =  clock . get instance (  )  . now (  )   +     total throttle period ;   string date =    fmt . format ( new  date (    total throttle until )  )  ;     log . log always (  log . warn "***  throttling "  +     action  +  " from all peers until " +  date +  " after exceeding max of " +     max +  " in " +   data helper . format duration (    check period )  )  ;   }  return true ;   }  return false ;   }  
public void   (  )  {     keep decaying = false ;     decay event . cancel (  )  ;   }  
public  string   (  )  {  return default protocol ;   }  
@ nullable @ override public t   (  )  throws  exception  {  t v ;  try  {  v = qs . poll (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  try  {  on error . accept ( ex )  ;   }  catch  (   throwable exc )   {  throw ne
public static  user entity   (  user user )  {   user entity user entity = new  user entity ( user . get username (  )  user . get name (  )  user . get email (  )  )  ;   list <  user property >  user properties = new  array list <  user property >  (  )  ;  for  (   entry <  string  string >  property : user . get properties (  )  . entry set (  )  )   {  user properties . add ( new  user property ( property . get key (  )  property . get value (  )  )  )  ;   }  user entity . set properties ( user properties )  ;  return user entity ;   }  
public  connection   ( long timeout ms )  throws  router restart exception   connect exception   socket timeout exception  {  if  (    log . should log (  log . debug )  )     log . debug ( " accept ( "  +  timeout ms  +  " )  called" )  ;  long expiration = timeout ms  +     context . clock (  )  . now (  )  ;  while  ( true )   {  if  (  ( timeout ms  >  0 )  &&  ( expiration  <     context . clock (  )  . now (  )  )  )  throw new  socket timeout exception ( "accept (  )  timed out" )  ;  if  (  !    active )   {  while  ( true )   {   packet packet =    syn queue . poll (  )  ;  if  ( packet  =  =  null || packet . get optional delay (  )   =  =   poison packet . poison   max   delay   request )  break ;  send reset ( packet )  ;   }  if  (    restart pending )  throw new  router restart exception (  )  ;  throw new  connect exception ( " server socket closed" )  ;   }   packet syn = null ;  while  (    active && syn  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " accept ( "  +  timeout ms  +  " ) : active = " +     active +  " queue: " +     syn queue . size (  )  )  ;  if  ( timeout ms  <  =  0 )   {  try  {  syn =    syn queue . take (  )  ;   }  catch  (   interrupted exception ie )   {   connect exception ce = new  connect exception ( " interrupted accept (  ) " )  ;  ce . init cause ( ie )  ;  throw ce ;   }   }  else  {  long remaining = expiration  -     context . clock (  )  . now (  )  ;  if  ( remaining  <  1 )  break ;  try  {  syn =    syn queue . poll ( remaining  time unit . milliseconds )  ;   }  catch  (   interrupted exception ie )   {   connect exception ce = new  connect exception ( " interrupted accept (  ) " )  ;  ce . init cause ( ie )  ;  throw ce ;   }  break ;   }   }  if  ( syn  !  =  null )   {  if  ( syn . get optional delay (  )   =  =   poison packet . poison   max   delay   request )   {  if  (    restart pending )  throw new  router restart exception (  )  ;  throw new  connect exception ( " server socket closed" )  ;   }  if  ( syn . is flag set (  packet . flag   synchronize )  )   {   destination from = syn . get optional from (  )  ;  if  ( from  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping syn packet with no from: "  +  syn )  ;  continue ;   }   connection oldcon =    manager . get connection by outbound id ( syn . get receive stream id (  )  )  ;  if  ( oldcon  !  =  null )   {  if  ( from . equals ( oldcon . get remote peer (  )  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping dup syn: "  +  syn )  ;  continue ;   }   }   connection con =    manager . receive connection ( syn )  ;  if  ( con  !  =  null )  return con ;   }  else  {  re receive packet ( syn )  ;   }   }   }   }  
@ override public void   (  string column label long x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  test observer <  object >  to )  throws  exception  {  to . assert not fuseable (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . never (  )  . window (  functions . just callable (  observable . never (  )  )  )  )  ;   }  
@ test ( timeout = 500 )  public void   (  )  throws  interrupted exception  {   flowable <  string >  w =  flowable . just ( "one" "two" "three" )  ;   flowable <  string >  o = w . filter ( new  predicate <  string >  (  )  {  @ override public boolean 
private void   (  )  {  int in =    context . get property ( prop   inbound   bandwidth   peak default   burst   seconds *    inbound burstk bytes per second )  ;  if  ( in  !  =     limiter . get inbound burst bytes (  )  )   {  if  ( in  >  =  min   inbound   bandwidth   peak )   {  if  ( in  <     inbound burstk bytes per second )     limiter . set inbound burst bytes (    inbound burstk bytes per second * 1024 )  ;  else    limiter . set inbound burst bytes ( in * 1024 )  ;   }  else  {  if  ( min   inbound   bandwidth   peak  <     inbound burstk bytes per second )     limiter . set inbound burst bytes (    inbound burstk bytes per second * 1024 )  ;  else    limiter . set inbound burst bytes ( min   inbound   bandwidth   peak * 1024 )  ;   }   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 1000 )  . flat map ( new  function <  integer  observable <  integer >  >  (
@ override public void   (  throwable t )  {  long r = remaining ;  if  ( r  !  =   long . max   value )   {  remaining = r  -  1 ;   }  if  ( r  =  =  0 )   {  actual . on error ( t )  ;   }  else  {  boolean b ;  try  {  b = predicate . test ( t )  ;   
@ test public void   (  )  {   flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  integer >  ts = s . test (  )  ;   flowable . range ( 1 10 )  . subscribe ( s )  ;  ts . asser
@ override public void   (  subscriber <  ?  super t >  t )  {   publish subscription < t >  ps = new  publish subscription < t >  ( t this )  ;  t . on subscribe ( ps )  ;  if  ( add ( ps )  )   {  if  ( ps . is cancelled (  )  )   {  remove ( ps )  ;   
public long   (  )  {  return    socket manager . get connection manager (  )  . get so timeout (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on next ( null )  ;   }  
public static void   (  string cache name long lifetime )  {  cache name = cache name . replace all ( " " "" )  ;  if  (  !  long . to string ( lifetime )  . equals (  jive globals . get property ( "cache . "  +  cache name  +  " . max lifetime" )  )  )   {   jive globals . set property (  ( "cache . "  +  cache name  +  " . max lifetime" )   long . to string ( lifetime )  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  subject <  integ
public  string   (  )  {  validate (  )  ;  process (  )  ;  if  (    errors . is empty (  )  &&    notices . is empty (  )  )  return "" ;   string builder buf = new  string builder ( 512 )  ;  buf . append ( " < div class = \"messages\" id = \"messages\" > " )  ;  if  (  !    errors . is empty (  )  )   {  buf . append ( " < div class = \"error\" > " )  ;  buf . append ( render (    errors )  )  ;  buf . append ( " <  / div > " )  ;   }  if  (  !    notices . is empty (  )  )   {  buf . append ( " < div class = \"notice\" > " )  ;  buf . append ( render (    notices )  )  ;  buf . append ( " <  / div > " )  ;   }  buf . append ( " <  / div > " )  ;  return buf . to string (  )  ;   }  
public static void   (  workgroup workgroup  string sessionid )  {  for  (   workgroup event listener listener : listeners )   {  try  {  listener . chat support started ( workgroup sessionid )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . amb (  arrays . as list (  maybe . just ( 1 )   maybe . just ( 2 )  )  )  . test (  )  . assert result ( 1 )  ;   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  drain loop (  )  ;   }   }  
@ test public void   (  )  {   list <  destination info >  dst = reporting service . get destinations (  )  ;  assert equals ( 3 dst . size (  )  )  ;   }  
public void   (  input stream in boolean verify sig )  throws  data format exception  io exception  {  if  (    signature  !  =  null )  throw new  illegal state exception (  )  ;     identity = new  router identity (  )  ;     identity . read bytes ( in )  ;   input stream din ;   message digest digest ;  if  ( verify sig )   {   sig type type =    identity . get signing public key (  )  . get type (  )  ;  if  ( type  !  =   sig type .  eddsa   sha512    ed25519 )   {  digest =    identity . get signing public key (  )  . get type (  )  . get digest instance (  )  ;  digest . update (    identity . to byte array (  )  )  ;  din = new  digest input stream ( in digest )  ;   }  else  {  digest = null ;  din = in ;   }   }  else  {  digest = null ;  din = in ;   }     published =  data helper . read long ( din 8 )  ;  int num addresses =  ( int )  data helper . read long ( din 1 )  ;  for  ( int i = 0 ;  i  <  num addresses ;  i +  +  )   {   router address address = new  router address (  )  ;  address . read bytes ( din )  ;     addresses . add ( address )  ;   }  int num peers =  ( int )  data helper . read long ( din 1 )  ;  if  ( num peers  =  =  0 )   {     peers = null ;   }  else  {     peers = new  hash set <  hash >  ( num peers )  ;  for  ( int i = 0 ;  i  <  num peers ;  i +  +  )   {   hash peer identity hash = new  hash (  )  ;  peer identity hash . read bytes ( din )  ;     peers . add ( peer identity hash )  ;   }   }   data helper . read properties ( din    options )  ;     signature = new  signature (    identity . get signing public key (  )  . get type (  )  )  ;     signature . read bytes ( in )  ;  if  ( verify sig )   {   sig type type =    identity . get signing public key (  )  . get type (  )  ;  if  ( type  !  =   sig type .  eddsa   sha512    ed25519 )   {   simple data structure hash =    identity . get signing public key (  )  . get type (  )  . get hash instance (  )  ;  hash . set data ( digest . digest (  )  )  ;     is valid = dsa engine . get instance (  )  . verify signature (    signature hash    identity . get signing public key (  )  )  ;     validated = true ;   }  else  {  do validate (  )  ;   }  if  (  !    is valid )   {  throw new  data format exception ( " bad sig" )  ;   }   }   }  
public static  uri   ( long account id long id )  {  if  ( s uri  =  =  null )   {  s uri =  uri . parse (  attachment . attachment   provider   uri   prefix )  ;   }  return s uri . build upon (  )  . append path (  long . to string ( account id )  )  . append path (  long . to string ( id )  )  . append path ( format   raw )  . build (  )  ;   }  
public static  string   ( long bytes )  {  float val = bytes ;  int scale = 0 ;  while  ( val  >  =  1024 . 0f )   {  scale +  +  ;  val /  = 1024 . 0f ;   }   decimal format fmt = new  decimal format ( "##0 . 00" )  ;   string str = fmt . format ( val )  ;  switch  ( scale )   {  case 1: return str  +  " ki" ;  case 2: return str  +  " mi" ;  case 3: return str  +  " gi" ;  case 4: return str  +  " ti" ;  case 5: return str  +  " pi" ;  case 6: return str  +  " ei" ;  case 7: return str  +  " zi" ;  case 8: return str  +  " yi" ;  default : return  long . to string ( bytes )  ;   }   }  
@ test public void   (  )  {   observable <  string >  o =  observable . just ( "a" "b" "c" "d" )  ;  o . count (  )  . subscribe ( wo )  ;  verify ( wo times ( 1 )  )  . on success ( any long (  )  )  ;  verify ( wo )  . on success ( 4l )  ;  verify ( wo
private static void   ( final  context context )  {  synchronized  ( s notification delayed message lock )   {  if  ( s notification delayed message pending )   {  s refresh all needed = true ;   }  else  {  ensure handler exists (  )  ;  s notification handler . send message delayed ( android . os .  message . obtain ( s notification handler notification   delayed   message context )  notification   delay )  ;  s notification delayed message pending = true ;  refresh all notifications internal ( context )  ;   }   }   }  
  (  type return type )  {  element type =  generic types . find generic parameter ( return type  stream . class )  . or else throw (  (  )   -  >  new  illegal state exception ( " cannot reflect  stream < t >  element type t in method return type "  +  return type )  )  ;   }  
static  set <  router address >    ( int num )  {   set <  router address >  addresses = new  hash set <  router address >  (  )  ;   router address addr = createtcp address ( num )  ;  if  ( addr  !  =  null )  addresses . add ( addr )  ;  return addresses ;   }  
public   (  field f  big integer l )  {  this . l = l ;  enc = new  big integer little endian encoding (  )  ;  enc . set field ( f )  ;   }  
public   (  node node )  {  super ( node )  ;   }  
private  media info   (  string media preference )  throws  parse exception  {  if  ( media preference  =  =  null )   {  if  ( media info  !  =  null )   {  return media info ;   }  return  sdp manager . find media info (  rtp packet . pcmu   encoding 8000 1 )  ;   }  int ix ;  int encoding =  rtp packet . pcmu   encoding ;  int sample rate = 8000 ;  int channels = 1 ;  try  {  if  ( media preference . index of ( "pcmu / " )   =  =  0 )   {  encoding =  rtp packet . pcmu   encoding ;  media preference = media preference . substring ( 5 )  ;   }  else if  ( media preference . index of ( "pcm / " )   =  =  0 )   {  encoding =  rtp packet . pcm   encoding ;  media preference = media preference . substring ( 4 )  ;   }  else if  ( media preference . index of ( "speex / " )   =  =  0 )   {  encoding =  rtp packet . speex   encoding ;  media preference = media preference . substring ( 6 )  ;   }  else if  ( media preference . index of ( "pcm" )   =  =  0 )   {   }  else  {   logger . println ( " invalid media specification "  +  media preference )  ;   }  if  (  ( ix = media preference . index of ( " / " )  )   <  0 )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  else  {  sample rate =  integer . parse int ( media preference . substring ( 0 ix )  )  ;  channels =  integer . parse int ( media preference . substring ( ix  +  1 )  )  ;   }   }  catch  (   index out of bounds exception e )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  catch  (   number format exception e )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  if  ( sample rate  =  =  8000 && channels  =  =  1 && encoding  =  =   rtp packet . pcm   encoding )   {  encoding =  rtp packet . pcmu   encoding ;   }   media info media info =  sdp manager . find media info ( encoding sample rate channels )  ;   logger . println ( "conference "  +  conference id  +  " using media settings " +  media info )  ;  conference start time =  system . current time millis (  )  ;  return media info ;   }  
@ override public void   (  )  {  first . cancel (  )  ;  second . cancel (  )  ;  if  ( get and increment (  )   =  =  0 )   {  first . clear (  )  ;  second . clear (  )  ;   }   }  
public boolean   (  )  {  return    isi pv6 ;   }  
@ test public void   (  )  {  run merge ( to hidden scalar new  test observer <  integer >  (  )  )  ;   }  
public int   (  )  {  return i ;   }  
protected  string   (  )  {  return auth   realm ;   }  
public  boolean   (  )  {  return    lost packet id plus2 ;   }  
public void   (  node left  node right )  {  final int left index = add node ( left )  ;  if  ( left  =  =  right )  return ;  final int right index = add node ( right )  ;  add neighbor ( left index right index )  ;  add neighbor ( right index left index )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
@ deprecated public static void   (  output stream out  boolean bool )  throws  data format exception  io exception  {  if  ( bool  =  =  null )  write long ( out 1 boolean   unknown )  ;  else if  (  boolean . true . equals ( bool )  )  write long ( out 
public void   (  )  {     is running = false ;  if  (    thread  !  =  null )     thread . interrupt (  )  ;  for  (   summary listener lsnr :    listeners )   {  lsnr . stop listening (  )  ;   }     listeners . clear (  )  ;   }  
@ override public void   ( t value )  {  d =  disposable helper . disposed ;  try  {  on event . accept ( value null )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  actual . on error ( ex )  ;  return ;   }  actual . on su
public synchronized void   ( boolean is alive )  {     alive = is alive ;  if  ( is alive )   {  long delay =    context . random (  )  . next int ( 2 * test   frequency )  ;  reschedule ( delay )  ;   }  else  {  cancel (  )  ;   }   }  
public void   ( int bonus )  {     capacity bonus = bonus ;   }  
@ override public  string   (  )  {  return "[ big integer field element val = "  +  bi  +  "]" ;   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  object >  to = ps . concat map maybe ( new  function <  integer  maybe source <  ?  extends  object >  >  (  )  {  @ override publ
@ override public  flowable <  object >    (  )  {  return  flowable . unsafe create ( new  publisher <  object >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  object >  observer )  {  observer . on subscribe ( new  boolean subscr
public void   ( final t packet )  {   runnable r = new  runnable (  )  {  @ override public void run (  )  {  try  {  channel handler . process ( packet )  ;   }  catch  (   exception e )   {   log . error (  locale utils . get localized string ( "admin . error" )  e )  ;  try  {   session session =  session manager . get instance (  )  . get session ( packet . get from (  )  )  ;  if  ( session  !  =  null )   {   log . debug ( " closing session of ' {  } ':  {  } " packet . get from (  )  session )  ;  session . close (  )  ;   }   }  catch  (   exception e1 )   {   log . error ( " unexpected exception while trying to close session of ' {  } ' . " packet . get from (  )  e1 )  ;   }   }   }   }   ;  executor . execute ( r )  ;   }  
public  string   (  context context )  {   host auth host auth = get or create host auth recv ( context )  ;  if  ( host auth  !  =  null )   {  return host auth . m protocol ;   }  return null ;   }  
public   (  maybe source < t >  source  consumer <  ?  super t >  on after success )  {  super ( source )  ;  this . on after success = on after success ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 256 )  ;  buf . append ( "con delay = " )  . append (    connect delay )  ;  buf . append ( " max size = " )  . append (    max message size )  ;  buf . append ( " rtt = " ) 
@ test public void   (  )  throws  exception  {   runtime exception outer = new  runtime exception ( " transaction throws ! " )  ;   runtime exception inner = new  runtime exception ( " rollback throws ! " )  ;   mockito . when ( c . get auto commit (  ) 
public void   (  storage storage )  {  if  ( coordinator  !  =  null )  coordinator . set wanted pieces (  )  ;   }  
public void   (  string username )  throws  service exception  {   user user = get and check user ( username )  ;  user manager . delete user ( user )  ;  roster manager . delete roster ( server . createjid ( username null )  )  ;   }  
  (  time zone time zone boolean daylight int style  locale locale )  {  m time zone = time zone ;  if  ( daylight )   {  style| = 0x80000000 ;   }  m style = style ;  m locale = locale ;   }  
private synchronized void   (  client app state state  exception e )  {     state = state ;  if  (    mgr  !  =  null )     mgr . notify ( this state null e )  ;   }  
@ deprecated void   ( boolean do pause )  {     do pause = do pause ;   }  
@ test public void   (  )  {  io exception expected exception = new io exception ( "fake exception" )  ;   flowable <  string >  flowable1 = create flowable ( new  string[] {  }  2000 new io exception ( "fake exception" )  )  ;   flowable <  string >  flo
@ test public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  intege
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   runnable r = new  runnable (  )  {  @ override public void run (  )  {  calls[0] +  +  ;   }   }   ;   scheduler s = new  computation scheduler (  )  ;  s . shutdown (  )  ;  s . shutdown (  ) 
public static  string   ( final  string filename )  {  final  string demo dir = getj robin demo directory (  )  ;  if  ( demo dir  !  =  null )   {  return demo dir  +  filename ;   }  else  {  return null ;   }   }  
@ test public void   (  )  {   flowable . sequence equal (  flowable . never (  )  new  flowable <  object >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  object >  s )  {  s . on subscribe ( new  boolean subscription ( 
public  optional <  repose cluster >    (  system model system model )  {  for  (   repose cluster cluster : system model . get repose cluster (  )  )   {  if  ( cluster . get id (  )  . equals ( cluster id )  && get local node ( cluster )  . is present (  )  )   {  return  optional . of ( cluster )  ;   }   }  return  optional . empty (  )  ;   }  
@ test public void   (  )  {  final  file indel output file = new  file ( output   data   path "split - vcfs - test - indels - delete - me . vcf" )  ;  final  file snp output file = new  file ( output   data   path "split - vcfs - test - snps - delete - m
public void   (  node node )  {  set root node ( node )  ;   }  
@ override public  string   (  )  {  return null ;   }  
private void   ( final  file input final  file output )  {  final  string[] args =  { "input = "  +  input "output = "  +  output "sort   order = coordinate" }  ;   sort sam sort sam = new  sort sam (  )  ;   assert . assert equals ( sort sam . instance main ( args )  0 " sort did not succeed" )  ;   }  
@ test public void   (  )  {  final  atomic integer counter = new  atomic integer (  )  ;   composite disposable s = new  composite disposable (  )  ;  s . add (  disposables . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  cou
@ test public void   (  )  {   single . just ( 1 )  . do on event ( new  bi consumer <  integer  throwable >  (  )  {  @ override public void accept (   integer v   throwable e )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test
@ override public v   (  object key )  {  return cache . get ( key )  ;   }  
 remote host id   (  )  {  return    remote host id ;   }  
public  data structure   (  )  {  return new  destination (  )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  rp =  replay subject . create (  )  ;  assert false ( rp . has observers (  )  )  ;   test observer <  integer >  to = rp . test (  )  ;  assert true ( rp . has observers (  )  )  ;  to . cancel 
static  < t >  string builder   (  map <  integer  list < t >  >  its )  {   string builder b = new  string builder (  )  ;  for  (   map .  entry <  integer  list < t >  >  e : its . entry set (  )  )   {  if  ( b . length (  )   >  0 )   {  b . append ( "  " )  ;   }  b . append ( e . get key (  )  )  . append ( " =  { " )  ;  b . append ( sequence frequency ( e . get value (  )  )  )  ;  b . append ( " } " )  ;   }  return b ;   }  
@ override public  object   (  )  throws  exception  {  return 1 ;   }  
public   (  socket s i2p socket i2ps  object slock byte[] initiali2p data  list < i2p socket >  sock list  fail callback on fail )  {  super ( s i2ps slock initiali2p data null sock list on fail )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
public static  comparator <  snark >    ( int type  string lang i2p snark servlet servlet )  {  boolean rev = type  <  0 ;   comparator <  snark >  rv ;  switch  ( type )   {  case  - 1: case 0: case 1: default : rv = new  torrent name comparator ( lang )  ;  if  ( rev )  rv =  collections . reverse order ( rv )  ;  break ;  case  - 2: case 2: rv = new  status comparator ( rev lang )  ;  break ;  case  - 3: case 3: rv = new  peers comparator ( rev lang )  ;  break ;  case  - 4: case 4: rv = new eta comparator ( rev lang )  ;  break ;  case  - 5: case 5: rv = new  size comparator ( rev lang )  ;  break ;  case  - 6: case 6: rv = new  downloaded comparator ( rev lang )  ;  break ;  case  - 7: case 7: rv = new  uploaded comparator ( rev lang )  ;  break ;  case  - 8: case 8: rv = new  down rate comparator ( rev lang )  ;  break ;  case  - 9: case 9: rv = new  up rate comparator ( rev lang )  ;  break ;  case  - 10: case 10: rv = new  remaining comparator ( rev lang )  ;  break ;  case  - 11: case 11: rv = new  ratio comparator ( rev lang )  ;  break ;  case  - 12: case 12: rv = new  file type comparator ( rev lang servlet )  ;  break ;   }  return rv ;   }  
public static void   ( final sam record record final  reference sequence file walker ref seq walker final boolean is bisulfite sequence )  {  final byte[] reference bases = ref seq walker . get ( record . get reference index (  )  )  . get bases (  )  ;   sequence util . calculate md and nm tags ( record reference bases true  ! is bisulfite sequence )  ;  if  ( is bisulfite sequence )   {  record . set attribute ( sam tag . nm . name (  )   sequence util . calculate sam nm tag ( record reference bases 0 is bisulfite sequence )  )  ;   }  fix uq ( record ref seq walker is bisulfite sequence )  ;   }  
public void   ( boolean is seed )  {  this . is seed = is seed ;   }  
@ override public  condition   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public  list < uri >    (  update type type  string id  update method method )  {   version available va =    available . get ( new  update item ( type id )  )  ;  if  ( va  !  =  null )   {   list < uri >  rv = va . source map . get ( method )  ;  if  ( rv  !  =  null )  return rv ;   }  switch  ( type )   {  case news: case news   su3: break ;  case router   signed:  {   string ur ls =    context . get property (  config update handler . prop   update   url  config update handler . default   update   url )  ;   string tokenizer tok = new  string tokenizer ( ur ls "  \r\n" )  ;   list < uri >  rv = new  array list < uri >  (  )  ;  while  ( tok . has more tokens (  )  )   {  try  {  rv . add ( new uri ( tok . next token (  )  . trim (  )  )  )  ;   }  catch  (  uri syntax exception use )   {   }   }   collections . shuffle ( rv    context . random (  )  )  ;  return rv ;   }  case router   signed   su3:  {   string ur ls =  config update handler . su3   update   urls ;   string tokenizer tok = new  string tokenizer ( ur ls "  \r\n" )  ;   list < uri >  rv = new  array list < uri >  (  )  ;  while  ( tok . has more tokens (  )  )   {  try  {  rv . add ( new uri ( tok . next token (  )  . trim (  )  )  )  ;   }  catch  (  uri syntax exception use )   {   }   }   collections . shuffle ( rv    context . random (  )  )  ;  return rv ;   }  case router   unsigned:  string url =    context . get property (  config update handler . prop   zip   url )  ;  if  ( url  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( url )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  case router   dev   su3:  string url3 =    context . get property (  config update handler . prop   dev   su3   url )  ;  if  ( url3  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( url3 )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  case plugin:  properties props =  plugin starter . plugin properties (    context id )  ;   string xpi2purl = props . get property ( "updateurl" )  ;  if  ( xpi2purl  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( xpi2purl )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  default : break ;   }  return  collections . empty list (  )  ;   }  
private url   (  string resource name )  {  try  {  return new url ( resource name )  ;   }  catch  (   malformedurl exception murle )   {  log . trace ( " unable to build url for resource  it is a configuration file" murle )  ;   }  return null ;   }  
@ test @ ignore ( " nulls are not allowed with rs" )  public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0 )  ;   flowable . range ( 1 2 )  . flat map ( new  function <  integer  flowable <  integer >  >  (  ) 
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public void   (  runnable task )  {     final shutdown tasks . add ( task )  ;   }  
public  string   (  )  {  return username ;   }  
public  certificate store configuration   (  connection type type )  throws io exception  {  final  string key store type = get key store type ( type )  ;  final  string password = get trust store password ( type )  ;  final  string location = get trust store location ( type )  ;  final  file file = canonicalize ( location )  ;  return new  certificate store configuration ( key store type file password . to char array (  )  )  ;   }  
@ deprecated public static  boolean   (  input stream in )  throws  data format exception  io exception  {  int val = in . read (  )  ;  switch  ( val )   {  case  - 1: throw new eof exception ( "eof reading boolean" )  ;  case 0: return  boolean . false 
public  destination   (  hash h )  {  synchronized  ( bad dests )   {  return bad dests . get ( h )  ;   }   }  
public  integer   (  )  throws  exception  {  if  ( actual server  =  =  null )   {  return null ;   }  return actual server . get http port (  )  ;   }  
void   (  unicast processor < t >  w )  {  queue . offer ( new  subject work < t >  ( w false )  )  ;  if  ( enter (  )  )   {  drain loop (  )  ;   }   }  
private static final int   (  string str int default value )  {  return  ( int ) get long ( str default value )  ;   }  
public void   ( final  simple timer .  timed event event final long delay final long timeout ms )  {  new  periodic timed event ( this delay timeout ms )  {  @ override public void time reached (  )  {  event . time reached (  )  ;   }  @ override public  string to string (  )  {  return event . to string (  )  ;   }   }   ;   }  
@ test public void   (  )  throws  exception  {  tos . write ( 0 )  ;  tos . write ( new byte[10] )  ;  tos . write ( new byte[10] 0 5 )  ;  assert equals ( 0 baos . size (  )  )  ;  tos . flush (  )  ;  assert equals ( 10 baos . size (  )  )  ;  tos . cl
void   ( int count )  {  loop count = count ;   }  
public void   (  string s )  {     config . set outproxy auth ( true )  ;   }  
public void   (  string s )  throws io exception  {  delegate . write chars ( s )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . concat eager (  arrays . as list (  flowable . just ( 1 )   flowable . just ( 2 )  )  )  . test (  )  . assert result ( 1 2 )  ;   }  
@ override public  string   (  string source )  {  final  query parameter collection parsed query parameters = new  query parameter collection ( source )  ;  final  list <  query parameter >  query parameters = parsed query parameters . get parameters (  
@ override @ suppress warnings ( "unchecked" )  public  map <  string  string >    (  result set r int column number  statement context ctx )  throws sql exception  {  return  (  map <  string  string >  ) r . get object ( column number )  ;   }  
public  sel datagram channel   (  )  {  return channelb ;   }  
private void   ( int doop )  throws  rrd exception  {  if  ( doop  >  =  0 )   {  op = doop ;  expect token (  time token . number " there should be number after "  +   ( op  =  =   time token . plus  ?  ' + ' : ' - ' )  )  ;  prev   multiplier =  - 1 ;   }  int delta =  integer . parse int ( token . value )  ;  token = scanner . next token (  )  ;  if  ( token . id  =  =   time token . months   minutes )   {  switch  ( prev   multiplier )   {  case  time token . days: case  time token . weeks: case  time token . months: case  time token . years: token = scanner . resolve months minutes (  time token . months )  ;  break ;  case  time token . seconds: case  time token . minutes: case  time token . hours: token = scanner . resolve months minutes (  time token . minutes )  ;  break ;  default : if  ( delta  <  6 )   {  token = scanner . resolve months minutes (  time token . months )  ;   }  else  {  token = scanner . resolve months minutes (  time token . minutes )  ;   }   }   }  prev   multiplier = token . id ;  delta* =  ( op  =  =   time token . plus )   ?   + 1 :  - 1 ;  switch  ( token . id )   {  case  time token . years: spec . dyear +  = delta ;  break ;  case  time token . months: spec . dmonth +  = delta ;  break ;  case  time token . weeks: delta* = 7 ;  spec . dday +  = delta ;  break ;  case  time token . days: spec . dday +  = delta ;  break ;  case  time token . hours: spec . dhour +  = delta ;  break ;  case  time token . minutes: spec . dmin +  = delta ;  break ;  case  time token . seconds: default : spec . dsec +  = delta ;  break ;   }   }  
@ check return value @ backpressure support (  backpressure kind . unbounded   in )  @ scheduler support (  scheduler support . none )  public final  maybe < t >    (  )  {  return  rx java plugins . on assembly ( new  flowable last maybe < t >  ( this ) 
public void   ( boolean speex encode )  {  this . speex encode = speex encode ;   }  
public static long   ( final  node parent node final  string child name )  throws  rrd exception  {  final  string value str = get child value ( parent node child name )  ;  return  long . parse long ( value str )  ;   }  
private int   ( boolean allow zero hop int expire30s int expire90s int expire150s int expire210s int expire270s int expire later int standard amount int in progress int fallback )  {  int rv = 0 ;  int remaining wanted = standard amount  -  expire later ;  if  ( allow zero hop )  remaining wanted -  = fallback ;  for  ( int i = 0 ;  i  <  expire270s && remaining wanted  >  0 ;  i +  +  )  remaining wanted -  -  ;  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire210s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire150s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire90s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire30s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv +  = 6 * expire30s ;  rv +  = 6 * remaining wanted ;  rv -  = in progress ;  rv -  = expire later ;   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv +  = 6 * expire30s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv -  = in progress ;  rv -  = expire later ;   }  if  ( allow zero hop &&  ( rv  >  standard amount )  )  rv = standard amount ;  if  ( rv  +  in progress  +  expire later +  fallback  >  4 * standard amount )  rv = 4 * standard amount  -  in progress  -  expire later  -  fallback ;  long lifetime = get lifetime (  )  ;  if  (  ( lifetime  <  60 * 1000 )  &&  ( rv  +  in progress  +  fallback  >  =  standard amount )  )  rv = standard amount  -  in progress  -  fallback ;  if  ( rv  >  0 &&    log . should log (  log . debug )  )     log . debug ( " count: rv: "  +  rv  +  " allow ?  " +  allow zero hop +  " 30s " +  expire30s +  " 90s " +  expire90s +  " 150s " +  expire150s +  " 210s " +  expire210s +  " 270s " +  expire270s +  " later " +  expire later +  " std " +  standard amount +  " in progress " +  in progress +  " fallback " +  fallback +  " for " +  to string (  )  +  " up for " +  lifetime )  ;  if  ( rv  <  0 )  return 0 ;  return rv ;   }  
public void   ( jid recipient  packet packet )  {   log . debug ( " presence sent to unreachable address: "  +  packet . toxml (  )  )  ;   }  
private int   (  )  {   service service ;  synchronized  ( lock )   {  if  (  ! isnat present (  )  || thinks we are double natted )  return  - 1 ;  service =    service ;   }   action getip = service . get action ( " get link layer max bit rates" )  ;  if  ( getip  =  =  null ||  ! getip . post control action (  )  )  return  - 1 ;   argument a = getip . get output argument list (  )  . get argument ( " new upstream max bit rate" )  ;  if  ( a  =  =  null )  return  - 1 ;  try  {  return  integer . parse int ( a . get value (  )  )  ;   }  catch  (   number format exception nfe )   {  return  - 1 ;   }   }  
  (  single observer <  ?  super  boolean >  actual  object value )  {  this . actual = actual ;  this . value = value ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay subscription ( 1  time unit . seconds null )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   maybe <  integer >  source =  maybe . create ( new  maybe on subscribe <  integer >  (  )  {  @ override public void subscribe (   maybe emitter <  integer 
long   (  )  throws io exception  {  return cached  ?  cache : read long (  )  ;   }  
@ test public void   (  )  {   single <  object >  cache =  single . error ( new  test exception (  )  )  . cache (  )  ;  cache . test (  )  . assert failure (  test exception . class )  ;  cache . test (  )  . assert failure (  test exception . class ) 
private  regular time period   ( long time period  date date  time zone zone )  {  if  ( time period  >  86400000 )   {  return new  day ( date zone )  ;   }  else if  ( time period  >  3600000 )   {  return new  hour ( date zone )  ;   }  else  {  return new  minute ( date zone )  ;   }   }  
private static int   ( int max )  {  long x =  system . nano time (  )  ;  x^ =  ( x  <  <  21 )  ;  x^ =  ( x  >  >  >  35 )  ;  x^ =  ( x  <  <  4 )  ;  return  math . abs (  ( int ) x % max )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
public  list <  peer >    (  )  {   peer coordinator coord = coordinator ;  if  ( coord  !  =  null )  return coord . peer list (  )  ;  return  collections . empty list (  )  ;   }  
private final static byte[]   ( int options )  {  if  (  ( options & url   safe )   =  =  url   safe )  return    url   safe   alphabet ;  else if  (  ( options & ordered )   =  =  ordered )  return    ordered   alphabet ;  else return    standard   alphabet ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   flowable .  <  integer  integer > using ( new  callable <  integer >  (  )  {  @ override publ
 timer   (  )  {  return m   timer ;   }  
public boolean   (  string id )  {  if  ( backends . contains key ( id )  )   {  backends . remove ( id )  ;  return true ;   }  return false ;   }  
public void   (  )  {  int n sockets = size (  )  ;  for  ( int n = 0 ;  n  <  n sockets ;  n +  +  )   {  ssdp search response socket sock = getssdp search response socket ( n )  ;  sock . start (  )  ;   }   }  
public static int   (  string workgroup name  date start date  date end date )  {   workgroup workgroup = get workgroup ( workgroup name )  ;  if  ( workgroup  =  =  null )   {  return 0 ;   }  int count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( workgroup   request   count )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  pstmt . set string ( 2  string utils . date to millis ( start date )  )  ;  pstmt . set string ( 3  string utils . date to millis ( end date )  )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  count = rs . get int ( 1 )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return count ;   }  
public static void   (  subscriber <  ?  >  s )  {  s . on subscribe ( instance )  ;  s . on complete (  )  ;   }  
public int   (  )  {  return wait ;   }  
@ override protected byte[]   (  )  throws i2cp message exception  io exception  {  if  (  (    session id  =  =  null )  ||  (    signing private key  =  =  null )  ||  (    private key  =  =  null ) ||  (    lease set  =  =  null )  )  throw new i2cp me
public static double[]   ( final double[] p posterior )  {  final double[] tmp = new double[p posterior . length] ;  final double total = sum ( p posterior )  ;  final double maxp = max   prob   below   one ;  final double minp =  ( 1  -  max   prob   below   one )   /   ( tmp . length  -  1 )  ;  for  ( int i = 0 ;  i  <  p posterior . length ;   +  + i )   {  tmp[i] = p posterior[i]  /  total ;  if  ( tmp[i]  >  maxp )  tmp[i] = maxp ;  else if  ( tmp[i]  <  minp )  tmp[i] = minp ;   }  return tmp ;   }  
void   (  )  {  for  (   zip observer <  ?   ?  >  zs : observers )   {  zs . dispose (  )  ;   }   }  
@ override public synchronized boolean   (  object obj )  {  if  (  ( obj  =  =  null )  ||  !  ( obj instanceof  rate )  )  return false ;  if  ( obj  =  =  this )  return true ;   rate r =  (  rate ) obj ;  if  (    period  !  =  r . get period (  )  ||
public void   ( boolean http basic auth )  {  this . http basic auth = http basic auth ;   jive globals . set property ( "plugin . userservice . http auth . enabled" http basic auth  ?  "true" : "false" )  ;   }  
@ override public void   (  string property  map <  string  object >  params )  {  if  ( property . equals ( "xmpp . pubsub . enabled" )  )   {  boolean enabled =  boolean . parse boolean (  (  string ) params . get ( "value" )  )  ;  enable service ( ena
@ test public void   (  )  {   observable <  string >  subject =  observable . from array ( new  string[] { "zero" "one" "two" "three" "four" "five" }  )  ;   observable <  observable <  string >  >  windowed = subject . window ( 3 1 )  ;   list <  list <
public  string   (  )  throws  unknowncpu exception  {   string smodel = identifycpu (  )  ;  if  ( smodel  !  =  null )  return smodel ;  throw new  unknowncpu exception ( " unknown amd cpu ;   family = "  +  cpuid . getcpu family (  )   +  ' / ' +  cpuid . getcpu extended family (  )  +  "   model = " +  cpuid . getcpu model (  )  +  ' / ' +  cpuid . getcpu extended model (  )  )  ;   }  
public   (  context context  host auth host auth )  {  super ( context log   tag host auth )  ;   }  
public   (  output stream out )  {  super ( "sam  sink  pinger" )  ;  set daemon ( true )  ;     out = out ;   }  
public void   (  agent session agent session )  {   workgroup manager . get instance (  )  . update workgroup status ( this )  ;   workgroup event dispatcher . agent joined ( this agent session )  ;   }  
boolean   (  inner subscriber < t >  producer )  {  for  (  ;   ;   )   {   inner subscriber < t > [] c = subscribers . get (  )  ;  if  ( c  =  =  terminated )   {  return false ;   }  int len = c . length ;  @ suppress warnings ( "unchecked" )   inner subscriber < t > [] u = new  inner subscriber[len  +  1] ;   system . arraycopy ( c 0 u 0 len )  ;  u[len] = producer ;  if  ( subscribers . compare and set ( c u )  )   {  return true ;   }   }   }  
@ override public boolean   (  )  {  return iter . has next (  )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
@ test public void   (  )  {   flowable . just ( 1 )  . group join (  flowable . just ( 2 )  new  function <  integer  flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   integer left )  throws  exception  {  return  flowa
public  string   (  )  {  return name ;   }  
public double   (  )  {  return lod genotype ;   }  
public   ( final  illumina file map tiles to files )  {  super ( tiles to files )  ;   }  
@ test public void   (  )  throws  exception  {   string expected = versions xml file reader ;   string actual = transform xml to format ( versions xml file reader new  media type (  mime type . application   xml  - 1 )  new  content transformer (  json f
private void   (  )  {     do log =    context . get boolean property ( prop   keep   message   history )  ;     history file =    context . get property ( prop   message   history   filename default   message   history   filename )  ;   }  
@ test public final void   (  )  {   test scheduler s = new  test scheduler (  )  ;  final  scheduler .  worker inner = s . create worker (  )  ;  try  {  final  atomic integer counter = new  atomic integer ( 0 )  ;  final  disposable subscription = inner
public void   ( int ms )  {  long count = 0 ;  long bw = 0 ;  long tcount = 0 ;  long too young =    context . clock (  )  . now (  )   -  60 * 1000 ;  long too old = too young  -  9 * 60 * 1000 ;  for  (   hop config cfg :    participating config . values (  )  )   {  long c = cfg . get and reset recent messages count (  )  ;  bw +  = c ;  long created = cfg . get creation (  )  ;  if  ( created  >  too young || created  <  too old )  continue ;  tcount +  +  ;  count +  = c ;   }  if  ( tcount  >  0 )  count = count *  ( 10 * 60 * 1000  /  ms )   /  tcount ;     context . stat manager (  )  . add rate data ( "tunnel . participating message count avg per tunnel" count ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating message count" bw ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating bandwidth" bw * 1024  /   ( ms  /  1000 )  ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating tunnels" tcount )  ;   }  
public   (  date date )  {  this . input = date ;   }  
public int   (  )  {  return    entries . size (  )  ;   }  
@ test public void   (  )  throws  exception  {  find pattern ( " connectable observable <  . * > \\s + cf ( 0 - 9|\\b ) " )  ;   }  
public  string   (  )  {  return " outbound client message send timeout" ;   }  
public void   (  )  {     may disconnect = true ;   }  
@ override public int   (  )  throws  cannot calculate size exception  {  int size = jid . to barejid (  )  . length (  )  ;  size +  =  cache sizes . size of string ( nickname )  ;  size +  =  cache sizes . size of collection ( groups )  ;  size +  =  ca
@ override public void   (  )  {  try  {  i session . get connection service (  )  . disconnect (  )  ;   }  catch  (   exception e )   {   }  if  ( listener  !  =  null )   {  try  {  i session . get connection service (  )  . remove connection listener 
@ test ( expected =  null pointer exception . class )  public void   (  )  {   spsc linked array queue <  object >  q = new  spsc linked array queue <  object >  ( 16 )  ;  q . offer ( null )  ;   }  
@ data provider ( name = " " )  public  object[][] bad grouped files (  )  {  return new  object[][] {  { "bad / grouped - unpaired - mate . sam" }  }  ;   }  
@ test ( data provider = "clipping tests" )  public void   ( final  string clipping action final  string bases1   1 final  string quals1   1 final  string bases1   2 final  string quals1   2 final  string bases2   1 final  string quals2   1 final  string 
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  long idx = index  +  1 ;  index = idx ;   disposable d = timer ;  if  ( d  !  =  null )   {  d . dispose (  )  ;   }   debounce emitter < t >  de = new  debounce emitter < t >  ( t idx t
  (  subscriber <  ?  super t >  actual long count  subscription arbiter sa  publisher <  ?  extends t >  source )  {  this . actual = actual ;  this . sa = sa ;  this . source = source ;  this . remaining = count ;   }  
@ override protected  per unit metric collector <  insert size metrics  integer  insert size collector args >    ( final  string sample final  string library final  string read group )  {  return new  per unit insert size metrics collector ( sample librar
public final  string   (  )  {  return m server id ;   }  
@ test public void   (  )  {   flowable . range ( 1 2 )  . map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . concat map delay error ( 
public  group element   (  )  {  return to rep (  representation . cached )  ;   }  
public long   (  )  {  return    last used ;   }  
public static int   (  )  {  return rtp timeout ;   }  
synchronized  string   (  )  {  return "locks = "  +  locks  +  "  " +  "unlocks = " +  unlocks +  "  " +  "delayed   locks = " +   ( locks  -  quick locks )  +  "  " +  "locked = " +  locked +  "  " +  "errors = " +  errors ;   }  
public  jingle trackeriq   ( final  xml pull parser parser )  throws  exception  {   jingle trackeriq iq = new  jingle trackeriq (  )  ;  boolean done = false ;  int event type ;   string element name ;  while  (  ! done )   {  event type = parser . get event type (  )  ;  element name = parser . get name (  )  ;  if  ( event type  =  =   xml pull parser . start   tag )   {  final  tracker entry .  type type ;  if  ( element name . equals (  tracker entry .  type . relay . to string (  )  )  )   {  type =  tracker entry .  type . relay ;   }  else if  ( element name . equals (  tracker entry .  type . tracker . to string (  )  )  )   {  type =  tracker entry .  type . tracker ;   }  else  {  parser . next (  )  ;  continue ;   }  final  string protocol = parser . get attribute value ( null "protocol" )  ;  final  tracker entry .  policy policy =  tracker entry .  policy . value of ( "   "  +  parser . get attribute value ( null "policy" )  )  ;  final  string address = parser . get attribute value ( null "address" )  ;  final  string verified = parser . get attribute value ( null "verified" )  ;  if  ( address  !  =  null && address . length (  )   >  0 )   {  final  tracker entry entry = new  tracker entry ( type policy address protocol )  ;  if  ( verified  !  =  null && verified . equals ( "true" )  )   {  entry . set verified ( true )  ;   }  iq . add entry ( entry )  ;   }   }  else if  ( event type  =  =   xml pull parser . end   tag )   {  if  ( element name . equals (  jingle trackeriq . name )  )   {  done = true ;   }   }  if  (  ! done )   {  parser . next (  )  ;   }   }  return iq ;   }  
public void   ( int tunnel depth )  {     tunnel depth out = tunnel depth ;   }  
protected boolean   ( final byte b )  {  for  ( int i = 0 ;  i  <  delimiters . length ;  i +  +  )   {  if  ( b  =  =  delimiters[i] )   {  return true ;   }   }  return false ;   }  
public static  string   (  )  {  return sip config . registrar address ;   }  
  (  single observer <  ?  super t >  actual  single source < t >  source )  {  this . actual = actual ;  this . source = source ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  maybe < t >    (  single source < t >  single source )  {   object helper . require non null ( single source "single source is null" )  ;  return  rx java plugin
@ test public void   (  )  {   test helper . check double on subscribe completable ( new  function <  completable  completable >  (  )  {  @ override public  completable apply (   completable f )  throws  exception  {  return f . do finally (  completable
public long   (  )  {  return    expiration ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable convert . subscribe with ( new  perf consumer ( bh )  )  ;   }  
public  long   (  )  {  return    synchronization source ;   }  
public int   (  )  {  return type ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception 
public void   (  )  {  try  {  while  (  ! quit && peer . is connected (  )  )   {   message m = null ;   peer state state = null ;  boolean should flush ;  synchronized  ( send queue )   {  should flush =  ! quit && peer . is connected (  )  && send queue . is empty (  )  ;   }  if  ( should flush )  dout . flush (  )  ;  synchronized  ( send queue )   {  while  (  ! quit && peer . is connected (  )  && send queue . is empty (  )  )   {  try  {  send queue . wait ( 60 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  state = peer . state ;  if  (  ! quit && state  !  =  null && peer . is connected (  )  )   {   iterator <  message >  it = send queue . iterator (  )  ;  while  ( m  =  =  null && it . has next (  )  )   {   message nm = it . next (  )  ;  if  ( nm . type  =  =   message . piece )   {  if  ( state . choking )   {  it . remove (  )  ;  if  ( peer . supports fast (  )  )   {   message r = new  message (  message . reject nm . piece nm . begin nm . length )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +  peer  +  ": " +  r )  ;  r . send message ( dout )  ;   }   }  nm = null ;   }  else if  ( nm . type  =  =   message . request && state . choked )   {  it . remove (  )  ;  nm = null ;   }  if  ( nm  !  =  null )   {  m = nm ;  it . remove (  )  ;   }   }  if  ( m  =  =  null )   {  m = send queue . poll (  )  ;   }   }   }  if  ( m  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +  peer  +  ": " +  m )  ;  last sent =  system . current time millis (  )  ;  if  ( m . type  =  =   message . choke )  remove message (  message . piece )  ;  int remainder = 0 ;  if  ( m . type  =  =   message . piece )   {  if  ( m . len  <  =   peer state . partsize )   {  state . uploaded ( m . len )  ;   }  else  {  state . uploaded (  peer state . partsize )  ;  remainder = m . len  -   peer state . partsize ;   }   }  m . send message ( dout )  ;  if  ( remainder  >  0 )  state . uploaded ( remainder )  ;  m = null ;   }   }   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . info )  )     log . info ( "io error sending to "  +  peer ioe )  ;   }  catch  (   throwable t )   {     log . error ( " error sending to "  +  peer t )  ;  if  ( t instanceof  out of memory error )  throw  (  out of memory error ) t ;   }  finally  {  quit = true ;  peer . disconnect (  )  ;   }   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  drain loop (  )  ;   }   }  
  (  latest coordinator < t r >  parent int index )  {  this . parent = parent ;  this . index = index ;   }  
@ override public void   (  string property  map params )  {  if  ( "provider . group . class name" . equals ( property )  )   {  init provider (  )  ;   }   }  
@ test public void   (  )  {   flowable <  integer >  on next =  flowable . error ( new  test exception (  )  )  ;   flowable <  integer >  on complete =  flowable . from iterable (  arrays . as list ( 4 )  )  ;   flowable <  integer >  on error =  flowab
private static void   ( byte[] a byte[] b )  {  for  ( int i = 0 ;  i  <  32 ;  i +  +  )   {  b[i]^ = a[i] ;   }   }  
@ override public int   (  )  {  return  ( count  <  <  16 )  ^ size ;   }  
@ test public void   (  )  {   observable . merge delay error (  observable . just (  observable . just ( 1 )   observable . just ( 2 )  )  1 )  . test (  )  . assert result ( 1 2 )  ;   }  
  (  subscriber <  ?  super t >  actual  maybe source <  ?  extends t >  other )  {  super ( actual )  ;  this . other = other ;  this . other disposable = new  atomic reference <  disposable >  (  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  sampler =  publish processor . create (  )  ;   flowable <  integer >  m = source . sample ( sampler )  ;  m . su
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   observable <  integer >  source =  observable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override publi
static boolean   ( final  string host final  string domain root )  {  if  ( domain root  =  =  null )   {  return false ;   }  return host . ends with ( domain root )  &&  ( host . length (  )   =  =  domain root . length (  )  || host . char at ( host . length (  )   -  domain root . length (  )   -  1 )   =  =  ' . ' )  ;   }  
public void   (  )  throws sql exception  {  cstmt . add batch (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  observable source <  object > 
protected void   (  )  {  if  ( lock )   {  passed = lock reference . try lock ( key )  ;   }  else  {  lock reference . unlock ( key )  ;   }  lock =  ! lock ;   }  
public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public void   (  string id )  {  this . id = id ;   }  
public synchronized void   (  )  {     initialized = false ;  if  (    kb  !  =  null )     kb . clear (  )  ;  if  (    ds  !  =  null )     ds . stop (  )  ;     explore keys . clear (  )  ;     negative cache . clear (  )  ;   }  
public synchronized void   (  )  {  if  (    initialized )  throw new  illegal state exception (  )  ;  if  (  ! get boolean property ( "i2p . dummy client facade" )  )   {   client manager facade impl cmfi = new  client manager facade impl ( this )  ;     client manager facade = cmfi ;     internal client manager = cmfi ;   }  else  {     client manager facade = new  dummy client manager facade ( this )  ;   }     garlic message parser = new  garlic message parser ( this )  ;     client message pool = new  client message pool ( this )  ;     job queue = new  job queue ( this )  ;     job queue . startup (  )  ;     in net message pool = new  in net message pool ( this )  ;     out net message pool = new  out net message pool ( this )  ;     message history = new  message history ( this )  ;     message registry = new  outbound message registry ( this )  ;     routing key generator = new  router key generator ( this )  ;  if  (  ! get boolean property ( "i2p . dummy net db" )  )     net db = new  floodfill network database facade ( this )  ;  else    net db = new  dummy network database facade ( this )  ;     key manager = new  key manager ( this )  ;  if  (  ! get boolean property ( "i2p . vm comm system" )  )     comm system = new  comm system facade impl ( this )  ;  else    comm system = new vm comm system ( this )  ;     profile organizer = new  profile organizer ( this )  ;  if  (  ! get boolean property ( "i2p . dummy peer manager" )  )     peer manager facade = new  peer manager facade impl ( this )  ;  else    peer manager facade = new  dummy peer manager facade (  )  ;     profile manager = new  profile manager impl ( this )  ;     bandwidth limiter = new fifo bandwidth limiter ( this )  ;  if  (  ! get boolean property ( "i2p . dummy tunnel manager" )  )     tunnel manager = new  tunnel pool manager ( this )  ;  else    tunnel manager = new  dummy tunnel manager facade (  )  ;     tunnel dispatcher = new  tunnel dispatcher ( this )  ;     stat publisher = new  statistics manager ( this )  ;     banlist = new  banlist ( this )  ;     blocklist = new  blocklist ( this )  ;     message validator = new  message validator ( this )  ;     throttle = new  router throttle impl ( this )  ;     app manager = new  router app manager ( this )  ;     initialized = true ;   }  
@ test public void   (  )  {   message message = new  message (  )  ;  message . set type (  message .  type . chat )  ;  message . set body ( " tests" )  ;  message . add extension ( new  data form (  data form .  type . submit )  )  ;   forwarded forwar
@ xml element public  string   (  )  {  return name ;   }  
public void   (  string resource name )  {  watch map . remove ( resource name )  ;   }  
@ test public void   (  )  {  final  string name = " computation scheduler test" ;   thread factory factory = new  thread factory (  )  {  @ override public  thread new thread (   runnable r )  {  return new  thread ( r name )  ;   }   }   ;  final  sched
@ override public  observable <  object >    (  )  {  return  observable . never (  )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  debounce timed subscriber < t >  ( new  serialized subscriber < t >  ( s )  timeout unit scheduler . create worker (  )  )  )  ;   }  
private void   (  )  {  int in =    context . get property ( prop   outbound   bandwidth   peak default   burst   seconds *    outbound burstk bytes per second )  ;  if  ( in  !  =     limiter . get outbound burst bytes (  )  )   {  if  ( in  >  =  min   outbound   bandwidth   peak )   {  if  ( in  <     outbound burstk bytes per second )     limiter . set outbound burst bytes (    outbound burstk bytes per second * 1024 )  ;  else    limiter . set outbound burst bytes ( in * 1024 )  ;   }  else  {  if  ( min   outbound   bandwidth   peak  <     outbound burstk bytes per second )     limiter . set outbound burst bytes (    outbound burstk bytes per second * 1024 )  ;  else    limiter . set outbound burst bytes ( min   outbound   bandwidth   peak * 1024 )  ;   }   }   }  
public long   (  )  {  return queue wait time ;   }  
public void   ( i local status i local status )  {   log . debug ( " gadu gadu:  local status changed: "  +  i local status )  ;  get session (  )  . set presence and status (  (  (  gadu gadu transport ) get session (  )  . get transport (  )  )  . convert gadu gadu status toxmpp ( i local status . get status type (  )  )  "" )  ;   }  
@ override protected void   (  single observer <  ?  super r >  observer )  {  source . subscribe ( new  reduce seed observer < t r >  ( observer reducer seed )  )  ;   }  
public void   ( boolean can change nickname )  {  this . can change nickname = can change nickname ;   }  
@ test public void   (  )  {   collect wgs metrics collect wgs metrics = new  collect wgs metrics (  )  ;   fast wgs metrics collector collector = new  fast wgs metrics collector ( collect wgs metrics 100 create interval list (  )  )  ;   abstract locus i
public static void   ( boolean send to cluster )  {  if  ( send to cluster )   {   cache factory . do synchronous cluster task ( new  flush task (  )  false )  ;   }  if  ( items to add . get first (  )   =  =  null && items to delete . get first (  )   =  =  null )   {  return ;   }   connection con = null ;  boolean rollback = false ;   linked list <  retry wrapper >  add list = null ;   linked list <  published item >  del list = null ;  synchronized  ( items pending )   {  add list = items to add ;  del list = items to delete ;  items to add = new  linked list <  >  (  )  ;  items to delete = new  linked list <  >  (  )  ;  int copied = 0 ;  for  (   string key : items pending . key set (  )  )   {  if  (  ! item cache . contains key ( key )  )   {  item cache . put ( key  (  (  (  retry wrapper ) items pending . get ( key )  . object )  )  . get (  )  )  ;  copied +  +  ;   }   }  if  ( log . is debug enabled (  )  && copied  >  0 )   {  log . debug ( " added "  +  copied  +  " pending items to published item cache" )  ;   }  items pending . clear (  )  ;   }  try  {  con =  db connection manager . get transaction connection (  )  ;  write pending items ( con add list del list )  ;   }  catch  (  sql exception se )   {  log . error ( " failed to flush pending items ;  initiating rollback" se )  ;   linked list node <  retry wrapper >  node = add list . get last (  )  ;  while  ( node  !  =  null )   {  save published item ( node . object )  ;  node . remove (  )  ;  node = add list . get last (  )  ;   }  rollback = true ;   }  finally  {   db connection manager . close transaction connection ( con rollback )  ;   }   }  
public void   (  client connection runner runner )  {  synchronized  (    pending runners )   {     pending runners . remove ( runner )  ;   }   list <  session id >  ids = runner . get session ids (  )  ;   list <  destination >  dests = runner . get destinations (  )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " unregistering  ( dropping )  a client connection with ids: "  +  ids )  ;  synchronized  (    runners )   {  for  (   session id id : ids )   {     runner session ids . remove ( id )  ;   }  for  (   destination dest : dests )   {     runners . remove ( dest )  ;     runners by hash . remove ( dest . calculate hash (  )  )  ;   }  for  (  iterator <  client connection runner >  iter =    runners . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   client connection runner r = iter . next (  )  ;  if  ( r . equals ( runner )  )  iter . remove (  )  ;   }  for  (  iterator <  client connection runner >  iter =    runners by hash . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   client connection runner r = iter . next (  )  ;  if  ( r . equals ( runner )  )  iter . remove (  )  ;   }   }   }  
public   (  string server name  connection connection  streamid streamid  locale language )  {  if  ( connection  =  =  null )   {  throw new  illegal argument exception ( "connection must not be null" )  ;   }  conn = connection ;  this . streamid = streamid ;  this . server name = server name ;   string id = streamid . getid (  )  ;  this . address = new jid ( null server name id true )  ;  this . session manager =  session manager . get instance (  )  ;  this . stream manager = new  stream manager ( this )  ;  this . language = language ;   }  
public  data structure   (  )  {  return new  router identity (  )  ;   }  
@ override public  set <  user provider >    (  )  {  final  set <  user provider >  result = new  linked hash set <  >  (  )  ;  result . add all ( providers by prefix . values (  )  )  ;  result . add ( fallback provider )  ;  return result ;   }  
public  boolean   (  )  {  return    lost packet id plus7 ;   }  
public   (  publisher <  ?  extends t >  source )  {  this . source = source ;   }  
@ test public void   (  )  {   comparator <  media >  sort function = new  comparator <  media >  (  )  {  @ override public int compare (   media t1   media t2 )  {  return 1 ;   }   }   ;   flowable <  media >  o =  flowable . just ( new  movie (  )  ne
private static  mode   (  string content  string encoding )  {  if  ( " shift   jis" . equals ( encoding )  && is only double byte kanji ( content )  )   {  return  mode . kanji ;   }  boolean has numeric = false ;  boolean has alphanumeric = false ;  for  ( int i = 0 ;  i  <  content . length (  )  ;   +  + i )   {  char c = content . char at ( i )  ;  if  ( c  >  =  '0' && c  <  =  '9' )   {  has numeric = true ;   }  else if  ( get alphanumeric code ( c )   !  =   - 1 )   {  has alphanumeric = true ;   }  else  {  return  mode . byte ;   }   }  if  ( has alphanumeric )   {  return  mode . alphanumeric ;   }  if  ( has numeric )   {  return  mode . numeric ;   }  return  mode . byte ;   }  
@ test ( data provider = "  data provider" )  public void test has cbcls ( final int lane final boolean create cbcl dir final boolean create cbcl final boolean expected result )  throws io exception  {  final  file basecalls dir = io util . create temp di
public static void   (  string username )  {   string message = get mark message ( username )  ;  warn ( message )  ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return e instanceof  test exception || e instanceof  composite exception ;   }  
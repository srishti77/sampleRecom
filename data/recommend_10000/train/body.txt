public   (  history strategy parent strategy )  {  this . parent = parent strategy ;  if  ( parent  =  =  null )   {  max number = default   max   number ;   }  else  {  type =  type . defaul type ;  max number = parent . get max number (  )  ;   }   }  
@ inject public   (  configuration service configuration service )  {  this . configuration service = configuration service ;   }  
public  string   (  )  {  return name ;   }  
public byte   (  )  {  return telephone event payload ;   }  
boolean   (  string canonical name  path plugin dir )  {  final  plugin metadata metadata =  plugin metadata . get instance ( plugin dir )  ;  plugin metadata . put ( canonical name metadata )  ;  if  ( xmpp server . get instance (  )  . is setup mode (  )  &&  !  ( canonical name . equals ( "admin" )  )  )   {  return false ;   }  if  ( failure to load count . contains key ( canonical name )  && failure to load count . get ( canonical name )   >   jive globals . get int property ( "plugins . loading . retries" 5 )  )   {   log . debug ( " the unloaded file for plugin ' {  } ' is silently ignored  as it has failed to load repeatedly . " canonical name )  ;  return false ;   }   log . debug ( " loading plugin ' {  } ' .  .  . " canonical name )  ;  try  {  final  path plugin config = plugin dir . resolve ( "plugin . xml" )  ;  if  (  !  files . exists ( plugin config )  )   {   log . warn ( " plugin ' {  } ' could not be loaded: no plugin . xml file found . " canonical name )  ;  failure to load count . put ( canonical name  integer . max   value )  ;  return false ;   }  final  version current server version = xmpp server . get instance (  )  . get server info (  )  . get version (  )  ;  if  ( metadata . get min server version (  )   !  =  null )   {  final  version compare version = new  version ( current server version . get major (  )  current server version . get minor (  )  current server version . get micro (  )  null  - 1 )  ;  if  ( metadata . get min server version (  )  . is newer than ( compare version )  )   {   log . warn ( " ignoring plugin ' {  } ': requires server version  {  }  .   current server version is  {  }  . " canonical name metadata . get min server version (  )  current server version )  ;  failure to load count . put ( canonical name  integer . max   value )  ;  return false ;   }   }  if  ( metadata . get prior to server version (  )   !  =  null )   {  final  version compare version = new  version ( current server version . get major (  )  current server version . get minor (  )  current server version . get micro (  )  null  - 1 )  ;  if  (  ! metadata . get prior to server version (  )  . is newer than ( compare version )  )   {   log . warn ( " ignoring plugin ' {  } ': compatible with server versions up to but excluding  {  }  .   current server version is  {  }  . " canonical name metadata . get prior to server version (  )  current server version )  ;  failure to load count . put ( canonical name  integer . max   value )  ;  return false ;   }   }  if  ( metadata . get min java version (  )   !  =  null )   {  final  java spec version runtime version = new  java spec version (  system . get property ( "java . specification . version" )  )  ;  if  ( metadata . get min java version (  )  . is newer than ( runtime version )  )   {   log . warn ( " ignoring plugin ' {  } ': requires  java specification version  {  }  .   openfire is currently running in  java  {  }  . " canonical name metadata . get min java version (  )   system . get property ( "java . specification . version" )  )  ;  failure to load count . put ( canonical name  integer . max   value )  ;  return false ;   }   }  final  string dev mode classes dir =  system . get property ( canonical name  +  " . classes" )  ;  final  string dev modeweb root =  system . get property ( canonical name  +  " . web root" )  ;  final boolean dev mode = dev modeweb root  !  =  null || dev mode classes dir  !  =  null ;  final  plugin dev environment dev =  ( dev mode  ?  configure plugin dev environment ( plugin dir dev mode classes dir dev modeweb root )  : null )  ;  final  plugin class loader plugin loader ;   string parent plugin name = null ;   plugin parent plugin = null ;  final  string parent canonical name =  plugin metadata helper . get parent plugin ( plugin dir )  ;  if  ( parent canonical name  !  =  null )   {  for  (  final  map .  entry <  string  plugin >  entry : plugins loaded . entry set (  )  )   {  if  ( entry . get key (  )  . equals ignore case ( parent canonical name )  )   {  parent plugin name = entry . get key (  )  ;  parent plugin = entry . get value (  )  ;  break ;   }   }  if  ( parent plugin  =  =  null )   {   log . info ( " unable to load plugin ' {  } ': parent plugin ' {  } ' has not been loaded . " canonical name parent canonical name )  ;   integer count = failure to load count . get ( canonical name )  ;  if  ( count  =  =  null )   {  count = 0 ;   }  failure to load count . put ( canonical name  +  + count )  ;  return false ;   }  plugin loader = classloaders . get ( parent plugin )  ;   }  else  {  plugin loader = new  plugin class loader (  )  ;   }  plugin loader . add directory ( plugin dir . to file (  )  dev mode )  ;  if  ( dev  !  =  null && dev . get classes dir (  )   !  =  null )   {  plugin loader . addurl file ( dev . get classes dir (  )  . touri (  )  . tourl (  )  )  ;   }  final sax reader sax reader = new sax reader (  )  ;  sax reader . set encoding ( "utf - 8" )  ;  final  document pluginxml = sax reader . read ( plugin config . to file (  )  )  ;  final  string class name = pluginxml . select single node ( " / plugin / class" )  . get text (  )  . trim (  )  ;  final  plugin plugin =  (  plugin ) plugin loader . load class ( class name )  . new instance (  )  ;  classloaders . put ( plugin plugin loader )  ;  plugins loaded . put ( canonical name plugin )  ;  plugin dirs . put ( canonical name plugin dir )  ;  if  ( dev  !  =  null )   {  plugin development . put ( plugin dev )  ;   }  if  ( parent plugin  !  =  null )   {   list <  string >  children plugins = parent plugin map . get ( parent plugin )  ;  if  ( children plugins  =  =  null )   {  children plugins = new  array list <  >  (  )  ;  parent plugin map . put ( parent plugin children plugins )  ;   }  children plugins . add ( canonical name )  ;  child plugin map . put ( plugin parent plugin name )  ;   }  if  (  !  db connection manager . get schema manager (  )  . check plugin schema ( plugin )  )   {   log . error ( " error while loading plugin ' {  } ':  {  } " canonical name  locale utils . get localized string ( "upgrade . database . failure" )  )  ;   }  final  path webxml = plugin dir . resolve ( "web" )  . resolve ( "web - inf" )  . resolve ( "web . xml" )  ;  if  (  files . exists ( webxml )  )   {   plugin servlet . register servlets ( this plugin webxml . to file (  )  )  ;   }  final  path custom webxml = plugin dir . resolve ( "web" )  . resolve ( "web - inf" )  . resolve ( "web - custom . xml" )  ;  if  (  files . exists ( custom webxml )  )   {   plugin servlet . register servlets ( this plugin custom webxml . to file (  )  )  ;   }  configure caches ( plugin dir canonical name )  ;  final  class loader old loader =  thread . current thread (  )  . get context class loader (  )  ;   thread . current thread (  )  . set context class loader ( plugin loader )  ;  plugin . initialize plugin ( this plugin dir . to file (  )  )  ;   log . debug ( " initialized plugin ' {  } ' . " canonical name )  ;   thread . current thread (  )  . set context class loader ( old loader )  ;  final  element admin element =  (  element ) pluginxml . select single node ( " / plugin / adminconsole" )  ;  if  ( admin element  !  =  null )   {  final  element app name =  (  element ) admin element . select single node ( " / plugin / adminconsole / global / appname" )  ;  if  ( app name  !  =  null )   {  app name . add attribute ( "plugin" canonical name )  ;   }   element image el =  (  element ) admin element . select single node ( " / plugin / adminconsole / global / logo - image" )  ;  if  ( image el  !  =  null )   {  image el . set text ( "plugins / "  +  canonical name  +  " / " +  image el . get text (  )  )  ;  image el . add attribute ( "plugin" canonical name )  ;   }  image el =  (  element ) admin element . select single node ( " / plugin / adminconsole / global / login - image" )  ;  if  ( image el  !  =  null )   {  image el . set text ( "plugins / "  +  canonical name  +  " / " +  image el . get text (  )  )  ;  image el . add attribute ( "plugin" canonical name )  ;   }  final  list urls = admin element . select nodes ( " /  / @url" )  ;  for  (  final  object url : urls )   {  final  attribute attr =  (  attribute ) url ;  attr . set value ( "plugins / "  +  canonical name  +  " / " +  attr . get value (  )  )  ;   }  final  string[] element names = new  string[] { "tab" "sidebar" "item" }  ;  for  (  final  string element name : element names )   {  final  list values = admin element . select nodes ( " /  / "  +  element name )  ;  for  (  final  object value : values )   {  final  element element =  (  element ) value ;  if  ( element . attribute ( "name" )   !  =  null || element . attribute ( "value" )   !  =  null )   {  element . add attribute ( "plugin" canonical name )  ;   }   }   }   admin console . add model ( canonical name admin element )  ;   }  fire plugin created event ( canonical name plugin )  ;   log . info ( " successfully loaded plugin ' {  } ' . " canonical name )  ;  return true ;   }  catch  (   throwable e )   {   log . error ( " an exception occurred while loading plugin ' {  } ':" canonical name e )  ;   integer count = failure to load count . get ( canonical name )  ;  if  ( count  =  =  null )   {  count = 0 ;   }  failure to load count . put ( canonical name  +  + count )  ;  return false ;   }   }  
@ deprecated public   (  packet router router  string server name  connection connection )  {  this . router = router ;  this . connection = connection ;   }  
@ override public void   (  string local domain  string remote domain )  {  final  domain pair domain pair = new  domain pair ( local domain remote domain )  ;  outgoing domain pairs . add ( domain pair )  ;  xmpp server . get instance (  )  . get routing
void   (  validator validator )  {  this . validator = validator ;   }  
@ test ( timeout = 1000 )  public void   (  )  throws  interrupted exception  {  final  disposable first set = mock (  disposable . class )  ;  serial disposable . update ( first set )  ;  final  count down latch start = new  count down latch ( 1 )  ;  fi
@ override protected void   (  subscriber <  ?  super t >  s )  {   parallel reduce full main subscriber < t >  parent = new  parallel reduce full main subscriber < t >  ( s source . parallelism (  )  reducer )  ;  s . on subscribe ( parent )  ;  source .
void   ( boolean should wait )  {  synchronized  ( synchronizer )   {  if  (    log . should debug (  )  )     log . debug ( "close (  ) " )  ;  if  ( idle closer  !  =  null )  idle closer . cancel (  )  ;  if  ( socket  !  =  null && socket . is connected (  )  )   {  try  {   collection <  string >  to delete = delayed deleter . get queued (  )  ;   map <  string  integer >  send delete = new  hash map <  string  integer >  ( to delete . size (  )  )  ;  for  (   string uidl : to delete )   {  int id = geti dfromuidl ( uidl )  ;  if  ( id  >  =  0 )   {  send delete . put ( uidl  integer . value of ( id )  )  ;   }   }  if  ( should wait )   {  if  (  ! send delete . is empty (  )  )   {   collection <  string >  deleted = delete ( send delete . key set (  )  )  ;  for  (   string uidl : deleted )   {  delayed deleter . remove queued ( uidl )  ;   }   }  else  {  send cmd1a ( "quit" )  ;   }  if  (    log . should debug (  )  )     log . debug ( "close (  )  with wait complete" )  ;   }  else  {  if  (  ! send delete . is empty (  )  )   {  for  (   integer id : send delete . values (  )  )   {  send cmd1a no wait ( "dele "  +  id )  ;   }   }  send cmd1a no wait ( "quit" )  ;   }   }  catch  (  io exception e )   {   }  finally  {  if  ( socket  !  =  null )   {  try  {  socket . close (  )  ;   }  catch  (  io exception e )   {   }   }   }   }  socket = null ;  connected = false ;  clear (  )  ;   }   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   flowable . just ( 1 )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  throws  exception  {  throw e ;
public void   ( int max published items )  {  this . max published items = max published items ;   }  
public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write safeutf ( out text )  ;   externalizable util . get instance (  )  . write int ( out session type . ordinal (  )  )  ;   externalizable util . get instance (  )  . write boolean ( out address  !  =  null )  ;  if  ( address  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out address )  ;   }   externalizable util . get instance (  )  . write boolean ( out streamid  !  =  null )  ;  if  ( streamid  !  =  null )   {   externalizable util . get instance (  )  . write safeutf ( out streamid . getid (  )  )  ;   }   }  
@ test public void   (  )  {   flowable <  integer >  s1 =  flowable . just ( 1 )  ;   flowable <  integer >  s2 =  flowable . just ( 2 )  ;   flowable <  integer >  s3 =  flowable . just ( 3 )  ;   flowable <  integer >  s4 =  flowable . just ( 4 )  ;   
public void   (  string id )  {  this . id = id ;   }  
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
@ override public synchronized void   (  string destination id )  {  if  ( destinations . get ( destination id )   !  =  null )   {  destinations . get ( destination id )  . increment request count (  )  ;   }   }  
public void   (  )  {  final  imap string k1 = new  imap simple string ( " key" )  ;   imap list list = build list ( k1 string   1 )  ;  assert element ( string   1 list . get keyed list or empty ( "key" false )  )  ;  assert element ( string   1 list . get keyed list or empty ( "key" true )  )  ;  assert element (  imap string . empty list . get keyed list or empty ( "ke" false )  )  ;  assert element ( string   1 list . get keyed list or empty ( "ke" true )  )  ;  assert element (  imap string . empty list . get keyed list or empty ( "ke" )  )  ;  assert element ( string   1 list . get keyed list or empty ( "key" )  )  ;   }  
public void   ( boolean enabled )  {  patterns enabled = enabled ;   jive globals . set property ( patterns   enabled   property enabled  ?  "true" : "false" )  ;  change content filter patterns (  )  ;   }  
@ override public void   (  )  {  completed . set ( true )  ;   }  
public int   (  )  {  return digest frequency ;   }  
public   (  socket socket  connection configuration configuration boolean client mode )  throws io exception  {  wrapper = new tls wrapper ( configuration client mode )  ;  tls engine = wrapper . get tls engine (  )  ;  reader = new tls stream reader ( wrapper socket )  ;  writer = new tls stream writer ( wrapper socket )  ;  if  ( socket . get channel (  )   !  =  null )   {  rbc = socket . get channel (  )  ;  wbc = socket . get channel (  )  ;   }  else  {  rbc =  channels . new channel ( socket . get input stream (  )  )  ;  wbc =  channels . new channel ( socket . get output stream (  )  )  ;   }  initialhs status =  handshake status . need   unwrap ;  initialhs complete = false ;  netbb size = tls engine . get session (  )  . get packet buffer size (  )  ;  appbb size = tls engine . get session (  )  . get application buffer size (  )  ;  incoming netbb =  byte buffer . allocate ( netbb size )  ;  outgoing netbb =  byte buffer . allocate ( netbb size )  ;  outgoing netbb . position ( 0 )  ;  outgoing netbb . limit ( 0 )  ;  appbb =  byte buffer . allocate ( appbb size )  ;  if  ( client mode )   {  socket . set so timeout ( 0 )  ;  socket . set keep alive ( true )  ;  initialhs status =  handshake status . need   wrap ;  tls engine . begin handshake (  )  ;   }  else if  ( configuration . get client auth (  )   =  =   connection .  client auth . needed )   {  if  (  jive globals . get boolean property (  connection settings .  server . tls   certificate   verify true )  &&  jive globals . get boolean property (  connection settings .  server . tls   certificate   chain   verify true )  &&  !  jive globals . get boolean property (  connection settings .  server . tls   accept   selfsigned   certs false )  )   {  tls engine . set need client auth ( true )  ;   }  else  {  tls engine . set want client auth ( true )  ;   }   }   }  
@ test public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   runnable task = new  runnable (  )  {  @ override public void run (  )  {  calls . get and increment (  )  ;   }   }   ;   test executor exec = new  test executor ( 
@ override public void   (  observer <  ?  super r >  t )  {  r r ;  try  {  r =  object helper . require non null ( seed supplier . call (  )  " the seed supplied is null" )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   em
int[]   (  )  {  while  ( pos  <  y . length )   {  if  (  double . is nan ( y[pos] )  )   {  pos +  +  ;   }  else  {  int end pos = pos  +  1 ;  while  ( end pos  <  y . length &&  !  double . is nan ( y[end pos] )  )   {  end pos +  +  ;   }  int[] result =  { pos end pos }  ;  pos = end pos ;  if  ( result[1]  -  result[0]  >  =  2 )   {  return result ;   }   }   }  return null ;   }  
public synchronized byte[]   (  )  {  return    bobip ;   }  
public   (  )  {  super ( "stun" )  ;   }  
@ override public  maybe <  ?  extends  integer >    (  integer v )  throws  exception  {  return  maybe . empty (  )  ;   }  
  (  equal coordinator < t >  parent int index int buffer size )  {  this . parent = parent ;  this . index = index ;  this . queue = new  spsc linked array queue < t >  ( buffer size )  ;   }  
@ suppress warnings ( "unchecked" )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    ( t item1 t item2 t item3 t item4 t item5 t item6 t item7 t item8 t item9 t item10 )  {   object helper 
public  collection <  string >    (  )  {  return sysadmins ;   }  
@ test public void   (  )  {  final io exception ioe = new io exception (  )  ;  final  test exception te = new  test exception (  )  ;   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  int count ;  @ over
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  test observer <  integer >  to =  maybe . using ( new  call
private void   (  advertiser adv )  {  get device data (  )  . set advertiser ( adv )  ;   }  
synchronized void   ( int bytes )  {     allocated +  = bytes ;  if  (    lsnr  =  =  null )     allocations since wait +  +  ;   }  
@ test public void   (  )  {   observable <  string >  src =  observable . just ( "a" "b" "c" )  ;  src . filter ( is   d )  . first ( "default" )  . subscribe ( wo )  ;  verify ( wo times ( 1 )  )  . on success ( any string (  )  )  ;  verify ( wo times 
public  map <  string  string >    (  )  {  return params ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . from iterable ( new  iterable <  object >  (  )  {  @ override public  iterator <  object >  iterator (  )  {  return null ;   }   }   )  . blocking last (  )  ;   }
public  string   (  )  {  return  jive globals . get property ( "update . proxy . host" )  ;   }  
public long   (  )  {  return subscription time ;   }  
@ override protected byte[]   (  )  throws i2cp message exception  io exception  {  if  (  (    session id  =  =  null )  ||  (    signing private key  =  =  null )  ||  (    private key  =  =  null ) ||  (    lease set  =  =  null )  )  throw new i2cp me
public   (  string id  node xsl  string system id )  {  this . id = id ;  this . uri = null ;  this . xsl = xsl ;  this . system id = system id ;   }  
@ override public void   (  string dest  string id )  {  if  (    log . should log (  log . debug )  )     log . debug ( " connection "  +  id  +  " received from " +  dest )  ;  try  {   sink sink = new  sink ( id dest )  ;  synchronized  (    remote pee
@ test public void   (  )  {   disposable underlying = mock (  disposable . class )  ;  serial disposable . update ( underlying )  ;  verify zero interactions ( underlying )  ;  serial disposable . update ( underlying )  ;  verify ( underlying )  . dispos
public  string   ( long expiration )  {  long now =    context . clock (  )  . now (  )  ;  if  ( now  -   (  router . clock   fudge   factor * 3  /  2 )   >  =  expiration )   {  if  (    log . should log (  log . info )  )     log . info ( " rejecting message because it expired "  +   ( now  -  expiration )   +  "ms ago" )  ;     context . stat manager (  )  . add rate data ( "router . invalid message time"  ( now  -  expiration )  )  ;  return "expired "  +   ( now  -  expiration )   +  "ms ago" ;   }  else if  ( now  +  4 *  router . clock   fudge   factor  <  expiration )   {  if  (    log . should log (  log . info )  )     log . info ( " rejecting message because it will expire too far in the future  ( "  +   ( expiration  -  now )   +  "ms ) " )  ;     context . stat manager (  )  . add rate data ( "router . invalid message time"  ( now  -  expiration )  )  ;  return "expire too far in the future  ( "  +   ( expiration  -  now )   +  "ms ) " ;   }  return null ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  test observer . create (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;  assert equals ( 0 to . errors (  )  . size (  )  )  ;  to . on error ( new  test exception (  )  )  ;  as
@ override protected void   ( @ non null  subscription value )  {  value . cancel (  )  ;   }  
@ test public void   (  )  {   test subscriber <  long >  ts = new  test subscriber <  long >  ( 2l )  {  @ override public void on next (   long t )  {  super . on next ( t )  ;  cancel (  )  ;  on complete (  )  ;   }   }   ;   flowable . range long ( 1
public   (  session key key  session tag tag )  {  this . key = key ;  this . tag = tag ;   }  
private static  string   ( int lane )  {   string out str =  string . value of ( lane )  ;  while  ( out str . length (  )   <  3 )   {  out str = "0"  +  out str ;   }  return "l"  +  out str ;   }  
@ override public int   (  )  throws io exception  {  return input stream . available (  )  ;   }  
public   (  string name )  {     job = name ;     max time =  - 1 ;     min time =  - 1 ;     max pending time =  - 1 ;     min pending time =  - 1 ;   }  
public   (  localmuc room room  string old nick  string new nick  presence presence )  {  super ( room )  ;  this . old nick = old nick ;  this . new nick = new nick ;  this . presence = presence ;   }  
@ override protected  ad hoc command .  action   (  session data data )  {  return  ad hoc command .  action . complete ;   }  
@ override public void   (  throwable t )  {  parent . error ( t )  ;   }  
public int   ( k bucket < t >  l k bucket < t >  r )  {  if  ( l . get range end (  )   <  r . get range begin (  )  )  return  - 1 ;  if  ( l . get range begin (  )   >  r . get range end (  )  )  return 1 ;  return 0 ;   }  
@ nullable @ override public final t   (  )  throws  exception  {  if  ( get (  )   =  =  fused   ready )   {  t v = value ;  value = null ;  lazy set ( fused   consumed )  ;  return v ;   }  return null ;   }  
@ override public void   (  )  {  lower latch . count down (  )  ;  lower count . increment and get (  )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  s )  {  s . on subscrib
public   (  flowable < t >  source )  {  super ( source )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source1 =  publish subject . create (  )  ;   publish subject <  integer >  source2 =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >  fail = new  function < 
private int[]   ( int[] in samples )  {  int[] out samples = new int[in samples . length * 2] ;  int out ix = 0 ;  for  ( int in ix = 0 ;  in ix  <  in samples . length ;  in ix +  +  )   {  out samples[out ix] = in samples[in ix] ;  out ix +  +  ;  out samples[out ix] = in samples[in ix] ;  out ix +  +  ;   }  return out samples ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . from iterable (  arrays . as list ( 1 null )  )  . blocking last (  )  ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  run finally (  )  ;   }  
public  string   (  )  {  return body ;   }  
public long   (  )  {  return get service data (  )  . get timeout (  )  ;   }  
private void   ( final sq lite database db final  string message id final long dst folder key )  {  db . execsql (  string . format (  locale . us message   move   insert  message move . table   name message id message id message id message id dst folder key message id dst folder key )  )  ;   }  
public void   (  )  {  assert true ( m store . require copy message to sent folder (  )  )  ;   }  
private static final  string   (  string s )  {  return s ;   }  
@ override public void   ( t value )  {  if  ( compare and set ( false true )  )   {  set . dispose (  )  ;  actual . on success ( value )  ;   }   }  
public  credential   (  context context )  {  m flags| = flag   oauth ;  if  ( m credential  =  =  null )   {  if  ( m credential key  >  =  0 )   {  m credential =  credential . restore credentials with id ( context m credential key )  ;   }  else  {  m credential = new  credential (  )  ;   }   }  return m credential ;   }  
@ test public void   (  )  {   observable . range ( 1 100 )  . concat map eager ( to just )  . subscribe ( to )  ;  to . assert no errors (  )  ;  to . assert value count ( 100 )  ;  to . assert complete (  )  ;   }  
private url   ( uri host )  {  if  ( host  =  =  null || host . get scheme (  )   =  =  null || host . get host (  )   =  =  null )   {  return null ;   }  try  {  return new url ( host . get scheme (  )  host . get host (  )  host . get port (  )  "" )  ;   }  catch  (   malformedurl exception ex )   {  log . error ( " invalid host url: "  +  host ex )  ;   }  return null ;   }  
@ override public void   (  )  {  target . on complete (  )  ;  latch . count down (  )  ;   }  
public void   ( i2cp message message i2p session impl session )  {  if  (    log . should log (  log . debug )  )     log . debug ( " handle message "  +  message )  ;   request lease set message msg =  (  request lease set message ) message ;   lease set lease set = new  lease set (  )  ;  for  ( int i = 0 ;  i  <  msg . get endpoints (  )  ;  i +  +  )   {   lease lease = new  lease (  )  ;  lease . set gateway ( msg . get router ( i )  )  ;  lease . set tunnel id ( msg . get tunnel id ( i )  )  ;  lease . set end date ( msg . get end date (  )  )  ;  lease set . add lease ( lease )  ;   }  sign lease set ( lease set session )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0 )  ;   flowable . from array ( 10 9 8 7 6 5 4 3 2 1 )  . parallel (  )  . sorted (  functions . natural comparator (  )  )  . subscribe ( ts )  ;  ts 
public static final boolean   (  boolean b1  boolean b2 )  {  return  ( b1  =  =   boolean . true && b2  =  =   boolean . true )  ||  ( b1  !  =   boolean . true && b2  !  =   boolean . true )  ;   }  
static void   (  router context ctx  string page  map <  integer  string >  sections )  {   string builder buf = new  string builder ( 512 )  ;  for  (   string section : sections . values (  )  )  buf . append ( section )  . append ( s )  ;  ctx . router (  )  . save config ( prop   summarybar  +  page buf . to string (  )  )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 64 )  ;  buf . append ( "[ certificate: type: " )  ;  if  ( get certificate type (  )   =  =  certificate   type   null )  buf . append ( " null" )  ;  else if  ( get certifi
@ override public void   (  disposable d )  {  if  (  disposable helper . set ( this d )  )   {  actual . on subscribe ( this )  ;   }   }  
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public   ( i2p app context context )  {     dir = new  concurrent hash map <  string  inet socket address >  ( 8 )  ;   }  
  (  string text )  {  this . text = text ;   }  
@ suppress warnings ( "rawtypes" )  @ nullable public static  function <  ?  super  flowable  ?  extends  flowable >    (  )  {  return on flowable assembly ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on exception resume next ( null )  ;   }  
  (  replay observer < t >  parent  observer <  ?  super t >  child )  {  this . parent = parent ;  this . child = child ;   }  
@ xml element public  string   (  )  {  return name ;   }  
public boolean   (  packet interceptor interceptor )  {  return global interceptors . remove ( interceptor )  ;   }  
private i2np message   (  byte array buf  inbound message state state i2np message handler handler )  {  try  {  i2np message m ;  int num fragments = state . get fragment count (  )  ;  if  ( num fragments  >  1 )   {   byte array fragments[] = state . get fragments (  )  ;  int off = 0 ;  for  ( int i = 0 ;  i  <  num fragments ;  i +  +  )   {   system . arraycopy ( fragments[i] . get data (  )  0 buf . get data (  )  off fragments[i] . get valid (  )  )  ;  off +  = fragments[i] . get valid (  )  ;   }  if  ( off  !  =  state . get complete size (  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " hmm  offset of the fragments  =  "  +  off  +  " while the state says " +  state . get complete size (  )  )  ;  return null ;   }  m = i2np message impl . from raw byte array (    context buf . get data (  )  0 state . get complete size (  )  handler )  ;   }  else  {  m = i2np message impl . from raw byte array (    context state . get fragments (  ) [0] . get data (  )  0 state . get complete size (  )  handler )  ;   }  m . set unique id ( state . get message id (  )  )  ;  return m ;   }  catch  (  i2np message exception ime )   {  if  (    log . should log (  log . warn )  )   {   byte array ba ;  if  ( state . get fragment count (  )   >  1 )  ba = buf ;  else ba = state . get fragments (  ) [0] ;  byte[] data = ba . get data (  )  ;     log . warn ( " message invalid: "  +  state  +  "  peer state: " +     transport . get peer state ( state . get from (  )  )  +  "\ndump:\n" +   hex dump . dump ( data 0 state . get complete size (  )  )  +  "\nraw:\n" +   base64 . encode ( data 0 state . get complete size (  )  )  ime )  ;   }  if  ( state . get fragments (  ) [0] . get data (  ) [0]  =  =   database store message . message   type )   {   peer state ps =    transport . get peer state ( state . get from (  )  )  ;  if  ( ps  !  =  null && ps . get remote port (  )   =  =  65520 )   {     transport . send destroy ( ps )  ;     transport . drop peer ( ps true " corrupt dsm" )  ;     context . banlist (  )  . banlist router forever ( state . get from (  )     x ( " sent corrupt dsm" )  )  ;   }   }     context . message history (  )  . dropped inbound message ( state . get message id (  )  state . get from (  )  "error: "  +  ime . to string (  )   +  ": " +  state . to string (  )  )  ;  return null ;   }  catch  (   runtime exception e )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error handling a message: "  +  state e )  ;     context . message history (  )  . dropped inbound message ( state . get message id (  )  state . get from (  )  "error: "  +  e . to string (  )   +  ": " +  state . to string (  )  )  ;  return null ;   }  finally  {  state . release resources (  )  ;   }   }  
@ test public void   (  )  {  handle . register row mapper (  constructor mapper . factory (  user . class )  )  ;   set <  user >  user set = handle . create query ( "select * from user order by id asc" )  . map to (  user . class )  . collect (  collect
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . concat array (  (  publisher <  object > [] ) null )  ;   }  
@ override public void   (  naming service listener nsl )  {  for  (   naming service ns :    services )   {  ns . register listener ( nsl )  ;   }   }  
public  page view   (  )  {  if  ( views . size (  )   >  0 )   {  return views . get ( views . size (  )   -  1 )  ;   }  return null ;   }  
  (  subscriber <  ?  super t >  actual  predicate <  ?  super t >  predicate )  {  this . actual = actual ;  this . predicate = predicate ;   }  
private static  string   (  string path )  {  if  (  file . separator char  !  =  ' / ' )   {  path = path . replace (  file . separator char ' / ' )  ;   }  if  (  ! path . starts with ( " / " )  )   {  path = " / "  +  path ;   }  return path ;   }  
@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . of hours (  - 7 )  )  ;  h . execute ( "insert into stuff ( ts )  values  (  ?  ) " dt )  ;  assert that ( dt . is equal ( h . c
public boolean   (  )  {  return started support ;   }  
protected int   ( byte out[] int cur index )  {  if  (    data  =  =  null )   {  out[cur index +  + ] = 0x0 ;  out[cur index +  + ] = 0x0 ;  out[cur index +  + ] = 0x0 ;  out[cur index +  + ] = 0x0 ;   }  else  {   data helper . to long ( out cur index 4    data . length )  ;  cur index +  = 4 ;   system . arraycopy (    data 0 out cur index    data . length )  ;  cur index +  =    data . length ;   }  return cur index ;   }  
@ data provider ( name = " " )  public  object[][] test fragment multi hit with filtering test cases (  )  {  final  array list <  object[] >  ret = new  array list <  object[] >  (  )  ;   list <  hit spec >  hit specs ;  hit specs = new  array list <  h
private void   ( final  vcf tuple tuple final  variant context writer writer final  genotype concordance scheme scheme )  {   variant context truth context = null  call context = null ;  final  list <  genotype >  genotypes = new  array list <  >  ( 2 )  ;  if  ( tuple . left variant context . is present (  )  )   {  truth context = tuple . left variant context . get (  )  ;   }  if  ( tuple . right variant context . is present (  )  )   {  call context = tuple . right variant context . get (  )  ;   }  if  ( truth context  !  =  null && truth context . is symbolic (  )  || call context  !  =  null && call context . is symbolic (  )  )   {  return ;   }  final  alleles alleles = normalize alleles ( truth context truth   sample call context call   sample ignore   filter   status )  ;  if  (  ! alleles . all alleles . is empty (  )  )   {  if  ( truth context  =  =  null && call context  =  =  null )   {  throw new  illegal state exception ( " both truth and call contexts are null ! " )  ;   }  final  variant context builder builder ;  final  list <  allele >  all alleles = alleles . as list (  )  ;  final  list <  allele >  truth alleles = alleles . truth alleles (  )  ;  final  list <  allele >  call alleles = alleles . call alleles (  )  ;  final  set <  allele >  site alleles = new  hash set <  >  (  )  ;  site alleles . add all ( all alleles )  ;  site alleles . remove (  allele . no   call )  ;  final  variant context initial context =  ( call context  =  =  null )   ?  truth context : call context ;  builder = new  variant context builder ( initial context . get source (  )  initial context . get contig (  )  initial context . get start (  )  initial context . get end (  )  site alleles )  ;  builder . compute end from alleles ( all alleles initial context . get start (  )  )  ;  builder . log10p error ( initial context . get log10p error (  )  )  ;  add to genotypes ( genotypes truth context truth   sample output   vcf   truth   sample   name all alleles truth alleles missing   sites   hom   ref )  ;  add to genotypes ( genotypes call context call   sample output   vcf   call   sample   name all alleles call alleles false )  ;  builder . genotypes ( genotypes )  ;  final  truth and call states state =  genotype concordance . determine state ( truth context truth   sample call context call   sample min   gq min   dp ignore   filter   status )  ;  final  contingency state[] state array = scheme . get concordance state array ( state . truth state state . call state )  ;  builder . attribute ( contingency   state   tag  arrays . as list ( state array )  )  ;  writer . add ( builder . make (  )  )  ;   }   }  
void   (  )  {   disposable helper . dispose ( other )  ;   }  
@ override public void   (  )  {  to . cancel (  )  ;   }  
@ override public void   (  )  {  u c = collection ;  collection = null ;  actual . on success ( c )  ;   }  
@ test public void   (  )  throws  exception  {  final  file metrics file =  file . create temp file ( "cbcl . " " . metrics" )  ;  metrics file . delete on exit (  )  ;  final  string[] args = new  string[] { "basecalls   dir = "  +  cbcl . get absolute 
  (  latest coordinator < t r >  parent int index )  {  this . parent = parent ;  this . index = index ;   }  
public long   (  )  {  return    sequence num ;   }  
@ test public void   (  )  {   replay subject <  string >  subject =  replay subject . create (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "one" )  ;  subject . o
@ override public boolean   (  )  {  if  ( error  !  =  null )   {  throw  exception helper . wrap or throw ( error )  ;   }  if  (  ! has next )   {  return false ;   }  return  ! is next consumed || move to next (  )  ;   }  
@ override public  collection < muc role >    ( jid user )  {   list < muc role >  user roles = new  array list <  >  (  )  ;  for  (   localmuc room room : localmuc room manager . get rooms (  )  )   {  muc role role = room . get occupant by fulljid ( us
@ override public void   (  )  {  if  ( cancelled )   {  return ;   }  cancelled = true ;  do terminate (  )  ;  if  (  ! enable operator fusion )   {  if  ( wip . get and increment (  )   =  =  0 )   {  queue . clear (  )  ;  actual . lazy set ( null )  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   observable .  <  integer > never (  )  . buffer ( 2 1  time unit . milliseconds  schedulers . single (  )  new  callable <  collection <  integer >  >  (  )  {  int count ;  @ override pu
@ override public  boolean   (  )  throws  exception  {  number of subscribe calls . increment and get (  )  ;  if  ( atomic integer . decrement and get (  )   !  =  0 )   {  throw new  runtime exception (  )  ;   }  return true ;   }  
private void   (  )  {   array list pm to remove = new  array list (  )  ;  synchronized  ( private mixes for me )   {  for  ( int i = 0 ;  i  <  private mixes for me . size (  )  ;  i +  +  )   {   conference member member =  (  conference member ) private mixes for me . get ( i )  ;  pm to remove . add ( member )  ;   }   }  for  ( int i = 0 ;  i  <  pm to remove . size (  )  ;  i +  +  )   {   conference member member =  (  conference member ) pm to remove . get ( i )  ;  member . remove private mix ( this )  ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  member  +  " removing private mix for " +  this )  ;   }   }   }  
void   (  date locked time )  {  this . locked time = locked time . get time (  )  ;   }  
private   (  observable source < t >  on subscribe  observable source < t >  source final  atomic reference <  publish observer < t >  >  current )  {  this . on subscribe = on subscribe ;  this . source = source ;  this . current = current ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . debounce ( 1  time unit . milliseconds )  . test ( 0l )  . await done ( 5  time unit . seconds )  . assert failure (  missing backpressure exception . class )  ;   }  
public void   (  agent session agent session )  {  accepted sessions . add ( agent session )  ;  pending sessions . remove ( agent session )  ;   }  
public void   ( int check frequency )  {   jive globals . set property ( "update . frequency"  integer . to string ( check frequency )  )  ;   }  
@ deprecated @ override public boolean   (  )  {  throw new  illegal argument exception ( "unsupported" )  ;   }  
@ override public void   (  observer <  ?  super  integer >  t )  {  t . on subscribe (  disposables . empty (  )  )  ;  for  ( int i = 0 ;  i  <  m ;  i +  +  )   {  t . on next ( i )  ;   }  t . on complete (  )  ;   }  
public synchronized byte[]   (  )  {  if  (    sentx  =  =  null )  prepare session request (  )  ;  return    sentx ;   }  
public   ( final boolean ignore classes and fields hints )  {  super (  )  ;  final  list <  buffer >  buffers to delete = new  array list <  >  (  )  ;  final  map <  string  string >  attachment or byte buffer field name map = new  hash map <  >  (  )  ;  final  string java vendor =  system . get property ( "java . vendor" )  ;  final  string java version =  system . get property ( "java . version" )  ;  if  (  ! ignore classes and fields hints )   {  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  )   {  final  string java14to16 direct buffer attachment field name = "viewed buffer" ;  final  string java17to19 direct buffer attachment field name = "att" ;  final  string byte buffer as non byte buffer byte buffer field name = "bb" ;  final  string[] direct buffer classnames = new  string[] { "java . nio .  direct byte buffer" "java . nio .  direct byte bufferr" "java . nio .  direct char bufferrs" "java . nio .  direct char bufferru" "java . nio .  direct char buffers" "java . nio .  direct char bufferu" "java . nio .  direct double bufferrs" "java . nio .  direct double bufferru" "java . nio .  direct double buffers" "java . nio .  direct double bufferu" "java . nio .  direct float bufferrs" "java . nio .  direct float bufferru" "java . nio .  direct float buffers" "java . nio .  direct float bufferu" "java . nio .  direct int bufferrs" "java . nio .  direct int bufferru" "java . nio .  direct int buffers" "java . nio .  direct int bufferu" "java . nio .  direct long bufferrs" "java . nio .  direct long bufferru" "java . nio .  direct long buffers" "java . nio .  direct long bufferu" "java . nio .  direct short bufferrs" "java . nio .  direct short bufferru" "java . nio .  direct short buffers" "java . nio .  direct short bufferu" }  ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  byte buffer as char bufferb" "java . nio .  byte buffer as char bufferl" "java . nio .  byte buffer as char bufferrb" "java . nio .  byte buffer as char bufferrl" "java . nio .  byte buffer as double bufferb" "java . nio .  byte buffer as double bufferl" "java . nio .  byte buffer as double bufferrb" "java . nio .  byte buffer as double bufferrl" "java . nio .  byte buffer as float bufferb" "java . nio .  byte buffer as float bufferl" "java . nio .  byte buffer as float bufferrb" "java . nio .  byte buffer as float bufferrl" "java . nio .  byte buffer as int bufferb" "java . nio .  byte buffer as int bufferl" "java . nio .  byte buffer as int bufferrb" "java . nio .  byte buffer as int bufferrl" "java . nio .  byte buffer as long bufferb" "java . nio .  byte buffer as long bufferl" "java . nio .  byte buffer as long bufferrb" "java . nio .  byte buffer as long bufferrl" "java . nio .  byte buffer as short bufferb" "java . nio .  byte buffer as short bufferl" "java . nio .  byte buffer as short bufferrb" "java . nio .  byte buffer as short bufferrl" }  ;  final  string[] java version elements =  system . get property ( "java . version" )  . split ( "\\ . " )  ;  int index of early access suffix = java version elements[0] . last index of ( " - ea" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }  else  {  index of early access suffix = java version elements[0] . last index of ( " - internal" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }  else  {  index of early access suffix = java version elements[0] . last index of ( " -  ubuntu" )  ;  if  ( index of early access suffix  !  =   - 1 )   {  java version elements[0] = java version elements[0] . substring ( 0 index of early access suffix )  ;   }   }   }  final int major  minor ;  if  ( java version elements . length  >  =  2 )   {  major =  integer . parse int ( java version elements[0] )  ;  int min ;  try  {  min =  integer . parse int ( java version elements[1] )  ;   }  catch  (   number format exception nfe )   {  min = 7 ;   }  minor = min ;   }  else  {  major = 1 ;  int min ;  try  {  min =  integer . parse int ( java version elements[0] )  ;   }  catch  (   number format exception nfe )   {  min = 7 ;   }  minor = min ;   }  final  string direct buffer attachment field name ;  if  ( minor  =  =  1 && major  <  =  6 )  direct buffer attachment field name = java14to16 direct buffer attachment field name ;  else direct buffer attachment field name = java17to19 direct buffer attachment field name ;  for  (  final  string direct buffer classname : direct buffer classnames )  attachment or byte buffer field name map . put ( direct buffer classname direct buffer attachment field name )  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " the  android  project" )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "byte buffer" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  byte buffer as char buffer" "java . nio .  byte buffer as double buffer" "java . nio .  byte buffer as float buffer" "java . nio .  byte buffer as int buffer" "java . nio .  byte buffer as long buffer" "java . nio .  byte buffer as short buffer" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "bb" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  char view buffer impl" "java . nio .  double view buffer impl" "java . nio .  float view buffer impl" "java . nio .  int view buffer impl" "java . nio .  long view buffer impl" "java . nio .  short view buffer impl" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . contains ( " apache" )  )   {  final  string byte buffer as non byte buffer byte buffer field name = "byte buffer" ;  final  string[] byte buffer as non byte buffer classnames = new  string[] { "java . nio .  char to byte buffer adapter" "java . nio .  double to byte buffer adapter" "java . nio .  float to byte buffer adapter" "java . nio .  int to byte buffer adapter" "java . nio .  long to byte buffer adapter" "java . nio .  short to byte buffer adapter" }  ;  for  (  final  string byte buffer as non byte buffer classname : byte buffer as non byte buffer classnames )  attachment or byte buffer field name map . put ( byte buffer as non byte buffer classname byte buffer as non byte buffer byte buffer field name )  ;   }  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {   }  else if  ( java vendor . contains ( "ibm" )  )   {   }   }  if  (  ! attachment or byte buffer field name map . is empty (  )  )   {  final  list <  string >  classnames to remove = new  array list <  >  (  )  ;  for  (  final  string classname : attachment or byte buffer field name map . key set (  )  )  try  {   class . for name ( classname )  ;   }  catch  (   class not found exception cnfe )   {  classnames to remove . add ( classname )  ;   }  for  (  final  string classname to remove : classnames to remove )  attachment or byte buffer field name map . remove ( classname to remove )  ;   }  attachment or byte buffer field map = new  hash map <  >  (  )  ;  if  (  ! attachment or byte buffer field name map . is empty (  )  )  for  (  final  entry <  string  string >  attachment or byte buffer field name entry : attachment or byte buffer field name map . entry set (  )  )   {  final  string classname = attachment or byte buffer field name entry . get key (  )  ;  final  string fieldname = attachment or byte buffer field name entry . get value (  )  ;  try  {  final  class <  ?  >  buffer class =  class . for name ( classname )  ;   field buffer field = null ;   class <  ?  >  buffer intermediary class = buffer class ;  final  list <  class <  ?  >  >  intermediary class without buffer list = new  array list <  >  (  )  ;  while  ( buffer intermediary class  !  =  null )   {  try  {  buffer field = buffer intermediary class . get declared field ( fieldname )  ;   }  catch  (   no such field exception nsfe )   {  if  (  ! buffer intermediary class . equals (  object . class )  &&  ! buffer intermediary class . equals (  buffer . class )  )  intermediary class without buffer list . add ( buffer intermediary class )  ;   }  buffer intermediary class = buffer intermediary class . get superclass (  )  ;   }  if  ( buffer field  =  =  null )   {  final  string super classes msg ;  if  ( intermediary class without buffer list . is empty (  )  )  super classes msg = "" ;  else if  ( intermediary class without buffer list . size (  )   =  =  1 )  super classes msg = " and in its super class "  +  intermediary class without buffer list . get ( 0 )  . get name (  )  ;  else  {  final  string builder builder = new  string builder (  )  ;  builder . append ( " and in its super classes" )  ;  int class index = 0 ;  for  (  final  class <  ?  >  intermediary class without buffer : intermediary class without buffer list )   {  builder . append ( ' ' )  ;  builder . append ( intermediary class without buffer . get name (  )  )  ;  if  ( class index  <  intermediary class without buffer list . size (  )   -  1 )  builder . append ( ' ' )  ;  class index +  +  ;   }  super classes msg = builder . to string (  )  ;   }  logger . warn ( " the field "  +  fieldname  +  " hasn't been found in the class " +  classname +  super classes msg )  ;   }  else  {  attachment or byte buffer field map . put ( buffer class buffer field )  ;   }   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  classname  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }   }  if  ( attachment or byte buffer field name map . is empty (  )  )   {  final  byte buffer sliced big endian read only direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . big   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  . as read only buffer (  )  ;  final  byte buffer sliced big endian read write direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . big   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  ;  final  char buffer big endian read only direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as char buffer (  )  ;  final  char buffer big endian read write direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as char buffer (  )  ;  final  double buffer big endian read only direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as double buffer (  )  ;  final  double buffer big endian read write direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as double buffer (  )  ;  final  float buffer big endian read only direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as float buffer (  )  ;  final  float buffer big endian read write direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as float buffer (  )  ;  final  int buffer big endian read only direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as int buffer (  )  ;  final  int buffer big endian read write direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as int buffer (  )  ;  final  long buffer big endian read only direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as long buffer (  )  ;  final  long buffer big endian read write direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as long buffer (  )  ;  final  short buffer big endian read only direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as read only buffer (  )  . as short buffer (  )  ;  final  short buffer big endian read write direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . big   endian )  . as short buffer (  )  ;  final  byte buffer sliced little endian read only direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . little   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  . as read only buffer (  )  ;  final  byte buffer sliced little endian read write direct byte buffer =  (  (  byte buffer )  byte buffer . allocate direct ( 2 )  . order (  byte order . little   endian )  . put (  ( byte ) 0 )  . put (  ( byte ) 0 )  . position ( 1 )  . limit ( 2 )  )  . slice (  )  ;  final  char buffer little endian read only direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as char buffer (  )  ;  final  char buffer little endian read write direct char buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as char buffer (  )  ;  final  double buffer little endian read only direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as double buffer (  )  ;  final  double buffer little endian read write direct double buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as double buffer (  )  ;  final  float buffer little endian read only direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as float buffer (  )  ;  final  float buffer little endian read write direct float buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as float buffer (  )  ;  final  int buffer little endian read only direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as int buffer (  )  ;  final  int buffer little endian read write direct int buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as int buffer (  )  ;  final  long buffer little endian read only direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as long buffer (  )  ;  final  long buffer little endian read write direct long buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as long buffer (  )  ;  final  short buffer little endian read only direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as read only buffer (  )  . as short buffer (  )  ;  final  short buffer little endian read write direct short buffer =  byte buffer . allocate direct ( 1 )  . order (  byte order . little   endian )  . as short buffer (  )  ;  final  list <  buffer >  buffers = new  array list <  >  (  )  ;  buffers . add ( sliced big endian read only direct byte buffer )  ;  buffers . add ( sliced big endian read write direct byte buffer )  ;  buffers . add ( big endian read only direct char buffer )  ;  buffers . add ( big endian read write direct char buffer )  ;  buffers . add ( big endian read only direct double buffer )  ;  buffers . add ( big endian read write direct double buffer )  ;  buffers . add ( big endian read only direct float buffer )  ;  buffers . add ( big endian read write direct float buffer )  ;  buffers . add ( big endian read only direct int buffer )  ;  buffers . add ( big endian read write direct int buffer )  ;  buffers . add ( big endian read only direct long buffer )  ;  buffers . add ( big endian read write direct long buffer )  ;  buffers . add ( big endian read only direct short buffer )  ;  buffers . add ( big endian read write direct short buffer )  ;  buffers . add ( sliced little endian read only direct byte buffer )  ;  buffers . add ( sliced little endian read write direct byte buffer )  ;  buffers . add ( little endian read only direct char buffer )  ;  buffers . add ( little endian read write direct char buffer )  ;  buffers . add ( little endian read only direct double buffer )  ;  buffers . add ( little endian read write direct double buffer )  ;  buffers . add ( little endian read only direct float buffer )  ;  buffers . add ( little endian read write direct float buffer )  ;  buffers . add ( little endian read only direct int buffer )  ;  buffers . add ( little endian read write direct int buffer )  ;  buffers . add ( little endian read only direct long buffer )  ;  buffers . add ( little endian read write direct long buffer )  ;  buffers . add ( little endian read only direct short buffer )  ;  buffers . add ( little endian read write direct short buffer )  ;  for  (   buffer buffer : buffers )   {  final  class <  ?  >  buffer class = buffer . get class (  )  ;  if  (  ! attachment or byte buffer field map . contains key ( buffer class )  )   {   field buffer field = null ;   class <  ?  >  buffer intermediary class = buffer class ;  while  ( buffer intermediary class  !  =  null && buffer field  =  =  null )   {  for  (  final  field field : buffer intermediary class . get declared fields (  )  )   {  final boolean field was accessible = field . is accessible (  )  ;  try  {  field . set accessible ( true )  ;  final  object field value = field . get ( buffer )  ;  if  ( field value  !  =  null && field value instanceof  buffer )   {  buffer field = field ;  break ;   }   }  catch  (   illegal access exception iae )   {  logger . warn ( " cannot access the field "  +  field . get name (  )   +  " of the class " +  buffer intermediary class . get name (  )  iae )  ;   }  finally  {  field . set accessible ( field was accessible )  ;   }   }  buffer intermediary class = buffer intermediary class . get superclass (  )  ;   }  if  ( buffer field  !  =  null )  attachment or byte buffer field map . put ( buffer class buffer field )  ;   }   }  buffers to delete . add all ( buffers )  ;   }  deallocatable buffer class set = new  hash set <  >  (  )  ;  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  || java vendor . equals ( " the  android  project" )  )   {   class <  ?  >  direct byte buffer class = null ;  final  string direct byte buffer class name = "java . nio .  direct byte buffer" ;  try  {  direct byte buffer class =  class . for name ( direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( direct byte buffer class )  ;   }  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )   {   class <  ?  >  read only direct byte buffer class = null ;  final  string read only direct byte buffer class name = "java . nio .  direct byte buffer impl .  read only" ;  try  {  read only direct byte buffer class =  class . for name ( read only direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read only direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read only direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read only direct byte buffer class )  ;   class <  ?  >  read write direct byte buffer class = null ;  final  string read write direct byte buffer class name = "java . nio .  direct byte buffer impl .  read write" ;  try  {  read write direct byte buffer class =  class . for name ( read write direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read write direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read write direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read write direct byte buffer class )  ;   }  else if  ( java vendor . contains ( " apache" )  )   {   class <  ?  >  read only direct byte buffer class = null ;  final  string read only direct byte buffer class name = "java . nio .  read only direct byte buffer" ;  try  {  read only direct byte buffer class =  class . for name ( read only direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read only direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read only direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read only direct byte buffer class )  ;   class <  ?  >  read write direct byte buffer class = null ;  final  string read write direct byte buffer class name = "java . nio .  read write direct byte buffer" ;  try  {  read write direct byte buffer class =  class . for name ( read write direct byte buffer class name )  ;   }  catch  (   class not found exception cnfe )   {  final  string msg = " the class "  +  read write direct byte buffer class name  +  " hasn't been found while initializing the deallocator .   java vendor: " +  java vendor +  "  java version: " +  java version ;  logger . warn ( msg cnfe )  ;   }  if  ( read write direct byte buffer class  !  =  null )  deallocatable buffer class set . add ( read write direct byte buffer class )  ;   }  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {   }  else if  ( java vendor . contains ( "ibm" )  )   {   }  if  ( deallocatable buffer class set . is empty (  )  )   {  final  byte buffer dummy read write direct byte buffer =  byte buffer . allocate direct ( 1 )  ;  final  class <  ?  >  read write direct byte buffer class = dummy read write direct byte buffer . get class (  )  ;  deallocatable buffer class set . add ( read write direct byte buffer class )  ;  buffers to delete . add ( dummy read write direct byte buffer )  ;  final  byte buffer dummy read only direct byte buffer =  byte buffer . allocate direct ( 1 )  . as read only buffer (  )  ;  final  class <  ?  >  read only direct byte buffer class = dummy read only direct byte buffer . get class (  )  ;  deallocatable buffer class set . add ( read only direct byte buffer class )  ;  buffers to delete . add ( dummy read only direct byte buffer )  ;   }  if  ( java vendor . equals ( " sun  microsystems  inc . " )  || java vendor . equals ( " oracle  corporation" )  )  deallocator = new  oracle sun open jdk deallocator (  )  ;  else if  ( java vendor . equals ( " the  android  project" )  )  deallocator = new  android deallocator (  )  ;  else if  ( java vendor . equals ( " free  software  foundation   inc . " )  )  deallocator = new  gnu classpath deallocator (  )  ;  else if  ( java vendor . contains ( " apache" )  )  deallocator = new  apache harmony deallocator (  )  ;  else if  ( java vendor . equals ( " jeroen  frijters" )  )   {  deallocator = null ;   }  else if  ( java vendor . contains ( "ibm" )  )   {  deallocator = null ;   }  else deallocator = null ;  for  (  final  buffer buffer to delete : buffers to delete )  deallocate ( buffer to delete )  ;   }  
public   (  transport session < b >  session )  {  this . session ref = new  weak reference <  transport session < b >  >  ( session )  ;   }  
@ test public void   (  )  {   flowable <  string >  a =  single . just ( "a" )  . to flowable (  )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;  a . subscribe ( ts )  ;  ts . assert value ( "a" )  ;  ts . assert no err
public static int   (  string workgroup name  date start date  date end date )  {   workgroup workgroup = null ;  try  {  workgroup =  workgroup manager . get instance (  )  . get workgroup ( new jid ( workgroup name )  )  ;   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  if  ( workgroup  =  =  null )   {  return 0 ;   }  int count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( workgroup   state   request   count )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  pstmt . set int ( 2 1 )  ;  pstmt . set string ( 3  string utils . date to millis ( start date )  )  ;  pstmt . set string ( 4  string utils . date to millis ( end date )  )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  count = rs . get int ( 1 )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return count ;   }  
public   (  string network int mask )  throws  unknown host exception  {  this . network =  inet address . get by name ( network )  . get address (  )  ;  this . mask = mask ;   }  
public void   (  string contact  string nickname  list <  string >  grouplist )  {  if  ( grouplist  =  =  null )   {  grouplist = new  array list <  string >  (  )  ;   }  if  ( grouplist . is empty (  )  )   {   log . debug ( " no groups provided for the sync of contact "  +  contact  +  " .   using default group . " )  ;  grouplist . add ( get default group (  )  )  ;   }   log . debug ( " syncing contact  =  "  +  contact  +  "  nickname  =  " +  nickname +  "  grouplist  =  " +  grouplist )  ;  oscar buddy oscar buddy = null ;  try  {  final jid jid = parent . get transport (  )  . convertid tojid ( contact )  ;  oscar buddy = parent . get buddy manager (  )  . get buddy ( jid )  ;   log . debug ( " found related oscarbuddy: "  +  oscar buddy )  ;   }  catch  (   not found exception e )   {   log . debug ( " didn't find related oscarbuddy .   one will be created . " )  ;   }  final  list <  buddy item >  free buddy items = new  array list <  buddy item >  (  )  ;  if  ( oscar buddy  !  =  null )   {  for  (   buddy item buddy : oscar buddy . get buddy items (  )  )   {  if  (  ! groups . contains key ( buddy . get group id (  )  )  )   {   log . debug ( " removing "  +  buddy  +  " because of unknown group" )  ;  free buddy items . add ( buddy )  ;   }  else if  (  ! grouplist . contains ( groups . get ( buddy . get group id (  )  )  . get group name (  )  )  )   {   log . debug ( " removing "  +  buddy  +  " because not in list of groups" )  ;  free buddy items . add ( buddy )  ;   }  else  {  if  ( buddy . get alias (  )   =  =  null ||  ! buddy . get alias (  )  . equals ( nickname )  )   {   log . debug ( " updating alias for "  +  buddy )  ;  buddy . set alias ( nickname )  ;  request ( new  pre mod cmd (  )  )  ;  request ( new  modify items cmd ( buddy . to ssi item (  )  )  )  ;  request ( new  post mod cmd (  )  )  ;  update highest id ( buddy )  ;  oscar buddy . tie buddy item ( buddy true )  ;   }   }   }   }  for  (   string group : grouplist )   {   integer group id = get group id or create new ( group )  ;  if  ( is member of group ( group id contact )  )   {  continue ;   }   integer new buddy id = 1 ;  if  ( highest buddy id per group . contains key ( group id )  )   {  new buddy id = get next buddy id ( group id )  ;   }  if  ( free buddy items . size (  )   >  0 )   {  request ( new  pre mod cmd (  )  )  ;   buddy item buddy = free buddy items . remove ( 0 )  ;   buddy item new buddy = new  buddy item ( buddy )  ;  new buddy . set groupid ( group id )  ;  new buddy . set id ( new buddy id )  ;  new buddy . set alias ( nickname )  ;  request ( new  delete items cmd ( buddy . to ssi item (  )  )  )  ;  if  ( oscar buddy  !  =  null )   {  oscar buddy . remove buddy item ( buddy . get group id (  )  false )  ;   }  request ( new  create items cmd ( new buddy . to ssi item (  )  )  )  ;  if  ( oscar buddy  =  =  null )   {  oscar buddy = new oscar buddy ( parent . get buddy manager (  )  new buddy )  ;  request ( new  buddy auth request ( contact " automated add request on behalf of user . " )  )  ;   }  else  {  oscar buddy . tie buddy item ( new buddy false )  ;   }  request ( new  post mod cmd (  )  )  ;   }  else  {  final  buddy item new buddy = new  buddy item ( contact group id new buddy id )  ;  new buddy . set alias ( nickname )  ;  update highest id ( new buddy )  ;  if  ( parent . get transport (  )  . get type (  )  . equals (  transport type . icq )  )   {  new buddy . set awaiting auth ( true )  ;   }  request ( new  pre mod cmd (  )  )  ;  request ( new  create items cmd ( new buddy . to ssi item (  )  )  )  ;  request ( new  post mod cmd (  )  )  ;  if  ( oscar buddy  =  =  null )   {  oscar buddy = new oscar buddy ( parent . get buddy manager (  )  new buddy )  ;  request ( new  buddy auth request ( contact " automated add request on behalf of user . " )  )  ;   }  else  {  oscar buddy . tie buddy item ( new buddy true )  ;   }   }   }  for  (   buddy item buddy : free buddy items )   {  request ( new  delete items cmd ( buddy . to ssi item (  )  )  )  ;  if  ( oscar buddy  !  =  null )   {  oscar buddy . remove buddy item ( buddy . get group id (  )  false )  ;   }   }  if  ( oscar buddy  !  =  null )   {  parent . get buddy manager (  )  . store buddy ( oscar buddy )  ;   }   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    (  observable source <  ?  extends t >  .  .  .  sources )  {  return from array ( sour
private static boolean   (  string a  string .  .  .  others )  {  for  (   string other : others )   {  if  ( a . equals ignore case ( other )  )   {  return true ;   }   }  return false ;   }  
public int   (  )  throws sql exception  {  return cstmt . get fetch size (  )  ;   }  
@ override public void   (  )  {  socket . close session (  )  ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
private  configured limit group   (  configured limit group original group )  {  final  configured limit group new group = new  configured limit group (  )  ;  new group . set default ( original group . is default (  )  )  ;  new group . set id ( original group . get id (  )  )  ;  final  list <  string >  new role list = new  array list <  >  ( original group . get groups (  )  )  ;   collections . copy ( new role list original group . get groups (  )  )  ;  new group . get groups (  )  . add all ( new role list )  ;  final  list <  configured ratelimit >  new limits = new  array list <  >  ( original group . get limit (  )  )  ;   collections . copy ( new limits original group . get limit (  )  )  ;  new group . get limit (  )  . add all ( new limits )  ;  return new group ;   }  
@ override public void   (  remote packet router remote packet router )  {  this . remote packet router = remote packet router ;   }  
private void   (  update listener upd  object cfg )  throws  update failed exception  {  upd . configuration updated ( cfg )  ;  log . debug ( " configuration  updated: "  +  cfg . to string (  )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . equals ( null just1 )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay subscription (  (  flowable <  object >  ) null )  ;   }  
@ override public  string   (  )  {  return " encodes a cache key into a representation that the distributed datastore can address . " ;   }  
private void   ( pep service pep service jid subscriber jid owner )  {  iq subscription packet = new iq ( iq .  type . set )  ;  subscription packet . set from ( subscriber )  ;  subscription packet . set to ( owner . to barejid (  )  )  ;   element pubsub element = subscription packet . set child element ( "pubsub" "http: /  / jabber . org / protocol / pubsub" )  ;   element subscribe element = pubsub element . add element ( "subscribe" )  ;  subscribe element . add attribute ( "jid" subscriber . to barejid (  )  )  ;   element options element = pubsub element . add element ( "options" )  ;   element x element = options element . add element ( q name . get ( "x" "jabber:x:data" )  )  ;   data form data form = new  data form ( x element )  ;   form field form field = data form . add field (  )  ;  form field . set variable ( "form   type" )  ;  form field . set type (  form field .  type . hidden )  ;  form field . add value ( "http: /  / jabber . org / protocol / pubsub#subscribe   options" )  ;  form field = data form . add field (  )  ;  form field . set variable ( "pubsub#subscription   type" )  ;  form field . add value ( "items" )  ;  form field = data form . add field (  )  ;  form field . set variable ( "pubsub#subscription   depth" )  ;  form field . add value ( "all" )  ;  pep service manager . process ( pep service subscription packet )  ;   }  
public int   (  )  {  return  (  (  (  ( int ) rtcp data[16] )   <  <  24 )  & 0xff000000 )  |  (  (  (  ( int ) rtcp data[17] )   <  <  16 )  & 0x00ff0000 )  |  (  (  (  ( int ) rtcp data[18] )   <  <  8 )  & 0x0000ff00 ) |  ( rtcp data[19] & 0xff )  ;   }  
@ override public  set <  map .  entry < k v >  >    (  )  {  return cache . entry set (  )  ;   }  
@ test public void   (  )  {  final  atomic boolean completed = new  atomic boolean (  )  ;   observable . just ( 0 1 )  . switch map single delay error ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <
public long   (  )  throws io exception  {  return delegate . get file pointer (  )  ;   }  
public boolean[]   (  )  {  return week ;   }  
@ test public void   (  )  throws  exception  {   signature sgr = new  eddsa engine (  message digest . get instance ( "sha - 512" )  )  ;   eddsa parameter spec spec =  eddsa named curve table . get by name ( "ed25519 - sha - 512" )  ;  for  (   ed25519 
public long   (  )  {  return queue wait time ;   }  
@ override @ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  super . test structure (  )  ;   }  
public   ( final  collect wgs metrics metrics final int coverage cap final  interval list intervals )  {  super ( metrics coverage cap intervals )  ;   }  
 collection <  local client session >    (  )  {   list <  local client session >  sessions = new  array list <  >  (  )  ;  for  (   routable channel handler route : routes . values (  )  )   {  if  ( route instanceof  local client session )   {  sessions . add (  (  local client session ) route )  ;   }   }  return sessions ;   }  
public  string   (  file signed file )  {  for  (   signing public key signing public key :    trusted keys . key set (  )  )   {  boolean is valid signature = verify ( signed file signing public key )  ;  if  ( is valid signature )  return    trusted keys . get ( signing public key )  ;   }  return null ;   }  
public static void   (  input stream in long n )  throws io exception  {  if  ( n  <  0 )  throw new  illegal argument exception (  )  ;  if  ( n  =  =  0 )  return ;  long read = 0 ;  long nm1 = n  -  1 ;  if  ( nm1  >  0 )   {  do  {  long c = in . skip ( nm1  -  read )  ;  if  ( c  <  0 )  throw new eof exception ( "eof while skipping "  +  n  +  "  read only " +  read )  ;  if  ( c  =  =  0 )   {  if  ( in . read (  )   =  =   - 1 )  throw new eof exception ( "eof while skipping "  +  n  +  "  read only " +  read )  ;  read +  +  ;   }  else  {  read +  = c ;   }   }  while  ( read  <  nm1 )  ;   }  if  ( in . read (  )   =  =   - 1 )  throw new eof exception ( "eof while skipping "  +  n  +  "  read only " +  read )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . element at ( 1 10 )  . to flowable (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   flowable <  integer >  just =  flowable . just ( 1 )  ;   test subscriber <  list <  integer >  >  ts = new  test subscriber <  list <  integer >  >  (  )  ;  just . with latest from ( just just just new  function4 <  intege
public xmpp server info   (  )  {  if  (  ! initialized )   {  throw new  illegal state exception ( " not initialized yet" )  ;   }  return xmpp server info ;   }  
  (  string .  .  .  values )  {  this . values = values ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write serializable ( out componentjid )  ;   }  
@ test public void   (  )  {   observable . range ( 1 10 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . just
@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
private  < t > void   ( final  observer < t >  observer final t value int delay )  {  inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  observer . on next ( value )  ;   }   }   delay  time unit . milliseconds )  ;   }  
private static  string   (  string s )  {  return s . replace all ( " < " "&lt ; " )  . replace all ( " > " "&gt ; " )  ;   }  
public void   (  object factory object factory )  {  this . object factory = object factory ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer counter = new  atomic integer (  )  ;   observable <  integer >  oi =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void sub
public int   (  )  {  return    status ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
private  object pool <  xml filter chain >    ( final  translation base translation )  {  return new  soft reference object pool <  >  ( new  xml filter chain factory ( xslt chain builder translation configuration root config )  )  ;   }  
public boolean   ( int tunnel )  {  return    helper . is interactive ( tunnel )  ;   }  
public long   (  )  {  return free mem ;   }  
public  ask type   (  )  {  if  ( is shared (  )  )   {  return ask   none ;   }  else  {  return ask status ;   }   }  
protected int   (  )  {  return search   bredth ;   }  
public static boolean   (  atomic reference <  subscription >  field  subscription s long request )  {  if  ( set once ( field s )  )   {  s . request ( request )  ;  return true ;   }  return false ;   }  
@ test public void   (  )  {  final  variant iterator producer .  threadsafe iterator factory = new  variant iterator producer .  threadsafe (  vcf file segment generator . by whole contig subdividing with width ( ten   million )   arrays . as list ( vcf 
@ test public void   (  )  {   executor service exec =  executors . new fixed thread pool ( 3 )  ;   scheduler s =  schedulers . from ( exec )  ;  try  {   callable <  list <  integer >  >  as = new  callable <  list <  integer >  >  (  )  {  @ override p
@ override public  string   (  )  {  return chat service name  +  " . "  +  xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;   }  
@ test public void   (  )  {   flowable . never (  )  . test (  )  . await count ( 1  test wait strategy . sleep   1ms 50 )  . assert timeout (  )  ;   }  
@ override public void   (  object e )  throws  exception  {  throw new  test exception ( " second" )  ;   }  
@ test public void   (  )  {  assert that ( versioned   uri matches pattern (  variant parser . variant   regex )  )  ;   }  
@ test public void   (  )  {  final  subject <  integer >  ps =  publish subject .  <  integer > create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ override public void on next (   integer t )  {  super . on next
@ test public void   (  )  throws io exception  {  byte orig[] = new byte[256 * 1024] ;     context . random (  )  . next bytes ( orig )  ;  for  ( int i = 0 ;  i  <  orig . length  /  1024 ;  i +  +  )   {  byte msg[] = new byte[1024] ;   system . arrayc
default  this   (  collector factory factory )  {  return configure (  jdbi collectors . class c  -  >  c . register ( factory )  )  ;   }  
public boolean   ( long period )  {  return get rate ( period )   !  =  null ;   }  
public  string   (  )  throws  unknowncpu exception  {   string smodel = identifycpu (  )  ;  if  ( smodel  !  =  null )  return smodel ;  throw new  unknowncpu exception ( " unknown amd cpu ;   family = "  +  cpuid . getcpu family (  )   +  ' / ' +  cpuid . getcpu extended family (  )  +  "   model = " +  cpuid . getcpu model (  )  +  ' / ' +  cpuid . getcpu extended model (  )  )  ;   }  
public static void   (  output stream raw stream  properties props boolean utf8 boolean sort )  throws  data format exception  io exception  {  if  ( props  !  =  null &&  ! props . is empty (  )  )   {   properties p ;  if  ( sort )   {  p = new  ordered properties (  )  ;  p . put all ( props )  ;   }  else  {  p = props ;   }   byte array output stream baos = new  byte array output stream ( p . size (  )  * 64 )  ;  for  (   map .  entry <  object  object >  entry : p . entry set (  )  )   {   string key =  (  string ) entry . get key (  )  ;   string val =  (  string ) entry . get value (  )  ;  if  ( utf8 )  write stringutf8 ( baos key )  ;  else write string ( baos key )  ;  baos . write ( ' = ' )  ;  if  ( utf8 )  write stringutf8 ( baos val )  ;  else write string ( baos val )  ;  baos . write ( ' ; ' )  ;   }  if  ( baos . size (  )   >  65535 )  throw new  data format exception ( " properties too big  ( 65535 max ) : "  +  baos . size (  )  )  ;  byte prop bytes[] = baos . to byte array (  )  ;  write long ( raw stream 2 prop bytes . length )  ;  raw stream . write ( prop bytes )  ;   }  else  {  write long ( raw stream 2 0 )  ;   }   }  
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . msn . username" "kraken" )  ;   }  
public  string   (  )  {  return this . config root ;   }  
 string   (  )  {   packet handler handler =    handler ;  if  ( handler  !  =  null )  return handler . get handler status (  )  ;  else return "" ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {  final  atomic reference <  observer <  ?  super  object >  >  ref main = new  atomic reference <  observer <  ?  super  object >  >  (  )  ;  fina
private void   ( int new size )  {  try  {  pool lock . lock (  )  ;  max pool size = new size ;  while  ( pool . size (  )   +  checkout counter  >  max pool size &&  ! pool . is empty (  )  )   {  pool . poll (  )  ;   }   }  finally  {  pool lock . unlock (  )  ;   }   }  
@ test public void   (  )  {   observable . never (  )  . timeout ( 100  time unit . milliseconds  observable . just ( 1 )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 )  ;   }  
@ override public void   (  input stream in int length int type )  throws i2cp message exception  io exception  {  super . read message ( in length type )  ;  try  {     daf . read bytes ( in )  ;   }  catch  (   data format exception dfe )   {  throw new
private boolean   ( int type )  {  boolean removed = false ;  synchronized  ( send queue )   {   iterator <  message >  it = send queue . iterator (  )  ;  while  ( it . has next (  )  )   {   message m = it . next (  )  ;  if  ( m . type  =  =  type )   {  it . remove (  )  ;  removed = true ;  if  ( type  =  =   message . piece && peer . supports fast (  )  )   {   message r = new  message (  message . reject m . piece m . begin m . length )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +  peer  +  ": " +  r )  ;  try  {  r . send message ( dout )  ;   }  catch  (  io exception ioe )   {   }   }   }   }  send queue . notify all (  )  ;   }  return removed ;   }  
public   (  )  {     lost packet id plus1 =  boolean . value of ( false )  ;     lost packet id plus10 =  boolean . value of ( false )  ;     lost packet id plus11 =  boolean . value of ( false )  ;     lost packet id plus12 =  boolean . value of ( false )  ;     lost packet id plus13 =  boolean . value of ( false )  ;     lost packet id plus14 =  boolean . value of ( false )  ;     lost packet id plus15 =  boolean . value of ( false )  ;     lost packet id plus16 =  boolean . value of ( false )  ;     lost packet id plus2 =  boolean . value of ( false )  ;     lost packet id plus3 =  boolean . value of ( false )  ;     lost packet id plus4 =  boolean . value of ( false )  ;     lost packet id plus5 =  boolean . value of ( false )  ;     lost packet id plus6 =  boolean . value of ( false )  ;     lost packet id plus7 =  boolean . value of ( false )  ;     lost packet id plus8 =  boolean . value of ( false )  ;     lost packet id plus9 =  boolean . value of ( false )  ;     packet id =  integer . value of ( 0 )  ;   }  
@ beta @ suppress warnings ( "rawtypes" )  public static void   ( @ nullable  function <  ?  super  parallel flowable  ?  extends  parallel flowable >  handler )  {  if  ( lockdown )   {  throw new  illegal state exception ( " plugins can't be changed any
void   ( long n )  {  request ( n )  ;   }  
@ test public void   (  )  {   single . zip (  single . error ( new  test exception (  )  )   single . just ( 1 )  add string )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . from action ( null )  ;   }  
static void   ( int num data bytes  bit array bits )  throws  writer exception  {  int capacity = num data bytes * 8 ;  if  ( bits . get size (  )   >  capacity )   {  throw new  writer exception ( "data bits cannot fit in the qr  code"  +  bits . get size (  )   +  "  >  " +  capacity )  ;   }  for  ( int i = 0 ;  i  <  4 && bits . get size (  )   <  capacity ;   +  + i )   {  bits . append bit ( false )  ;   }  int num bits in last byte = bits . get size (  )  & 0x07 ;  if  ( num bits in last byte  >  0 )   {  for  ( int i = num bits in last byte ;  i  <  8 ;  i +  +  )   {  bits . append bit ( false )  ;   }   }  int num padding bytes = num data bytes  -  bits . get size in bytes (  )  ;  for  ( int i = 0 ;  i  <  num padding bytes ;   +  + i )   {  bits . append bits (  ( i & 0x01 )   =  =  0  ?  0xec : 0x11 8 )  ;   }  if  ( bits . get size (  )   !  =  capacity )   {  throw new  writer exception ( " bits size does not equal capacity" )  ;   }   }  
@ override public void   ( b t )  {  if  ( once )   {  return ;   }  once = true ;  dispose (  )  ;  parent . next (  )  ;   }  
private  regular time period   ( long time period  date date  time zone zone )  {  if  ( time period  >  86400000 )   {  return new  day ( date zone )  ;   }  else if  ( time period  >  3600000 )   {  return new  hour ( date zone )  ;   }  else  {  return new  minute ( date zone )  ;   }   }  
public void   (  string name )  {  this . name = name ;   }  
@ test public void   (  )  throws io exception  {  int expected = 0 ;  assert equals ( expected stream . skip ( magic   skip )  )  ;  verify ( buffer times ( 1 )  )  . skip ( any int (  )  )  ;   }  
void   (  )  {  if  ( once . compare and set ( false true )  )   {  parent . emit ( idx value this )  ;   }   }  
public long   (  string event name )  {  long now =    context . clock (  )  . now (  )  ;  if  (    log . should log (  log . info )  )   {  synchronized  ( this )   {  locked   init timestamps (  )  ;     timestamps . put ( event name  long . value of ( now )  )  ;     timestamp order . add ( event name )  ;   }   }  return now  -     created ;   }  
public void   (  )  {   log . info ( "["  +  name  +  "] destroy " +  name +  " plugin resources" )  ;  if  ( database  !  =  null )   {  database . stop (  )  ;   jmx helper . unregister ( objectname   databasepool )  ;   }  if  ( client  !  =  null )   {  client . stop (  )  ;   jmx helper . unregister ( objectname   core   client   threadpool )  ;   }  if  ( packet counter  !  =  null )   {  packet counter . stop (  )  ;   jmx helper . unregister ( objectname   packet   counter )  ;   }  if  ( openfire  !  =  null )   {  openfire . stop (  )  ;   jmx helper . unregister ( objectname   openfire )  ;   }  if  ( email scheduler  !  =  null )   {  email scheduler . stop monitoring (  )  ;   }   http bind manager . get instance (  )  . remove jetty handler ( context )  ;   http bind manager . get instance (  )  . remove jetty handler ( context2 )  ;   log . info ( "["  +  name  +  "] plugin fully destroyed . " )  ;   }  
@ override public int   (  )  {  return major version ;   }  
private boolean   (  policy set ps  policy policy )  {  if  (  ( ps . m password mode  >  >   legacy policy set . password   mode   shift )   !  =  policy . m password mode )   {  return false ;   }  if  ( ps . m min password length  !  =  policy . m password min length )  return false ;  if  ( ps . m password complex chars  !  =  policy . m password complex chars )  return false ;  if  ( ps . m password history  !  =  policy . m password history )  return false ;  if  ( ps . m password expiration days  !  =  policy . m password expiration days )  return false ;  if  ( ps . m max password fails  !  =  policy . m password max fails )  return false ;  if  ( ps . m max screen lock time  !  =  policy . m max screen lock time )  return false ;  if  ( ps . m require remote wipe  !  =  policy . m require remote wipe )  return false ;  if  ( ps . m require encryption  !  =  policy . m require encryption )  return false ;  if  ( ps . m require encryption external  !  =  policy . m require encryption external )  return false ;  return true ;   }  
private static void   ( final  context context )  {  synchronized  ( suri matcher )   {  if  ( integrity   check   uri  !  =  null )   {  return ;   }  integrity   check   uri =  uri . parse ( "content: /  / "  +   email content . authority  +  " / integrity check" )  ;  account   backup   uri =  uri . parse ( "content: /  / "  +   email content . authority  +  " / account backup" )  ;  folder   status   uri =  uri . parse ( "content: /  / "  +   email content . authority  +  " / status" )  ;  email   app   mime   type = context . get string ( r . string . application   mime   type )  ;  final  string ui notification authority =  email content . email   package   name  +  " . uinotifications" ;  uiprovider   conversation   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uimessages" )  ;  uiprovider   folder   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uifolder" )  ;  uiprovider   folderlist   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uifolders" )  ;  uiprovider   account   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uiaccount" )  ;  uiprovider   attachment   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uiattachment" )  ;  uiprovider   attachments   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uiattachments" )  ;  uiprovider   all   accounts   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uiaccts" )  ;  uiprovider   message   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uimessage" )  ;  uiprovider   recent   folders   notifier =  uri . parse ( "content: /  / "  +  ui notification authority  +  " / uirecentfolders" )  ;  suri matcher . adduri (  email content . authority "account" account )  ;  suri matcher . adduri (  email content . authority "account / #" account   id )  ;  suri matcher . adduri (  email content . authority "account check / #" account   check )  ;  suri matcher . adduri (  email content . authority "mailbox" mailbox )  ;  suri matcher . adduri (  email content . authority "mailbox / *" mailbox   id )  ;  suri matcher . adduri (  email content . authority "mailbox notification / #" mailbox   notification )  ;  suri matcher . adduri (  email content . authority "mailbox most recent message / #" mailbox   most   recent   message )  ;  suri matcher . adduri (  email content . authority "mailbox count / #" mailbox   message   count )  ;  suri matcher . adduri (  email content . authority "message" message )  ;  suri matcher . adduri (  email content . authority "message / #" message   id )  ;  suri matcher . adduri (  email content . authority "attachment" attachment )  ;  suri matcher . adduri (  email content . authority "attachment / #" attachment   id )  ;  suri matcher . adduri (  email content . authority "attachment / message / #" attachments   message   id )  ;  suri matcher . adduri (  email content . authority "attachment / cached file" attachments   cached   file   access )  ;  suri matcher . adduri (  email content . authority "body" body )  ;  suri matcher . adduri (  email content . authority "body / #" body   id )  ;  suri matcher . adduri (  email content . authority "body html / #" body   html )  ;  suri matcher . adduri (  email content . authority "body text / #" body   text )  ;  suri matcher . adduri (  email content . authority "hostauth" hostauth )  ;  suri matcher . adduri (  email content . authority "hostauth / *" hostauth   id )  ;  suri matcher . adduri (  email content . authority "credential" credential )  ;  suri matcher . adduri (  email content . authority "credential / *" credential   id )  ;  suri matcher . adduri (  email content . authority "synced message / #" synced   message   id )  ;  suri matcher . adduri (  email content . authority "message by selection" message   selection )  ;  suri matcher . adduri (  email content . authority  message move . path message   move )  ;  suri matcher . adduri (  email content . authority  message state change . path message   state   change )  ;  suri matcher . adduri (  email content . authority "deleted message" deleted   message )  ;  suri matcher . adduri (  email content . authority "deleted message / #" deleted   message   id )  ;  suri matcher . adduri (  email content . authority "updated message" updated   message )  ;  suri matcher . adduri (  email content . authority "updated message / #" updated   message   id )  ;  suri matcher . adduri (  email content . authority "policy" policy )  ;  suri matcher . adduri (  email content . authority "policy / #" policy   id )  ;  suri matcher . adduri (  email content . authority "quickresponse" quick   response )  ;  suri matcher . adduri (  email content . authority "quickresponse / #" quick   response   id )  ;  suri matcher . adduri (  email content . authority "quickresponse / account / #" quick   response   account   id )  ;  suri matcher . adduri (  email content . authority "uifolders / #" ui   folders )  ;  suri matcher . adduri (  email content . authority "uifullfolders / #" ui   full   folders )  ;  suri matcher . adduri (  email content . authority "uiallfolders / #" ui   all   folders )  ;  suri matcher . adduri (  email content . authority "uisubfolders / #" ui   subfolders )  ;  suri matcher . adduri (  email content . authority "uimessages / #" ui   messages )  ;  suri matcher . adduri (  email content . authority "uimessage / #" ui   message )  ;  suri matcher . adduri (  email content . authority "uiundo" ui   undo )  ;  suri matcher . adduri (  email content . authority query   uirefresh  +  " / #" ui   folder   refresh )  ;  suri matcher . adduri (  email content . authority "uifolder / *" ui   folder )  ;  suri matcher . adduri (  email content . authority "uiinbox / #" ui   inbox )  ;  suri matcher . adduri (  email content . authority "uiaccount / #" ui   account )  ;  suri matcher . adduri (  email content . authority "uiaccts" ui   accts )  ;  suri matcher . adduri (  email content . authority "uiacctsettings" ui   acctsettings )  ;  suri matcher . adduri (  email content . authority "uiattachments / #" ui   attachments )  ;  suri matcher . adduri (  email content . authority "uiattachment / #" ui   attachment )  ;  suri matcher . adduri (  email content . authority "uiattachmentbycid / # / *" ui   attachment   by   cid )  ;  suri matcher . adduri (  email content . authority "uisearch / #" ui   search )  ;  suri matcher . adduri (  email content . authority "uiaccountdata / #" ui   account   data )  ;  suri matcher . adduri (  email content . authority "uiloadmore / #" ui   folder   load   more )  ;  suri matcher . adduri (  email content . authority "uiconversation / #" ui   conversation )  ;  suri matcher . adduri (  email content . authority "uirecentfolders / #" ui   recent   folders )  ;  suri matcher . adduri (  email content . authority "uidefaultrecentfolders / #" ui   default   recent   folders )  ;  suri matcher . adduri (  email content . authority "pick trash folder / #" account   pick   trash   folder )  ;  suri matcher . adduri (  email content . authority "pick sent folder / #" account   pick   sent   folder )  ;  suri matcher . adduri (  email content . authority "uipurgefolder / #" ui   purge   folder )  ;   }   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . observe on (  schedulers . computation (  )  )  . observe on (  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert failure (  test ex
@ test public void   (  )  {   completable subject cs =  completable subject . create (  )  ;   test observer <  void >  to = cs . test (  )  ;  cs . on complete (  )  ;   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  c
private  message   (  string transport  string command )  {   message message = new  message (  )  ;  message . set from ( admin user )  ;  message . set to ( transport )  ;  message . setid ( command )  ;  message . set body ( command )  ;  message . set type (  type . chat )  ;  return message ;   }  
public  snark   (  string filename )  {  synchronized  (    snarks )   {  return    snarks . get ( filename )  ;   }   }  
@ override public void   (  )  {  inner complete ( this )  ;   }  
public static void   (  workgroup workgroup  string sessionid )  {  for  (   workgroup event listener listener : listeners )   {  try  {  listener . chat support started ( workgroup sessionid )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
public int   (  )  {  return m timeout ;   }  
void   (  )  {  if  ( compare and set ( 0 1 )  )   {  try  {  on finally . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }   }   }  
@ override public  single <  ?  extends  integer >    (  integer v )  throws  exception  {  return  single . just ( v )  ;   }  
public static void   (  string args[] )  {  try  {   enumeration <  network interface >  ifcs =  network interface . get network interfaces (  )  ;  if  ( ifcs  !  =  null )   {  while  ( ifcs . has more elements (  )  )   {   network interface ifc = ifcs . next element (  )  ;  for  (  enumeration <  inet address >  addrs = ifc . get inet addresses (  )  ;  addrs . has more elements (  )  ;   )   {   inet address addr = addrs . next element (  )  ;   system . out . println ( "i2p mtu for "  +  addr . get host address (  )   +  " is " +  getmtu ( addr )  )  ;   }   }   }   }  catch  (   socket exception se )   {   system . out . println ( "no interfaces" )  ;   }   }  
@ override public void   (  drop target drop event drop target drop event )  {  try  {   transferable transferable = drop target drop event . get transferable (  )  ;  if  ( transferable . is data flavor supported (  data flavor . java file list flavor ) 
public int   (  )  {  return iterations ;   }  
public static void   (  )  {   workgroup event dispatcher . remove listener ( singleton )  ;  singleton = null ;   }  
public int   (  )  {  return 0 ;   }  
@ override public void   ( long n )  {  s . request ( n )  ;   }  
private void   (  message message  string subdomain )  {   log . debug ( " found unregister command !  " )  ;   string body = message . get body (  )  ;   pattern p =  pattern . compile ( "^ user ' (  .  +  ) ' unregistered . " )  ;   matcher m = p . matcher ( body )  ;  if  ( m . matches (  )  )   {   string user = m . group ( 1 )  ;  jid user jid = new jid ( user )  ;  transport session manager . remove registration of user fromdb ( subdomain user jid . get node (  )  )  ;   log . debug ( "unregister command was successfull for user: "  +  user jid . get node (  )  )  ;   }   }  
@ test ( timeout = 2000 )  public void   (  )  {   flowable <  integer >  source =  flowable . just ( 1 )  . repeat (  )  ;   flowable <  list <  integer >  >  result = source . buffer ( 2 3 )  . take ( 1 )  ;   subscriber <  object >  o =  test helper . 
@ override public  publisher <  list <  object >  >    (  flowable <  object >  f )  throws  exception  {  return f . buffer ( 2  time unit . seconds 10 )  ;   }  
public   (  string message )  {  super ( message )  ;   }  
public long   ( byte[] encrypted )  {     handler . receive tunnel message ( encrypted 0 encrypted . length )  ;  try  {   thread . sleep (    delay )  ;   }  catch  (   exception e )   {   }  return  - 1 ;   }  
@ override public  collection <  string >    (  string query int start index int num results )  {  if  ( query  =  =  null || "" . equals ( query )  )   {  return  collections . empty list (  )  ;   }  query = "%"  +  query . replace ( '*' '%' )   +  "%" 
public static  string   (  string s1  string s2  string s3  string s4 )  {  return  ( new  string builder (  )  )  . append ( s1 )  . append ( s2 )  . append ( s3 )  . append ( s4 )  . to string (  )  ;   }  
public void   (  sink sink )  {  this . sink = sink ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  parallel invalid (  )  . filter (  functions . always true (  )  )  . filter (  functions . always true (  )  )  . sequential (  )  . tes
private boolean   ( uri uri  string actual version  file f boolean issu3 )  {   string url = uri . to string (  )  ;  update status ( " < b > "  +     t ( " update downloaded" )   +  " <  / b > " )  ;   file to = new  file (    context . get router dir (  )   router . update   file )  ;   string err ;  if  ( issu3 )   {  su3 file up = new su3 file (    context f )  ;   file temp = new  file (    context . get temp dir (  )  "su3out - "  +     context . random (  )  . next long (  )   +  " . zip" )  ;  try  {  if  ( up . verify and migrate ( temp )  )   {   string ver = up . get version string (  )  ;  int type = up . get content type (  )  ;  if  ( ver  =  =  null ||  version comparator . comp (  router version . version ver )   >  =  0 )  err = " old version "  +  ver ;  else if  ( type  !  =  su3 file . content   router )  err = " bad su3 content type "  +  type ;  else if  (  !  file util . copy ( temp to true false )  )  err = " failed copy to "  +  to ;  else err = null ;   }  else  {  err = " signature failed  signer "  +   data helper . striphtml ( up . get signer string (  )  )   +  ' ' +  up . get sig type (  )  ;   }   }  catch  (  io exception ioe )   {     log . error ( "su3 extract error" ioe )  ;  err =  data helper . striphtml ( ioe . to string (  )  )  ;   }  finally  {  temp . delete (  )  ;   }   }  else  {   trusted update up = new  trusted update (    context )  ;  err = up . migrate verified (  router version . version f to )  ;   }  if  ( err  =  =  null )   {   string policy =    context . get property (  config update handler . prop   update   policy )  ;  long modtime =    context . clock (  )  . now (  )  ;     context . router (  )  . save config (  news helper . prop   last   update   time  long . to string ( modtime )  )  ;  if  ( "install" . equals ( policy )  )   {     log . log (  log . crit " update was downloaded and verified  restarting to install it" )  ;  update status ( " < b > "  +     t ( " update verified" )   +  " <  / b >  < br > " +     t ( " restarting" )  )  ;  restart (  )  ;   }  else  {     log . log always (  log . warn " update was downloaded and verified  will be installed at next restart" )  ;  update status ( "" )  ;   }   }  else  {     log . log (  log . crit err  +  " from "  +  url )  ;  update status ( " < b > "  +  err  +  ' ' +     t ( "from  { 0 } " linkify ( url )  )  +  "  <  / b > " )  ;   }  return err  =  =  null ;   }  
public static  email client connection manager   (  context context  http params params  host auth host auth )  {   tracking key manager key manager = new  tracking key manager (  )  ;  boolean ssl = host auth . should use ssl (  )  ;  int port = host auth . m port ;   scheme registry registry = new  scheme registry (  )  ;  registry . register ( new  scheme ( "http"  plain socket factory . get socket factory (  )  ssl  ?  standard   port : port )  )  ;  registry . register ( new  scheme ( "https" ssl utils . get http socket factory ( context host auth key manager false )  ssl  ?  port : standard   ssl   port )  )  ;  registry . register ( new  scheme ( "httpts" ssl utils . get http socket factory ( context host auth key manager true )  ssl  ?  port : standard   ssl   port )  )  ;  return new  email client connection manager ( params registry key manager )  ;   }  
public  database entry   (  )  {  return    data ;   }  
public void   (  )  {     is running = false ;  if  (    thread  !  =  null )     thread . interrupt (  )  ;  for  (   summary listener lsnr :    listeners )   {  lsnr . stop listening (  )  ;   }     listeners . clear (  )  ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {  error . completable . to observable (  )  . blocking for each (  functions . empty consumer (  )  )  ;   }  
public  string   (  )  throws io exception  {  verify header (  )  ;  return    version ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  )  {  return  rx java plugins . on assembly ( new  observable ignore elements completable < t >  ( this )  )  ;   }  
@ override public void   (  )  {  disposed = true ;   disposable helper . dispose ( main disposable )  ;   disposable helper . dispose ( other observer )  ;  if  ( get and increment (  )   =  =  0 )   {  queue = null ;  single item = null ;   }   }  
public   (  boolean auto accept suggestions  boolean mail notifications  boolean archiving enabled )  {  this . auto accept suggestions = auto accept suggestions ;  this . mail notifications = mail notifications ;  this . archiving enabled = archiving enabled ;   }  
@delete public  response   ( @ path param ( "username" )   string username  user groups entity user groups entity )  throws  service exception  {  plugin . delete user from groups ( username user groups entity )  ;  return  response . status (  response .
public boolean   (  )  throws sql exception  {  return pstmt . execute (  )  ;   }  
static long   ( byte[] in int offset )  {  int result = in[offset +  + ] & 0xff ;  result| =  ( in[offset +  + ] & 0xff )   <  <  8 ;  result| =  ( in[offset +  + ] & 0xff )   <  <  16 ;  result| = in[offset]  <  <  24 ;  return  (  ( long ) result )  & 0xffffffffl ;   }  
@ test public void   (  )  {   something result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( "name"  either . right ( "brian" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  .
void   (  )  {  subscribe next (  )  ;   }  
private void   (  output stream os )  throws io exception  {  os . write (  ( int ) ' ! ' )  ;  os . write ( 0xff )  ;  os . write ( 11 )  ;   put . ascii ( "netscape2 . 0" os )  ;  os . write ( 3 )  ;  os . write ( 1 )  ;   put . le short ( loop count  >  1  ?  loop count  -  1 : 0 os )  ;  os . write ( 0 )  ;   }  
@ override public  string   (  )  {  return configured rate limit . to string (  )  ;   }  
private static void   ( byte[] payload int p )  {  payload[toport   bytes] =  ( byte )  (  ( p  >  >  8 )  & 0xff )  ;  payload[toport   bytes  +  1] =  ( byte )  ( p & 0xff )  ;   }  
private int   (  uri uri )  {   context context = get context (  )  ;  long account id =  long . parse long ( uri . get last path segment (  )  )  ;  try  {  final  account account =  account . restore account with id ( context account id )  ;  if  ( account  =  =  null )   {  return 0 ;   }  delete account data ( context account id )  ;  uri =  content uris . with appended id (  account . content   uri account id )  ;  context . get content resolver (  )  . delete ( uri null null )  ;   account backup restore . backup ( context )  ;   security policy . get instance ( context )  . reduce policies (  )  ;  set services enabled sync ( context )  ;  return 1 ;   }  catch  (   exception e )   {   log utils . w (  logging . log   tag " exception while deleting account" e )  ;   }  return 0 ;   }  
@ override public void   (  )  {  w . dispose (  )  ;  u b ;  synchronized  ( this )   {  b = buffer ;  buffer = null ;   }  queue . offer ( b )  ;  done = true ;  if  ( enter (  )  )   {   queue drain helper . drain loop ( queue actual false this this ) 
protected void   (  chat setting setting )  {  settings list . remove ( setting . get key (  )  )  ;   }  
protected static void   (  string audio port )  {  sip config . audio port = audio port ;   }  
public  versioned map type   (  media type prefered media range )  {  org . openrepose . filters . versioning . config .  media type media type ;  for  (   map .  entry <  string  service version mapping >  service mapping : service mappings . entry set (  )  )   {  media type = get matching media type ( service mapping . get value (  )  prefered media range )  ;  if  ( media type  !  =  null )   {  return new  versioned map type ( service mapping . get value (  )  media type )  ;   }   }  return null ;   }  
public   (  socket s i2p socket i2ps  object slock byte[] initiali2p data  list < i2p socket >  sock list  fail callback on fail )  {  super ( s i2ps slock initiali2p data null sock list on fail )  ;   }  
private void   ( final  file output final int num duplicates final int num read pairs examined )  {  final  list <  duplication metrics >  metrics list =  metrics file . read beans ( output )  ;   assert . assert equals ( metrics list . size (  )  1 )  ;  final  duplication metrics metrics = metrics list . get ( 0 )  ;   assert . assert equals ( metrics . read   pair   duplicates * 2  +  metrics . unpaired   read   duplicates num duplicates )  ;   assert . assert equals ( metrics . read   pairs   examined num read pairs examined )  ;   }  
public void   (  string id )  {  this . id = id ;   }  
private  host auth   (  string protocol )  {   host auth host auth =  provider test utils . setup host auth ( protocol "name" false m context )  ;  host auth . m protocol = protocol ;  return host auth ;   }  
public synchronized void   (  )  {     keep testing = false ;  if  (    log . should log (  log . info )  )     log . info ( " stop testing peers" )  ;   }  
@ override public  maybe source <  object >    (  maybe <  object >  m )  throws  exception  {  return m . take until (  flowable . never (  )  )  ;   }  
@ override public void   (  )  throws  exception  {  count . get and increment (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  completable subject cs =  completable subject . create (  )  ;   test subscriber <  inte
public int   (  )  {  return count (    high capacity peers )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  single < r >    (  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper )  {   object helper . require non null ( mapper "mapper is null
public void   (  )  {  if  (    upnp manager  !  =  null )   {     upnp manager . rescan (  )  ;     upnp manager . update ( get ports (  )  )  ;   }   }  
void   (  )  {  if  ( wip . get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   subscriber <  ?  super t >  a = actual . get (  )  ;  for  (  ;   ;   )   {  if  ( a  !  =  null )   {  if  ( enable operator fusion )   {  drain fused ( a )  ;   }  else  {  drain regular ( a )  ;   }  return ;   }  missed = wip . add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }  a = actual . get (  )  ;   }   }  
void   ( boolean choke )  {  synchronized  ( send queue )   {  int inverse type = choke  ?   message . unchoke :  message . choke ;  if  (  ! remove message ( inverse type )  )   {   message m = new  message ( choke  ?   message . choke :  message . unchoke )  ;  add message ( m )  ;   }   }   }  
@ override public  string   (  )  {  return  help constants . doc   cat   base   calling ;   }  
private int   ( final  context context  string id  uri[] folders )  {  int updated = 0 ;  final long now =  system . current time millis (  )  ;  final  content resolver resolver = context . get content resolver (  )  ;  final  content values touch values = new  content values ( 1 )  ;  for  (  final  uri folder : folders )   {  touch values . put (  mailbox columns . last   touched   time now )  ;   log utils . d ( tag "update stamp: %s updated" folder )  ;  updated +  = resolver . update ( folder touch values null null )  ;   }  final  uri to notify = uiprovider   recent   folders   notifier . build upon (  )  . append path ( id )  . build (  )  ;   log utils . d ( tag "update timestamp:  notifying on %s" to notify )  ;  notifyui ( to notify null )  ;  return updated ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final  replay subject <  integer >  rp =  replay subject . create with time and size ( 1  time unit . seconds scheduler 2 )  ;   test observer <  integer >  to = new  t
@ override public void   (  throwable e )  {  e . print stack trace (  )  ;  latch . count down (  )  ;   }  
public   (  )  {  super ( "xep - 0215:  external  service  discovery" )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
private static void   (  peer peer  peer listener listener byte[] bs  log log )  {  if  ( log . should log (  log . debug )  )  log . debug ( " got comment msg from "  +  peer )  ;  try  {   input stream is = new  byte array input stream ( bs )  ;  b decoder dec = new b decoder ( is )  ;  be value bev = dec . bdecode map (  )  ;   map <  string be value >  map = bev . get map (  )  ;  int type = map . get ( "msg   type" )  . get int (  )  ;  if  ( type  =  =  0 )   {  int num = 20 ;  be value b = map . get ( "num" )  ;  if  ( b  !  =  null )  num = b . get int (  )  ;  listener . got comment req ( peer num )  ;   }  else if  ( type  =  =  1 )   {   list < be value >  list = map . get ( "comments" )  . get list (  )  ;  if  ( list . is empty (  )  )  return ;   list <  comment >  comments = new  array list <  comment >  ( list . size (  )  )  ;  long now = i2p app context . get global context (  )  . clock (  )  . now (  )  ;  for  (  be value li : list )   {   map <  string be value >  m = li . get map (  )  ;   string owner = m . get ( "owner" )  . get string (  )  ;   string text = m . get ( "text" )  . get string (  )  ;  int rating = m . get ( "like" )  . get int (  )  ;  long time = now  -   (  math . max ( 0 m . get ( "timestamp" )  . get int (  )  )  * 1000l )  ;   comment c = new  comment ( text owner rating time false )  ;  comments . add ( c )  ;   }  listener . got comments ( peer comments )  ;   }  else  {  if  ( log . should log (  log . info )  )  log . info ( " unknown comment msg type "  +  type  +  " from " +  peer )  ;   }   }  catch  (   exception e )   {  if  ( log . should log (  log . info )  )  log . info ( " comment msg exception from "  +  peer e )  ;   }   }  
public boolean   (  )  {  return is active ;   }  
public int   (  )  {  return max number ;   }  
@ data provider ( name = " " )  public  object[][] bad grouped files (  )  {  return new  object[][] {  { "bad / grouped - unpaired - mate . sam" }  }  ;   }  
public static  policy   ( long flags )  {   policy policy = new  policy (  )  ;  policy . m password mode =  (  ( int )  ( flags & password   mode   mask )  )   >  >  password   mode   shift ;  policy . m password min length =  ( int )  (  ( flags & password   length   mask )   >  >  password   length   shift )  ;  policy . m password max fails =  ( int )  (  ( flags & password   max   fails   mask )   >  >  password   max   fails   shift )  ;  policy . m password complex chars =  ( int )  (  ( flags & password   complex   chars   mask )   >  >  password   complex   chars   shift )  ;  policy . m password history =  ( int )  (  ( flags & password   history   mask )   >  >  password   history   shift )  ;  policy . m password expiration days =  ( int )  (  ( flags & password   expiration   mask )   >  >  password   expiration   shift )  ;  policy . m max screen lock time =  ( int )  (  ( flags & screen   lock   time   mask )   >  >  screen   lock   time   shift )  ;  policy . m require remote wipe = 0  !  =   ( flags & require   remote   wipe )  ;  policy . m require encryption = 0  !  =   ( flags & require   encryption )  ;  policy . m require encryption external = 0  !  =   ( flags & require   encryption   external )  ;  return policy ;   }  
@ setup public void   (  )  {   integer[] source array = new  integer[count] ;   arrays . fill ( source array 777 )  ;   flowable <  integer >  source =  flowable . from array ( source array )  ;  flowable plain = source . switch map ( new  function <  in
  (  throwable t )  {  this . t = t ;   }  
public static  string   (  )  {  final  string home dir path = get user home directory (  )   +  jrobin   dir  +  get file separator (  )  ;  final  file home dir file = new  file ( home dir path )  ;  return  ( home dir file . exists (  )  || home dir file . mkdirs (  )  )   ?  home dir path : null ;   }  
protected void   ( final  metrics file <  collect wgs metrics .  wgs metrics  integer >  file )  {  file . add histogram ( get unfiltered baseq histogram (  )  )  ;   }  
public  string   (  )  {  return " { "  +  local  +  "  -  >  " +  remote +  " } " ;   }  
@ data provider ( name = "solexa qual str to phreds" )  public  object[][]   (  )  {  return new  object[][] { new  object[] { "x@ axy"  +   (  ( char ) 156 )   +   (  ( char ) 157 )  +   (  ( char ) 0 )  +   (  ( char ) 1 )  +  " ? " new byte[][] { new b
@ setup public void   (  )  {   scheduler s =  schedulers . single (  )  ;   scheduler s2 = new  single scheduler (  )  ;  subscribe on flowable =  flowable . just ( 1 )  . subscribe on ( s )  ;  observe on flowable =  flowable . just ( 1 )  . observe on 
private static int   (  )  {  long x =  system . nano time (  )  ;  x^ =  ( x  <  <  21 )  ;  x^ =  ( x  >  >  >  35 )  ;  x^ =  ( x  <  <  4 )  ;  return  math . abs (  ( int ) x % 100 )  ;   }  
@ override public int   ( final  truth and call states that )  {  int result = this . truth state . compare to ( that . truth state )  ;  if  ( result  =  =  0 )  result = this . call state . compare to ( that . call state )  ;  return result ;   }  
@ test public void   (  )  throws io exception  {  buffer = new  cyclic byte buffer (  heapspace byte array provider . get instance (  )  10 0 0 false false )  ;  byte[] data = new byte[] { 1 2 3 4 5 6 7 }  ;  buffer . put ( data )  ;  buffer . get ( data
public void   (  string exception stack )  {  this . exception stack = exception stack ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe . just ( 1 )  . flat map single element ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (  final  integer integer
@ test public void   (  )  throws  exception  {  final x509 cert selector selector = new x509 cert selector (  )  ;  selector . set subject ( valid chain[0] . get subjectx500 principal (  )  )  ;  final x509 certificate[] chain = valid chain ;  final  cer
@ override public  iterator < t >    (  )  {  return list . iterator (  )  ;   }  
private boolean   (  )  {  return  jive globals . get boolean property ( "xmpp . muc . subject . change . strict" true )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . debounce ( 1  time unit . seconds new  test scheduler (  )  )  )  ;   test helper . check disposed (  publish processor . create (  )  . debounce (  function
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
@ test public void   (  )  {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   publish processor <  integer >  pp =  publish processor . create (  )  ;   maybe <  integer >  source = pp . single element (  )  . cache 
private static  string   (  string[] ui projection final boolean unseen only )  {   string builder sb = gen select ( get message list map (  )  ui projection )  ;  append conversation info columns ( sb )  ;  sb . append ( " from "  +   message . table   name  +  " where " +   message . flag   loaded   selection +  " and " +   message columns . mailbox   key +  " =  ?  " )  ;  if  ( unseen only )   {  sb . append ( "and " )  . append (  message columns . flag   seen )  . append ( "  =  0 " )  ;  sb . append ( "and " )  . append (  message columns . flag   read )  . append ( "  =  0 " )  ;   }  sb . append ( "order by "  +   message columns . timestamp  +  " desc " )  ;  sb . append ( "limit "  +  ui provider . conversation   projection   query   cursor   window   limit )  ;  return sb . to string (  )  ;   }  
public long   (  )  {  return get long header value ( http . seq )  ;   }  
public void   (  string entry )  {   buffered writer bw = null ;  try  {  bw = new  buffered writer ( new  output stream writer ( new  file output stream ( this . file true )  "utf - 8" )  )  ;   string timestamp = new  date (  )  . to string (  )  ;  bw . write ( timestamp  +  "  -  -  "  +  entry )  ;  bw . new line (  )  ;   }  catch  (  io exception exp )   {   }  finally  {  if  ( bw  !  =  null )  try  {  bw . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
public int   ( final  string s final  string[] tokens final  string token )  {  final  string tokenizer tokenizer = new  string tokenizer ( s token false )  ;  int i = 0 ;  while  ( tokenizer . has more tokens (  )  )   {  tokens[i +  + ] = tokenizer . next token (  )  ;   }  return i ;   }  
public  update task   (  update type type  update method method  string id  string current version long max time )  {  if  ( type  !  =   update type . type   dummy )  return null ;  return new  dummy runner (    context    mgr max time )  ;   }  
private void   (  string conference id boolean monitor )  {  if  ( monitor )   {  synchronized  ( conference monitors )   {  loginfo ( "adding conference monitor for "  +  conference id )  ;  conference monitors . add ( new  conference monitor ( null conference id )  )  ;   }   }  else  {  synchronized  ( conference monitors )   {   array list <  conference monitor >  monitors to remove = new  array list <  conference monitor >  (  )  ;  for  (   conference monitor m : conference monitors )   {  if  ( null  !  =  m . get service (  )  )   {  continue ;   }  if  ( conference id . equals ( m . get conference id (  )  )  )   {  monitors to remove . add ( m )  ;   }   }  for  (   conference monitor m : monitors to remove )   {  loginfo ( " removing conference monitor for "  +  conference id )  ;  conference monitors . remove ( m )  ;   }   }   }   }  
@ test ( timeout = 1000 )  public void   (  )  {   test subscriber <  integer >  ts0 = new  test subscriber <  integer >  (  )  {  @ override public void on complete (  )  {  throw new  test exception (  )  ;   }   }   ;   test subscriber <  integer >  ts
public long   (  )  {  return data store . get total responses (  )  ;   }  
@ test public void   (  )  {  convert file ( unmapped cram unmapped sam " . sam" )  ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test observer <  long >  to = new  test observer <  long >  (  )  ;   observable . range long (  long . max   value  -  1l 2l )  . subscribe ( to )  ;  to . assert complete (  )  ;  to . assert no errors 
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   completable . complete (  )  . do after terminate ( new  action (  )  {  @ override public void run (  )  throws  exception  {  throw new  te
public static long   ( final int unsigned int )  {  return unsigned int & 0xffffffffl ;   }  
@ override public void   (  servlet request servlet request  servlet response servlet response )  throws io exception   servlet exception  {  if  ( index  <  filters . size (  )  )   {   log . trace ( " executing injected filter  {  }  of  {  }  .  .  . "
@ override public  object   ( t element )  {  return element ;   }  
public  string   (  )  {  return second party call end treatment ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on terminate ( null )  ;   }  
@ benchmark public void   (  blackhole bh )  {  pipeline observable . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable processor <  integer >  subject =  behavior processor . create (  )  ;  subject . on next ( null )  ;  subject . blocking subscribe (  )  ;   }  
public boolean   ( int family code )  {  return snacs . contains key ( family code )  ;   }  
public static void   (  output stream out  string string )  throws  data format exception  io exception  {  if  ( string  =  =  null )   {  out . write (  ( byte ) 0 )  ;   }  else  {  byte[] raw = string . get bytes ( "utf - 8" )  ;  int len = raw . length ;  if  ( len  >  255 )  throw new  data format exception ( " the i2p data spec limits strings to 255 bytes or less  but this is "  +  len  +  " [" +  string +  "]" )  ;  out . write (  ( byte ) len )  ;  out . write ( raw )  ;   }   }  
public  list <  news entry >    (  )  {  return    entries ;   }  
public   (  input stream is )  {  super ( is )  ;   }  
private void   (  response response  client transaction client transaction )  throws  parse exception   sip exception   invalid argument exception  {   from header from header =  (  from header ) response . get header (  from header . name )  ;   string display name = from header . get address (  )  . get display name (  )  ;  int status code = response . get status code (  )  ;   logger . println ( "handle call participant invited "  +  cp  +  " status " +  status code +  " " +  response . get reason phrase (  )  )  ;   logger . println ( "handle call participant invited   displayname "  +  display name )  ;   call id header call id header =  (  call id header ) response . get header (  call id header . name )  ;  if  ( sip call id . equals ( call id header . get call id (  )  )  && display name . equals ( cp . get display name (  )  )  &&  ( status code  =  =   response . ok || status code  =  =   response . session   progress ) &&  (  ( c seq header ) response . get header ( c seq header . name )  )  . get method (  )  . equals (  request . invite )  )   {  if  ( status code  =  =   response . session   progress )   {  if  ( cp . get handle session progress (  )   =  =  false )   {   logger . write file ( " call "  +  cp  +  "  ignoring session   progress" )  ;  return ;   }   logger . write file ( " call "  +  cp  +  "  treating session   progress as ok" )  ;   }  if  ( response . get raw content (  )   =  =  null )   {   logger . error ( " call "  +  cp  +  " no sdp in ok  response ! " )  ;  cancel request ( "sip error !  no sdp in ok  response ! " )  ;  return ;   }  this . client transaction = client transaction ;  if  ( status code  =  =   response . ok )   {  got ok = true ;   logger . write file ( " call "  +  cp  +  "  got ok  call answered\n" +  response )  ;   }   to header to header =  (  to header ) response . get header (  to header . name )  ;  if  ( status code  =  =   response . ok )   {  sip util . send ack ( client transaction )  ;  ack sent = true ;   }  if  ( call answered )   {   logger . write file ( " call "  +  cp  +  " done processing ok" )  ;  return ;   }  sdp body = new  string ( response . get raw content (  )  )  ;   sdp info sdp info ;  try  {  sdp info = sip util . get sdp info ( sdp body false )  ;   }  catch  (   parse exception e )   {   logger . error ( " call "  +  cp  +  "  invalid sdp in ok  response !  " +  e . get message (  )  )  ;  cancel request ( "sip error !   invalid sdp in ok  response ! " )  ;  return ;   }   media info media info = sdp info . get media info (  )  ;   inet socket address isa = new  inet socket address ( sdp info . get remote host (  )  sdp info . get remote port (  )  )  ;   inet socket address rtcp address = sdp info . get rtcp address (  )  ;  set endpoint address ( isa media info . get payload (  )  sdp info . get transmit media info (  )  . get payload (  )  sdp info . get telephone event payload (  )  rtcp address )  ;  call answered = true ;  if  ( cp . get join confirmation timeout (  )   =  =  0 )   {  set state (  call state . answered )  ;   }  initialize call answered treatment (  )  ;  if  ( call answered treatment  !  =  null )   {  start call answered treatment (  )  ;   }  else  {  if  ( cp . get join confirmation timeout (  )   =  =  0 )   {  set state (  call state . established )  ;   }   }   }  else  {   logger . write file ( " call "  +  cp  +  "  ignoring response: " +  response . get reason phrase (  )  )  ;  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( " call "  +  cp  +  "  response: " +  response )  ;   }   }   }  
public void   (  locale log locale )  {     log locale = log locale ;   }  
private void   (  )  {  try  {   properties props = new  ordered properties (  )  ;   data helper . load props ( props new  byte array input stream ( config . get bytes ( "utf - 8" )  )  )  ;  synchronized  (  base bean . class )   {   data helper . store props ( props config file (  )  )  ;   }  saved = true ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }  
default  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  throw new  unsupported operation exception ( " not supported for method" )  ;   }  
public static  gojara admin manager   (  )  {  if  ( myself  =  =  null )   {  myself = new  gojara admin manager (  )  ;   }  return myself ;   }  
public static  account   (  context context long id  content observer observer )  {  return  email content . restore content with id ( context  account . class  account . content   uri  account . content   projection id observer )  ;   }  
public long   (  presence type xmpp status )  {  if  ( xmpp status  =  =   presence type . available )   {  return  full user info . icqstatus   default ;   }  else if  ( xmpp status  =  =   presence type . away )   {  return  full user info . icqstatus   away ;   }  else if  ( xmpp status  =  =   presence type . xa )   {  return  full user info . icqstatus   na ;   }  else if  ( xmpp status  =  =   presence type . dnd )   {  return  full user info . icqstatus   dnd ;   }  else if  ( xmpp status  =  =   presence type . chat )   {  return  full user info . icqstatus   ffc ;   }  else if  ( xmpp status  =  =   presence type . unavailable )   {  return  set extra info cmd . icqstatus   none ;   }  else  {  return  full user info . icqstatus   default ;   }   }  
@ override protected void   ( final sam record rec final  reference sequence ref )  {  if  ( pf   reads   only && rec . get read fails vendor quality check flag (  )  )  return ;  if  ( aligned   reads   only && rec . get read unmapped flag (  )  )  retur
@ override public void   ( int content length )  {  do set content length (  ( long ) content length )  ;   }  
public static boolean   (  )  {  return direct conferencing ;   }  
public static long   (  atomic long requested long n )  {  for  (  ;   ;   )   {  long r = requested . get (  )  ;  if  ( r  =  =   long . min   value )   {  return  long . min   value ;   }  if  ( r  =  =   long . max   value )   {  return  long . max   value ;   }  long u = add cap ( r n )  ;  if  ( requested . compare and set ( r u )  )   {  return r ;   }   }   }  
@ test public void   (  )  {  sam record set builder builder = new sam record set builder ( false sam file header .  sort order . queryname )  ;  builder . set read length ( read   length )  ;  builder . add pair ( "mapped   paired" 1 1 31 )  ;   peekable
public synchronized void   ( int num threads )  {     is running = false ;     inbound build messages . clear (  )  ;   build message state poison = new  build message state (    context null null null )  ;  for  ( int i = 0 ;  i  <  num threads ;  i +  +  )   {     inbound build messages . offer ( poison )  ;   }   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  interrupted exception  {   flowable . empty (  )  . on backpressure buffer (  - 1 )  ;   }  
public int   ( final  list <  file >  files final  tile index tile index final int current tile )  {  int count = 0 ;  int num clusters in tile = 0 ;  for  (  final  input stream input stream : streams )   {  final  tile index .  tile index record tile index record = tile index . find tile ( current tile )  ;  final  bcl index reader bcl index reader = new  bcl index reader ( files . get ( count )  )  ;  final long virtual file pointer = bcl index reader . get ( tile index record . get zero based tile number (  )  )  ;  if  (  !  ( input stream instanceof  block compressed input stream )  )   {  throw new  unsupported operation exception ( " seeking only allowed on bzgf" )  ;   }  else  {  try  {  if  ( tile index . get num tiles (  )   !  =  bcl index reader . get num tiles (  )  )   {  throw new  picard exception (  string . format ( "%s . get num tiles ( %d )   !  =  %s . get num tiles ( %d ) " tile index . get file (  )  . get absolute path (  )  tile index . get num tiles (  )  bcl index reader . get bci file (  )  . get absolute path (  )  bcl index reader . get num tiles (  )  )  )  ;   }   (  (  block compressed input stream ) input stream )  . seek ( virtual file pointer )  ;  num clusters in tile = tile index record . get num clusters in tile (  )  ;   }  catch  (  final io exception e )   {  throw new  picard exception ( " problem seeking to "  +  virtual file pointer e )  ;   }   }  count +  +  ;   }  return num clusters in tile ;   }  
@ test public void   (  )  {   set <  string >  one = new  hash set (  )  ;  one . add ( "abc" )  ;   set <  string >  two = new  hash set (  )  ;  two . add ( " abc" )  ;  assert false (  set utilities . null safe equals ( one two )  )  ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )  . observe on (  schedulers . computation (  )  true )  . do on next ( new  consumer <  integer >  (  )  {  @ ove
@ override public  string   (  )  {  return " meta data router" ;   }  
@ override public void   (  )  {  super . on resume (  )  ;  if  ( m quick response edit text . length (  )   =  =  0 )   {  m dialog . get button (  alert dialog . button   positive )  . set enabled ( false )  ;   }   }  
public  trust store   (  connection type type )  {  final  certificate store configuration configuration = type to trust store . get ( type )  ;  if  ( configuration  =  =  null )   {  return null ;   }  return trust stores . get ( configuration )  ;   }  
@ override public void   (  filter config filter config )  throws  servlet exception  {  log . trace ( " rate  limiting filter initializing .  .  . " )  ;  config filename = new  filter config helper ( filter config )  . get filter config ( default   conf
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . error (  (  throwable ) null )  ;   }  
@ override protected  test arg   ( final sam record sam rec final  reference sequence ref seq )  {  return new  test arg ( sam rec ref seq )  ;   }  
public  genotype concordance counts   (  )  {  return indel counter ;   }  
public  string   ( final byte[] quals to convert )  {  final  string builder sb = new  string builder ( bases . length )  ;  for  (  final byte qual : quals to convert )   {  sb . append (  string . value of (  ( int ) qual )  )  ;  sb . append ( " " )  ;   }  return sb . to string (  )  ;   }  
public   (  string base64 data )  throws  data format exception  {  super (  )  ;  from base64 ( base64 data )  ;   }  
private static boolean   (  list <  file >  in files  file out file )  {  boolean debug = false ;   list < v6 entry >  entries = new  array list < v6 entry >  ( 20000 )  ;  for  (   file geo file : in files )   {  int count = 0 ;   input stream in = null ;   buffered reader br = null ;  try  {  in = new  buffered input stream ( new  file input stream ( geo file )  )  ;  if  ( geo file . get name (  )  . ends with ( " . gz" )  )  in = new gzip input stream ( in )  ;   string buf = null ;  br = new  buffered reader ( new  input stream reader ( in "iso - 8859 - 1" )  )  ;  while  (  ( buf = br . read line (  )  )   !  =  null )   {  try  {  if  ( buf . char at ( 0 )   =  =  '#' )   {  continue ;   }   string[] s =  data helper . split ( buf " " )  ;   string ips1 = s[0] . replace ( "\"" "" )  . trim (  )  ;   string ips2 = s[1] . replace ( "\"" "" )  . trim (  )  ;  byte[] ip1 =  inet address . get by name ( ips1 )  . get address (  )  ;  byte[] ip2 =  inet address . get by name ( ips2 )  . get address (  )  ;   string country = s[4] . replace ( "\"" "" )  . trim (  )  . to lower case (  locale . us )  ;  entries . add ( new v6 entry ( ip1 ip2 country )  )  ;  count +  +  ;   }  catch  (   unknown host exception uhe )   {  uhe . print stack trace (  )  ;   }  catch  (   runtime exception re )   {  re . print stack trace (  )  ;   }   }   system . err . println ( " read "  +  count  +  " entries from " +  geo file )  ;   }  catch  (  io exception ioe )   {  ioe . print stack trace (  )  ;  return false ;   }  finally  {  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  if  ( br  !  =  null )  try  {  br . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }   collections . sort ( entries )  ;  v6 entry old = null ;  for  ( int i = 0 ;  i  <  entries . size (  )  ;  i +  +  )   {  v6 entry e = entries . get ( i )  ;  if  ( debug )   system . out . println ( "proc "  +  e . to string (  )  )  ;  if  ( old  !  =  null )   {  if  ( e . from  =  =  old . from && e . to  =  =  old . to )   {  if  ( debug )   system . out . println ( "remove dup "  +  e )  ;  entries . remove ( i )  ;  i -  -  ;  continue ;   }  if  ( e . from  <  =  old . to )   {  if  ( e . from  <  old . to )   {  v6 entry rewrite = new v6 entry ( old . from e . from  -  1 old . cc )  ;  if  ( debug )   system . out . println ( "rewrite old to "  +  rewrite )  ;  entries . set ( i  -  1 rewrite )  ;   }  if  ( e . to  <  old . to )   {  v6 entry insert = new v6 entry ( e . to  +  1 old . to old . cc )  ;  if  ( debug )   system . out . println ( "insert "  +  insert )  ;  int j = i  +  1 ;  while  ( j  <  entries . size (  )  && insert . compare to ( entries . get ( j )  )   >  0 )   {  j +  +  ;   }  entries . add ( j insert )  ;   }   }   }  old = e ;   }   output stream out = null ;  try  {  out = new gzip output stream ( new  buffered output stream ( new  file output stream ( out file )  )  )  ;  out . write (  data helper . getascii ( magic )  )  ;  write long ( out  system . current time millis (  )  )  ;  byte[] comment =  data helper . getutf8 ( comment )  ;  out . write ( comment )  ;  out . write ( new byte[256  -   ( 16  +  8  +  comment . length ) ] )  ;  for  (  v6 entry e : entries )   {  write long ( out e . from )  ;  write long ( out e . to )  ;  out . write (  data helper . getascii ( e . cc )  )  ;   }   system . err . println ( " wrote "  +  entries . size (  )   +  " entries to " +  out file )  ;   }  catch  (  io exception ioe )   {  ioe . print stack trace (  )  ;  return false ;   }  finally  {  if  ( out  !  =  null )  try  {  out . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  return true ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
@ test public void   (  )  throws  exception  {  assert that ( h . attach (  define with name dao . class )  . get by id ( 1 )  )  . is equal to ( new  something ( 1 " elsie  hughes" )  )  ;   }  
void   (  service connection conn )  {   log . debug ( "oscar service connected: "  +  conn . to string (  )  )  ;  services . add ( conn )  ;   }  
@ override public void   ( t t )  {  u v = value ;  if  ( v  !  =  null )   {  v . add ( t )  ;   }   }  
 string   (  )  {  return m username ;   }  
@ test public void   (  )  {  try  {  for  ( int i = 1 ;  i  <  3 ;  i +  +  )   {   observable . just ( i )  . test (  )  . with tag ( "testing with item = "  +  i )  . assert result ( 1 )  ;   }  fail ( " should have thrown ! " )  ;   }  catch  (   asse
@ test public void   (  )  throws io exception  {  final  file input = new  file ( test   data   dir "summary   alignment   stats   test2 . sam" )  ;  final  file outfile =  file . create temp file ( "alignment metrics" " . txt" )  ;  outfile . delete on 
public static boolean   (  router context ctx )  {  return ctx . get boolean property (  config update handler . prop   update   disabled )  ;   }  
private void   ( long max memory int k bps long rec max mem int threshk bps )  {  if  (  system version . is android (  )  )  return ;   string path ;  if  (  system version . is linux service (  )  )   {  path = " / etc / i2p" ;   }  else  {  path =    context . get base dir (  )  . to string (  )  ;   }   string msg = " configured for "  +   data helper . format size ( k bps * 1024l )   +  " bps share bandwidth but only " +   data helper . format size ( max memory )  +  "b available memory . " ;  if  (    context . has wrapper (  )  )   {  msg +  = "  recommend increasing wrapper . java . maxmemory in "  +  path  +   file . separator char +  "wrapper . config" ;   }  else if  (  !  system version . is windows (  )  )   {  msg +  = "  recommend increasing maxmemopt in "  +  path  +   file . separator char +  "runplain . sh or  / usr / bin / i2prouter - nowrapper" ;   }  else  {  msg +  = "  recommend running the restartable version of i2p  and increasing wrapper . java . maxmemory in "  +  path  +   file . separator char +  "wrapper . config" ;   }  msg +  = " to at least "  +   ( rec max mem * 11  /  10  /   ( 1024 * 1024 )  )   +  "  ( mb ) " +  " if the actual share bandwidth exceeds " +   data helper . format size ( threshk bps * 1024l )  +  " bps . " ;   system . out . println ( "warn: "  +  msg )  ;     context . log manager (  )  . get log (  bloom filteriv validator . class )  . log always (  log . warn msg )  ;   }  
protected void   (  )  {   integer start index =  integer . value of ( 0 )  ;  set synchronization source (  bit assistant . to long from integer network ( super . get payload (  )  start index )  )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;  set timestamp (  network time protocol . ntp to date time (  bit assistant . to long network ( super . get payload (  )  start index )  )  )  ;  start index =  integer . value of ( start index . int value (  )   +  8 )  ;  setrtp timestamp (  bit assistant . to long from integer network ( super . get payload (  )  start index )  )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;  set packet count (  bit assistant . to long from integer network ( super . get payload (  )  start index )  )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;  set octet count (  bit assistant . to long from integer network ( super . get payload (  )  start index )  )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;   byte first byte = super . get first byte (  )  ;  if  ( start index . int value (  )   <   array extensions . get length ( super . get payload (  )  )  . int value (  )  )   {   array list list = new  array list (  )  ;  for  (  integer i =  integer . value of ( 0 )  ;  i . int value (  )   <  first byte . byte value (  )  ;   )   {  rtcp report block item = rtcp report block . parse bytes (  bit assistant . sub array ( super . get payload (  )  start index  integer . value of ( 24 )  )  )  ;  if  ( item  !  =  null )  list . add ( item )  ;  start index =  integer . value of ( start index . int value (  )   +  24 )  ;   integer integer = i =  integer . value of ( i . int value (  )   +  1 )  ;  rtcp report block    tmp = item ;   }  set report blocks (  ( rtcp report block[] ) list . to array ( new rtcp report block[0] )  )  ;   }   }  
public  string   (  )  {  return subject ;   }  
@ test public void   (  )  {   unicast subject <  integer >  ap =  unicast subject . create (  )  ;  ap . on next ( 1 )  ;  ap . on complete (  )  ;   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . any )  ;  ap . subscrib
public static boolean   ( ssl socket ssl socket  string hostname )  {  try  {  ssl socket . get class (  )  . get method ( "set hostname"  string . class )  . invoke ( ssl socket hostname )  ;  return true ;   }  catch  (   exception ignored )   {  return false ;   }   }  
  (  string host int port int priority int weight )  {  super ( host port )  ;  this . priority = priority ;  this . weight = weight ;   }  
@ override public  cluster data   (  )  {   cbcl data cbcl data = reader . next (  )  ;  if  ( cbcl data  =  =  null )  return null ;  final  cluster data cluster = new  cluster data ( output read types )  ;  cluster . set lane ( lane )  ;  cluster . set 
public  field   (  )  {  return f ;   }  
public   (  router context ctx )  {     context = ctx ;     context . simple timer2 (  )  . add periodic event ( new ocmosj cache cleaner (  )  clean   interval clean   interval )  ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set on completable assembly ( new  function <  completable  completable >  (  )  {  @ override public  completable apply (   completable t )  {  return new  completable error ( new  test exception (
@ test public void   (  )  {   flowable . just ( 1 )  . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  throws  exception  {  return  flowable . just ( v * 10 )  ; 
@ test public void   (  )  {  final  something by varargs s = handle . attach (  something by varargs . class )  ;  final  list <  something >  out = s . get ( new  something key ( 1 "1" )  new  something key ( 2 "2" )  )  ;  assert that ( out )  . has sa
private static final  string   (  )  {  if  (    is win )  return "jbigi - windows - " ;  if  (    isk freebsd )  return "jbigi - kfreebsd - " ;  if  (    is freebsd )  return "jbigi - freebsd - " ;  if  (    is netbsd )  return "jbigi - netbsd - " ;  if  (    is openbsd )  return "jbigi - openbsd - " ;  if  (    is mac )  return "jbigi - osx - " ;  if  (    isos2 )  return "jbigi - os2 - " ;  if  (    is sunos )  return "jbigi - solaris - " ;  return "jbigi - linux - " ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single element (  )  ;   maybe ob
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . zip with (  arrays . as list ( 1 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  {  return null 
private void   ( iq packet )  {  iq reply ;   element iq = packet . get child element (  )  ;   string os = iq . element ( "os" )  . get text (  )  ;  reply = iq . create resultiq ( packet )  ;  if  ( os  =  =  null ||  (  ! os . equals ( "windows" )  &&  ! os . equals ( "mac" )  &&  ! os . equals ( "linux" )  )  )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . not   acceptable )  )  ;  send packet ( reply )  ;  return ;   }   element spark element = reply . set child element ( "query" "jabber:iq:spark" )  ;   string client = null ;  if  ( os . equals ( "windows" )  )   {  client =  jive globals . get property ( "spark . windows . client" )  ;   }  else if  ( os . equals ( "mac" )  )   {  client =  jive globals . get property ( "spark . mac . client" )  ;   }  else if  ( os . equals ( "linux" )  )   {  client =  jive globals . get property ( "spark . linux . client" )  ;   }  if  ( client  !  =  null )   {  int index = client . index of ( "   " )  ;   string version number = client . substring ( index  +  1 )  ;  int index of period = version number . index of ( " . " )  ;  version number = version number . substring ( 0 index of period )  ;  version number = version number . replace all ( "   " " . " )  ;  spark element . add element ( "version" )  . set text ( version number )  ;   file client file = new  file (  jive globals . get home directory (  )  "enterprise / spark / "  +  client )  ;  if  (  ! client file . exists (  )  )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  send packet ( reply )  ;  return ;   }  long updated time = client file . last modified (  )  ;  spark element . add element ( "updated time" )  . set text (  long . to string ( updated time )  )  ;   string downloadurl =  jive globals . get property ( "spark . client . downloadurl" )  ;   string server = xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;  downloadurl = downloadurl . replace ( "127 . 0 . 0 . 1" server )  ;  spark element . add element ( "downloadurl" )  . set text ( downloadurl  +  " ? client = "  +  client )  ;   string display message =  jive globals . get property ( "spark . client . display message" )  ;  if  ( display message  !  =  null && display message . trim (  )  . length (  )   >  0 )   {  spark element . add element ( "display message" )  . set text ( display message )  ;   }   }  else  {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  send packet ( reply )  ;  return ;   }  send packet ( reply )  ;   }  
@ override protected  void   (  void .  .  .  params )  {  runnable . run (  )  ;  return null ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . cancel (  )  ;  on error ( e )  ;  return ;   }  if  (  !
@ override public  string   (  )  {   string builder buf = new  string builder ( 128 )  ;  buf . append ( "ies " )  ;  buf . append (  addresses . to string (    aliceip    alice port )  )  ;  buf . append ( "  relay tag: " )  . append (    sent relay tag
@ test public void   (  )  {  final  list <  integer >  expected =  arrays . as list ( 1 )  ;  for  ( int i = 0 ;  i  <  100000 ;  i +  +  )   {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . subsc
@ test ( timeout = 1000 )  public void   (  )  throws  exception  {  final  scheduler s =  schedulers . single (  )  ;   disposable d = s . schedule direct ( new  runnable (  )  {  @ override public void run (  )  {  throw new  illegal state exception (  
public boolean   ( final  download request request )  throws  null pointer exception  {  if  ( request  =  =  null )   {  throw new  null pointer exception (  )  ;   }  final long request id = request . m attachment id ;  if  ( request id  <  0 )   {   log utils . d ( log   tag " not adding a  download request with an invalid attachment id" )  ;  return false ;   }  debug trace ( " queuing  download request #%d" request id )  ;  synchronized  ( m lock )   {  final boolean exists = m request map . contains key ( request id )  ;  if  (  ! exists )   {  m request queue . offer ( request )  ;  m request map . put ( request id request )  ;   }  else  {  debug trace ( " download request #%d was already in the queue" )  ;   }   }  return true ;   }  
private void   (  )  {  add command ( new  get number active users (  )  )  ;  add command ( new  get number online users (  )  )  ;  add command ( new  get number user sessions (  )  )  ;  add command ( new  get list active users (  )  )  ;  add command ( new  get users presence (  )  )  ;  add command ( new  get list groups (  )  )  ;  add command ( new  get list group users (  )  )  ;  add command ( new  add group users (  )  )  ;  add command ( new  delete group users (  )  )  ;  add command ( new  add group (  )  )  ;  add command ( new  update group (  )  )  ;  add command ( new  delete group (  )  )  ;  add command ( new  add user (  )  )  ;  add command ( new  delete user (  )  )  ;  add command ( new  authenticate user (  )  )  ;  add command ( new  change user password (  )  )  ;  add command ( new  user properties (  )  )  ;  add command ( new  packets notification (  )  )  ;  add command ( new  get server stats (  )  )  ;  add command ( new  http bind status (  )  )  ;  add command ( new  user created (  )  )  ;  add command ( new  user modified (  )  )  ;  add command ( new  user deleting (  )  )  ;  add command ( new  group created (  )  )  ;  add command ( new  group deleting (  )  )  ;  add command ( new  group modified (  )  )  ;  add command ( new  group member added (  )  )  ;  add command ( new  group member removed (  )  )  ;  add command ( new  group admin added (  )  )  ;  add command ( new  group admin removed (  )  )  ;  add command ( new v card created (  )  )  ;  add command ( new v card deleting (  )  )  ;  add command ( new v card modified (  )  )  ;  add command ( new  get admin console info (  )  )  ;   }  
@ override public void   (  )  {  if  ( m is processing )   {  return ;   }  if  ( m state  =  =  state   names )   {  finish (  )  ;   }  else  {  super . on back pressed (  )  ;   }  reset state from current fragment (  )  ;   }  
public  string   (  )  {  return conn pool id ;   }  
public int   (  string page name int default value )  {  return get page property ( page name "console . refresh" default value )  ;   }  
public  class   (  string class name )  throws  class not found exception  {   class the class = null ;  try  {  the class =  class . for name ( class name )  ;   }  catch  (   class not found exception e1 )   {  try  {  the class =  thread . current thread (  )  . get context class loader (  )  . load class ( class name )  ;   }  catch  (   class not found exception e2 )   {  the class = get class (  )  . get class loader (  )  . load class ( class name )  ;   }   }  return the class ;   }  
@ override @ managed operation public void   (  )  {  datastore service . get default datastore (  )  . remove all (  )  ;   }  
public boolean   (  )  {  return dtmf detection ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . sync )  ;   flowable . range ( 1 5 )  . hide (  )  . do finally ( this )  . subscribe ( ts )  ;   subscriber fusion . assert fusion ( ts  q
public void   ( final int id final  string read group id final sam read group record read group record final  string sample final  string library final sam file header header final sam record set builder set builder )  throws io exception  {  final  string separator = ":" ;  final int contig1 = 0 ;  final int contig2 = 1 ;  final int contig3 = 2 ;  read group record . set sample ( sample )  ;  read group record . set platform ( platform )  ;  read group record . set library ( library )  ;  read group record . set platform unit ( read group id )  ;  set builder . set read group ( read group record )  ;  set builder . set use nm flag ( true )  ;  set builder . set header ( header )  ;  final int max = 800 ;  final int min = 1 ;  final  random rg = new  random ( 5 )  ;  for  ( int i = 0 ;  i  <  num   reads ;  i +  +  )   {  final int start = rg . next int ( max )   +  min ;  final  string new read name = read   name  +  separator  +  id +  separator +  i ;  if  ( i  <  =  num   reads  /  3 )   {  set builder . add pair ( new read name contig1 start  +  id start  +  id  +  length )  ;   }  else if  ( i  <   ( num   reads  -   ( num   reads  /  3 )  )  )   {  set builder . add pair ( new read name contig2 start  +  id start  +  id  +  length )  ;   }  else  {  set builder . add pair ( new read name contig3 start  +  id start  +  id  +  length )  ;   }   }   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c =  completable . defer ( new  callable <  completable >  (  )  {  @ override public  completable call (  )  {  return normal . completable ;   }   }   )  ;  normal . assert subscriptions ( 0
@ test public void   (  )  {   flowable . create ( source no cancel  backpressure strategy . latest )  . subscribe ( ts )  ;  source no cancel . on next ( 1 )  ;  source no cancel . on error ( new  test exception (  )  )  ;  ts . request ( 2 )  ;  ts . as
@ deprecated void   ( boolean do pause )  {     do pause = do pause ;   }  
@ override @ nullable public  throwable   (  )  {  if  ( subscribers . get (  )   =  =  terminated )   {  return error ;   }  return null ;   }  
@ test public void   (  )  {  final  log argument group extractor extractor =  log argument group extractor . instance ( "" "" "" ""  log format argument . remote   address )  ;  http log formatter . set logic ( extractor formatter )  ;  assert that ( for
public void   (  string ns  string value )  {  set attribute ( "xmlns:"  +  ns value )  ;   }  
@ test public void   (  )  {   test subscriber <  list <  integer >  >  ts = new  test subscriber <  list <  integer >  >  (  long . max   value  >  >  1 )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable . unsafe create ( new  publi
@ test public void   (  )  {   test helper . assert bad request reported (  flowable . just ( 1 )  . group by (  functions . just function ( 1 )  )  )  ;   }  
@ test public void   (  )  {  final  throwable e = new  runtime exception ( " oops" )  ;  final  test subscriber <  integer >  inner1 = new  test subscriber <  integer >  (  )  ;  final  test subscriber <  integer >  inner2 = new  test subscriber <  integ
public  string   (  )  {  return transport ;   }  
public   (  element query element jid archive )  {  this . archive = archive ;  if  ( query element . attribute ( "queryid" )   !  =  null )   {  this . queryid = query element . attribute value ( "queryid" )  ;   }   element x element = query element . element ( q name . get ( "x"  data form . namespace )  )  ;  if  ( x element  !  =  null )   {  this . data form = new  data form ( x element )  ;   }   element set element = query element . element ( q name . get ( "set"  xmpp result set . namespace )  )  ;  if  ( set element  !  =  null )   {  result set = new  xmpp result set ( set element )  ;   }   }  
public static  string   (  string string  string plugin name )  {  if  ( string  =  =  null )   {  return null ;   }  if  ( string . index of ( "$ { " )   =  =  0 && string . index of ( " } " )   =  =  string . length (  )   -  1 )   {  return  locale utils . get localized string ( string . substring ( 2 string . length (  )   -  1 )  plugin name )  ;   }  return string ;   }  
public static int   (  )  {  return  read ends for mark duplicates . get size of (  )   +   ( 3 * 4 )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 512 )  . merge with (  maybe . just ( 100 )  )  . test ( 513 )  . assert value count ( 513 )  . assert complete (  )  ;   }  
private static  attachment   ( com . android . mail . providers .  attachment ui att  string cached file long account key )  {  final  attachment att = new  attachment (  )  ;  att . set content uri ( ui att . content uri . to string (  )  )  ;  if  (  !  text utils . is empty ( cached file )  )   {  final  uri .  builder cached file builder =  uri . parse ( "content: /  / "  +   email content . authority  +  " / attachment / cached file" )  . build upon (  )  ;  cached file builder . append query parameter (  attachment . cached   file   query   param cached file )  ;  att . set cached file uri ( cached file builder . build (  )  . to string (  )  )  ;   }  att . m account key = account key ;  att . m file name = ui att . get name (  )  ;  att . m mime type = ui att . get content type (  )  ;  att . m size = ui att . size ;  return att ;   }  
public   (  pub sub service service )  {  this . service = service ;   }  
@ nullable @ override public  object   (  )  throws  exception  {  return null ;   }  
public static  < t >  vcf file segment generator   ( final  vcf file segment generator strategy final  overlap detector < t >  overlaps )  {  return new  vcf file segment generator (  )  {  @ override public  iterable <  vcf file segment >  for vcf (  final  file vcf )  {  return  fluent iterable . from ( strategy . for vcf ( vcf )  )  . filter ( new  predicate <  vcf file segment >  (  )  {  @ override public boolean apply (  final  vcf file segment segment )  {  final boolean keep =  ! overlaps . get overlaps ( new  interval ( segment . contig (  )  segment . start (  )  segment . stop (  )  )  )  . is empty (  )  ;  if  (  ! keep )   {  log . debug (  string . format ( " ignoring segment because it does not overlap with detector  %s::%s:%s - %s" segment . vcf (  )  . get name (  )  segment . contig (  )  segment . start (  )  segment . stop (  )  )  )  ;   }  return keep ;   }   }   )  ;   }   }   ;   }  
public i2p session   (  )  {  return    session ;   }  
public void   ( final  read ends for mark duplicates read )  {  try  {  this . out . write short ( read . score )  ;  this . out . write short ( read . library id )  ;  this . out . write byte ( read . orientation )  ;  this . out . write int ( read . read1 reference index )  ;  this . out . write int ( read . read1 coordinate )  ;  this . out . write long ( read . read1 index in file )  ;  this . out . write int ( read . read2 reference index )  ;  if  ( read . orientation  >   read ends . r )   {  this . out . write int ( read . read2 coordinate )  ;  this . out . write long ( read . read2 index in file )  ;   }  this . out . write short ( read . read group )  ;  this . out . write short ( read . tile )  ;  this . out . write short (  ( short ) read . x )  ;  this . out . write short (  ( short ) read . y )  ;  this . out . write byte ( read . orientation for optical duplicates )  ;  this . out . write int ( read . duplicate set size )  ;   }  catch  (  final io exception ioe )   {  throw new  picard exception ( " exception writing  read ends to file . " ioe )  ;   }   }  
public   (  flowable < t >  source int capacity hint )  {  super ( source )  ;  this . state = new  cache state < t >  ( source capacity hint )  ;  this . once = new  atomic boolean (  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  s1 =  flowable . just ( 1 )  ;   flowable <  integer >  s2 =  flowable . just ( 2 )  ;   flowable <  integer >  s3 =  flowable . just ( 3 )  ;   flowable <  list <  integer >  >  result =  flowable . c
public  date   (  )  {  return end time ;   }  
@ override public void   ( long n )  {  requests . add ( n )  ;   }  
public   (  router context context  kademlia network database facade facade )  {  super ( context )  ;     log = context . log manager (  )  . get log (  start explorers job . class )  ;     facade = facade ;   }  
public void   (  string f )  {     full = f  !  =  null && f . length (  )   >  0 ;   }  
public void   (  dialog terminated event dte )  {  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( "process dialog terminated called" )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . take until (  (  flowable <  integer >  ) null )  ;   }  
public void   (  payload garlic config clove )  {     clove = clove ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
private void   (  )  {  put ( " message digest . sha - 1" "net . i2p . crypto . sha1" )  ;  put ( " key factory .  eddsa" "net . i2p . crypto . eddsa .  key factory" )  ;  put ( " key pair generator .  eddsa" "net . i2p . crypto . eddsa .  key pair generator" )  ;  put ( " signature . sha512with eddsa" "net . i2p . crypto . eddsa .  eddsa engine" )  ;  put ( " alg .  alias .  key factory . 1 . 3 . 101 . 100" " eddsa" )  ;  put ( " alg .  alias .  key factory . oid . 1 . 3 . 101 . 100" " eddsa" )  ;  put ( " alg .  alias .  key pair generator . 1 . 3 . 101 . 100" " eddsa" )  ;  put ( " alg .  alias .  key pair generator . oid . 1 . 3 . 101 . 100" " eddsa" )  ;  put ( " alg .  alias .  signature . 1 . 3 . 101 . 101" "sha512with eddsa" )  ;  put ( " alg .  alias .  signature . oid . 1 . 3 . 101 . 101" "sha512with eddsa" )  ;  put ( " key factory . dh" "net . i2p . crypto . elgamal .  key factory" )  ;  put ( " key factory .  diffie hellman" "net . i2p . crypto . elgamal .  key factory" )  ;  put ( " key factory .  el gamal" "net . i2p . crypto . elgamal .  key factory" )  ;  put ( " key pair generator . dh" "net . i2p . crypto . elgamal .  key pair generator" )  ;  put ( " key pair generator .  diffie hellman" "net . i2p . crypto . elgamal .  key pair generator" )  ;  put ( " key pair generator .  el gamal" "net . i2p . crypto . elgamal .  key pair generator" )  ;  put ( " signature . sha256with el gamal" "net . i2p . crypto . elgamal .  el gamal sig engine" )  ;  put ( " alg .  alias .  key factory . 1 . 3 . 14 . 7 . 2 . 1 . 1" " el gamal" )  ;  put ( " alg .  alias .  key factory . oid . 1 . 3 . 14 . 7 . 2 . 1 . 1" " el gamal" )  ;  put ( " alg .  alias .  key pair generator . 1 . 3 . 14 . 7 . 2 . 1 . 1" " el gamal" )  ;  put ( " alg .  alias .  key pair generator . oid . 1 . 3 . 14 . 7 . 2 . 1 . 1" " el gamal" )  ;  put ( " alg .  alias .  signature . 1 . 3 . 14 . 7 . 2 . 1 . 1" "sha256with el gamal" )  ;  put ( " alg .  alias .  signature . oid . 1 . 3 . 14 . 7 . 2 . 1 . 1" "sha256with el gamal" )  ;   }  
protected  hronized void sync (  )  {  if  ( m   byte buffer  !  =  null )   {  m   byte buffer . force (  )  ;   }   }  
private void   (  string info )  {  loginfo ( info )  ;   }  
void   (  )  {  if  ( wip . get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;  final  subscriber <  ?  super t >  a = actual ;  final  atomic reference < t >  q = queue ;  for  (  ;   ;   )   {  long r = get (  )  ;  long e = 0l ;  while  ( e  !  =  r )   {  if  ( is cancelled (  )  )   {  q . lazy set ( null )  ;  return ;   }  boolean d = done ;  t o = q . get and set ( null )  ;  boolean empty = o  =  =  null ;  if  ( d && empty )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error ( ex )  ;   }  else  {  complete (  )  ;   }  return ;   }  if  ( empty )   {  break ;   }  a . on next ( o )  ;  e +  +  ;   }  if  ( e  =  =  r )   {  if  ( is cancelled (  )  )   {  q . lazy set ( null )  ;  return ;   }  boolean d = done ;  boolean empty = q . get (  )   =  =  null ;  if  ( d && empty )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error ( ex )  ;   }  else  {  complete (  )  ;   }  return ;   }   }  if  ( e  !  =  0 )   {   backpressure helper . produced ( this e )  ;   }  missed = wip . add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
@ override public  string   (  )  {  return null ;   }  
private static io exception   (  )  {  final  string message = " end of stream reached" ;  if  (  debug utils . debug )   {   log utils . d (  logging . log   tag message )  ;   }  return new io exception ( message )  ;   }  
@ test public void   (  )  {   flowable <  string >  observable =  flowable . from iterable (  arrays . as list ( "one" "two" )  )  . skip last ( 2 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  observable . subscribe ( 
@ override public  test config   (  )  {  return new  test config ( this )  ;   }  
public   (  string[] white list )  {  this . white list =  arrays . copy of ( white list white list . length )  ;   ;   }  
@ suppress warnings ( "unchecked" )  public static  < c >  jpa class < c >    (  class < c >  clazz )  {  return  (  jpa class < c >  ) cache . compute if absent ( clazz  jpa class::new )  ;   }  
public void   (  )  throws  messaging exception  {  final  string e = " =  ? euc - kr ? b ? uvg50 ln4yko4pg =  =  ?  = " ;  final  string d = "\ube44\ubc00\ubc88\ud638\ub97c" ;   string from list =  string . format ( "%s  < sender@droid . com > " e )  ;   string reply to list =  string . format ( "%s  < reply1@droid . com >  %s  < reply2@droid . com > " e e )  ;   string to list =  string . format ( "%s  < toa@droid . com >  %s  < tob@droid . com > " e e )  ;   string cc list =  string . format ( "%s  < cca@droid . com >  %s  < ccb@droid . com > " e e )  ;   string bcc list =  string . format ( "%s  < bcca@droid . com >  %s  < bccb@droid . com > " e e )  ;  final  address from =  address . from header ( from list ) [0] ;  final  address[] replies =  address . from header ( reply to list )  ;  final  address[] tos =  address . from header ( to list )  ;  final  address[] ccs =  address . from header ( cc list )  ;  final  address[] bccs =  address . from header ( bcc list )  ;  final  mime message message = new  mime message (  )  ;  message . set from ( from )  ;  message . set reply to ( replies )  ;  message . set recipients (  recipient type . to tos )  ;  message . set recipients (  recipient type . cc ccs )  ;  message . set recipients (  recipient type . bcc bccs )  ;  final  email content .  message local message = new  email content .  message (  )  ;  final boolean result =  legacy conversions . update message fields ( local message message 1 1 )  ;  assert true ( result )  ;   string decoded from =  string . format ( "%s  < sender@droid . com > " d )  ;   string decoded reply =  string . format ( "%s  < reply1@droid . com >  %s  < reply2@droid . com > " d d )  ;   string decoded to =  string . format ( "%s  < toa@droid . com >  %s  < tob@droid . com > " d d )  ;   string decoded cc =  string . format ( "%s  < cca@droid . com >  %s  < ccb@droid . com > " d d )  ;   string decoded bcc =  string . format ( "%s  < bcca@droid . com >  %s  < bccb@droid . com > " d d )  ;  assert equals ( decoded from local message . m from )  ;  assert equals ( decoded reply local message . m reply to )  ;  assert equals ( decoded to local message . m to )  ;  assert equals ( decoded cc local message . m cc )  ;  assert equals ( decoded bcc local message . m bcc )  ;   }  
  ( int index int end )  {  this . index = index ;  this . end = end ;   }  
public   (  )  {  unencrypted = new byte[buffer   size] ;  base = new byte[buffer   size] ;  crc = new  adler32 (  )  ;   }  
@ test public void   (  )  {  final  http log formatter formatter = new  http log formatter ( "%h%%%u%u" )  ;  assert that ( " should have parsed four handlers . " formatter . get handler list (  )  . size (  )  equal to ( 4 )  )  ;   }  
@ override public void   (  subscriber <  ?  super t >  s )  {  if  ( s instanceof  conditional subscriber )   {  s . on subscribe ( new  array conditional subscription < t >  (  (  conditional subscriber <  ?  super t >  ) s array )  )  ;   }  else  {  s
static final  queue drain subscriber <  integer  integer  integer >    (  test subscriber <  integer >  ts final  disposable d )  {  return new  queue drain subscriber <  integer  integer  integer >  ( ts new  spsc array queue <  integer >  ( 4 )  )  {  @ override public void on next (   integer t )  {  fast path ordered emit max ( t false d )  ;   }  @ override public void on error (   throwable t )  {   }  @ override public void on complete (  )  {   }  @ override public void on subscribe (   subscription s )  {   }  @ override public boolean accept (   subscriber <  ?  super  integer >  a   integer v )  {  super . accept ( a v )  ;  a . on next ( v )  ;  return true ;   }   }   ;   }  
@ override public  network interface   (  inet address address )  throws  socket exception  {  for  (   network interface iface : get network interfaces (  )  )   {  for  (   inet address iface address : new  enumeration iterable <  >  ( iface . get inet 
@ override public void   (  http connection pool config configuration object )  throws  update failed exception  {   pool type default pool = configuration object . get pool (  )  . get ( 0 )  ;  boolean is pool configured = false ;  for  (   pool type po
private  map <  string  property mapping >    (  )  {   map <  string  property mapping >  map = new  hash map <  >  (  )  ;  if  ( profile . get name (  )   !  =  null && profile . get name (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( name new  property mapping ( profile . get name (  )  )  )  ;   }  if  ( profile . get email (  )   !  =  null && profile . get email (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( email new  property mapping ( profile . get email (  )  )  )  ;   }  if  ( profile . get full name (  )   !  =  null && profile . get full name (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( full   name new  property mapping ( profile . get full name (  )  )  )  ;   }  if  ( profile . get nickname (  )   !  =  null && profile . get nickname (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( nickname new  property mapping ( profile . get nickname (  )  )  )  ;   }  if  ( profile . get birthday (  )   !  =  null && profile . get birthday (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( birthday new  property mapping ( profile . get birthday (  )  )  )  ;   }  if  ( profile . get photo (  )   !  =  null && profile . get photo (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( photo new  property mapping ( profile . get photo (  )  )  )  ;   }  if  ( profile . get home street (  )   !  =  null && profile . get home street (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   street new  property mapping ( profile . get home street (  )  )  )  ;   }  if  ( profile . get home city (  )   !  =  null && profile . get home city (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   city new  property mapping ( profile . get home city (  )  )  )  ;   }  if  ( profile . get home state (  )   !  =  null && profile . get home state (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   state new  property mapping ( profile . get home state (  )  )  )  ;   }  if  ( profile . get home zip (  )   !  =  null && profile . get home zip (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   zip new  property mapping ( profile . get home zip (  )  )  )  ;   }  if  ( profile . get home country (  )   !  =  null && profile . get home country (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   country new  property mapping ( profile . get home country (  )  )  )  ;   }  if  ( profile . get home phone (  )   !  =  null && profile . get home phone (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   phone new  property mapping ( profile . get home phone (  )  )  )  ;   }  if  ( profile . get home mobile (  )   !  =  null && profile . get home mobile (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   mobile new  property mapping ( profile . get home mobile (  )  )  )  ;   }  if  ( profile . get home fax (  )   !  =  null && profile . get home fax (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   fax new  property mapping ( profile . get home fax (  )  )  )  ;   }  if  ( profile . get home pager (  )   !  =  null && profile . get home pager (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( home   pager new  property mapping ( profile . get home pager (  )  )  )  ;   }  if  ( profile . get business street (  )   !  =  null && profile . get business street (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   street new  property mapping ( profile . get business street (  )  )  )  ;   }  if  ( profile . get business city (  )   !  =  null && profile . get business city (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   city new  property mapping ( profile . get business city (  )  )  )  ;   }  if  ( profile . get business state (  )   !  =  null && profile . get business state (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   state new  property mapping ( profile . get business state (  )  )  )  ;   }  if  ( profile . get business zip (  )   !  =  null && profile . get business zip (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   zip new  property mapping ( profile . get business zip (  )  )  )  ;   }  if  ( profile . get business country (  )   !  =  null && profile . get business country (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   country new  property mapping ( profile . get business country (  )  )  )  ;   }  if  ( profile . get business job title (  )   !  =  null && profile . get business job title (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   job   title new  property mapping ( profile . get business job title (  )  )  )  ;   }  if  ( profile . get business department (  )   !  =  null && profile . get business department (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   department new  property mapping ( profile . get business department (  )  )  )  ;   }  if  ( profile . get business phone (  )   !  =  null && profile . get business phone (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   phone new  property mapping ( profile . get business phone (  )  )  )  ;   }  if  ( profile . get business mobile (  )   !  =  null && profile . get business mobile (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   mobile new  property mapping ( profile . get business mobile (  )  )  )  ;   }  if  ( profile . get business fax (  )   !  =  null && profile . get business fax (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   fax new  property mapping ( profile . get business fax (  )  )  )  ;   }  if  ( profile . get business pager (  )   !  =  null && profile . get business pager (  )  . trim (  )  . length (  )   >  0 )   {  map . put ( business   pager new  property mapping ( profile . get business pager (  )  )  )  ;   }  return map ;   }  
void   (  )  {  if  (  disposable helper . dispose ( this )  )   {  actual . on complete (  )  ;   }   }  
public void   (  )  {  synchronized  (  load client apps job . class )   {  if  (    loaded )  return ;     loaded = true ;   }   list <  client app config >  apps =  client app config . get client apps ( get context (  )  )  ;  if  ( apps . is empty (  )  )   {     log . log always (  log . warn " warning  -   no client apps or router console configured  -  we are just a router" )  ;   system . err . println ( " warning  -   no client apps or router console configured  -  we are just a router" )  ;  return ;   }  for  ( int i = 0 ;  i  <  apps . size (  )  ;  i +  +  )   {   client app config app = apps . get ( i )  ;  if  ( app . disabled )   {  if  ( "net . i2p . router . web .  router console runner" . equals ( app . class name )  )   {   string s = " warning  -   router console is disabled .   to enable \n edit the file "  +   client app config . config file ( get context (  )  )   +  " \n change the line \"client app . " +  i +  " . start on load = false\"" +  " to \"client app . " +  i +  " . start on load = true\" \n and restart . " ;     log . log always (  log . warn s )  ;   system . err . println ( s )  ;   }  continue ;   }   string arg val[] = parse args ( app . args )  ;  if  ( app . delay  <  =  0 )   {  run client ( app . class name app . client name arg val get context (  )     log )  ;   }  else  {   delayed run client drc = new  delayed run client ( get context (  )  . simple timer2 (  )  get context (  )  app . class name app . client name arg val )  ;  drc . schedule ( app . delay )  ;   }   }   }  
private static  string   ( int bit field )  {   string builder sb = new  string builder ( " " )  ;  for  ( int i = 0 ;  i  <  32 ;  i +  +   bit field >  >  = 1 )   {  if  (  ( bit field & 1 )   !  =  0 )   {  sb . append ( i )  . append ( " " )  ;   }   }  return sb . to string (  )  ;   }  
@ override public void   (  )  {  if  ( current  =  =  null )   {  throw new  illegal state exception (  )  ;   }  if  ( provider . is read only (  )  )   {  return ;   }  jid user = current ;  iter . remove (  )  ;  provider . delete member ( name user )
public  string   (  )  {  return name ;   }  
@ test public void   (  )  {  int n =  flowable . buffer size (  )  * 3 ;   list <  flowable <  integer >  >  sources = new  array list <  flowable <  integer >  >  (  )  ;   string builder expected = new  string builder ( n * 2 )  ;  for  ( int i = 0 ;  
@ test public void   (  )  {   test helper . check invalid parallel subscribers (  flowable . just ( 1 )  . parallel ( 1 )  . do on next (  functions . empty consumer (  )   parallel failure handling . error )  . filter (  functions . always true (  )  ) 
public   (  string msg  throwable nested throwable )  {  super ( msg )  ;  this . nested throwable = nested throwable ;   }  
public void   (  runnable task )  {     shutdown tasks . add ( task )  ;   }  
public long   (  )  {  return    last lookup successful ;   }  
void   ( u value  inner subscriber < t u >  inner )  {  if  ( get (  )   =  =  0 && compare and set ( 0 1 )  )   {  long r = requested . get (  )  ;   simple queue < u >  q = inner . queue ;  if  ( r  !  =  0l &&  ( q  =  =  null || q . is empty (  )  )  )   {  actual . on next ( value )  ;  if  ( r  !  =   long . max   value )   {  requested . decrement and get (  )  ;   }  inner . request more ( 1 )  ;   }  else  {  if  ( q  =  =  null )   {  q = get inner queue ( inner )  ;   }  if  (  ! q . offer ( value )  )   {  on error ( new  missing backpressure exception ( " inner queue full ?  ! " )  )  ;  return ;   }   }  if  ( decrement and get (  )   =  =  0 )   {  return ;   }   }  else  {   simple queue < u >  q = inner . queue ;  if  ( q  =  =  null )   {  q = new  spsc array queue < u >  ( buffer size )  ;  inner . queue = q ;   }  if  (  ! q . offer ( value )  )   {  on error ( new  missing backpressure exception ( " inner queue full ?  ! " )  )  ;  return ;   }  if  ( get and increment (  )   !  =  0 )   {  return ;   }   }  drain loop (  )  ;   }  
@ override public  observer <  ?  super  long >    ( final  observer <  ?  super  long >  child )  {  return new  default observer <  long >  (  )  {  @ override public void on complete (  )  {   }  @ override public void on error (   throwable e )  {   }
@ test public void   (  )  {  final  blocking multi observer <  integer >  bmo = new  blocking multi observer <  integer >  (  )  ;   schedulers . single (  )  . schedule direct ( new  runnable (  )  {  @ override public void run (  )  {  bmo . on success
private  set <  string >    ( final  set <  string >  actual cols final  set <  string >  expected cols )  {  final  set <  string >  missing columns = new  hash set <  >  ( expected cols )  ;  missing columns . remove all ( actual cols )  ;  if  (  ! missing columns . is empty (  )  )   {  throw new  picard exception (  string . format ( "library   params file %s is missing the following columns: %s . " library   params . get absolute path (  )   string util . join ( "  " missing columns )  )  )  ;   }  final  set <  string >  remaining columns = new  hash set <  >  ( actual cols )  ;  remaining columns . remove all ( expected cols )  ;  return remaining columns ;   }  
public  auth token   (  )  {  return auth token ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . zip ( null just1 new  bi function <  object  integer  object >  (  )  {  @ override public  object apply (   object a   integer b )  {  return 1 ;   }   }   )  ;   }  
long   (  )  throws  rrd exception  {  return  util .  xml . get child value as long ( root "step" )  ;   }  
private void   (  config config  properties properties )  {   string local host address = config . get private host (  )  ;  properties . set property ( "javax . sip . ip   address" local host address )  ;  set voip gateways ( config )  ;  if  ( voip gateways . size (  )   =  =  0 )   {   logger . println ( " there are no  voip gateways .   you cannot make calls to the phone system . " )  ;   }  sip factory =  sip factory . get instance (  )  ;  sip factory . set path name ( "gov . nist" )  ;  try  {  sip stack =  (  sip stack ) sip factory . create sip stack ( properties )  ;  address factory = sip factory . create address factory (  )  ;  header factory = sip factory . create header factory (  )  ;  message factory = sip factory . create message factory (  )  ;   }  catch  (   peer unavailable exception e )   {   logger . exception ( "could not stsart sip stack . " e )  ;  return ;   }  catch  (   sip exception e )   {   logger . exception ( "could not start sip stack . " e )  ;  return ;   }   listening point udp listen port = null ;   listening point tcp listen port = null ;  try  {   string s =  system . get property ( "com . sun . voip . server . sip   port"  string . value of ( sip   port )  )  ;  int sip port =  integer . parse int ( s )  ;   logger . println ( "" )  ;   logger . println ( " bridge private address: "  +  properties . get property ( "javax . sip . ip   address" )  )  ;  tcp listen port = sip stack . create listening point ( local host address sip port "tcp" )  ;  udp listen port = sip stack . create listening point ( local host address sip port "udp" )  ;  sip provider = sip stack . create sip provider ( tcp listen port )  ;  sip provider . add listening point ( udp listen port )  ;  sip provider . add sip listener ( this )  ;  sip address = new  inet socket address ( sip stack . getip address (  )  sip port )  ;  default sip proxy = config . get default proxy (  )  ;   sip util . initialize (  )  ;  for  ( int i = 0 ;  i  <  voip gateway login info . size (  )  ;  i +  +  )   {  try  {   inet address inet address =  inet address . get by name ( voip gateways . get ( i )  )  ;   proxy credentials proxy credentials = voip gateway login info . get ( i )  ;  if  ( proxy credentials . get auth user name (  )   !  =  null )   {  registrations . add ( new  register processing ( inet address . get host address (  )  voip gateways . get ( i )  proxy credentials )  )  ;   }   }  catch  (   exception e )   {   system . out . println (  string . format ( " bad  address %s " voip gateways . get ( i )  )  )  ;  continue ;   }   }   }  catch  (   transport already supported exception e )   {   logger . exception ( " stack has transport already supported" e )  ;  return ;   }  catch  (   null pointer exception e )   {   logger . exception ( " stack has no  listening points" e )  ;  return ;   }  catch  (   object in use exception e )   {   logger . exception ( " stack has no  listening points" e )  ;  return ;   }  catch  (   transport not supported exception e )   {   logger . exception ( " transport not supported exception" e )  ;  return ;   }  catch  (   too many listeners exception e )   {   logger . exception ( " too many listeners exception" e )  ;  return ;   }  catch  (   invalid argument exception e )   {   logger . exception ( " invalid argument exception" e )  ;  return ;   }   logger . println ( " default sip  proxy: "  +  default sip proxy )  ;   logger . println ( "" )  ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  actual . on complete (  )  ;   }  
void   (  window boundary inner observer < t b >  sender )  {  boundary observer . compare and set ( sender null )  ;  queue . offer ( next   window )  ;  drain (  )  ;   }  
protected   ( final long message key final  string server id final long id )  {  m message key = message key ;  m server id = server id ;  m last id = id ;   }  
@ override public void   (  )  {  final  content resolver resolver = m context . get content resolver (  )  ;  final  uri purge uri =  email provider . ui uri ( "uipurgefolder" m mailbox id )  ;  resolver . delete ( purge uri null null )  ;   }  
@ override public void   ( byte buf[] int off int len )  throws io exception  {  if  (    complete )   {  return ;   }  boolean is finished = inf . finished (  )  ;  for  ( int i = off ;  i  <  off  +  len ;  i +  +  )   {  if  (  ! is finished )   {  if 
public  string   (  )  {  return proxy ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . from observable ( null )  ;   }  
private boolean   (  element doc )  {   string error = null ;  if  ( connection . get compression policy (  )   =  =   connection .  compression policy . disabled )   {  error = " < failure xmlns = 'http: /  / jabber . org / protocol / compress' >  < setup - failed /  >  <  / failure > " ;   log . warn ( " client requested compression while compression is disabled .   closing "  +  "connection : "  +  connection )  ;   }  else if  ( connection . is compressed (  )  )   {  error = " < failure xmlns = 'http: /  / jabber . org / protocol / compress' >  < setup - failed /  >  <  / failure > " ;   log . warn ( " client requested compression and connection is already compressed .   closing "  +  "connection : "  +  connection )  ;   }  else  {   string method = doc . element text ( "method" )  ;  if  (  ! "zlib" . equals ( method )  )   {  error = " < failure xmlns = 'http: /  / jabber . org / protocol / compress' >  < unsupported - method /  >  <  / failure > " ;   log . warn ( " requested compression method is not supported: "  +  method  +  " .   closing connection : " +  connection )  ;   }   }  if  ( error  !  =  null )   {  connection . deliver raw text ( error )  ;  return false ;   }  else  {  connection . add compression (  )  ;  connection . deliver raw text ( " < compressed xmlns = 'http: /  / jabber . org / protocol / compress' /  > " )  ;  connection . start compression (  )  ;  return true ;   }   }  
@ test public void   (  )  {   observable <  integer >  src =  observable . empty (  )  ;  src . skip while ( less   than   five )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w never (  )  )  . on error ( any 
private int   (  method method )  {   annotation[][] parameter annotations = method . get parameter annotations (  )  ;  return  int stream . range ( 0 parameter annotations . length )  . filter ( i  -  >   stream . of ( parameter annotations[i] )  . any match (  batch chunk size . class::is instance )  )  . find first (  )  . or else (  - 1 )  ;   }  
@ test public void   (  )  {  final  per tile parser <  dummy dt >  ddts = new  mock per tile parser ( file   map )  ;  ddts . verify data ( make list ( 1 2 3 4 5 )  null )  ;   }  
private  list <  string >    (  hash hash )  {  try  {   skip list <  integer  properties >  rev =    bf . get index ( reverse   skiplist    hash index serializer    info serializer )  ;  if  ( rev  =  =  null )  return null ;   integer idx = get reverse key ( hash )  ;   properties props = rev . get ( idx )  ;  if  ( props  =  =  null )  return null ;   list <  string >  rv = new  array list <  string >  ( props . size (  )  )  ;  for  (   string key : props . string property names (  )  )   {   list <  destination >  ld = lookup all ( key )  ;  if  ( ld  !  =  null )   {  for  (   destination d : ld )   {  if  ( d . calculate hash (  )  . equals ( hash )  )   {  rv . add ( key )  ;  break ;   }   }   }   }  if  (  ! rv . is empty (  )  )  return rv ;   }  catch  (  io exception ioe )   {     log . error ( "db get reverse error" ioe )  ;   }  catch  (   runtime exception e )   {     log . error ( "db get reverse error" e )  ;   }  return null ;   }  
private void   ( double total capacity  set <  peer profile >  reordered )  {  int num not failing = reordered . size (  )  ;  double mean capacity = avg ( total capacity num not failing )  ;  int min high capacity peers = get minimum high capacity peers (  )  ;  int num exceeding mean = 0 ;  double threshold at median = 0 ;  double threshold at min high cap = 0 ;  double threshold at lowest =  capacity calculator . growth   factor ;  int cur = 0 ;  for  (   peer profile profile : reordered )   {  double val = profile . get capacity value (  )  ;  if  ( val  >  mean capacity )  num exceeding mean +  +  ;  if  ( cur  =  =  reordered . size (  )   /  2 )  threshold at median = val ;  if  ( cur  =  =  min high capacity peers  -  1 )  threshold at min high cap = val ;  if  ( cur  =  =  reordered . size (  )   -  1 )  threshold at lowest = val ;  cur +  +  ;   }  if  ( num exceeding mean  >  =  min high capacity peers )   {  if  (    log . should log (  log . info )  )     log . info ( " our average capacity is doing well ["  +  mean capacity  +  "]  and includes " +  num exceeding mean )  ;     threshold capacity value = mean capacity ;   }  else if  ( mean capacity  >  threshold at median && reordered . size (  )   /  2  >  min high capacity peers )   {  if  (    log . should log (  log . info )  )     log . info ( " our average capacity ["  +  mean capacity  +  "] is greater than the median " +  " so threshold is that reqd to get the min high cap peers " +  threshold at min high cap )  ;     threshold capacity value = threshold at min high cap ;   }  else if  ( reordered . size (  )   /  2  >  =  min high capacity peers )   {  if  (    log . should log (  log . info )  )     log . info ( " our average capacity ["  +  mean capacity  +  "] is skewed under the median " +  " so use the median threshold " +  threshold at median )  ;     threshold capacity value = threshold at median ;   }  else  {  if  (    log . should log (  log . info )  )     log . info ( " our average capacity is doing well ["  +  mean capacity  +  "]  but there aren't enough of them " +  num exceeding mean )  ;     threshold capacity value =  math . max ( threshold at min high cap threshold at lowest )  ;   }  if  (    threshold capacity value  <  =   capacity calculator . growth   factor )     threshold capacity value =  capacity calculator . growth   factor  +  0 . 0001 ;   }  
public boolean   (  )  {  synchronized  ( this )   {  return worker  !  =  null && worker . stop  !  =  true ;   }   }  
@ test public void   (  )  {   publish processor <  object >  pp =  publish processor . create (  )  ;   test observer <  integer >  to =  maybe .  <  integer > error ( new  test exception ( " main" )  )  . delay ( pp )  . test (  )  ;  to . assert empty 
@ override nio connection   (  io session session )  {  return new nio connection ( session new  offline packet deliverer (  )  configuration )  ;   }  
public void   (  set <  transport manager .  port >  ports )  {  if  (    log . should log (  log . debug )  )     log . debug ( "u pnp  update with "  +  ports . size (  )   +  " ports" )  ;  if  (  !    is running )  return ;   set <  forward port >  forwards = new  hash set <  forward port >  ( ports . size (  )  )  ;  for  (   transport manager .  port entry : ports )   {   string style = entry . style ;  int port = entry . port ;  int protocol =  - 1 ;  if  ( "ssu" . equals ( style )  )  protocol =  forward port . protocol   udp   ipv4 ;  else if  ( "ntcp" . equals ( style )  )  protocol =  forward port . protocol   tcp   ipv4 ;  else continue ;  if  (    log . should log (  log . debug )  )     log . debug ( " adding: "  +  style  +  " " +  port )  ;   forward port fp = new  forward port ( style false protocol port )  ;  forwards . add ( fp )  ;   }     upnp . on change public ports ( forwards    upnp callback )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . collect into ( 1 null )  ;   }  
@ test public void   (  )  {   flowable <  boolean >  observable =  flowable . sequence equal (  flowable . just ( "one" )   flowable . just ( "one" )  new  bi predicate <  string  string >  (  )  {  @ override public boolean test (   string t1   string t
public void   ( final  input stream is )  {  dis = new  data input stream ( is )  ;   }  
int   ( int arc index )  {  return rrd . get archive ( arc index )  . get pdp count (  )  ;   }  
public int   (  )  {  return 0 ;   }  
public synchronized  session key   (  )  {  return    session key ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . merge with (  maybe . just ( 100 )  )  . take ( 3 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
public  map <  long  integer >    (  data input in )  throws io exception  {  return strategy . read long int map ( in )  ;   }  
@ override public void   (  )  {  s . dispose (  )  ;   }  
public boolean   (  )  {  return    context . client manager (  )  . verify client liveliness (  )  ;   }  
@ override public void   (  )  {  if  ( windows . decrement and get (  )   =  =  0 )   {  upstream . dispose (  )  ;   }   }  
protected void   ( final  cluster data cluster data final  barcode data barcode data )  {  cluster data . set matched barcode ( barcode data . get barcode (  )  )  ;   }  
@ benchmark public void   (  )  {  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {  unbounded . on next ( 1 )  ;   }   }  
public static void   ( boolean expression @ nullable  string error message template @ nullable  object .  .  .  error message args )  {  if  (  ! expression )   {  throw new  illegal state exception ( format ( error message template error message args )  )  ;   }   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  complete ( u )  ;   }  
@ test public void   (  )  {  serial disposable . dispose (  )  ;   }  
public boolean   ( @ non null  disposable .  .  .  ds )  {   object helper . require non null ( ds "ds is null" )  ;  if  (  ! disposed )   {  synchronized  ( this )   {  if  (  ! disposed )   {   open hash set <  disposable >  set = resources ;  if  ( set  =  =  null )   {  set = new  open hash set <  disposable >  ( ds . length  +  1 )  ;  resources = set ;   }  for  (   disposable d : ds )   {   object helper . require non null ( d "d is null" )  ;  set . add ( d )  ;   }  return true ;   }   }   }  for  (   disposable d : ds )   {  d . dispose (  )  ;   }  return false ;   }  
@ test ( data provider = "missing tile formats" )  public void   ( final int lane final  list <  supported illumina format >  formats final  list <  supported illumina format >  formats to get tiles final  list <  string >  relative files to delete final 
public  string   (  )  {  return value ;   }  
private   (  stats field field )  {  this . field = field ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c =  completable . concat array ( normal . completable error . completable normal . completable )  ;  c . blocking await (  )  ;   }  
public void   (  simple timer2 .  timed event evt )  {     expire event = evt ;   }  
@ test public void   (  )  {  try  {   completable . complete (  )  . lift ( new  completable operator (  )  {  @ override public  completable observer apply (   completable observer o )  throws  exception  {  throw new  test exception (  )  ;   }   }   )
public  garlic clove   ( int index )  {  return    cloves[index] ;   }  
@ test @ suppress warnings ( "rawtypes" )  public void   (  )  {  try  {   rx java plugins . set on maybe subscribe ( new  bi function <  maybe  maybe observer  maybe observer >  (  )  {  @ override public  maybe observer apply (   maybe o  final  maybe o
@ suppress warnings ( "unchecked" )  @ test ( timeout = 1000 )  public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   list <  single 
@ override public boolean   (  )  {  return subscribers . get (  )   =  =  terminated ;   }  
public int   (  )  {  return    purpose ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 100 100 2 )  )  . filter (  functions . always true (  )  )  . test (  )  . assert failure (  test exception . class 0 )  ;   }  
@ test public void   (  )  throws  exception  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber <  integer >  ts = p
public  list <  file >    ( final int i )  {  final  list <  file >  cbcl files = new  array list <  >  (  )  ;  surface to tile to cbcl map . values (  )  . for each ( map  -  >   {  if  ( map . contains key ( i )  )   {  cbcl files . add ( map . get ( i )  )  ;   }   }   )  ;  return cbcl files ;   }  
public  jingle trackeriq   ( final  xml pull parser parser )  throws  exception  {   jingle trackeriq iq = new  jingle trackeriq (  )  ;  boolean done = false ;  int event type ;   string element name ;  while  (  ! done )   {  event type = parser . get event type (  )  ;  element name = parser . get name (  )  ;  if  ( event type  =  =   xml pull parser . start   tag )   {  final  tracker entry .  type type ;  if  ( element name . equals (  tracker entry .  type . relay . to string (  )  )  )   {  type =  tracker entry .  type . relay ;   }  else if  ( element name . equals (  tracker entry .  type . tracker . to string (  )  )  )   {  type =  tracker entry .  type . tracker ;   }  else  {  parser . next (  )  ;  continue ;   }  final  string protocol = parser . get attribute value ( null "protocol" )  ;  final  tracker entry .  policy policy =  tracker entry .  policy . value of ( "   "  +  parser . get attribute value ( null "policy" )  )  ;  final  string address = parser . get attribute value ( null "address" )  ;  final  string verified = parser . get attribute value ( null "verified" )  ;  if  ( address  !  =  null && address . length (  )   >  0 )   {  final  tracker entry entry = new  tracker entry ( type policy address protocol )  ;  if  ( verified  !  =  null && verified . equals ( "true" )  )   {  entry . set verified ( true )  ;   }  iq . add entry ( entry )  ;   }   }  else if  ( event type  =  =   xml pull parser . end   tag )   {  if  ( element name . equals (  jingle trackeriq . name )  )   {  done = true ;   }   }  if  (  ! done )   {  parser . next (  )  ;   }   }  return iq ;   }  
public  destination   (  )  {  return socket mgr . get session (  )  . get my destination (  )  ;   }  
public long   (  )  {  return    accept timeout ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c =  completable . never (  )  . timeout ( 100  time unit . milliseconds normal . completable )  ;  c . blocking await (  )  ;  normal . assert subscriptions ( 1 )  ;   }  
@ override public  iterator <  integer >    (  )  {  return new  iterator <  integer >  (  )  {  @ override public boolean has next (  )  {  return true ;   }  @ override public  integer next (  )  {  throw new  test exception (  )  ;   }  @ override publ
public synchronized void   ( int ms )  {     rtt =  ( int )  (    rtt dampening *    rtt  +   ( 1  -     rtt dampening )  * ms )  ;  if  (    rtt  >  max   rtt )     rtt = max   rtt ;     updated =    context . clock (  )  . now (  )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   flowable processor <  integer >  ps =  publish processor .  <  integer > create (  )  ;   test subscriber <  flowable <  integer >  >  ts = ps . window ( 5  time unit 
@ test public void   (  )  {  final  publish subject <  object >  subject =  publish subject . create (  )  ;  final  disposable disposable =  observable . error ( new  runtime exception ( " leak" )  )  . retry when ( new  function <  observable <  throwa
protected void   (  )  {  m is processing = false ;  final  account setup fragment old content fragment = get content fragment (  )  ;  if  ( old content fragment  !  =  null )   {  old content fragment . set next button enabled ( true )  ;   }  get fragment manager (  )  . execute pending transactions (  )  ;  switch  ( m state )   {  case state   basics: final boolean advance = on basics complete (  )  ;  if  (  ! advance )   {  m state = state   basics   post ;  break ;   }  case state   basics   post: if  ( should divert to manual (  )  )   {  m skip auto discover = true ;  m is pre configured provider = false ;  m state = state   type ;   }  else  {  m skip auto discover = false ;  if  ( m is pre configured provider )   {  if  (  !  text utils . is empty ( m setup data . get am protocol (  )  )  &&  !  text utils . equals ( m setup data . get am protocol (  )  m setup data . get incoming protocol ( this )  )  )   {  m state = state   ab ;   }  else  {  m state = state   credentials ;  if  ( possibly divert to gmail (  )  )   {  return ;   }   }   }  else  {  final  string am protocol = m setup data . get am protocol (  )  ;  if  (  !  text utils . is empty ( am protocol )  )   {  m setup data . set incoming protocol ( this am protocol )  ;  final  account account = m setup data . get account (  )  ;  set defaults for protocol ( account )  ;  m state = state   credentials ;   }  else  {  m state = state   type ;   }   }   }  update content fragment ( true )  ;  break ;  case state   type: m state = state   credentials ;  update content fragment ( true )  ;  break ;  case state   ab: if  ( possibly divert to gmail (  )  )   {  return ;   }  m state = state   credentials ;  update content fragment ( true )  ;  break ;  case state   credentials: collect credentials (  )  ;  if  ( m is pre configured provider )   {  m state = state   checking   preconfigured ;  initiate check settings fragment (  setup data fragment . check   incoming |  setup data fragment . check   outgoing )  ;   }  else  {  populate host auths from setup data (  )  ;  if  ( m skip auto discover )   {  m state = state   manual   incoming ;  update content fragment ( true )  ;   }  else  {  m state = state   auto   discover ;  initiate auto discover (  )  ;   }   }  break ;  case state   checking   preconfigured: if  ( m pre configured failed )   {  if  ( m password failed )   {   fragment manager fm = get fragment manager (  )  ;  fm . pop back stack immediate ( credentials   backstack   tag 0 )  ;  final  account setup credentials fragment f =  (  account setup credentials fragment ) get content fragment (  )  ;  f . set password failed ( m password failed )  ;  reset state from current fragment (  )  ;   }  else  {  m state = state   manual   incoming ;  update content fragment ( true )  ;   }   }  else  {  m state = state   options ;  update content fragment ( true )  ;   }  break ;  case state   auto   discover: m state = state   manual   incoming ;  update content fragment ( true )  ;  break ;  case state   manual   incoming: on incoming complete (  )  ;  m state = state   checking   incoming ;  initiate check settings fragment (  setup data fragment . check   incoming )  ;  break ;  case state   checking   incoming: final  email service utils .  email service info service info = m setup data . get incoming service info ( this )  ;  if  ( service info . uses smtp )   {  m state = state   manual   outgoing ;   }  else  {  m state = state   options ;   }  update content fragment ( true )  ;  break ;  case state   manual   outgoing: on outgoing complete (  )  ;  m state = state   checking   outgoing ;  initiate check settings fragment (  setup data fragment . check   outgoing )  ;  break ;  case state   checking   outgoing: m state = state   options ;  update content fragment ( true )  ;  break ;  case state   options: m state = state   creating ;  initiate account creation (  )  ;  break ;  case state   creating: m state = state   names ;  update content fragment ( true )  ;  if  ( m setup data . get flow mode (  )   =  =   authenticator setup intent helper . flow   mode   force   create )   {  get fragment manager (  )  . execute pending transactions (  )  ;  initiate account finalize (  )  ;   }  break ;  case state   names: initiate account finalize (  )  ;  break ;  case state   finalize: finish (  )  ;  break ;  default :  log utils . wtf (  log utils . tag " unknown state %d" m state )  ;  break ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  list composite disposable cd = new  list composite disposable (  )  ;   runnable run = new  runnable (  )  {  @ override public void run
public void   ( final  packet packet final  session session final boolean incoming final boolean processed )  {  if  (  ! processed )   {  return ;   }  stanza . increment and get (  )  ;  if  ( packet instanceof  message )   {  message . increment and get (  )  ;   }  if  ( packet instanceof  presence )   {  presence . increment and get (  )  ;   }  if  ( packet instanceof iq )   {  iq . increment and get (  )  ;  switch  (  (  ( iq ) packet )  . get type (  )  )   {  case get: iq get . increment and get (  )  ;  break ;  case set: iq set . increment and get (  )  ;  break ;  case result: iq result . increment and get (  )  ;  break ;  case error: iq error . increment and get (  )  ;  break ;   }   }   }  
@ override public  string   (  )  {  return " get  presence of  active  users" ;   }  
@ override public void   ( boolean can anyone discoverjid )  {  this . can anyone discoverjid = can anyone discoverjid ;   }  
@ test public void   (  )  {   signing public key public key = new  signing public key (  )  ;  byte data[] = new byte[ signing public key . keysize   bytes] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )  data[i] =  ( byte )  ( i % 56 )  ;  publ
@ test public void   (  )  {   flowable <  integer >  source =  flowable . just ( 1 )  ;  assert same ( source  (  (  (  has upstream publisher <  ?  >  ) source . reduce ( sum )  )  )  . source (  )  )  ;   }  
@ override public  collection <  user >    (  set <  string >  fields  string query int start index int num results )  throws  unsupported operation exception  {  if  ( searchsql  =  =  null )   {  throw new  unsupported operation exception (  )  ;   }  i
@ override public boolean   ( t t )  {  if  ( done )   {  return false ;   }   atomic reference array <  object >  ara = values ;  int n = ara . length (  )  ;   object[] objects = new  object[n  +  1] ;  objects[0] = t ;  for  ( int i = 0 ;  i  <  n ;  i
private void   (  )  {  int in =    context . get property ( prop   outbound   bandwidth   peak default   burst   seconds *    outbound burstk bytes per second )  ;  if  ( in  !  =     limiter . get outbound burst bytes (  )  )   {  if  ( in  >  =  min   outbound   bandwidth   peak )   {  if  ( in  <     outbound burstk bytes per second )     limiter . set outbound burst bytes (    outbound burstk bytes per second * 1024 )  ;  else    limiter . set outbound burst bytes ( in * 1024 )  ;   }  else  {  if  ( min   outbound   bandwidth   peak  <     outbound burstk bytes per second )     limiter . set outbound burst bytes (    outbound burstk bytes per second * 1024 )  ;  else    limiter . set outbound burst bytes ( min   outbound   bandwidth   peak * 1024 )  ;   }   }   }  
@ test public void   (  )  throws  exception  {  for  (  final  string reference : legal numeric character references )   {  final boolean result = xml lightweight parser . has illegal character references ( reference )  ;  assert false ( " value \""  +  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
public  string   (  )  {  return " expire participating tunnels" ;   }  
private void   (  pub sub service service iq iq  element child element  string nodeid )  {   node node = service . get node ( nodeid )  ;  if  ( node  =  =  null )   {  send error packet ( iq  packet error .  condition . item   not   found null )  ;  return ;   }  if  (  ! node . is admin ( iq . get from (  )  )  )   {  send error packet ( iq  packet error .  condition . forbidden null )  ;  return ;   }  iq reply = iq . create resultiq ( iq )  ;   element reply child element = child element . create copy (  )  ;  reply . set child element ( reply child element )  ;  reply child element . element ( "configure" )  . add ( node . get configuration form (  )  . get element (  )  )  ;  router . route ( reply )  ;   }  
public   ( final  read ends for mark duplicates read )  {  this . library id = read . get library id (  )  ;  this . orientation = read . orientation ;  this . read1 reference index = read . read1 reference index ;  this . read1 coordinate = read . read1 coordinate ;  this . read2 reference index = read . read2 reference index ;  this . read2 coordinate = read . read2 coordinate ;  this . read group = read . get read group (  )  ;  this . tile = read . get tile (  )  ;  this . x = read . x ;  this . y = read . y ;  this . orientation for optical duplicates = read . orientation for optical duplicates ;  this . score = read . score ;  this . read1 index in file = read . read1 index in file ;  this . read2 index in file = read . read2 index in file ;   }  
@ override public i binder   (  intent intent )  {  if  (  account manager . action   authenticator   intent . equals ( intent . get action (  )  )  )   {  return new  eas authenticator ( this )  . geti binder (  )  ;   }  else  {  return null ;   }   }  
public  string   (  )  {  build engine map (  )  ;  if  (    engines . is empty (  )  )  return " < b >  no search engines specified <  / b > " ;   string dflt =    context . get property ( prop   default )  ;  if  ( dflt  =  =  null ||  !    engines . contains key ( dflt )  )   {  int idx =    context . random (  )  . next int (    engines . size (  )  )  ;  int i = 0 ;  for  (   string name :    engines . key set (  )  )   {  dflt = name ;  if  ( i +  +   >  =  idx )   {     context . router (  )  . save config ( prop   default dflt )  ;  break ;   }   }   }   string builder buf = new  string builder ( 1024 )  ;  buf . append ( " < select name = \"engine\" title = \"" )  . append (    t ( " select search engine" )  )  . append ( "\" > " )  ;  for  (   string name :    engines . key set (  )  )   {  buf . append ( " < option value = \"" )  . append ( name )  . append ( '\"' )  ;  if  ( name . equals ( dflt )  )  buf . append ( " selected = \"selected\"" )  ;  buf . append ( ' > ' )  . append ( name )  . append ( " <  / option > \n" )  ;   }  buf . append ( " <  / select > \n" )  ;  return buf . to string (  )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  try  {  on error . accept ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  t = new  compos
public static void   (  workgroup event listener listener )  {  listeners . remove ( listener )  ;   }  
public  string   (  )  {  return system id ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is enum (  )   ?   optional . o
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   spsc linked array queue <  object >  q = queue ;   subscriber <  ?  super r >  a = actual ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  q . clear (  )  ;  return ;   }   throwable ex = error . get (  )  ;  if  ( ex  !  =  null )   {  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;  return ;   }  boolean d = active . get (  )   =  =  0 ;   integer mode =  (  integer ) q . poll (  )  ;  boolean empty = mode  =  =  null ;  if  ( d && empty )   {  lefts . clear (  )  ;  rights . clear (  )  ;  disposables . dispose (  )  ;  a . on complete (  )  ;  return ;   }  if  ( empty )   {  break ;   }   object val = q . poll (  )  ;  if  ( mode  =  =  left   value )   {  @ suppress warnings ( "unchecked" )  t left left =  ( t left ) val ;  int idx = left index +  +  ;  lefts . put ( idx left )  ;   publisher < t left end >  p ;  try  {  p =  object helper . require non null ( left end . apply ( left )  " the left end returned a null  publisher" )  ;   }  catch  (   throwable exc )   {  fail ( exc a q )  ;  return ;   }   left right end subscriber end = new  left right end subscriber ( this true idx )  ;  disposables . add ( end )  ;  p . subscribe ( end )  ;  ex = error . get (  )  ;  if  ( ex  !  =  null )   {  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;  return ;   }  long r = requested . get (  )  ;  long e = 0l ;  for  (  t right right : rights . values (  )  )   {  r w ;  try  {  w =  object helper . require non null ( result selector . apply ( left right )  " the result selector returned a null value" )  ;   }  catch  (   throwable exc )   {  fail ( exc a q )  ;  return ;   }  if  ( e  !  =  r )   {  a . on next ( w )  ;  e +  +  ;   }  else  {   exception helper . add throwable ( error new  missing backpressure exception ( " could not emit value due to lack of requests" )  )  ;  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;  return ;   }   }  if  ( e  !  =  0l )   {   backpressure helper . produced ( requested e )  ;   }   }  else if  ( mode  =  =  right   value )   {  @ suppress warnings ( "unchecked" )  t right right =  ( t right ) val ;  int idx = right index +  +  ;  rights . put ( idx right )  ;   publisher < t right end >  p ;  try  {  p =  object helper . require non null ( right end . apply ( right )  " the right end returned a null  publisher" )  ;   }  catch  (   throwable exc )   {  fail ( exc a q )  ;  return ;   }   left right end subscriber end = new  left right end subscriber ( this false idx )  ;  disposables . add ( end )  ;  p . subscribe ( end )  ;  ex = error . get (  )  ;  if  ( ex  !  =  null )   {  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;  return ;   }  long r = requested . get (  )  ;  long e = 0l ;  for  (  t left left : lefts . values (  )  )   {  r w ;  try  {  w =  object helper . require non null ( result selector . apply ( left right )  " the result selector returned a null value" )  ;   }  catch  (   throwable exc )   {  fail ( exc a q )  ;  return ;   }  if  ( e  !  =  r )   {  a . on next ( w )  ;  e +  +  ;   }  else  {   exception helper . add throwable ( error new  missing backpressure exception ( " could not emit value due to lack of requests" )  )  ;  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;  return ;   }   }  if  ( e  !  =  0l )   {   backpressure helper . produced ( requested e )  ;   }   }  else if  ( mode  =  =  left   close )   {   left right end subscriber end =  (  left right end subscriber ) val ;  lefts . remove ( end . index )  ;  disposables . remove ( end )  ;   }  else if  ( mode  =  =  right   close )   {   left right end subscriber end =  (  left right end subscriber ) val ;  rights . remove ( end . index )  ;  disposables . remove ( end )  ;   }   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
public static  integer   ( final  string file name )  {  final  matcher matcher =  pattern . compile ( "^s   \\d +     ( \\d { 1 5 }  )  .  + " )  . matcher ( file name )  ;  if  (  ! matcher . matches (  )  )   {  return null ;   }  return  integer . parse int ( matcher . group ( 1 )  )  ;   }  
private void   (  presence presence boolean is transfer  map <  string  string >  headers )  {  if  ( is transfer )   {  presence . get element (  )  . add ( handset provider . toxml ( new  transferring event (  )  )  )  ;   }  else  {  presence . get element (  )  . add ( rayo provider . toxml ( new  ringing event ( null headers )  )  )  ;   }   }  
public  timestamper   (  )  {  return new  timestamper (  )  ;   }  
public   (  router context ctx  console update manager mgr  list < uri >  uris long last update time )  {  super ( ctx mgr  update type . router   unsigned uris )  ;     ms = last update time ;   }  
public  list map <  transition  detail pair >    ( final  string sample alias final  string library )  {  final  list map <  transition  detail pair >  detail metrics map = new  list map <  >  (  )  ;  for  (  final  string context : new  tree set <  >  ( artifact map . key set (  )  )  )   {  if  (  ( context . length (  )  & 1 )   =  =  0 )  throw new  picard exception ( " contexts cannot have an even number of bases: "  +  context  +  " .   this should never happen here ! " )  ;  final char ref base = context . char at ( context . length (  )   /  2 )  ;  for  (  final  transition .  base alt base :  transition .  base . values (  )  )   {  final  transition transition =  transition . transition of ( ref base  ( char ) alt base . base )  ;  final  pre adapter detail metrics pre adapter detail metrics = new  pre adapter detail metrics (  )  ;  final  bait bias detail metrics bait bias detail metrics = new  bait bias detail metrics (  )  ;  pre adapter detail metrics . sample   alias = sample alias ;  pre adapter detail metrics . library = library ;  pre adapter detail metrics . context = context ;  pre adapter detail metrics . ref   base = transition . ref (  )  ;  pre adapter detail metrics . alt   base = transition . call (  )  ;  bait bias detail metrics . sample   alias = sample alias ;  bait bias detail metrics . library = library ;  bait bias detail metrics . context = context ;  bait bias detail metrics . ref   base = transition . ref (  )  ;  bait bias detail metrics . alt   base = transition . call (  )  ;  final  alignment accumulator[] accumulators = artifact map . get ( context )  ;  final  alignment accumulator[] reverse comp accumulators = artifact map . get (  sequence util . reverse complement ( context )  )  ;  final  alignment accumulator fwd ref alignments = accumulators[ transition . base index map[transition . ref (  ) ]] ;  final  alignment accumulator fwd alt alignments = accumulators[ transition . base index map[transition . call (  ) ]] ;  final  alignment accumulator rev ref alignments = reverse comp accumulators[ transition . base index map[transition . complement (  )  . ref (  ) ]] ;  final  alignment accumulator rev alt alignments = reverse comp accumulators[ transition . base index map[transition . complement (  )  . call (  ) ]] ;  if  ( expected tandem reads )   {  pre adapter detail metrics . pro   ref   bases = fwd ref alignments . r1   pos  +  fwd ref alignments . r2   pos  +  rev ref alignments . r1   neg +  rev ref alignments . r2   neg ;  pre adapter detail metrics . pro   alt   bases = fwd alt alignments . r1   pos  +  fwd alt alignments . r2   pos  +  rev alt alignments . r1   neg +  rev alt alignments . r2   neg ;  pre adapter detail metrics . con   ref   bases = fwd ref alignments . r1   neg  +  fwd ref alignments . r2   neg  +  rev ref alignments . r1   pos +  rev ref alignments . r2   pos ;  pre adapter detail metrics . con   alt   bases = fwd alt alignments . r1   neg  +  fwd alt alignments . r2   neg  +  rev alt alignments . r1   pos +  rev alt alignments . r2   pos ;   }  else  {  pre adapter detail metrics . pro   ref   bases = fwd ref alignments . r1   pos  +  fwd ref alignments . r2   neg  +  rev ref alignments . r1   neg +  rev ref alignments . r2   pos ;  pre adapter detail metrics . pro   alt   bases = fwd alt alignments . r1   pos  +  fwd alt alignments . r2   neg  +  rev alt alignments . r1   neg +  rev alt alignments . r2   pos ;  pre adapter detail metrics . con   ref   bases = fwd ref alignments . r1   neg  +  fwd ref alignments . r2   pos  +  rev ref alignments . r1   pos +  rev ref alignments . r2   neg ;  pre adapter detail metrics . con   alt   bases = fwd alt alignments . r1   neg  +  fwd alt alignments . r2   pos  +  rev alt alignments . r1   pos +  rev alt alignments . r2   neg ;   }  bait bias detail metrics . fwd   cxt   ref   bases = fwd ref alignments . r1   pos  +  fwd ref alignments . r1   neg  +  fwd ref alignments . r2   pos +  fwd ref alignments . r2   neg ;  bait bias detail metrics . fwd   cxt   alt   bases = fwd alt alignments . r1   pos  +  fwd alt alignments . r1   neg  +  fwd alt alignments . r2   pos +  fwd alt alignments . r2   neg ;  bait bias detail metrics . rev   cxt   ref   bases = rev ref alignments . r1   pos  +  rev ref alignments . r1   neg  +  rev ref alignments . r2   pos +  rev ref alignments . r2   neg ;  bait bias detail metrics . rev   cxt   alt   bases = rev alt alignments . r1   pos  +  rev alt alignments . r1   neg  +  rev alt alignments . r2   pos +  rev alt alignments . r2   neg ;  pre adapter detail metrics . calculate derived statistics (  )  ;  bait bias detail metrics . calculate derived statistics (  )  ;  detail metrics map . add ( transition new  detail pair ( pre adapter detail metrics bait bias detail metrics )  )  ;   }   }  return detail metrics map ;   }  
private static  state   (  session object session object  request wrapper request )  {   state state = null ;   string filename = request . get filename ( new   filename )  ;  if  ( filename  !  =  null &&  ( button pressed ( request new   upload )  || button pressed ( request send )  )  )   {  int i = filename . last index of ( ' / ' )  ;  if  ( i  !  =   - 1 )  filename = filename . substring ( i  +  1 )  ;  i = filename . last index of ( '\\' )  ;  if  ( i  !  =   - 1 )  filename = filename . substring ( i  +  1 )  ;  if  ( filename  !  =  null && filename . length (  )   >  0 )   {   input stream in = null ;   output stream out = null ;  i2p app context ctx = i2p app context . get global context (  )  ;   string temp = "susimail - attachment - "  +  ctx . random (  )  . next long (  )  ;   file f ;   mail cache drafts = session object . caches . get ( dir   drafts )  ;  if  ( drafts  !  =  null )   {  f = new  file ( drafts . get attachment dir (  )  temp )  ;   }  else  {  f = new  file ( ctx . get temp dir (  )  temp )  ;   }  try  {  in = request . get input stream ( new   filename )  ;  if  ( in  =  =  null )  throw new io exception ( "no stream" )  ;  out = new  secure file output stream ( f )  ;   data helper . copy ( in out )  ;   string content type = request . get content type ( new   filename )  ;   string encode to ;   string ctlc = content type . to lower case (  locale . us )  ;  if  ( ctlc . starts with ( "text / " )  )   {  encode to = "quoted - printable" ;  if  (  ! ctlc . contains ( "charset = " )  )  content type +  = " ;  charset = \"utf - 8\"" ;   }  else  {  encode to = "base64" ;   }   encoding encoding =  encoding factory . get encoding ( encode to )  ;  if  ( encoding  !  =  null )   {  if  ( session object . attachments  =  =  null )  session object . attachments = new  array list <  attachment >  (  )  ;  session object . attachments . add ( new  attachment ( filename content type encode to f )  )  ;   }  else  {  session object . error +  =    t ( " no  encoding found for  { 0 } " encode to )   +  '\n' ;   }   }  catch  (  io exception e )   {  session object . error +  =    t ( " error reading uploaded file:  { 0 } " e . get message (  )  )   +  '\n' ;  f . delete (  )  ;   }  finally  {  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  if  ( out  !  =  null )  try  {  out . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  state =  state . new ;   }  else if  ( session object . attachments  !  =  null && button pressed ( request delete   attachment )  )   {  for  (   string item : get checked items ( request )  )   {  try  {  int n =  integer . parse int ( item )  ;  for  ( int i = 0 ;  i  <  session object . attachments . size (  )  ;  i +  +  )   {   attachment attachment = session object . attachments . get ( i )  ;  if  ( attachment . hash code (  )   =  =  n )   {  session object . attachments . remove ( i )  ;  break ;   }   }   }  catch  (   number format exception nfe )   {   }   }  state =  state . new ;   }  return state ;   }  
public   ( boolean rev  string lang )  {  super ( rev lang )  ;   }  
public  peer manager facade   (  )  {  return    peer manager facade ;   }  
@ test @ ignore ( " null values no longer permitted" )  public void   (  )  {  final  atomic reference <  observer <  integer >  >  serial = new  atomic reference <  observer <  integer >  >  (  )  ;   test observer <  integer >  to = new  test observer <
@ override public  configuration resource   (  configuration resource cr )  {  return cr ;   }  
public  string   (  )  {  return cache name ;   }  
public  sel datagram channel   (  )  {  return channelb    ;   }  
public static  date   (  date date  double milliseconds )  {  return new  date ( date . get time (  )   +   ( long )  ( milliseconds . double value (  )  * 1 . 0d )  )  ;   }  
public   ( org . xmpp . packet .  roster .  item item )  {  this ( item . getjid (  )  get sub type ( item )  get ask status ( item )   roster item . recv   none item . get name (  )  new  linked list <  >  ( item . get groups (  )  )  )  ;   }  
public   ( byte[] first byte[] second )  {  this . first =  array utilities . null safe copy ( first )  ;  this . second =  array utilities . null safe copy ( second )  ;   }  
public void   ( boolean v )  throws io exception  {  delegate . write boolean ( v )  ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   update insert = h . create update ( "insert into something   else  ( name )  values  ( :name ) " )  ;  insert . bind ( "name" " brian" )  ;   long id1 = insert . 
@ test public void   (  )  {   observable <  integer >  src =  observable . range ( 1 10 )  . skip while ( less   than   five )  ;  int n = 5 ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {   observer <  object >  o =  test helper . mock observer (  )  ; 
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  boolean call on overflow = false ;  boolean call error = false ;   deque < t >  dq = deque ;  synchronized  ( dq )   {  if  ( dq . size (  )   =  =  buffer size )   {  switch  ( strategy
@ test public void   (  )  {   observable . range ( 1 10 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . just
@ test ( timeout = 4000 )  public void   (  )  throws  interrupted exception  {  final  replay processor <  long >  replay =  replay processor . create unbounded (  )  ;   thread source = new  thread ( new  runnable (  )  {  @ override public void run (  
public i2p session   (  )  {  return    session ;   }  
public   (  collection < e >  results  comparator < e >  comparator )  {  if  ( results  =  =  null )   {  throw new  null pointer exception ( " argument 'results' cannot be null . " )  ;   }  final int size = results . size (  )  ;  result list = new  array list <  >  ( size )  ;  uid to index = new  hashtable <  >  ( size )  ;   list < e >  sorted results = null ;  if  ( comparator  !  =  null )   {  sorted results = new  array list <  >  ( results )  ;   collections . sort ( sorted results comparator )  ;   }  int index = 0 ;  for  (  final e result :  ( sorted results  !  =  null  ?  sorted results : results )  )   {  if  ( result  =  =  null )   {  throw new  null pointer exception ( " the result set must not contain 'null' elements . " )  ;   }  final  string uid = result . getuid (  )  ;  if  ( uid to index . contains key ( uid )  )   {  throw new  illegal argument exception ( " the result set can not contain elements that have the same uid . " )  ;   }  result list . add ( result )  ;  uid to index . put ( uid index )  ;  index +  +  ;   }   }  
public   ( i2p app context ctx  peer checker task task )  {  super ( ctx . simple timer2 (  )  )  ;     task = task ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable <  integer >  error =  observable . error ( new  runtime exception (  )  )  ;   observable . amb (  arrays . as list (  observable . just ( 1 )  error )  )  . test (  )  . asse
public void   (  string password )  {   jive globals . set property ( "plugin . email . listener . password" password )  ;   }  
@ suppress warnings ( "unchecked" )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t1 t2 t3 t4 t5 t6 t7 t8 t9 r >  observable < r >    (  observable source <  ?  extends t1 >  source1  observable source <  ?  ext
private void   ( int now int disc sch on int conn timeout int lifetime int send stream id )  {  when ( clock . now (  )  )  . then return (  ( long ) now )  ;  when ( con . get disconnect scheduled on (  )  )  . then return (  ( long ) disc sch on )  ;  when ( con . get options (  )  )  . then return ( opts )  ;  when ( opts . get connect timeout (  )  )  . then return (  ( long ) conn timeout )  ;  when ( con . get lifetime (  )  )  . then return (  ( long ) lifetime )  ;  when ( con . get send stream id (  )  )  . then return (  ( long ) send stream id )  ;   }  
  (  atomic boolean lock  nameddb database  nameddb info  logger    log )  throws i2p exception  io exception   runtime exception  {  int port = 0 ;   inet address host = null ;  this . lock = lock ;  this . tg = null ;  this . database = database ;  this . info = info ;  this .    log =    log ;  lives = new  atomic boolean ( false )  ;  try  {  wlock (  )  ;  try  {  this . info . add ( "starting"  boolean . true )  ;   }  finally  {  wunlock (  )  ;   }   properties q = new  properties (  )  ;  rlock (  )  ;  try  {  n = this . info . get ( "nickname" )  . to string (  )  ;  prikey = new  byte array input stream (  ( byte[] ) info . get ( "keys" )  )  ;   properties r =  (  properties ) info . get ( "properties" )  ;   lifted . copy properties ( r q )  ;  this . go   out = info . exists ( "outport" )  ;  this . come   in = info . exists ( "inport" )  ;  if  ( this . come   in )   {  port =  integer . parse int ( info . get ( "inport" )  . to string (  )  )  ;  host =  inet address . get by name ( info . get ( "inhost" )  . to string (  )  )  ;   }   }  finally  {  runlock (  )  ;   }   string i2cp host = q . get property ( i2p client . prop   tcp   host "127 . 0 . 0 . 1" )  ;  int i2cp port = 7654 ;   string i2cp port str = q . get property ( i2p client . prop   tcp   port "7654" )  ;  try  {  i2cp port =  integer . parse int ( i2cp port str )  ;   }  catch  (   number format exception nfe )   {  throw new  illegal argument exception ( " invalid i2cp port specified ["  +  i2cp port str  +  "]" )  ;   }  if  ( this . come   in )   {  this . listener = new  server socket ( port backlog host )  ;   }  socket manager = i2p socket manager factory . create manager ( prikey i2cp host i2cp port q )  ;   }  catch  (  io exception e )   {  wlock (  )  ;  try  {  this . info . add ( "starting"  boolean . false )  ;   }  finally  {  wunlock (  )  ;   }  throw e ;   }  catch  (   runtime exception e )   {  wlock (  )  ;  try  {  this . info . add ( "starting"  boolean . false )  ;   }  finally  {  wunlock (  )  ;   }  throw e ;   }  catch  (   exception e )   {  wlock (  )  ;  try  {  this . info . add ( "starting"  boolean . false )  ;   }  finally  {  wunlock (  )  ;   }  e . print stack trace (  )  ;  throw new  runtime exception ( e )  ;   }   }  
@ override public void   (  http servlet request request  http servlet response response  presence presence )  throws io exception  {  response . set content type ( "text / xml" )  ;   print writer out = response . get writer (  )  ;  if  ( presence  =  =
@ test public void   (  )  {   flowable <  integer >  observable =  flowable .  <  integer > empty (  )  . single element (  )  . to flowable (  )  ;   subscriber <  integer >  observer =  test helper . mock subscriber (  )  ;  observable . subscribe ( ob
@ test public void   (  )  {   flowable . range ( 1 2 )  . replay (  integer . max   value )  . auto connect (  )  . test (  )  . assert result ( 1 2 )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts = pp . parallel (  )  . reduce ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  intege
private  hits for insert   (  )  {  if  (  ! peek iterator . has next (  )  )  throw new  illegal state exception (  )  ;  final  string read name = peek iterator . peek (  )  . get read name (  )  ;  final  hits for insert hits = new  hits for insert (  )  ;   boolean is paired = null ;  do  {  final sam record rec = peek iterator . next (  )  ;  replace hard with soft clips ( rec )  ;  if  ( peek iterator . has next (  )  && query name comparator . file order compare ( rec peek iterator . peek (  )  )   >  0 )   {  throw new  illegal state exception ( " underlying iterator is not queryname sorted: "  +  rec  +  "  >  " +  peek iterator . peek (  )  )  ;   }  if  ( is paired  =  =  null )   {  is paired = rec . get read paired flag (  )  ;   }  else if  ( is paired  !  =  rec . get read paired flag (  )  )   {  throw new  picard exception ( " got a mix of paired and unpaired alignments for read "  +  read name )  ;   }  if  (  ! rec . get read paired flag (  )  || rec . get first of pair flag (  )  )   {  if  ( rec . get supplementary alignment flag (  )  )   {  hits . add supplemental first of pair or fragment ( rec )  ;   }  else  {  hits . add first of pair or fragment ( rec )  ;   }   }  else if  ( rec . get second of pair flag (  )  )   {  if  ( rec . get supplementary alignment flag (  )  )   {  hits . add supplemental second of pair ( rec )  ;   }  else  {  hits . add second of pair ( rec )  ;   }   }  else throw new  picard exception ( " read is marked as pair but neither first or second: "  +  read name )  ;   }  while  ( peek iterator . has next (  )  && peek iterator . peek (  )  . get read name (  )  . equals ( read name )  )  ;  if  ( hits . num hits (  )   <  =  1 )   {  if  ( hits . get first of pair ( 0 )   !  =  null )   {  hits . get first of pair ( 0 )  . set attribute ( sam tag . hi . name (  )  null )  ;  hits . get first of pair ( 0 )  . set not primary alignment flag ( false )  ;   }  if  ( hits . get second of pair ( 0 )   !  =  null )   {  hits . get second of pair ( 0 )  . set attribute ( sam tag . hi . name (  )  null )  ;  hits . get second of pair ( 0 )  . set not primary alignment flag ( false )  ;   }   }  else  {  primary alignment selection strategy . pick primary alignment ( hits )  ;   }  return hits ;   }  
public void   ( byte[] in int in off int len )  {  digest . update ( in in off len )  ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return 1  /  v  >  0 ;   }   }    parallel failure handling .
@ override public void   (  disposable r )  {  srw . set resource ( r )  ;   }  
private static void   (  print writer out )  {  boolean fixed =  boolean . parse boolean (  config . get property ( config   ports   fixed "true" )  )  ;   string host =  config . get property ( config   host default   host )  ;   string pop3 =  config . get property ( config   ports   pop3 ""  +  default   pop3port )  ;   string smtp =  config . get property ( config   ports   smtp ""  +  default   smtpport )  ;  out . println ( " < div id = \"dologin\" >  < h1 > "  +     t ( "i2p mail  login" )   +  " <  / h1 >  < table cellspacing = \"3\" cellpadding = \"5\" > \n" +  " < tr >  < td align = \"right\" width = \"30%\" > " +     t ( " user" )  +  " <  / td >  < td width = \"40%\" align = \"left\" >  < input type = \"text\" size = \"32\" name = \"" +  user +  "\" value = \"" +  "\" >  @mail . i2p <  / td >  <  / tr > \n" +  " < tr >  < td align = \"right\" width = \"30%\" > " +     t ( " password" )  +  " <  / td >  < td width = \"40%\" align = \"left\" >  < input type = \"password\" size = \"32\" name = \"pass\" value = \"" +  "\" >  <  / td >  <  / tr > \n" )  ;  if  ( true )   {  out . println ( " < tr >  < td align = \"right\" width = \"30%\" > "  +     t ( " host" )   +  " <  / td >  < td width = \"40%\" align = \"left\" >  < input type = \"text\" size = \"32\" name = \"" +  host +  "\" value = \"" +  quotehtml ( host )  +  "\"" +   ( fixed  ?  " disabled" : "" )  +  " >  <  / td >  <  / tr > \n" +  " < tr >  < td align = \"right\" width = \"30%\" > " +     t ( "pop3  port" )  +  " <  / td >  < td width = \"40%\" align = \"left\" >  < input type = \"text\" style = \"text - align: right ; \" size = \"5\" name = \"" +  pop3 +  "\" value = \"" +  quotehtml ( pop3 )  +  "\"" +   ( fixed  ?  " disabled" : "" )  +  " >  <  / td >  <  / tr > \n" +  " < tr >  < td align = \"right\" width = \"30%\" > " +     t ( "smtp  port" )  +  " <  / td >  < td width = \"40%\" align = \"left\" >  < input type = \"text\" style = \"text - align: right ; \" size = \"5\" name = \"" +  smtp +  "\" value = \"" +  quotehtml ( smtp )  +  "\"" +   ( fixed  ?  " disabled" : "" )  +  " >  <  / td >  <  / tr > \n" )  ;   }  out . println ( " < tr >  < td colspan = \"2\" >  < hr >  <  / td >  <  / tr > \n"  +  " < tr >  < td colspan = \"2\" align = \"center\" > "  +  button ( login    t ( " login" )  )   +  spacer +  button ( offline    t ( " read  mail  offline" )  )  +  spacer +  button ( configure    t ( " settings" )  )  +  " <  / td >  <  / tr > \n" +  " < tr >  < td align = \"center\" colspan = \"2\" >  < hr >  < a href = \"http: /  / hq . postman . i2p /  ? page   id = 14\" target = \"   blank\" > " +     t ( " learn about i2p mail" )  +  " <  / a >  |  < a href = \"http: /  / hq . postman . i2p /  ? page   id = 16\" target = \"   blank\" > " +     t ( " create  account" )  +  " <  / a >  <  / td >  <  / tr > \n" +  " <  / table >  <  / div > " )  ;   }  
@ test public void   (  )  throws  exception  {   signing private key signing private key = new  signing private key (  )  ;  byte data[] = new byte[ signing private key . keysize   bytes] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )  data[i] =
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . range ( 1 5 )  . buffer ( 5 1 )  . test (  )  . assert result (  arrays . as list ( 1 2 3 4 5 )   arrays . as list ( 2 3 4 5 )   arrays . as list ( 3 4 5 )   arrays . as list
@ override protected  action   (  session data data )  {  return null ;   }  
public void   (  )  {  interceptor manager . remove interceptor ( this )  ;   }  
private void   (  )  {  xmpp server server = xmpp server . get instance (  )  ;  server . getiq disco info handler (  )  . add server feature ( namespace )  ;  stuniq handler = new stuniq handler (  )  ;  server . getiq router (  )  . add handler ( stuniq handler )  ;   }  
private void   (  )  {   properties props = web app properties (    context )  ;   set <  string >  keys = props . string property names (  )  ;  for  (   string name : keys )   {  if  ( name . starts with ( prefix )  && name . ends with ( enabled )  )   {   string app = name . substring ( prefix . length (  )  name . last index of ( enabled )  )  ;  if  ( routerconsole . equals ( app )  )  continue ;  if  (  web app starter . is web app running ( app )  )   {  try  {   web app starter . stop web app (    context app )  ;   }  catch  (   throwable t )   {  t . print stack trace (  )  ;   }   }   }   }   }  
@ override public void   (  user user  map <  string  object >  params )  {  final jid barejid = xmpp server . get instance (  )  . createjid ( user . get username (  )  null )  ;  final pep service pep service = pep service manager . getpep service ( bar
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  boundary =  publish processor . create (  )  ;   subscriber <  object >  o =  test helper . mock subscriber (  ) 
public void   (  certificate store store )  {  if  ( store  =  =  null )   {  throw new  illegal argument exception ( " argument 'store' cannot be null . " )  ;   }  if  ( store watcher  =  =  null )   {  return ;   }  final  path dir = store . get configuration (  )  . get file (  )  . to path (  )  . normalize (  )  . get parent (  )  ;  synchronized  ( watched stores )   {  watched stores . put ( store dir )  ;  if  (  ! watched paths . contains key ( dir )  )   {  try  {  final  watch key watch key = dir . register ( store watcher  standard watch event kinds . entry   modify  standard watch event kinds . entry   create )  ;  watched paths . put ( dir watch key )  ;   }  catch  (   throwable t )   {   log . warn ( " unable to add a watcher for a path that contains files that provides the backend storage for certificate stores .   changes to those files are unlikely to be picked up automatically .   path:  {  } " dir t )  ;  watched stores . remove ( store )  ;   }   }   }   }  
  ( final  string .  .  .  values )  {  this . values = values ;   }  
public int   (  )  {  return number ;   }  
private void   (  map <  forward port  forward port status >  statuses )  {  byte[] ipaddr = null ;   detectedip[] ips =    upnp . get address (  )  ;  if  ( ips  !  =  null )   {  for  (   detectedip ip : ips )   {  if  (  transport util . is publicly routable ( ip . public address . get address (  )  false )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " external address: "  +  ip . public address  +  " type: " +  ip . nat type )  ;  if  (  ! ip . public address . equals (    detected address )  )   {     detected address = ip . public address ;     manager . external address received ( source   upnp    detected address . get address (  )  0 )  ;   }  ipaddr = ip . public address . get address (  )  ;  break ;   }   }   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " no external address returned" )  ;   }  for  (   map .  entry <  forward port  forward port status >  entry : statuses . entry set (  )  )   {   forward port fp = entry . get key (  )  ;   forward port status fps = entry . get value (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( fp . name  +  " "  +  fp . protocol +  " " +  fp . port number +  " status: " +  fps . status +  " reason: " +  fps . reason string +  " ext port: " +  fps . external port )  ;   string style ;  if  ( fp . protocol  =  =   forward port . protocol   udp   ipv4 )  style = "ssu" ;  else if  ( fp . protocol  =  =   forward port . protocol   tcp   ipv4 )  style = "ntcp" ;  else continue ;  boolean success = fps . status  >  =   forward port status . maybe   success ;     manager . forward port status ( style ipaddr fp . port number fps . external port success fps . reason string )  ;   }   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . publish (  functions .  <  flowable <  integer >  > identity (  )  )  . rebatch requests ( 1 )  . test (  )  . assert result ( 1 2 3 4 5 6 7 8 9 10 )  ;   }  
private  unsupported operation exception   (  type type  object value )  {  if  ( type instanceof  class <  ?  >  )   {  final  type variable <  ?  > [] params =  (  (  class <  ?  >  ) type )  . get type parameters (  )  ;  if  ( params . length  >  0 )   {  return new  unsupported operation exception ( " no type parameters found for erased type '"  +  type  +   arrays . to string ( params )  +  "' .   to bind a generic type  prefer using bind by type . " )  ;   }   }  return new  unsupported operation exception ( " no argument factory registered for '"  +  value  +  "' of type " +  type )  ;   }  
public double   ( final  genotype concordance scheme scheme final  call state[] call state list )  {  double numerator = 0 . 0 ;  double denominator = 0 . 0 ;  scheme . validate scheme (  )  ;  for  (  final  call state call state : call state list )   {  for  (  final  truth state truth state :  truth state . values (  )  )   {  final  truth and call states truth and call states = new  truth and call states ( truth state call state )  ;  final long count = get count ( truth and call states )  ;  for  (  final  contingency state contingency state : scheme . get concordance state array ( truth and call states )  )   {  if  (  contingency state . tp  =  =  contingency state )   {  numerator +  = count ;  denominator +  = count ;   }  else if  (  contingency state . fp  =  =  contingency state )   {  denominator +  = count ;   }   }   }   }  return  ( numerator  /  denominator )  ;   }  
public  string   (  )  {  return    requesturi  !  =  null  ?     requesturi : " / home" ;   }  
  ( int sql type  callable statement mapper mapper  string name )  {  this . sql type = sql type ;  this . mapper = mapper ;  this . name = name ;  params . add ( this )  ;   }  
public  chat settings   (  workgroup workgroup )  {   string workgroup node = workgroup . getjid (  )  . get node (  )  ;   chat settings chat settings = cached settings . get ( workgroup node )  ;  if  ( chat settings  =  =  null )   {  synchronized  ( workgroup node . intern (  )  )   {  chat settings = cached settings . get ( workgroup node )  ;  if  ( chat settings  =  =  null )   {  chat settings = get chat settings from db ( workgroup )  ;   }   }   }  return chat settings ;   }  
public long   (  )  {  return    last send ;   }  
public long   (  )  {  long timeout = 30 * 60 * 1000 ;  try  {  timeout =  long . parse long ( workgroup . get properties (  )  . get property ( "chatbot . session . timeout" )  )  ;   }  catch  (   number format exception e )   {   }  return timeout ;   }  
public   (  ldap manager manager  ldap user profile profile )  {  this . manager = manager ;  this . profile = profile ;   }  
protected double   (  node parent node )  {   string value str = get value ( parent node )  ;  return  util . parse double ( value str )  ;   }  
@ test public void   (  )  {   flowable . sequence equal (  flowable . range ( 1 20 )   flowable . range ( 1 20 )  2 )  . to flowable (  )  . test (  )  . assert result ( true )  ;   }  
@ setup public void   (  )  {   integer[] array = new  integer[items] ;   arrays . fill ( array 777 )  ;  flat map completable =  flowable . from array ( array )  . flat map completable (  functions . just function (  completable . from action ( this )  .
private void   ( iq packet  session session )  {  iq result = iq . create resultiq ( packet )  ;  session . process ( result )  ;   }  
private void   ( int adjustment )  {  rtp timestamp +  = adjustment ;  buffer[4] =  ( byte )  (  ( rtp timestamp  >  >  24 )  & 0xff )  ;  buffer[5] =  ( byte )  (  ( rtp timestamp  >  >  16 )  & 0xff )  ;  buffer[6] =  ( byte )  (  ( rtp timestamp  >  >  8 )  & 0xff )  ;  buffer[7] =  ( byte )  ( rtp timestamp & 0xff )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public void   (  throwable e )  {  d =  disposable helper . disposed ;  actual . on error ( e )  ;   }  
public static void   (  string policy )  throws  modification not allowed exception  {  set permission policy (  permission policy . value of ( policy )  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
public  exception   (  )  {  return inner exception ;   }  
@ override protected void   (  observer <  ?  super  integer >  o )  {   range disposable parent = new  range disposable ( o start end )  ;  o . on subscribe ( parent )  ;  parent . run (  )  ;   }  
@ data provider ( name = " " )  public  object[][] test wgs metrics merge data provider (  )  {  return new  object[][] {  { empty metrics (  )  empty metrics (  )  empty metrics (  )  }   { empty metrics (  )  single depth metrics ( 1 1 1 )  single depth
public  string   (  )  {  return  split vcfs . class . get simple name (  )  ;   }  
@ test public void   (  )  throws io exception  {  int expected = 2048 ;  source buffer . put ( fill ( new byte[2048] )  )  ;  assert equals ( " available should be entire buffer" expected source buffer . available (  )  )  ;  byte[] buffer = new byte[204
@ test public void   (  )  {  final  publish subject <  integer >  s =  publish subject . create (  )  ;  final  atomic integer count parent = new  atomic integer (  )  ;  final  atomic integer count children = new  atomic integer (  )  ;  final  atomic i
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
public static void   ( i2p app context ctx ssl socket socket  string host )  throws ssl exception  {   log log = ctx . log manager (  )  . get log ( i2pssl socket factory . class )  ;  if  ( ctx . get boolean property ( prop   disable )  || host . equals ( "localhost" )  || host . equals ( "127 . 0 . 0 . 1" ) || host . equals ( "::1" ) || host . equals ( "0:0:0:0:0:0:0:1" )  )   {  if  ( log . should warn (  )  )  log . warn ( " skipping hostname validation for "  +  host )  ;  return ;   }   hostname verifier hv ;  if  (  system version . is android (  )  )   {  hv =  httpsurl connection . get default hostname verifier (  )  ;   }  else  {  hv = new  default hostname verifier ( get default matcher ( ctx )  )  ;   }  ssl session sess = socket . get session (  )  ;  if  (  ! hv . verify ( host sess )  )   {  throw new ssl handshake exception ( "ssl hostname verify failed   expected "  +  host  +  "  -  set " +  prop   disable +  " = true to disable verification  ( dangerous !  ) " )  ;   }   }  
public void   (  data output out  map <  ?  extends  serializable  ?  extends  serializable >  map )  throws io exception  {  write object ( out map )  ;   }  
  ( int[] values  string .  .  .  other encoding names )  {  this . values = values ;  this . other encoding names = other encoding names ;   }  
@ override protected byte[]   (  )  throws  signature exception  {   big integer elgp = key . get params (  )  . getp (  )  ;   big integer pm1 = elgp . subtract (  big integer . one )  ;   big integer elgg = key . get params (  )  . getg (  )  ;   big in
@ override public  flowable < t >    (  )  {  return  rx java plugins . on assembly ( new  flowable element at < t >  ( source index default value true )  )  ;   }  
public static int   (  context context  account account )  {  return  ( int ) account . m id | reason   attachment   user ;   }  
public   (  date and flags options )  {  super (  )  ;     daf = options ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to ( null )  ;   }  
public  string   (  )  {  int[] silence = new int[media info . get samples per packet (  ) ] ;   string dtmf keys = null ;  dtmf keys = process data ( silence )  ;  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( "no data received  done processing dtmf with silence" )  ;  if  ( dtmf keys  !  =  null )   {   logger . println ( "silence .  dtmf "  +  dtmf keys )  ;   }   }  return dtmf keys ;   }  
@ test public void   (  )  {   runnable noop = mock (  runnable . class )  ;   unicast subject <  integer >  ap =  unicast subject . create ( 16 noop false )  ;  ap . on next ( 1 )  ;  ap . on error ( new  runtime exception (  )  )  ;   test observer <  i
@ test public void   (  )  throws io exception  {  final  file input = new  file ( test   data   dir "summary   alignment   bisulfite   test . sam" )  ;  final  file reference = new  file ( test   data   dir "summary   alignment   stats   test . fasta" ) 
@ override public  < t extends  event listener > t   (  class < t >  clazz )  throws  servlet exception  {  return context . create listener ( clazz )  ;   }  
@ test public void   (  )  {   replay processor <  integer >  rs =  replay processor . create with time ( 1  time unit . days  schedulers . trampoline (  )  )  ;  rs . on next ( 1 )  ;  rs . on next ( 2 )  ;  rs . on next ( 3 )  ;  rs . on complete (  )  
public void   ( byte target[] int target offset )  {  int offset = read body offset (  )  ;  int size =    message[offset] & 0xff ;  offset +  +  ;   system . arraycopy (    message offset target target offset size )  ;   }  
private void   (  client session session  presence presence )  {   connection con = null ;   prepared statement pstmt = null ;  final  string presence text ;  if  (  ! xmpp server . get instance (  )  . get user manager (  )  . is registered user ( session . get address (  )  )  )   {  return ;   }  if  (  presence .  type . unavailable . equals ( presence . get type (  )  )  )   {  presence text = presence . get type (  )  . to string (  )  ;   }  else if  ( presence . get show (  )   !  =  null )   {  presence text = presence . get show (  )  . to string (  )  ;   }  else if  ( presence . is available (  )  )   {  presence text = "available" ;   }  else  {  return ;   }  set presence ( session presence text )  ;   }  
@ before public void   (  )  {  persondao = db rule . get jdbi (  )  . on demand (  persondao . class )  ;  persondao . create table (  )  ;   }  
private void   (  packet packet )  {  if  ( packet . get from (  )  . to barejid (  )  . equals ( get group chat room name (  )  )  )   {  return ;   }   room interceptor manager interceptor manager =  room interceptor manager . get instance (  )  ;   string roomid = packet . get from (  )  . get node (  )  ;   string sessionid = packet . get from (  )  . get node (  )  ;  synchronized  ( sessionid . intern (  )  )   {  if  ( packet instanceof  presence )   {   presence presence =  (  presence ) packet ;  if  (  presence .  type . error  =  =  presence . get type (  )  )   {   string warn message = " possible server misconfiguration .   received error "  +  "presence:"  +  presence . toxml (  )  ;   log . warn ( warn message )  ;  return ;   }   element muc user = presence . get child element ( "x" "http: /  / jabber . org / protocol / muc#user" )  ;  if  ( muc user  =  =  null )   {  return ;   }   element item = muc user . element ( "item" )  ;  if  ( item  =  =  null )   {  return ;   }  if  ( workgroup name . equals ( packet . get from (  )  . get resource (  )  )  )   {  return ;   }  jid presence fulljid = new jid ( item . attribute value ( "jid" )  )  ;   string presencejid = presence fulljid . to barejid (  )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false false )  ;   user request initial request = requests . get ( sessionid )  ;   map <  packet java . util .  date >  message list = transcripts . get ( roomid )  ;  if  ( message list  =  =  null )   {  message list = new  linked hash map <  packet java . util .  date >  (  )  ;  transcripts . put ( roomid message list )  ;   workgroup event dispatcher . chat support started ( this sessionid )  ;   }  message list . put ( packet . create copy (  )  new java . util .  date (  )  )  ;  boolean occupant added = false ;   set <  string >  set = occupants counter . get ( roomid )  ;  if  ( set  =  =  null )   {  set = new  hash set <  string >  (  )  ;  occupants counter . put ( roomid set )  ;   }  if  ( presence . is available (  )  )   {  occupant added = set . add ( presencejid )  ;   }  else  {   string xpath = " / presence / *[name (  )  = 'x'] / *[name (  )  = 'status']" ;   element status =  (  element ) presence . get element (  )  . select single node ( xpath )  ;  if  ( status  =  =  null ||  ! "303" . equals ( status . attribute value ( "code" )  )  )   {  set . remove ( presencejid )  ;   }   }   string agentjid = null ;  for  (   agent agent : get agents (  )  )   {  if  ( agent . get agentjid (  )  . to barejid (  )  . equals ( presencejid )  )   {  agentjid = agent . get agentjid (  )  . to barejid (  )  ;   }   }  if  ( agentjid  !  =  null )   {   agent session agent session ;  try  {  agent session = agent manager . get agent session ( presence fulljid )  ;  if  ( agent session  !  =  null )   {  if  ( presence . is available (  )  )   {  if  ( occupant added )   {  agent session . add chat info ( this sessionid initial request new java . util .  date (  )  )  ;   workgroup event dispatcher . agent joined chat support ( this sessionid agent session )  ;   }   }  else  {  agent session . remove chat info ( this sessionid )  ;   workgroup event dispatcher . agent left chat support ( this sessionid agent session )  ;   }   }   }  catch  (   agent not found exception e )   {   }  if  ( presence . is available (  )  )   {  if  ( occupant added )   {   db workgroup . update joined session ( sessionid agentjid true )  ;   }   }  else  {   db workgroup . update joined session ( sessionid agentjid false )  ;   }   }  else  {  if  ( occupant added )   {  initial request . support started ( roomid )  ;   }   }  if  ( occupant added )   {  initial request . user joined room ( new jid ( packet . get from (  )  . to barejid (  )  )  presence fulljid )  ;   }  boolean is agent = false ;  try  {  is agent = agent manager . get agent session ( presence fulljid )   !  =  null ;   }  catch  (   agent not found exception e )   {   }  if  (  !  (  (  presence ) packet )  . is available (  )  &&  ! is agent )   {   map <  packet java . util .  date >  map = transcripts . get ( roomid )  ;   string builder buf = new  string builder (  )  ;  buf . append ( " < transcript > " )  ;  for  (   packet p : map . key set (  )  )   {  java . util .  date date = map . get ( p )  ;  if  ( p instanceof  message )   {   message stored message =  (  message ) p ;   element delay = stored message . add child element ( "x" "jabber:x:delay" )  ;  delay . add attribute ( "stamp" utc   format . format ( date )  )  ;  if  (  model util . has length ( stored message . get body (  )  )  )   {  buf . append ( p . toxml (  )  )  ;   }   }  else  {   presence stored presence =  (  presence ) p ;   element delay = stored presence . add child element ( "x" "jabber:x:delay" )  ;  delay . add attribute ( "stamp" utc   format . format ( date )  )  ;  buf . append ( p . toxml (  )  )  ;   }   }  buf . append ( " <  / transcript > " )  ;   db workgroup . update transcript ( sessionid buf . to string (  )  new java . util .  date (  )  )  ;   }  if  (  !  (  (  presence ) packet )  . is available (  )  && set . is empty (  )  )   {  occupants counter . remove ( roomid )  ;  initial request = requests . remove ( sessionid )  ;  if  ( initial request  !  =  null && initial request . has joined room (  )  )   {  initial request . support ended (  )  ;   }   map <  packet java . util .  date >  map = transcripts . get ( roomid )  ;   string builder buf = new  string builder (  )  ;  buf . append ( " < transcript > " )  ;  for  (   packet p : map . key set (  )  )   {  java . util .  date date = map . get ( p )  ;  if  ( p instanceof  message )   {   message stored message =  (  message ) p ;   element delay = stored message . add child element ( "x" "jabber:x:delay" )  ;  delay . add attribute ( "stamp" utc   format . format ( date )  )  ;  if  (  model util . has length ( stored message . get body (  )  )  )   {  buf . append ( p . toxml (  )  )  ;   }   }  else  {   presence stored presence =  (  presence ) p ;   element delay = stored presence . add child element ( "x" "jabber:x:delay" )  ;  delay . add attribute ( "stamp" utc   format . format ( date )  )  ;  buf . append ( p . toxml (  )  )  ;   }   }  buf . append ( " <  / transcript > " )  ;   string roomjid = packet . get from (  )  . to string (  )   +  " / "  +  getjid (  )  . get node (  )  ;   leave room leave room = new  leave room ( get fulljid (  )  . to string (  )  roomjid )  ;  send ( leave room )  ;  transcripts . remove ( roomid )  ;   workgroup event dispatcher . chat support finished ( this sessionid )  ;   }  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false true )  ;   }  else if  ( packet instanceof  message )   {  if  ( packet . get from (  )  . get resource (  )   !  =  null )   {  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false false )  ;   map <  packet java . util .  date >  message list = transcripts . get ( roomid )  ;  if  ( message list  =  =  null )   {  message list = new  linked hash map <  packet java . util .  date >  (  )  ;  transcripts . put ( roomid message list )  ;   }  message list . put ( packet . create copy (  )  new java . util .  date (  )  )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false true )  ;   }   }   }   }  
@ override public void   (  )  {  if  (  cluster manager . is clustering started (  )  &&  !  cluster manager . is senior cluster member (  )  )   {  return ;   }  try  {  localmuc room manager . cleanup rooms ( get cleanup date (  )  )  ;   }  catch  (  
@ suppress warnings ( "unchecked" )  public int   (  )  throws  class not found exception   illegal access exception   invocation target exception   no such method exception  {  final  class policy =  class . for name ( policy )  ;  final  object return v
protected int   (  )  {  io util . assert inputs are valid ( input )  ;  io util . assert file is writable ( output )  ;  io util . assert file is writable ( metrics   file )  ;  final boolean use barcodes =  ( null  !  =  barcode   tag || null  !  =  read   one   barcode   tag || null  !  =  read   two   barcode   tag )  ;  report memory stats ( " start of do work" )  ;  log . info ( " reading input file and constructing read end information . " )  ;  build sorted read end lists ( use barcodes )  ;  report memory stats ( " after build sorted read end lists" )  ;  generate duplicate indexes ( use barcodes this . remove   sequencing   duplicates || this . tagging   policy  !  =   duplicate tagging policy .  dont tag )  ;  report memory stats ( " after generate duplicate indexes" )  ;  log . info ( " marking "  +  this . num duplicate indices  +  " records as duplicates . " )  ;  if  ( this . read   name   regex  =  =  null )   {  log . warn ( " skipped optical duplicate cluster discovery ;  library size estimation may be inaccurate ! " )  ;   }  else  {  log . info ( " found "  +   ( this . library id generator . get number of optical duplicate clusters (  )  )   +  " optical duplicate clusters . " )  ;   }  final  sam header and iterator header and iterator = open inputs ( false )  ;  final sam file header header = header and iterator . header ;  final sam file header .  sort order sort order = header . get sort order (  )  ;  final sam file header output header = header . clone (  )  ;  log . info ( " reads are assumed to be ordered by: "  +  sort order )  ;  if  ( sort order  !  =  sam file header .  sort order . coordinate && sort order  !  =  sam file header .  sort order . queryname )   {  throw new  picard exception ( " this program requires input that are either coordinate or query sorted .  "  +  " found "  +  sort order )  ;   }  comment . for each ( output header::add comment )  ;  final  map <  string  string >  chained pg ids = get chained pg ids ( output header )  ;  final sam file writer out = new sam file writer factory (  )  . makesam orbam writer ( output header true output )  ;  long record in file index = 0 ;  long next optical duplicate index = this . optical duplicate indexes  !  =  null && this . optical duplicate indexes . has next (  )   ?  this . optical duplicate indexes . next (  )  : no   such   index ;  long next duplicate index =  ( this . duplicate indexes . has next (  )   ?  this . duplicate indexes . next (  )  : no   such   index )  ;   closeable iterator <  representative read indexer >  representative read iterator = null ;   representative read indexer rri = null ;  int representative read index in file =  - 1 ;  int duplicate set size =  - 1 ;  int next representative index =  - 1 ;  if  ( tag   duplicate   set   members )   {  representative read iterator = this . representative read indices for duplicates . iterator (  )  ;  if  ( representative read iterator . has next (  )  )   {  rri = representative read iterator . next (  )  ;  next representative index = rri . read index in file ;  representative read index in file = rri . representative read index in file ;  duplicate set size = rri . set size ;   }   }  final  progress logger progress = new  progress logger ( log  ( int ) 1e7 " written" )  ;  final  closeable iterator < sam record >  iterator = header and iterator . iterator ;   string duplicate query name = null ;   string optical duplicate query name = null ;  while  ( iterator . has next (  )  )   {  final sam record rec = iterator . next (  )  ;  final  string library =  library id generator . get library name ( header rec )  ;   duplication metrics metrics = library id generator . get metrics by library ( library )  ;  if  ( metrics  =  =  null )   {  metrics = new  duplication metrics (  )  ;  metrics . library = library ;  library id generator . add metrics by library ( library metrics )  ;   }  if  ( rec . get read unmapped flag (  )  )   {   +  + metrics . unmapped   reads ;   }  else if  ( rec . is secondary or supplementary (  )  )   {   +  + metrics . secondary   or   supplementary   rds ;   }  else if  (  ! rec . get read paired flag (  )  || rec . get mate unmapped flag (  )  )   {   +  + metrics . unpaired   reads   examined ;   }  else  {   +  + metrics . read   pairs   examined ;   }  final boolean need next duplicate index = record in file index  >  next duplicate index &&  ( sort order  =  =  sam file header .  sort order . coordinate ||  ! rec . get read name (  )  . equals ( duplicate query name )  )  ;  if  ( need next duplicate index )   {  next duplicate index =  ( this . duplicate indexes . has next (  )   ?  this . duplicate indexes . next (  )  : no   such   index )  ;   }  final boolean is duplicate = record in file index  =  =  next duplicate index ||  ( sort order  =  =  sam file header .  sort order . queryname && record in file index  >  next duplicate index && rec . get read name (  )  . equals ( duplicate query name )  )  ;  if  ( is duplicate )   {  duplicate query name = rec . get read name (  )  ;  rec . set duplicate read flag ( true )  ;  if  (  ! rec . is secondary or supplementary (  )  &&  ! rec . get read unmapped flag (  )  )   {  if  (  ! rec . get read paired flag (  )  || rec . get mate unmapped flag (  )  )   {   +  + metrics . unpaired   read   duplicates ;   }  else  {   +  + metrics . read   pair   duplicates ;   }   }   }  else  {  rec . set duplicate read flag ( false )  ;   }  final boolean need next optical duplicate index = record in file index  >  next optical duplicate index &&  ( sort order  =  =  sam file header .  sort order . coordinate ||  ! rec . get read name (  )  . equals ( optical duplicate query name )  )  ;  if  ( need next optical duplicate index )   {  next optical duplicate index =  ( this . optical duplicate indexes . has next (  )   ?  this . optical duplicate indexes . next (  )  : no   such   index )  ;   }  final boolean is optical duplicate = sort order  =  =  sam file header .  sort order . queryname && record in file index  >  next optical duplicate index && rec . get read name (  )  . equals ( optical duplicate query name )  || record in file index  =  =  next optical duplicate index ;  if  ( clear   dt )   {  rec . set attribute ( duplicate   type   tag null )  ;   }  if  ( this . tagging   policy  !  =   duplicate tagging policy .  dont tag && rec . get duplicate read flag (  )  )   {  if  ( is optical duplicate )   {  optical duplicate query name = rec . get read name (  )  ;  rec . set attribute ( duplicate   type   tag  duplicate type . sequencing . code (  )  )  ;   }  else if  ( this . tagging   policy  =  =   duplicate tagging policy .  all )   {  rec . set attribute ( duplicate   type   tag  duplicate type . library . code (  )  )  ;   }   }  if  ( tag   duplicate   set   members )   {  final boolean need next representative index = record in file index  >  next representative index ;  if  ( need next representative index && representative read iterator . has next (  )  )   {  rri = representative read iterator . next (  )  ;  next representative index = rri . read index in file ;  representative read index in file = rri . representative read index in file ;  duplicate set size = rri . set size ;   }  final boolean is in duplicate set = record in file index  =  =  next representative index ||  ( sort order  =  =  sam file header .  sort order . queryname && record in file index  >  next duplicate index )  ;  if  ( is in duplicate set )   {  if  (  ! rec . is secondary or supplementary (  )  &&  ! rec . get read unmapped flag (  )  )   {  if  ( tag   duplicate   set   members )   {  rec . set attribute ( duplicate   set   index   tag representative read index in file )  ;  rec . set attribute ( duplicate   set   size   tag duplicate set size )  ;   }   }   }   }  record in file index +  +  ;  if  ( this . remove   duplicates && rec . get duplicate read flag (  )  )   {  continue ;   }  if  ( this . remove   sequencing   duplicates && is optical duplicate )   {  continue ;   }  if  ( program   record   id  !  =  null && pg tag argument collection . add   pg   tag   to   reads )   {  rec . set attribute ( sam tag . pg . name (  )  chained pg ids . get ( rec . get string attribute ( sam tag . pg . name (  )  )  )  )  ;   }  out . add alignment ( rec )  ;  progress . record ( rec )  ;   }  iterator . close (  )  ;  this . duplicate indexes . cleanup (  )  ;  if  ( tag   duplicate   set   members )   {  this . representative read indices for duplicates . cleanup (  )  ;   }  report memory stats ( " before output close" )  ;  out . close (  )  ;  report memory stats ( " after output close" )  ;  finalize and write metrics ( library id generator )  ;  return 0 ;   }  
public static void   (  lock out event listener listener )  {  listeners . remove ( listener )  ;   }  
@ inject public   ( @ value (  repose spring properties . node . cluster   id )   string cluster id @ value (  repose spring properties . node . node   id )   string node id  datastore service datastore service  configuration service configuration service
public int   (  )  {  synchronized  (    trend )   {  for  ( int i = 0 ;  i  <  trend   count  -  1 ;  i +  +  )   {  if  (    trend[i]  !  =     trend[i  +  1] )  return 0 ;   }  return    trend[0] ;   }   }  
public   (  long synchronization and contributing sources[] )  throws  argument null exception  {  if  ( synchronization and contributing sources  =  =  null )   {  throw new  argument null exception ( "synchronization and contributing sources" )  ;   }  else  {  set synchronization and contributing sources ( synchronization and contributing sources )  ;  return ;   }   }  
@ override public void   (  )  {  log . trace ( " rate  limiting filter destroying .  .  . " )  ;  configuration service . unsubscribe from ( config filename this )  ;  log . trace ( " rate  limiting filter destroyed . " )  ;   }  
public  string   (  )  {  if  ( bind addr  =  =  null )  return "" ;  return bind addr . to string (  )  ;   }  
static  set <  router address >    ( int num )  {   set <  router address >  addresses = new  hash set <  router address >  (  )  ;   router address addr = createtcp address ( num )  ;  if  ( addr  !  =  null )  addresses . add ( addr )  ;  return addresses ;   }  
private boolean   (  )  {  while  (  ! stop &&  !    util . connected (  )  )   {  boolean ok =    util . connect (  )  ;  if  (  ! ok )   {  try  {   thread . sleep ( 30 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  return  ! stop &&    util . connected (  )  ;   }  
@ override public  string   (  )  {  return "[protocol "  +  m protocol  +  "]" ;   }  
public void   (  )  {  if  ( metainfo  =  =  null || storage  =  =  null )   {  wanted bytes =  - 1 ;  return ;   }  synchronized  ( wanted pieces )   {  wanted pieces . clear (  )  ;   bit field bitfield = storage . get bit field (  )  ;  int[] pri = storage . get piece priorities (  )  ;  long count = 0 ;  for  ( int i = 0 ;  i  <  metainfo . get pieces (  )  ;  i +  +  )   {  if  (  (  ! bitfield . get ( i )  )  &&  ( pri  =  =  null || pri[i]  >  =  0 )  )   {   piece p = new  piece ( i )  ;  if  ( pri  !  =  null )  p . set priority ( pri[i] )  ;  wanted pieces . add ( p )  ;  count +  = metainfo . get piece length ( i )  ;   }   }  wanted bytes = count ;   collections . shuffle ( wanted pieces    random )  ;   }   }  
@ test public void   (  )  {   subscriber <  string >  w =  test helper . mock subscriber (  )  ;   publish processor <  string >  w1 =  publish processor . create (  )  ;   publish processor <  string >  w2 =  publish processor . create (  )  ;   publish
public muc event delegate   (  )  {  return muc event delegate ;   }  
@ test public void   (  )  {   throwable e = new  bad exception (  )  ;  assert same ( e new  composite exception ( e )  . get cause (  )  . get cause (  )  )  ;  assert same ( e new  composite exception ( new  runtime exception ( e )  )  . get cause (  )
@ test public void   (  )  {   set <  string >  one = new  hash set (  )  ;  one . add ( "abc" )  ;   set <  string >  two = null ;  assert false (  set utilities . null safe equals ( one two )  )  ;   }  
public  string[]   (  )  {   string[] themes = null ;   file dir = new  file (    context . get base dir (  )  "docs / themes / susidns" )  ;   file filter file filter = new  file filter (  )  {  public boolean accept (   file file )  {  return file . is directory (  )  ;   }   }   ;   file[] dirnames = dir . list files ( file filter )  ;  if  ( dirnames  !  =  null )   {  themes = new  string[dirnames . length] ;  for  ( int i = 0 ;  i  <  dirnames . length ;  i +  +  )   {  themes[i] = dirnames[i] . get name (  )  ;   }   }  return themes ;   }  
public  list <  file >    (  )  {   list <  file >  rv = new  array list <  file >  (    torrent files . size (  )  )  ;  for  (   torrent file tf :    torrent files )   {  rv . add ( tf . ra ffile )  ;   }  return rv ;   }  
private static  map <  string  string >    (  string type  document web xml  string type name )  {  final  map <  string  string >  result = new  hash map <  >  (  )  ;  final  list <  element >  elements = web xml . get root element (  )  . elements ( type )  ;  for  (  final  element element : elements )   {  final  string name = element . element text trim ( type  +  " - name" )  ;  if  ( type name . equals ( name )  )   {  final  list <  element >  init param elements = element . elements ( "init - param" )  ;  for  (  final  element init param element : init param elements )   {  final  string p name = init param element . element text trim ( "param - name" )  ;  final  string p value = init param element . element text trim ( "param - value" )  ;  if  ( p name  =  =  null || p name . is empty (  )  )   {   log . warn ( " unable to add init - param that has no name" )  ;   }  else  {  result . put ( p name p value )  ;   }   }   }   }  return result ;   }  
public synchronized void   (  )  {  if  (  ! stop )   {  if  (    log . should log (  log . warn )  )     log . warn ( " already started: "  +     thread name )  ;  return ;   }  stop = false ;  consecutive fails = 0 ;  run started = false ;     fast unannounce = false ;  snark . set tracker problems ( null )  ;     thread = new i2p app thread ( this    thread name  +  " #"  +   (  +  +    run count )  true )  ;     thread . start (  )  ;  started = true ;   }  
@ test public void   (  )  throws io exception  {  final  string tmp dir = io util . get default tmp dir (  )  . get absolute path (  )  ;  final  string[] args = new  string[] { "input =  / dev / stdin" "split   to   n   reads = 5" "output = "  +  tmp di
@ test public void   (  )  {   replay subject <  integer >  async =  replay subject . create (  )  ;  async . on next ( 1 )  ;   subject <  integer >  serial = async . to serialized (  )  ;  assert false ( serial . has observers (  )  )  ;  assert false (
@ override public final void   (  )  {   disposable helper . dispose ( s )  ;   }  
@ override public void   (  )  {  just . on next ( 1 )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  list <  object >  received = new  array list <  object >  (  )  ;   lambda observer <  object >  o = new  lambda observer <  object >  
public   ( long b )  {     longhashcode = b ;   }  
void   (  )  throws  rrd exception  {  if  ( ds defs . size (  )   =  =  0 )   {  throw new  rrd exception ( " no rrd datasource specified .   at least one is needed . " )  ;   }  if  ( arc defs . size (  )   =  =  0 )   {  throw new  rrd exception ( " no rrd archive specified .   at least one is needed . " )  ;   }   }  
@ override public void   (  localmuc room room )  {  localmuc room manager . add room ( room . get name (  )  room )  ;   }  
void   (  inner observer inner )  {  set . delete ( inner )  ;  on complete (  )  ;   }  
public void   (  )  {     executor . set rejected execution handler ( new  thread pool executor .  discard policy (  )  )  ;     executor . shutdown now (  )  ;   }  
private http server list   (  )  {  return get device data (  )  . gethttp server list (  )  ;   }  
@ test @ ignore ( " failed operator may leave the child  observer in an inconsistent state which prevents further error delivery . " )  public void   (  )  {   test observer <  string >  to = new  test observer <  string >  (  )  ;   observable . just ( 1
public  string   (  )  {   node error desc node = getu pnp error description node (  )  ;  if  ( error desc node  =  =  null )  return "" ;  return error desc node . get value (  )  ;   }  
static  < t >  string builder   (  map <  integer  list < t >  >  its )  {   string builder b = new  string builder (  )  ;  for  (   map .  entry <  integer  list < t >  >  e : its . entry set (  )  )   {  if  ( b . length (  )   >  0 )   {  b . append ( "  " )  ;   }  b . append ( e . get key (  )  )  . append ( " =  { " )  ;  b . append ( sequence frequency ( e . get value (  )  )  )  ;  b . append ( " } " )  ;   }  return b ;   }  
private  notification compat .  builder   ( long account id  string ticker  char sequence title  string content text  intent intent  integer number boolean enable audio boolean ongoing )  {   pending intent pending = null ;  if  ( intent  !  =  null )   {  pending =  pending intent . get activity ( m context 0 intent  pending intent . flag   update   current )  ;   }  final  notification compat .  builder builder = new  notification compat .  builder ( m context )  . set content title ( title )  . set content text ( content text )  . set content intent ( pending )  . set number ( number  =  =  null  ?  0 : number )  . set small icon ( r . drawable . ic   notification   mail   24dp )  . set when ( m clock . get time (  )  )  . set ticker ( ticker )  . set ongoing ( ongoing )  ;  if  ( enable audio )   {   account account =  account . restore account with id ( m context account id )  ;  setup sound and vibration ( builder account )  ;   }  return builder ;   }  
@ override public boolean   (  )  {  return true ;   }  
public boolean   (  date date )  {  final boolean local node = has local node written all data before ( date )  ;  if  (  ! local node )   {  return false ;   }  final  collection <  object >  objects =  cache factory . do synchronous cluster task ( new  has written all data task ( date )  false )  ;  for  (  final  object object : objects )   {  if  (  !  (  (  boolean ) object )  )   {  return false ;   }   }  return true ;   }  
@ test public void   (  )  {   flowable . zip (  flowable . just ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )   flowable 
public  profile organizer   (  )  {  return    profile organizer ;   }  
public   (  )  {  super ( " rayo: xep 0327  -  dtmf" )  ;   }  
@ test public void   (  )  {  instance . get next available time (  )  . set time ( 100 )  ;  assert equals ( date instance . get next available time (  )  )  ;   }  
@ override public void   (  )  {  complete +  +  ;  dispose (  )  ;   }  
@ override public void   (  )  {  unsubscription count . increment and get (  )  ;   }  
double   ( int ds index )  throws  rrd exception  {  return  util .  xml . get child value as double ( ds nodes[ds index] "last   ds" )  ;   }  
@ suppress warnings ( "unused" )  @ test public void   (  )  {   observable <  movie >  movie =  observable .  <  movie > just ( new  horror movie (  )  )  ;   observable <  horror movie >  movie2 = movie . compose ( new  observable transformer <  movie  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flat map maybe ( new  function <  integer  maybe source <  string >  >  (  )  {  @ override public  maybe source <  string >  apply (  final  integer integer )  throws  exception  {  if  ( integer  =  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register join row mapper register join row mapper =  (  register join row mapper ) annotation ;  registry . get (  row mappers . class )  . 
@ override protected void   (  )  {  super . on pause (  )  ;  m activity resumed = false ;   }  
private int   ( boolean allow zero hop int expire30s int expire90s int expire150s int expire210s int expire270s int expire later int standard amount int in progress int fallback )  {  int rv = 0 ;  int remaining wanted = standard amount  -  expire later ;  if  ( allow zero hop )  remaining wanted -  = fallback ;  for  ( int i = 0 ;  i  <  expire270s && remaining wanted  >  0 ;  i +  +  )  remaining wanted -  -  ;  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire210s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire150s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire90s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  for  ( int i = 0 ;  i  <  expire30s && remaining wanted  >  0 ;  i +  +  )   {  remaining wanted -  -  ;   }  if  ( remaining wanted  >  0 )   {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv +  = 6 * expire30s ;  rv +  = 6 * remaining wanted ;  rv -  = in progress ;  rv -  = expire later ;   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv +  = 6 * expire30s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv +  = 4 * expire90s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv +  = 2 * expire150s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv +  = expire210s ;  rv -  = in progress ;  rv -  = expire later ;   }   }  else  {  rv =  (  (  ( expire270s  >  0 )  &&    context . random (  )  . next boolean (  )  )   ?  1 : 0 )  ;  rv -  = in progress ;  rv -  = expire later ;   }  if  ( allow zero hop &&  ( rv  >  standard amount )  )  rv = standard amount ;  if  ( rv  +  in progress  +  expire later +  fallback  >  4 * standard amount )  rv = 4 * standard amount  -  in progress  -  expire later  -  fallback ;  long lifetime = get lifetime (  )  ;  if  (  ( lifetime  <  60 * 1000 )  &&  ( rv  +  in progress  +  fallback  >  =  standard amount )  )  rv = standard amount  -  in progress  -  fallback ;  if  ( rv  >  0 &&    log . should log (  log . debug )  )     log . debug ( " count: rv: "  +  rv  +  " allow ?  " +  allow zero hop +  " 30s " +  expire30s +  " 90s " +  expire90s +  " 150s " +  expire150s +  " 210s " +  expire210s +  " 270s " +  expire270s +  " later " +  expire later +  " std " +  standard amount +  " in progress " +  in progress +  " fallback " +  fallback +  " for " +  to string (  )  +  " up for " +  lifetime )  ;  if  ( rv  <  0 )  return 0 ;  return rv ;   }  
@ override protected  string   (  )  {  return custom   amplicon   set   name  !  =  null  ?  custom   amplicon   set   name :  collect targeted metrics . render probe name from file ( amplicon   intervals )  ;   }  
public  config registry   (  )  {  return new  config registry ( this )  ;   }  
@ test public void   (  )  {   maybe . create ( new  maybe on subscribe <  object >  (  )  {  @ override public void subscribe (   maybe emitter <  object >  e )  throws  exception  {   disposable d =  disposables . empty (  )  ;  e . set disposable ( d )
@ override public  config registry   (  )  {  return config ;   }  
synchronized void   (  )  {  locks +  +  ;  locked +  +  ;   }  
public   ( int local port  logging l boolean own dest  event dispatcher notify this i2p tunnel tunnel  string pkf )  {  super ( local port own dest l notify this "socks  proxy on "  +  tunnel . listen host  +  ':' +  local port tunnel pkf )  ;  set name ( "socks  proxy on "  +  tunnel . listen host  +  ':' +  local port )  ;  parse options (  )  ;  notify event ( "opensocks tunnel result" "ok" )  ;   }  
public long   (  )  {  return    expiration ;   }  
public static  string   ( int n  string s  string p i2p app context ctx )  {  return  translate . get string ( n s p ctx bundle   name )  ;   }  
public void   (  connection con )  {  long next send = con . get next send time (  )  ;  long now =    context . clock (  )  . now (  )  ;  long remaining ;  if  ( next send  <  =  0 )   {  remaining = con . get options (  )  . get send ack delay (  )  ;  next send = now  +  remaining ;  con . set next send time ( next send )  ;   }  else  {  remaining = next send  -  now ;   }  if  (    log . should log (  log . debug )  )     log . debug ( " event occurred w /  remaining: "  +  remaining  +  " on " +  con )  ;  if  ( remaining  <  =  0 )   {  if  ( con . get close sent on (  )   <  =  0 )   {  con . send available (  )  ;   }  else  {   }  con . set next send time ( now  +  con . get options (  )  . get send ack delay (  )  )  ;   }  else  {  reschedule ( remaining con )  ;   }   }  
public   ( i2p snark util util  string url )  throws  illegal argument exception  {   string ihash ;   string name ;   string trackerurl = null ;  if  ( url . starts with ( magnet )  )   {   string xt = get param ( "xt" url )  ;  if  ( xt  =  =  null ||  ! xt . starts with ( "urn:btih:" )  )  throw new  illegal argument exception (  )  ;  ihash = xt . substring ( "urn:btih:" . length (  )  )  ;  trackerurl = get tracker param ( url )  ;  name = util . get string ( " magnet" )   +  ' '  +  ihash ;   string dn = get param ( "dn" url )  ;  if  ( dn  !  =  null )  name +  = "  ( "  +  dn  +  ' ) ' ;   }  else if  ( url . starts with ( maggot )  )   {  ihash = url . substring ( maggot . length (  )  )  . trim (  )  ;  int col = ihash . index of ( ':' )  ;  if  ( col  >  =  0 )  ihash = ihash . substring ( 0 col )  ;  name = util . get string ( " magnet" )   +  ' '  +  ihash ;   }  else  {  throw new  illegal argument exception (  )  ;   }  byte[] ih = null ;  if  ( ihash . length (  )   =  =  32 )   {  ih =  base32 . decode ( ihash )  ;   }  else if  ( ihash . length (  )   =  =  40 )   {  ih = new byte[20] ;  try  {  for  ( int i = 0 ;  i  <  20 ;  i +  +  )   {  ih[i] =  ( byte )  (  integer . parse int ( ihash . substring ( i * 2  ( i * 2 )   +  2 )  16 )  & 0xff )  ;   }   }  catch  (   number format exception nfe )   {  ih = null ;   }   }  if  ( ih  =  =  null || ih . length  !  =  20 )  throw new  illegal argument exception (  )  ;     ih = ih ;     name = name ;     tracker = trackerurl ;   }  
public   ( i2p app context ctx  hop config config )  {     processor = new  inbound gateway processor ( ctx config )  ;   }  
  (  observable source < t >  source )  {  this . source = source ;   }  
private static void   (  list <  string >  list  file file )  throws io exception  {  write subscriptions ( list new  buffered writer ( new  output stream writer ( new  secure file output stream ( file )  "utf - 8" )  )  )  ;   }  
public void   ( byte[] xid )  {  id = xid ;   }  
@ test public void   (  )  {   flowable . generate ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  throw new  test exception (  )  ;   }   }   new  bi consumer <  object  emitter <  object >  >  (  )  {  @ 
int   (  )  {  return    inboundk bytes per second ;   }  
public   (  simple timer2 pool long delay long timeout ms )  {  super ( pool delay )  ;  if  ( timeout ms  <  5000 )  throw new  illegal argument exception ( "timeout minimum 5000" )  ;     timeout ms = timeout ms ;   }  
public int   (  )  {  if  ( this . major version  !  =   - 1 )   {  return this . major version ;   }  else  {  return 1 ;   }   }  
@ test public void   (  )  throws  exception  {  check source (  maybe . class . get simple name (  )  true )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publish processor <  integer >  pp0 =  publish processor . create (  )  ;   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   test observer <  object >  to =  ma
public  string   ( long kilobytes )  {  return format ( kilobytes * 1024 )  ;   }  
@ test public void   (  )  {   completable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  completable source >  (  )  {  @ override public  completable
private void   (  )  {  final  string email = m setup data . get email (  )  ;  final  string[] email parts = email . split ( "@" )  ;  final  string domain = email parts[1] ;  final  account account = m setup data . get account (  )  ;  final  email service utils .  email service info info = m setup data . get incoming service info ( this )  ;  final  host auth recv auth = account . get or create host auth recv ( this )  ;  recv auth . set user name ( email )  ;  recv auth . set connection ( m setup data . get incoming protocol (  )  domain  host auth . port   unknown info . offer tls  ?   host auth . flag   tls :  host auth . flag   ssl )  ;   account setup credentials fragment . populate host auth with results ( this recv auth m setup data . get credential results (  )  )  ;  m setup data . set incoming cred loaded ( true )  ;  if  ( info . uses smtp )   {  final  host auth send auth = account . get or create host auth send ( this )  ;  send auth . set user name ( email )  ;  send auth . set connection (  host auth . legacy   scheme   smtp domain  host auth . port   unknown  host auth . flag   tls )  ;   account setup credentials fragment . populate host auth with results ( this send auth m setup data . get credential results (  )  )  ;  m setup data . set outgoing cred loaded ( true )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   spsc linked array queue <  object >  q = new  spsc linked array queue <  object >  ( 16 )  ;  q . offer ( null )  ;   }  
private void   (  jdbi db )  {  db . register array type (  integer . class "int" )  ;  db . register array type (  string . class "varchar" )  ;   }  
public void   (  )  {  int count = 2500 ;  int n = 4 ;   thread[] threads = new  thread[n] ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {  threads[i] = new r tester ( count )  ;   }  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {  threads[i] . start (  )  ;   }  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {  try  {  threads[i] . join (  )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  
@ override public void   (  )  {   multi user chat service impl muc server =  (  multi user chat service impl ) xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( service name )  ;  if  ( muc server  =  = 
  (  rrd graph rrd graph )  {  this . rrd graph = rrd graph ;  if  ( rrd graph . im . xsize  >  0 )   {  this . sec per pix =  ( rrd graph . im . end  -  rrd graph . im . start )   /   double . value of ( rrd graph . im . xsize )  ;   }  this . calendar =  calendar . get instance (  locale . get default (  )  )  ;  this . calendar . set first day of week ( rrd graph . gdef . first day of week )  ;   }  
public  file   (  )  {  return disk . get attachment dir (  )  ;   }  
@ override public  intent   (  )  {  final  intent intent = super . get intent (  )  ;  final long account id =  intent utilities . get account id from intent ( intent )  ;  if  ( account id  <  0 )   {  return intent ;   }   intent mod intent = new  inte
@ override public  enumeration <  string >    (  )  {  return context . get attribute names (  )  ;   }  
@ override public void   ( jid jid  chat state type chat state )  {   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send chat state: i was called ! " )  ;   }  
public void   (  string r )  {  try  {  if  (  integer . parse int ( r )   <  min   refresh )  r = ""  +  min   refresh ;     context . router (  )  . save config ( prop   refresh r )  ;   }  catch  (   runtime exception e )   {   }   }  
@ test public void   (  )  {   test helper . assert bad request reported (  publish processor . create (  )  . buffer ( 1 )  )  ;   test helper . assert bad request reported (  publish processor . create (  )  . buffer ( 1 2 )  )  ;   test helper . assert
@ override public  maybe source <  object >    (  observable <  object >  o )  throws  exception  {  return o . single element (  )  ;   }  
  (  string .  .  .  values )  {  this . values = values ;   }  
public   (  string name  string value )  {  this (  )  ;  set name ( name )  ;  set value ( value )  ;   }  
public  map <  hash  tunnel pool >    (  )  {  return new  hash map <  hash  tunnel pool >  (    client outbound pools )  ;   }  
public static  store   (  account account  context context )  throws  messaging exception  {  return new  imap store ( context account )  ;   }  
public  string   (  )  {   string builder buf = new  string builder ( 128 )  ;  buf . append ( print (  )  )  ;  if  ( levels[0]  !  =  null )   {  buf . append ( '\n' )  ;  buf . append ( levels[0] . print (  )  )  ;   }  return buf . to string (  )  ;   }  
@ override public t   (  )  throws  exception  {  return callable . call (  )  ;   }  
public static  network interface provider   (  )  {  return instance ;   }  
static  interval list   ( final  reference sequence file ref file final int max nmer to merge )  {  final  list <  interval >  preliminary intervals = new  linked list <  >  (  )  ;  final sam file header header = new sam file header (  )  ;  header . set sequence dictionary ( ref file . get sequence dictionary (  )  )  ;  header . set sort order ( sam file header .  sort order . coordinate )  ;  final  interval list final intervals = new  interval list ( header )  ;  for  (  final sam sequence record rec : ref file . get sequence dictionary (  )  . get sequences (  )  )   {  final  reference sequence ref = ref file . get sequence ( rec . get sequence name (  )  )  ;  final byte[] bytes = ref . get bases (  )  ;   string util . to upper case ( bytes )  ;  boolean n block is open =  sequence util . is no call ( bytes[0] )  ;  int start = 0 ;  for  ( int i = 0 ;  i  <  bytes . length ;   +  + i )   {  locus progress . record ( rec . get sequence name (  )  i )  ;  final boolean current base isn =  sequence util . is no call ( bytes[i] )  ;  if  ( n block is open  !  =  current base isn )   {  preliminary intervals . add ( new  interval ( rec . get sequence name (  )  start  +  1 i false n block is open  ?   nmer : acg tmer )  )  ;  start = i ;  n block is open =  ! n block is open ;   }   }  preliminary intervals . add ( new  interval ( rec . get sequence name (  )  start  +  1 bytes . length false n block is open  ?   nmer : acg tmer )  )  ;   }  while  (  ! preliminary intervals . is empty (  )  )   {  if  ( preliminary intervals . size (  )   >  =  3 && preliminary intervals . get ( 0 )  . get name (  )   =  =  acg tmer && preliminary intervals . get ( 1 )  . get name (  )   =  =   nmer && preliminary intervals . get ( 2 )  . get name (  )   =  =  acg tmer && preliminary intervals . get ( 0 )  . abuts ( preliminary intervals . get ( 1 )  )  && preliminary intervals . get ( 1 )  . abuts ( preliminary intervals . get ( 2 )  )  && preliminary intervals . get ( 1 )  . length (  )   <  =  max nmer to merge )   {  final  interval temp = new  interval ( preliminary intervals . get ( 0 )  . get contig (  )  preliminary intervals . get ( 0 )  . get start (  )  preliminary intervals . get ( 2 )  . get end (  )  false acg tmer )  ;  for  ( int i = 0 ;  i  <  3 ;   +  + i )   {  preliminary intervals . remove ( 0 )  ;   }  preliminary intervals . add ( 0 temp )  ;   }  else  {  final  interval remove = preliminary intervals . remove ( 0 )  ;  final intervals . add ( remove )  ;  interval progress . record ( remove . get contig (  )  remove . get start (  )  )  ;   }   }  return final intervals ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  for  ( int i = 0 ;  i  <   flowable . buffer size (  )   -  1 ;  i +  +  )   {  pp . on next ( i  +  2 )  ;   }   }   }  
public void   (  filter key fk )  {  buf . offer ( fk . bit offset )  ;  buf . offer ( fk . word offset )  ;   }  
public   ( int event  string conference id )  {  this . event = event ;  this . conference id = conference id ;   }  
public void   (  hash peer )  {   peer profile data = get profile ( peer )  ;  if  (  ! data . get is expandeddb (  )  )  data . expanddb profile (  )  ;  db history hist = data . getdb history (  )  ;  hist . store failed (  )  ;   }  
public  file   (  )  {  return web root ;   }  
public  string   (  )  {  return get class (  )  . get simple name (  )   +  "@"  +   integer . to hex string ( hash code (  )  )  +  "[name = " +  get factory name (  )  +  " lock mode = " +  m   lock mode +  "]" ;   }  
@ override public  object   (  object a  integer b  integer c  integer d )  throws  exception  {  return a ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final  flowable processor <  integer >  ps =  publish processor .  <  integer > create (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (
@ override public  publisher < b < t >  >    (  flowable < a < t  ?  >  >  a )  {  return  flowable . empty (  )  ;   }  
@ override public void   (  string property  map params )  {  if  ( "provider . group . class name" . equals ( property )  )   {  init provider (  )  ;   }   }  
@ test public void   (  )  {   maybe . just ( 1 )  . to ( new  function <  maybe <  integer >   flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   maybe <  integer >  v )  throws  exception  {  return v . to flowable ( 
void   (  )  {  synchronized  ( this )   {  buffers . clear (  )  ;   }   }  
public  collection <  string >    (  streamid streamid )  {   lock lock =  cache factory . get lock ( streamid validated domains cache )  ;  try  {  lock . lock (  )  ;   set <  string >  validated domains = validated domains cache . get ( streamid )  ;  if  ( validated domains  =  =  null )   {  return  collections . empty list (  )  ;   }  return  collections . unmodifiable collection ( validated domains )  ;   }  finally  {  lock . unlock (  )  ;   }   }  
@ data provider ( name = " " )  public  object[][] test indexed run lane1 data provider (  )  {  return new  object[][] {  { true }   { false }  }  ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . just ( 1 )  ;   test observer <  integer >  to =  test observer . create (  )  ;   observable . concat eager (  observable . just ( source source source )  1 1 )  . subscribe (
public static  set <  object name >    ( final  string query )  throws  malformed object name exception  {  final  object name object name query = new  object name ( query )  ;   set <  object name >  names = new  hash set <  object name >  (  )  ;  final  list < m bean server >  servers = m bean server factory . findm bean server ( null )  ;  for  ( int i = 0 ;  names . size (  )   =  =  0 && i  <  servers . size (  )  ;  i +  +  )   {  names = servers . get ( i )  . query names ( object name query null )  ;   }  if  ( names . size (  )   =  =  0 )   {  names = get platformm bean server (  )  . query names ( object name query null )  ;   }  return names ;   }  
public   (  maybe source < t >  source  function <  ?  super t  ?  extends  maybe source <  ?  extends u >  >  mapper  bi function <  ?  super t  ?  super u  ?  extends r >  result selector )  {  super ( source )  ;  this . mapper = mapper ;  this . result selector = result selector ;   }  
@ test ( expected =  unsupported operation exception . class )  public void   (  )  {  root command line . get command token (  )  ;   }  
public   (  )  {  super ( " personal  eventing 'pubsub#owner'  handler" )  ;  info = new iq handler info ( "pubsub" "http: /  / jabber . org / protocol / pubsub#owner" )  ;   }  
@ test public void   (  )  {   string writer sw = new  string writer (  )  ;   print writer pw = new  print writer ( sw )  ;  new  composite exception ( new  test exception (  )  )  . print stack trace ( pw )  ;  assert true ( sw . to string (  )  . conta
public static void   (  string args[] )  {   string con options = "i2cp . tcp . host = localhost i2cp . tcp . port = 7654 tunnels . inbound depth = 0" ;  if  ( args . length  >  0 )   {  con options = "" ;  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )  con options = con options  +  " "  +  args[i] ;   }  try  {   test util . startup bridge ( 6000 )  ;  run test ( "localhost" 6000 con options )  ;   }  catch  (   throwable t )   {     log . error ( " error running test" t )  ;   }  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   system . exit ( 0 )  ;   }  
public void   (  string data )  {  set content ( data true )  ;   }  
@ suppress warnings ( "unchecked" )  public static  < t >  consumer < t >    (  )  {  return  (  consumer < t >  ) empty   consumer ;   }  
public   (  string username  string name boolean is default  element list element )  {  this . userjid = xmpp server . get instance (  )  . createjid ( username null true )  ;  this . name = name ;  this . is default = is default ;  update list ( list element )  ;   }  
@ override public void   ( t t )  {  if  ( remaining  !  =  0l )   {  remaining -  -  ;   }  else  {  actual . on next ( t )  ;   }   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   observable <  object >  f )  throws  exc
 destination   (  string ip )  {  if  ( ip  =  =  null )  return null ;  if  ( ip . ends with ( " . i2p" )  )   {  if  ( ip . length (  )   <  520 )   {  if  (    manager  !  =  null && ip . length (  )   =  =  base32   hash   length  +  8 && ip . ends with ( " . b32 . i2p" )  )   {  i2p session sess =    manager . get session (  )  ;  if  ( sess  !  =  null )   {  byte[] b =  base32 . decode ( ip . substring ( 0 base32   hash   length )  )  ;  if  ( b  !  =  null )   {   hash h =  hash . create ( b )  ;  if  (    log . should log (  log . info )  )     log . info ( " using existing session for lookup of "  +  ip )  ;  try  {  return sess . lookup dest ( h 15 * 1000 )  ;   }  catch  (  i2p session exception ise )   {   }   }   }   }  if  (    log . should log (  log . info )  )     log . info ( " using naming service for lookup of "  +  ip )  ;  return    context . naming service (  )  . lookup ( ip )  ;   }  if  (    log . should log (  log . info )  )     log . info ( " creating  destination for "  +  ip )  ;  try  {  return new  destination ( ip . substring ( 0 ip . length (  )   -  4 )  )  ;   }  catch  (   data format exception dfe )   {  return null ;   }   }  else  {  if  (    log . should log (  log . info )  )     log . info ( " creating  destination for "  +  ip )  ;  try  {  return new  destination ( ip )  ;   }  catch  (   data format exception dfe )   {  return null ;   }   }   }  
public void   (  writer out  string router prefix  string version  string country  string family  string caps  string ip  string sybil int port  sig type type  string mtu  string ipv6  string ssucaps int cost )  throws io exception  {   string builder buf = new  string builder ( 4 * 1024 )  ;   list <  hash >  sybils = sybil  !  =  null  ?  new  array list <  hash >  ( 128 )  : null ;  if  ( " . " . equals ( router prefix )  )   {  render router info ( buf    context . router (  )  . get router info (  )  true true )  ;   }  else  {  boolean not found = true ;   set <  router info >  routers =    context . net db (  )  . get routers (  )  ;  int ip mode = 0 ;  if  ( ip  !  =  null )   {  if  ( ip . ends with ( " / 24" )  )   {  ip mode = 1 ;   }  else if  ( ip . ends with ( " / 16" )  )   {  ip mode = 2 ;   }  else if  ( ip . ends with ( " / 8" )  )   {  ip mode = 3 ;   }  for  ( int i = 0 ;  i  <  ip mode ;  i +  +  )   {  int last = ip . substring ( 0 ip . length (  )   -  1 )  . last index of ( ' . ' )  ;  if  ( last  >  0 )  ip = ip . substring ( 0 last  +  1 )  ;   }   }  for  (   router info ri : routers )   {   hash key = ri . get identity (  )  . get hash (  )  ;  if  (  ( router prefix  !  =  null && key . to base64 (  )  . starts with ( router prefix )  )  ||  ( version  !  =  null && version . equals ( ri . get version (  )  )  )  ||  ( country  !  =  null && country . equals (    context . comm system (  )  . get country ( key )  )  ) ||  ( family  !  =  null && family . equals ( ri . get option ( "family" )  )  ) ||  ( caps  !  =  null && ri . get capabilities (  )  . contains ( caps )  ) ||  ( type  !  =  null && type  =  =  ri . get identity (  )  . get sig type (  )  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;   }  else if  ( ip  !  =  null )   {  for  (   router address ra : ri . get addresses (  )  )   {  if  ( ip mode  =  =  0 )   {  if  ( ip . equals ( ra . get host (  )  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }  else  {   string host = ra . get host (  )  ;  if  ( host  !  =  null && host . starts with ( ip )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }   }  else if  ( port  !  =  0 )   {  for  (   router address ra : ri . get addresses (  )  )   {  if  ( port  =  =  ra . get port (  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }  else if  ( mtu  !  =  null )   {  for  (   router address ra : ri . get addresses (  )  )   {  if  ( mtu . equals ( ra . get option ( "mtu" )  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }  else if  ( ipv6  !  =  null )   {  for  (   router address ra : ri . get addresses (  )  )   {   string host = ra . get host (  )  ;  if  ( host  !  =  null && host . starts with ( ipv6 )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }  else if  ( ssucaps  !  =  null )   {  for  (   router address ra : ri . get addresses (  )  )   {  if  (  ! "ssu" . equals ( ra . get transport style (  )  )  )  continue ;  if  ( ssucaps . equals ( ra . get option ( "caps" )  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }  else if  ( cost  !  =  0 )   {  for  (   router address ra : ri . get addresses (  )  )   {  if  ( cost  =  =  ra . get cost (  )  )   {  render router info ( buf ri false true )  ;  if  ( sybil  !  =  null )  sybils . add ( key )  ;  not found = false ;  break ;   }   }   }   }  if  ( not found )   {  buf . append ( " < div class = \"netdbnotfound\" > " )  ;  buf . append (    t ( " router" )  )  . append ( ' ' )  ;  if  ( router prefix  !  =  null )  buf . append ( router prefix )  ;  else if  ( version  !  =  null )  buf . append ( version )  ;  else if  ( country  !  =  null )  buf . append ( country )  ;  else if  ( family  !  =  null )  buf . append (    t ( " family" )  )  . append ( ' ' )  . append ( family )  ;  buf . append ( ' ' )  . append (    t ( "not found in network database" )  )  ;  buf . append ( " <  / div > " )  ;   }   }  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;  if  ( sybil  !  =  null )   sybil renderer . render sybilhtml ( out    context sybils sybil )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . take ( 1 null  schedulers . single (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  byte[] temp = null ;   byte array output stream baos = new  byte array output stream (  )  ;   data helper . write string ( baos " hello  i2p" )  ;  temp = baos . to byte array (  )  ;   string s = null ;  
public static  string   (  string base url  string .  .  .  paths )  {   string path = concat uris ( paths )  ;  if  (  string utils . is blank ( path )  )   {  return base url ;   }   string builder url ;  if  ( base url . ends with ( " / " )  )   {  url = new  string builder ( base url . substring ( 0 base url . length (  )   -  1 )  )  ;   }  else  {  url = new  string builder ( base url )  ;   }  return url . append ( path )  . to string (  )  ;   }  
void   (  )  {     in progress . set ( false )  ;     context . simple timer2 (  )  . add event ( new  status cleaner (    last status    last error )  status   clean   time )  ;   }  
public static x509crl   (  input stream in )  throws  general security exception  {   certificate factory cf =  certificate factory . get instance ( "x . 509" )  ;  return  ( x509crl ) cf . generatecrl ( in )  ;   }  
public synchronized void   (  )  {  current page -  -  ;  if  ( current page  <  1 )  current page = 1 ;   }  
@ test public void   (  )  {  final  disposable d1 =  disposables . empty (  )  ;  final  disposable d2 =  disposables . empty (  )  ;   single .  <  integer > create ( new  single on subscribe <  integer >  (  )  {  @ override public void subscribe (   s
public  string   (  )  {  return " iterative search timeout" ;   }  
@ test public void   (  )  throws  exception  {  final  atomic boolean throw exception = new  atomic boolean ( true )  ;  int value =  observable . just ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   inte
@ test public void   (  )  {  final  blocking multi observer <  integer >  bmo = new  blocking multi observer <  integer >  (  )  ;   thread . current thread (  )  . interrupt (  )  ;  try  {  assert true ( bmo . blocking get error (  )  instanceof  inter
private   (  string pattern  time zone time zone  locale locale  date format symbols symbols )  throws  illegal argument exception  {  if  ( locale  =  =  null )   {  locale =  locale . get default (  )  ;   }  m pattern = pattern ;  m time zone = time zone ;  m locale = locale ;  if  ( symbols  =  =  null )   {  symbols = new  date format symbols ( locale )  ;   }   list rules list = parse ( pattern time zone locale symbols )  ;  m rules =  (  rule[] ) rules list . to array ( new  rule[rules list . size (  ) ] )  ;  int len = 0 ;  for  ( int i = m rules . length ;   -  - i  >  =  0 ;   )   {  len +  = m rules[i] . estimate length (  )  ;   }  m max length estimate = len ;   }  
@ override protected  jdbi   (  )  {  return  jdbi . create ( "jdbc:h2:mem:"  +  uuid . randomuuid (  )  )  ;   }  
@ override public void   (  test subscriber <  object >  ts )  throws  exception  {   composite exception ce =  (  composite exception ) ts . errors (  )  . get ( 0 )  ;  assert equals ( 5 ce . get exceptions (  )  . size (  )  )  ;   }  
default  this   (  sql array type factory factory )  {  return configure (  sql array types . class c  -  >  c . register ( factory )  )  ;   }  
public  request queue .  overflow type   (  )  {  return overflow type ;   }  
@ override public void   (  )  {  parent . complete (  )  ;   }  
public  string   (  )  {  return business city ;   }  
public  map <  string  plugin metadata >    (  )  {  return  collections . unmodifiable map ( this . plugin metadata )  ;   }  
private long   (  ping request req )  {  long receive id ;  synchronized  (    recently closed )   {   long rcvid ;  do  {  receive id =    context . random (  )  . next long (  packet . max   stream   id  -  1 )   +  1 ;  rcvid =  long . value of ( receive id )  ;   }  while  (    recently closed . contains key ( rcvid )  ||    connection by inbound id . contains key ( rcvid )  ||    pending pings . put if absent ( rcvid req )   !  =  null )  ;   }  return receive id ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . range ( 1 2 )  . buffer ( 2 1 new  callable <  list <  integer >  >  (  )  {  int calls ;  @ override public  list <  integer >  call (  )  throws  exception  {  if  (  +  + 
public  string   (  )  {  return    component ;   }  
@ override @ suppress warnings ( "unchecked" )  public  map <  string  string >    (  result set r int column number  statement context ctx )  throws sql exception  {  return  (  map <  string  string >  ) r . get object ( column number )  ;   }  
public static  string   (  )  {  return log file name ;   }  
  (  single observer <  ?  super t >  actual t default item )  {  this . actual = actual ;  this . default item = default item ;   }  
public i2p socket options   (  properties opts )  {   connection options cur opts = new  connection options (    default options )  ;  cur opts . set properties ( opts )  ;  return cur opts ;   }  
public  hash   (  )  {  return    destination ;   }  
public  filter action   (  http servlet request wrapper request  http servlet response wrapper response )  {   filter action filter action ;  if  ( request has expected headers ( request )  )   {  if  (  ! record limited request ( request response )  )   {  filter action =  filter action . return ;   }  else if  ( describe limits uri pattern . is present (  )  && describe limits uri pattern . get (  )  . matcher ( request . get requesturi (  )  )  . matches (  )  )   {   optional <  media type >  preferred media type = get preferred media type ( request . get splittable headers (  http headers . accept )  )  ;  if  (  ! preferred media type . is present (  )  )   {  response . set status ( sc   not   acceptable )  ;  filter action =  filter action . return ;   }  else  {  original preferred accept = preferred media type . get (  )  ;  filter action = describe limits for request ( request response )  ;   }   }  else  {  filter action =  filter action . pass ;   }   }  else  {  log . warn ( " expected header:  {  }  was not supplied in the request .   rate limiting requires this header to operate . "  power api header . user )  ;  response . set status ( sc   unauthorized )  ;  filter action =  filter action . return ;   }  return filter action ;   }  
@ override public boolean   (  web view wv  string url )  {  final  string deparameterized url ;  int i = url . last index of ( ' ? ' )  ;  if  ( i  =  =   - 1 )   {  deparameterized url = url ;   }  else  {  deparameterized url = url . substring ( 0 i ) 
public static  string   ( final byte[][] barcodes  string delim )  {  final  string[] bcs = new  string[barcodes . length] ;  for  ( int i = 0 ;  i  <  barcodes . length ;  i +  +  )   {  bcs[i] =  string util . bytes to string ( barcodes[i] )  ;   }  return string seqs to string ( bcs delim )  ;   }  
public void   (  string src name  paint color )  {  plot elements . add ( new  area ( src name color )  )  ;   }  
public int   (  )  {  return    id ;   }  
public h2 database rule   (  )  {  install plugins = true ;  return this ;   }  
private void   (  )  {   set <  forward port >  ports ;  synchronized  ( lock )   {  ports = new  hash set <  forward port >  ( ports forwarded )  ;   }  if  ( ports . is empty (  )  )  return ;  register ports ( ports )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 1000 )  . flat map ( new  function <  integer  flowable <  integer >  >  (
@ override public final void   (  )  {  t value = get (  )  ;  if  ( value  !  =  null )   {  value = get and set ( null )  ;  if  ( value  !  =  null )   {  on disposed ( value )  ;   }   }   }  
public void   (  hash peer )  {     reply gateway = peer ;   }  
public static  conversation event   ( jid roomjid jid user  string new nickname  date date )  {   conversation event event = new  conversation event (  )  ;  event . type =  type . nickname changed ;  event . roomjid = roomjid ;  event . user = user ;  event . nickname = new nickname ;  event . date = date ;  return event ;   }  
@ override protected sam record and reference   ( sam record sam rec final  reference sequence ref seq )  {  return new sam record and reference ( sam rec ref seq )  ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  public static  < k v >  callable <  map < k v >  >    (  )  {  return  (  callable ) instance ;   }  
@ override public boolean   (  )  throws io exception  {  return    out buf . length (  )   >  0 ||    in buf . length (  )   >  0 || in . ready (  )  ;   }  
public void   (  )  {  interceptor manager . remove interceptor ( this )  ;   }  
public   ( final int[] indices )  {  this . indices = indices ;  this . index = 0 ;   }  
public void   ( jid roomjid jid user )  {  if  (  cluster manager . is senior cluster member (  )  )   {  conversation manager . left group conversation ( roomjid user new  date (  )  )  ;  muc room muc room = xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( roomjid )  . get chat room ( roomjid . get node (  )  )  ;  if  ( muc room  !  =  null && muc room . get occupants count (  )   =  =  0 )   {  conversation manager . room conversation ended ( roomjid new  date (  )  )  ;   }   }  else  {   conversation events queue events queue = conversation manager . get conversation events queue (  )  ;  events queue . add group chat event ( conversation manager . get room conversation key ( roomjid )   conversation event . occupant left ( roomjid user new  date (  )  )  )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject .  <  integer > create (  )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer
@ test public void   (  )  {  final  list <  object >  received = new  array list <  object >  (  )  ;   lambda observer <  object >  o = new  lambda observer <  object >  ( new  consumer <  object >  (  )  {  @ override public void accept (   object v ) 
public void   (  )  {  migrating = true ;   }  
@ override public void   (  subscriber <  ?  super  string >  observer )  {  this . observer = observer ;  observer . on subscribe ( new  subscription (  )  {  @ override public void cancel (  )  {   system . out . println ( " =  =  >   synchronize test u
@ test public void   (  )  throws  exception  {  o = new  object (  )  ;   weak reference <  object >  wr = new  weak reference <  object >  ( o )  ;   test subscriber <  object >  ts = new  test subscriber <  object >  ( 0l )  ;   flowable . just ( o )  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . repeat until ( null )  ;   }  
@ override public  string   (  string value )  {  if  ( value  =  =  null )   {  return null ;   }  byte[] bytes = value . get bytes (  standard charsets . utf   8 )  ;  return  base64 . encode bytes ( cipher ( bytes get key (  )   cipher . encrypt   mode
@ test public void   (  )  throws io exception  sax exception  {  mock request . set content ( content remove me )  ;  mock request . add header ( accept "application / other" )  ;  mock response . set content type ( "application / other" )  ;  http servl
public boolean   (  )  {  return  ( content input  !  =  null )   ?  true : false ;   }  
@ override public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  observable <  object >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super
@ before public void   (  )  {  original request = mock (  http servlet request . class )  ;  response = mock (  http servlet response . class )  ;  when ( original request . get scheme (  )  )  . then return ( "http" )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "one" "two" "three" "four" "five" "six" )  ;   observable <  grouped observable <  integer  string >  >  grouped = source . group by ( length )  ;   map <  integer  colle
@ override protected  reference argument collection   (  )  {  return new  reference argument collection (  )  {  @ argument ( short name =  standard option definitions . reference   short   name common = false doc = " the reference sequence  ( fasta )  f
public static  handle   (  )  {   connection fake connection =  mockito . mock (  connection . class )  ;  return new  handle ( new  config registry (  )  new  local transaction handler (  )  new  default statement builder (  )  fake connection )  ;   }  
@ test public void   (  )  {   observable <  horror movie >  horrors =  observable . just ( new  horror movie (  )  )  ;   observable <  cool rating >  ratings =  observable . just ( new  cool rating (  )  )  ;   observable .  <  movie  cool rating  resul
@ override public  parsed sql   (  string sql  statement context ctx )  {  try  {  return cache . compute if absent ( sql this::internal parse )  ;   }  catch  (   illegal argument exception e )   {  throw new  unable to create statement exception ( " exc
public  handle   (  )  {  return get jdbi (  )  . open (  )  ;   }  
void   (  http session session )  {  this . session = session ;   }  
public long   (  )  {  return    last rejected transient ;   }  
@ test public void   (  )  {   single . zip (  single . just ( 1 )   single . just ( 2 )   single . just ( 3 )   single . just ( 4 )   single . just ( 5 )   single . just ( 6 )  new  function6 <  integer  integer  integer  integer  integer  integer  objec
@ test public void   (  )  {   async processor <  object >  as =  async processor . create (  )  ;  assert false ( as . has value (  )  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . get
@ override public  string   (  )  throws  unknown host exception  {  if  ( host address  !  =  null )   {  return host address ;   }   connection multiplexer session multiplexer session = multiplexer manager . get multiplexer session ( connection manager 
@ override public  connection configuration   (  )  {  if  ( configuration  =  =  null )   {  final  connection manager impl connection manager =  (  (  connection manager impl ) xmpp server . get instance (  )  . get connection manager (  )  )  ;  config
@ override public void   (  long t )  {  count . increment and get (  )  ;  request (  long . max   value  -  1 )  ;   }  
void   (  request req )  {  synchronized  ( send queue )   {   iterator <  message >  it = send queue . iterator (  )  ;  while  ( it . has next (  )  )   {   message m = it . next (  )  ;  if  ( m . type  =  =   message . request && m . piece  =  =  req . get piece (  )  && m . begin  =  =  req . off && m . length  =  =  req . len )   {  if  (    log . should log (  log . debug )  )     log . debug ( " discarding duplicate request "  +  req  +  " to peer " +  peer )  ;  return ;   }   }   }   message m = new  message (  message . request req . get piece (  )  req . off req . len )  ;  add message ( m )  ;  req . send time =  system . current time millis (  )  ;   }  
public static  admin manager   (  )  {  return  admin manager container . instance ;   }  
  ( final  string .  .  .  strings )  {  accepted types = new  hash set <  >  (  )  ;   collections . add all ( accepted types strings )  ;   }  
@ test ( data provider = "p loh" )  public void   ( final double p loh )  {  final  fingerprint fp observed = new  fingerprint ( "test" null "noop" )  ;  final  fingerprint fp expected = new  fingerprint ( "test" null "noop" )  ;  final  haplotype probabi
public void   (  entry event event )  {  handle entry event ( event false )  ;   }  
@ override public  maybe <  integer >    (  )  throws  exception  {  return  maybe . just ( 1 )  ;   }  
@ test public void   (  )  {   maybe <  integer >  m =  maybe . just ( 1 )  ;  assert same ( m  (  (  (  has upstream maybe source <  ?  >  ) m . is empty (  )  )  . source (  )  )  )  ;   }  
@ override public boolean   (  )  {  return get (  )   =  =  null ;   }  
@ override public boolean   (  )  {  return can occupants invite ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;   flowable . concat delay error (  arrays . as list (  flowable . just ( 1 )   flowable . just ( 2 )  )  )  . subscrib
@ override public void   (  string column label  input stream x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public  string   (  )  {  return get service node (  )  . get node value ( event   sub   url )  ;   }  
private byte   (  string dtmf key to send )  {  byte dtmf key =  ( byte )  - 1 ;  try  {  dtmf key =  ( byte )  integer . parse int ( dtmf key to send )  ;   }  catch  (   number format exception e )   {   }  if  ( dtmf key  >  =  0 && dtmf key  <  =  9 )   {  return dtmf key ;   }  if  ( dtmf key to send . equals ( "*" )  )   {  return 10 ;   }  if  ( dtmf key to send . equals ( "#" )  )   {  return 11 ;   }  if  ( dtmf key  >  =  12 && dtmf key  <  =  15 )   {  return dtmf key ;   }  return 15 ;   }  
@ override public  single source <  object >    (  single <  object >  s )  throws  exception  {  return s . do on dispose (  functions . empty   action )  ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )  throws  exception  {  return 1  /  v ;   }   }    parallel failure handling 
@ data provider ( name = " " )  public  iterator <  object[] >  indel flip data (  )  {  final  allele  refcaa =  allele . create ( "caa" true )  ;  final  allele  refgtt =  allele . create ( "gtt" true )  ;  final  allele  refacgt =  allele . create ( "a
public void   ( boolean allow to discover members only rooms )  {  this . allow to discover members only rooms = allow to discover members only rooms ;  muc persistence manager . set property ( chat service name "discover . members only"  boolean . to string ( allow to discover members only rooms )  )  ;   }  
@ override public int   (  )  {  return registrationi ds . size (  )  ;   }  
public void   (  )  {     reused = true ;   }  
@ benchmark public  object   (  blackhole bh )  {  return observable plain . subscribe with ( new  perf consumer ( bh )  )  ;   }  
  (  single observer <  ?  super t >  s  composite disposable set )  {  this . s = s ;  this . set = set ;   }  
@ override public  observable <  ?  >    (  completable c )  throws  exception  {  return c . to observable (  )  ;   }  
public void   (  string exception )  {  this . exception = exception ;   }  
@ override protected void   (  session data data  element command )  {   data form form = new  data form (  data form .  type . form )  ;  form . set title ( " dispatching a v card deleting event . " )  ;  form . add instruction ( " fill out this form to 
@ test public void   (  )  {   observable <  integer >  source =  observable . just ( 1 )  ;   test observer <  integer >  to =  test observer . create (  )  ;   observable . concat eager (  observable . just ( source source source )  )  . subscribe ( to 
public void   (  string resource )  {  this . resource = resource ;   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer (  )  ;  final  maybe <  object >  maybe =  maybe . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  atomic integer . increment and get (  )
@ test public void   (  )  {   single . just ( 1 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (  final  integer integer )  throws  exception  {  if  ( integer  =
public   (  )  {  new  drop target ( this this )  ;  drag source . create default drag gesture recognizer ( this  dnd constants . action   copy   or   move this )  ;   }  
public byte[]   (  )  {  if  ( sha   digest  =  =  null )  return null ;  byte[] result = sha   digest . digest (  )  ;  return result ;   }  
@ test public void   (  )  {   subscriber <  string >  w =  test helper . mock subscriber (  )  ;   publish processor <  string >  w1 =  publish processor . create (  )  ;   publish processor <  string >  w2 =  publish processor . create (  )  ;   flowabl
@ override public void   (  filter config config )  throws  servlet exception  {  assert config  !  =  null ;  context = new  compressing filter context ( config )  ;  logger = context . get logger (  )  ;  logger . log ( " compressing filter has initiali
@ non null @ override public  disposable   ( @ non null  runnable action long delay time @ non null  time unit unit )  {  return w . schedule ( action delay time unit )  ;   }  
@ override protected  scheduler   (  )  {  return  schedulers . trampoline (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  boundary =  publish subject . create (  )  ;   observer <  object >  o =  test helper . mock observer (  )  ;   in orde
public void   (  )  {   session key session key =  key generator . get instance (  )  . generate session key (  )  ;   hash h = sha256 generator . get instance (  )  . calculate hash ( session key . get data (  )  )  ;  byte iv[] = new byte[16] ;   system . arraycopy ( h . get data (  )  0 iv 0 16 )  ;   string msg = " hello world" ;  byte encrypted[] =    context . el gamalaes engine (  )  . encryptaes block (  data helper . getascii ( msg )  session key iv null null 64 )  ;   set <  session tag >  found tags = new  hash set <  session tag >  (  )  ;   session key found key = new  session key (  )  ;  byte decrypted[] = null ;  try  {  decrypted =    context . el gamalaes engine (  )  . decryptaes block ( encrypted 0 encrypted . length session key iv null found tags found key )  ;   }  catch  (   data format exception dfe )   {  dfe . print stack trace (  )  ;  fail (  )  ;   }  assert not null ( decrypted )  ;   string read = new  string ( decrypted )  ;  assert equals ( msg read )  ;   }  
public url   (  string name )  {  url resource = hazelcast classloader . get resource ( name )  ;  if  ( resource  =  =  null )   {   plugin manager plugin manager = xmpp server . get instance (  )  . get plugin manager (  )  ;  for  (   plugin plugin : plugin manager . get plugins (  )  )   {   string plugin name = plugin manager . get plugin directory ( plugin )  . get name (  )  ;  if  ( "hazelcast" . equals ( plugin name )  || "admin" . equals ( plugin name )  )   {  continue ;   }   plugin class loader plugin classloader = plugin manager . get plugin classloader ( plugin )  ;  resource = plugin classloader . get resource ( name )  ;  if  ( resource  !  =  null )   {  return resource ;   }   }   }  return resource ;   }  
public void   (  data input stream din )  throws io exception  {  piece . read ( din off len )  ;   }  
public static void   (  string args[] )  {  if  ( args . length  !  =  1 )   {   system . err . println ( " usage:  fix win paths [wrapper . conf]\r\n" )  ;   system . exit ( 1 )  ;   }  if  (  !  system . get property ( "os . name" )  . starts with ( " win" )  )   {  return ;   }  replace ( args[0] )  ;   }  
@ override public void   (  observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 0 )  ;  observer . on next ( 1 )  ;  observer . on error ( e )  ;   }  
public static  < t r > void   (  function <  flowable < t >   ?  extends  publisher < r >  >  transform )  {   list <  throwable >  errors = track plugin errors (  )  ;  try  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   flowable < t >  source = new  flowable < t >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super t >  subscriber )  {  try  {   boolean subscription d1 = new  boolean subscription (  )  ;  subscriber . on subscribe ( d1 )  ;   boolean subscription d2 = new  boolean subscription (  )  ;  subscriber . on subscribe ( d2 )  ;  b[0] = d1 . is cancelled (  )  ;  b[1] = d2 . is cancelled (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }   }   ;   publisher < r >  out = transform . apply ( source )  ;  out . subscribe (  no op consumer . instance )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " first disposed ? " false b[0] )  ;  assert equals ( " second not disposed ? " true b[1] )  ;  assert error ( errors 0  illegal state exception . class " subscription already set ! " )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  finally  {   rx java plugins . reset (  )  ;   }   }  
private  peer profile   (  hash peer )  {   peer profile prof =    context . profile organizer (  )  . get profile ( peer )  ;  if  ( prof  =  =  null )   {  prof = new  peer profile (    context peer )  ;     context . profile organizer (  )  . add profile ( prof )  ;   }  return prof ;   }  
public static  list <  weighted host address >    (  weighted host address[] records )  {  final  list <  weighted host address >  result = new  linked list <  >  (  )  ;   sorted map <  integer  set <  weighted host address >  >  by priority = new  tree map <  >  (  )  ;  for  (  final  weighted host address record : records )   {  if  ( by priority . contains key ( record . get priority (  )  )  )   {  by priority . get ( record . get priority (  )  )  . add ( record )  ;   }  else  {  final  set <  weighted host address >  set = new  hash set <  >  (  )  ;  set . add ( record )  ;  by priority . put ( record . get priority (  )  set )  ;   }   }  for  (   map .  entry <  integer  set <  weighted host address >  >  weights : by priority . entry set (  )  )   {   list <  weighted host address >  zero weights = new  linked list <  >  (  )  ;  int total weight = 0 ;  final  iterator <  weighted host address >  i = weights . get value (  )  . iterator (  )  ;  while  ( i . has next (  )  )   {  final  weighted host address next = i . next (  )  ;  if  ( next . weight  =  =  0 )   {  zero weights . add ( next )  ;  i . remove (  )  ;  continue ;   }  total weight +  = next . get weight (  )  ;   }  int iteration weight = total weight ;   iterator <  weighted host address >  iter = weights . get value (  )  . iterator (  )  ;  while  ( iter . has next (  )  )   {  int needle = new  random (  )  . next int ( iteration weight )  ;  while  ( true )   {  final  weighted host address record = iter . next (  )  ;  needle -  = record . get weight (  )  ;  if  ( needle  <  =  0 )   {  result . add ( record )  ;  iter . remove (  )  ;  iteration weight -  = record . get weight (  )  ;  break ;   }   }  iter = weights . get value (  )  . iterator (  )  ;   }   collections . shuffle ( zero weights )  ;  for  (   weighted host address zero : zero weights )   {  result . add ( zero )  ;   }   }  return result ;   }  
public static  trampoline scheduler   (  )  {  return instance ;   }  
@ override public boolean   (  )  {  return true ;   }  
private static  map <  string  string >    (  string prefix )  {   map <  string  string >  m = new  hash map <  string  string >  (  )  ;  m . put ( "first name" prefix  +  " first" )  ;  m . put ( "last name" prefix  +  " last" )  ;  return m ;   }  
private void   (  )  {   analyzer analyzer = null ;   string analyzer class = null ;   string words = null ;  analyzer class = workgroup . get properties (  )  . get property ( "search . analyzer . class name" )  ;  if  ( analyzer class  !  =  null )   {  words = workgroup . get properties (  )  . get property ( "search . analyzer . stop word list" )  ;   }  else  {  analyzer class = get analyzer class (  )  ;  words =  jive globals . get property ( "workgroup . search . analyzer . stop word list" )  ;   }   list <  string >  stop words = new  array list <  string >  (  )  ;  if  ( words  !  =  null )   {   string tokenizer st = new  string tokenizer ( words " " )  ;  while  ( st . has more tokens (  )  )   {  stop words . add ( st . next token (  )  . trim (  )  )  ;   }   }  try  {  analyzer = get analyzer instance ( analyzer class stop words )  ;   }  catch  (   exception e )   {   log . error ( " error loading custom "  +  "search analyzer: "  +  analyzer class e )  ;   }  if  ( analyzer  =  =  null && stop words . size (  )   >  0 )   {  analyzer = new  standard analyzer ( stop words . to array ( new  string[stop words . size (  ) ] )  )  ;   }  else if  ( analyzer  =  =  null )   {  analyzer = new  standard analyzer (  )  ;   }  indexer analyzer = analyzer ;   }  
public void   ( byte payload[] int payload index byte out[] int out index  session key session key byte iv[] int iv offset int length )  {   system . arraycopy ( payload payload index out out index length )  ;     log . log always (  log . warn "aes is disabled" )  ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 )  . first ( 2 )  . to observable (  )  ;   observer <  integer >  observer =  test helper . mock observer (  )  ;  o . subscribe ( observer )  ;   in order in order = in o
public int   (  )  {  synchronized  (    tunnels )   {  return    tunnels . size (  )  ;   }   }  
public   ( int crash on iterator int crash on has next int crash on next  function <  integer t >  mapper )  {  this . crash on iterator = crash on iterator ;  this . crash on has next = crash on has next ;  this . crash on next = crash on next ;  this . mapper = mapper ;   }  
private static boolean   (  file src  file target dir )  {  if  (  ! src . exists (  )  )  return true ;  if  (  ! target dir . exists (  )  )   {  if  (  ! target dir . mkdir (  )  )   {   system . err . println ( "failed copy "  +  src . get path (  )  )  ;  return false ;   }   system . err . println ( " created "  +  target dir . get path (  )  )  ;   }   file target file = new  secure directory ( target dir src . get name (  )  )  ;  if  (  ! src . is directory (  )  )  return copy file ( src target file )  ;   file children[] = src . list files (  )  ;  if  ( children  =  =  null )   {   system . err . println ( "failed copy "  +  src . get path (  )  )  ;  return false ;   }  if  (  ! target file . exists (  )  )   {  if  (  ! target file . mkdir (  )  )   {   system . err . println ( "failed copy "  +  src . get path (  )  )  ;  return false ;   }   system . err . println ( " created "  +  target file . get path (  )  )  ;   }  boolean rv = true ;  for  ( int i = 0 ;  i  <  children . length ;  i +  +  )   {  rv& = copy ( children[i] target file )  ;   }  return rv ;   }  
public void   (  properties props )  {     last agreed to = get long ( props "tunnels . last agreed to" )  ;     last failed = get long ( props "tunnels . last failed" )  ;     last rejected critical = get long ( props "tunnels . last rejected critical" )  ;     last rejected bandwidth = get long ( props "tunnels . last rejected bandwidth" )  ;     last rejected transient = get long ( props "tunnels . last rejected transient" )  ;     last rejected probabalistic = get long ( props "tunnels . last rejected probabalistic" )  ;     lifetime agreed to . set ( get long ( props "tunnels . lifetime agreed to" )  )  ;     lifetime failed . set ( get long ( props "tunnels . lifetime failed" )  )  ;     lifetime rejected . set ( get long ( props "tunnels . lifetime rejected" )  )  ;  try  {     reject rate . load ( props "tunnel history . reject rate" true )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " loading tunnel history . reject rate" )  ;     fail rate . load ( props "tunnel history . fail rate" true )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " loading tunnel history . fail rate" )  ;   }  catch  (   illegal argument exception iae )   {     log . warn ( " tunnel history rates are corrupt  resetting" iae )  ;  create rates (    stat group )  ;   }   }  
private  string   (  string s  string key )  {  int ix ;  if  (  ( ix = s . index of ( key )  )   <  0 )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " missing "  +  key  +  ": " +  s )  ;   }  return null ;   }  if  ( ix  >  0 )   {  info = s . substring ( 0 ix )  ;   }  if  (  ( ix = s . index of ( "'" )  )   <  0 )   {   logger . println ( " missing quote: "  +  s )  ;  return null ;   }  s = s . substring ( ix  +  1 )  ;  if  (  ( ix = s . index of ( "'" )  )   <  0 )   {   logger . println ( " missing quote: "  +  s )  ;  return null ;   }  return s . substring ( 0 ix )  ;   }  
public  rpid   (  )  {  return this . rpid ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp1 =  publish processor . create (  )  ;  final  publish processor <  integer >  pp2 =  publish process
public synchronized void   (  )  {  if  (    initialized )  throw new  illegal state exception (  )  ;  if  (  ! get boolean property ( "i2p . dummy client facade" )  )   {   client manager facade impl cmfi = new  client manager facade impl ( this )  ;     client manager facade = cmfi ;     internal client manager = cmfi ;   }  else  {     client manager facade = new  dummy client manager facade ( this )  ;   }     garlic message parser = new  garlic message parser ( this )  ;     client message pool = new  client message pool ( this )  ;     job queue = new  job queue ( this )  ;     job queue . startup (  )  ;     in net message pool = new  in net message pool ( this )  ;     out net message pool = new  out net message pool ( this )  ;     message history = new  message history ( this )  ;     message registry = new  outbound message registry ( this )  ;     routing key generator = new  router key generator ( this )  ;  if  (  ! get boolean property ( "i2p . dummy net db" )  )     net db = new  floodfill network database facade ( this )  ;  else    net db = new  dummy network database facade ( this )  ;     key manager = new  key manager ( this )  ;  if  (  ! get boolean property ( "i2p . vm comm system" )  )     comm system = new  comm system facade impl ( this )  ;  else    comm system = new vm comm system ( this )  ;     profile organizer = new  profile organizer ( this )  ;  if  (  ! get boolean property ( "i2p . dummy peer manager" )  )     peer manager facade = new  peer manager facade impl ( this )  ;  else    peer manager facade = new  dummy peer manager facade (  )  ;     profile manager = new  profile manager impl ( this )  ;     bandwidth limiter = new fifo bandwidth limiter ( this )  ;  if  (  ! get boolean property ( "i2p . dummy tunnel manager" )  )     tunnel manager = new  tunnel pool manager ( this )  ;  else    tunnel manager = new  dummy tunnel manager facade (  )  ;     tunnel dispatcher = new  tunnel dispatcher ( this )  ;     stat publisher = new  statistics manager ( this )  ;     banlist = new  banlist ( this )  ;     blocklist = new  blocklist ( this )  ;     message validator = new  message validator ( this )  ;     throttle = new  router throttle impl ( this )  ;     app manager = new  router app manager ( this )  ;     initialized = true ;   }  
public   (  )  {   jive globals . migrate property tree ( "property based user mapper" )  ;  fallback provider =  user multi provider . instantiate ( "property based user mapper . fallback provider . class name" )  ;  if  ( fallback provider  =  =  null )   {  throw new  illegal state exception ( " expected a  user provider class name in property 'property based user mapper . fallback provider . class name'" )  ;   }  final  list <  string >  set properties =  jive globals . get property names ( "property based user mapper . set" )  ;  for  (  final  string set property : set properties )   {  final  user provider provider =  user multi provider . instantiate ( set property  +  " . provider . class name" )  ;  if  ( provider  =  =  null )   {  throw new  illegal state exception ( " expected a  user provider class name in property '"  +  set property  +  " . provider . class name'" )  ;   }  providers by prefix . put ( set property provider )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on request ( null )  ;   }  
void   (  date now date )  {  for  (   map .  entry <  string  user participations >  entry : participants . entry set (  )  )   {   conversation participation current participation = entry . get value (  )  . get recent participation (  )  ;  if  ( current participation . get left (  )   =  =  null )   {  current participation . participation ended ( now date )  ;  conversation manager . queue participant left ( this new jid ( entry . get key (  )  )  current participation )  ;   }   }   }  
@ override public boolean   (  )  {  return this . left iterator . has next (  )  || this . right iterator . has next (  )  ;   }  
public   (  publisher <  ?  extends t >  source )  {  this . source = source ;   }  
@ override public  saved state[]   ( int size )  {  return new  saved state[size] ;   }  
public  collection   (  )  {  return map . values (  )  ;   }  
public synchronized void   (  output stream out )  throws io exception  {   limit input stream lin = null ;  try  {  lin = get raw input stream ( 0 )  ;   data helper . copy ( lin out )  ;   }  catch  (  io exception ioe )   {  if  (    log . should debug (  )  )     log . debug ( " decode ioe" ioe )  ;  throw ioe ;   }  finally  {  if  ( lin  !  =  null )  try  {  lin . close (  )  ;   }  catch  (  io exception ioe )   {   }   ;  buffer . read complete ( true )  ;   }   }  
@ override public  list <  string >    ( final  list <  integer >  expected tiles final int[] expected cycles final  illumina file util .  supported illumina format format )  {  final  list <  string >  failures = new  linked list <  string >  (  )  ;  if
@ override public void   (  )  {  configuration service . unsubscribe from ( http   conn   pool   config   name this )  ;  actor system . shutdown (  )  ;   }  
public  string   (  )  {  return sample ;   }  
  (  atomic reference <  disposable >  parent  maybe observer <  ?  super t >  actual )  {  this . parent = parent ;  this . actual = actual ;   }  
@ override public int   (  )  {  return    alias of . size (  )  ;   }  
void   ( double[] x double[] y bottom double[] y top  paint paint )  {  gd . set paint ( paint )  ;   path iterator path = new  path iterator ( y top )  ;  for  ( int[] pos = path . get next path (  )  ;  pos  !  =  null ;  pos = path . get next path (  )  )   {  int start = pos[0]  end = pos[1]  n = end  -  start ;  int[] x dev = new int[n * 2]  y dev = new int[n * 2] ;  for  ( int i = start ;  i  <  end ;  i +  +  )   {  int ix1 = i  -  start  ix2 = n * 2  -  1  -  i  +  start ;  x dev[ix1] = x dev[ix2] =  ( int ) x[i] ;  y dev[ix1] =  ( int ) y top[i] ;  y dev[ix2] =  ( int ) y bottom[i] ;   }  gd . fill polygon ( x dev y dev x dev . length )  ;  gd . draw polygon ( x dev y dev x dev . length )  ;   }   }  
public void   (  peer peer int size )  {  uploaded . add and get ( size )  ;   }  
public   (  string[] white list )  {  this . white list =  arrays . copy of ( white list white list . length )  ;   }  
public int   (  )  {  return get integer value ( http   max   connections 20 )  ;   }  
public void   (  boolean log )  {  this . log = log ;   }  
@ override public void   ( t t )  {  if  (  ! get (  )  )   {  actual . on next ( t )  ;   }   }  
public   (  char sequence source )  {  if  ( source  !  =  null )   {   matcher matcher = pattern . matcher ( source )  ;  if  ( matcher . matches (  )  )   {  major =  integer . parse int ( matcher . group ( 1 )  )  ;  minor =  integer . parse int ( matcher . group ( 2 )  )  ;   }  else  {  this . major = this . minor = 0 ;   }   }  else  {  this . major = this . minor = 0 ;   }   }  
public void   (  destination peer )  {  if  ( peer  =  =  null )  throw new  null pointer exception (  )  ;  synchronized  ( this )   {  if  (    remote peer  !  =  null )  throw new  runtime exception ( " remote peer already set ["  +     remote peer  +  "  " +  peer +  "]" )  ;     remote peer = peer ;   }     connection manager . update opts from share ( this )  ;   }  
public static byte[]   ( byte[] data )  {  try  {   message digest md =  message digest . get instance ( "md5" )  ;  md . update ( data )  ;  return md . digest (  )  ;   }  catch  (   no such algorithm exception nsae )   {   }  return null ;   }  
@ test ( timeout = 1000 )  public void   (  )  throws  interrupted exception  {  final  atomic boolean unsubscribed = new  atomic boolean (  )  ;  final  count down latch latch = new  count down latch ( 1 )  ;   observable <  observable <  long >  >  sour
public static  string   (  )  {  return  management factory . get runtimemx bean (  )  . get name (  )  . split ( "@" ) [0] ;   }  
public void   (  plugin manager manager  file plugin directory )  {  secret =  jive globals . get property ( "plugin . restapi . secret" "" )  ;  if  ( "" . equals ( secret )  )   {  secret =  string utils . random string ( 16 )  ;  set secret ( secret )  ;   }  custom auth filter class name =  jive globals . get property ( "plugin . restapi . custom auth filter" "" )  ;  enabled =  jive globals . get boolean property ( "plugin . restapi . enabled" false )  ;  http auth =  jive globals . get property ( "plugin . restapi . http auth" "basic" )  ;  allowedi ps =  string utils . string to collection (  jive globals . get property ( "plugin . restapi . allowedi ps" "" )  )  ;   property event dispatcher . add listener ( this )  ;   }  
public void   (  list <  string >  groups )  {  this . groups = groups ;   }  
private static  collection <  remote server configuration >    (  permission permission )  {   collection <  remote server configuration >  answer = new  array list <  >  (  )  ;  java . sql .  connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   configurations )  ;  pstmt . set string ( 1 permission . to string (  )  )  ;  rs = pstmt . execute query (  )  ;   remote server configuration configuration ;  while  ( rs . next (  )  )   {  configuration = new  remote server configuration ( rs . get string ( 1 )  )  ;  configuration . set remote port ( rs . get int ( 2 )  )  ;  configuration . set permission ( permission )  ;  answer . add ( configuration )  ;   }   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return answer ;   }  
public  map .  entry <  string  host txt entry >    (  )  {  if  (  ! has next (  )  )  throw new  no such element exception (  )  ;   map .  entry <  string  host txt entry >  rv = next ;  next = null ;  return rv ;   }  
public  media type   ( byte[] readable contents  media type media type  output stream output stream )  throws io exception  {  if  (  media type . application   xml   value . equals ignore case ( media type . to string (  )  )  )   {  output stream . write ( readable contents )  ;  return  media type . application   xml ;   }  else  {  response transformer . stream as json ( new  byte array input stream ( readable contents )  output stream )  ;  return  media type . application   json ;   }   }  
private static  string   (  string s int length )  {   string builder b = new  string builder ( s )  ;  for  ( int i = 0 ;  i  <  length  -  s . length (  )  ;  i +  +  )   {  b . append ( ' ' )  ;   }  return b . to string (  )  ;   }  
@ test public void   (  )  {  new  ed25519 field element (  math utils . get field (  )  new int[10] )  ;   }  
@ test public void   (  )  {   test helper . check utility class (  end consumer helper . class )  ;   }  
private   ( int version number int[] alignment pattern centers ec blocks .  .  .  ec blocks )  {  this . version number = version number ;  this . alignment pattern centers = alignment pattern centers ;  this . ec blocks = ec blocks ;  int total = 0 ;  int ec codewords = ec blocks[0] . getec codewords per block (  )  ;  ecb[] ecb array = ec blocks[0] . getec blocks (  )  ;  for  (  ecb ec block : ecb array )   {  total +  = ec block . get count (  )  *  ( ec block . get data codewords (  )   +  ec codewords )  ;   }  this . total codewords = total ;   }  
private static void   (  mock transport transport int msg num boolean body )  {  setup single message top ( transport msg num false false )  ;   }  
@ test public void   (  )  {  final  blocking multi observer <  integer >  bmo = new  blocking multi observer <  integer >  (  )  ;   schedulers . single (  )  . schedule direct ( new  runnable (  )  {  @ override public void run (  )  {  bmo . on error (
public static void   (  string subdomain  string name )  {  muc service properties properties = property maps . get ( subdomain )  ;  if  ( properties  =  =  null )   {  properties = new muc service properties ( subdomain )  ;   }  properties . remove ( name )  ;  property maps . put ( subdomain properties )  ;   }  
public int   (  )  {  return delivery port ;   }  
@ test public void   (  )  {   publish subject <  integer >  subject =  publish subject . create (  )  ;  final  atomic integer count = new  atomic integer ( 0 )  ;   disposable sub = subject . retry ( retry twice )  . subscribe ( new  consumer <  integer
@ override public void   (  )  {  if  ( compare and set ( false true )  )   {  scheduler . schedule direct ( new  dispose task (  )  )  ;   }   }  
public void   (  treatment manager treatment manager )  throws  parse exception  {  if  ( get state (  )   !  =   call state . invited )   {   logger . println ( " call "  +  cp  +  ": ns outgoing call agent: bad state " +  get state (  )  )  ;  return ;   }   media info media info = mixer media preference ;  if  ( treatment manager  !  =  null )   {  int sample rate = treatment manager . get sample rate (  )  ;  int channels = treatment manager . get channels (  )  ;  try  {  media info =  media info . find media info (  rtp packet . pcm   encoding sample rate channels )  ;   }  catch  (  io exception e )   {   logger . println ( " using conference media preference "  +  media info  +  ": " +  e . get message (  )  )  ;   }   }   inet socket address isa = call handler . get member (  )  . get member receiver (  )  . get receive address (  )  ;   logger . println ( " call "  +  cp  +  ": ns outgoing call agent: " +  media info +  " remote " +  isa )  ;  set endpoint address ( isa media info . get payload (  )  media info . get payload (  )   ( byte ) 0 )  ;  if  ( call answered )   {   logger . write file ( " call "  +  cp  +  ": ns outgoing call agent: done remote sdp" )  ;  return ;   }  call answered = true ;  if  ( cp . get join confirmation timeout (  )   =  =  0 )   {  set state (  call state . answered )  ;   }  initialize call answered treatment (  )  ;  if  ( call answered treatment  !  =  null )   {  start call answered treatment (  )  ;   }  else  {  if  ( cp . get join confirmation timeout (  )   =  =  0 )   {  set state (  call state . established )  ;   }   }   }  
private static void   (  string s  throwable t )  {  if  ( debug )   {   system . out . println ( "ec constants: "  +  s )  ;  if  ( t  !  =  null )  t . print stack trace (  )  ;   }   }  
private static  collection <  string >    (  string group names )  {   collection <  string >  answer = new  hash set <  string >  (  )  ;  if  ( group names  !  =  null )   {   string tokenizer tokenizer = new  string tokenizer ( group names " " )  ;  while  ( tokenizer . has more tokens (  )  )   {  answer . add ( tokenizer . next token (  )  )  ;   }   }  return answer ;   }  
@ test public void   (  )  {  final  disposable d =  disposables . empty (  )  ;   observable .  <  integer > create ( new  observable on subscribe <  integer >  (  )  {  @ override public void subscribe (   observable emitter <  integer >  e )  throws  e
@ deprecated public void   ( long when )  {     key established time = when ;   }  
@ test public void   (  )  {   subscriber <  integer >  consumer = new  disposable subscriber <  integer >  (  )  {  @ override public void on next (   integer t )  {   }  @ override public void on error (   throwable t )  {   }  @ override public void on
@ test public void   (  )  {   message message = new  message (  )  ;  message . set type (  message .  type . chat )  ;  message . set body ( " tests" )  ;  message . add extension ( new  data form (  data form .  type . submit )  )  ;   forwarded forwar
public  string   (  )  {  last serial =  long . to string (    context . random (  )  . next long (  )  )  ;  action = null ;  return last serial ;   }  
@ override protected void   (  socket s )  {  i2p socket dest sock = null ;  try  {  try  {  s . set so timeout ( initial   so   timeout )  ;   }  catch  (   socket exception ioe )   {   }  socks server serv = socks server factory . createsocks server (  
public  string   (  )  {  return    content type ;   }  
private static  string   (  context context  xml resource parser xml  string name )  {  int res id = xml . get attribute resource value ( null name 0 )  ;  if  ( res id  =  =  0 )   {  return xml . get attribute value ( null name )  ;   }  else  {  return context . get string ( res id )  ;   }   }  
 string   (  )  {  return path ;   }  
@ override public void   ( t t )  {  actual . on success ( t )  ;  run finally (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  interval list to bed program = new  interval list to bed (  )  ;  final  file tmp =  file . create temp file ( "interval   list   to   bed   test   output" " . bed" )  ;  tmp . delete on exit (  )  ;
@ override public void   (  string t1 )  {  try  {   thread . sleep ( 50 )  ;   }  catch  (   interrupted exception e )   {  e . print stack trace (  )  ;   }  value1 . set ( t1 )  ;   }  
@ test public void   (  )  {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 5 )  . concat with (  single . just ( 100 )  )  . take ( 3 )  . subscribe ( ts )  ;  ts . assert result ( 1 2 3 )  ; 
@ override public  string   (  )  {  return "xmlns:db = \"jabber:server:dialback\"" ;   }  
public void   ( iq packet muc role role )  throws  forbidden exception   conflict exception   not allowed exception   cannot be invited exception  {  iq reply = iq . create resultiq ( packet )  ;   element element = packet . get child element (  )  ;  @ suppress warnings ( "unchecked" )   list <  element >  items list = element . elements ( "item" )  ;  if  (  ! items list . is empty (  )  )   {  handle items element ( role items list reply )  ;   }  else  {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error (  packet error .  condition . bad   request )  ;   }  if  ( reply . get to (  )   !  =  null )   {  router . route ( reply )  ;   }   }  
@ override public  set <  user provider >    (  )  {  final  set <  user provider >  result = new  linked hash set <  >  (  )  ;  result . add all ( providers by prefix . values (  )  )  ;  result . add ( fallback provider )  ;  return result ;   }  
public   (  string version  string constraint )  {  super ( version )  ;  min version = "" ;  source map = new  concurrent hash map <  update method  list < uri >  >  ( 4 )  ;  this . constraint = constraint ;   }  
@ data provider ( name = " " )  public  object[][]  valid arguments test provider (  )  {  final  list <  object[] >  objects = new  array list <  >  (  )  ;  for  (  final  strategy strategy :  strategy . values (  )  )  for  (  final  integer seed : new
private synchronized void   (  string key  string value  string original value )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( update   property )  ;  pstmt . set string ( 1 value )  ;  pstmt . set string ( 2 key )  ;  pstmt . set string ( 3 group . get name (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {  logger . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   map <  string  object >  event = new  hash map <  >  (  )  ;  event . put ( "property key" key )  ;  event . put ( "type" "property modified" )  ;  event . put ( "original value" original value )  ;   group event dispatcher . dispatch event ( group  group event dispatcher .  event type . group   modified event )  ;   }  
@ override public void   (  )  {  super . destroy (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . never (  )  . window ( 1  time unit . seconds 1 )  . test ( 0l )  . assert failure (  missing backpressure exception . class )  ;   }  
@ override public void   (  )  {  completed latch . count down (  )  ;   }  
protected void   (  string msg )  {   log log =    context . log manager (  )  . get log ( get class (  )  )  ;  if  ( log . should log (  log . debug )  )  log . debug ( msg )  ;   }  
public   (  flowable < t >  source long time  time unit unit  scheduler scheduler int buffer size boolean delay error )  {  super ( source )  ;  this . time = time ;  this . unit = unit ;  this . scheduler = scheduler ;  this . buffer size = buffer size ;  this . delay error = delay error ;   }  
@ test public void   (  )  throws  interrupted exception  {   observable <  string >  os = async   observable   of   infinite   integers ( new  count down latch ( 1 )  )  . zip with ( async   observable   of   infinite   integers ( new  count down latch (
public synchronized void   (  )  throws  socket exception  {  if  (    log . should log (  log . debug )  )     log . debug ( " starting up the udp endpoint" )  ;  shutdown (  )  ;     socket = get socket (  )  ;  if  (    socket  =  =  null )   {     log . log (  log . crit "udp  unable to open a port" )  ;  throw new  socket exception ( "ssu  unable to bind to a port on "  +     bind address )  ;   }  int count =    counter . increment and get (  )  ;     sender = new udp sender (    context    socket "udp sender "  +  count this )  ;     sender . startup (  )  ;  if  (    transport  !  =  null )   {     receiver = new udp receiver (    context    transport    socket "udp receiver "  +  count this )  ;     receiver . startup (  )  ;   }   }  
public void   (  string message )  {  this . message = message ;   }  
void   (  info hash ih  hash hash boolean is seed )  {  if  (    log . should log (  log . debug )  )     log . debug ( " announce "  +  hash  +  " for " +  ih )  ;   peers peers =    torrents . get ( ih )  ;  if  ( peers  =  =  null )   {  if  (    torrents . size (  )   >  =  max   torrents )  return ;  peers = new  peers (  )  ;   peers peers2 =    torrents . put if absent ( ih peers )  ;  if  ( peers2  !  =  null )  peers = peers2 ;   }  if  ( peers . size (  )   <  absolute   max   per   torrent )   {   peer peer = new  peer ( hash . get data (  )  )  ;   peer peer2 = peers . put if absent ( peer peer )  ;  if  ( peer2  !  =  null )  peer = peer2 ;  peer . set last seen (    context . clock (  )  . now (  )  )  ;  if  ( is seed )  peer . set seed ( true )  ;   }  else  {   }   }  
private void   (  http servlet request wrapper request )  {   collections . list ( request . get header names (  )  )  . stream (  )  . filter ( splittabel header util::is splittable )  . for each ( header name  -  >   {   enumeration <  string >  header values = request . get headers ( header name )  ;  request . remove header ( header name )  ;  split request header values ( header values )  . for each ( header value  -  >  request . add header ( header name header value )  )  ;   }   )  ;   }  
@ test public void   (  )  {   completable subject cs =  completable subject . create (  )  ;  assert false ( cs . has complete (  )  )  ;  assert false ( cs . has throwable (  )  )  ;  assert null ( cs . get throwable (  )  )  ;  assert false ( cs . has 
public void   (  )  {     outbound queue . clear (  )  ;   }  
public void   (  )  {  while  ( quit  =  =  false )   {  try  {   thread . sleep ( 500 )  ;   }  catch  (   interrupted exception ie )   {   }  pmc . erase (  )  ;  int data = updater . get data (  )  ;  set title ( title  +  " "  +  data )  ;  pmc . add element ( pmc . window size vector data )  ;  pmc . paint (  )  ;   }   }  
  (  )  {  super (    context . simple timer2 (  )  )  ;   }  
@ test public void   (  )  {   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   single <  string >  a =  single . just ( "a" )  ;   single <  string >  b =  single . just ( "b" )  ;   single . zip ( a b new  bi function <  str
@ override public void   (  disposable d )  {  disposable[0] = d ;   }  
@ override void   (  runnable r )  {  m posted to handler . add ( r )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   flowable .  <  integer  integer > using ( new  callable <  integer >  (  )  {  @ override publ
private void   ( final long account id )  {   content resolver resolver = m context . get content resolver (  )  ;  if  ( account id  =  =   account . account   id   combined   view )   {   cursor c = resolver . query (  account . content   uri  email content . id   projection null null null )  ;  try  {  while  ( c . move to next (  )  )   {  long id = c . get long (  email content . id   projection   column )  ;  register message notification ( id )  ;   }   }  finally  {  c . close (  )  ;   }   }  else  {   content observer obs = m notification map . get ( account id )  ;  if  ( obs  !  =  null )  return ;   log utils . i ( log   tag " registering for notifications for account "  +  account id )  ;   content observer observer = new  message content observer ( s notification handler m context account id )  ;  resolver . register content observer (  message . notifier   uri true observer )  ;  m notification map . put ( account id observer )  ;  observer . on change ( true )  ;   }   }  
public boolean   (  )  {  return m file . exists (  )  ;   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public void   (  string username  string password  string name  string email  string group names )  throws  user already exists exception   group already exists exception   user not found exception   group not found exception  {  user manager . create user ( username password name email )  ;  user manager . get user ( username )  ;  if  ( group names  !  =  null )   {   collection <  group >  groups = new  array list <  group >  (  )  ;   string tokenizer tkn = new  string tokenizer ( group names " " )  ;  while  ( tkn . has more tokens (  )  )   {   string group name = tkn . next token (  )  ;   group group = null ;  try  {  group =  group manager . get instance (  )  . get group ( group name )  ;   }  catch  (   group not found exception e )   {  group =  group manager . get instance (  )  . create group ( group name )  ;  group . get properties (  )  . put ( "shared roster . show in roster" "only group" )  ;  group . get properties (  )  . put ( "shared roster . display name" group name )  ;  group . get properties (  )  . put ( "shared roster . group list" "" )  ;   }  groups . add ( group )  ;   }  for  (   group group : groups )   {  group . get members (  )  . add ( server . createjid ( username null )  )  ;   }   }   }  
public   (  thread thread reference  destroyable thread logic )  {  if  ( thread reference  =  =  null || thread logic  =  =  null )   {  throw new  illegal argument exception ( " references for creating a destroyable thread reference must not be null . "  +  " thread  reference: "  +  thread reference  +  "  -   thread  logic: " +  thread logic )  ;   }  this . thread reference = thread reference ;  this . thread logic = thread logic ;   }  
public int   (  )  {  return code ;   }  
public   ( jid address )  {  this . address = address ;   }  
@ override public double   (  )  {  double average response time =  ( double ) data store . get total responses (  )   /  data store . get accumulated response time (  )  ;  if  (  double . is nan ( average response time )  )   {  return double   zero ;  
@ override public void   ( byte[] nodeid )  {   lock client lock =  cache factory . get lock ( nodeid users cache )  ;  try  {  client lock . lock (  )  ;   list <  string >  remote client routes = new  array list <  >  (  )  ;  for  (   map .  entry <  s
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  if  ( s instanceof  queue subscription )   {  @ suppress warnings ( "unchecked" )   queue subscription < t >  qs =  (  queue subs
void   (  string key  string value boolean is encrypted )  {  properties . put ( key value )  ;  encrypted . put ( key is encrypted )  ;   jive globals . clearxml property encryption entry ( key )  ;   map <  string  object >  params = new  hash map <  >  (  )  ;  params . put ( "value" value )  ;   property event dispatcher . dispatch event ( key  property event dispatcher .  event type . property   set params )  ;   }  
private synchronized void   (  )  {  if  ( openfired  =  =  null )   {  try  {   file windows exe = new  file ( bin dir "openfired . exe" )  ;   file unix exe = new  file ( bin dir "openfired" )  ;  if  ( windows exe . exists (  )  )   {  openfired =  runtime . get runtime (  )  . exec ( new  string[] { windows exe . to string (  )  }  )  ;   }  else if  ( unix exe . exists (  )  )   {  openfired =  runtime . get runtime (  )  . exec ( new  string[] { unix exe . to string (  )  }  )  ;   }  else  {  throw new  file not found exception (  )  ;   }   }  catch  (   exception e )   {  try  {   file lib dir = new  file ( bin dir . get parent file (  )  "lib" )  . get absolute file (  )  ;  openfired =  runtime . get runtime (  )  . exec ( new  string[] { "java" " - jar" new  file ( lib dir "startup . jar" )  . to string (  )  }  )  ;   }  catch  (   exception ex )   {  ex . print stack trace (  )  ;  j option pane . show message dialog ( null " launcher could not start \n"  +  app name " file not found" j option pane . error   message )  ;   }   }  final  simple attribute set styles = new  simple attribute set (  )  ;   swing worker <  string  void >  input worker = new  swing worker <  string  void >  (  )  {  @ override public  string do in background (  )  {  if  ( openfired  !  =  null )   {  try  (  input stream in = openfired . get input stream (  )  )  {  int c ;  while  (  ( c = in . read (  )  )   !  =   - 1 )   {  try  {   style constants . set font family ( styles "courier new" )  ;  pane . get document (  )  . insert string ( pane . get document (  )  . get length (  )  ""  +   ( char ) c styles )  ;   }  catch  (   bad location exception e )   {   }   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }  return "ok" ;   }   }   ;  input worker . execute (  )  ;   swing worker <  string  void >  error worker = new  swing worker <  string  void >  (  )  {  @ override public  string do in background (  )  {  if  ( openfired  !  =  null )   {  try  (  input stream in = openfired . get error stream (  )  )  {  int c ;  while  (  ( c = in . read (  )  )   !  =   - 1 )   {  try  {   style constants . set foreground ( styles  color . red )  ;  pane . get document (  )  . insert string ( pane . get document (  )  . get length (  )  ""  +   ( char ) c styles )  ;   }  catch  (   bad location exception e )   {   }   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }  return "ok" ;   }   }   ;  error worker . execute (  )  ;  if  ( fresh start )   {  try  {   thread . sleep ( 1000 )  ;  card layout . show ( card panel "running" )  ;   }  catch  (   exception ex )   {   }  fresh start = false ;   }  else  {  pane . set text ( "" )  ;  card layout . show ( card panel "running" )  ;   }   }   }  
public synchronized void   (  )  {  if  (    pumper . is alive (  )  )  return ;  if  (    log . should log (  log . warn )  )     log . warn ( " starting ntcp transport listening" )  ;  start it (  )  ;   router address addr = configure local address (  )  ;  int port ;  if  ( addr  !  =  null )  port = addr . get port (  )  ;  else port =    ssu port ;   router address my address = bind address ( port )  ;  if  ( my address  !  =  null )   {  replace address ( my address )  ;   }  else if  ( addr  !  =  null )   {  replace address ( addr )  ;   }  else if  ( port  >  0 )   {  for  (   inet address ia : get saved local addresses (  )  )   {   ordered properties props = new  ordered properties (  )  ;  props . set property (  router address . prop   host ia . get host address (  )  )  ;  props . set property (  router address . prop   port  integer . to string ( port )  )  ;  int cost = get default cost ( ia instanceof  inet6 address )  ;  my address = new  router address ( style props cost )  ;  replace address ( my address )  ;   }   }   }  
@ override public void   (  observer <  ?  super t >  s )  {   throwable error ;  try  {  error =  object helper . require non null ( error supplier . call (  )  " callable returned null throwable .   null values are generally not allowed in 2 . x operato
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . complete (  )  . do on complete ( null )  ;   }  
@ override public  flowable <  object >    (  flowable <  object >  f )  throws  exception  {  return f . on backpressure buffer ( 8  functions . empty   action  backpressure overflow strategy . error )  ;   }  
@ test ( data provider = "u byte data" )  public void   ( final byte unsigned byte final int expected int )  {  final short expected short =  ( short ) expected int ;   assert . assert equals (  unsigned type util . u byte to short ( unsigned byte )  expe
public void   (  )  {     comm system facades . put (    context . router hash (  )  this )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( new  flowable subscriber <  integer >  (  )  {  @ override public void on subscribe (   subscription d )  {   }  @ override public void on next (   inte
public  string[]   (  )  {  return print lines . to array ( new  string[print lines . size (  ) ] )  ;   }  
void   (  tunnel info info )  {  if  (    log . should log (  log . debug )  )     log . debug ( to string (  )   +  ":  adding tunnel "  +  info )  ;   lease set ls = null ;  synchronized  (    tunnels )   {     tunnels . add ( info )  ;  if  (    settings . is inbound (  )  &&  !    settings . is exploratory (  )  )  ls = locked   build new lease set (  )  ;   }  if  ( ls  !  =  null )     context . client manager (  )  . request lease set (    settings . get destination (  )  ls )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . just ( 1 )  . to list ( new  callable <  collection <  integer >  >  (  )  {  @ override public  collection <  integer >  call (  )  throws  exception  {  throw new  test excep
@ test public void   (  )  {   observable . range ( 1 10 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completabl
public void   ( int limit )  {     limit = limit ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  completable   ( final  iterable <  ?  extends  completable source >  sources )  {   object helper . require non null ( sources "sources is null" )  ;  return  rx java p
@ override public void   (  )  throws  exception  {  values . add ( 100 )  ;   }  
  ( final  file directory final int lane final  cycle illumina file map cycles to tile files final  output mapping output mapping )  {  this . tile order = get tile order ( cycles to tile files )  ;  this . lane = lane ;  this . lane directory = new  file ( directory  illumina file util . long lane str ( this . lane )  )  ;  this . cycles to tile files = cycles to tile files ;  this . current tile = tile order . first (  )  ;  this . output mapping = output mapping ;   }  
private static void   (  content values values )  {  if  ( values . contains key (  message .  message columns . to   list )  )   {  final  string to = values . get as string (  message .  message columns . to   list )  ;  values . put (  message .  message columns . to   list  address . from header to string ( to )  )  ;   }  if  ( values . contains key (  message .  message columns . from   list )  )   {  final  string from = values . get as string (  message .  message columns . from   list )  ;  values . put (  message .  message columns . from   list  address . from header to string ( from )  )  ;   }  if  ( values . contains key (  message .  message columns . cc   list )  )   {  final  string cc = values . get as string (  message .  message columns . cc   list )  ;  values . put (  message .  message columns . cc   list  address . from header to string ( cc )  )  ;   }  if  ( values . contains key (  message .  message columns . bcc   list )  )   {  final  string bcc = values . get as string (  message .  message columns . bcc   list )  ;  values . put (  message .  message columns . bcc   list  address . from header to string ( bcc )  )  ;   }  if  ( values . contains key (  message .  message columns . reply   to   list )  )   {  final  string reply to = values . get as string (  message .  message columns . reply   to   list )  ;  values . put (  message .  message columns . reply   to   list  address . from header to string ( reply to )  )  ;   }   }  
public   (  )  {  xmpp server server = xmpp server . get instance (  )  ;  router = server . get presence router (  )  ;  server name = server . get server info (  )  . getxmpp domain (  )  ;   string list =  jive globals . get property ( white   list )  ;  if  ( list  !  =  null )   {  white list . add all ( csv to list ( list )  )  ;   }   }  
public final static  date   (  )  {  return new  date (  calendar . get instance (  time zone . get time zone ( "gmt" )  )  )  ;   }  
public static void   (  completable source )  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;  source . subscribe ( new  completable observer (  )  {  @ override public void on subscribe (   disposable d )  {  try  {  b[0] = d . is disposed (  )  ;  d . dispose (  )  ;  b[1] = d . is disposed (  )  ;  d . dispose (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }  @ override public void on error (   throwable e )  {   }  @ override public void on complete (  )  {   }   }   )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " reports disposed upfront ? " false b[0] )  ;  assert equals ( " didn't report disposed after ? " true b[1] )  ;   }  
@ test public void   (  )  {   flowable <  integer >  source =  flowable . from publisher ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  integer >  s )  {   boolean subscription s1 = new  boolean subsc
@ test public void   (  )  {  final  header value first = new  header value impl ( "equal" 0 . 8 )   second = new  header value impl ( "equal" 0 . 8 )   third = new  header value impl ( "eqlam" 0 . 8 )  ;  assert equals ( " comparing header values must ma
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  completable source next )  {  return concat with ( next )  ;   }  
@ test public void   (  )  {  final  observer <  ?  > [] sub =  { null }  ;  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  s )  {  sub[0] = s ;   }   }   . replay (  )  . connect (  
public static  string   (  string username )  throws  unsupported operation exception   user not found exception  {  return auth provider . get server key ( username )  ;   }  
public void   (  dialog terminated event dte )  {  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( "process dialog terminated called" )  ;   }   }  
public static  internal component manager   (  )  {  return instance ;   }  
public  tunnel manager facade   (  )  {  return    tunnel manager ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . timeout (  functions . just function (  flowable . never (  )  )   flowable . never (  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   test helper . check utility class (  object helper . class )  ;   }  
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  try  {  parent . on complete . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  actual . on error ( ex )  ;  return ;   }  actual . on complete ( 
public   (  string id int in sample rate int in channels int out sample rate int out channels )  throws io exception  {  super ( id in sample rate in channels out sample rate out channels )  ;  if  ( in sample rate  >  out sample rate )   {  throw new io exception ( " upsampler in sample rate "  +  in sample rate  +  "  >  out sample rate " +  out sample rate )  ;   }  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " new  upsampler: from "  +  in sample rate  +  " / " +  in channels +  " to " +  out sample rate +  " / " +  out channels )  ;   }  reset (  )  ;   }  
@ override public  session cookie config   (  )  {  return proxy . get session cookie config (  )  ;   }  
@ before public void   (  )  throws  exception  {   configuration service configuration service = mock (  configuration service . class )  ;   string configuration root = "" ;  filter = new  translation filter ( configuration service configuration root ) 
public   (  string value )  {  this . value = value ;   }  
public void   (  plugin listener listener )  {  plugin listeners . remove ( listener )  ;   }  
@ test public void   (  )  {   observer <  string >  w =  test helper . mock observer (  )  ;   test observable w1 = new  test observable (  )  ;   test observable w2 = new  test observable (  )  ;   test observable w3 = new  test observable (  )  ;   obs
void   (  inner consumer inner  throwable e )  {  set . delete ( inner )  ;  on error ( e )  ;   }  
public double   (  )  {  return packet count . get and set ( 0 )  ;   }  
public int   (  )  {  return hash len ;   }  
@ test public void   (  )  throws  exception  {  set password types ( "plain md5 plain plain" )  ;  assert true ( "weird password chains are fine" jdbc auth provider . compare passwords ( password md5   password )  )  ;   }  
default  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  throw new  unsupported operation exception ( " not supported for type" )  ;   }  
public double   (  )  {  return xff ;   }  
@ test public void   (  )  {   executor service exec =  executors . new fixed thread pool ( 4 )  ;   scheduler s =  schedulers . from ( exec )  ;  try  {   callable <  list <  integer >  >  as = new  callable <  list <  integer >  >  (  )  {  @ override p
private void   (  packet packet  connection con )  {  if  ( con . get receive stream id (  )   =  =  packet . get send stream id (  )  )   {   destination from = con . get remote peer (  )  ;  if  ( from  =  =  null )  from = packet . get optional from (  )  ;  boolean ok = packet . verify signature (    context from null )  ;  if  (  ! ok )   {  if  (    log . should log (  log . error )  )     log . error ( " received unsigned  /  forged rst on "  +  con )  ;  return ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " reset received" )  ;  con . reset received (  )  ;  con . event occurred (  )  ;     context . stat manager (  )  . add rate data ( "stream . reset received" con . get highest acked through (  )  con . get lifetime (  )  )  ;  return ;   }   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " received a packet for the wrong connection ?  "  +  con  +  "  /  " +  packet )  ;  return ;   }   }  
@ override public  iterator <  disco item >    (  string name  string node jid senderjid )  {  return new  array list <  disco item >  (  )  . iterator (  )  ;   }  
private boolean   (  )  throws io exception  {   list <  send recv >  cmds = new  array list <  send recv >  ( 2 )  ;  cmds . add ( new  send recv ( null  mode . a1 )  )  ;   send recv capa = null ;  if  ( gotcapa )   {  if  (    log . should debug (  )  )     log . debug ( " skipping capa" )  ;   }  else  {  capa = new  send recv ( "capa"  mode . ls )  ;  cmds . add ( capa )  ;   }  boolean rv = send cmds ( cmds )  ;  if  ( rv && capa  !  =  null )   {  if  ( capa . ls  !  =  null )   {  for  (   string cap : capa . ls )   {   string t = cap . trim (  )  ;  if  ( t . equals ( "pipelining" )  )  supports pipelining = true ;  else if  ( t . equals ( "uidl" )  )  supportsuidl = true ;  else if  ( t . equals ( "top" )  )  supportstop = true ;   }   }  gotcapa = true ;  if  (    log . should debug (  )  )     log . debug ( "pop3 server caps: pipelining ?  "  +  supports pipelining  +  " uidl ?  " +  supportsuidl +  " top ?  " +  supportstop )  ;   }  return rv ;   }  
public void   ( long account id )  {   account account =  account . restore account with id ( m context account id )  ;  if  ( account  =  =  null )  return ;  if  ( account . m policy key  =  =  0 )  return ;   policy policy =  policy . restore policy with id ( m context account . m policy key )  ;  if  ( policy  =  =  null )  return ;  if  (  debug utils . debug )   {   log utils . d ( tag "policies required for "  +  account . m display name  +  ": " +  policy )  ;   }  set account hold flag ( m context account true )  ;  final  notification controller nc =  notification controller creator holder . get instance ( m context )  ;  if  ( policy . m protocol policies unsupported  =  =  null )   {  nc . show security needed notification ( account )  ;   }  else  {  nc . show security unsupported notification ( account )  ;   }   }  
private void   (  )  {   log . debug ( " notifying all local users about the imminent destruction of chat service ' {  } '" chat service name )  ;  if  ( users . is empty (  )  )   {  return ;   }  final  executor service service =  executors . new fixed thread pool (  math . min ( users . size (  )  10 )  )  ;  for  (  final  localmuc user user : users . values (  )  )   {  service . submit ( new  runnable (  )  {  @ override public void run (  )  {  try  {  for  (  final  localmuc role role : user . get roles (  )  )   {  final muc room room = role . get chat room (  )  ;  final  presence presence = room . create presence (  presence .  type . unavailable )  ;  presence . set from ( role . get role address (  )  )  ;  final  element fragment = presence . add child element ( "x" "http: /  / jabber . org / protocol / muc#user" )  ;  final  element item = fragment . add element ( "item" )  ;  item . add attribute ( "affiliation" "none" )  ;  item . add attribute ( "role" "none" )  ;  fragment . add element ( "status" )  . add attribute ( "code" "332" )  ;  role . send ( presence )  ;   }   }  catch  (   exception e )   {   log . debug ( " unable to inform  {  }  about the imminent destruction of chat service ' {  } '" user . get address (  )  chat service name e )  ;   }   }   }   )  ;   }  service . shutdown (  )  ;  try  {  service . await termination (  jive globals . get int property ( "xmpp . muc . await - termination - millis" 500 )   time unit . milliseconds )  ;   log . debug ( " successfully notified all  {  }  local users about the imminent destruction of chat service ' {  } '" users . size (  )  chat service name )  ;   }  catch  (   interrupted exception e )   {   log . debug ( " interrupted while waiting for all users to be notified of shutdown of chat service ' {  } ' .   shutting down immediately . " chat service name )  ;   }  service . shutdown now (  )  ;   }  
  (  subscriber <  ?  super t >  actual  action on overflow  backpressure overflow strategy strategy long buffer size )  {  this . actual = actual ;  this . on overflow = on overflow ;  this . strategy = strategy ;  this . buffer size = buffer size ;  this . requested = new  atomic long (  )  ;  this . deque = new  array deque < t >  (  )  ;   }  
@ test public void   (  )  throws  exception  {  mock columns ( "long field" )  ;   long a long val = 100l ;  when ( result set . get long ( 1 )  )  . then return ( a long val )  ;  when ( result set . was null (  )  )  . then return ( false )  ;   sample
private static void   ( final  list <  file >  input files )  {  final vcf header header = new vcf file reader ( input files . get ( 0 )  false )  . get file header (  )  ;  final sam sequence dictionary dict = header . get sequence dictionary (  )  ;  final  variant context comparator comparator = new  variant context comparator ( header . get sequence dictionary (  )  )  ;  final  list <  string >  samples = header . get genotype samples (  )  ;   file last file = null ;   variant context last context = null ;  for  (  final  file f : input files )   {  final vcf file reader in = new vcf file reader ( f false )  ;  try  {  dict . assert same dictionary ( in . get file header (  )  . get sequence dictionary (  )  )  ;   }  catch  (  final  assertion error e )   {  log . error ( " file #1: "  +  input files . get ( 0 )  )  ;  log . error ( " file #2: "  +  f )  ;  throw e ;   }  final  list <  string >  these samples = in . get file header (  )  . get genotype samples (  )  ;  if  (  ! samples . equals ( these samples )  )   {  final  sorted set <  string >  s1 = new  tree set <  >  ( samples )  ;  final  sorted set <  string >  s2 = new  tree set <  >  ( these samples )  ;  s1 . remove all ( these samples )  ;  s2 . remove all ( samples )  ;  throw new  illegal argument exception ( "vc fs do not have identical sample lists . "  +  "  samples unique to first file: "  +  s1  +  " .   samples unique to " +  f . get absolute path (  )  +  ": " +  s2 +  " . " )  ;   }  final  closeable iterator <  variant context >  variant iterator = in . iterator (  )  ;  if  ( variant iterator . has next (  )  )   {  final  variant context current context = variant iterator . next (  )  ;  if  ( last context  !  =  null && comparator . compare ( last context current context )   >  =  0 )   {  throw new  illegal argument exception ( " first record in file "  +  f . get absolute path (  )   +  " is not after first record in " +  "previous file " +  last file . get absolute path (  )  )  ;   }  last context = current context ;  last file = f ;   }   closer util . close ( in )  ;   }   }  
@ override public void   ( long n )  {  requests . add ( n )  ;   }  
public void   (  properties props  string prefix boolean treat as current )  throws  illegal argument exception  {  for  (   rate r :    rates )   {  long period = r . get period (  )  ;   string cur prefix = prefix  +  " . "  +   data helper . format duration ( period )  ;  r . load ( props cur prefix treat as current )  ;   }   }  
@ override public void   (  string username )  {  logger . finest ( "delete user" )  ;  user list . remove ( username )  ;   }  
void   ( final  bcl data bcl data final int read final int cycle final int byte to decode )  {  if  ( byte to decode  =  =  0 )   {  bcl data . bases[read][cycle] =  ( byte ) ' . ' ;  bcl data . qualities[read][cycle] =  ( byte ) 2 ;   }  else  {  bcl data . bases[read][cycle] = base   lookup[byte to decode & base   mask] ;  bcl data . qualities[read][cycle] = bcl quality evaluation strategy . revise and conditionally log quality (  ( byte )  ( byte to decode  >  >  >  2 )  )  ;   }   }  
@ override public void   (  )  {  source . subscribe ( this )  ;   }  
public   ( final  tile tile final  tile read aggregator handler final  tile processing record processing record )  {  this . tile = tile ;  this . handler = handler ;  this . processing record = processing record ;   }  
public  set <  class <  ?  >  >    (  )  {  return  ( deallocatable buffer class set )  ;   }  
public static  map <  integer  cluster data >    ( final int lane final  list <  integer >  tiles final  string read structure final  illumina data type .  .  .  data types )  {  final  list <  integer >  sorted tiles = new  array list <  integer >  ( tiles )  ;   collections . sort ( sorted tiles )  ;  final  map <  integer  cluster data >  data = new  hash map <  integer  cluster data >  (  )  ;  int offset = 0 ;  for  (  final int tile : sorted tiles )   {  final  string key = lt str ( lane tile )  ;  final  list <  cluster data >  cds = gold data . get ( key )  ;  final  list <  integer >  read nos = gold indices . get ( key )  ;  final int size = gold sizes . get ( key )  ;  for  ( int i = 0 ;  i  <  cds . size (  )  ;  i +  +  )   {  data . put ( offset  +  read nos . get ( i )  selective copy cd ( cds . get ( i )  read structure data types )  )  ;   }  offset +  = size ;   }  return data ;   }  
  (  maybe observer <  ?  super  boolean >  actual )  {  this . actual = actual ;   }  
@ test public void   (  )  throws  exception  {   action unsubscribe = mock (  action . class )  ;   flowable <  integer >  o =  flowable . just ( 1 )  . do on cancel ( unsubscribe )  . cache (  )  ;  o . subscribe (  )  ;  o . subscribe (  )  ;  o . subs
private void   (  )  {  if  (    received unconfirmed identity  !  =  null )  return ;  int frags =    received identity . length ;  byte[] ident ;  if  ( frags  >  1 )   {  int ident size = 0 ;  for  ( int i = 0 ;  i  <     received identity . length ;  i +  +  )  ident size +  =    received identity[i] . length ;  ident = new byte[ident size] ;  int off = 0 ;  for  ( int i = 0 ;  i  <     received identity . length ;  i +  +  )   {  int len =    received identity[i] . length ;   system . arraycopy (    received identity[i] 0 ident off len )  ;  off +  = len ;   }   }  else  {  ident =    received identity[0] ;   }   byte array input stream in = new  byte array input stream ( ident )  ;   router identity peer = new  router identity (  )  ;  try  {  peer . read bytes ( in )  ;     received unconfirmed identity = peer ;   }  catch  (   data format exception dfe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " improperly formatted yet fully received ident" dfe )  ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " improperly formatted yet fully received ident" ioe )  ;   }   }  
@ test public void   (  )  {  try  {   rx java plugins . set fail on non blocking scheduler ( true )  ;   flowable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  . map ( new  function <  integer  integer >  (  )  {  @ override public  i
@ override protected  ad hoc command .  action   (  session data data )  {  return  ad hoc command .  action . complete ;   }  
@ test public void   (  )  {  final  disposable d =  disposables . empty (  )  ;   observable .  <  integer > create ( new  observable on subscribe <  integer >  (  )  {  @ override public void subscribe (   observable emitter <  integer >  e )  throws  e
public void   (  pending snac listener l )  {  listeners . remove ( l )  ;   }  
public int   (  )  {  return off color ;   }  
private  list <  client session >    (  list <  client session >  sessions int min )  {  if  ( min  <  0 )   {  return  collections . empty list (  )  ;   }   list <  client session >  answer = new  array list <  >  ( sessions . size (  )  )  ;  for  (   client session session : sessions )   {  if  ( session . get presence (  )  . get priority (  )   >  =  min )   {  answer . add ( session )  ;   }   }  return answer ;   }  
@ non null @ override public  disposable   ( @ non null final  runnable action long delay time @ non null  time unit unit )  {  if  ( disposed )   {  return  empty disposable . instance ;   }  return schedule actual ( action delay time unit null )  ;   } 
public boolean   (  )  {  return is distributed bridge ;   }  
public long   (  )  {  return    confirmed sent time ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( "insert - id - name - positional" )  3 " tip" )  ;  assert that ( h . select ( "select name from something" )  . map to (  st
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private void   (  string builder sb  string .  .  .  fragments )  {  if  ( sb . length (  )   !  =  0 )   {  sb . append ( " and " )  ;   }  for  (   string fragment : fragments )   {  sb . append ( fragment )  ;   }   }  
@ override public int   (  )  {  return  objects . hash ( string value long value )  ;   }  
@ suppress warnings ( "unchecked" )  private  hashtable <  string  string >    (  element incoming form )  {  if  ( incoming form . element ( q name . get ( "x" "jabber:x:data" )  )   !  =  null )   {  return extract extended search query ( incoming form 
@ override public  string   (  )  {  return remote peer . get address (  )  . get host address (  )  ;   }  
private void   ( long id )  throws i2cp message exception  {   message payload message msg = new  message payload message (  )  ;  msg . set message id ( id )  ;   session id sid =    runner . get session id (    to dest . calculate hash (  )  )  ;  if  ( sid  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " no session for "  +     to dest . calculate hash (  )  )  ;  return ;   }  msg . set session id ( sid . get session id (  )  )  ;  msg . set payload (    payload )  ;     runner . do send ( msg )  ;   }  
private static  mode   (  string content  string encoding )  {  if  ( " shift   jis" . equals ( encoding )  && is only double byte kanji ( content )  )   {  return  mode . kanji ;   }  boolean has numeric = false ;  boolean has alphanumeric = false ;  for  ( int i = 0 ;  i  <  content . length (  )  ;   +  + i )   {  char c = content . char at ( i )  ;  if  ( c  >  =  '0' && c  <  =  '9' )   {  has numeric = true ;   }  else if  ( get alphanumeric code ( c )   !  =   - 1 )   {  has alphanumeric = true ;   }  else  {  return  mode . byte ;   }   }  if  ( has alphanumeric )   {  return  mode . alphanumeric ;   }  if  ( has numeric )   {  return  mode . numeric ;   }  return  mode . byte ;   }  
@ test public void   (  )  {   single . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  throw new io exception (  )  ;   }   }   )  . test (  )  . assert failure ( io excep
  (  observer < t >  observer )  {  this . observer = observer ;   }  
public int   (  )  {  return max leaf nodes ;   }  
@ test public void   (  )  throws  exception  {   runtime exception outer = new  runtime exception ( " transaction throws ! " )  ;   runtime exception inner = new  runtime exception ( " rollback throws ! " )  ;   mockito . when ( c . get auto commit (  ) 
public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write boolean ( out room participation )  ;   externalizable util . get instance (  )  . write externalizable collection ( out participations )  ;   }  
@ test public void   (  )  throws  interrupted exception   execution exception  {   observable <  string >  obs =  observable . just ( "one" "two" "three" )  ;   future <  list <  string >  >  f = obs . to list (  )  . to future (  )  ;  assert equals ( "
  (  rrd graph def gdef  image parameters im )  {  this . gdef = gdef ;  this . im = im ;  pixiex =  ( double ) im . xsize  /   ( double )  ( im . end  -  im . start )  ;  if  (  ! gdef . logarithmic )   {  pixiey =  ( double ) im . ysize  /   ( im . maxval  -  im . minval )  ;   }  else  {  pixiey =  ( double ) im . ysize  /   (  math . log10 ( im . maxval )   -   math . log10 ( im . minval )  )  ;   }   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   flowable <  object >  o )  throws  exception  { 
public  string   (  )  {  return sample alias ;   }  
  (  maybe observer <  ?  super t >  actual  function <  ?  super  throwable  ?  extends  maybe source <  ?  extends t >  >  resume function boolean allow fatal )  {  this . actual = actual ;  this . resume function = resume function ;  this . allow fatal = allow fatal ;   }  
private static int   ( byte[] source int src offset byte[] destination int dest offset int options )  {  byte[] decodabet = get decodabet ( options )  ;  if  ( source[src offset  +  2]  =  =  equals   sign )   {  int out buff =  (  ( decodabet[source[src offset]] & 0xff )   <  <  18 )  |  (  ( decodabet[source[src offset  +  1]] & 0xff )   <  <  12 )  ;  destination[dest offset] =  ( byte )  ( out buff  >  >  >  16 )  ;  return 1 ;   }  else if  ( source[src offset  +  3]  =  =  equals   sign )   {  int out buff =  (  ( decodabet[source[src offset]] & 0xff )   <  <  18 )  |  (  ( decodabet[source[src offset  +  1]] & 0xff )   <  <  12 )  |  (  ( decodabet[source[src offset  +  2]] & 0xff )   <  <  6 )  ;  destination[dest offset] =  ( byte )  ( out buff  >  >  >  16 )  ;  destination[dest offset  +  1] =  ( byte )  ( out buff  >  >  >  8 )  ;  return 2 ;   }  else  {  try  {  int out buff =  (  ( decodabet[source[src offset]] & 0xff )   <  <  18 )  |  (  ( decodabet[source[src offset  +  1]] & 0xff )   <  <  12 )  |  (  ( decodabet[source[src offset  +  2]] & 0xff )   <  <  6 ) |  (  ( decodabet[source[src offset  +  3]] & 0xff )  )  ;  destination[dest offset] =  ( byte )  ( out buff  >  >  16 )  ;  destination[dest offset  +  1] =  ( byte )  ( out buff  >  >  8 )  ;  destination[dest offset  +  2] =  ( byte )  ( out buff )  ;  return 3 ;   }  catch  (   exception e )   {   system . out . println ( ""  +  source[src offset]  +  ": " +   ( decodabet[source[src offset]] )  )  ;   system . out . println ( ""  +  source[src offset  +  1]  +  ": " +   ( decodabet[source[src offset  +  1]] )  )  ;   system . out . println ( ""  +  source[src offset  +  2]  +  ": " +   ( decodabet[source[src offset  +  2]] )  )  ;   system . out . println ( ""  +  source[src offset  +  3]  +  ": " +   ( decodabet[source[src offset  +  3]] )  )  ;  return  - 1 ;   }   }   }  
@ override void   (  )  {  if  ( wip . get and increment (  )   =  =  0 )   {  queue . lazy set ( null )  ;   }   }  
public void   (  )  {     messages to write . clear (  )  ;  try  {     messages to write . put ( new  poisoni2cp message (  )  )  ;   }  catch  (   interrupted exception ie )   {   }   }  
public  parameter   ( int n )  {  return  (  parameter ) get ( n )  ;   }  
@ test public void   (  )  {  assert not null ( commands )  ;   }  
@ override public final boolean   (  )  {  return get (  )   !  =  fused   ready ;   }  
 session   (  )  {  return  session manager . get instance (  )  . get outgoing server session ( address )  ;   }  
public int   (  string sql  object .  .  .  args )  {   update stmt = create update ( sql )  ;  int position = 0 ;  for  (   object arg : args )   {  stmt . bind ( position +  +  arg )  ;   }  return stmt . execute (  )  ;   }  
public   (  flowable < t >  source  consumer <  ?  super t >  on drop )  {  super ( source )  ;  this . on drop = on drop ;   }  
public boolean   (  destination dest )  {  return true ;   }  
private int   ( int cur page )  throws io exception  {  int rv = 0 ;  while  ( cur page  >  0 )   {   block file . page seek ( bf . file cur page )  ;  int magic = bf . file . read int (  )  ;  if  ( magic  !  =   block file . magic   cont )  throw new io exception ( " bad  skip span magic number 0x"  +   integer . to hex string ( magic )   +  " on page " +  cur page )  ;  int next = bf . file . read unsigned int (  )  ;  bf . free page ( cur page )  ;  cur page = next ;  rv +  +  ;   }  return rv ;   }  
public static void   (  async task <  ?   ?   ?  >  task )  {  cancel task ( task true )  ;   }  
@ override public  routing key generator   (  )  {  return    routing key generator ;   }  
@ override public void   ( t value )  {  actual . on success ( value )  ;   }  
  (  observer <  ?  super t >  actual  completable source other )  {  this . actual = actual ;  this . other = other ;   }  
public void   (  agent session agent session )  {   workgroup manager . get instance (  )  . update workgroup status ( this )  ;   workgroup event dispatcher . agent joined ( this agent session )  ;   }  
@ override public  jsp config descriptor   (  )  {  return context . get jsp config descriptor (  )  ;   }  
public int   (  )  {  return  jive globals . get int property ( http   bind   port http   bind   port   default )  ;   }  
  (  merge with observer < t >  parent )  {  this . parent = parent ;   }  
public static boolean   (  )  {  return    one dot nine ;   }  
public void   (  )  {  peers . clear (  )  ;  if  ( requests  !  =  null )  requests . clear (  )  ;   }  
@ override @ non null public synchronized  throwable   (  )  {  if  ( cause  =  =  null )   {   composite exception causal chain local cause = new  composite exception causal chain (  )  ;   set <  throwable >  seen causes = new  hash set <  throwable >  
@ override public void   (  subscription d )  {   subscription helper . set once ( upstream d  long . max   value )  ;   }  
public long   (  )  {  if  (    leases . is empty (  )  )  return  - 1 ;  return    first expiration ;   }  
public   (  observable source < t >  source  predicate <  ?  super t >  predicate )  {  super ( source )  ;  this . predicate = predicate ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . just ( 1 )  . do finally ( null )  ;   }  
public boolean   (  )  {  return    not modified ;   }  
private void   ( iq iq )  {  final  string clients allowed =  jive globals . get property ( "clients . allowed" "all" )  ;  final boolean disconnect if no match =  ! "all" . equals ( clients allowed )  ;  if  ( "all" . equals ( clients allowed )  ||  ! disconnect if no match )   {  return ;   }   client session session = session manager . get session ( iq . get from (  )  )  ;  if  ( session  =  =  null )   {  return ;   }  if  ( iq .  type . result  =  =  iq . get type (  )  )   {  final  list <  string >  clients = new  array list <  string >  (  )  ;   string tokenizer client tokens = new  string tokenizer ( clients allowed " " )  ;  while  ( client tokens . has more tokens (  )  )   {  clients . add ( client tokens . next token (  )  . to lower case (  )  )  ;   }  final  string other clients allowed =  jive globals . get property ( "other . clients . allowed" "" )  ;  client tokens = new  string tokenizer ( other clients allowed " " )  ;  while  ( client tokens . has more tokens (  )  )   {  clients . add ( client tokens . next token (  )  . to lower case (  )  . trim (  )  )  ;   }   element child = iq . get child element (  )  ;   string client name = child . element text trim ( "name" )  ;  boolean disconnect = true ;  if  ( client name  !  =  null )   {  for  (   string c : clients )   {  if  ( client name . to lower case (  )  . contains ( c )  )   {  disconnect = false ;  break ;   }   }   }  else  {  disconnect = true ;   }  if  ( disconnect )   {  close session ( session client name  !  =  null  ?  client name : " unknown" )  ;   }   }  else  {  close session ( session " unknown" )  ;   }   }  
private void   (  )  throws sql exception  {  if  ( disconnected mode )   {  return ;   }  this . registrationid =  sequence manager . nextid ( this )  ;   connection con = null ;   prepared statement pstmt = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;  pstmt = con . prepare statement ( insert   registration )  ;  pstmt . set long ( 1 registrationid )  ;  pstmt . set string ( 2 jid . to string (  )  )  ;  pstmt . set string ( 3 transport type . name (  )  )  ;  pstmt . set string ( 4 username )  ;  if  ( password  !  =  null )   {   string encrypted password =  auth factory . encrypt password ( password )  ;  pstmt . set string ( 5 encrypted password )  ;   }  else  {  pstmt . set null ( 5  types . varchar )  ;   }  if  ( nickname  !  =  null )   {  pstmt . set string ( 6 nickname )  ;   }  else  {  pstmt . set null ( 6  types . varchar )  ;   }  pstmt . set long ( 7 registration date . get time (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {  abort transaction = true ;  throw sqle ;   }  finally  {   db connection manager . close transaction connection ( pstmt con abort transaction )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on error return item ( null )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable .  <  integer > error ( new  test exception (  )  )  . buffer ( 2 1 )  . test (  )  . assert failure (  test exception . class )  ;   }  
public  list <  inet address >    (  )  {   list <  inet address >  list = new  array list <  inet address >  (  )  ;  try  {   enumeration <  network interface >  ifaces =  network interface . get network interfaces (  )  ;  while  ( ifaces . has more elements (  )  )   {   network interface iface = ifaces . next element (  )  ;   enumeration <  inet address >  iaddresses = iface . get inet addresses (  )  ;  while  ( iaddresses . has more elements (  )  )   {   inet address iaddress = iaddresses . next element (  )  ;  if  (  ! iaddress . is loopback address (  )  &&  ! iaddress . is link local address (  )  )   {  list . add ( iaddress )  ;   }   }   }   }  catch  (   exception e )   {   }  return list ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  subscription lambda subscriber < t >  ( s on subscribe on request on cancel )  )  ;   }  
public   (  socket s  socket i2ps  object slock byte[] initiali2p data byte[] initial socket data i2p tunnel runner .  fail callback on timeout )  {  this . s = s ;  this . i2ps = i2ps ;  this . slock = slock ;  this . initiali2p data = initiali2p data ;  this . initial socket data = initial socket data ;  this . on timeout = on timeout ;  last activity on =  - 1 ;  started on =  clock . get instance (  )  . now (  )  ;     log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  (    log . should log (  log . info )  )     log . info ( " outproxy runner started" )  ;     runner id =       runner id . increment and get (  )  ;  set name ( " outproxy runner "  +     runner id )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  test observer <  integer >  to = ps . retry (  functions . 
public  bit field   (  snark snark )  {   meta info metainfo = snark . get meta info (  )  ;  if  ( metainfo  =  =  null )  return null ;   properties config = get config ( snark )  ;   string bf = config . get property ( prop   meta   bitfield )  ;  if  ( bf  =  =  null )  return null ;  int len = metainfo . get pieces (  )  ;  if  ( bf . equals ( " . " )  )   {   bit field bitfield = new  bit field ( len )  ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )  bitfield . set ( i )  ;  return bitfield ;   }  byte[] bitfield =  base64 . decode ( bf )  ;  if  ( bitfield  =  =  null )  return null ;  if  ( bitfield . length * 8  <  len )  return null ;  return new  bit field ( bitfield len )  ;   }  
private void   (  output stream os )  throws io exception  {  os . write (  ( int ) ' ' )  ;   put . le short ( the position . x os )  ;   put . le short ( the position . y os )  ;   put . le short ( the width os )  ;   put . le short ( the height os )  ;  os . write ( is interlaced  ?  0x40 : 0 )  ;   }  
public  string   (  )  {  return " kademlia  store  send  failed" ;   }  
@ override protected void   ( final sam file header header final  file sam file )  {  io util . assert file is writable ( chart   output )  ;  final  list < sam read group record >  read groups = header . get read groups (  )  ;  if  ( read groups . size 
@ override public  iterator   (  )  {  return xpath . iterator (  )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public static i2cp message   (  input stream in )  throws io exception  i2cp message exception  {  int length ;  try  {  length =  ( int )  data helper . read long ( in 4 )  ;   }  catch  (   data format exception dfe )   {  throw new io exception ( " connection closed" )  ;   }  if  ( length  >  max   length )  throw new i2cp message exception ( " invalid message length specified" )  ;  try  {  int type =  ( int )  data helper . read long ( in 1 )  ;  i2cp message msg = create message ( type )  ;  msg . read message ( in length type )  ;  return msg ;   }  catch  (   data format exception dfe )   {  throw new i2cp message exception ( " error reading the message" dfe )  ;   }   }  
public  destination   (  )  {  return    msg . get destination (  )  ;   }  
@ test public void   (  )  {   runtime exception actual = exception logger . new exception ( test   message  runtime exception . class )  ;  assert equals ( test   message actual . get message (  )  )  ;   }  
private  max forwards header   (  )  throws io exception  {  if  ( max forwards header  !  =  null )   {  return max forwards header ;   }  try  {  max forwards header = header factory . create max forwards header ( max   forwards )  ;  return max forwards header ;   }  catch  (   invalid argument exception e )   {  throw new io exception ( "a problem occurred while creating  max forwards header "  +  e . get message (  )  )  ;   }   }  
@ test public void   (  )  throws sql exception  {   tuple4 <  integer  string  integer  integer >  result = db rule . get shared handle (  )  . create query ( "select * from something where id  =  2" )  . map to ( new  generic type <  tuple4 <  integer  
@ override public boolean   (  throwable e )  throws  exception  {  return e instanceof  test exception || e instanceof  composite exception ;   }  
public int[]   ( int sample time )  throws io exception  {  if  ( time remaining  <  =  0 )   {  return null ;   }  time remaining -  = sample time ;  int length = sample rate * sample time * channels  /  1000 ;  int[] linear data = new int[length] ;  for  ( int i = 0 ;  i  <  length ;  i +  =  ( 2 * channels )  )   {  int s =  ( int )  ( amplitude * volume *  math . sin ( sample * twopi * frequency  /  sample rate )  )  ;  linear data[i] = s ;  if  ( channels  =  =  2 )   {  linear data[i  +  1] = s ;   }  sample +  +  ;   }  return linear data ;   }  
public static boolean   ( double volume )  {  return volume  <  =  zero volume ;   }  
public   (  servlet context context  string context name  request proxy service request proxy service )  {  super ( context )  ;  this . target context = context name ;  this . proxy service = request proxy service ;  uri uri = null ;   string target host port = null ;  try  {  uri = new uri ( target context )  ;  target host port = uri . get host (  )   +  ":"  +  uri . get port (  )  ;   }  catch  (  uri syntax exception ex )   {  log . error ( " invalid target context: "  +  target context ex )  ;   }  this . target = target host port ;   }  
  (  single observer <  ?  super r >  actual  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper )  {  this . actual = actual ;  this . mapper = mapper ;   }  
@ test public void   (  )  {  final  test scheduler scheduler = new  test scheduler (  )  ;   rx java plugins . set computation scheduler handler ( new  function <  scheduler  scheduler >  (  )  {  @ override public  scheduler apply (   scheduler v )  thr
@ benchmark public void   (  blackhole bh )  {  observe on completable . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
@ override public int   (  )  {  return style . hash code (  )  ^ port ;   }  
public static  group element[][]   (  string file name )  {   eddsa named curve spec ed25519 =  eddsa named curve table . get by name ( "ed25519 - sha - 512" )  ;   curve curve = ed25519 . get curve (  )  ;   field field = curve . get field (  )  ;   group element[][] precmp = new  group element[32][8] ;   buffered reader file = null ;  int row = 0  col = 0 ;  try  {   input stream is =  precomputation test vectors . class . get resource as stream ( file name )  ;  if  ( is  =  =  null )  throw new io exception ( " resource not found: "  +  file name )  ;  file = new  buffered reader ( new  input stream reader ( is )  )  ;   string line ;  while  (  ( line = file . read line (  )  )   !  =  null )   {  if  ( line . equals ( "  }  " )  )  col +  = 1 ;  else if  ( line . equals ( " }  " )  )   {  col = 0 ;  row +  = 1 ;   }  else if  ( line . starts with ( "  {  " )  )   {   string ypx str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element ypx = field . from byte array (  utils . hex to bytes ( ypx str )  )  ;  line = file . read line (  )  ;   string ymx str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element ymx = field . from byte array (  utils . hex to bytes ( ymx str )  )  ;  line = file . read line (  )  ;   string xy2d str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element xy2d = field . from byte array (  utils . hex to bytes ( xy2d str )  )  ;  precmp[row][col] =  group element . precomp ( curve ypx ymx xy2d )  ;   }   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }  finally  {  if  ( file  !  =  null )  try  {  file . close (  )  ;   }  catch  (  io exception e )   {   }   }  return precmp ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout (  (  observable <  integer >  ) null new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   intege
@ override public  string   (  )  {  return  string . format ( " { %d byte literal ( file )  } " m size )  ;   }  
@ deprecated public boolean   (  )  {  return m shared preferences . get boolean ( confirm   send confirm   send   default )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   single . just ( 1 )  . do finally ( new  action (  )  {  @ override public void run (  )  throws  exception  {  throw new  test exception (  
@ jdbi constructor public   ( long id  string content )  {  set id ( id )  ;  set content ( content )  ;   }  
@ override public int   ( int requested mode )  {  if  (  ( requested mode & sync )   !  =  0 && fusion mode  =  =  sync )   {  return sync ;   }  return none ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer counter = new  atomic integer (  )  ;   observable <  string >  o =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscr
public void   (  string header )  {  if  ( header  =  =  null || header . trim (  )  . length (  )   =  =  0 )   {   jive globals . delete property ( http   bind   forwarded   server )  ;   }  else  {   jive globals . set property ( http   bind   forwarded   server header )  ;   }   }  
public   (  bi consumer <  ?  super t  ?  super  throwable >  on callback )  {  this . on callback = on callback ;   }  
public   (  peer peer  data input stream din )  {  this . peer = peer ;  this . din = din ;  last rcvd =  system . current time millis (  )  ;   }  
public  sub sidebar tag   (  )  {  return subsidebar tag ;   }  
@ benchmark public void   (  blackhole bh )  {  pipeline flowable . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
private void   (  peer profile p )  {  long min =  long . max   value ;  long t = p . get last heard about (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = p . get last send successful (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = p . get last send failed (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = p . get last heard from (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;   tunnel history th = p . get tunnel history (  )  ;  if  ( th  !  =  null )   {  t = th . get last agreed to (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = th . get last rejected critical (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = th . get last rejected bandwidth (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = th . get last rejected transient (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = th . get last rejected probabalistic (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;  t = th . get last failed (  )  ;  if  ( t  >  0 && t  <  min )  min = t ;   }  long fha = p . get first heard about (  )  ;  if  ( min  >  0 && min  <   long . max   value &&  ( fha  <  =  0 || min  <  fha )  )   {  p . set first heard about ( min )  ;  if  (    log . should debug (  )  )     log . debug ( " fixed up the fha time for "  +  p . get peer (  )  . to base64 (  )   +  " to " +   ( new  date ( min )  )  )  ;   }   }  
public final  disposable   (  )  {   connect consumer cc = new  connect consumer (  )  ;  connect ( cc )  ;  return cc . disposable ;   }  
private static void   (  byte array output stream out  string string )  throws  data format exception  io exception  {  if  ( string  =  =  null )   {  out . write ( 0 )  ;   }  else  {  byte[] raw = string . get bytes ( "utf - 8" )  ;  int len = raw . length ;  if  ( len  >  =  255 )   {  if  ( len  >  max   value   length )  throw new  data format exception ( max   value   length  +  " max  but this is "  +  len +  " [" +  string +  "]" )  ;  out . write ( 0xff )  ;   data helper . write long ( out 2 len )  ;   }  else  {  out . write ( len )  ;   }  out . write ( raw )  ;   }   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  completable   ( final  single source < t >  single )  {   object helper . require non null ( single "single is null" )  ;  return  rx java plugins . on assembly 
@ override protected  action   (  session data data )  {  return null ;   }  
public  router info   (  )  {  return    recipient ;   }  
private  string   ( final sam record record final  string tag )  {   string value = record . get string attribute ( tag )  ;  if  ( value  =  =  null )   {  throw new  picard exception ( " record: "  +  record . get read name (  )   +  " does have a value for tag: " +  tag )  ;   }  return value ;   }  
public long   (  )  throws io exception  {  return delegate . read long (  )  ;   }  
@ test public void   (  )  {  final  flowable <  string >  o1 =  flowable . unsafe create ( new  test error flowable ( "one" "two" "three" )  )  ;  final  flowable <  string >  o2 =  flowable . unsafe create ( new  test error flowable ( "four" "five" "six
  (  observer <  ?  super  observable < t >  >  actual long timespan  time unit unit  scheduler scheduler int buffer size )  {  super ( actual new  mpsc linked queue <  object >  (  )  )  ;  this . timespan = timespan ;  this . unit = unit ;  this . scheduler = scheduler ;  this . buffer size = buffer size ;   }  
@ override public boolean   (  )  {  return    size  <  =  0 ;   }  
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  proxy service name =  jive globals . get property ( "xmpp . proxy . service" "proxy" )  ;  routing table = server . get routing table (  )  ;  router = server . get pack
public synchronized int   (  )  {  return    alice port ;   }  
public static  < t > void   (  function <  observable < t >   ?  extends  completable source >  transform )  {   list <  throwable >  errors = track plugin errors (  )  ;  try  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   observable < t >  source = new  observable < t >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super t >  observer )  {  try  {   disposable d1 =  disposables . empty (  )  ;  observer . on subscribe ( d1 )  ;   disposable d2 =  disposables . empty (  )  ;  observer . on subscribe ( d2 )  ;  b[0] = d1 . is disposed (  )  ;  b[1] = d2 . is disposed (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }   }   ;   completable source out = transform . apply ( source )  ;  out . subscribe (  no op consumer . instance )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " first disposed ? " false b[0] )  ;  assert equals ( " second not disposed ? " true b[1] )  ;  assert error ( errors 0  illegal state exception . class " disposable already set ! " )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  finally  {   rx java plugins . reset (  )  ;   }   }  
public void   ( byte[] data )  {  if  ( data . length  >  max   length )  throw new  illegal argument exception (  )  ;     encrypted data = data ;   }  
  ( final int start final int stop )  {  this . start = start ;  this . stop = stop ;   }  
private void   ( final  file input file final  file file to compare final  string extension )  {  final  sam format converter sam format converter = new  sam format converter (  )  ;  final  list <  file >  sam files = new  array list <  file >  (  )  ;  final  validate sam file validate sam file = new  validate sam file (  )  ;  final  comparesa ms comparesa ms = new  comparesa ms (  )  ;  sam format converter . input = input file ;  try  {  sam format converter . output =  file . create temp file ( " sam file converter test . "  +  input file . get name (  )  extension )  ;  sam format converter . output . delete on exit (  )  ;   }  catch  (  final io exception e )   {  e . print stack trace (  )  ;   }  sam format converter . do work (  )  ;  validate sam file . input = sam format converter . output ;  assert equals ( validate sam file . do work (  )  0 )  ;  sam files . add ( sam format converter . output )  ;  sam files . add ( file to compare )  ;  comparesa ms . sam files = sam files ;  comparesa ms . do work (  )  ;  assert true ( comparesa ms . are equal (  )  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . just ( 1 2 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single element (  )  
public  string   (  )  {  load config (  )  ;   string filename = properties . get property ( get book (  )   +  "   addressbook" )  ;   file path = new  file ( addressbook dir (  )  filename )  ;  try  {  return path . get canonical path (  )  ;   }  catch  (  io exception ioe )   {   }  return filename ;   }  
public void   ( int code )  {  set status code ( code )  ;  set content length ( 0 )  ;   }  
@ test public void   (  )  {   flowable <  movie >  o1 =  flowable . just ( new  horror movie (  )  new  movie (  )  )  ;   flowable <  media >  o2 =  flowable . just ( new  media (  )  new  horror movie (  )  )  ;   list <  media >  values =  flowable . 
public boolean   (  )  {  return stop ;   }  
public boolean   (  string name )  {  return  ( get device ( name )   !  =  null )   ?  true : false ;   }  
@ override protected void   (  single observer <  ?  super t >  observer )  {  source . subscribe ( new  switch if empty maybe observer < t >  ( observer other )  )  ;   }  
  (  observer <  ?  super t >  actual  behavior subject < t >  state )  {  this . actual = actual ;  this . state = state ;   }  
public void   (  string from recording file )  {  this . from recording file = from recording file ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
public   (  inet address local address )  {  this . local address = local address ;  register processing = new  register processing ( this )  ;  sip security manager = new  sip security manager (  )  ;   }  
@ override public void   ( i2np message msg  hash to router  tunnel id to tunnel )  {  int size =  math . max ( msg . get message size (  )  1024  /  2 )  ;  if  (    context . tunnel dispatcher (  )  . should drop participating message (  tunnel dispatch
public static final int   (  string url str )  {  try  {  url url = new url ( url str )  ;  int port = url . get port (  )  ;  if  ( port  <  =  0 )  port = default   port ;  return port ;   }  catch  (   exception e )   {  return default   port ;   }   }  
public synchronized  artifact directory watcher   (  )  {  return dir watcher ;   }  
@ override public int   ( byte target[] int offset )  {  target[offset] = 0 ;  return 1 ;   }  
@ override public boolean   (  object other )  {  if  (  !  ( other instanceof  parameterized type )  )   {  return false ;   }   parameterized type that =  (  parameterized type ) other ;  return get raw type (  )  . equals ( that . get raw type (  )  ) 
public  string   (  )  {  return sample ;   }  
@ override public void   (  throwable t )  {  target . on error ( t )  ;  latch . count down (  )  ;   }  
public  map <  string  string >    (  properties options )  {  if  (  !    file . exists (  )  )  return  collections . empty map (  )  ;   string search opt = null ;   string starts with = null ;  if  ( options  !  =  null )   {  search opt = options . get property ( "search" )  ;  starts with = options . get property ( "starts with" )  ;   }   buffered reader in = null ;  get read lock (  )  ;  try  {  in = new  buffered reader ( new  input stream reader ( new  file input stream (    file )  "utf - 8" )  16 * 1024 )  ;   string line = null ;   map <  string  string >  rv = new  hash map <  string  string >  (  )  ;  while  (  ( line = in . read line (  )  )   !  =  null )   {  if  ( line . length (  )   <  =  0 )  continue ;  if  ( starts with  !  =  null )   {  if  ( starts with . equals ( "[0 - 9]" )  )   {  if  ( line . char at ( 0 )   <  '0' || line . char at ( 0 )   >  '9' )  continue ;   }  else if  (  ! line . starts with ( starts with )  )   {  continue ;   }   }  if  ( line . starts with ( "#" )  )  continue ;  if  ( line . index of ( '#' )   >  0 )  line = line . substring ( 0 line . index of ( '#' )  )  . trim (  )  ;  int split = line . index of ( ' = ' )  ;  if  ( split  <  =  0 )  continue ;   string key = line . substring ( 0 split )  ;  if  ( search opt  !  =  null && key . index of ( search opt )   <  0 )  continue ;   string b64 = line . substring ( split  +  1 )  ;  if  ( b64 . length (  )   <  387 )  continue ;  rv . put ( key b64 )  ;   }  if  ( search opt  =  =  null && starts with  =  =  null )   {     last write =    file . last modified (  )  ;     size = rv . size (  )  ;   }  return rv ;   }  catch  (  io exception ioe )   {     log . error ( "get entries error" ioe )  ;  return  collections . empty map (  )  ;   }  finally  {  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  release read lock (  )  ;   }   }  
@ test public void   (  )  throws  exception  {   prepared batch b = db rule . open handle (  )  . prepare batch ( "insert into something  ( id  name )  values  (  ?   ?  ) " )  ;  b . add ( 0 "a" )  ;  b . add ( 0 "a" )  ;  assert that exception of type 
public  map <  string  tracker entry >    (  )  {  return relay entries ;   }  
public void   (  )  {  byte[] buf = new byte[max   size] ;   datagram packet pack = new  datagram packet ( buf buf . length )  ;  while  ( true )   {  try  {  this . sock . receive ( pack )  ;  byte[] nbuf = new byte[pack . get length (  ) ] ;   system . arraycopy ( pack . get data (  )  0 nbuf 0 nbuf . length )  ;  this . sink . send ( null nbuf )  ;   }  catch  (   exception e )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  ( log . should warn (  )  )  log . warn ( "error sending" e )  ;  break ;   }   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  object >  ts = new  test subscriber <  object >  ( 0l )  ;   flowable . empty (  )  . parallel ( 1 )  . run on (  immediate thin scheduler . instance )  . filter (  fun
@ test public void   (  )  {   observable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  return  completable . complete
@ override public void   (  )  {   log . debug ( " removing my created listener for jabber:iq:register .   component "  +  subdomain )  ;  interceptor manager . remove interceptor ( interceptor )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "bb" "ccc" "dddd" )  ;   function <  string  string >  duplicate err = new  function <  string  string >  (  )  {  @ override public  string apply (   string t1 )  { 
@ test ( expected exceptions =  illegal state exception . class )  public void   (  )  {  final  test mergeable metric illegal illegal1 = new  test mergeable metric illegal (  )   illegal2 = new  test mergeable metric illegal (  )  ;  illegal1 . merge ( i
public void   (  )  {  for  ( int i = 1 ;  i  <  =  1024 ;  i +  +  )   {  test batched ( i false false 1024 false false 1024 false false )  ;  test batched ( i true false 1024 false false 1024 false false )  ;  test batched ( i true true 1024 false false 1024 false false )  ;  test batched ( i false false 1024 true false 1024 false false )  ;  test batched ( i true false 1024 true false 1024 false false )  ;  test batched ( i true true 1024 true false 1024 false false )  ;  test batched ( i false false 1024 true true 1024 false false )  ;  test batched ( i true false 1024 true true 1024 false false )  ;  test batched ( i true true 1024 true true 1024 false false )  ;  test batched ( i false false 1024 false false 1024 true false )  ;  test batched ( i true false 1024 false false 1024 true false )  ;  test batched ( i true true 1024 false false 1024 true false )  ;  test batched ( i false false 1024 true false 1024 true false )  ;  test batched ( i true false 1024 true false 1024 true false )  ;  test batched ( i true true 1024 true false 1024 true false )  ;  test batched ( i false false 1024 true true 1024 true false )  ;  test batched ( i true false 1024 true true 1024 true false )  ;  test batched ( i true true 1024 true true 1024 true false )  ;  test batched ( i false false 1024 false false 1024 true true )  ;  test batched ( i true false 1024 false false 1024 true true )  ;  test batched ( i true true 1024 false false 1024 true true )  ;  test batched ( i false false 1024 true false 1024 true true )  ;  test batched ( i true false 1024 true false 1024 true true )  ;  test batched ( i true true 1024 true false 1024 true true )  ;  test batched ( i false false 1024 true true 1024 true true )  ;  test batched ( i true false 1024 true true 1024 true true )  ;  test batched ( i true true 1024 true true 1024 true true )  ;   }   }  
public   (  observable source < t >  observable )  {  this . observable = observable ;   }  
public static int   ( final double[] nums )  {  double min = nums[0] ;  int index = 0 ;  for  ( int i = 1 ;  i  <  nums . length ;   +  + i )   {  if  ( nums[i]  <  min )   {  min = nums[i] ;  index = i ;   }   }  return index ;   }  
public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
@ test public void   (  )  {   maybe subject <  object >  other =  maybe subject . create (  )  ;   test observer <  object >  to =  observable . empty (  )  . concat with ( other )  . test (  )  ;  assert true ( other . has observers (  )  )  ;  to . can
  ( long keep alive time  time unit unit  thread factory thread factory )  {  this . keep alive time = unit  !  =  null  ?  unit . to nanos ( keep alive time )  : 0l ;  this . expiring worker queue = new  concurrent linked queue <  thread worker >  (  )  ;  this . all workers = new  composite disposable (  )  ;  this . thread factory = thread factory ;   scheduled executor service evictor = null ;   future <  ?  >  task = null ;  if  ( unit  !  =  null )   {  evictor =  executors . new scheduled thread pool ( 1 evictor   thread   factory )  ;  task = evictor . schedule with fixed delay ( this this . keep alive time this . keep alive time  time unit . nanoseconds )  ;   }  evictor service = evictor ;  evictor task = task ;   }  
@ xml element wrapper ( name = "outcast groups" )  @ xml element ( name = "outcast group" )  public  list <  string >    (  )  {  return outcast groups ;   }  
@ override public final void   ( long n )  {   subscription helper . deferred request ( subscription missed requested n )  ;   }  
@ test @ ignore ( "take ( 0 )  is now empty (  )  and doesn't even subscribe to the original source" )  public void   (  )  {  final  atomic boolean subscribed = new  atomic boolean ( false )  ;  final  disposable bs =  disposables . empty (  )  ;   obser
@ override public void   (  )  throws  unavailable exception  {  super . init (  )  ;     dir allowed = get init boolean ( "dir allowed"    dir allowed )  ;   string rb = get init parameter ( "resource base" )  ;  if  ( rb  !  =  null )   {  try  {     re
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . using (  functions . just callable ( 1 )   functions . just function ( new  observable <  integer >  (  )  {  @ override protecte
public void   (  search listener listener )  {  device search listener list . remove ( listener )  ;   }  
private boolean   (  file ks  set <  string >  alt names )  {  if  ( ks . exists (  )  )   {   string kspw =    context . get property ( prop   keystore   password  key store util . default   keystore   password )  ;   key store util . log cert expiration ( ks kspw 180 * 24 * 60* 60* 1000l )  ;  boolean rv =    context . get property ( prop   key   password )   !  =  null ;  if  (  ! rv )   system . err . println ( " console ssl error  must set "  +  prop   key   password  +  " in " +   ( new  file (    context . get config dir (  )  "router . config" )  )  . get absolute path (  )  )  ;  return rv ;   }  return create key store ( ks alt names )  ;   }  
public void   (  string value )  {  set header ( http . nt value )  ;   }  
public  string   (  )  {  return code ;   }  
  (  observer <  ?  super t >  actual  observable source <  ?  >  other )  {  super ( actual other )  ;  this . wip = new  atomic integer (  )  ;   }  
@ test public void   (  )  {  assert false ( " should reject invalid content type" request pool for xml . accepts ( "" json xml "" )  )  ;   }  
@ test public void   (  )  throws  exception  {  int c = h . execute ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  ;  assert that ( c )  . is equal to ( 1 )  ;   }  
private int   (  )  throws io exception  {  verify header (  )  ;  return version   offset  +     version length  +     signer length ;   }  
public void   (  )  {  bb iterator = null ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   function <  integer  flowable <  integer >  >  delay func = new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowa
public void   ( byte target[] int target offset )  {  int read offset = read body offset (  )   +  1  +  2 ;  int len = read current fragment size (  )  ;   system . arraycopy (    message read offset target target offset len )  ;   }  
@ override public  servlet input stream   (  )  throws io exception  {  if  ( is get reader called )   {  throw new  illegal state exception ( "get reader (  )  has already been called" )  ;   }  is get input stream called = true ;  return get compressing
@ override public  parallel failure handling   (  long n  throwable e )  throws  exception  {  throw new  test exception (  )  ;   }  
@ override public void   (  bundle saved instance state )  {  super . on activity created ( saved instance state )  ;  get view (  )  ;  final  setup data fragment setup data =  (  (  setup data fragment .  setup data container ) get activity (  )  )  . g
@ test public void   (  )  {   observable . range ( 1 1024 )  . concat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . 
@ small test public void   (  )  throws  exception  {  final  file directory = new  isolated context ( new  mock content resolver (  )  get context (  )  )  . get files dir (  )  ;  final  file created1 =  utility . create unique file internal ( get true 
public   (  transport buddy manager <  same time buddy >  manager  string uin  string nickname  string group )  {  super ( manager uin nickname null )  ;  if  ( group  !  =  null )   {  this . set groups (  arrays . as list ( group )  )  ;   }   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ override public  auth provider   (  string username )  {  final jid jid = xmpp server . get instance (  )  . createjid ( username null )  ;  final boolean is admin =  admin manager . get admin provider (  )  . get admins (  )  . contains ( jid )  ;  if 
void   (  string router version )  {     router supports fast receive =    context . is router context (  )  ||  ( router version  !  =  null && router version . length (  )   >  0 &&  version comparator . comp ( router version min   fast   version )   >  =  0 )  ;     router supports host lookup =    context . is router context (  )  || test   lookup ||  ( router version  !  =  null && router version . length (  )   >  0 &&  version comparator . comp ( router version min   host   lookup   version )   >  =  0 )  ;     router supports subsessions =    context . is router context (  )  ||  ( router version  !  =  null && router version . length (  )   >  0 &&  version comparator . comp ( router version min   subsession   version )   >  =  0 )  ;  synchronized  (    state lock )   {  if  (    state  =  =   state . opening )   {  change state (  state . gotdate )  ;   }   }   }  
public int   (  )  {  return 0x7fffffff ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public vo
@ override public void   (  throwable e )  {  s . on error ( e )  ;   }  
private static final boolean   (  string signed file  string out file boolean verify sig  string pk file )  {   input stream in = null ;  try  {  su3 file file = new su3 file ( signed file )  ;  if  ( pk file  !  =  null )  file . set public key certificate ( new  file ( pk file )  )  ;  file . set verify signature ( verify sig )  ;   file out = new  file ( out file )  ;  boolean ok = file . verify and migrate ( out )  ;  if  ( ok )   system . out . println ( " file extracted  ( signed by "  +  file . get signer string (  )   +  ' ' +  file .    sig type +  ' ) ' )  ;  else  system . out . println ( " signature invalid  ( signed by "  +  file . get signer string (  )   +  ' ' +  file .    sig type +  ' ) ' )  ;  return ok ;   }  catch  (  io exception ioe )   {   system . out . println ( " error extracting from file '"  +  signed file  +  "'" )  ;  ioe . print stack trace (  )  ;  return false ;   }   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   flowable . from publisher ( new  publisher <  object >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  object >  s )  
public void   ( int family code boolean pending )  {  if  ( pending )   {  snacs . put ( family code new  array list <  snac request >  (  )  )  ;   }  else  {  snacs . remove ( family code )  ;   }   }  
public boolean   (  )  {  return wildcard ;   }  
public void   (  occupant left event event )  {  muc role leave role = event . get role (  )  ;  if  ( leave role  =  =  null )   {  return ;   }  lock . write lock (  )  . lock (  )  ;  try  {  remove occupant role ( leave role event . is originator (  )  )  ;  if  ( occupants by fulljid . is empty (  )  &&  ! is persistent (  )  )   {  end time =  system . current time millis (  )  ;  if  ( event . is originator (  )  )   {  muc service . remove chat room ( name )  ;  muc event dispatcher . room destroyed ( get role (  )  . get role address (  )  )  ;   }   }  if  ( occupants by fulljid . is empty (  )  )   {  set empty date ( new  date (  )  )  ;   }   }  finally  {  lock . write lock (  )  . unlock (  )  ;   }   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
private boolean   (  )  {  return get context (  )  . get property ( prop   publish   unreachable default   publish   unreachable )  ;   }  
@ override public void   ( byte[] bytes int i int i1 )  throws io exception  {  for  (   output stream os : streams to split to )   {  os . write ( bytes i i1 )  ;   }   }  
private static  string   (  string type )  {  return uri with column ( type  base columns .    id )  ;   }  
private void   (  )  {  if  (  ! m loaded )  return ;  enable next button (  !  text utils . is empty ( m username view . get text (  )  )  && m authentication view . get auth valid (  )  &&  utility . is server name valid ( m server view ) &&  utility . is port field valid ( m port view )  )  ;  m cache login credential = m username view . get text (  )  . to string (  )  . trim (  )  ;   }  
public void   ( final  tracker entry entry )  {  entries . put ( entry . get jid (  )  entry )  ;   }  
@ override public int   (  )  {  return  objects . hash ( id name )  ;   }  
@ override public void   (  )  {  poll (  )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  throws  interrupted exception  {  final  atomic reference <  string >  name = new  atomic reference <  string >  (  )  ;  final  atomic reference <  throwable >  err = new  atomic reference <  throwable >  ( 
public   ( pkcs8 encoded key spec spec )  {  throw new  unsupported operation exception ( "todo" )  ;   }  
static  < t >  sql array type factory   (  class < t >  type  string sql type name )  {   sql array type < t >  array type = new  vendor supported array type <  >  ( sql type name )  ;  return  ( t ctx )   -  >  t . equals ( type )   ?   optional . of ( array type )  :  optional . empty (  )  ;   }  
public void   (  string ip )  {  this . get device data (  )  . set multicasti pv6 address ( ip )  ;   }  
@ test public void   (  )  {  final  group element t =  group element . precomp ( curve one one zero )  ;  assert that ( t . curve is ( equal to ( curve )  )  )  ;  assert that ( t . repr is (  group element .  representation . precomp )  )  ;  assert tha
@ override public void   (  )  {  s . dispose (  )  ;   }  
private void   (  uri uri )  {   string id = uri . get last path segment (  )  ;   message msg =  message . restore message with id ( get context (  )   long . parse long ( id )  )  ;  if  ( msg  !  =  null )   {  notifyui conversation mailbox ( msg . m mailbox key )  ;   }   }  
public  string   (  )  {  return home zip ;   }  
void   (  )  {   disposable helper . dispose ( timer )  ;   }  
public  text builder   (  string text )  {  m builder . append ( text )  ;  return this ;   }  
public int   (  )  {  synchronized  (    servers )   {  return    servers . size (  )  ;   }   }  
@ override public  conversation   (  long conversation id )  {  throw new  unsupported operation exception ( "mam - muc cannot perform this operation" )  ;   }  
public static void   (  )  {  content   uri =  uri . parse (  email content . content   uri  +  " / message" )  ;  content   uri   limit   1 = uri with limit ( content   uri 1 )  ;  synced   content   uri =  uri . parse (  email content . content   uri  +  " / synced message" )  ;  selected   message   content   uri =  uri . parse (  email content . content   uri  +  " / message by selection" )  ;  deleted   content   uri =  uri . parse (  email content . content   uri  +  " / deleted message" )  ;  updated   content   uri =  uri . parse (  email content . content   uri  +  " / updated message" )  ;  notifier   uri =  uri . parse (  email content . content   notifier   uri  +  " / message" )  ;   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . concat with (  flowable . range ( 0  ( int ) elements )  )  . distinct (  )  ;   }  
private static final  string   ( boolean optimized )  {   string s append ;  if  ( optimized )   {  if  ( scpu type  =  =  null )  return null ;  if  ( scpu type . equals ( jbigi   optimization   k6   3 )  &&  !    is win )  s append = jbigi   optimization   k6   2 ;  else if  ( scpu type . equals ( jbigi   optimization   pentium2 )  &&    is sunos &&    isx86 )  s append = jbigi   optimization   pentium3 ;  else if  ( scpu type . equals ( jbigi   optimization   viac32 )  )  s append = jbigi   optimization   pentium3 ;  else s append = scpu type ;   }  else  {  s append = "none" ;   }  return s append ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test subscriber <  integer >  ts =  maybe . concat array (  maybe . just ( 1 )   maybe . just ( 2 )
@ test public void   (  )  {   completable . amb ( new  iterable iterator next throws (  )  )  . test (  )  . assert error (  test exception . class )  ;   }  
@ override @ visible for testing public boolean   (  )  {  return m transport . is open (  )  ;   }  
@ override public int   (  )  throws  messaging exception  {  check open (  )  ;  try  {  int unread message count = 0 ;  final  list <  imap response >  responses = m connection . execute simple command (  string . format (  locale . us  imap constants .
@ override public  set <  entry <  string  string >  >    (  )  {  return null ;   }  
@ test public void   (  )  {   single . from publisher (  flowable . just ( 1 )  )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   list <  string >  values =  flowable . just ( "one" "two" )  . start with array ( "zero" )  . to list (  )  . blocking get (  )  ;  assert equals ( "zero" values . get ( 0 )  )  ;  assert equals ( "two" values . get ( 2 )  )
public  long   (  )  {  return    synchronization source ;   }  
@ test public void   (  )  throws  exception  {  final  collection <  string >  result =  encryption artifact factory . get default protocols (  )  ;   assert . assert false ( result . is empty (  )  )  ;   }  
public static int   ( final byte[] b )  {  int a = b[0] & 0xff ;  int aa = b[1] & 0xff ;  return  (  ( a  <  <  8 )   +  aa )  ;   }  
@ override protected void   (  observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 1 )  ;  observer . on complete (  )  ;  observer . on next ( 2 )  ;  observer . on error ( new  
  (  completable observer s )  {  this . s = s ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  functions . empty consumer (  )   functions . empty consumer (  )  null )  ;   }  
void   ( ntcp connection con )  {     establishing . add ( con )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . concat map single delay error ( new  function <  integer  single source <  ?  extends  object >  >  (  )  {  @ override public  single source <  ?  extends  object >  apply (   integer v )  throws
public   (  string message )  {  super ( message )  ;   }  
public static boolean   (  object o )  {  return o instanceof  subscription notification ;   }  
@ override public boolean   ( jid requester )  {  return super . has permission ( requester )  ||  internal component manager . get instance (  )  . has component ( requester )  ;   }  
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . hide (  )  . concat map eager ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override pu
@ override protected  scheduler   (  )  {  return  schedulers . from ( executor )  ;   }  
public  relay request reader   (  )  {  return    relay request reader ;   }  
@ override public void   (  )  {  try  {  if  (  ! is destroyed (  )  && m file . exists (  )  )   {  m file . delete (  )  ;   }   }  catch  (   runtime exception re )   {   log utils . w (  logging . log   tag " failed to remove temp file: "  +  re . ge
private static boolean   ( int value )  {  return value  =  =   - 1 ;   }  
@ test public void   (  )  {   observable . empty (  )  . element at or error ( 0 )  . test (  )  . assert no values (  )  . assert error (  no such element exception . class )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . take last ( 1 )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ before public void   (  )  {  observer =  test helper . mock observer (  )  ;  observer2 =  test helper . mock observer (  )  ;  scheduler = new  test scheduler (  )  ;   }  
public void   (  string path  file dir )  {  stop thread (  )  ;  try  {  node process =  runtime . get runtime (  )  . exec ( path null dir )  ;   log . info ( " started  node" )  ;  input = new  buffered reader ( new  input stream reader ( node process . get input stream (  )  )  )  ;  error = new  buffered reader ( new  input stream reader ( node process . get error stream (  )  )  )  ;   log . info ( " started  node  console  reader" )  ;   }  catch  (   exception e )   {   log . info ( " started  node exception "  +  e )  ;   }  thread = new  thread ( this )  ;  thread . start (  )  ;   }  
@ override public void   (  packet packet  string subdomain  string to  string from )  throws  packet rejected exception  {   message message =  (  message ) packet ;   log . debug ( " intercepted spectrum message: "  +  message . to string (  )  )  ;   s
private void   (  packet packet )  {  xmpp server server = xmpp server . get instance (  )  ;  jid from = packet . get from (  )  ;  jid to = packet . get to (  )  ;  if  (  ! server . is local ( from )  &&  ! xmpp server . get instance (  )  . matches component ( from )  &&  ! server . is local ( to ) &&  ! xmpp server . get instance (  )  . matches component ( to )  )   {  return ;   }  final  set <  packet >  replies = new  hash set <  >  (  )  ;  try  {  if  ( packet instanceof iq )   {  iq reply = new iq (  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( from )  ;  reply . set from ( to )  ;  reply . set child element (  (  ( iq ) packet )  . get child element (  )  . create copy (  )  )  ;  reply . set error (  packet error .  condition . remote   server   not   found )  ;  replies . add ( reply )  ;   }  else if  ( packet instanceof  presence )   {  final  list < jid >  routes = new  array list <  >  (  )  ;  if  ( from . get resource (  )   =  =  null || from . get resource (  )  . trim (  )  . length (  )   =  =  0 )   {  routes . add all ( routing table . get routes ( from null )  )  ;   }  else  {  routes . add ( from )  ;   }  for  (  jid route : routes )   {   presence reply = new  presence (  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( route )  ;  reply . set from ( to )  ;  reply . set error (  packet error .  condition . remote   server   not   found )  ;  replies . add ( reply )  ;   }   }  else if  ( packet instanceof  message )   {   message reply = new  message (  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( from )  ;  reply . set from ( to )  ;  reply . set type (  (  (  message ) packet )  . get type (  )  )  ;  reply . set thread (  (  (  message ) packet )  . get thread (  )  )  ;  reply . set error (  packet error .  condition . remote   server   not   found )  ;  replies . add ( reply )  ;   }  final  session manager session manager =  session manager . get instance (  )  ;  for  (  final  packet reply : replies )   {  try  {  final  client session session = session manager . get session ( reply . get to (  )  )  ;   interceptor manager . get instance (  )  . invoke interceptors ( reply session false false )  ;  routing table . route packet ( reply . get to (  )  reply true )  ;   interceptor manager . get instance (  )  . invoke interceptors ( reply session false true )  ;   }  catch  (   packet rejected exception ex )   {   log . debug ( " reply got rejected by an interceptor: " reply ex )  ;   }   }   }  catch  (   exception e )   {   log . warn ( " an exception occurred while trying to returning a remote - server - not - found error  ( for domain ' {  } ' )  to the original sender .   original packet:  {  } " domain packet e )  ;   }   }  
public static  language   ( final  string candy code )  {  for  (  final  language language : values (  )  )   {  if  ( language . get code (  )  . equals ignore case ( candy code )  )   {  return language ;   }   }  return null ;   }  
@ override public  observable <  integer >    (  integer v )  throws  exception  {  return  observable . just ( v  +  1 )  . hide (  )  ;   }  
@ override public boolean   ( final  throwable throwable )  throws  exception  {  return  !  ( throwable instanceof  illegal argument exception )  ;   }  
public   ( i2p app context context )  {  super ( context )  ;   }  
private int   ( y lab thisy lab )  {  int pixel = this . get pixels per gridline ( thisy lab )  ;  int font height =  ( int )  math . ceil ( worker . get font height ( gdef . get font ( fonttag   axis )  )  )  ;  for  ( int j = 0 ;  j  <  4 ;  j +  +  )   {  if  ( pixel * thisy lab . lfac[j]  >  =  2 * font height )   {  return thisy lab . lfac[j] ;   }   }  return  - 1 ;   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . on error resume next (  functions . just function (  maybe . just ( 1 )  )  )  . test (  )  . assert result ( 1 )  ;   }  
public void   ( byte payload )  {  byte mark =  ( byte )  ( buffer[1] & mark   bit )  ;  buffer[1] =  ( byte )  ( payload | mark )  ;   }  
@ override public boolean   (  )  {  return io session . get filter chain (  )  . contains ( tls   filter   name )  ;   }  
@ override protected  map <  string  string >    (  remote behavior remote behavior )  {   map <  string  string >  headers = super . get headers ( remote behavior )  ;  headers . put (  extended http header . x   ttl  string . value of (  time unit . sec
private  agent session   (  string initial agent  string ignore agent  offer offer )  {   agent session best session ;  if  ( initial agent  !  =  null )   {  final  agent session list agent session list = queue . get agent session list (  )  ;  for  (   agent session agent session : agent session list . get agent sessions (  )  )   {   string session agent = agent session . get agent (  )  . get agentjid (  )  . to barejid (  )  ;  boolean match = session agent . starts with ( initial agent . to lower case (  )  )  ;   workgroup workgroup = offer . get request (  )  . get workgroup (  )  ;  if  ( agent session . is available to chat (  )  && agent session . get current chats ( workgroup )   <  agent session . get max chats ( workgroup )  && match )   {  best session = agent session ;   log . debug ( "rr  -   initial agent: "  +  best session . getjid (  )   +  " will receive offer for request: " +  offer . get request (  )  )  ;  return best session ;   }   }   }  final  agent session list agent session list = queue . get agent session list (  )  ;  final  list <  agent session >  possible sessions = new  array list <  agent session >  (  )  ;  for  (   agent session agent session : agent session list . get agent sessions (  )  )   {   string session agent = agent session . get agent (  )  . get agentjid (  )  . to barejid (  )  ;  boolean ignore = ignore agent  !  =  null && session agent . starts with ( ignore agent . to lower case (  )  )  ;  if  (  ! ignore && validate agent ( agent session offer )  )   {  possible sessions . add ( agent session )  ;   }   }  if  ( possible sessions . size (  )   >  0 )   {   agent session s = agent selector . best agent from ( possible sessions offer )  ;   log . debug ( "rr  -   agent selected: "  +  s . getjid (  )   +  " for receiving offer for request: " +  offer . get request (  )  )  ;  return s ;   }  return null ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  ts . await count ( 0  test wait strategy . sleep   1ms 0 )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . merge delay error ( new  iterable <  publisher <  object >  >  (  )  {  @ override public  iterator <  publisher <  object >  >  iterator (  )  {  return null ;   } 
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public void   ( long log id )  {  this . log id = log id ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  {  return just1 ;   }   }   ne
@ override public boolean   ( boolean forced )  {  this . server . stop (  )  ;  this . multi . stop (  )  ;  return super . close ( forced )  ;   }  
private boolean   ( boolean recheck )  throws io exception  {     check progress . set ( 0 )  ;  boolean resume = false ;     probably complete = true ;  int need = metainfo . get pieces (  )  ;   bit field bfield ;  if  ( recheck )   {  bfield = new  bit field ( need )  ;   }  else  {  bfield = bitfield ;   }  long length progress = 0 ;  for  (   torrent file tf :    torrent files )   {  long length = tf . ra ffile . length (  )  ;  length progress +  = tf . length ;  if  ( tf . ra ffile . exists (  )  && length  =  =  tf . length )   {  if  ( listener  !  =  null )  listener . storage allocated ( this length )  ;     check progress . set ( 0 )  ;  resume = true ;   }  else if  ( length  =  =  0 )   {  changed = true ;  synchronized  ( tf )   {  allocate file ( tf )  ;  try  {  tf . closeraf (  )  ;   }  catch  (  io exception ioe )   {   }   }  if  (  ! resume )     check progress . set (  ( int )  ( pieces * length progress  /  total   length )  )  ;   }  else  {   string msg = " file '"  +  tf . name  +  "' exists  but has wrong length  ( expected " +  tf . length +  " but found " +  length +  " )   -  repairing corruption" ;  if  ( listener  !  =  null )  listener . add message ( msg )  ;     log . error ( msg )  ;  changed = true ;  resume = true ;     check progress . set ( 0 )  ;     probably complete = false ;  synchronized  ( tf )   {   random access file raf = tf . checkraf (  )  ;  raf . set length ( tf . length )  ;  try  {  tf . closeraf (  )  ;   }  catch  (  io exception ioe )   {   }   }   }   }  if  ( resume )   {  byte[] piece = new byte[piece   size] ;  int file = 0 ;  long file end =    torrent files . get ( 0 )  . length ;  long piece end = 0 ;  for  ( int i = 0 ;  i  <  pieces ;  i +  +  )   {     check progress . set ( i )  ;  int length = get unchecked piece ( i piece )  ;  boolean correct hash = metainfo . check piece ( i piece 0 length )  ;  piece end +  = length ;  while  ( file end  <  =  piece end )   {   torrent file tf =    torrent files . get ( file )  ;  try  {  tf . closeraf (  )  ;   }  catch  (  io exception ioe )   {   }  if  (  +  + file  >  =     torrent files . size (  )  )  break ;  file end +  =    torrent files . get ( file )  . length ;   }  if  ( correct hash )   {  bfield . set ( i )  ;  need -  -  ;   }  if  ( listener  !  =  null )  listener . storage checked ( this i correct hash )  ;   }   }     check progress . set ( pieces )  ;     probably complete = complete (  )  ;  needed = need ;  boolean rv = false ;  if  ( recheck )   {  synchronized  ( bitfield )   {  rv =  ! bfield . equals ( bitfield )  ;  bitfield = bfield ;   }   }  if  ( listener  !  =  null )   {  listener . storage all checked ( this )  ;  if  ( needed  <  =  0 )  listener . storage completed ( this )  ;   }  return rv ;   }  
private static ssl socket factory   ( i2p app context context boolean load system certs  string relative cert path )  throws  general security exception  {   log log = context . log manager (  )  . get log ( i2pssl socket factory . class )  ;   key store ks ;  if  ( load system certs )   {  ks =  key store util . load system key store (  )  ;  if  ( ks  =  =  null )  throw new  general security exception ( " key  store init error" )  ;   }  else  {  try  {  ks =  key store . get instance (  key store . get default type (  )  )  ;  ks . load ( null "" . to char array (  )  )  ;   }  catch  (  io exception ioe )   {  throw new  general security exception ( " key  store init error" ioe )  ;   }   }   file dir = new  file ( context . get config dir (  )  relative cert path )  ;  int adds =  key store util . add certs ( dir ks )  ;  int total adds = adds ;  if  ( adds  >  0 )   {  if  ( log . should log (  log . info )  )  log . info ( " loaded "  +  adds  +  " trusted certificates from " +  dir . get absolute path (  )  )  ;   }   file dir2 = new  file ( context . get base dir (  )  relative cert path )  ;  if  (  ! dir . get absolute path (  )  . equals ( dir2 . get absolute path (  )  )  )   {  adds =  key store util . add certs ( dir2 ks )  ;  total adds +  = adds ;  if  ( adds  >  0 )   {  if  ( log . should log (  log . info )  )  log . info ( " loaded "  +  adds  +  " trusted certificates from " +  dir . get absolute path (  )  )  ;   }   }  if  ( total adds  >  0 || load system certs )   {  if  ( log . should log (  log . info )  )  log . info ( " loaded total of "  +  total adds  +  " new trusted certificates" )  ;   }  else  {   string msg = " no trusted certificates loaded  ( looked in "  +  dir . get absolute path (  )   +   ( dir . get absolute path (  )  . equals ( dir2 . get absolute path (  )  )   ?  "" :  ( " and "  +  dir2 . get absolute path (  )  )  )  +  "  ssl connections will fail .  " +  " copy the cert in " +  relative cert path +  " from the router to the directory . " ;  throw new  general security exception ( msg )  ;   }  ssl context sslc = ssl context . get instance ( "tls" )  ;   trust manager factory tmf =  trust manager factory . get instance (  trust manager factory . get default algorithm (  )  )  ;  tmf . init ( ks )  ;  sslc . init ( null tmf . get trust managers (  )  context . random (  )  )  ;  return sslc . get socket factory (  )  ;   }  
@ override public void   ( final boolean self change )  {   email content content = m content . get (  )  ;  if  ( content  !  =  null )   {  content . on change ( false )  ;   }   }  
@ test public void   (  )  throws  exception  {   out parameters ret = h . create call ( " ?   =  call to   degrees (  ?  ) " )  . register out parameter ( 0  types . double )  . bind ( 1 100 . 0d )  . invoke (  )  ;   double expected =  math . to degrees
private void   (  )  throws io exception  {  if  (  ! gdef . filename . equals ( " - " )  )   {  info . bytes = worker . save image ( gdef . filename gdef . image format gdef . image quality )  ;   }  else  {  info . bytes = worker . get image bytes ( gdef . image format gdef . image quality )  ;   }   }  
@ override public void   (  )  {  parent . done (  )  ;   }  
public   ( @ nullable  disposable initial disposable )  {  this . resource = new  atomic reference <  disposable >  ( initial disposable )  ;   }  
protected  input stream processor   (  )  {  return new  unknown content stream processor (  )  ;   }  
public  persistable map <  string  string >    (  )  {  synchronized  ( this )   {  if  ( properties  =  =  null )   {  properties = provider . load properties ( this )  ;   }   }  return properties ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  if  ( other  =  =  null )   {   timeout subscriber < t >  parent = new  timeout subscriber < t >  ( s item timeout indicator )  ;  s . on subscribe ( parent )  ;  parent . start first time
public boolean   (  )  {  return  ( options & option   fast )   !  =  0 ;   }  
@ override public int   (  file o1  file o2 )  {  return o1 . get name (  )  . compare to ( o2 . get name (  )  )  ;   }  
public static  string   (  )  {  return sip config . stack path ;   }  
@ override public boolean   (  )  throws  exception  {  return true ;   }  
public  packet handler   (  )  {  return    packet handler ;   }  
public   ( final int min gq )  {  this . min gq = min gq ;   }  
private  property   (  node var node )  {   property prop = new  property (  )  ;  if  ( var node  =  =  null )  return prop ;   string variable name = var node . get name (  )  ;  int index = variable name . last index of ( ':' )  ;  if  ( index  !  =   - 1 )  variable name = variable name . substring ( index  +  1 )  ;  prop . set name ( variable name )  ;  prop . set value ( var node . get value (  )  )  ;  return prop ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  flowable <  integer >  >  ts =  behavior processor . create default ( 1 )  . window (  functions . just callable ( pp )  )  . take
public boolean   (  string realm  string subrealm  string user  string pw )  {   string pfx = realm ;  if  ( user  !  =  null && user . length (  )   >  0 )  pfx +  = ' . '  +  user ;   string hex = md5 hex ( subrealm user pw )  ;  if  ( hex  =  =  null )  return false ;   map <  string  string >  to add =  collections . singleton map ( pfx  +  prop   md5 hex )  ;   list <  string >  to del = new  array list <  string >  ( 4 )  ;  to del . add ( pfx  +  prop   pw )  ;  to del . add ( pfx  +  prop   b64 )  ;  to del . add ( pfx  +  prop   crypt )  ;  to del . add ( pfx  +  prop   shash )  ;  return    context . router (  )  . save config ( to add to del )  ;   }  
public synchronized void   (  )  {  shutdown (  )  ;  try  {   thread . sleep ( 100 )  ;   }  catch  (   interrupted exception ie )   {   }  startup (  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  oi =  flowable . from iterable (  arrays . as list ( 1 2 )  )  ;   test subscriber <  integer >  o = new  test subscriber <  integer >  (  )  ;  oi . subscribe ( o )  ;  thrown . expect (  assertion er
@ override public v   (  )  {  if  ( index  >  0 )   {  index -  -  ;   }  else if  ( ss . prev  !  =  null )   {  ss . keys = null ;  ss . vals = null ;  ss = ss . prev ;  if  ( ss . n keys  <  =  0 )   {  throw new  no such element exception (  )  ;   }
@ test public void   (  )  {   single . just ( 1 )  . flatten as flowable ( new  function <  object  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   object v )  throws  exception  {   integer[] array = new  integer[1
private void   ( final int tile num final  list <  abstract illumina position file reader .  position info >  locs final boolean header only )  {  log . info ( " processing tile "  +  tile num )  ;  try  {  for  (  final  map .  entry <  integer  map <  integer  file >  >  entry : surface to tile to cbcl map . entry set (  )  )   {  final  map <  integer  file >  cycle map = entry . get value (  )  ;  for  ( int i = 0 ;  i  <  cycles ;  i +  +  )   {  final  byte buffer byte buffer =  byte buffer . allocate ( initial   header   size )  ;  byte buffer . order (  byte order . little   endian )  ;  final  file bcl file = cycle map . get ( output cycles[i] )  ;  if  ( bcl file  =  =  null )   {  throw new  picard exception ( " expected cbcl file for surface "  +  entry . get key (  )   +  " cycle " +   ( i  +  1 )  +  " but it was not found . " )  ;   }  final  input stream stream = open ( bcl file false false false )  ;  int read = stream . read ( byte buffer . array (  )  )  ;  if  ( read  !  =  initial   header   size )   {  throw new  runtimeio exception (  string . format ( "bcl %s has invalid header structure . " bcl file . get absolute file (  )  )  )  ;   }  final short version = byte buffer . get short (  )  ;  header size = byte buffer . get int (  )  ;  final  byte buffer header buffer =  byte buffer . allocate ( header size  -  initial   header   size )  ;  header buffer . order (  byte order . little   endian )  ;  read = stream . read ( header buffer . array (  )  )  ;  if  ( read  !  =  header size  -  initial   header   size )   {  throw new  picard exception (  string . format ( "bcl %s has invalid header structure . " bcl file . get absolute file (  )  )  )  ;   }  final byte bits per basecall = header buffer . get (  )  ;  final byte bits per quality score = header buffer . get (  )  ;  if  ( bits per basecall  !  =  2 && bits per basecall  !  =  bits per quality score )   {  throw new  picard exception ( "cbcl data not encoded in nibbles .   ( not currently supported )  bits per basecall : "  +  bits per basecall  +  " bits per quality score : " +  bits per quality score )  ;   }  final int number of bins = header buffer . get int (  )  ;  final byte[] quality bins = new byte[number of bins] ;  for  ( int j = 0 ;  j  <  number of bins ;  j +  +  )   {  header buffer . get int (  )  ;  final int to = header buffer . get int (  )  ;  quality bins[j] =  ( byte ) to ;   }  long file pos = 0 ;  final int num tiles = header buffer . get int (  )  ;   tile data tile info = null ;  for  ( int j = 0 ;  j  <  num tiles ;  j +  +  )   {  final int tile = header buffer . get int (  )  ;  final int num clusters in tile = header buffer . get int (  )  ;  final int uncompressed block size = header buffer . get int (  )  ;  final int compressed block size = header buffer . get int (  )  ;  final  tile data tile data = new  tile data ( tile num clusters in tile uncompressed block size compressed block size file pos )  ;  all tiles . get ( i  +  1 )  . add ( tile data )  ;  if  ( tile  =  =  tile num )   {  tile info = tile data ;   }  file pos +  = compressed block size ;   }  final boolean pf excluded = header buffer . get (  )   =  =  1 ;  if  ( tile info  =  =  null )   {  continue ;   }  cycle data[i] = new  cycle data ( version header size bits per basecall bits per quality score number of bins quality bins num tiles tile info pf excluded )  ;  this . streams[i] = stream ;  this . stream files[i] = bcl file ;  byte buffer . clear (  )  ;  header buffer . clear (  )  ;   }   }  if  ( header only )   {  return ;   }  int total cycle count = 0 ;  if  ( cycle data[total cycle count] . tile info  =  =  null )   {  throw new  picard exception ( " could not find tile "  +  tile num )  ;   }  for  (  final int output length : output lengths )   {  for  ( int cycle = 0 ;  cycle  <  output length ;  cycle +  +  )   {  final  cycle data current cycle data = cycle data[total cycle count] ;  try  {  if  ( cached tile[total cycle count]  =  =  null )   {  if  (  ! cached filter . contains key ( cycle data[total cycle count] . tile info . tile num )  )   {  cache filter and locs ( cycle data[total cycle count] . tile info locs )  ;   }  cache tile ( total cycle count cycle data[total cycle count] . tile info current cycle data )  ;   }   }  catch  (  final io exception e )   {  throw new  picard exception (  string . format ( " error while reading from bcl file for cycle %d .   offending file on disk is %s"  ( total cycle count  +  1 )  this . stream files[total cycle count] . get absolute path (  )  )  e )  ;   }  total cycle count +  +  ;   }   }   }  catch  (  final io exception ioe )   {  throw new  runtimeio exception ( ioe )  ;   }   }  
private void   (  )  {   list <  client app config >  clients =  client app config . get client apps (    context )  ;  for  ( int cur = 0 ;  cur  <  clients . size (  )  ;  cur +  +  )   {   client app config ca = clients . get ( cur )  ;   object val =    settings . get ( cur  +  " . enabled" )  ;  if  (  !  (  router console runner . class . get name (  )  . equals ( ca . class name )  )  )  ca . disabled = val  =  =  null ;  if  (    context . get boolean property (  config clients helper . prop   enable   client   change )  || is advanced (  )  )   {   string desc = get jetty string ( "nofilter   desc"  +  cur )  ;  if  ( desc  !  =  null )   {  int spc = desc . index of ( ' ' )  ;   string clss = desc ;   string args = null ;  if  ( spc  >  =  0 )   {  clss = desc . substring ( 0 spc )  ;  args = desc . substring ( spc  +  1 )  ;   }  ca . class name = clss ;  ca . args = args ;  ca . client name = get jetty string ( "nofilter   name"  +  cur )  ;   }   }   }  if  (    context . get boolean property (  config clients helper . prop   enable   client   change )  || is advanced (  )  )   {  int new client = clients . size (  )  ;   string new desc = get jetty string ( "nofilter   desc"  +  new client )  ;  if  ( new desc  !  =  null && new desc . trim (  )  . length (  )   >  0 )   {  int spc = new desc . index of ( ' ' )  ;   string clss = new desc ;   string args = null ;  if  ( spc  >  =  0 )   {  clss = new desc . substring ( 0 spc )  ;  args = new desc . substring ( spc  +  1 )  ;   }   string name = get jetty string ( "nofilter   name"  +  new client )  ;  if  ( name  =  =  null || name . trim (  )  . length (  )   <  =  0 )  name = "new client" ;   client app config ca = new  client app config ( clss name args 2 * 60 * 1000    settings . get ( new client  +  " . enabled" )   =  =  null )  ;  clients . add ( ca )  ;  add form notice (    t ( " new client added" )   +  ": "  +  name +  "  ( " +  clss +  " )  . " )  ;   }   }   client app config . write client app config (    context clients )  ;  add form notice (    t ( " client configuration saved successfully" )  )  ;   }  
  (  observer resource wrapper < r >  srw )  {  this . srw = srw ;   }  
private  fingerprint id details   ( final  path sam file final sam record rec )  {  final  picard exception e = new  picard exception ( " found read with no readgroup: "  +  rec . get read name (  )   +  " in file: " +  sam file )  ;  if  ( validation stringency  !  =   validation stringency . strict )   {  final sam read group record read group record = new sam read group record ( " < unknown > :::"  +  sam file . to uri (  )  . to string (  )  )  ;  read group record . set library ( " < unknown > " )  ;  read group record . set sample ( " < unknown > " )  ;  read group record . set platform unit ( " < unknown >  . 0 . zzz" )  ;  if  ( validation stringency  =  =   validation stringency . lenient )   {  log . warn ( e )  ;  log . warn ( "further messages from this file will be suppressed" )  ;   }  return new  fingerprint id details ( read group record sam file . to uri (  )  . to string (  )  )  ;   }  else  {  log . error ( e )  ;  throw e ;   }   }  
@ override public  boolean   (  )  {  return false ;   }  
 string   (  )  {  return dump (  )  ;   }  
public  string   (  )  {  return " monitor the floodfill pool" ;   }  
@ override public void   (  object t )  {  if  ( s  !  =   subscription helper . cancelled )   {  s . cancel (  )  ;  s =  subscription helper . cancelled ;  subscribe next (  )  ;   }   }  
private  list <  stun server address >    (  string addresses )  {   list <  stun server address >  list = new  array list <  stun server address >  (  )  ;  if  ( addresses . equals ( "" )  )   {  return list ;   }   string servers[] = addresses . split ( " ; " )  ;  for  (   string server : servers )   {   string address[] = server . split ( ":" )  ;   stun server address aux = new  stun server address ( address[0] address[1] )  ;  if  (  ! list . contains ( aux )  )   {  list . add ( aux )  ;   }   }  return list ;   }  
final void   ( final  prepared statement stmt )  {  for  (   statement customizer customizer : customizers )   {  try  {  customizer . before execution ( stmt ctx )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( " exception thrown in statement customization" e ctx )  ;   }   }   }  
public  string   (  )  {  return get file name (  )  ;   }  
public long   (  )  {  return    created on ;   }  
int   (  )  {  return size (  )  ;   }  
@ override public  void   (  )  {  return null ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {   test scheduler scheduler1 = new  test scheduler (  )  ;   atomic boolean os1 = new  atomic boolean ( false )  ;   observable <  long >  o1 = create observable of5 intervals of1 
@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   message data that =  (  message data ) o ;  if  (  ! token . equals ( that . token ) 
@ test public void   (  )  {  int n = 3 ;   publish processor <  integer >  source =  publish processor . create (  )  ;  final  list <  publish processor <  integer >  >  subjects = new  array list <  publish processor <  integer >  >  (  )  ;  for  ( in
public synchronized void   (  )  {     handler . shutdown (    num handler threads )  ;     executor . shutdown (  )  ;  shutdown exploratory (  )  ;     is shutdown = true ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ backpressure support (  backpressure kind . full )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t >  flowable < t >    (  publisher <  ?  extends  maybe s
  (  sequential disposable serial  observer <  ?  super t >  child )  {  this . serial = serial ;  this . child = child ;   }  
public float   (  )  {  return metric value ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map iterable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  {  return  arrays . as 
@ override protected void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 2 )  ;   }  
public  font   ( int tag )  {  return this . fonts[tag]  =  =  null  ?  this . fonts[fonttag   default] : this . fonts[tag] ;   }  
public void   ( boolean enabled )  {   jive globals . set property ( "update . notify - admins" enabled  ?  "true" : "false" )  ;   }  
public static long   (  intent intent )  {  return get long from intent ( intent message   id   param )  ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register row mapper register row mapper =  (  register row mapper ) annotation ;  try  {  registry . get (  row mappers . class )  . registe
@ test public void   (  )  {   maybe . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return v  =  =  1 ;   }   }   )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   replay processor <  integer >  source =  replay processor . create with time ( 1  time unit . seconds scheduler )  ;  source . on next ( 1 )  ;  scheduler . advance ti
public static void   (  string username )  {   string message = get mark message ( username )  ;  debug ( message )  ;   }  
@ test public void   (  )  {  mocked request . set requesturi ( " / v1 . 0 / limits" )  ;  mocked request . add header ( " accept"  media type . application   json   value )  ;   filter action filter action = new handler (  )  . handle request ( new  http
public  date   (  )  {  return    timestamp ;   }  
public  data structure   (  )  throws  data format exception  {   session config cfg = new  session config (  (  destination )  ( new  destination test (  )  )  . create data structure (  )  )  ;  cfg . set signature (  (  signature )  ( new  signature test (  )  )  . create data structure (  )  )  ;   properties options = new  properties (  )  ;  options . set property ( "router host" "localhost" )  ;  options . set property ( "router port" "54321" )  ;  options . set property ( "router secret" "blah" )  ;  cfg . set options ( options )  ;  cfg . sign session config (  (  signing private key )  ( new  signing private key test (  )  )  . create data structure (  )  )  ;  return cfg ;   }  
public   (  maybe source < t >  source  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper )  {  this . source = source ;  this . mapper = mapper ;   }  
@ override public void   (  )  {  if  (  !  cluster manager . is senior cluster member (  )  )   {  for  (   map .  entry <  string  statistic >  statistic entry : stats manager . get all statistics (  )  )   {   string key = statistic entry . get key (  
void   (  out net message msg )  {     fragments . add ( msg )  ;   }  
@ test public void   (  )  {   scalar ops sc = new  big integer scalar ops ( ed25519 field new  big integer ( "5" )  )  ;  assert that ( sc . reduce ( new byte[] { 7 }  )  is ( equal to (  utils . hex to bytes ( "020000000000000000000000000000000000000000
protected static void   ( final  variant context builder builder final int start final int end final  list <  allele >  alleles final  reference sequence reference sequence )  {  if  (  ! reference allele matches reference for indel ( alleles reference sequence start end )  )   {  throw new  illegal argument exception (  string . format ( " reference allele doesn't match reference at %s:%d - %d" reference sequence . get name (  )  start end )  )  ;   }  boolean changes in alleles = true ;  final  map <  allele byte[] >  allele bases map = new  hash map <  >  (  )  ;  alleles . for each ( a  -  >  allele bases map . put ( a a . get bases (  )  )  )  ;  int the start = start ;  int the end = end ;  while  ( changes in alleles )   {  changes in alleles = false ;  if  ( allele bases map . values (  )  . stream (  )  . collect (  collectors . grouping by ( a  -  >  a[a . length  -  1]  collectors . to set (  )  )  )  . size (  )   =  =  1 && the end  >  1 )   {  for  (  final  allele allele : allele bases map . key set (  )  )   {  allele bases map . put ( allele truncate base ( allele bases map . get ( allele )  true )  )  ;   }  changes in alleles = true ;  the end -  -  ;   }  if  ( allele bases map . values (  )  . stream (  )  . map ( a  -  >  a . length )  . any match ( l  -  >  l  =  =  0 )  )   {  for  (  final  allele allele : allele bases map . key set (  )  )   {  final byte extra base =  ( the start  >  1 )   ?  reference sequence . get bases (  ) [the start  -  2] : reference sequence . get bases (  ) [the end] ;  allele bases map . put ( allele extend one base ( allele bases map . get ( allele )  extra base )  )  ;   }  changes in alleles = true ;  the start -  -  ;   }   }  while  ( allele bases map . values (  )  . stream (  )  . all match ( a  -  >  a . length  >  =  2 )  && allele bases map . values (  )  . stream (  )  . collect (  collectors . grouping by ( a  -  >  a[0]  collectors . to set (  )  )  )  . size (  )   =  =  1 )   {  for  (  final  allele allele : allele bases map . key set (  )  )   {  allele bases map . put ( allele truncate base ( allele bases map . get ( allele )  false )  )  ;   }  the start +  +  ;   }  builder . start ( the start )  ;  builder . stop ( the end )  ;  final  map <  allele  allele >  fixed allele map = allele bases map . entry set (  )  . stream (  )  . collect (  collectors . to map (  map .  entry::get key me  -  >   allele . create ( me . get value (  )  me . get key (  )  . is reference (  )  )  )  )  ;   list <  allele >  fixed alleles = alleles . stream (  )  . map ( fixed allele map::get )  . collect (  collectors . to list (  )  )  ;  builder . alleles ( fixed alleles )  ;   }  
@ override public int   (  )  {  return  data helper . hash code (    certificate )  ^  ( int )    clove id ^  data helper . hash code (    msg ) ^  data helper . hash code (    expiration ) ^  data helper . hash code (    instructions )  ;   }  
@ override public  parallel failure handling   (  long n  throwable e )  throws  exception  {  throw new  test exception (  )  ;   }  
private static void   ( final  map <  type variable key  type >  mappings  type from final  type to )  {  if  ( from . equals ( to )  )   {  return ;   }  new  type visitor (  )  {  @ override void visit type variable (   type variable <  ?  >  type variable )  {  mappings . put ( new  type variable key ( type variable )  to )  ;   }  @ override void visit wildcard type (   wildcard type from wildcard type )  {  if  (  !  ( to instanceof  wildcard type )  )   {  return ;   }   wildcard type to wildcard type =  (  wildcard type ) to ;   type[] from upper bounds = from wildcard type . get upper bounds (  )  ;   type[] to upper bounds = to wildcard type . get upper bounds (  )  ;   type[] from lower bounds = from wildcard type . get lower bounds (  )  ;   type[] to lower bounds = to wildcard type . get lower bounds (  )  ;  check argument ( from upper bounds . length  =  =  to upper bounds . length && from lower bounds . length  =  =  to lower bounds . length " incompatible type: %s vs .  %s" from wildcard type to )  ;  for  ( int i = 0 ;  i  <  from upper bounds . length ;  i +  +  )   {  populate type mappings ( mappings from upper bounds[i] to upper bounds[i] )  ;   }  for  ( int i = 0 ;  i  <  from lower bounds . length ;  i +  +  )   {  populate type mappings ( mappings from lower bounds[i] to lower bounds[i] )  ;   }   }  @ override void visit parameterized type (   parameterized type from parameterized type )  {  if  ( to instanceof  wildcard type )   {  return ;   }   parameterized type to parameterized type = expect argument (  parameterized type . class to )  ;  if  ( from parameterized type . get owner type (  )   !  =  null && to parameterized type . get owner type (  )   !  =  null )   {  populate type mappings ( mappings from parameterized type . get owner type (  )  to parameterized type . get owner type (  )  )  ;   }  check argument ( from parameterized type . get raw type (  )  . equals ( to parameterized type . get raw type (  )  )  " inconsistent raw type: %s vs .  %s" from parameterized type to )  ;   type[] from args = from parameterized type . get actual type arguments (  )  ;   type[] to args = to parameterized type . get actual type arguments (  )  ;  check argument ( from args . length  =  =  to args . length "%s not compatible with %s" from parameterized type to parameterized type )  ;  for  ( int i = 0 ;  i  <  from args . length ;  i +  +  )   {  populate type mappings ( mappings from args[i] to args[i] )  ;   }   }  @ override void visit generic array type (   generic array type from array type )  {  if  ( to instanceof  wildcard type )   {  return ;   }   type component type =  types . get component type ( to )  ;  check argument ( component type  !  =  null "%s is not an array type . " to )  ;  populate type mappings ( mappings from array type . get generic component type (  )  component type )  ;   }  @ override void visit class (   class <  ?  >  from class )  {  if  ( to instanceof  wildcard type )   {  return ;   }  throw new  illegal argument exception ( " no type mapping from "  +  from class  +  " to " +  to )  ;   }   }   . visit ( from )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . limit ( 5 )  . test (  )  . assert failure (  test exception . class )  ;   }  
protected  string   ( asn1 object identifier type id asn1 primitive value )  {  return null ;   }  
@ test ( data provider = "data testp evidence given prior fromg ls" )  public void   ( final  haplotype probabilities from genotype likelihoods hp final  list <  snp >  snps final  list <  boolean >  swaps final  list < double[] >  g ls )  throws  excepti
@ check return value @ scheduler support (  scheduler support . none )  public final  < u >  observable < t >    (  observable source < u >  other )  {   object helper . require non null ( other "other is null" )  ;  return  rx java plugins . on assembly 
public  string   (  )  {  return get header value ( http . host )  ;   }  
public  tag set handle   (  public key target  session key key  set <  session tag >  session tags )  {  return null ;   }  
@ override public boolean   (  )  {  return members only ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 1 5 )  . concat map eager delay error ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer t )  {
@ override protected void   (  single observer <  ?  super t >  s )  {  s . on subscribe (  disposables . disposed (  )  )  ;  s . on success ( value )  ;   }  
public void   (  client session session  presence presence )  {  update presence ( session presence )  ;   }  
public void   (  string value )  {  get device node (  )  . set node ( device   type value )  ;   }  
public  field element   (  )  {   field element t0  t1  t2  t3 ;  t0 = square (  )  ;  t1 = t0 . square (  )  ;  t1 = t1 . square (  )  ;  t1 = multiply ( t1 )  ;  t0 = t0 . multiply ( t1 )  ;  t2 = t0 . square (  )  ;  t1 = t1 . multiply ( t2 )  ;  t2 = t1 . square (  )  ;  for  ( int i = 1 ;  i  <  5 ;   +  + i )   {  t2 = t2 . square (  )  ;   }  t1 = t2 . multiply ( t1 )  ;  t2 = t1 . square (  )  ;  for  ( int i = 1 ;  i  <  10 ;   +  + i )   {  t2 = t2 . square (  )  ;   }  t2 = t2 . multiply ( t1 )  ;  t3 = t2 . square (  )  ;  for  ( int i = 1 ;  i  <  20 ;   +  + i )   {  t3 = t3 . square (  )  ;   }  t2 = t3 . multiply ( t2 )  ;  t2 = t2 . square (  )  ;  for  ( int i = 1 ;  i  <  10 ;   +  + i )   {  t2 = t2 . square (  )  ;   }  t1 = t2 . multiply ( t1 )  ;  t2 = t1 . square (  )  ;  for  ( int i = 1 ;  i  <  50 ;   +  + i )   {  t2 = t2 . square (  )  ;   }  t2 = t2 . multiply ( t1 )  ;  t3 = t2 . square (  )  ;  for  ( int i = 1 ;  i  <  100 ;   +  + i )   {  t3 = t3 . square (  )  ;   }  t2 = t3 . multiply ( t2 )  ;  t2 = t2 . square (  )  ;  for  ( int i = 1 ;  i  <  50 ;   +  + i )   {  t2 = t2 . square (  )  ;   }  t1 = t2 . multiply ( t1 )  ;  t1 = t1 . square (  )  ;  for  ( int i = 1 ;  i  <  5 ;   +  + i )   {  t1 = t1 . square (  )  ;   }  return t1 . multiply ( t0 )  ;   }  
public void   ( io exception event ioee )  {  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( "process transaction terminated called" )  ;   }   }  
public void   ( int status )  {   state old state ;   state new state ;  synchronized  ( this )   {  old state =    state ;  locked   update ( status )  ;  new state =    state ;  this . notify all (  )  ;   }  if  (    listener  !  =  null )   {  if  ( old state  !  =  new state &&    expires  >     context . clock (  )  . now (  )  )     listener . message status (    session    nonce status )  ;   }   }  
@ override public void   (  )  {  r v = value ;  if  ( v  !  =  null )   {  value = null ;  s =  subscription helper . cancelled ;  actual . on success ( v )  ;   }   }  
@ suppress warnings ( "squid: redundant throws declaration check" )  public  header value   (  )  throws  malformed header value exception  {  final  map <  string  string >  parameters = new  hash map <  >  (  )  ;  final  string[] parameter split = raw 
@ test public void   (  )  {   observable <  string >  o =  observable . empty (  )  ;  o . count (  )  . subscribe ( wo )  ;  verify ( wo times ( 1 )  )  . on success ( any long (  )  )  ;  verify ( wo )  . on success ( 0l )  ;  verify ( wo never (  )  )
@ override public final void   (  )  {   subscription helper . cancel ( s )  ;   }  
public void   (  string newstatus )  {  if  ( newstatus  =  =  null )   {  newstatus = "" ;   }  if  (  ! verbose status . equals ( newstatus )  )   {   presence p = new  presence (  )  ;  p . set to ( get manager (  )  . get session (  )  . getjid (  )  )  ;  p . set from ( jid )  ;  get manager (  )  . get session (  )  . get transport (  )  . set up presence packet ( p presence )  ;  if  (  ! newstatus . equals ( "" )  )   {  p . set status ( newstatus )  ;   }  if  ( avatar set && avatar  !  =  null )   {   element vcard = p . add child element ( "x"  name space . vcard   temp   x   update )  ;  vcard . add element ( "photo" )  . addcdata ( avatar . get xmpp hash (  )  )  ;  vcard . add element ( "hash" )  . addcdata ( avatar . get xmpp hash (  )  )  ;   }  get manager (  )  . send packet ( p )  ;   }  verbose status = newstatus ;  last activity timestamp = new  date (  )  . get time (  )  ;  last activity event = verbose status ;   }  
@ override public void   (  )  {  child . on complete (  )  ;   }  
@ override public synchronized void   ( int timeout )  {  if  (    is  !  =  null &&    is instanceof  timeout piped input stream )   (  (  timeout piped input stream )    is )  . set read timeout ( timeout )  ;   }  
public static  map <  string  map <  string  pattern >  >    (  list <  configured limit group >  clg list )  {  final  map <  string  map <  string  pattern >  >  regex cache = new  hash map <  >  (  )  ;  for  (   configured limit group clg : clg list )   {  final  map <  string  pattern >  limit group regex cache = new  hash map <  >  (  )  ;  for  (   configured ratelimit crl : clg . get limit (  )  )   {  limit group regex cache . put ( crl . get uri (  )   pattern . compile ( crl . get uri regex (  )  )  )  ;   }  regex cache . put ( clg . get id (  )  limit group regex cache )  ;   }  return regex cache ;   }  
@ before public void   (  )  {   jive globals . set locale (  locale . english )  ;   }  
void   (  imap element e )  {  if  ( e  =  =  null )   {  throw new  runtime exception ( " can't add null" )  ;   }  m list . add ( e )  ;   }  
private void   (  )  {     is running = true ;     checker . set error ( "" )  ;     checker . set status (    t ( " reseeding" )  )  ;   system . out . println ( " reseed start" )  ;  int total ;  if  (    url  !  =  null )   {   string lc =    url . get path (  )  . to lower case (  locale . us )  ;  if  ( lc . ends with ( " . su3" )  )  total = reseedsu3 (    url false )  ;  else if  ( lc . ends with ( " . zip" )  )  total = reseed zip (    url false )  ;  else throw new  illegal argument exception ( " must end with  . zip or  . su3" )  ;   }  else  {  total = reseed ( false )  ;   }  if  ( total  >  =  20 )   {   string s = ngettext ( " reseed successful  fetched  { 0 }  router info" " reseed successful  fetched  { 0 }  router infos" total )  ;   system . out . println ( s  +  get display string (    url )  )  ;     checker . set status ( s )  ;     checker . set error ( "" )  ;   }  else if  ( total  >  0 )   {   string s = ngettext ( " reseed fetched only 1 router . " " reseed fetched only  { 0 }  routers . " total )  ;   system . out . println ( s  +  get display string (    url )  )  ;     checker . set error ( s )  ;     checker . set status ( "" )  ;   }  else  {  if  ( total  =  =  0 )   {   system . out . println ( " reseed failed "  +  get display string (    url )   +  " -  check network connection" )  ;   system . out . println ( " ensure that nothing blocks outbound http or https  check the logs  "  +  "and if nothing helps  read the faq about reseeding manually . " )  ;  if  (    url  =  =  null || "https" . equals (    url . get scheme (  )  )  )   {  if  (    sproxy host  !  =  null &&    sproxy port  >  0 )   system . out . println ( " check current proxy setting !   type: "  +  get display string (    sproxy type )   +  "  host: " +     sproxy host +  "  port: " +     sproxy port )  ;  else  system . out . println ( " consider enabling a proxy for https on the reseed configuration page" )  ;   }  else  {  if  (    proxy host  !  =  null &&    proxy port  >  0 )   system . out . println ( " check http proxy setting  -  host: "  +     proxy host  +  " port: " +     proxy port )  ;  else  system . out . println ( " consider enabling an http proxy on the reseed configuration page" )  ;   }   }   string old =    checker . get error (  )  ;     checker . set error (    t ( " reseed failed . " )   +  ' '  +     t ( " see  { 0 }  for help . " " < a target = \"   top\" href = \" / configreseed\" > "  +     t ( "reseed configuration page" )   +  " <  / a > " )  +  " < br > " +  old )  ;     checker . set status ( "" )  ;   }     is running = false ;     context . router (  )  . event log (  )  . add event (  event log . reseed  integer . to string ( total )  )  ;   }  
@ override public void   (  throwable t )  {  lazy set (  subscription helper . cancelled )  ;  parent . inner error ( this t )  ;   }  
@ data provider ( name = " " )  public  object[][] positive test data (  )  {  return new  object[][] {  { new  supported illumina format[] {  bcl  locs  pos  filter }  new  illumina data type[] {  base calls  illumina data type .  quality scores  illumin
private void   (  off hook command command  document document )  throws  exception  {   handset handset = command . get handset (  )  ;   element root = document . add element ( new q name ( "offhook" namespace )  )  ;  root . add attribute ( "crypto suite" handset . crypto suite )  ;  root . add attribute ( "local crypto" handset . local crypto )  ;  root . add attribute ( "remote crypto" handset . crypto suite )  ;  root . add attribute ( "codec" handset . codec )  ;  root . add attribute ( "stereo" handset . stereo )  ;  root . add attribute ( "mixer" handset . mixer )  ;   }  
void   ( char expected )  throws io exception  {  final int next = read byte (  )  ;  if  ( expected  !  =  next )   {  throw new io exception (  string . format ( " expected %04x  ( %c )  but got %04x  ( %c ) "  ( int ) expected expected next  ( char ) next )  )  ;   }   }  
public void   (  peer coordinator coordinator  meta info metainfo )  {  try  {   string base =  storage . filter name ( metainfo . get name (  )  )  ;   file base file ;  if  (    util . get files public (  )  )  base file = new  file ( root data dir base )  ;  else base file = new  secure file ( root data dir base )  ;  storage = new  storage (    util base file metainfo this false )  ;  storage . check (  )  ;  meta = metainfo ;  if  ( complete listener  !  =  null )   {   string new name = complete listener . got meta info ( this )  ;  if  ( new name  !  =  null )  torrent = new name ;   }  coordinator . set storage ( storage )  ;   }  catch  (  io exception ioe )   {  if  ( storage  !  =  null )   {  try  {  storage . close (  )  ;   }  catch  (  io exception ioee )   {   }  storage = null ;   }  fatal ( " could not create data files" ioe )  ;   }   }  
public void   (  )  {  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( "resume" )  ;   }   }  
@ override public void   (  simple resource context < r >  new context )  {  final r resource = checkout (  )  ;  try  {  new context . perform ( resource )  ;   }  finally  {  checkin ( resource )  ;   }   }  
public  statement builder factory   (  )  {  return this . statement builder factory . get (  )  ;   }  
private static void   (  string source name  image info ii )  {  print line ( 0 null source name )  ;  print line ( 1 " file format: " ii . get format name (  )  )  ;  print line ( 1 "mime type: " ii . get mime type (  )  )  ;  print line ( 1 " width  ( pixels ) : " ii . get width (  )  1 )  ;  print line ( 1 " height  ( pixels ) : " ii . get height (  )  1 )  ;  print line ( 1 " bits per pixel: " ii . get bits per pixel (  )  1 )  ;  print line ( 1 " progressive: " ii . is progressive (  )   ?  "yes" : "no" )  ;  print line ( 1 " number of images: " ii . get number of images (  )  1 )  ;  print line ( 1 " physical width  ( dpi ) : " ii . get physical width dpi (  )  1 )  ;  print line ( 1 " physical height  ( dpi ) : " ii . get physical height dpi (  )  1 )  ;  print line ( 1 " physical width  ( inches ) : " ii . get physical width inch (  )  1 . 0f )  ;  print line ( 1 " physical height  ( inches ) : " ii . get physical height inch (  )  1 . 0f )  ;  int num comments = ii . get number of comments (  )  ;  print line ( 1 " number of textual comments: " num comments 1 )  ;  if  ( num comments  >  0 )   {  for  ( int i = 0 ;  i  <  num comments ;  i +  +  )   {  print line ( 2 null ii . get comment ( i )  )  ;   }   }   }  
@ override public void   (  )  {  request ( 1 )  ;   }  
@ override public t   (  result set rs  statement context ctx )  throws sql exception  {  return specialize ( rs ctx )  . map ( rs ctx )  ;   }  
public synchronized  map <  string  sorting collection < cluster   output   record >  >    (  )  {  return barcode to record collection ;   }  
@ test public void   (  )  {   disposable r = mock (  disposable . class )  ;   async subscription as = new  async subscription ( r )  ;   subscription s = mock (  subscription . class )  ;  as . set subscription ( s )  ;  as . cancel (  )  ;  as . cancel
public void   (  )  {  if  (  ! m registered )   {  throw new  illegal state exception ( " connectivity manager not registered" )  ;   }  boolean waiting = false ;  m wait thread =  thread . current thread (  )  ;  m wake lock . acquire (  )  ;  try  {  while  (  ! m stop )   {   network info info = m connectivity manager . get active network info (  )  ;  if  ( info  !  =  null )   {  if  ( waiting )   {  if  (  debug utils . debug )   {   log utils . d ( tag m name  +  ":  connectivity wait ended" )  ;   }   }  return ;   }  else  {  if  (  ! waiting )   {  if  (  debug utils . debug )   {   log utils . d ( tag m name  +  ":  connectivity waiting .  .  . " )  ;   }  waiting = true ;   }  synchronized  ( m lock )   {  m wake lock . release (  )  ;  try  {  m lock . wait ( connectivity   wait   time )  ;   }  catch  (   interrupted exception e )   {   }  m wake lock . acquire (  )  ;   }   }   }   }  finally  {  if  ( m wake lock . is held (  )  )   {  m wake lock . release (  )  ;   }  m wait thread = null ;   }   }  
public boolean   (  service service )  {  if  ( service  =  =  null )  return false ;  return service . is subscribed (  )  ;   }  
private static void   (  input stream in int cnt )  throws io exception  {  for  ( int i = 0 ;  i  <  cnt ;  i +  +  )   {  if  ( in . read (  )   <  0 )  throw new eof exception (  )  ;   }   }  
public void   ( boolean enabled )  {  service enabled = enabled ;   jive globals . set property ( serviceenabled enabled  ?  "true" : "false" )  ;   }  
@ test public void   (  )  {   observable <  movie >  movies =  observable . just ( new  horror movie (  )  new  action movie (  )  new  movie (  )  )  ;   test observer <  string >  to = new  test observer <  string >  (  )  ;  movies . group by ( new  f
@ override public void   (  )  {  actual . on complete (  )  ;   }  
public void   (  )  {   logger . write file ( " conference receiver done "  +  conference id )  ;  done = true ;  close (  )  ;   }  
private void   (  object o1  object o2 final  string label )  {  if  ( o1  =  =  null )   {  o1 = "null" ;   }  if  ( o2  =  =  null )   {  o2 = "null" ;   }  report difference ( o1 . to string (  )  o2 . to string (  )  label )  ;   }  
@ test public void   (  )  {   exception e = new  exception (  )  ;   observable <  string >  ok =  observable . just ( "one" )  ;   observable <  string >  error =  observable . error ( e )  ;   observable <  string >  skip =  observable . concat ( ok er
@ test public void   (  )  {  @ suppress warnings ( "unchecked" )  final  subscriber <  ?  super  integer > [] subs = new  subscriber[1] ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 1 )  {  @ override public void on next (  
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . group join (  flowable . just ( 2 )  new  function <  integer  flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   integer left )  thr
public void   (  )  throws  exception  {  byte b[] =  data helper . getascii ( "hi  how are you today ? " )  ;   byte array output stream baos = new  byte array output stream (  )  ;   resettablegzip output stream o = new  resettablegzip output stream ( baos )  ;  o . write ( b )  ;  o . finish (  )  ;  o . flush (  )  ;  byte compressed[] = baos . to byte array (  )  ;  gzip input stream in = new gzip input stream ( new  byte array input stream ( compressed )  )  ;  byte rv[] = new byte[128] ;  int read = in . read ( rv )  ;  assert true (  data helper . eq ( rv 0 b 0 b . length )  )  ;   }  
@ test public void   (  )  {   test resource maybe observer <  integer >  rmo = new  test resource maybe observer <  integer >  (  )  ;  assert false ( rmo . is disposed (  )  )  ;   disposable d =  disposables . empty (  )  ;  rmo . add ( d )  ;  assert 
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  new i2p socket address ( new  destination (  )   - 1 )  ;   }  
public static  string   (  )  {  return counters . get info (  )  ;   }  
public static  uri   (  content resolver resolver  uri attachment uri )  {   cursor c = resolver . query ( attachment uri new  string[] {  columns . data }  null null null )  ;  if  ( c  !  =  null )   {  try  {  if  ( c . move to first (  )  )   {  final  string str uri = c . get string ( 0 )  ;  if  ( str uri  !  =  null )   {  return  uri . parse ( str uri )  ;   }   }   }  finally  {  c . close (  )  ;   }   }  return attachment uri ;   }  
@ override public  maybe source <  integer >    (  integer v )  throws  exception  {  if  ( v  =  =  1 )   {  return ms ;   }  return  maybe . empty (  )  ;   }  
public void   (  add affiliation affiliation )  {  jid affiliationjid = affiliation . get barejid (  )  ;  switch  ( affiliation . get affiliation (  )  )   {  case owner: remove member ( affiliationjid )  ;  remove admin ( affiliationjid )  ;  remove outcast ( affiliationjid )  ;  owners . add ( affiliationjid )  ;  break ;  case admin: remove member ( affiliationjid )  ;  remove owner ( affiliationjid )  ;  remove outcast ( affiliationjid )  ;  admins . add ( affiliationjid )  ;  break ;  case outcast: remove member ( affiliationjid )  ;  remove admin ( affiliationjid )  ;  remove owner ( affiliationjid )  ;  outcasts . add ( affiliationjid )  ;  break ;  case none: default : remove member ( affiliationjid )  ;  remove admin ( affiliationjid )  ;  remove owner ( affiliationjid )  ;  remove outcast ( affiliationjid )  ;  break ;   }   }  
@ override public void   (  )  {   observer <  object >  o = ref . get (  )  ;  o . on next ( 1 )  ;  o . on error ( ex )  ;   }  
@ test public void   (  )  {   observable <  string >  subject =  observable . just ( "one" "two" "three" "four" "five" )  ;   observable <  observable <  string >  >  windowed = subject . window ( 2 3 )  ;   list <  list <  string >  >  windows = to list
@ experimental public static  < t >  maybe observer < t >    (  observer <  ?  super t >  downstream )  {  return new  maybe to observable observer < t >  ( downstream )  ;   }  
protected int   (  )  {  return absolute   max   highcap   peers ;   }  
@ override public int   (  )  {  return poison   max   delay   request ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . observe on (  schedulers . single (  )  )  . take ( 3 )  . take ( 3 )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 2 3 )  ;   }  
@ deprecated public static void   (  output stream out  boolean bool )  throws  data format exception  io exception  {  if  ( bool  =  =  null )  write long ( out 1 boolean   unknown )  ;  else if  (  boolean . true . equals ( bool )  )  write long ( out 
public pdp status block   (  )  {  return pdp status block ;   }  
@ test @ ignore ( " null values not allowed" )  public void   (  )  {   flowable <  boolean >  observable =  flowable . sequence equal (  flowable . just (  (  string ) null )   flowable . just ( "one" )  )  . to flowable (  )  ;  verify result ( observab
@ test public void   (  )  {   maybe . just ( 1 )  . timeout (  flowable . timer ( 1  time unit . days )   maybe . just ( 2 )  )  . test (  )  . assert result ( 1 )  ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   behavior subject <  string >  src =  behavior subject . create default ( "null" )  ;  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  final  observer <  object >  o =  test helper . mock observer (  )  ;  
public void   (  public key recipient public key )  {     recipient public key = recipient public key ;   }  
@ override public  string   (  )  {  return  help constants . doc   cat   variant   filtering ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   integer v )  {  return null ;   }   }   new
public void   ( long id )  {  if  (  !    receive stream id . compare and set ( 0 id )  )  throw new  runtime exception ( " receive stream id already set ["  +     receive stream id  +  "  " +  id +  "]" )  ;  synchronized  (    connect lock )   {     connect lock . notify all (  )  ;   }   }  
@ test public void   (  )  {   flowable <  string >  observable =  flowable .  <  string > empty (  )  . skip last ( 2 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  observable . subscribe ( observer )  ;  verify ( obser
@ override public void   (  )  {  source . subscribe ( observer )  ;   }  
  (  string .  .  .  values )  {  values to return = values ;   }  
public   (  router context ctx )  {     context = ctx ;     log = ctx . log manager (  )  . get log ( udp endpoint test standalone . class )  ;     sent not received = new  concurrent hash set <  byte array >  ( 128 )  ;   }  
public boolean   (  )  {  return observers . get (  )   =  =  terminated && value  !  =  null ;   }  
@ override public void   (  string property  map params )  {  if  ( "ldap . override . avatar" . equals ( property )  )   {  db storage enabled = false ;   }   }  
@ override public  no such element exception   (  )  throws  exception  {  return new  no such element exception (  )  ;   }  
public synchronized boolean   ( boolean forced )  {  if  (  ! open )  return true ;  if  ( task  !  =  null )   {  task . close ( forced )  ;   }  synchronized  ( lock )   {  if  (  ! forced && sock mgr . list sockets (  )  . size (  )   !  =  0 )   {  l . log ( " there are still active connections ! " )  ;  for  (  i2p socket skt : sock mgr . list sockets (  )  )   {  l . log ( " -  > "  +  skt )  ;   }  return false ;   }  l . log ( " stopping tunnels for server at "  +  this . remote host  +  ':' +  this . remote port )  ;  open = false ;  try  {  if  ( i2pss  !  =  null )   {  i2pss . close (  )  ;  i2pss = null ;   }  i2p session session = sock mgr . get session (  )  ;  get tunnel (  )  . remove session ( session )  ;  session . destroy session (  )  ;   }  catch  (  i2p exception ex )   {     log . error ( " error destroying the session" ex )  ;   }  if  (    use pool &&    executor  !  =  null )   {     executor . set rejected execution handler ( new  thread pool executor .  discard policy (  )  )  ;     executor . shutdown now (  )  ;   }  return true ;   }   }  
@ test ( timeout = 3000 )  public void   (  )  throws  interrupted exception  {  final  subscriber <  object >  o =  test helper . mock subscriber (  )  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   resource subscriber <  object >  s =
@ override public  type   (  )  {  return  type . rate ;   }  
public static synchronized void   (  )  {  if  ( is clustering started (  )  )   {   log . debug ( " cluster manager:  shutting down clustered cache service . " )  ;   cache factory . stop clustering (  )  ;   }   }  
public static  private key   (  file file  sig type type )  throws  general security exception  io exception  {  byte[] data = get data ( file )  ;   key spec ks = new pkcs8 encoded key spec ( data )  ;   string algo = type . get base algorithm (  )  . get name (  )  ;   key factory kf =  key factory . get instance ( algo )  ;  return kf . generate private ( ks )  ;   }  
public void   ( i2p socket manager .  disconnect listener lsnr )  {     connection manager . get message handler (  )  . remove disconnect listener ( lsnr )  ;   }  
private  element   (  string username  element mergev card )  {  username = jid . unescape node ( username )  ;   map <  string  string >  map = get ldap attributes ( username )  ;   log . debug ( " ldapv card provider:  retrieving ldap mapped vcard for "  +  username )  ;  if  ( map . is empty (  )  )   {  return null ;   }   element vcard = new v card ( template )  . getv card ( map )  ;  if  ( mergev card  =  =  null )   {  return vcard ;   }  if  ( mergev card . element ( "photo" )   =  =  null )   {  return vcard ;   }   element photo element = mergev card . element ( "photo" )  . create copy (  )  ;  if  ( photo element  =  =  null || photo element . element ( "binval" )   =  =  null || photo element . element ( "binval" )  . get text (  )  . matches ( "\\s*" )  )   {  return vcard ;   }  if  (  !  (  ( vcard . element ( "photo" )   =  =  null || vcard . element ( "photo" )  . element ( "binval" )   =  =  null || vcard . element ( "photo" )  . element ( "binval" )  . get text (  )  . matches ( "\\s*" )  )  )  )   {  return vcard ;   }   log . debug ( " ldapv card provider:  merging avatar element from passed vcard" )  ;   element current element = vcard . element ( "photo" )  ;  if  ( current element  !  =  null )   {  vcard . remove ( current element )  ;   }  vcard . add ( photo element )  ;  return vcard ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  publish subject <  integer >  sampler =  publish subject . 
@ override public void   (  object output out )  throws io exception  {  room . write external ( out )  ;   }  
@ override public int   (  )  {  return hash ;   }  
 string   ( int ds index )  throws  rrd exception  {  return  util .  xml . get child value ( ds nodes[ds index] "name" )  ;   }  
@ test public void   (  )  throws  exception  {  o = new  object (  )  ;   weak reference <  object >  wr = new  weak reference <  object >  ( o )  ;   test observer <  long >  to =  observable . just ( o )  . count (  )  . to observable (  )  . on termin
public void   (  )  {     code to name . clear (  )  ;     code cache . clear (  )  ;     ip to country . clear (  )  ;     pending search . clear (  )  ;     pendingi pv6 search . clear (  )  ;     not found . clear (  )  ;   }  
@ override public void   (  long args )  {  throw new  runtime exception ( "forced failure" )  ;   }  
private g   (  )  {  g g = new g (  )  ;  a (  )  ;  if  ( a . size (  )   =  =  0 )   {  d . error ( "amf reader::read item called without a amf reader::read object or a amf reader::read array before" )  ;  g . a ( com . jcumulus . server . rtmfp . flow . h .  end )  ;  return g ;   }  d d =  ( d ) a . get last (  )  ;  e = d . d ;  boolean flag = false ;  if  ( d . g  =  =  17 )   {  d . error ( "amf reader::read item on a dictionary  used amf reader::read key and amf reader::read value rather" )  ;  g . a ( com . jcumulus . server . rtmfp . flow . h .  end )  ;  return g ;   }  if  ( d . f . size (  )   >  0 )   {  g . a (  (  string ) d . f . get first (  )  )  ;  d . f . remove first (  )  ;   }  else if  ( d . g  =  =  10 )   {  if  ( d . a  =  =  0 )   {  flag = true ;   }  else  {  d . a -  -  ;  g . a ( "" )  ;   }   }  else if  (  ! d . e )   {  if  ( d . c )   {  d . c = false ;  g . a ( com . jcumulus . server . rtmfp . flow . h .  raw object content )  ;  return g ;   }  flag = true ;   }  else  {   string s = j (  )  ;  g . a ( s )  ;  if  (  strings . is null or empty ( s )  )   {  if  ( d . g  =  =  9 )   {  d . g = 10 ;  return i (  )  ;   }  flag = true ;   }  else if  ( d . g  =  =  0 )   ;   }  if  ( flag )   {  if  ( e  =  =  0 && d . g  !  =  10 )   {  byte byte0 = f . l (  )  ;  if  ( byte0  !  =  9 )  d . error ( "amf0 end marker object absent" )  ;   }  k = d . b ;  a (  )  ;  a . remove last (  )  ;  g . a ( com . jcumulus . server . rtmfp . flow . h .  end )  ;  return g ;   }  else  {  g . a ( g (  )  )  ;  return g ;   }   }  
private void   (  )  {  thread = new  thread ( " update  manager" )  {  @ override public void run (  )  {  try  {   thread . sleep ( 5000 )  ;  load saved info (  )  ;  while  ( is service enabled (  )  )   {  wait for next check (  )  ;  if  ( is service enabled (  )  )   {  try  {  check for server update ( true )  ;  check for plugins updates ( true )  ;   }  catch  (   exception e )   {   log . error ( " error checking for updates" e )  ;   }  long now =  system . current time millis (  )  ;   jive globals . set property ( "update . last check"  string . value of ( now )  )  ;  if  ( now  !  =   jive globals . get long property ( "update . last check" 0 )  )   {   log . error ( " error: update service check did not save correctly .  "  +  " stopping update service . " )  ;  return ;   }   }   }   }  catch  (   interrupted exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  thread = null ;   }   }  private void wait for next check (  )  throws  interrupted exception  {  long last check =  jive globals . get long property ( "update . last check" 0 )  ;  if  ( last check  =  =  0 )   {   thread . sleep ( 30000 )  ;   }  else  {  long elapsed =  system . current time millis (  )   -  last check ;  long frequency = get check frequency (  )  *  jive constants . hour ;  while  ( elapsed  <  frequency )   {   thread . sleep ( frequency  -  elapsed )  ;  elapsed =  system . current time millis (  )   -  last check ;   }   }   }   }   ;  thread . set daemon ( true )  ;  thread . start (  )  ;   }  
public   (  statement stmt )  {  this . stmt = stmt ;   }  
public   (  router context context )  {  ctx = context ;  log = ctx . log manager (  )  . get log ( get class (  )  )  ;   }  
protected void   (  map <  string  list <  string >  >  data )  {  stages data . put ( stage data )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  action on dispose )  {  return do on lifecycle (  functions . empty consumer (  )   functions . empty consumer (  )   functions . empty   action  functi
public void   (  string context id )  {  try  {     context =  context helper . get context ( context id )  ;     log =    context . log manager (  )  . get log (  update handler . class )  ;   }  catch  (   throwable t )   {  t . print stack trace (  )  ;   }   }  
public void   ( double new value )  throws io exception  {  double[] values = new double[rows] ;  for  ( int i = 0 ;  i  <  values . length ;  i +  +  )   {  values[i] = new value ;   }  update ( values )  ;   }  
@ override public void   (  )  {  log . info ( "running synch with crowd .  .  . " )  ;   crowd manager manager = null ;  try  {  manager =  crowd manager . get instance (  )  ;   }  catch  (   exception e )   {  log . error ( " failure to load the  crowd
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . unsafe create ( null )  ;   }  
synchronized public int   ( final byte[] bytes final int start final int size )  {  try  {  if  ( this . bytes available to read  =  =  0 &&  ! closed )  wait (  )  ;   }  catch  (  final  interrupted exception ie )   {  throw new  picard exception ( " interrupted while waiting to read from fifo . " ie )  ;   }  final int read pos = this . next read pos ;  final int distance to end = this . capacity  -  read pos ;  final int available = distance to end  <  this . bytes available to read  ?  distance to end : this . bytes available to read ;  final int length = available  <  size  ?  available : size ;   system . arraycopy ( this . bytes read pos bytes start length )  ;  this . bytes available to read -  = length ;  this . bytes available to write +  = length ;  this . next read pos =  ( read pos  +  length )  % this . capacity ;  notify (  )  ;  return length ;   }  
@ override public void   (  movie v )  {   system . out . println ( v )  ;   }  
public static boolean   (  string name boolean encrypt )  {  if  ( properties  =  =  null )   {  if  ( is setup mode (  )  )   {  return false ;   }  properties =  jive properties . get instance (  )  ;   }  return properties . set property encrypted ( name encrypt )  ;   }  
@ override protected void   (  maybe observer <  ?  super  object >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  assert false (  (  (  disposable ) observer )  . is disposed (  )  )  ;  to . dispose (  )  ;  assert true (  ( 
public static  session controller   (  )  {  return instance ;   }  
@ data provider public  object[][]   (  )  {  return new  object[][] {  { "seq   dict   test . dictionary . bad" }   { "seq   dict   test . dictionary . bad . vcf" }  }  ;   }  
public   ( final  file basecall dir final  file barcode dir final int lane )  {  this . lane = lane ;  this . basecall dir = basecall dir ;  this . barcode dir = barcode dir ;  this . intensity dir = basecall dir . get parent file (  )  ;  final  file data dir = intensity dir . get parent file (  )  ;  this . basecall lane dir = new  file ( basecall dir long lane str ( lane )  )  ;  this . intensity lane dir = new  file ( intensity dir long lane str ( lane )  )  ;  final  file interop dir = new  file ( data dir . get parent file (  )  " inter op" )  ;  tile metrics out = new  file ( interop dir " tile metrics out . bin" )  ;   }  
@ test public void   (  )  {   flowable <  string >  other =  flowable . just ( "a" "b" "c" )  ;   flowable <  string >  source = underlying subject . timeout ( timeout time   unit test scheduler other )  ;   subscriber <  string >  observer =  test helpe
public int   (  )  {  return  (  (  (  ( int ) rtcp data[24] )   <  <  24 )  & 0xff000000 )  |  (  (  (  ( int ) rtcp data[25] )   <  <  16 )  & 0x00ff0000 )  |  (  (  (  ( int ) rtcp data[26] )   <  <  8 )  & 0x0000ff00 ) |  ( rtcp data[27] & 0xff )  ;   }  
public int[]   ( int sample time )  throws io exception  {  if  ( linear offset  >  =  linear data . length )   {  return null ;   }  int byte len = sample rate * sample time * channels* 2  /  1000 ;  int[] data = new int[byte len  /  2] ;  int data offset = 0 ;  for  ( int i = 0 ;  i  <  byte len ;  i +  = 2 )   {  if  ( linear offset  >  =  linear data . length )   {  break ;   }  data[data offset +  + ] = linear data[linear offset +  + ] ;   }  return data ;   }  
public  string   (  )  {  return super . to string (  )   +  " operation: "  +  operation +  " address: " +  address ;   }  
@ xml element public  string   (  )  {  return password ;   }  
public void   ( int id )  {  this . id = id ;   }  
  (  merge observer < t u >  parent long id )  {  this . id = id ;  this . parent = parent ;   }  
public boolean   (  )  {  return buffer . size (  )   !  =  0 ;   }  
@ override public  map entry mappers   (  string value column )  {  this . value column = value column ;  return this ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  open indicator =  publish subject . create (  )  ;   publish subject <  integer > 
@ test public void   (  )  {   flowable . create ( source no cancel  backpressure strategy . latest )  . subscribe ( ts )  ;  source no cancel . on next ( 1 )  ;  source no cancel . on complete (  )  ;  ts . request ( 1 )  ;  ts . assert values ( 1 )  ;  
@ override public boolean   (  )  {  return false ;   }  
@ test public void   (  )  {  final  string template = "% { somevar } i" ;  final  log argument group extractor expected =  log argument group extractor . instance ( "" "" "somevar" "" "i" )  ;  final  matcher m = pattern . matcher ( template )  ;  m . fi
public long   (  )  {  return get sum ( new  hash set <  truth state >  (  arrays . as list (  truth state . values (  )  )  )  new  hash set <  call state >  (  arrays . as list (  call state . values (  )  )  )  )  ;   }  
@ visible for testing public void   (  string signature )  {  m signature = signature ;   }  
private static  string   (  string segment  string account )  {  return base   exteral   uri2 . build upon (  )  . append path ( segment )  . append query parameter ( "account" account )  . build (  )  . to string (  )  ;   }  
public   ( i2p app context context )  {  super ( context  session status message . message   type )  ;   }  
private void   (  rrd db rrd  def def )  throws io exception   rrd exception  {   string backend = def . get backend (  )  ;  if  ( pool used && backend  =  =  null )   {   rrd db pool . get instance (  )  . release ( rrd )  ;   }  else  {  rrd . close (  )  ;   }   }  
public synchronized void   (  )  {  sync lock = false ;  notify all (  )  ;   }  
@ test public void   (  )  {   runnable noop = new  runnable (  )  {  @ override public void run (  )  {   }   }   ;   unicast processor <  integer >  ap =  unicast processor . create ( 16 noop false )  ;  ap . on next ( 1 )  ;  ap . on error ( new  runti
private static void   (  map <  string  list <  string >  >  headers  string key  string value )  {   list <  string >  entry = headers . get ( key )  ;  if  ( entry  =  =  null )   {  headers . put ( key entry = new  array list <  string >  ( 1 )  )  ;   }  else  {  entry . clear (  )  ;   }  entry . add ( value )  ;   }  
public static void   ( final  content resolver cr final long[] message keys final int count )  {  delete rows for messages ( cr content   uri message keys count )  ;   }  
public   ( boolean rev )  {  super ( rev )  ;   }  
static  list <  string >    (  file u )  throws  exception  {   list <  string >  lines = new  array list <  string >  (  )  ;   buffered reader in = new  buffered reader ( new  file reader ( u )  )  ;  try  {  for  (  ;   ;   )   {   string line = in . read line (  )  ;  if  ( line  =  =  null )   {  break ;   }  lines . add ( line )  ;   }   }  finally  {  in . close (  )  ;   }  return lines ;   }  
public static  string   (  date old date )  {   timestamp stamp = new  timestamp (  system . current time millis (  )  )  ;   date current date = new  date ( stamp . get time (  )  )  ;  long diff = current date . get time (  )   -  old date . get time (  )  ;  long diff seconds = diff  /  1000 % 60 ;  long diff minutes = diff  /   ( 60 * 1000 )  % 60 ;  long diff hours = diff  /   ( 60 * 60 * 1000 )  % 24 ;  long diff days = diff  /   ( 24 * 60 * 60* 1000 )  ;   string seconds = diff seconds  =  =  0  ?  "" :  ( diff seconds  +  "  sec" )  ;   string minutes = diff minutes  =  =  0  ?  "" :  ( diff minutes  +  "  min " )  ;   string hours = diff hours  =  =  0  ?  "" :  ( diff hours  +  "  hours " )  ;   string days = diff days  =  =  0  ?  "" :  ( diff days  +  "  days " )  ;  return days  +  hours  +  minutes +  seconds +  " ago" ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . set once ( this s )  )   {  if  ( s instanceof  queue subscription )   {  @ suppress warnings ( "unchecked" )   queue subscription < t >  qs =  (  queue subscription < t >  ) s 
@ override public void   ( t t )  {  if  (  ! terminate )   {  if  ( has next )   {  on error ( new  illegal state exception ( "on next already called in this generate turn" )  )  ;   }  else  {  if  ( t  =  =  null )   {  on error ( new  null pointer exc
@ override protected  string   (  )  {  return "inet" ;   }  
public  string[]   (  )  {  return attributes ;   }  
@ deprecated public static  simple timer   (  )  {  return i2p app context . get global context (  )  . simple timer (  )  ;   }  
public void   ( int level )  {  try  {  if  ( connection . get transaction isolation (  )   =  =  level )   {  return ;   }  connection . set transaction isolation ( level )  ;   }  catch  (  sql exception e )   {  throw new  unable to manipulate transaction isolation level exception ( level e )  ;   }   }  
  (  conditional subscriber <  ?  super t >  actual  predicate <  ?  super t >  filter )  {  super ( actual )  ;  this . filter = filter ;   }  
private void   (  )  {  set listen on (  )  ;   string listen port = get listen port (  )  ;   string dest = get target destination (  )  ;   string shared client = get shared client (  )  ;  if  ( get persistent client key (  )  )   {   string priv key file = get priv key file (  )  ;     tunnel . run client ( new  string[] { listen port dest shared client priv key file }  this )  ;   }  else  {     tunnel . run client ( new  string[] { listen port dest shared client }  this )  ;   }   }  
@ override public boolean   (  )  {  return enabled ;   }  
public  local incoming server session   (  connection conn  streamid id  string from domain )  throws  unauthorized exception  {  if  ( server name  =  =  null )   {  throw new  unauthorized exception ( " server not initialized" )  ;   }   local incoming server session session = new  local incoming server session ( server name conn id from domain )  ;  conn . init ( session )  ;  conn . register close listener ( incoming server listener session )  ;  return session ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
private void   ( final sam record record )  {  if  ( record . get supplementary alignment flag (  )  )  return ;  metrics . total   reads +  +  ;  read length histogram . increment ( record . get read bases (  )  . length )  ;  if  (  ! record . get read fails vendor quality check flag (  )  )   {  metrics . pf   reads +  +  ;  if  ( is noise read ( record )  )  metrics . pf   noise   reads +  +  ;  if  ( record . get read unmapped flag (  )  )   {  final byte[] read bases = record . get read bases (  )  ;  if  (  !  ( record instanceof bam record )  )   string util . to upper case ( read bases )  ;  if  ( adapter utility . is adapter sequence ( read bases )  )   {  this . adapter reads +  +  ;   }   }  else if  ( do ref metrics )   {  metrics . pf   reads   aligned +  +  ;  if  ( record . get read paired flag (  )  &&  ! record . get proper pair flag (  )  )  metrics . pf   reads   improper   pairs +  +  ;  if  (  ! record . get read negative strand flag (  )  )  num positive strand +  +  ;  if  ( record . get read paired flag (  )  &&  ! record . get mate unmapped flag (  )  )   {  metrics . reads   aligned   in   pairs +  +  ;  final  integer mate mq = record . get integer attribute ( sam tag . mq . to string (  )  )  ;  if  ( mate mq  =  =  null || mate mq  >  =  mapping   quality   threshold && record . get mapping quality (  )   >  =  mapping   quality   threshold )   {   +  + this . chimeras denominator ;  if  (  chimera util . is chimeric ( record max insert size expected orientations )  )   {   +  + this . chimeras ;   }   }   }  else  {  if  ( record . get mapping quality (  )   >  =  mapping   quality   threshold )   {   +  + this . chimeras denominator ;  if  ( record . get attribute ( sam tag . sa . to string (  )  )   !  =  null )   +  + this . chimeras ;   }   }   }   }   }  
@ test public void   (  )  {   observable <  horror movie >  horrors =  observable . just ( new  horror movie (  )  )  ;   observable <  observable <  horror movie >  >  meta horrors =  observable . just ( horrors )  ;   observable .  <  media > merge ( m
public boolean   (  )  {  synchronized  (    state lock )   {  return    state  =  =   state . closed ||    state  =  =   state . init ;   }   }  
@ override public  integer   (  integer t1  integer t2 )  throws  exception  {  return t1  +  t2 ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write safeutf ( out subdomain )  ;   externalizable util . get instance (  )  . write safeutf ( out description )  ;   externalizable util
public   (  maybe source < t >  source )  {  super ( source )  ;   }  
private long   (  )  {  long now =    context . clock (  )  . now (  )  ;  long current hour = now  /  hour ;     current hour = current hour ;  long next =  (  ( 1  +  current hour )  * hour )   +  lag ;  return  math . max ( 5000 next  -  now )  ;   }  
public static  rate limiting configuration   (  )  {  final  rate limiting configuration new cfg = new  rate limiting configuration (  )  ;  final  request endpoint endpoint = new  request endpoint (  )  ;  endpoint . set include absolute limits (  boolean . true )  ;  endpoint . set uri regex ( " / v1 . 0 / limits /  ? " )  ;  new cfg . set request endpoint ( endpoint )  ;  new cfg . get limit group (  )  . add ( new configured limit group ( default   user   role default   uri default   uri   regex default   limit   group   id )  )  ;  new cfg . get limit group (  )  . add ( new multi method configured limit group ( default   user   role multi   method   uri multi   method   uri   regex multi   method   limit   group   id )  )  ;  new cfg . set global limit group ( new global limit group (  )  )  ;  return new cfg ;   }  
@ test public void   (  )  throws  exception  {  tos . write ( 0 )  ;  tos . write ( new byte[10] )  ;  tos . write ( new byte[10] 0 5 )  ;  assert equals ( 0 baos . size (  )  )  ;  tos . flush (  )  ;  assert equals ( 10 baos . size (  )  )  ;  tos . cl
@ test public void   (  )  {   observable . generate ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return null ;   }   }   new  bi function <  object  emitter <  object >   object >  (  )  {  @ override public  object apply
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . error ( new  test exception (  )  )  . time interval (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
public void   (  string ip )  {  this . ssdp multicasti pv4 = ip ;   }  
@ override public int   ( final  locus result that )  {  return this . snp . compare to ( that . snp )  ;   }  
public   ( final  scoring strategy duplicate scoring strategy )  {  this . duplicate scoring strategy = duplicate scoring strategy ;   }  
protected  iterable <  long >    ( boolean use infinite long elements )  {  return use infinite  ?  new  infinite range (  )  : new  finite range ( elements )  ;   }  
@ override public  string   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
boolean   ( boolean d boolean empty  observer <  ?  super t >  a )  {  if  ( cancelled )   {  queue . clear (  )  ;  return true ;   }  if  ( d )   {   throwable e = error ;  if  ( delay error )   {  if  ( empty )   {  if  ( e  !  =  null )   {  a . on error ( e )  ;   }  else  {  a . on complete (  )  ;   }  worker . dispose (  )  ;  return true ;   }   }  else  {  if  ( e  !  =  null )   {  queue . clear (  )  ;  a . on error ( e )  ;  worker . dispose (  )  ;  return true ;   }  else if  ( empty )   {  a . on complete (  )  ;  worker . dispose (  )  ;  return true ;   }   }   }  return false ;   }  
@ override public  row mapper <  map <  string  object >  >    (  result set rs  statement context ctx )  throws sql exception  {   result set meta data m = rs . get meta data (  )  ;  int column count = m . get column count (  )  ;   string[] column name
private void   ( int new value )  {  physical height dpi = new value ;   }  
static int   ( int value int poly )  {  if  ( poly  =  =  0 )   {  throw new  illegal argument exception ( "0 polynomial" )  ;   }  int msb set in poly = findmsb set ( poly )  ;  value <  <  = msb set in poly  -  1 ;  while  ( findmsb set ( value )   >  =  msb set in poly )   {  value^ = poly  <  <   ( findmsb set ( value )   -  msb set in poly )  ;   }  return value ;   }  
public boolean   ( jid user )  {  if  ( association policy  =  =   leaf node association policy . all )   {  return true ;   }  else if  ( association policy  =  =   leaf node association policy . owners )   {  return is admin ( user )  ;   }  else  {  return is admin ( user )  || association trusted . contains ( user )  ;   }   }  
public  array list   (  )  {  return mix descriptors ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   flowable . just ( 1 )  . do finally ( new  action (  )  {  @ override public void run (  )  throws  exception  {  throw new  test exception (
public void   (  )  {  this . enabled = false ;  if  ( data socket  !  =  null )   {  data socket . close (  )  ;   }   }  
public void   ( long id )  {  if  ( id  <  =  0 || id  >  max   id   value )  throw new  illegal argument exception ( "bad id "  +  id )  ;     tunnel id = id ;   }  
@ override public  servlet output stream   (  )  throws io exception  {  if  ( is get writer called )   {  throw new  illegal state exception ( "get writer (  )  has already been called" )  ;   }  is get output stream called = true ;  return get compressi
public void   ( int rule id )  {  db rule manager . delete rule ( rule id )  ;   }  
@ override public void   (  )  {  ts . cancel (  )  ;   }  
public  integer   (  )  throws  exception  {  if  ( actual server  =  =  null )   {  return null ;   }  return actual server . get http port (  )  ;   }  
@ test public void   (  )  {   test scheduler test = new  test scheduler (  )  ;   size and time bound replay buffer <  integer >  buf = new  size and time bound replay buffer <  integer >  ( 2 2000  time unit . milliseconds test )  ;   list <  integer > 
public static  group controller   (  )  {  return instance ;   }  
@ test public void   (  )  {   single <  list <  integer >  >  o =  observable . just ( 1 2 3 )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  {  return new  array list <  integer >  (  )  ;  
public  string   (  )  {  return " participant next hop lookup timeout" ;   }  
@ test @ ignore ( " observers can't throw" )  public void   (  )  {   atomic reference <  throwable >  on error = new  atomic reference <  throwable >  (  )  ;   subscriber <  string >  o = observer   success ( on error )  ;  try  {  o . on subscribe ( th
public synchronized void   (  )  {  unload controllers (  )  ;  load controllers (    config file )  ;  start controllers (  )  ;   }  
public  hash   (  )  {  return    peers[   peers . length  -  1] ;   }  
public void   ( long id )  {  if  ( id  <  0 )  set flag ( flag   no   ack )  ;     ack through = id ;   }  
public   ( final byte[] header final  file file final  byte buffer buf )  {  super ( header file float   size buf )  ;   }  
public   (  group element a  eddsa parameter spec spec )  {  this . a = a ;  this .  aneg = a . negate (  )  ;   aneg . precompute ( false )  ;  this . spec = spec ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . range ( 1 2 )  . reduce ( sum )  )  ;   }  
@ override public synchronized void   (  buffer rb )  {  super . set body ( rb )  ;   mail part part = get part (  )  ;  if  ( part  !  =  null )   {   string[] hdrs = part . header lines ;  for  ( int i = 0 ;  i  <  hdrs . length ;  i +  +  )   {   strin
public  string   (  )  {  return backend . get path (  )  ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set fail on non blocking scheduler ( true )  ;   flowable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  . map ( new  function <  integer  integer >  (  )  {  @ override public  i
@ override public  element   (  string username  element v card element )  throws  unsupported operation exception  {  if  ( db storage enabled && default provider  !  =  null )   {  if  ( is validv card change ( username v card element )  )   {   element
public void   (  string context removed )  {  this . context removed = context removed ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . zip with ( new  iterable <  object >  (  )  {  @ override public  iterator <  object >  iterator (  )  {  return null ;   }   }   new  bi function <  integer  object  ob
public boolean   ( long fetch header timeout long total timeout long inactivity timeout )  {     fetch header timeout =  ( int )  math . min ( fetch header timeout  integer . max   value )  ;     fetch end time =  ( total timeout  >  0  ?   system . current time millis (  )   +  total timeout :  - 1 )  ;     fetch inactivity timeout =  ( int )  math . min ( inactivity timeout  integer . max   value )  ;     keep fetching = true ;  if  (    log . should log (  log . debug )  )     log . debug ( " fetching  ( proxied ?  "  +     should proxy  +  " )  url = " +     actualurl )  ;  while  (    keep fetching )   {   socket timeout timeout = null ;  if  (    fetch header timeout  >  0 )   {  timeout = new  socket timeout (    fetch header timeout )  ;  final  socket timeout stimeout = timeout ;  timeout . set timeout command ( new  runnable (  )  {  public void run (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "timeout reached on "  +     url  +  ": " +  stimeout )  ;     aborted = true ;   }   }   )  ;  timeout . set total timeout period (    fetch end time )  ;   }  try  {  for  ( int i = 0 ;  i  <     listeners . size (  )  ;  i +  +  )     listeners . get ( i )  . attempting (    url )  ;  send request ( timeout )  ;  if  ( timeout  !  =  null )  timeout . reset timer (  )  ;  do fetch ( timeout )  ;  if  ( timeout  !  =  null )  timeout . cancel (  )  ;  if  (  !    transfer failed )  return true ;  break ;   }  catch  (  io exception ioe )   {  if  ( timeout  !  =  null )  timeout . cancel (  )  ;  for  ( int i = 0 ;  i  <     listeners . size (  )  ;  i +  +  )     listeners . get ( i )  . attempt failed (    url    bytes transferred    bytes remaining    current attempt    num retries ioe )  ;  if  (    log . should log (  log . warn )  )     log . warn ( "err: do fetch failed " ioe )  ;  if  ( ioe instanceof  malformedurl exception || ioe instanceof  unknown host exception || ioe instanceof  connect exception )     keep fetching = false ;   }  finally  {  if  (    out  !  =  null )   {  try  {     out . close (  )  ;   }  catch  (  io exception cioe )   {   }     out = null ;   }  if  (    proxy  !  =  null )   {  try  {     proxy . close (  )  ;     proxy = null ;   }  catch  (  io exception ioe )   {   }   }   }     current attempt +  +  ;  if  (    current attempt  >     num retries ||  (    already transferred  =  =  0 &&    current attempt  >  max   complete   fails )  ||  !    keep fetching )  break ;     redirects = 0 ;  try  {  long delay =    context . random (  )  . next int ( 60 * 1000 )  ;   thread . sleep ( 5 * 1000  +  delay )  ;   }  catch  (   interrupted exception ie )   {   }   }  for  ( int i = 0 ;  i  <     listeners . size (  )  ;  i +  +  )     listeners . get ( i )  . transfer failed (    url    bytes transferred    bytes remaining    current attempt )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " all attempts failed for "  +     url )  ;  return false ;   }  
public static  private key   (  file ks  string kspw  string alias  string keypw )  throws  general security exception  io exception  {   input stream fis = null ;  try  {   key store key store =  key store . get instance (  key store . get default type (  )  )  ;  fis = new  file input stream ( ks )  ;  char[] pwchars = kspw  !  =  null  ?  kspw . to char array (  )  : null ;  key store . load ( fis pwchars )  ;  char[] keypwchars = keypw . to char array (  )  ;  return  (  private key ) key store . get key ( alias keypwchars )  ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
public i2p snark util   (  )  {  return    util ;   }  
@delete @ path ( " /  { jid } " )  public  response   ( @ path param ( "jid" )   string jid @ default value ( "conference" )  @ query param ( "servicename" )   string service name @ path param ( "room name" )   string room name )  throws  service exceptio
private static  object   (  class type  string value )  throws  exception  {  if  ( type . get name (  )  . equals ( "java . lang .  string" )  )   {  return value ;   }  if  ( type . get name (  )  . equals ( "boolean" )  )   {  return  boolean . value of ( value )  ;   }  if  ( type . get name (  )  . equals ( "int" )  )   {  return  integer . value of ( value )  ;   }  if  ( type . get name (  )  . equals ( "long" )  )   {  return  long . value of ( value )  ;   }  if  ( type . get name (  )  . equals ( "float" )  )   {  return  float . value of ( value )  ;   }  if  ( type . get name (  )  . equals ( "double" )  )   {  return  double . value of ( value )  ;   }  if  ( type . get name (  )  . equals ( "java . util .  date" )  )   {  try  {  return date formatter . parse ( value )  ;   }  catch  (   exception ignored )   {   }   }  if  ( type . get name (  )  . equals ( "java . awt .  color" )  )   {   string tokenizer tokens = new  string tokenizer ( value " " )  ;  int red =  integer . parse int ( tokens . next token (  )  )  ;  int green =  integer . parse int ( tokens . next token (  )  )  ;  int blue =  integer . parse int ( tokens . next token (  )  )  ;  return new  color ( red green blue )  ;   }  if  ( type . get name (  )  . equals ( "java . lang .  class" )  )   {  return  class utils . for name ( value )  ;   }  return null ;   }  
public void   (  )  {  for  (   jarurl connection url : cached jar files )   {  try  {   log . info ( " unloading plugin jar file "  +  url . get jar file (  )  . get name (  )  )  ;  url . get jar file (  )  . close (  )  ;   }  catch  (   exception e )   {   log . error ( " failed to unload jar file" e )  ;   }   }   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  s =  subscription helper . cancelled ;  t v = value ;  value = null ;  if  ( v  =  =  null )   {  actual . on complete (  )  ;   }  else  {  actual . on success ( v )  ;   } 
public void   (  file directory boolean development mode )  {  try  {   file classes dir = new  file ( directory "classes" )  ;  if  ( classes dir . exists (  )  )   {  addurl ( classes dir . touri (  )  . tourl (  )  )  ;   }   file database dir = new  file ( directory "database" )  ;  if  ( database dir . exists (  )  )   {  addurl ( database dir . touri (  )  . tourl (  )  )  ;   }   file i18n dir = new  file ( directory "i18n" )  ;  if  ( i18n dir . exists (  )  )   {  addurl ( i18n dir . touri (  )  . tourl (  )  )  ;   }   file web dir = new  file ( directory "web" )  ;  if  ( web dir . exists (  )  )   {  addurl ( web dir . touri (  )  . tourl (  )  )  ;   }   file lib dir = new  file ( directory "lib" )  ;   file[] jars = lib dir . list files ( new  filename filter (  )  {  public boolean accept (   file dir   string name )  {  return name . ends with ( " . jar" )  || name . ends with ( " . zip" )  ;   }   }   )  ;  if  ( jars  !  =  null )   {  for  ( int i = 0 ;  i  <  jars . length ;  i +  +  )   {  if  ( jars[i]  !  =  null && jars[i] . is file (  )  )   {   string jar file uri = jars[i] . touri (  )  . to string (  )   +  " !  / " ;  if  ( development mode )   {  if  (  ! jars[i] . get name (  )  . equals ( "plugin - "  +  directory . get name (  )   +  " . jar" )  )   {  addurl file ( new url ( "jar" ""  - 1 jar file uri )  )  ;   }   }  else  {  addurl file ( new url ( "jar" ""  - 1 jar file uri )  )  ;   }   }   }   }   }  catch  (   malformedurl exception mue )   {   log . error ( mue . get message (  )  mue )  ;   }   }  
@ override public int   (  )  {  return p . hash code (  )  ^ g . hash code (  )  ;   }  
public static void   ( final  string[] args )  {  new  collect multiple metrics (  )  . instance main with exit ( args )  ;   }  
@ override public int   (  data input in  collection <  string >  collection )  throws io exception  {  return 0 ;   }  
public   (  router context enclosing context  router info peer long send on )  {  super ( enclosing context )  ;     peer = peer ;     send on = send on ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as observable ( new  function <  object  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   object v )  throws  exception  {   integer[] array = new  integer[
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . with latest from ( null new  bi function <  integer  object  object >  (  )  {  @ override public  object apply (   integer a   object b )  {  return 1 ;   }   }   )  ; 
public void   ( sax parse exception e )  {   log . error ( " fatal:"  +  e . get localized message (  )  )  ;  nr of errors +  +  ;   }  
public static boolean   (  context context long mailbox id )  {  if  ( mailbox id  <  0 )   {  return false ;   }  switch  ( get mailbox type ( context mailbox id )  )   {  case  - 1: case type   drafts: case type   outbox: return false ;   }  return true ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable . just ( 1 2 3 4 5 6 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . last element (  )  ;   
@ override public  string   (  )  {  return super . to string (  )   +  " socket: "  +  socket +  " session: " +  session ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . error (  functions .  <  throwable > null supplier (  )  )  . blocking get (  )  ;   }  
boolean   (  )  {  return    drop duplicates ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . just ( 1 )  . flat map maybe ( null )  ;   }  
public long   (  )  {  return    last changed ;   }  
@ test public void   (  )  {   observable <  long >  source =  observable . interval ( 1l  time unit . seconds scheduler )  . map ( new  function <  long  long >  (  )  {  @ override public  long apply (   long value )  {  if  ( value  =  =  1l )   {  thr
private void   (  imap list list char end )  throws io exception   messaging exception  {  for  (  ;   ;   )   {  for  (  ;   ;   )   {  final int next = peek (  )  ;  if  ( next  =  =  end )   {  return ;   }  if  ( next  !  =  ' ' )   {  break ;   }  read byte (  )  ;   }  final  imap element el = parse element (  )  ;  if  ( el  =  =  null )   {  return ;   }  list . add ( el )  ;   }   }  
public   ( byte[] bfkey )  {  int ni ;  m   pbox = new int[pbox   entries] ;  for  ( ni = 0 ;  ni  <  pbox   entries ;  ni +  +  )   {  m   pbox[ni] = pbox   init[ni] ;   }  m   sbox1 = new int[sbox   entries] ;  m   sbox2 = new int[sbox   entries] ;  m   sbox3 = new int[sbox   entries] ;  m   sbox4 = new int[sbox   entries] ;  for  ( ni = 0 ;  ni  <  sbox   entries ;  ni +  +  )   {  m   sbox1[ni] = sbox   init   1[ni] ;  m   sbox2[ni] = sbox   init   2[ni] ;  m   sbox3[ni] = sbox   init   3[ni] ;  m   sbox4[ni] = sbox   init   4[ni] ;   }  int n len = bfkey . length ;  if  ( n len  =  =  0 )  return ;  int n key pos = 0 ;  int n build = 0 ;  int nj ;  for  ( ni = 0 ;  ni  <  pbox   entries ;  ni +  +  )   {  for  ( nj = 0 ;  nj  <  4 ;  nj +  +  )   {  n build =  ( n build  <  <  8 )  |  (  (  ( int ) bfkey[n key pos] )  & 0x0ff )  ;  if  (  +  + n key pos  =  =  n len )   {  n key pos = 0 ;   }   }  m   pbox[ni]^ = n build ;   }  long l zero = 0 ;  for  ( ni = 0 ;  ni  <  pbox   entries ;  ni +  = 2 )   {  l zero = encrypt block ( l zero )  ;  m   pbox[ni] =  ( int )  ( l zero  >  >  >  32 )  ;  m   pbox[ni  +  1] =  ( int )  ( l zero & 0x0ffffffffl )  ;   }  for  ( ni = 0 ;  ni  <  sbox   entries ;  ni +  = 2 )   {  l zero = encrypt block ( l zero )  ;  m   sbox1[ni] =  ( int )  ( l zero  >  >  >  32 )  ;  m   sbox1[ni  +  1] =  ( int )  ( l zero & 0x0ffffffffl )  ;   }  for  ( ni = 0 ;  ni  <  sbox   entries ;  ni +  = 2 )   {  l zero = encrypt block ( l zero )  ;  m   sbox2[ni] =  ( int )  ( l zero  >  >  >  32 )  ;  m   sbox2[ni  +  1] =  ( int )  ( l zero & 0x0ffffffffl )  ;   }  for  ( ni = 0 ;  ni  <  sbox   entries ;  ni +  = 2 )   {  l zero = encrypt block ( l zero )  ;  m   sbox3[ni] =  ( int )  ( l zero  >  >  >  32 )  ;  m   sbox3[ni  +  1] =  ( int )  ( l zero & 0x0ffffffffl )  ;   }  for  ( ni = 0 ;  ni  <  sbox   entries ;  ni +  = 2 )   {  l zero = encrypt block ( l zero )  ;  m   sbox4[ni] =  ( int )  ( l zero  >  >  >  32 )  ;  m   sbox4[ni  +  1] =  ( int )  ( l zero & 0x0ffffffffl )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . concat (  arrays . as list (  maybe . just ( 1 )   maybe .  <  integer > error ( new  test exception (  )  )   maybe . just ( 3 )  )  )  . test (  )  . assert failure (  test exce
public  string   (  )  {  return name ;   }  
public void   (  string room name  string service name )  throws muc service exception  {  muc room chat room = xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( service name )  . get chat room ( room name . to lower case (  )  )  ;  if  ( chat room  !  =  null )   {  chat room . destroy room ( null null )  ;   }  else  {  throw new muc service exception ( " could not remove the channel" room name " chat room could be not found" )  ;   }   }  
@ test public void   (  )  throws  exception  {  assert false ( fo . is done (  )  )  ;  assert false ( fo . is cancelled (  )  )  ;  fo . cancel ( false )  ;  assert true ( fo . is done (  )  )  ;  assert true ( fo . is cancelled (  )  )  ;  try  {  fo .
public boolean   ( final  string read name final  physical location loc )  {  try  {  if  ( this . read name regex  =  =   read name parser . default   read   name   regex )   {  final int fields = get last three fields ( read name ':' tmp location fields )  ;  if  (  !  ( fields  =  =  5 || fields  =  =  7 )  )   {  if  ( null  !  =  log &&  ! this . warned about regex not matching )   {  this . log . warn (  string . format ( " default read   name   regex '%s' did not match read name '%s' .  "  +  " you may need to specify a read   name   regex in order to correctly identify optical duplicates .  "  +  " note that this message will not be emitted again even if other read names do not match the regex . " this . read name regex read name )  )  ;  this . warned about regex not matching = true ;   }  return false ;   }  loc . set tile (  ( short ) tmp location fields[0] )  ;  loc . setx ( tmp location fields[1] )  ;  loc . sety ( tmp location fields[2] )  ;  return true ;   }  else if  ( this . read name regex  =  =  null )   {  return false ;   }  else  {  if  ( this . read name pattern  =  =  null )  this . read name pattern =  pattern . compile ( this . read name regex )  ;  final  matcher m = this . read name pattern . matcher ( read name )  ;  if  ( m . matches (  )  )   {  loc . set tile (  ( short )  integer . parse int ( m . group ( 1 )  )  )  ;  loc . setx (  integer . parse int ( m . group ( 2 )  )  )  ;  loc . sety (  integer . parse int ( m . group ( 3 )  )  )  ;  return true ;   }  else  {  if  ( null  !  =  log &&  ! this . warned about regex not matching )   {  this . log . warn (  string . format ( "read   name   regex '%s' did not match read name '%s' .   your regex may not be correct .  "  +  " note that this message will not be emitted again even if other read names do not match the regex . " this . read name regex read name )  )  ;  warned about regex not matching = true ;   }  return false ;   }   }   }  catch  (   number format exception nfe )   {  if  ( log  !  =  null &&  ! this . warned about regex not matching )   {  this . log . warn ( "a field field parsed out of a read name was expected to contain an integer and did not .  " " read name: " read name " .   cause: " nfe . get message (  )  )  ;  warned about regex not matching = true ;   }  return false ;   }   }  
public void   (  )  {  default route = true ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  single < t >    (  )  {  return  rx java plugins . on assembly ( new  single cache < t >  ( this )  )  ;   }  
public  data structure   (  )  {  return new  lease set (  )  ;   }  
private static void   (  class <  ?  >  clazz  map <  string  jpa member >  members )  {  for  (   field member : clazz . get declared fields (  )  )   {  if  ( members . contains key ( member . get name (  )  )  )   {  continue ;   }   column column = member . get annotation (  column . class )  ;  if  ( column  !  =  null )   {  members . put ( member . get name (  )  new  jpa member ( clazz column member )  )  ;   }   }   }  
@ override protected  subject <  integer >    (  )  {  return  behavior subject . create (  )  ;   }  
@ override public boolean   ( final  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;  else return this . compare to (  (  haplotype block ) o )   =  =  0 ;   }  
protected void   ( final long new length )  throws io exception  {  m   write lock . lock (  )  ;  try  {  if  ( new length  >   integer . max   value )   {  throw new io exception ( " cannot create this big memory backed rrd" )  ;   }  buffer = new byte[ ( int ) new length] ;   }  finally  {  m   write lock . unlock (  )  ;   }   }  
private  collection < jid >    (  string group name )  {   cache <  string  collection < jid >  >  group membership cache =  cache factory . create local cache ( group   membership   cache   name )  ;   collection < jid >  members = group membership cache . get ( group name )  ;  if  ( members  !  =  null )   {  return members ;   }  try  {   list <  string >  users = manager . get group members ( group name )  ;   collection < jid >  results = new  array list <  >  (  )  ;  for  (   string username : users )   {  results . add ( server . createjid ( username null )  )  ;   }  group membership cache . put ( group name results )  ;  return results ;   }  catch  (   remote exception re )   {  log . error ( " failure to get the members of crowd group:"  +   string . value of ( group name )  re )  ;   }  group membership cache . put ( group name new  array list < jid >  (  )  )  ;  return  collections . empty list (  )  ;   }  
@ override public void   (  cancellable c )  {  set disposable ( new  cancellable disposable ( c )  )  ;   }  
final public static  truth and call states   ( final  variant context truth context final  string truth sample final  variant context call context final  string call sample final int min gq final int min dp final  boolean ignore filtered status )  {   truth state truth state = null ;   call state call state = null ;  final  genotype concordance state codes truth state code = get state code ( truth context truth sample min gq min dp )  ;  if  ( null  !  =  truth state code )   {  truth state =  genotype concordance states . truth map . get ( truth state code . ordinal (  )  )  ;   }   genotype concordance state codes call state code = get state code ( call context call sample min gq min dp )  ;  if  ( ignore filtered status && call state code  =  =   genotype concordance state codes . vc   filtered   code )   {  call state code = null ;   }  if  ( null  !  =  call state code )   {  call state =  genotype concordance states . call map . get ( call state code . ordinal (  )  )  ;   }  final  alleles alleles = normalize alleles ( truth state  =  =  null  ?  truth context : null truth sample call state  =  =  null  ?  call context : null call sample ignore filtered status )  ;  final  ordered set <  string >  all alleles = alleles . all alleles ;  final  string truth allele1 = alleles . truth allele1 ;  final  string truth allele2 = alleles . truth allele2 ;  final  string call allele1 = alleles . call allele1 ;  final  string call allele2 = alleles . call allele2 ;  if  ( null  =  =  truth state )   {  final int allele0idx = all alleles . index of ( truth allele1 )  ;  final int allele1idx = all alleles . index of ( truth allele2 )  ;  if  ( allele0idx  =  =  allele1idx )   {  truth state =  truth state . get hom ( allele0idx )  ;   }  else  {  truth state =  truth state . get var ( allele0idx allele1idx )  ;   }   }  if  ( null  =  =  call state )   {  final int allele0idx = all alleles . index of ( call allele1 )  ;  final int allele1idx = all alleles . index of ( call allele2 )  ;  if  ( allele0idx  =  =  allele1idx )   {  call state =  call state . get hom ( allele0idx )  ;   }  else  {  call state =  call state . get het ( allele0idx allele1idx )  ;   }  if  ( null  =  =  call state )   {  throw new  illegal state exception ( " this should never happen .  .  .   could not classify the call variant: "  +  call context . get genotype ( call sample )  )  ;   }   }  return new  truth and call states ( truth state call state )  ;   }  
@ override public  timestamp   (  string column label  calendar cal )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public static void   (  string[] args )  {  if  ( args . length  !  =  1 )   {   logger . println ( " usage: java  speech detector  <  . au file > " )  ;   system . exit ( 1 )  ;   }   treatment manager treatment manager = null ;  try  {  treatment manager = new  treatment manager ( args[0] 0 )  ;   }  catch  (  io exception e )   {   system . out . println ( " can't get treatment "  +  e . get message (  )  )  ;   system . exit ( 1 )  ;   }   media info media info = new  media info (  ( byte ) 0  rtp packet . pcm   encoding treatment manager . get sample rate (  )  treatment manager . get channels (  )  false )  ;   logger . println ( " media info "  +  media info )  ;   speech detector speech detector = new  speech detector ( " test" media info )  ;  byte[] linear data ;  while  (  ( linear data = treatment manager . get linear data bytes (  rtp packet . packet   period )  )   !  =  null )   {  if  ( speech detector . process data ( linear data )   =  =  true )   {  if  ( speech detector . is speaking (  )  )   {   logger . println ( " started speaking .  .  . " )  ;   }  else  {   logger . println ( " stopped speaking .  .  . " )  ;   }   }   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . scan with ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   null )  ;   }  
@ override public void   (  throwable e )  {  d =  disposable helper . disposed ;   maybe observer <  ?  super t >  a = actual ;  if  ( a  !  =  null )   {  actual = null ;  a . on error ( e )  ;   }   }  
@ override public  element   (  string username  element v card element )  throws  already exists exception  {  if  ( loadv card ( username )   !  =  null )   {  throw new  already exists exception ( " username "  +  username  +  " already has a v card" )
@ override public void   ( boolean can occupants change subject )  {  this . can occupants change subject = can occupants change subject ;   }  
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
public static  account   (  string name boolean save it  context context )  {   account account = new  account (  )  ;  account . m display name = name ;  account . m email address = name  +  "@android . com" ;  account . m sync key = "sync - key - "  +  name ;  account . m sync lookback = 1 ;  account . m sync interval =  account . check   interval   never ;  account . m host auth key recv = 0 ;  account . m host auth key send = 0 ;  account . m flags = 4 ;  account . m sender name = name ;  account . m protocol version = "2 . 5"  +  name ;  account . m policy key = 0 ;  account . m security sync key = "sec - sync - key - "  +  name ;  account . m signature = "signature - "  +  name ;  if  ( save it )   {  account . save ( context )  ;   }  return account ;   }  
public  xmpp result set   (  )  {  return result set ;   }  
public   (  control point ctrlp )  {  set control point ( ctrlp )  ;   }  
@ test ( expected =  index out of bounds exception . class )  public void   (  )  {   flowable . from array ( 1 2 )  . element at (  - 1 )  ;   }  
@ test public void   (  )  {   collector <  double  ?   optional double >  collector =  optional collectors . to optional double (  )  ;  assert that (  stream .  <  double > empty (  )  . collect ( collector )  )  . is empty (  )  ;  assert that (  strea
@ xml element public boolean   (  )  {  return members only ;   }  
public static  string   (  )  {  if  (  ! is shared secret allowed (  )  )   {  return null ;   }   string shared secret =  jive globals . get property ( "xmpp . auth . shared secret" )  ;  if  ( shared secret  =  =  null )   {  shared secret =  string utils . random string ( 8 )  ;   jive globals . set property ( "xmpp . auth . shared secret" shared secret )  ;   }  return shared secret ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   single <  integer >  source1 =  single . error ( new  test exception ( " first" )  )  ;   single <  integer >  source2 =  single . error ( ne
public  < t > t   (  class < t >  extension )  {  return get handle (  )  . attach ( extension )  ;   }  
@ test public void   (  )  {  run merge ( to hidden scalar new  test observer <  integer >  (  )  )  ;   }  
@ override public  iterator <  element >    (  string name  string node jid senderjid )  {   element identity =  document helper . create element ( "identity" )  ;  identity . add attribute ( "category" "proxy" )  ;  identity . add attribute ( "name" "soc
@ override public void   ( t t )  {   single source <  ?  extends r >  ms ;  try  {  ms =  object helper . require non null ( mapper . apply ( t )  " the mapper returned a null  single source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw i
public long   (  )  {  return    context . clock (  )  . now (  )   -     created ;   }  
@ override public  object   (  observable <  integer >  o )  throws  exception  {  return o . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  throws  exception  {  return new  array list <  intege
@ override public  connection   (  connection conn )  {  return c ;   }  
public boolean   (  string feature )  {  return features . contains ( feature )  ;   }  
@ override public int   ( char cbuf[] int off int len )  throws io exception  {  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  int c = read (  )  ;  if  ( c  <  0 )   {  if  ( i  =  =  0 )  return  - 1 ;  return i ;   }  cbuf[off  +  i] =  ( char ) c ; 
@ test public void   (  )  throws  exception  {  i2p app context context = i2p app context . get global context (  )  ;  i2p session session = create session (  )  ;   connection manager mgr = new  connection manager ( context session new  connection opti
private  compressing servlet input stream   (  )  throws io exception  {  if  ( compressedsis  =  =  null )   {  compressedsis = new  compressing servlet input stream ( http request . get input stream (  )  compressing stream factory context )  ;   }  return compressedsis ;   }  
public void   (  hash db entry )  {  if  (  !    initialized )  return ;   database entry o =    ds . get ( db entry )  ;  if  ( o  =  =  null )   {     kb . remove ( db entry )  ;     context . peer manager (  )  . remove capabilities ( db entry )  ;  return ;   }  if  ( o . get type (  )   =  =   database entry . key   type   routerinfo )   {  lookup before dropping ( db entry  (  router info ) o )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " dropping a lease: "  +  db entry )  ;     ds . remove ( db entry false )  ;   }  
public  collection <  conversation >    (  archive search search )  {  if  ( search . get query string (  )   !  =  null )   {  return lucene search ( search )  ;   }  else  {  return database search ( search )  ;   }   }  
public int   (  )  {  return weight ;   }  
@ override public  string   (  )  {  if  ( this . location  !  =  null )  return " book from "  +  this . location ;  return " map containing "  +  this . addresses . size (  )   +  " entries" ;   }  
public boolean   ( iq packet )  {  return false ;   }  
private static  string   (  string dest path )  {   string buffer sb = new  string buffer ( dest path )  ;  do  {  sb . append ( " . bak" )  ;   }  while  (  util . file exists ( sb . to string (  )  )  )  ;  return sb . to string (  )  ;   }  
@ override public void   (  )  {  cancelled = true ;   subscription helper . cancel ( main subscription )  ;   disposable helper . dispose ( other observer )  ;  if  ( get and increment (  )   =  =  0 )   {  queue = null ;  single item = null ;   }   }  
  (  subscriber <  ?  super t >  actual long count long time  time unit unit  scheduler scheduler int buffer size boolean delay error )  {  this . actual = actual ;  this . count = count ;  this . time = time ;  this . unit = unit ;  this . scheduler = scheduler ;  this . queue = new  spsc linked array queue <  object >  ( buffer size )  ;  this . delay error = delay error ;   }  
@ test ( expected =  index out of bounds exception . class )  public void   (  )  {   flowable . just ( "one" )  . take last (  - 1 )  ;   }  
private void   ( final  sink out final sam record rec )  {  if  ( include secondary alignments ||  ! rec . get not primary alignment flag (  )  )   {  out . add ( rec )  ;  if  ( this . progress . record ( rec )  && cross species reads  >  0 )   {  log . info (  string . format ( "%d  reads have been unmapped due to being suspected of being  cross - species contamination . " cross species reads )  )  ;   }   }   }  
@ test public void   (  )  {   flowable . sequence equal (  flowable . never (  )  new  flowable <  object >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  object >  s )  {  s . on subscribe ( new  boolean subscription ( 
@ override public int   (  )  {  if  (  !    hash code initialized )   {     hash code =  data helper . hash code (    identity )   +   ( int )    published ;     hash code initialized = true ;   }  return    hash code ;   }  
@ benchmark public void   (  blackhole bh )  {  nbp range . subscribe ( new  perf observer ( bh )  )  ;   }  
public   ( boolean authentication error  host auth host auth )  {  super ( null )  ;  if  ( authentication error )   {  m exception type = autodiscover   authentication   failed ;   }  else  {  m exception type = autodiscover   authentication   result ;   }  m host auth = host auth ;   }  
public static  string   ( int level )  {  switch  ( level )   {  case debug: return str   debug ;  case info: return str   info ;  case warn: return str   warn ;  case error: return str   error ;  case crit: return str   crit ;   }  return  ( level  >  crit  ?  str   crit : str   debug )  ;   }  
public   (  maybe on subscribe < t >  source )  {  this . source = source ;   }  
public  handle   (  )  {  return get jdbi (  )  . open (  )  ;   }  
protected int   (  node parent node  string child name )  throws  rrd exception  {   string value str = get child value ( parent node child name )  ;  return  integer . parse int ( value str )  ;   }  
public void   (  string userjid )  {  sysadmins . remove ( userjid . trim (  )  . to lower case (  )  )  ;  update sysadmin property (  )  ;   }  
private void   ( long start )  {  int elapsed =  ( int )  (  system . current time millis (  )   -  start )  ;  if  ( elapsed  <  0 )   {  elapsed = 0 ;   }  else if  ( elapsed  >  =  sleep distribution . length )   {  elapsed = sleep distribution . length  -  1 ;   }  sleep distribution[elapsed] +  +  ;   }  
public void   (  )  {  int n servers = size (  )  ;  for  ( int n = 0 ;  n  <  n servers ;  n +  +  )   {  http server server = gethttp server ( n )  ;  server . start (  )  ;   }   }  
public  string   ( int mode )  {  boolean enabled =  transport manager . isntcp enabled (    context )  ;   string hostname =    context . get property ( prop   i2np   ntcp   hostname )  ;  boolean specified = hostname  !  =  null && hostname . length (  )   >  0 ;   string auto =    context . get property ( prop   i2np   ntcp   auto   ip "true" )  ;  if  (  ( mode  =  =  0 &&  (  ! specified )  && auto . equals ( "false" )  && enabled )  ||  ( mode  =  =  1 && specified && auto . equals ( "false" )  && enabled )  ||  ( mode  =  =  2 && auto . equals ( "true" )  && enabled ) ||  ( mode  =  =  3 && auto . equals ( "always" )  && enabled ) ||  ( mode  =  =  4 &&  ! enabled )  )  return checked ;  return "" ;   }  
@ override public  observable <  object >    (  )  {  return  observable . never (  )  ;   }  
@ override public  long   (  object[] a )  throws  exception  {  return  (  long ) a[0] ;   }  
private  http host   (  string target host )  throws  http exception  {  try  {  return uri utils . extract host ( new uri ( target host )  )  ;   }  catch  (  uri syntax exception ex )   {  log . error ( " invalid target host url: "  +  target host ex )  ;   }  throw new  http exception ( " invalid target host" )  ;   }  
public void   (  )  {  mutex . unlock (  )  ;   }  
public long   (  )  {  return    expire idle write time ;   }  
@ test public void   (  )  {   flowable <  media >  o1 =  flowable .  <  media > just ( new  horror movie (  )  new  movie (  )  )  ;   flowable <  media >  o2 =  flowable . just ( new  media (  )  new  horror movie (  )  )  ;   flowable <  flowable <  me
public static  string   ( url url )  {  final  string path = url . get path (  )  ;  int last dot = path . last index of ( ' . ' )  ;  return  ( last dot  >  =  0 )   ?  path . substring ( last dot )  : "" ;   }  
public static void   ( final  server server )  throws  exception  {  register ( server server object name )  ;  register ( new  threading (  )   threading . object name )  ;  register ( new dns cache policy (  )  dns cache policy . object name )  ;   }  
public long   (  )  {  return connection pool . get borrowed count (  )  ;   }  
@ test ( expected exceptions =  picard exception . class )  public void   (  )  throws  exception  {  final  file output file =  file . create temp file ( "add comments to bam test . sam file"  bam file io utils . bam   file   extension )  ;  output file 
@ override public void   ( long n )  {  if  (  !  subscription helper . validate ( n )  )   {  return ;   }  if  (  backpressure helper . add ( this n )   !  =  0l )   {  return ;   }  long e = 0l ;  s s = state ;  final  bi function < s  ?  super  emitte
  (  string name  string rpn expression )  {  super ( name )  ;  this . rpn expression = rpn expression ;   }  
@ override public void   (  string username  date modification date )  throws  user not found exception  {  logger . finest ( "set modification date" )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  atomic reference <  throwable >  err = new  atomic reference <  throwable >  (  )  ;  normal . completable . subscr
@ override public void   (  )  {   disposable helper . dispose ( this )  ;  actual . on complete (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 0 2 )  . parallel ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  
public  string   (  )  {  return id ;   }  
public  string   (  )  {  return "sequence "  +  sequence  +  "  is missing " +  is missing +  "  data " +  data ;   }  
public void   (  configuration resource resolver resource resolver )  {  this . resource resolver = resource resolver ;   }  
public void   (  string category )  {   remote session task task = new  setter task ( address  setter task .  type . catergory category )  ;  do cluster task ( task )  ;   }  
public   (  simple timer .  timed event t long timeout ms )  {  if  (    log . should log (  log . debug )  )     log . debug ( " creating w /  delay "  +  timeout ms  +  " : " +  t )  ;     timed event = t ;     scheduled = timeout ms  +   system . current time millis (  )  ;   }  
static boolean   (  router context ctx )  {  if  ( ctx . net db (  )  . floodfill enabled (  )  )  return false ;  return ctx . get property ( "net db . floodfill only" default   floodfill   only )  ;   }  
@ override public boolean   (  )  {  return queue . is empty (  )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 256 )  ;  buf . append ( "con delay = " )  . append (    connect delay )  ;  buf . append ( " max size = " )  . append (    max message size )  ;  buf . append ( " rtt = " ) 
@ override public void   (  )  {  cache . clear (  )  ;   }  
public static  date   ( int year int month int date int hour int minute int second )  {  return new  date (  date . utc ( year  -  1900 month  -  1 date hour minute second )  )  ;   }  
@ test public void   (  )  {   observable . create ( new  observable on subscribe <  object >  (  )  {  @ override public void subscribe (   observable emitter <  object >  e )  throws  exception  {  e . on error ( null )  ;   }   }   )  . test (  )  . as
public  string   (  )  {  return protocol ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  500 ;  i +  +  )   {   test subscriber <  object >  ts =  flowable . merge (  flowable . just ( 1 )  . observe on (  schedulers . single (  )  )  . map ( new  function <  integer  object >  (  )  {  
@ override protected void   (  subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  ts . cancel (  )  ;  observer . on error ( new  test exception (  )  )  ;   }  
@ override public boolean   (  )  {  return password  !  =  null && password . trim (  )  . length (  )   >  0 ;   }  
  (  observer <  ?  super r >  actual  bi function < r  ?  super t r >  accumulator r value )  {  this . actual = actual ;  this . accumulator = accumulator ;  this . value = value ;   }  
public static boolean   (  )  {  return max rows supported ;   }  
private  string   (  method method  type return type )  {  return method . get declaring class (  )  . get simple name (  )   +  " . "  +  method . get name (  )  +  " method is annotated with @ sql update so should return void  boolean  or  number but is returning: " +  return type ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( "insert - keith" )  )  ;  assert that ( h . select ( "select name from something" )  . map to (  string . class )  . list (  
public boolean   ( final  string sequence name final int pos )  {  return sequence to bit set . get ( sequence name )   !  =  null && pos  <  =  sequence to bit set . get ( sequence name )  . length (  )  && sequence to bit set . get ( sequence name )  . get ( pos )  ;   }  
public boolean   ( final  read ends for mate cigar current )  {  return  ( current . is paired (  )  && 0  =  =  current . has unmapped )  ;   }  
public void   (  string page name  string property int new value )  {   string to store = page name  +  " = "  +  new value ;   user user = get user (  )  ;  if  ( user  !  =  null )   {   string values = user . get properties (  )  . get ( property )  ;  if  ( values  !  =  null )   {  if  ( values . contains ( to store )  )   {  return ;   }  else  {  if  ( values . contains ( page name )  )   {  int old value = get page property ( page name property  - 1 )  ;   string to remove = page name  +  " = "  +  old value ;  user . get properties (  )  . put ( property values . replace ( to remove to store )  )  ;   }  else  {  user . get properties (  )  . put ( property values  +  " "  +  to store )  ;   }   }   }  else  {  user . get properties (  )  . put ( property to store )  ;   }   }   }  
@ test public void   (  )  {   flowable . just ( 1 2 )  . do after next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test (  )  . assert failur
@ test public void   (  )  {   timed <  integer >  t1 = new  timed <  integer >  ( 1 5  time unit . seconds )  ;   timed <  integer >  t2 = new  timed <  integer >  ( 1 5  time unit . seconds )  ;   timed <  integer >  t3 = new  timed <  integer >  ( 2 5 
public void   (  string s )  {  if  ( s  !  =  null )   {  try  {     config . set limit minute (  integer . parse int ( s . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
private  string   (  )  {   string s = get tunnel (  )  . get client options (  )  . get property ( prop   ssl   outproxies )  ;  if  ( s  =  =  null )  return null ;   string[] p =  data helper . split ( s "[  ;  \r\n\t]" )  ;  if  ( p . length  =  =  0 )  return null ;  if  ( p . length  =  =  1 )  return p[0] ;  int i =    context . random (  )  . next int ( p . length )  ;  return p[i] ;   }  
@ override public void   ( t value )  {   iterator <  ?  extends r >  iterator ;  boolean has ;  try  {  iterator = mapper . apply ( value )  . iterator (  )  ;  has = iterator . has next (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if 
private boolean   (  garlic clove clove )  {   string invalid reason =    context . message validator (  )  . validate message ( clove . get clove id (  )  clove . get expiration (  )  . get time (  )  )  ;  boolean rv = invalid reason  =  =  null ;  if  (  ! rv )   {   string how long ago =  data helper . format duration (    context . clock (  )  . now (  )   -  clove . get expiration (  )  . get time (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " clove is not valid: id = "  +  clove . get clove id (  )   +  " expiration " +  how long ago +  " ago" new  exception ( " invalid within .  .  . " )  )  ;  else if  (    log . should log (  log . warn )  )     log . warn ( " clove is not valid: id = "  +  clove . get clove id (  )   +  " expiration " +  how long ago +  " ago: " +  invalid reason +  ": " +  clove )  ;     context . message history (  )  . message processing error ( clove . get clove id (  )  clove . get data (  )  . get class (  )  . get simple name (  )  " clove is not valid  ( expiration "  +  how long ago  +  " ago ) " )  ;   }  return rv ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ test public void   (  )  throws  exception  {   metric registry registry = new  metric registry (  )  ;   aggregate meter factory parent factory = new  summing meter factory ( registry "parent" )  ;   aggregate meter factory child factory = parent facto
public void   (  list < jid >  jids )  {  if  ( admin list  =  =  null )   {  admin list = new  array list <  >  (  )  ;   }  else  {  admin list . clear (  )  ;   }   list < jid >  admins = new  array list <  >  (  )  ;  for  (  jid jid : jids )   {  if  ( jid  !  =  null )   {  admins . add ( jid . as barejid (  )  )  ;   }   }  admin list . add all ( admins )  ;  provider . set admins ( admins )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . contains ( 2 )  . test (  )  . assert result ( false )  ;   }  
public long   (  )  {  return iq set . get (  )  ;   }  
public  string   (  context context )  {   host auth host auth = get or create host auth recv ( context )  ;  if  ( host auth  !  =  null )   {  return host auth . m protocol ;   }  return null ;   }  
@ test public void   (  )  throws io exception  {  byte[] serialized = serializer . write object ( target )  ;  assert not null ( serialized )  ;   }  
@ override public int   (  )  {  return  ( count  <  <  16 )  ^ size ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . concat with (  flowable . just ( 2 )  . delay ( 500  time unit . milliseconds )  )  . skip last ( 300  time unit . milliseconds true )  . test (  )  . await done ( 5  time unit . seconds )  . assert 
public synchronized  string   (  )  throws io exception  {  return header . get info (  )  ;   }  
protected void   (  http servlet request request  http servlet response response  http content content )  throws io exception  {   input stream in = null ;  try  {  in = content . get input stream (  )  ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not found: "  +  content )  ;  response . send error ( 404 )  ;  return ;   }   output stream out = null ;  try  {  out = response . get output stream (  )  ;   }  catch  (   illegal state exception e )   {  out = new  writer output stream ( response . get writer (  )  )  ;   }  long content   length = content . get content length (  )  ;   enumeration <  ?  >  req ranges = request . get headers ( " range" )  ;  if  ( req ranges  =  =  null ||  ! req ranges . has more elements (  )  )   {  write headers ( response content content   length )  ;  if  ( content   length  >  =  0 && request . get method (  )  . equals ( "head" )  )   {  if  (    log . should log (  log . info )  )     log . info ( "head: "  +  content )  ;   }  else  {  copy ( in out )  ;   }  return ;   }   list <  inclusive byte range >  ranges =  inclusive byte range . satisfiable ranges ( req ranges content   length )  ;  if  ( ranges  =  =  null || ranges . size (  )   !  =  1 )   {  write headers ( response content content   length )  ;  response . set status ( 416 )  ;  response . set header ( " content -  range"  inclusive byte range . to416 header range string ( content   length )  )  ;  in . close (  )  ;  return ;   }   inclusive byte range single satisfiable range = ranges . get ( 0 )  ;  long single length = single satisfiable range . get size ( content   length )  ;  write headers ( response content single length )  ;  response . set status ( 206 )  ;  response . set header ( " content -  range" single satisfiable range . to header range string ( content   length )  )  ;  copy ( in single satisfiable range . get first ( content   length )  out single length )  ;   }  
private   (  map <  string  cached rate limit >  limit map  pair <  configured ratelimit  cached rate limit >  lowest limit )  {  this . limit map = new  concurrent hash map <  >  ( limit map )  ;  this . least remaining limit = lowest limit ;   }  
private int   ( o element )  {  if  ( elements  !  =  null )   {  for  ( int i = 0 ;  i  <  elements . length ;  i +  +  )  if  ( elements[i] . equals ( element )  )  return i ;   }  return  - 1 ;   }  
@ override public void   (  disposable s )  {   disposable helper . set once ( this s )  ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return 1  /  v  >  0 ;   }   }   new  bi function <  long  th
public  list <  pre adapter detail metrics >    (  )  {  return pre adapter detail metrics list ;   }  
@ test public void   (  )  {   test subscriber <  list <  integer >  >  ts = new  test subscriber <  list <  integer >  >  ( 3l )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable . unsafe create ( new  publisher <  integer >  (  )  {
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable sour
public void   (  )  {  print ( true )  ;   }  
public   ( int max size )  {  if  ( max size  <  1 )  throw new  illegal argument exception (  )  ;     max size = max size ;     messages = new  linked list <  message >  (  )  ;   }  
public boolean   (  )  {  boolean already =    success ;     success = true ;  return already ;   }  
public  disposable   ( int index  disposable resource )  {  for  (  ;   ;   )   {   disposable o = get ( index )  ;  if  ( o  =  =   disposable helper . disposed )   {  resource . dispose (  )  ;  return null ;   }  if  ( compare and set ( index o resource )  )   {  return o ;   }   }   }  
public  read type   (  )  {  return read type ;   }  
@ override public void   (  )  {  wait until ( "message" new  condition (  )  {  @ override public boolean is met (  )  {  return false ;   }   }   0 )  ;   }  
public   (  observable source < t >  source  function <  ?  super  observable <  object >   ?  extends  observable source <  ?  >  >  handler )  {  super ( source )  ;  this . handler = handler ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 3 )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public voi
void   ( final int n )  throws io exception  {  int bytes skipped = ras . skip bytes ( n )  ;  if  ( this . debug )   {   system . out . println ( " skipping "  +  bytes skipped  +  " bytes" )  ;   }   }  
public boolean   (  )  {  return    are files public ;   }  
public void   (  )  {   set <  forward port >  ports ;  synchronized  ( lock )   {  ports = new  hash set <  forward port >  ( ports forwarded )  ;   }  if  ( ports . is empty (  )  )  return ;  this . unregister ports ( ports )  ;   }  
public void   (  garlic config config )  {  if  ( config  !  =  null )   {     clove configs . add ( config )  ;   }   }  
private void   (  media info media info )  throws io exception  {  au header = new byte[24] ;  au header[0] = ' . ' ;  au header[1] = 's' ;  au header[2] = 'n' ;  au header[3] = 'd' ;  au header[7] = 24 ;  int encoding = media info . get encoding (  )  ;  if  ( encoding  =  =   rtp packet . pcmu   encoding )   {  au header[15] = 1 ;   }  else  {  au header[15] = 3 ;   }  int sample rate = media info . get sample rate (  )  ;  au header[16] =  ( byte )  (  ( sample rate  >  >  24 )  & 0xff )  ;  au header[17] =  ( byte )  (  ( sample rate  >  >  16 )  & 0xff )  ;  au header[18] =  ( byte )  (  ( sample rate  >  >  8 )  & 0xff )  ;  au header[19] =  ( byte )  ( sample rate & 0xff )  ;  int channels = media info . get channels (  )  ;  au header[20] =  ( byte )  (  ( channels  >  >  24 )  & 0xff )  ;  au header[21] =  ( byte )  (  ( channels  >  >  16 )  & 0xff )  ;  au header[22] =  ( byte )  (  ( channels  >  >  8 )  & 0xff )  ;  au header[23] =  ( byte )  ( channels & 0xff )  ;  bo . write ( au header 0 au header . length )  ;   }  
@ before public void   (  )  throws  exception  {  template engine = new  defined attribute template engine (  )  ;  parser = new  colon prefix sql parser (  )  ;  ctx = mock (  statement context . class )  ;   }  
public void   ( boolean send disconnect )  {  synchronized  (    state lock )   {  if  (    state  =  =   state . closing ||    state  =  =   state . closed ||    state  =  =   state . init )  return ;  change state (  state . closing )  ;   }  if  (    log . should log (  log . info )  )     log . info ( get prefix (  )   +  " destroy the session" new  exception ( " destroy session (  ) " )  )  ;  if  ( send disconnect &&    producer  !  =  null )   {  try  {     producer . disconnect ( this )  ;   }  catch  (  i2p session exception ipe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error destroying the session" ipe )  ;   }   }  if  (    availability notifier  !  =  null )     availability notifier . stop notifying (  )  ;  close socket (  )  ;     subsession map . clear (  )  ;  if  (    session listener  !  =  null )     session listener . disconnected ( this )  ;   }  
public static  class <  ?  >    ( final  class loader class loader final  string class name )  throws  class not found exception  {  if  ( class name  =  =  null )   {  throw new  illegal argument exception ( " class name cannot be null ! " )  ;   }  if  ( class name . length (  )   <  =  max   prim   classname   length &&  character . is lower case ( class name . char at ( 0 )  )  )   {  for  ( int i = 0 ;  i  <  primitive   classes   array . length ;  i +  +  )   {  if  ( class name . equals ( primitive   classes   array[i] . get name (  )  )  )   {  return primitive   classes   array[i] ;   }   }   }   class loader the class loader = class loader ;  if  ( class name . starts with ( "com . hazelcast . " )  || class name . starts with ( "[ lcom . hazelcast . " )  )   {  the class loader =  hazelcast instance . class . get class loader (  )  ;   }  if  ( the class loader  =  =  null )   {  the class loader =  thread . current thread (  )  . get context class loader (  )  ;   }  if  ( the class loader  !  =  null )   {  if  ( class name . starts with ( "[" )  )   {  return  class . for name ( class name true the class loader )  ;   }  else  {  return the class loader . load class ( class name )  ;   }   }  return  class . for name ( class name )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   test observer <  integer >  to = pp1 . single element (  )  . timeout ( 
public static void   ( jid roomjid jid user )  {  for  (  muc event listener listener : listeners )   {  listener . occupant left ( roomjid user )  ;   }   }  
@ override public long   (  )  {  return 1 ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final  replay processor <  integer >  rp =  replay processor . create with time and size ( 1  time unit . seconds scheduler 2 )  ;   test subscriber <  integer >  ts = 
public void   (  )  {  if  ( attachments  !  =  null )   {  attachments . clear (  )  ;   }   }  
public void   (  string workgroup  packet packet boolean read boolean processed )  throws  packet rejected exception  {  if  (  ! read || processed )   {  return ;   }  jid jid = packet . get from (  )  ;  if  ( jid ban map . contains key ( jid . to barejid (  )  )  || domain ban map . contains key ( jid . get domain (  )  )  )   {  send notifications ( packet jid . to string (  )  )  ;   packet rejected exception exception = new  packet rejected exception ( " user '"  +  packet . get from (  )  . to barejid (  )   +  "' not allowed to join queue . " )  ;  if  ( rejection message  !  =  null )   {  exception . set rejection message ( rejection message )  ;   }  throw exception ;   }   }  
@ test public void   (  )  {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable .  <  integer > error ( new  test exception (  )  )  . concat with (  single . just ( 100 )  )  . subscribe ( ts )  ;  ts . asser
@ test public void   (  )  {   publish subject <  integer >  source1 =  publish subject . create (  )  ;   publish subject <  integer >  source2 =  publish subject . create (  )  ;   observable <  integer >  duration1 =  observable .  <  integer > error (
@ test public void   (  )  {   string total = "" ;  for  (  char i : l )  total +  = i ;  assert equals ( "abc" total )  ;  for  (  char i : l )  total +  = i ;  assert equals ( "abcabc" total )  ;  total = "" ;  iter = l . iterator (  )  ;  total +  = it
public int   (  )  {  return minor ;   }  
public void   (  properties props )  {     inbound settings . read from properties ( "inbound . " props )  ;     outbound settings . read from properties ( "outbound . " props )  ;   }  
private boolean   (  string user id )  {  return datastore service . get default datastore (  )  . remove ( user id )  ;   }  
public  message   (  )  {  return room subject ;   }  
public void   (  )  {  final  array list <  queued operation >  temp = new  array list <  queued operation >  ( m pending operations )  ;  for  (   queued operation qo : temp )   {  qo . cancel (  )  ;   }   }  
private   (  parcel in )  {  super ( in )  ;  m value = in . read string (  )  ;   }  
private void   (  lock request qlr )  {  log . debug ( " registering thread: "  +  qlr . get thread reference (  )  . to string (  )  )  ;  if  (  ! threads holding lock . add ( qlr . get thread reference (  )  )  )   {  log . warn ( "failed thread registration [lock key: "  +  qlr . get lock key (  )   +  "]" )  ;   }  if  (  ! locked )   {  locked = true ;  current key = qlr . get lock key (  )  ;   }   }  
@ test public void   (  )  {   publish processor <  integer >  source1 =  publish processor . create (  )  ;   publish processor <  integer >  source2 =  publish processor . create (  )  ;   flowable <  integer >  duration1 =  flowable .  <  integer > err
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  private storage = server . get private storage (  )  ;   }  
private void   (  optional <  row mapper <  ?  >  >  mapper  tuple expected )  throws sql exception  {  assert that ( mapper . is present (  )  )  ;  assert that ( mapper . get (  )  )  . is instance of (  row mapper . class )  ;  assert that ( mapper . get (  )  . map ( null null )  )  . is equal to ( expected )  ;   }  
private  string   (  )  {  return settings . get chat setting (  key enum . invitation   resent   message )  . get value (  )  ;   }  
@ override public  collection <  user provider >    (  )  {  return mapper . get user providers (  )  ;   }  
@ override public void   (  disposable d )  {  if  ( observers . get (  )   =  =  terminated )   {  d . dispose (  )  ;   }   }  
@ deprecated public  nio socket acceptor   (  )  {  return get socket acceptor (  connection type . connection   manager true )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ receive message begin message: " )  ;  buf . append ( "\n\t session id: " )  . append (    session id )  ;  buf . append ( "\n\t message id: " )  . a
@ data provider ( name = " " )  public  object[][] bad data (  )  {  return new  object[][] {  { test   input   vcf   empty test   output test   genotypes   vcf1 subsetted   haplotype   database   for   testing }   { test   input   vcf   no   file test   
@ override public void   ( t t )  {  if  ( empty )   {  empty = false ;   }  actual . on next ( t )  ;   }  
 list <  string >    (  )  {   list <  string >  rv = new  array list <  string >  ( 16 )  ;  for  (   transport t :    transports . values (  )  )   {  rv . add all ( t . get most recent error messages (  )  )  ;   }  return rv ;   }  
@ suppress warnings ( "unchecked" )  public void   (  )  {  long now =    context . clock (  )  . now (  )  ;   list <  message selector >  removing = new  array list <  message selector >  ( 8 )  ;  synchronized  (    selectors )   {  for  ( int i = 0 ; 
private void   ( final  file hazelcast plugin directory )  {  logger . info ( " all plugins have initialized ;  initializing clustering" )  ;  final  string openfire home =  jive globals . get home directory (  )  ;   file plugin dir = new  file ( openfire home "plugins" )  ;   file[] jars = plugin dir . list files ( new  file filter (  )  {  @ override public boolean accept (   file pathname )  {   string file name = pathname . get name (  )  . to lower case (  )  ;  return  ( file name . equals ignore case ( "enterprise . jar" )  || file name . equals ignore case ( "coherence . jar" )  )  ;   }   }   )  ;  if  ( jars  !  =  null && jars . length  >  0 )   {  logger . warn ( " conflicting clustering plugins found ;  remove  coherence and / or  enterprise jar files" )  ;  return ;   }  try  {  final  path path to local hazelcast config =  paths . get ( openfire home "conf / hazelcast - local - config . xml" )  ;  if  (  !  files . exists ( path to local hazelcast config )  )   {   files . copy (  paths . get ( hazelcast plugin directory . get absolute path (  )  "classes / hazelcast - local - config . xml . template" )  path to local hazelcast config )  ;   }   cluster manager . startup (  )  ;   }  catch  (  final io exception e )   {  logger . warn ( " unable to create local  hazelcast configuration file from template ;  clustering will not start" e )  ;   }   }  
@ override public void   ( t t )  {  queue . offer (  notification lite . next ( t )  )  ;   }  
@ test public void   (  )  {  final  variant context context one = build variant context ( "source" "one" 100 )  ;  final  list <  string >  contigs = get ordered contig list ( context one )  ;   assert . assert equals ( 0 new  variant context comparator 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  array composite disposable acd = new  array composite disposable ( 2 )  ;   runnable r = new  runnable (  )  {  @ override public void r
public static  externalizable util   (  )  {  return instance ;   }  
@ override public  long   (  )  {  return count +  +  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . concat map completable delay error ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  return  completable
public  string   (  )  {  return registered   name ;   }  
@ test ( timeout = 5000 )  public void   (  )  throws  exception  {   list <  observable <  integer >  >  source list = new  array list <  observable <  integer >  >  ( 3 )  ;  source list . add (  observable . range ( 0 100000 )  . subscribe on (  schedu
@ override public  iterator < v >    (  )  {  return new  iterator < v >  (  )  {  private final  iterator <  default cache .  cache object < v >  >  it = cached objects . iterator (  )  ;  @ override public boolean has next (  )  {  return it . has next 
public  icon   (  string uri )  {   icon list icon list = get icon list (  )  ;  if  ( icon list . size (  )   <  =  0 )  return null ;  int n icon = icon list . size (  )  ;  for  ( int n = 0 ;  n  <  n icon ;  n +  +  )   {   icon icon = icon list . get icon ( n )  ;  if  ( icon . isurl ( uri )  )  return icon ;   }  return null ;   }  
public   ( final  set <  metric accumulation level >  accumulation levels final  list < sam read group record >  sam rg records final int c quality threshold final int next base quality threshold final int min read length final double max mismatch rate )  {  this . c quality threshold = c quality threshold ;  this . next base quality threshold = next base quality threshold ;  this . min read length = min read length ;  this . max mismatch rate = max mismatch rate ;  setup ( accumulation levels sam rg records )  ;   }  
@ xml element ( name = "group" )  @ xml element wrapper ( name = "groups" )  public  list <  string >    (  )  {  return groups ;   }  
public   (  node subscription subscription )  {  super ( subscription . get node (  )  )  ;  sub id = subscription . getid (  )  ;  state = subscription . get state (  )  ;  owner = subscription . get owner (  )  ;  sub jid = subscription . getjid (  )  ;   }  
@ override public final boolean   (  imap element that )  {  if  (  ! super . equals for test ( that )  )   {  return false ;   }   imap string that string =  (  imap string ) that ;  return get string (  )  . equals ( that string . get string (  )  )  ; 
@ override public void   (  string username  date creation date )  throws  user not found exception  {  logger . finest ( "set creation date" )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 1024 )  . concat map single ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (   integer v )  throws  exception  {  return  single 
@ override public void   (  )  {  lists . add ( new  array list <  string >  ( list )  )  ;  list . clear (  )  ;   }  
public static  integer   (  date date )  {  return  integer . value of ( date . get hours (  )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . range ( 1 5 )  . buffer ( 1  time unit . days  schedulers . single (  )  2  functions .  <  integer > create array list ( 16 )  true )  . test (  )  . assert result (  arrays
private  mendelian violation detector   (  )  {  return new  mendelian violation detector (  immutable set . copy of ( skip   chroms )   immutable set . copy of ( male   chroms )   immutable set . copy of ( female   chroms )  min   het   fraction min   gq min   dp generate trio metrics base (  )   immutable list . copy of ( par intervals . get (  )  )  progress logger )  ;   }  
public  string   ( int[] linear data )  {  number of times called +  +  ;  long start =  system . current time millis (  )  ;  if  ( sample rate converter  !  =  null )   {  try  {  int n samples = linear data . length ;  linear data = sample rate converter . resample ( linear data )  ;  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( " resample for  dtmf: n samples "  +  n samples  +  " new n samples " +  linear data . length )  ;   }   }  catch  (  io exception e )   {   logger . println ( " call "  +  member receiver  +  "  dtmf decoder: " +  e . get message (  )  )  ;   }   }  int keys[] = new int[max   keys] ;  int nkeys = decoder . decode ( keys  audio conversion . ints to shorts ( linear data )  0 )  ;   string dtmf keys = null ;  if  ( nkeys  >  0 )   {  char[] char keys = new char[nkeys] ;  for  ( int i = 0 ;  i  <  nkeys ;  i +  +  )   {  char keys[i] = char   keys[keys[i]] ;   }  dtmf keys = new  string ( char keys )  ;   }  total decode time +  =  (  system . current time millis (  )   -  start )  ;  return dtmf keys ;   }  
public   ( boolean fold case )  {  this . fold case = fold case ;   }  
public boolean   (  string id )  {  if  ( backends . contains key ( id )  )   {  backends . remove ( id )  ;  return true ;   }  return false ;   }  
@ test public void   (  )  throws  exception  {   system . gc (  )  ;   thread . sleep ( 100 )  ;  long start =  management factory . get memorymx bean (  )  . get heap memory usage (  )  . get used (  )  ;  source =  flowable . from callable ( new  calla
@ override public void   (  subscriber <  ?  super c > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )   subscriber < t > [] parents = new  subscriber[n] ;  f
public  string   (  )  {   string builder buf = new  string builder ( 512 )  ;  buf . append ( " < div id = \"availablethemes\" > " )  ;   string current =    context . get property ( css helper . prop   theme   name css helper . default   theme )  ;   set <  string >  themes = theme set (  )  ;  for  (   string theme : themes )   {  buf . append ( " < label for = \"" )  . append ( theme )  . append ( "\" >  < div class = \"themechoice\" > " )  . append ( " < input type = \"radio\" class = \"optbox\" name = \"theme\" " )  ;  if  ( theme . equals ( current )  )  buf . append ( checked )  ;  buf . append ( "value = \"" )  . append ( theme )  . append ( "\" id = \"" )  . append ( theme )  . append ( "\" > " )  . append ( " < object height = \"48\" width = \"48\" data = \" / themes / console / " )  . append ( theme )  . append ( " / images / thumbnail . png\" > " )  . append ( " < img height = \"48\" width = \"48\" alt = \"\" src = \" / themes / console / images / thumbnail . png\" > " )  . append ( " <  / object >  < br > " )  . append ( " < div class = \"themelabel\" > " )  . append (    t ( theme )  )  . append ( " <  / div > " )  . append ( " <  / div >  <  / label > \n" )  ;   }  boolean universal theming =    context . get boolean property ( css helper . prop   universal   theming )  ;  buf . append ( " <  / div >  < div id = \"themeoptions\" > " )  ;  buf . append ( " < label >  < input type = \"checkbox\" name = \"universal theming\" " )  ;  if  ( universal theming )  buf . append ( checked )  ;  buf . append ( "value = \"1\" > " )  . append (    t ( " set theme universally across all apps" )  )  . append ( " <  / label >  < br > \n" )  ;  return buf . to string (  )  ;   }  
 < r >  callable < r >    ( r r )  {  return new  callable < r >  (  )  {  @ override public r call (  )  {  throw new  test exception (  )  ;   }   }   ;   }  
public static  local connection multiplexer session   (  string server name  xml pull parser xpp  connection connection )  throws  xml pull parser exception  {   string domain = xpp . get attribute value ( "" "to" )  ;   log . debug ( " local connection multiplexer session: [ con mng]  starting registration of new connection manager for domain: "  +  domain )  ;   string builder sb = new  string builder (  )  ;  sb . append ( " <  ? xml version = '1 . 0' encoding = '" )  ;  sb . append ( charset )  ;  sb . append ( "' ?  > " )  ;  sb . append ( " < stream:stream " )  ;  sb . append ( "xmlns:stream = \"http: /  / etherx . jabber . org / streams\" " )  ;  sb . append ( "xmlns = \"jabber:connectionmanager\" from = \"" )  ;  sb . append ( domain )  ;  sb . append ( "\" version = \"1 . 0\" > " )  ;  if  ( domain  =  =  null )   {   log . debug ( " local connection multiplexer session: [ con mng]  domain not specified in stanza: "  +  xpp . get text (  )  )  ;   stream error error = new  stream error (  stream error .  condition . bad   format )  ;  sb . append ( error . toxml (  )  )  ;  connection . deliver raw text ( sb . to string (  )  )  ;  connection . close (  )  ;  return null ;   }  jid address = new jid ( domain )  ;   string secret key =  connection multiplexer manager . get default secret (  )  ;  if  ( secret key  =  =  null )   {   log . debug ( " local connection multiplexer session: [ con mng] a shared secret for connection manager was not found . " )  ;   stream error error = new  stream error (  stream error .  condition . internal   server   error )  ;  sb . append ( error . toxml (  )  )  ;  connection . deliver raw text ( sb . to string (  )  )  ;  connection . close (  )  ;  return null ;   }  if  (  session manager . get instance (  )  . get connection multiplexer session ( address )   !  =  null )   {   log . debug ( " local connection multiplexer session: [ con mng]  another connection manager is already using domain: "  +  domain )  ;   stream error error = new  stream error (  stream error .  condition . conflict )  ;  sb . append ( error . toxml (  )  )  ;  connection . deliver raw text ( sb . to string (  )  )  ;  connection . close (  )  ;  return null ;   }  connection . set tls policy ( connection . get configuration (  )  . get tls policy (  )  )  ;  connection . set compression policy ( connection . get configuration (  )  . get compression policy (  )  )  ;   (  (  multiplexer packet deliverer ) connection . get packet deliverer (  )  )  . set connection manager domain ( address . get domain (  )  )  ;   local connection multiplexer session session =  session manager . get instance (  )  . create multiplexer session ( connection address )  ;  session . set address ( address )  ;  connection . init ( session )  ;  try  {   log . debug ( " local connection multiplexer session: [ con mng]  send stream header with id: "  +  session . get streamid (  )   +  " for connection manager with domain: " +  domain )  ;  sb = new  string builder (  )  ;  sb . append ( " <  ? xml version = '1 . 0' encoding = '" )  ;  sb . append ( charset )  ;  sb . append ( "' ?  > " )  ;  sb . append ( " < stream:stream " )  ;  sb . append ( "xmlns:stream = \"http: /  / etherx . jabber . org / streams\" " )  ;  sb . append ( "xmlns = \"jabber:connectionmanager\" from = \"" )  ;  sb . append ( domain )  ;  sb . append ( "\" id = \"" )  ;  sb . append ( session . get streamid (  )  . to string (  )  )  ;  sb . append ( "\" version = \"1 . 0\"  > " )  ;  connection . deliver raw text ( sb . to string (  )  )  ;  sb = new  string builder ( 490 )  ;  sb . append ( " < stream:features > " )  ;  if  ( connection . get tls policy (  )   !  =   connection . tls policy . disabled )   {  sb . append ( " < starttls xmlns = \"urn:ietf:params:xml:ns:xmpp - tls\" > " )  ;  if  ( connection . get tls policy (  )   =  =   connection . tls policy . required )   {  sb . append ( " < required /  > " )  ;   }  sb . append ( " <  / starttls > " )  ;   }   string specific features = session . get available stream features (  )  ;  if  ( specific features  !  =  null )   {  sb . append ( specific features )  ;   }  sb . append ( " <  / stream:features > " )  ;  connection . deliver raw text ( sb . to string (  )  )  ;  return session ;   }  catch  (   exception e )   {   log . error ( " an error occured while creating a  connection  manager  session" e )  ;  connection . close (  )  ;  return null ;   }   }  
@ test public void   (  )  {  repose info logic . increment request count (  )  ;  assert equals ( 1 repose info logic . get total requests (  )  )  ;   }  
@ test public void   (  )  {  final  observable <  string >  o1 =  observable . unsafe create ( new  test error observable ( "one" "two" "three" )  )  ;  final  observable <  string >  o2 =  observable . unsafe create ( new  test error observable ( "four"
@ override public jaxb element < t >    ( final  input stream source )  {  jaxb element < t >  rtn = null ;   unmarshaller pooled object ;  final  object pool <  unmarshaller >  object pool = get unmarshaller pool (  )  ;  try  {  pooled object = object p
void   (  )  {  destroy2 (  )  ;   }  
@ override public  string   (  )  {  return "poison" ;   }  
@ test ( data provider = "u byte data" )  public void   ( final byte unsigned byte final int expected int )  {   assert . assert equals (  unsigned type util . u byte to int ( unsigned byte )  expected int )  ;   }  
public void   (  )  {  add call ( conference whisper group )  ;  set whispering ( conference whisper group )  ;   }  
private static void   ( sq lite database db )  {  try  {   cursor message cursor = db . query (  message . table   name  message . content   projection null null null null null )  ;   content values cv = new  content values (  )  ;   string[] where args = new  string[1] ;  try  {  while  ( message cursor . move to next (  )  )   {  for  ( int i = 0 ;  i  <  address   column   indices . length ;  i +  +  )   {   address[] addrs =  address . from header ( message cursor . get string ( address   column   indices[i] )  )  ;  cv . put ( address   column   names[i]  address . to string ( addrs )  )  ;   }  where args[0] = message cursor . get string (  message . content   id   column )  ;  db . update (  message . table   name cv where   id where args )  ;   }   }  finally  {  message cursor . close (  )  ;   }   }  catch  (  sql exception e )   {   log utils . w ( tag " exception upgrading  email provider . db from 125 to 126 "  +  e )  ;   }   }  
@ override public  list <  string >    ( x509 certificate certificate )  {   list <  string >  identities = new  array list <  >  (  )  ;  try  {   collection <  list <  ?  >  >  alt names = certificate . get subject alternative names (  )  ;  if  ( alt n
@ suppress warnings ( "unchecked" )  @ test public final void   (  )  throws  exception  {  final  function <  long  void >  called op = mock (  function . class )  ;  final  test scheduler scheduler = new  test scheduler (  )  ;  final  scheduler .  work
@ override public boolean   (  )  {  logger . finest ( "is read only" )  ;  return false ;   }  
public int   (  )  {  return war   cache   control   secs ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  parallel invalid (  )  . do on next (  functions . empty consumer (  )   parallel failure handling . error )  . filter (  functions . alw
  ( int integer value int int value )  {  this . integer value = integer value ;  this . int value = int value ;   }  
@ override public  bundle   (  bundle params )  {  final  string set visibility key = ui provider .  conversation cursor command . command   key   set   visibility ;  if  ( params . contains key ( set visibility key )  )   {  final boolean visible = param
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public final  < r >  flowable < r >    (  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper int prefetch
public  map <  string be value >    (  )  {  return handshake map ;   }  
public  string   (  )  {  return duration ;   }  
public static void   ( final  string[] argv )  {  new  collect insert size metrics (  )  . instance main with exit ( argv )  ;   }  
@ test public void   (  )  {   replay processor <  integer >  source =  replay processor . create with size ( 1 )  ;  source . on next ( 1 )  ;  source . on next ( 2 )  ;   size bound replay buffer <  integer >  buf =  (  size bound replay buffer <  integ
@ override public void   (  )  {  try  {  send message (  )  ;   }  catch  (   exception e )   {   log . error ( " an exception occurred while sending a sms message  ( to ' {  } ' ) " destination address e )  ;   }   }  
  (  equal coordinator < t >  parent )  {  this . parent = parent ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  consumer <  ?  super  subscription >  on subscribe )  {  return do on lifecycle ( on
@ test public void   (  )  {   observable . from iterable (  arrays . as list ( 1 2 3 )  )  . subscribe ( new  observer <  integer >  (  )  {  @ override public void on subscribe (   disposable d )  {  @ suppress warnings ( "unchecked" )   queue disposabl
@ override public boolean   (  )  {  return false ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test helper . check disposed ( pp . single element (  )  . is empty (  )  . to maybe (  )  )  ;   }  
private  request   (  message content content  string destination )  throws  invalid argument exception   parse exception  {   string dest username = destination ;   string dest host = sip host ;  if  ( destination . index of ( "@" )   =  =  0 || destination . index of ( "@" )   =  =  destination . length (  )   -  1 )   {  throw new  invalid argument exception ( " the address provided is invalid ! " )  ;   }  else if  ( destination . index of ( "@" )   >  0 )   {  dest username = destination . substring ( 0 destination . index of ( "@" )  )  ;  dest host = destination . substring ( destination . index of ( "@" )   +  1 )  ;   }   sipuri dest uri = address factory . create sipuri ( dest username dest host )  ;   request message request = prepare request (  request type . message dest uri null dest uri session id seq num +  +  )  ;  message request . set content ( content . content content . content type header )  ;  return message request ;   }  
@ test public void   (  )  {  final  test observable <  string >  w1 = new  test observable <  string >  ( "one" "two" "three" )  ;  final  test observable <  string >  w2 = new  test observable <  string >  ( "hello"  integer . max   value )  ;   observe
@ test public void   (  )  {  fetch from ( "http: /  / "  +  stats   host  +  ":0" true )  ;   }  
public  string   (  )  {  if  ( phone number  =  =  null )   {  if  ( input treatment  =  =  null )   {  return " anonymous" ;   }  if  ( name  !  =  null )   {  return name  +  "@"  +  input treatment ;   }  return input treatment ;   }  int end = phone number . index of ( "@" )  ;  if  ( end  >  =  0 )   {  if  ( name  =  =  null || name . equals ( " anonymous" )  )   {  return phone number ;   }  int start = 0 ;  if  ( phone number . index of ( "sip:" )   =  =  0 )   {  start = phone number . index of ( ":" )   +  1 ;   }   string s = name . replace all ( " " "   " )  ;  if  ( s . equals ( phone number . substring ( start end )  )  )   {  return phone number ;   }   }  if  ( name  =  =  null || name . equals ( "" )  || name . equals ( phone number )  )   {  return " anonymous@"  +  phone number ;   }  return name  +  "@"  +  phone number ;   }  
@ override public void   (  integer t )  {  fast path ordered emit max ( t false d )  ;   }  
@ override public  string   (  )  {  return name ;   }  
public  string   (  )  {  return description ;   }  
@ override public void   ( t t )  {  subscriber . on next ( t )  ;   }  
public void   (  string conference join treatment )  {  this . conference join treatment = conference join treatment ;   }  
public static  < t > void   (  observer <  ?  super t >  observer t value  atomic integer wip  atomic throwable error )  {  if  ( wip . get (  )   =  =  0 && wip . compare and set ( 0 1 )  )   {  observer . on next ( value )  ;  if  ( wip . decrement and get (  )   !  =  0 )   {   throwable ex = error . terminate (  )  ;  if  ( ex  !  =  null )   {  observer . on error ( ex )  ;   }  else  {  observer . on complete (  )  ;   }   }   }   }  
long   (  )  throws io exception  {  return ras . get file pointer (  )  ;   }  
public void   (  boolean value )  {     lost packet id plus15 = value ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  long idx = index  +  1 ;  index = idx ;   disposable d = timer ;  if  ( d  !  =  null )   {  d . dispose (  )  ;   }   debounce emitter < t >  de = new  debounce emitter < t >  ( t idx t
  ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
@ test public void   (  )  throws  exception  {  final  byte buffer sbb = new  cyclic byte buffer (  )  ;  sbb . put ( "expected" . get bytes (  )  )  ;  final  input stream is = new  byte buffer input stream ( sbb )  ;  final byte[] bytes = new byte[1024
private static ec private key   (  signing private key pk )  throws  general security exception  {   sig type type = pk . get type (  )  ;  byte[] b = pk . get data (  )  ;   big integer s = new  native big integer ( 1 b )  ;  ec private key spec ks = new ec private key spec ( s  ( ec parameter spec ) type . get params (  )  )  ;   key factory kf =  key factory . get instance ( "ec" )  ;  return  ( ec private key ) kf . generate private ( ks )  ;   }  
private void   (  comment c )  {  real size +  +  ;  if  (  ! c . is hidden (  )  )   {  size +  +  ;  int r = c . get rating (  )  ;  if  ( r  >  0 )   {  if  ( c . is mine (  )  )   {  my rating = r ;   }  else  {  total rating +  = r ;  rating size +  +  ;   }   }  long time = c . get time (  )  ;  if  ( time  >  latest comment time )  latest comment time = time ;   }   string t = c . get text (  )  ;  if  ( t  !  =  null )  total text size +  = t . length (  )  ;  modified = true ;   }  
@ test public void   (  )  {   observable . just ( 1 2 )  . hide (  )  . do after next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . filter (  f
@ test public void   (  )  {  iq entity time handler iq entity time handler = new iq entity time handler (  )  ;   date date = new  date (  )  ;   calendar calendar = new  gregorian calendar (  )  ;  calendar . set time ( date )  ;  calendar . set time zo
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   flowable <  integer >  result = source . take ( 1  time unit . seconds scheduler )  ;   
@ test public void   (  )  {   observable . range ( 1 5 )  . do after next ( after next )  . filter (  functions . always true (  )  )  . subscribe with ( to )  . assert result ( 1 2 3 4 5 )  ;  assert equals (  arrays . as list ( 1  - 1 2  - 2 3  - 3 4  
public int   (  )  {  return type ;   }  
public boolean   (  class <  ?  >  iface )  throws sql exception  {  return connection . is wrapper for ( iface )  ;   }  
public long   (  )  throws io exception  {  final long end time = get end time (  )  ;  final long arc step = get arc step (  )  ;  final long num rows = rows . get (  )  ;  return end time  -   ( num rows  -  1 )  * arc step ;   }  
static long   (  context context int app widget id )  {  final  shared preferences prefs = context . get shared preferences ( legacy   prefs   name 0 )  ;  long mailbox id = prefs . get long ( legacy   mailbox   id   prefix  +  app widget id  mailbox . no   mailbox )  ;  return mailbox id ;   }  
@ deprecated public byte[]   (  )  {  if  (  ! is rekeying included (  )  )  return null ;  byte[] rv = new byte[keying   material   length] ;   system . arraycopy (    message    payload begin offset  +  1  +  4 rv 0 keying   material   length )  ;  retu
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  try  {   flowable . merge (  arrays . as list (  flowable . just ( 1 )   flowable . just ( 2 )  )  0 )  ;  fail ( " expected  illegal argument exception" )  ;   }  catch  (   illegal argum
public  set <  integer >    (  )  {  return detected cycles ;   }  
@ override public void   (  )  {  super . clear (  )  ;  synchronized  ( this )   {  known group names in list = null ;   }   }  
@ test public void   (  )  {  perform test using with observable factory error ( false )  ;   }  
@ override public void   (  )  {  s . dispose (  )  ;   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public   (  )  {  super ( 0  integer . max   value handler   keepalive   ms  time unit . milliseconds new  synchronous queue <  runnable >  (  )  new  custom thread factory (  )  )  ;   }  
@ override public void   (  observer <  ?  super t >  t )  {   publish disposable < t >  ps = new  publish disposable < t >  ( t this )  ;  t . on subscribe ( ps )  ;  if  ( add ( ps )  )   {  if  ( ps . is disposed (  )  )   {  remove ( ps )  ;   }   }  
@ deprecated public boolean   (  )  {  return is enabled (  connection type . connection   manager false )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . any )  ;   single . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  itera
public void   ( int parameter index float x )  throws sql exception  {  pstmt . set float ( parameter index x )  ;   }  
public void   (  )  {   (  (  client session ) get session (  )  )  . set initialized ( initialized )  ;   }  
@ test public void   (  )  {  final  test observer <  object >  subscriber = new  test observer <  object >  (  )  ;  final  object value = new  object (  )  ;   object returned =  observable . just ( value )  . to ( new  function <  observable <  object 
@ test public void   (  )  {  final  flowable <  string >  o1 =  flowable . unsafe create ( new  test synchronous flowable (  )  )  ;  final  flowable <  string >  o2 =  flowable . unsafe create ( new  test synchronous flowable (  )  )  ;   list <  flowab
@ override public void   (  collection < jid >  userji ds )  {  boolean list changed = false ;  for  (  jid userjid : userji ds )   {  if  (  ! allowed to create . contains ( userjid )  )   {  allowed to create . add ( userjid )  ;  list changed = true ; 
long   ( int ds index )  {  return rrd . get data source ( ds index )  . get minimum heartbeat (  )  ;   }  
public  throwable   (  )  {  throw new  error ( " not implemented .  .  . " )  ;   }  
public  rrd graph info   (  )  {  return info ;   }  
  (  subscriber <  ?  super t >  actual long delay  time unit unit  worker w boolean delay error )  {  super (  )  ;  this . actual = actual ;  this . delay = delay ;  this . unit = unit ;  this . w = w ;  this . delay error = delay error ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . first ( null )  ;   }  
private void   (  )  {     do log =    context . get boolean property ( prop   keep   message   history )  ;     history file =    context . get property ( prop   message   history   filename default   message   history   filename )  ;   }  
public int   (  )  {  return type * 93 ;   }  
public void   (  )  {  synchronized  ( this )   {  if  (    state  !  =   tunnel state . starting &&    state  !  =   tunnel state . running )  return ;  change state (  tunnel state . stopping )  ;   }   collection < i2p session >  sessions = get all sessions (  )  ;     tunnel . run close ( new  string[] { "forced" "all" }  this )  ;  release ( sessions )  ;  change state (  tunnel state . stopped )  ;   }  
public   (  )  {     context =  router context . list contexts (  )  . get ( 0 )  ;     log =    context . log manager (  )  . get log ( get class (  )  )  ;     listeners = new  copy on write array list <  summary listener >  (  )  ;     instance = this ;     sem = new  semaphore ( max   concurrent   png true )  ;     context . add shutdown task ( new  shutdown (  )  )  ;   }  
public   ( int max open files final  read ends for mark duplicates codec read ends for mark duplicates codec )  {  pair info map = new  coordinate sorted pair info map <  string  read ends for mark duplicates >  ( max open files new  codec ( read ends for mark duplicates codec )  )  ;   }  
@ override public  user   (  string username  string password  string name  string email )  throws  user already exists exception  {  try  {  load user ( username )  ;  throw new  user already exists exception ( " username "  +  username  +  " already exi
public void   (  )  {  if  (    session . is closed (  )  )  return ;  long now =    context . clock (  )  . now (  )  ;  long last activity =    session . last activity (  )  ;  if  (    log . should log (  log . info )  )     log . info ( " fire idle timer  last activity: "  +   data helper . format duration ( now  -  last activity )   +  " ago " )  ;  long next delay = 0 ;  if  (    shutdown enabled && now  -  last activity  >  =     shutdown time )   {  if  (    log . should log (  log . warn )  )     log . warn ( " closing on idle "  +     session )  ;     session . destroy session (  )  ;  return ;   }  else if  ( last activity  <  =     last active &&  !    shutdown enabled )   {  if  (    log . should log (  log . warn )  )     log . warn ( " still idle  sleeping again "  +     session )  ;  next delay =    reduce time ;   }  else if  (    reduce enabled && now  -  last activity  >  =     reduce time )   {  if  (    log . should log (  log . warn )  )     log . warn ( " reducing quantity on idle "  +     session )  ;  try  {     session . get producer (  )  . update tunnels (    session    reduce quantity )  ;   }  catch  (  i2p session exception ise )   {     log . error ( "bork idle reduction "  +  ise )  ;   }     session . set reduced (  )  ;     last active = last activity ;  if  (    shutdown enabled )  next delay =    shutdown time  -   ( now  -  last activity )  ;  else next delay =    reduce time ;   }  else  {  next delay =    minimum time  -   ( now  -  last activity )  ;   }     context . simple timer2 (  )  . add event ( this next delay )  ;   }  
@ override public void   (  throwable t )  {  if  (  ! done )   {  done = true ;  subscription . cancel (  )  ;  actual . on error ( t )  ;   }   }  
public static boolean   (  class <  ?  extends  servlet request authenticator >  clazz )  {  final  auth check filter instance = get instance (  )  ;  if  ( instance  =  =  null )   {  return false ;   }  final  servlet request authenticator authenticator = instance . servlet request authenticator ;  return authenticator  !  =  null && clazz . is assignable from ( authenticator . get class (  )  )  ;   }  
private void   (  message message  chatbot session session )  {  send question ( message session session . get current substep (  )   +  1 )  ;   }  
@ override public void   ( t t )  {   completable source c ;  try  {  c =  object helper . require non null ( mapper . apply ( t )  " the mapper returned a null  completable source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( e
public void   (  )  {  muc event dispatcher . add listener ( this )  ;   }  
@ override public void   ( jid sender jid receiver )  {  final  chat state change event event = new  chat state change event ( sender receiver  chat state type . inactive )  ;  listener . chat state change ( event )  ;   }  
@ test public void   (  )  {   async subscription as = new  async subscription (  )  ;  assert false ( as . is disposed (  )  )  ;  as . dispose (  )  ;  assert true ( as . is disposed (  )  )  ;   }  
private void   (  )  throws io exception   messaging exception  {  final  list <  imap response >  responses = m connection . execute simple command (  string . format (  locale . us  imap constants . select  +  " \"%s\""  imap store . encode folder name ( m name m store . m path prefix )  )  )  ;  m mode =  open mode . read   write ;  int message count =  - 1 ;  for  (   imap response response : responses )   {  if  ( response . is data response ( 1  imap constants . exists )  )   {  message count = response . get string or empty ( 0 )  . get number or zero (  )  ;   }  else if  ( response . is ok (  )  )   {  final  imap string response code = response . get response code or empty (  )  ;  if  ( response code . is (  imap constants . read   only )  )   {  m mode =  open mode . read   only ;   }  else if  ( response code . is (  imap constants . read   write )  )   {  m mode =  open mode . read   write ;   }   }  else if  ( response . is tagged (  )  )   {  throw new  messaging exception ( " can't open mailbox: "  +  response . get status response text or empty (  )  )  ;   }   }  if  ( message count  =  =   - 1 )   {  throw new  messaging exception ( " did not find message count during select" )  ;   }  m message count = message count ;  m exists = true ;   }  
  ( final  rrd updater updater final int length )  throws io exception  {  super ( updater  rrd primitive . rrd   double length false )  ;  this . length = length ;   }  
public static  auth provider   (  )  {  return auth provider ;   }  
public static void   (  string stun port )  {  sip config . stun port = stun port ;   }  
public  encrypted build record   ( i2p app context ctx  public key to key  hash to peer )  {  byte[] out = new byte[ encrypted build record . length] ;   system . arraycopy ( to peer . get data (  )  0 out 0 peer   size )  ;  byte encrypted[] = ctx . el gamal engine (  )  . encrypt (    data to key )  ;   system . arraycopy ( encrypted 1 out peer   size 256 )  ;   system . arraycopy ( encrypted 258 out 256  +  peer   size 256 )  ;  return new  encrypted build record ( out )  ;   }  
protected   ( int tcp port  inet address bind interface )  throws io exception  {  super (  )  ;  server socket = new  server socket ( tcp port  - 1 bind interface )  ;   }  
public   (  router context ctx  tunnel data message msg )  {  super ( ctx )  ;     msg = msg ;   }  
@ override public void   (  )  {  if  ( s  !  =   disposable helper . disposed )   {  actual . on complete (  )  ;   }   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  @ experimental public final  flowable < t >    ( @ non null  completable source other )  {   object helper . require no
@ override public boolean   (  )  {  return qs . is empty (  )  ;   }  
  (  observer <  ?  super t >  actual  observable source <  ?  >  other )  {  super ( actual other )  ;   }  
public boolean   (  string sub domain )  {   log . info ( " removing "  +  sub domain  +  " from watched  transports . " )  ;  t session manager . remove transport ( sub domain )  ;  gojara adminmanager . gateway unregistered ( sub domain )  ;  return this . active transports . remove ( sub domain )  ;   }  
@ override public  config   (  )  {   config copy = new  config (  )  ;  copy . clock = this . clock ;  return copy ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
@ override public void   (  print writer pw )  {  super . print stack trace ( pw )  ;  if  ( nested throwable  !  =  null )   {  nested throwable . print stack trace ( pw )  ;   }   }  
@ override public  publisher <  object >    (  flowable <  object >  f )  throws  exception  {  return f . merge with (  single . just ( 1 )  )  ;   }  
@ override public boolean   ( t v1 t v2 )  {  offer ( v1 )  ;  offer ( v2 )  ;  return true ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  {   }   }   null )  ;   }  
private boolean   ( final  reader r final  string builder sb )  throws io exception  {  sb . set length ( 0 )  ;  int b ;  boolean hit whitespace = false ;  while  (  ( b = r . read (  )  )   !  =   - 1 )   {  final char c =  ( char ) b ;  if  ( c  =  =  '\n' )   {  break ;   }  if  (  character . is whitespace ( c )  )   {  hit whitespace = true ;   }  if  (  ! hit whitespace )   {  sb . append ( c )  ;   }  if  ( sb . length (  )   >  max   line   len )   {  return false ;   }   }  return  ( b  !  =   - 1 )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . unsubscribe on (  schedulers . single (  )  )  . test (  )  . assert result (  )  ;   }  
  (  config registry config  extension method extension method )  {  this . config = require non null ( config )  ;  this . extension method = extension method ;   }  
long   (  )  throws io exception  {  return ras . get file pointer (  )  ;   }  
public void   ( int start index )  {  if  ( start index  <  0 )   {  throw new  illegal argument exception ( "a start index less than 0 is not valid . " )  ;   }  this . start index = start index ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flatten as flowable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable (
@ test public void   (  )  {   flowable . range long ( 1l 5l )  . filter (  functions . always true (  )  )  . rebatch requests ( 1 )  . test (  )  . assert result ( 1l 2l 3l 4l 5l )  ;   }  
@ test public void   (  )  throws  exception  {  assert that ( find sql on classpath ( get class (  )  "test locate by method name" )  )  . contains ( "select 1" )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  sample config object config = new  sample config object ( config properties )  ;  final  test config updater updater2 = new  test config updater ( update lock update key1 "prop2" 0 null t
@ test public void   (  )  {   observable . merge delay error (  observable . just (  observable . just ( 1 )   observable . just ( 2 )  )  1 )  . test (  )  . assert result ( 1 2 )  ;   }  
@ test public void   (  )  {   test helper . check fused is empty clear (  flowable . range long ( 1 2 )  )  ;   }  
public   (  )  {  workgroup settings = new  workgroup settings (  )  ;  provider manager =  workgroup provider manager . get instance (  )  ;  agent manager =  workgroup manager . get instance (  )  . get agent manager (  )  ;   }  
@ test public void   (  )  {   test disposable observer <  integer >  tc = new  test disposable observer <  integer >  (  )  ;  assert false ( tc . is disposed (  )  )  ;  assert equals ( 0 tc . start )  ;  assert true ( tc . values . is empty (  )  )  ; 
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable processor <  integer >  subject =  publish processor . create (  )  ;  subject . on next ( null )  ;  subject . blocking subscribe (  )  ;   }  
public byte[]   (  )  {  return three prime bytes ;   }  
@ override public void   (  )  {   throwable ex = error ;  if  ( ex  !  =  null )   {  actual . on error ( ex )  ;   }  else  {  actual . on success ( value )  ;   }   }  
@ override public void   (  )  {  source . subscribe ( parent )  ;   }  
public iq   ( iq packet )  {  if  ( packet . get type (  )   =  =  iq .  type . result )   {   list <  element >  items = packet . get child element (  )  . elements ( "item" )  ;  for  (   element item : items )   {   string jid = item . attribute value ( "jid" )  ;  iq disco = new iq ( iq .  type . get )  ;  disco . set to ( jid )  ;  disco . set from ( packet . get to (  )  )  ;  disco . set child element ( "query" "http: /  / jabber . org / protocol / disco#info" )  ;  workgroup manager . send ( disco )  ;   }  return null ;   }  iq reply = iq . create resultiq ( packet )  ;  if  ( iq .  type . set  =  =  packet . get type (  )  )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error (  packet error .  condition . bad   request )  ;  return reply ;   }  if  ( workgroup manager . get address (  )  . equals ( packet . get to (  )  )  )   {   element iq = packet . get child element (  )  ;   string node = iq . attribute value ( "node" )  ;  reply . set child element ( iq . create copy (  )  )  ;   element query element = reply . get child element (  )  ;  if  ( node  =  =  null )   {  for  (   workgroup workgroup : workgroup manager . get workgroups (  )  )   {   element item = query element . add element ( "item" )  ;  item . add attribute ( "jid" workgroup . getjid (  )  . to string (  )  )  ;  item . add attribute ( "name" workgroup . getjid (  )  . get node (  )  )  ;   }   }  else if  ( "http: /  / jabber . org / protocol / commands" . equals ( node )  )   {  for  (   ad hoc command command : command manager . get commands (  )  )   {  if  ( command . has permission ( packet . get from (  )  )  )   {   element item = query element . add element ( "item" )  ;  item . add attribute ( "jid" workgroup manager . get address (  )  . to string (  )  )  ;  item . add attribute ( "node" command . get code (  )  )  ;  item . add attribute ( "name" command . get label (  )  )  ;   }   }   }  else  {  reply . set error (  packet error .  condition . service   unavailable )  ;   }   }  else  {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error (  packet error .  condition . not   acceptable )  ;   }  return reply ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . just ( 1 1 1 1 2 )  . collect into ( new  hash set <  integer >  (  )  new  bi consumer <  hash set <  integer >   integer >  (  )  {  @ override public void accept (   hash 
@ override public  map <  integer  string >    (  )  {  throw new  runtime exception ( " forced failure" )  ;   }  
private boolean   (  signature signature  simple data structure hash  public key pub key )  throws  general security exception  {   sig type type = signature . get type (  )  ;  int hashlen = hash . length (  )  ;  if  ( type . get hash len (  )   !  =  hashlen )  throw new  illegal argument exception ( "type mismatch hash = "  +  hash . get class (  )   +  " key = " +  type )  ;  byte[] sigbytes =  sig util . to java sig ( signature )  ;  boolean rv ;  if  ( type . get base algorithm (  )   =  =   sig algo .  eddsa )   {   eddsa engine jsig = new  eddsa engine (  )  ;  jsig . init verify ( pub key )  ;  rv = jsig . verify one shot ( hash . get data (  )  sigbytes )  ;   }  else  {   string algo = get raw algo ( type )  ;  java . security .  signature jsig = java . security .  signature . get instance ( algo )  ;  jsig . init verify ( pub key )  ;  jsig . update ( hash . get data (  )  )  ;  rv = jsig . verify ( sigbytes )  ;   }  return rv ;   }  
public  string   (  string username  string basedn )  throws  exception  {  boolean debug =  log . is debug enabled (  )  ;  username = username  +  username suffix ;  if  ( debug )   {   log . debug ( " ldap manager:  trying to find a user's dn based on their username .  "  +  username field  +  ": " +  username +  "   base dn: " +  basedn +  " .  .  . " )  ;   }   dir context ctx = null ;  try  {  ctx = get context ( basedn )  ;  if  ( debug )   {   log . debug ( " ldap manager:  starting ldap search .  .  . " )  ;   }   search controls constraints = new  search controls (  )  ;  if  ( sub tree search )   {  constraints . set search scope (  search controls . subtree   scope )  ;   }  else  {  constraints . set search scope (  search controls . onelevel   scope )  ;   }  constraints . set returning attributes ( new  string[] { username field }  )  ;   naming enumeration <  search result >  answer = ctx . search ( "" get search filter (  )  new  string[] { sanitize search filter ( username )  }  constraints )  ;  if  ( debug )   {   log . debug ( " ldap manager:  .  .  .  search finished" )  ;   }  if  ( answer  =  =  null ||  ! answer . has more elements (  )  )   {  if  ( debug )   {   log . debug ( " ldap manager:  user dn based on username '"  +  username  +  "' not found . " )  ;   }  throw new  user not found exception ( " username "  +  username  +  " not found" )  ;   }   string userdn = answer . next (  )  . get name (  )  ;  if  ( answer . has more elements (  )  )   {  if  ( debug )   {   log . debug ( " ldap manager:  search for userdn based on username '"  +  username  +  "' found multiple " +  "responses  throwing exception . " )  ;   }  throw new  user not found exception ( "ldap username lookup for "  +  username  +  " matched multiple entries . " )  ;   }  answer . close (  )  ;  if  ( userdn . starts with ( "ldap: /  / " )  )   {  userdn = userdn . replace ( " "  +  basedn "" )  ;  userdn = userdn . substring ( userdn . last index of ( " / " )   +  1 )  ;  userdn = java . net . url decoder . decode ( userdn "utf - 8" )  ;   }  if  ( enclose userdn )   {  userdn = get encloseddn ( userdn )  ;   }  return userdn ;   }  catch  (  final  user not found exception e )   {   log . trace ( " ldap manager:  user not found exception thrown" e )  ;  throw e ;   }  catch  (  final  exception e )   {   log . debug ( " ldap manager:  exception thrown when searching for userdn based on username '"  +  username  +  "'" e )  ;  throw e ;   }  finally  {  try  {  ctx . close (  )  ;   }  catch  (   exception ignored )   {   }   }   }  
private static  string   (  string nodeid )  {  if  (  db connection manager . get database type (  )   =  =   db connection manager .  database type . oracle && "" . equals ( nodeid )  )   {  return " " ;   }  return nodeid ;   }  
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
public synchronized  public key   (  )  {  return    public key ;   }  
@ override public void   (  observer <  ?  super t >  t )  {  source . subscribe ( new  dematerialize observer < t >  ( t )  )  ;   }  
@ test public void   (  )  throws  exception  {  assert true ( md5   password . equals ( jdbc auth provider . hash password ( password jdbc auth provider .  password type . md5 )  )  )  ;  assert true ( sha1   password . equals ( jdbc auth provider . hash
@ test public void   (  )  throws  exception  {  final  delete delete command = new  delete ( "object - key" new  inet socket address (  inet address . get by address ( new byte[] { 127 0 0 1 }  )  1000 )  null false )  ;  final  service client response r
@ override public void   (  )  {   system . out . println ( "completed" )  ;  latch . count down (  )  ;   }  
public int   (  peer profile left  peer profile right )  {  return  data helper . compare to ( left . get peer (  )  . get data (  )  right . get peer (  )  . get data (  )  )  ;   }  
public boolean   (  )  {  return is method ( http . notify )  ;   }  
@ override public void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   simple queue < t >  q = queue ;   array deque <  inner queued observer < r >  >  observers = this . observers ;   observer <  ?  super r >  a 
@ override protected void   (  single observer <  ?  super t >  observer )  {  source . subscribe ( observer )  ;   }  
public  message router   (  )  {  return  (  message router ) modules . get (  message router . class )  ;   }  
public void   (  string public key )  {   jive globals . set property ( recaptcha   public   key public key )  ;   }  
@ override boolean   (  element doc )  {   string tag = doc . get name (  )  ;  if  ( "route" . equals ( tag )  )   {  process route ( new  route ( doc )  )  ;  return true ;   }  else if  ( "handshake" . equals ( tag )  )   {  if  (  !  (  (  local conne
@ test ( expected =  test exception . class )  public void   (  )  {   subject <  string >  s =  publish subject . create (  )  ;   iterator <  string >  it = most recent ( s "default" )  . iterator (  )  ;  assert true ( it . has next (  )  )  ;  assert 
@ test public void   (  )  {   group element b = ed25519 . getb (  )  ;  for  ( int i = 0 ;  i  <  32 ;  i +  +  )   {  assert that ( i  +  " 0" b . select ( i 0 )  is ( equal to (  group element . precomp ( curve one one zero )  )  )  )  ;  for  ( int j 
  ( int[] bits int size )  {  this . bits = bits ;  this . size = size ;   }  
@ test public void   (  )  {   flowable <  integer >  o =  flowable . from iterable (  arrays . as list ( 1 2 3 4 5 )  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . assert no values (  )  ;  ts . request (  l
public boolean   ( iq packet )  {   element iq = packet . get child element (  )  ;   string name = iq . get name (  )  ;  return "workgroup - properties" . equals ( name )  ;   }  
@ test public void   (  )  {   observable <  string >  obs =  observable . empty (  )  ;   observer <  boolean >  observer =  test helper . mock observer (  )  ;  obs . all ( new  predicate <  string >  (  )  {  @ override public boolean test (   string s
public  list <  filter context >    (  servlet context servlet context  list <  filter >  filters to create )  throws  filter initialization exception  {  final  list <  filter context >  filter contexts = new  linked list <  >  (  )  ;  for  (  org . openrepose . core . systemmodel . config .  filter papi filter : filters to create )   {  if  ( class loader manager service . has filter ( papi filter . get name (  )  )  )   {  final  filter context context = load filter context ( papi filter class loader manager service . get loaded applications (  )  servlet context )  ;  filter contexts . add ( context )  ;   }  else  {  log . error ( " unable to satisfy requested filter chain  -  none of the loaded artifacts supply a filter named "  +  papi filter . get name (  )  )  ;  throw new  filter initialization exception ( " unable to satisfy requested filter chain  -  none of the loaded artifacts supply a filter named "  +  papi filter . get name (  )  )  ;   }   }  return filter contexts ;   }  
@ test public void   (  )  {  final  runtime exception err = new  runtime exception (  )  ;   observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integer >  o )  {   disposa
public static void   (  output stream out  date date )  throws  data format exception  io exception  {  if  ( date  =  =  null )  write long ( out date   length 0l )  ;  else write long ( out date   length date . get time (  )  )  ;   }  
void   (  )  {   simple queue < u >  q = queue ;  if  ( q  !  =  null )   {  q . clear (  )  ;   }   }  
public  list <  string >    (  )  {  return rules ;   }  
private void   (  )  {  int port = get requested port (  )  ;  if  ( port  <  0 )   {  port = udp endpoint . select random port (    context )  ;   map <  string  string >  changes = new  hash map <  string  string >  (  )  ;  changes . put ( prop   internal   port  integer . to string ( port )  )  ;  changes . put ( prop   external   port  integer . to string ( port )  )  ;     context . router (  )  . save config ( changes null )  ;     log . log always (  log . info "udp selected random port "  +  port )  ;   }   }  
public final  byte array   (  )  {  if  (    cache )   {   byte array rv =    available . poll (  )  ;  if  ( rv  !  =  null )  return rv ;   }     last overflow =  system . current time millis (  )  ;  byte data[] = new byte[   entry size] ;   byte array rv = new  byte array ( data )  ;  rv . set valid ( 0 )  ;  return rv ;   }  
private void   ( int min length )  {  allocate (  )  ;  final int new size = buffer . length  +  buffer . length *  ( min length  /  buffer . length  +  1 )  ;  final byte[] new buffer = byte array provider . allocate ( new size )  ;  final int read = get ( new buffer 0 new size )  ;  buffer = new buffer ;  next writable index = read ;  next readable index = 0 ;  has elements = true ;   }  
@ test public void   (  )  {  try  {   flowable . just ( 1 )  . test (  )  . assert never ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t )  throws  exception  {  throw new  illegal argument exception (  )  ;   }   }  
@ override public void   (  )  throws  exception  {  counter . get and increment (  )  ;   }  
private void   ( final  string[] args final  file metrics final int expected ret val final int expectedn metrics final boolean expect all match )  throws io exception  {  final  crosscheck read group fingerprints cross checker = new  crosscheck read group fingerprints (  )  ;   assert . assert equals ( cross checker . instance main ( args )  expected ret val )  ;   assert . assert true ( metrics . can read (  )  )  ;  try  (  stream <  string >  lines =  files . lines ( metrics . to path (  )   charset . default charset (  )  )  )  {  long num of lines = lines . count (  )   -  1 ;   assert . assert equals ( num of lines expectedn metrics )  ;   }  if  ( expect all match )   {  try  (  stream <  string >  lines =  files . lines ( metrics . to path (  )   charset . default charset (  )  )  )  {  lines . skip ( 1 )  . for each ( s  -  >   {  final  list <  string >  strings =  arrays . as list ( s . split ( "\t" )  )  ;  strings . sub list ( 1 strings . size (  )  )  . for each ( str  -  >   assert . assert true (  double . parse double ( str )   >  0d "expected positive value  found: "  +  str )  )  ;   }   )  ;   }   }   }  
@ override public synchronized void   (  )  {  repose info . increment response count (  )  ;   }  
public void   (  peer peer int size )  {  downloaded . add and get ( size )  ;   }  
public  abstract illumina position file reader .  position info   (  )  {  return position info ;   }  
@ override public void   (  cancellable c )  {  set disposable ( new  cancellable disposable ( c )  )  ;   }  
@ test public void   (  )  throws io exception  {  long expected = stream   data1 . length (  )   -  1 ;  long actual = combined stream . skip ( expected )  ;  assert equals ( expected actual )  ;   }  
@ test ( data provider = "bad format files" expected exceptions = sam exception . class )  public void   ( final  string filename )  throws io exception  {  convert file ( filename null  fastq quality format .  standard )  ;   }  
@ suppress warnings ( "unchecked" )  public void   (  replay subscription < t >  p )  {  for  (  ;   ;   )   {   replay subscription < t > [] a = subscribers . get (  )  ;  int n = a . length ;  if  ( n  =  =  0 )   {  return ;   }  int j =  - 1 ;  for  (
private static  string   (  )  {   string model string = null ;  int family = cpuid . getcpu family (  )  ;  int model = cpuid . getcpu model (  )  ;  if  ( family  =  =  15 || family  =  =  6 )   {  model +  = cpuid . getcpu extended model (  )   <  <  4 ;   }  if  ( family  =  =  15 )   {  family +  = cpuid . getcpu extended family (  )  ;   }  switch  ( family )   {  case 4:  {  switch  ( model )   {  case 0: model string = "486 dx - 25 / 33" ;  break ;  case 1: model string = "486 dx - 50" ;  break ;  case 2: model string = "486 sx" ;  break ;  case 3: model string = "486 dx / 2" ;  break ;  case 4: model string = "486 sl" ;  break ;  case 5: model string = "486 sx / 2" ;  break ;  case 7: model string = "486 dx / 2 - wb" ;  break ;  case 8: model string = "486 dx / 4" ;  break ;  case 9: model string = "486 dx / 4 - wb" ;  break ;  default : model string = " intel 486 / 586 model "  +  model ;  break ;   }   }  break ;  case 5:  {  is pentium compatible = true ;  switch  ( model )   {  case 0: model string = " pentium 60 / 66 a - step" ;  break ;  case 1: model string = " pentium 60 / 66" ;  break ;  case 2: model string = " pentium 75  -  200" ;  break ;  case 3: model string = " over drive podp5v83" ;  break ;  case 4: is pentiummmx compatible = true ;  model string = " pentium mmx" ;  break ;  case 7: model string = " mobile  pentium 75  -  200" ;  break ;  case 8: is pentiummmx compatible = true ;  model string = " mobile  pentium mmx" ;  break ;  default : model string = " intel  pentium model "  +  model ;  break ;   }   }  break ;  case 6:  {  is pentium compatible = true ;  is pentiummmx compatible = true ;  int extmodel = model  >  >  4 ;  if  ( extmodel  >  =  1 )   {  is pentium2 compatible = true ;  is pentium3 compatible = true ;  is pentium4 compatible = true ;  is pentiumm compatible = true ;  is core2 compatible = true ;  if  ( extmodel  >  =  2 )  is corei compatible = true ;   }  switch  ( model )   {  case 0: model string = " pentium  pro a - step" ;  break ;  case 1: model string = " pentium  pro" ;  break ;  case 3: is pentium2 compatible = true ;  model string = " pentium ii  (  klamath ) " ;  break ;  case 5: is pentium2 compatible = true ;  model string = " pentium ii  (  deschutes )    celeron  (  covington )    mobile  pentium ii  (  dixon ) " ;  break ;  case 6: is pentium2 compatible = true ;  model string = " mobile  pentium ii   celeron  (  mendocino ) " ;  break ;  case 7: is pentium2 compatible = true ;  is pentium3 compatible = true ;  model string = " pentium iii  (  katmai ) " ;  break ;  case 8: is pentium2 compatible = true ;  is pentium3 compatible = true ;  model string = " pentium iii  (  coppermine )    celeron w / sse" ;  break ;  case 9: is pentium2 compatible = true ;  is pentium3 compatible = true ;  is pentiumm compatible = true ;  model string = " pentium m  (  banias ) " ;  break ;  case 10: is pentium2 compatible = true ;  is pentium3 compatible = true ;  model string = " pentium iii  xeon  (  cascades ) " ;  break ;  case 11: is pentium2 compatible = true ;  is pentium3 compatible = true ;  model string = " pentium iii  ( 130 nm ) " ;  break ;  case 13: is pentium2 compatible = true ;  is pentium3 compatible = true ;  is pentiumm compatible = true ;  model string = " core  (  yonah ) " ;  break ;  case 14: case 15: is pentium2 compatible = true ;  is pentium3 compatible = true ;  is pentiumm compatible = true ;  is core2 compatible = true ;  model string = " penryn" ;  break ;  case 0x16: model string = " merom" ;  break ;  case 0x17: model string = " penryn" ;  break ;  case 0x1a: is corei compatible = true ;  model string = " nehalem" ;  break ;  case 0x1c: is atom compatible = true ;  is core2 compatible = false ;  is pentium4 compatible = false ;  model string = " atom" ;  break ;  case 0x1d: is corei compatible = true ;  model string = " penryn" ;  break ;  case 0x1e: is corei compatible = true ;  model string = " nehalem" ;  break ;  case 0x25: model string = " westmere" ;  break ;  case 0x26: is atom compatible = true ;  is corei compatible = false ;  model string = " atom" ;  break ;  case 0x2a: is sandy compatible = true ;  model string = " sandy  bridge" ;  break ;  case 0x2b: model string = " core i7 / i5  ( 32nm ) " ;  break ;  case 0x2c: model string = " westmere" ;  break ;  case 0x2d: is sandy compatible = true ;  model string = " sandy  bridge" ;  break ;  case 0x2e: model string = " nehalem" ;  break ;  case 0x2f: model string = " westemere" ;  break ;  case 0x36: is atom compatible = true ;  is core2 compatible = false ;  is corei compatible = false ;  model string = " atom" ;  break ;  case 0x37: is atom compatible = true ;  is core2 compatible = false ;  is corei compatible = false ;  model string = " atom" ;  break ;  case 0x3a: is sandy compatible = true ;  is ivy compatible = true ;  model string = " ivy  bridge" ;  break ;  case 0x3d:  {  cpuidcpu info c = new cpuidcpu info (  )  ;  if  ( c . hasavx2 (  )  && c . hasbmi1 (  )  && c . hasbmi2 (  ) && c . hasfma3 (  ) && c . hasmovbe (  ) && c . hasabm (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  is haswell compatible = true ;  if  ( c . hasadx (  )  )  is broadwell compatible = true ;  model string = " broadwell  core i3 / i5 / i7" ;   }  else  {  if  ( c . hasavx (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  model string = " broadwell  celeron /  pentium w /  avx" ;   }  else  {  model string = " broadwell  celeron /  pentium" ;   }   }  break ;   }  case 0x3e: is sandy compatible = true ;  is ivy compatible = true ;  model string = " ivy  bridge" ;  break ;  case 0x3c: case 0x3f: case 0x45: case 0x46:  {  cpuidcpu info c = new cpuidcpu info (  )  ;  if  ( c . hasavx2 (  )  && c . hasbmi1 (  )  && c . hasbmi2 (  ) && c . hasfma3 (  ) && c . hasmovbe (  ) && c . hasabm (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  is haswell compatible = true ;  model string = " haswell  core i3 / i5 / i7 model "  +  model ;   }  else  {  if  ( c . hasavx (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  model string = " haswell  celeron /  pentium w /  avx model "  +  model ;   }  else  {  model string = " haswell  celeron /  pentium model "  +  model ;   }   }  break ;   }  case 0x4a: is core2 compatible = false ;  is corei compatible = false ;  model string = " quark" ;  break ;  case 0x4d: is atom compatible = true ;  model string = " atom" ;  break ;  case 0x4e: case 0x55: case 0x5e:  {  cpuidcpu info c = new cpuidcpu info (  )  ;  if  ( c . hasavx2 (  )  && c . hasbmi1 (  )  && c . hasbmi2 (  ) && c . hasfma3 (  ) && c . hasmovbe (  ) && c . hasabm (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  is haswell compatible = true ;  if  ( c . hasadx (  )  )  is broadwell compatible = true ;  model string = " skylake  core i3 / i5 / i7" ;   }  else  {  if  ( c . hasavx (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  model string = " skylake  celeron /  pentium w /  avx" ;   }  else  {  model string = " skylake  celeron /  pentium" ;   }   }  break ;   }  case 0x8e: case 0x9e:  {  cpuidcpu info c = new cpuidcpu info (  )  ;  if  ( c . hasavx2 (  )  && c . hasbmi1 (  )  && c . hasbmi2 (  ) && c . hasfma3 (  ) && c . hasmovbe (  ) && c . hasabm (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  is haswell compatible = true ;  if  ( c . hasadx (  )  )  is broadwell compatible = true ;  model string = " kaby  lake  core i3 / i5 / i7" ;   }  else  {  if  ( c . hasavx (  )  )   {  is sandy compatible = true ;  is ivy compatible = true ;  model string = " kaby  lake  celeron /  pentium w /  avx" ;   }  else  {  model string = " kaby  lake  celeron /  pentium" ;   }   }  break ;   }  default : model string = " intel model "  +  model ;  break ;   }   }  break ;  case 7:  {  model string = " intel  itanium model "  +  model ;   }  break ;  case 15:  {  is pentium compatible = true ;  is pentiummmx compatible = true ;  is pentium2 compatible = true ;  is pentium3 compatible = true ;  is pentium4 compatible = true ;  switch  ( model )   {  case 0: case 1: model string = " pentium iv  ( 180 nm ) " ;  break ;  case 2: model string = " pentium iv  ( 130 nm ) " ;  break ;  case 3: model string = " pentium iv  ( 90 nm ) " ;  break ;  case 4: model string = " pentium iv  ( 90 nm ) " ;  break ;  case 6: model string = " pentium iv  ( 65 nm ) " ;  break ;  default : model string = " intel  pentium iv model "  +  model ;  break ;   }   }  break ;  case 16:  {  model string = " intel  itanium ii model "  +  model ;   }   }  return model string ;   }  
@ test public void   (  )  {   iterable <  integer >  it =  flowable . range ( 1 300 )  . blocking iterable (  )  ;   flowable . just ( it it )  . flat map iterable (  functions .  <  iterable <  integer >  > identity (  )  )  . share (  )  . share (  )  
public  result set   (  )  throws sql exception  {  return cstmt . get generated keys (  )  ;   }  
public double   (  )  {  if  ( storage  !  =  null && storage . is checking (  )  )  return storage . get checking progress (  )  ;  else return 1 . 0d ;   }  
public void   (  )  {   string text = " this shoulder is visible" ;   spannable string builder ssb =  (  spannable string builder )  text utilities . highlight terms in text ( text "should ould" )  ;   background color span[] spans = ssb . get spans ( 0 ssb . length (  )   background color span . class )  ;  assert equals ( 1 spans . length )  ;   background color span span = spans[0] ;  assert equals ( text . index of ( "should" )  ssb . get span start ( span )  )  ;  assert equals ( text . index of ( "er is" )  ssb . get span end ( span )  )  ;   }  
@ test public void   (  )  throws  exception  {   mock http servlet request mock request = new  mock http servlet request (  )  ;   mock http servlet response mock response = new  mock http servlet response (  )  ;   filter chain mock filter chain = mock 
public static  string   (  path plugin dir )  {  return get element value ( plugin dir " / plugin / database key" )  ;   }  
private static  map <  string  string >    (  string args )  {   map <  string  string >  rv = new  hash map <  string  string >  ( 8 )  ;  char data[] = args . to char array (  )  ;   string builder buf = new  string builder ( 32 )  ;  boolean is quoted = false ;   string key = null ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )   {  switch  ( data[i] )   {  case '\'': case '"': if  ( is quoted )   {  if  ( key  !  =  null )   {  rv . put ( key buf . to string (  )  . trim (  )  )  ;  key = null ;   }  buf . set length ( 0 )  ;   }  is quoted =  ! is quoted ;  break ;  case ' ': case '\r': case '\n': case '\t': case ' ': if  ( is quoted )   {  buf . append ( data[i] )  ;   }  else  {  if  ( key  !  =  null )   {  rv . put ( key buf . to string (  )  . trim (  )  )  ;  key = null ;   }  buf . set length ( 0 )  ;   }  break ;  case ' = ': if  ( is quoted )   {  buf . append ( data[i] )  ;   }  else  {  key = buf . to string (  )  . trim (  )  . to lower case (  locale . us )  ;  buf . set length ( 0 )  ;   }  break ;  default : buf . append ( data[i] )  ;  break ;   }   }  if  ( key  !  =  null )  rv . put ( key buf . to string (  )  . trim (  )  )  ;  return rv ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final int indicator = 999999999 ;  hot stream (  )  . window ( 10 )  . take ( 2 )  . flat map ( new  function <  flowable <  integer >   flowable
public boolean   ( boolean monitor )  {  synchronized  ( incoming call listeners )   {  if  ( monitor  =  =  true )   {  if  ( incoming call listeners . contains ( this )  )   {  report error ( " client already has an incoming call listener" )  ;  return false ;   }  incoming call listeners . add ( this )  ;   incoming call handler . set direct conferencing ( false )  ;  loginfo ( "adding incoming call monitor  setting direct conferencing to false" )  ;   }  else  {  if  ( incoming call listeners . contains ( this )   =  =  false )   {  return false ;   }  incoming call listeners . remove ( this )  ;  if  ( incoming call listeners . size (  )   =  =  0 )   {   incoming call handler . set direct conferencing ( true )  ;  loginfo ( "removing last incoming call monitor setting direct conferencing to true" )  ;   }   }   }  return true ;   }  
@ override public  object   (  string name )  {  if  (  context . layout   inflater   service . equals ( name )  )   {  return m real context . get system service ( name )  ;   }  return super . get system service ( name )  ;   }  
public   (  )  throws io exception  {   logger . init (  )  ;   string s =  system . get property ( "com . sun . voip . server . receive   monitor   port" )  ;  int port = receive   monitor   port ;  if  ( s  !  =  null )   {  try  {  port =  integer . parse int ( s )  ;   }  catch  (   number format exception e )   {   logger . println ( " invalid  receive monitor port: "  +  e . get message (  )   +  " .   defaulting to " +  port )  ;   }   }  server socket = new  server socket ( port )  ;  start (  )  ;   }  
private int   (  date start date  date end date  string owner jid  string with jid  long before  string where clause )  {   string builder querysb ;  querysb = new  string builder ( count   conversations )  ;  querysb . append ( " where " )  ;  if  ( where clause  !  =  null && where clause . length (  )   !  =  0 )   {  querysb . append ( where clause )  ;  querysb . append ( " and " )  ;   }  querysb . append ( conversation   id )  . append ( "  <   ? " )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  int parameter index ;  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( querysb . to string (  )  )  ;  parameter index = bind conversation parameters ( start date end date owner jid with jid pstmt )  ;  pstmt . set long ( parameter index before )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  return rs . get int ( 1 )  ;   }  else  {  return 0 ;   }   }  catch  (  sql exception sqle )   {   log . error ( " error counting conversations" sqle )  ;  return 0 ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ test public void   (  )  {  final  string expected = " sun  06  nov 1994 08:49:37 gmt" ;  final  calendar then =  calendar . get instance (  )  ;  then . set time zone (  time zone . get time zone ( "gmt" )  )  ;  then . set ( 1994 10 6 8 49 37 )  ;  as
public static ssl socket factory   (  context context  host auth host auth  key manager key manager boolean insecure )  {  javax . net . ssl . ssl socket factory underlying = getssl socket factory ( context host auth key manager insecure )  ;  ssl socket factory wrapped = new ssl socket factory ( underlying )  ;  if  ( insecure )   {  wrapped . set hostname verifier ( ssl socket factory . allow   all   hostname   verifier )  ;   }  return wrapped ;   }  
public synchronized void   (  destination src byte[] data )  {  byte[] payload ;  if  (  ! this . raw )   {  synchronized  ( this . maker )   {  payload = this . maker . makei2p datagram ( data )  ;   }   }  else payload = data ;  try  {  this . sess . send message ( this . dest payload  ( this . raw  ?  i2p session . proto   datagram   raw : i2p session . proto   datagram )  i2p session . port   unspecified i2p session . port   unspecified )  ;   }  catch  (  i2p session exception ise )   {  throw new  runtime exception ( "failed to send data" ise )  ;   }   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public synchronized  list <  string >    (  tunnel controller controller )  {  if  ( controller  =  =  null )  return new  array list <  string >  (  )  ;  controller . stop tunnel (  )  ;   list <  string >  msgs = controller . clear messages (  )  ;     controllers lock . write lock (  )  . lock (  )  ;  try  {     controllers . remove ( controller )  ;   }  finally  {     controllers lock . write lock (  )  . unlock (  )  ;   }  msgs . add ( " tunnel "  +  controller . get name (  )   +  " removed" )  ;  return msgs ;   }  
public void   (  )  throws  exception  {   mime header header = new  mime header (  )  ;   string actual1 = header . write to string (  )  ;  assert equals ( "empty header" actual1 null )  ;  header . set header ( " header1" "value1" )  ;   string actual2 = header . write to string (  )  ;  assert equals ( "single header" actual2 " header1: value1\r\n" )  ;  header . set header ( " header2" "value2" )  ;   string actual3 = header . write to string (  )  ;  assert equals ( "multiple headers" actual3 " header1: value1\r\n"  +  " header2: value2\r\n" )  ;  header . set header (  mime header . header   android   attachment   store   data "value3" )  ;   string actual4 = header . write to string (  )  ;  assert equals ( "multiple headers" actual4 " header1: value1\r\n"  +  " header2: value2\r\n" )  ;   }  
@ check return value @ scheduler support (  scheduler support . custom )  public final  maybe < t >    ( long delay  time unit unit  scheduler scheduler )  {  return delay subscription (  flowable . timer ( delay unit scheduler )  )  ;   }  
private  collect wgs metrics .  wgs metrics   ( final int depth final int count scale final int start )  {  final int count = 100000 * count scale ;  final int total excluded =  ( 10  +  20  +  30 +  40 +  50 +  60 )  * count scale ;  return new  collect wgs metrics .  wgs metrics ( build interval list ( start start )  single depth histogram ( depth count )  single depth histogram ( depth count )  10d * count scale  /  count 20d * count scale  /  count 30d * count scale  /  count 40d * count scale  /  count 50d * count scale  /  count 60d * count scale  /  count total excluded  /   ( double )  ( count  +  total excluded )  1000000 null  - 1 )  ;   }  
public void   ( boolean allow requeue )  {  if  (  !    closed . compare and set ( false true )  )   {     log . log close loop ( "ntcp connection" this )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " closing connection "  +  to string (  )  new  exception ( "cause" )  )  ;  ntcp connection to close = locked   close ( allow requeue )  ;  if  ( to close  !  =  null && to close  !  =  this )   {  if  (    log . should log (  log . warn )  )     log . warn ( " multiple connections on remove  closing "  +  to close  +  "  ( already closed " +  this +  " ) " )  ;     context . stat manager (  )  . add rate data ( "ntcp . multiple close on remove" to close . get uptime (  )  )  ;  to close . close (  )  ;   }   }  
private static void   (  string sam host int sam port  string con options )  {  test transient ( sam host sam port con options )  ;  test new dest ( sam host sam port con options )  ;  test old dest ( sam host sam port con options )  ;  test fast ( sam host sam port con options )  ;   }  
public static void   ( final  string[] argv )  {   system . exit ( new  merge sam files (  )  . instance main ( argv )  )  ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  < u >  flowable < u >    ( final  class < u >  clazz )  {   object helper . require non null ( clazz "cla
public void   (  )  {  try  {   thread . sleep ( 30 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }     context . router (  )  . shutdown (  router . exit   hard )  ;   }  
@ override public boolean   (  )  {  return actual . has throwable (  )  ;   }  
  (  subscriber <  ?  super t >  actual )  {  this . actual = actual ;   }  
@ test public void   (  )  {   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  ( observer )  ;  with timeout . subscribe ( ts )  ;  test scheduler . advance ti
@ override public void   (  system model system model )  {  initialized = false ;   map <  string  list <  string >  >  all nodes =  system model interrogator . all cluster nodes ( system model )  ;  for  (   map .  entry <  string  list <  string >  >  e
public   (  router context ctx  floodfill network database facade facade  hash key  job on find  job on failed int timeout ms boolean is lease )  {  super ( ctx )  ;     log = ctx . log manager (  )  . get log ( get class (  )  )  ;     facade = facade ;     key = key ;     on find = new  copy on write array list <  job >  (  )  ;  if  ( on find  !  =  null )     on find . add ( on find )  ;     on failed = new  copy on write array list <  job >  (  )  ;  if  ( on failed  !  =  null )     on failed . add ( on failed )  ;  int timeout = timeout ms  /  flood   search   time   factor ;  if  ( timeout  <  timeout ms )  timeout = timeout ms ;     timeout ms = timeout ;     expiration = timeout  +  ctx . clock (  )  . now (  )  ;     is lease = is lease ;     created =  system . current time millis (  )  ;   }  
public   ( i2p app context ctx  tunnel creator config config )  {     config = config ;     processor = new  outbound gateway processor ( ctx config )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  o 
public void   (  hash key  hash from local dest )  {  if  (  !    initialized )  return ;  search ( key null null 20 * 1000 true from local dest )  ;   }  
@ override public int   (  )  {  return delegate . size (  )  ;   }  
@ override public void   (  handle handle )  {  rollback +  +  ;  super . rollback ( handle )  ;   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  observable . empty (  )   observable . amb array (  )  )  ;   }  
void   ( jid componentjid )  {  for  (   component event listener listener : listeners )   {  listener . component registered ( componentjid )  ;   }   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( main disposable . get (  )  )  ;   }  
@ test public void   (  )  {   publish subject <  object >  channel =  publish subject . create (  )  ;   observer <  object >  observera =  test helper . mock observer (  )  ;   observer <  object >  observerb =  test helper . mock observer (  )  ;   obs
public  string   (  )  {   string buffer sb = new  string buffer (  )  ;  long time = start time ;  for  ( int row = 0 ;  row  <  rows ;  row +  +   time +  = step )   {  sb . append ( time )  ;  sb . append ( ": " )  ;  for  ( int ds = 0 ;  ds  <  ds count ;  ds +  +  )   {  sb . append ( data[row][ds] )  ;  sb . append ( " " )  ;   }  sb . append ( newline )  ;   }  return sb . to string (  )  ;   }  
private int   (  string[] args int i )  {  if  ( i  >  =  args . length )   {  usage (  )  ;   }  int n = 0 ;  try  {  n =  integer . parse int ( args[i] )  ;  if  ( n  <  =  0 )   {   logger . println ( " number must be positive: "  +  args[i] )  ;   system . exit ( 1 )  ;   }   }  catch  (   number format exception e )   {   logger . println ( " invalid integer "  +  args[i]  +  " " +  e . get message (  )  )  ;   system . exit ( 1 )  ;   }  return n ;   }  
@ non null public static  runtime exception   ( @ non null  throwable t )  {  throw  exception helper . wrap or throw ( t )  ;   }  
private static byte[]   ( long now )  {   simple date format fmt = new  simple date format ( "yym mddh hmmss" )  ;  fmt . set time zone (  time zone . get time zone ( "gmt" )  )  ;  byte[] nowbytes =  data helper . getascii ( fmt . format ( new  date ( now )  )  )  ;  if  ( nowbytes . length  !  =  12 )  throw new  illegal argument exception (  )  ;  byte[] rv = new byte[15] ;  rv[0] = 0x17 ;  rv[1] = 13 ;   system . arraycopy ( nowbytes 0 rv 2 12 )  ;  rv[14] =  ( byte ) 'z' ;  return rv ;   }  
@ override public  string   (  )  {  return " get admin console info . " ;   }  
@ override public int   (  properties options )  {  if  (  !    file . exists (  )  )  return 0 ;   buffered reader in = null ;  get read lock (  )  ;  try  {  if  (    file . last modified (  )   <  =     last write )  return    size ;  in = new  buffere
@ test public void   (  )  throws  exception  {  find pattern ( " completable source <  . * > \\s + ss" )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable so
private static int   ( final  attachment att )  {  int priority class = priority   none ;  final int flags = att . m flags ;  if  (  ( flags &  attachment . flag   download   forward )   !  =  0 )   {  priority class = priority   send   mail ;   }  else if  (  ( flags &  attachment . flag   download   user   request )   !  =  0 )   {  priority class = priority   foreground ;   }  return priority class ;   }  
@ override public void   (  )  {  get room (  )  . presence updated (  update presence . this )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  subscription s = mock (  subscription . class )  ;   flowable <  string >  never =  flowable . unsafe create ( new  publisher <  string >  (  )  {  @ override public void subscribe (   su
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . on error return item ( 1 )  )  ;   }  
@ override public  string   (  string username  string prop name )  throws  user not found exception  {  return mapper . get user property provider ( username )  . load property ( username prop name )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . last element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
final void   (  )  {   node head = get (  )  ;  if  ( head . value  !  =  null )   {   node n = new  node ( null 0l )  ;  n . lazy set ( head . get (  )  )  ;  set ( n )  ;   }   }  
@ test public void   (  )  {  int num =  ( int )  (  flowable . buffer size (  )  * 4 . 1 )  ;   atomic integer c1 = new  atomic integer (  )  ;   atomic integer c2 = new  atomic integer (  )  ;   test subscriber <  integer >  ts = new  test subscriber < 
@ test public void   (  )  {   test scheduler scheduler1 = new  test scheduler (  )  ;   test scheduler scheduler2 = new  test scheduler (  )  ;   observable <  integer >  o =  observable . just ( 1 2 3 )  ;   observable <  integer >  o1 = o . observe on 
public final static int   (  string str  string chars )  {  return find of ( str chars  ( str . length (  )   -  1 )  0  - 1 true )  ;   }  
@ override public  transport session < xmpp buddy >    (  registration registration jid jid  presence type presence type  string verbose status  integer priority )  {   transport session < xmpp buddy >  session = new xmpp session ( registration jid this p
public  string   (  )  {  if  ( email notify list  =  =  null || email notify list . is empty (  )  )   {  return "" ;   }   string builder buf = new  string builder (  )  ;  buf . append ( email notify list . get ( 0 )  )  ;  for  ( int i = 1 ;  i  <  email notify list . size (  )  ;  i +  +  )   {  buf . append ( "  " )  ;  buf . append ( email notify list . get ( i )  )  ;   }  return buf . to string (  )  ;   }  
@ test public void   (  )  throws  transformer exception  {   source resource = resolver . resolve ( null "" )  ;  assert null ( " should handle null href" resource )  ;   }  
  (  completable observer co )  {  this . co = co ;   }  
@ test public void   (  )  throws  exception  {  tos . write ( new byte[10] )  ;  assert equals ( 0 baos . size (  )  )  ;  tos . reset (  )  ;  assert equals ( 0 baos . size (  )  )  ;  tos . close (  )  ;  assert equals ( 0 baos . size (  )  )  ;  asser
public   ( int id )  {  if  ( id  <  0 || id  >  65535 )  throw new  illegal argument exception (  )  ;     session id = id ;   }  
private   (  )  {  server = xmpp server . get instance (  )  ;  user manager = server . get user manager (  )  ;  roster manager = server . get roster manager (  )  ;   }  
public void   (  string f )  {  try  {     cost =  integer . parse int ( f )  ;   }  catch  (   number format exception nfe )   {   }   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
private boolean   ( long entry boolean add if new )  {   array wrapper w = new  array wrapper ( entry )  ;  get read lock (  )  ;  try  {  return locked   add ( w add if new )  ;   }  finally  {  release read lock (  )  ;   }   }  
public   (  field f  big integer l )  {  this . l = l ;  enc = new  big integer little endian encoding (  )  ;  enc . set field ( f )  ;   }  
@ deprecated public boolean   (  )  {  return false ;   }  
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
@ before public void   (  )  throws  exception  {  filter config = new  mock filter config (  )  ;  filter config . add init parameter ( "debug" "true" )  ;  filter config . add init parameter ( "stats enabled" "true" )  ;  filter = new  compressing filte
public   (  )  {  super ( "xmpp  roster  handler" )  ;  info = new iq handler info ( "query" "jabber:iq:roster" )  ;   }  
@ override public  publisher <  integer >    (  flowable <  integer >  v )  {  return new  flowable do on each <  integer >  ( v new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  throw new  test exce
public  string   (  )  {  return version ;   }  
@ test public void   (  )  throws  exception  {   target host info target host info = new  target host info ( target host )  ;  assert equals ( " returned url was not the expected url" new url ( "http" "otherhost . com"  - 1 "" )  target host info . get p
public void   (  node node )  {  set root node ( node )  ;   }  
public  group   (  string name boolean force lookup )  throws  group not found exception  {   group group = null ;  if  ( force lookup )   {  group cache . remove ( name )  ;   }  else  {  group = group cache . get ( name )  ;   }  if  ( group  =  =  null )   {  synchronized  ( name . intern (  )  )   {  group = group cache . get ( name )  ;  if  ( group  =  =  null )   {  group = provider . get group ( name )  ;  group cache . put ( name group )  ;   }   }   }  return group ;   }  
@ test public void   (  )  {  assert that ( handle . create query ( "select :id" )  . bind ( "id" 3 )  . map to (  integer . class )  . find only (  )  . int value (  )  )  . is equal to ( 3 )  ;   }  
@ override public boolean   (  object o )  {  if  ( o  =  =  this )   {  return true ;   }  if  (  ( o  =  =  null )  ||  ( o . get class (  )   !  =  get class (  )  )  )   {  return false ;   }  return  (  (  attachment info ) o )  . m id  =  =  m id ; 
public msim connection   (  )  {  return connection ;   }  
public int   (  )  {  return keysize   bytes ;   }  
@ test ( expected =  test exception . class )  public void   (  )  {   completable c =  completable . merge delay error ( new  iterable iterator has next throws (  )  )  ;  c . blocking await (  )  ;   }  
@ test public void   (  )  {  assert equals ( destination id destination info logic . get destination id (  )  )  ;   }  
@ override public void   (  subscription d )  {   queue subscription <  ?  >  qd =  (  queue subscription <  ?  >  ) d ;  assert false ( qd . is empty (  )  )  ;  qd . clear (  )  ;  assert true ( qd . is empty (  )  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  single < r >    (  callable < r >  seed supplier  bi function < r  ?  super t r >  reducer )  {   object helper . require non null ( seed supplier "seed supplier 
@ override public void   (  )  {  source . subscribe ( new  resume single observer < t >  ( this actual )  )  ;   }  
@ override public long   (  )  {  return    remaining ;   }  
private void   (  string action  http servlet request req )  {  if  ( action . equals (    t ( " delete selected" )  )  || action . equals (    t ( " save tracker configuration" )  )  )   {  boolean changed = false ;   map <  string  tracker >  trackers =    manager . get tracker map (  )  ;   list <  string >  removed = new  array list <  string >  (  )  ;   list <  string >  open = new  array list <  string >  (  )  ;   list <  string >  priv = new  array list <  string >  (  )  ;   enumeration <  ?  >  e = req . get parameter names (  )  ;  while  ( e . has more elements (  )  )   {   object o = e . next element (  )  ;  if  (  !  ( o instanceof  string )  )  continue ;   string k =  (  string ) o ;  if  ( k . starts with ( "delete   " )  )   {  k = k . substring ( 7 )  ;   tracker t ;  if  (  ( t = trackers . remove ( k )  )   !  =  null )   {  removed . add ( t . announceurl )  ;     manager . add message (    t ( " removed" )   +  ": "  +   data helper . striphtml ( k )  )  ;  changed = true ;   }   }  else if  ( k . starts with ( "ttype   " )  )   {   string val = req . get parameter ( k )  ;  k = k . substring ( 6 )  ;  if  ( "1" . equals ( val )  )  open . add ( k )  ;  else if  ( "2" . equals ( val )  )  priv . add ( k )  ;   }   }  if  ( changed )   {     manager . save tracker map (  )  ;   }  open . remove all ( removed )  ;   list <  string >  old open = new  array list <  string >  (    manager . util (  )  . get open trackers (  )  )  ;   collections . sort ( old open )  ;   collections . sort ( open )  ;  if  (  ! open . equals ( old open )  )     manager . save open trackers ( open )  ;  priv . remove all ( removed )  ;  priv . remove all ( open )  ;   list <  string >  old priv = new  array list <  string >  (    manager . get private trackers (  )  )  ;   collections . sort ( old priv )  ;   collections . sort ( priv )  ;  if  (  ! priv . equals ( old priv )  )     manager . save private trackers ( priv )  ;   }  else if  ( action . equals (    t ( " add tracker" )  )  )   {   string name = req . get parameter ( "tname" )  ;   string hurl = req . get parameter ( "thurl" )  ;   string aurl = req . get parameter ( "taurl" )  ;  if  ( name  !  =  null && hurl  !  =  null && aurl  !  =  null )   {  name =  data helper . striphtml ( name . trim (  )  )  ;  hurl =  data helper . striphtml ( hurl . trim (  )  )  ;  aurl =  data helper . striphtml ( aurl . trim (  )  )  . replace ( " = " "&#61 ; " )  ;  if  ( name . length (  )   >  0 && hurl . starts with ( "http: /  / " )  &&  tracker client . is valid announce ( aurl )  )   {   map <  string  tracker >  trackers =    manager . get tracker map (  )  ;  trackers . put ( name new  tracker ( name aurl hurl )  )  ;     manager . save tracker map (  )  ;   string type = req . get parameter ( "add   tracker   type" )  ;  if  ( "1" . equals ( type )  )   {   list <  string >  new open = new  array list <  string >  (    manager . util (  )  . get open trackers (  )  )  ;  new open . add ( aurl )  ;     manager . save open trackers ( new open )  ;   }  else if  ( "2" . equals ( type )  )   {   list <  string >  new priv = new  array list <  string >  (    manager . get private trackers (  )  )  ;  new priv . add ( aurl )  ;     manager . save private trackers ( new priv )  ;   }   }  else  {     manager . add message (    t ( " enter valid tracker name and ur ls" )  )  ;   }   }  else  {     manager . add message (    t ( " enter valid tracker name and ur ls" )  )  ;   }   }  else if  ( action . equals (    t ( " restore defaults" )  )  )   {     manager . set default tracker map (  )  ;     manager . save open trackers ( null )  ;     manager . add message (    t ( " restored default trackers" )  )  ;   }  else  {     manager . add message ( " unknown post action: \""  +  action  +  '\"' )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  list <  integer >  >  ts = pp . buff
@ test public void   (  )  {  assert not null ( jaxb transform . get marshaller pool (  )  )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private synchronized void   (  )  throws io exception  {  byte[] delim = new byte[3] ;  byte[] buf = new byte[segment   record   length] ;  if  ( file  =  =  null )   {  return ;   }  if  (  ( dboptions & geoip   check   cache )   !  =  0 )   {  mtime = database file . last modified (  )  ;   }  file . seek ( file . length (  )   -  3 )  ;  for  ( int i = 0 ;  i  <  structure   info   max   size ;  i +  +  )   {  file . read fully ( delim )  ;  if  ( delim[0]  =  =   - 1 && delim[1]  =  =   - 1 && delim[2]  =  =   - 1 )   {  database type = file . read byte (  )  ;  if  ( database type  >  =  106 )   {  database type -  = 105 ;   }  if  ( database type  =  =   database info . region   edition   rev0 )   {  database segments = new int[1] ;  database segments[0] = state   begin   rev0 ;  record length = standard   record   length ;   }  else if  ( database type  =  =   database info . region   edition   rev1 )   {  database segments = new int[1] ;  database segments[0] = state   begin   rev1 ;  record length = standard   record   length ;   }  else if  ( database type  =  =   database info . city   edition   rev0 || database type  =  =   database info . city   edition   rev1 || database type  =  =   database info . org   edition || database type  =  =   database info . org   edition   v6 || database type  =  =   database info . isp   edition || database type  =  =   database info . isp   edition   v6 || database type  =  =   database info . domain   edition || database type  =  =   database info . domain   edition   v6 || database type  =  =   database info . asnum   edition || database type  =  =   database info . asnum   edition   v6 || database type  =  =   database info . netspeed   edition   rev1 || database type  =  =   database info . netspeed   edition   rev1   v6 || database type  =  =   database info . city   edition   rev0   v6 || database type  =  =   database info . city   edition   rev1   v6 )   {  database segments = new int[1] ;  database segments[0] = 0 ;  if  ( database type  =  =   database info . city   edition   rev0 || database type  =  =   database info . city   edition   rev1 || database type  =  =   database info . asnum   edition   v6 || database type  =  =   database info . netspeed   edition   rev1 || database type  =  =   database info . netspeed   edition   rev1   v6 || database type  =  =   database info . city   edition   rev0   v6 || database type  =  =   database info . city   edition   rev1   v6 || database type  =  =   database info . asnum   edition )   {  record length = standard   record   length ;   }  else  {  record length = org   record   length ;   }  file . read fully ( buf )  ;  for  ( int j = 0 ;  j  <  segment   record   length ;  j +  +  )   {  database segments[0] +  =  ( unsigned byte to int ( buf[j] )   <  <   ( j * 8 )  )  ;   }   }  break ;   }  else  {  file . seek ( file . get file pointer (  )   -  4 )  ;   }   }  if  (  ( database type  =  =   database info . country   edition )  ||  ( database type  =  =   database info . country   edition   v6 )  ||  ( database type  =  =   database info . proxy   edition ) ||  ( database type  =  =   database info . netspeed   edition )  )   {  database segments = new int[1] ;  database segments[0] = country   begin ;  record length = standard   record   length ;   }  if  (  ( dboptions & geoip   memory   cache )   =  =  1 )   {  int l =  ( int ) file . length (  )  ;  dbbuffer = new byte[l] ;  file . seek ( 0 )  ;  file . read fully ( dbbuffer 0 l )  ;  database info = get database info (  )  ;  file . close (  )  ;   }  if  (  ( dboptions & geoip   index   cache )   !  =  0 )   {  int l = database segments[0] * record length * 2 ;  index   cache = new byte[l] ;  file . seek ( 0 )  ;  file . read fully ( index   cache 0 l )  ;   }  else  {  index   cache = null ;   }   }  
@ override public  element   (  string username )  {  synchronized  ( username . intern (  )  )   {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;   element v card element = null ;  sax reader xml reader = null ;  t
public void   (  list <  string >  members )  {  this . members = members ;   }  
@ test public void   (  )  {  final int m = 4 ;  final  atomic integer subscription count = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . range ( 1 10 )  . flat map ( new  function <  integer  flowable <  integer >  >  (  )  { 
public static boolean   ( final  string input )  {  return ipv4   pattern . matcher ( input )  . matches (  )  ;   }  
public static boolean   (  )  {  return use single sender ;   }  
@ override public final boolean   (  )  {  return index  =  =  end ;   }  
public void   (  )  {  for  (   request queue request queue : get request queues (  )  )   {  request queue . shutdown (  )  ;   }  chatbot = null ;  queue comparator = null ;   }  
public static void   (  )  {  computation (  )  . shutdown (  )  ;  io (  )  . shutdown (  )  ;  new thread (  )  . shutdown (  )  ;  single (  )  . shutdown (  )  ;  trampoline (  )  . shutdown (  )  ;   scheduler pool factory . shutdown (  )  ;   }  
public void   (  )  {  encodes = 0 ;  bytes encoded = 0 ;  encode time = 0 ;   }  
@ override public void   (  single observer <  ?  super  boolean >  s )  {   equal coordinator < t >  parent = new  equal coordinator < t >  ( s prefetch comparer )  ;  s . on subscribe ( parent )  ;  parent . subscribe ( first second )  ;   }  
@ override public void   (  single observer <  ?  super t >  t )  {  source . subscribe ( new  single element observer < t >  ( t default value )  )  ;   }  
public   ( ssl server socket socket )  {  super (  selector provider . provider (  )  )  ;     socket = socket ;   }  
private  peer profile   (  hash peer )  {  return    context . profile organizer (  )  . get profile nonblocking ( peer )  ;   }  
public void   (  string s )  {  if  ( s  !  =  null )     other options . put ( "inbound . random key" s . trim (  )  )  ;   }  
@ override public  string   (  )  {  if  ( is direct (  )  )  return super . get file name (  )  ;  load config (  )  ;   string filename = properties . get property ( get book (  )   +  "   addressbook" )  ;  return basename ( filename )  ;   }  
public int   (  )  {  return a ;   }  
public void   ( jid to )  {  if  (  ! presence . equals (  presence type . unavailable )  )   {   presence p = new  presence (  )  ;  p . set type (  presence .  type . unavailable )  ;  p . set to ( to )  ;  p . set from ( jid )  ;  get manager (  )  . send packet ( p )  ;   }   }  
public void   ( long milliseconds )  {  m time +  = milliseconds ;   }  
@ override public  single <  ?  extends  integer >    (  integer v )  throws  exception  {  return  single . just ( v )  ;   }  
@ override public  user provider   (  string username )  {  for  (  final  map .  entry <  string  user provider >  entry : providers by prefix . entry set (  )  )   {  final  string users property =  jive globals . get property ( entry . get key (  )   +
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer ( 3 )  ;  final  atomic integer number of subscribe calls = new  atomic integer ( 0 )  ;   maybe . from callable ( new  callable <  boolean >  (  )  {  @ override pub
public static boolean   (  router context ctx  string transport style )  {  return ctx . get boolean property ( prop   ipv4   firewalled )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   burst . item ( 1 )  . create (  )  . collect ( callable list creator (  )  bi consumer throws ( e )  )  . to observable (  )  . test (  )  . assert error ( e )  . 
@ test ( expected =  arithmetic exception . class )  public void   (  )  {  handle . execute ( "insert into intervals ( id  foo )  values (  ?    ?  ) " 10  duration . of seconds (  long . min   value )  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . range long ( 1 2 )  )  ;   }  
private  filter sam reads   ( final  file input file final  file input sam final  filter sam reads .  filter filter )  throws  exception  {  return setup program ( input file input sam filter null )  ;   }  
@ override public void   ( final  subscriber <  ?  super  string >  observer )  {   system . out . println ( " test flowable subscribed to  .  .  . " )  ;  observer . on subscribe ( new  boolean subscription (  )  )  ;  t = new  thread ( new  runnable (  
public void   (  string name )  {   remote session task task = new  setter task ( address  setter task .  type . name name )  ;  do cluster task ( task )  ;   }  
@ test public void   (  )  {  final  disposable d =  disposables . empty (  )  ;   maybe .  <  integer > create ( new  maybe on subscribe <  integer >  (  )  {  @ override public void subscribe (   maybe emitter <  integer >  e )  throws  exception  {  e 
protected boolean   ( int size )  {  if  ( size  <  =  dont   compress   size )  return false ;   string p = get options (  )  . get property ( "i2cp . gzip" )  ;  if  ( p  !  =  null )  return  boolean . parse boolean ( p )  ;  return should   compress ;   }  
@ test public void   (  )  throws  exception  {   string xml = " < root >  < foo >  <  / foo >  <  / root > " ;  xml properties props = new xml properties ( new  byte array input stream ( xml . get bytes (  )  )  )  ;  assert null ( props . get attribute 
@ test ( timeout = 5000 )  public void   (  )  throws  interrupted exception  {  final  test scheduler scheduler = new  test scheduler (  )  ;  final  completable c = error . completable . delay ( 250  time unit . milliseconds scheduler )  ;  final  atomi
public int   ( int tunnel )  {  return    helper . get post max ( tunnel )  ;   }  
public  string   (  )  {  return " <  ? xml version = '1 . 0' encoding = 'utf - 8' ?  > "  +  " < presence xmlns = 'urn:ietf:params:xml:ns:pidf'"  +  " xmlns:dm = 'urn:ietf:params:xml:ns:pidf:data - model'" +  " xmlns:rpid = 'urn:ietf:params:xml:ns:pidf:rpid'" +  " xmlns:c = 'urn:ietf:params:xml:ns:pidf:cipid'" +  " entity = '"  +  entity  +  "' > " +  " < tuple id = 't" +  get eight length ( tuple status . hash code (  )  )  +  "' >  < status >  < basic > " +  tuple status . to string (  )  +  " <  / basic >  <  / status >  <  / tuple > " +  " < dm:person id = 'p" +  get eight length ( this . hash code (  )  )  +  "' >  < rpid:activities >  < rpid:" +  rpid . to string (  )  +  " /  >  <  / rpid:activities > " +   (  ( dm note  !  =  null &&  ! dm note . equals ( "" )  )   ?  " < dm:note > "  +  dm note  +  " <  / dm:note > " : "" )  +  " <  / dm:person > " +  " <  / presence > " ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . switch on next (  flowable . just (  flowable . just ( 1 )  )  . hide (  )  )  )  ;   }  
private  list <  news entry >    (  )  {   file file = new  file (    context . get base dir (  )  "docs / initial news / initial news . xml" )  ;   reader reader = null ;  try  {  char[] buf = new char[512] ;   string builder out = new  string builder ( 2048 )  ;  reader = new  translate reader (    context bundle   name new  file input stream ( file )  )  ;  int len ;  while  (  ( len = reader . read ( buf )  )   >  0 )   {  out . append ( buf 0 len )  ;   }   list <  news entry >  rv = parse news ( out . to string (  )  true )  ;  if  (  ! rv . is empty (  )  )   {  rv . get ( 0 )  . updated =    context . clock (  )  . now (  )  ;   }  else  {  if  (    log . should warn (  )  )     log . warn ( "failed to load "  +  file )  ;   }  return rv ;   }  catch  (  io exception ioe )   {  if  (    log . should warn (  )  )     log . warn ( "failed to load "  +  file ioe )  ;  return  collections . empty list (  )  ;   }  finally  {  try  {  if  ( reader  !  =  null )  reader . close (  )  ;   }  catch  (  io exception foo )   {   }   }   }  
public void   (  conference member member )  {  synchronized  ( member done listeners )   {   string conference id = member . get conference manager (  )  . get id (  )  ;   array list <  conference member >  member list = member done listeners . get ( conference id )  ;  if  ( member list  =  =  null )   {  member list = new  array list <  conference member >  (  )  ;  member done listeners . put ( conference id member list )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " created member done list for "  +  conference id )  ;   }   }  if  ( member list . contains ( member )  )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " member already in done list for "  +  conference id )  ;   }  return ;   }  member list . add ( member )  ;   }   }  
@ inject public   (  http client service http client service  configuration service configuration service )  {  this . http client service = http client service ;  this . configuration service = configuration service ;   }  
@ test public void   (  )  {  convert file ( unmapped cram unmapped bam " . bam" )  ;   }  
@ test public void   (  )  {   observable <  string >  o =  observable . zip (  observable .  <  integer > empty (  )   observable .  <  string > empty (  )  new  bi function <  integer  string  string >  (  )  {  @ override public  string apply (   integ
@ test public void   (  )  throws  exception  {   meter meter one = mock (  meter . class )  ;   meter meter two = mock (  meter . class )  ;   meter meter three = mock (  meter . class )  ;   multi meter . mark all ( meter one meter two meter three )  ; 
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . combine latest delay error ( null 128  flowable . never (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  assert that ( hash ring datastore . get name (  )  equal to (  hash ring datastore . datastore   name )  )  ;   }  
protected void   ( final int lane )  {  if  ( lane  !  =  get lane (  )  )   {  throw new  picard exception ( " lane number mismatch: "  +  lane  +  "  !  =  " +  get lane (  )  )  ;   }   }  
@ test public void   (  )  throws  exception  {  final x509 certificate invalid =  keystore test utils . generate expired certificate (  )  ;  final  collection < x509 certificate >  input = new  array list <  >  (  )  ;  input . add ( invalid )  ;  final
@ override public  string   (  )  {  return null ;   }  
private   (  )  {  user cache =  cache factory . create cache ( " user" )  ;  remote users cache =  cache factory . create cache ( " remote  users  existence" )  ;  init provider (  )  ;  init property provider (  )  ;   property event listener prop listener = new  property event listener (  )  {  @ override public void property set (   string property   map params )  {  if  ( "provider . user . class name" . equals ( property )  )   {  init provider (  )  ;   }  if  ( "provider . userproperty . class name" . equals ( property )  )   {  init property provider (  )  ;   }   }  @ override public void property deleted (   string property   map params )  {  if  ( "provider . user . class name" . equals ( property )  )   {  init provider (  )  ;   }  if  ( "provider . userproperty . class name" . equals ( property )  )   {  init property provider (  )  ;   }   }  @ override public void xml property set (   string property   map params )  {   }  @ override public void xml property deleted (   string property   map params )  {   }   }   ;   property event dispatcher . add listener ( prop listener )  ;   user event listener user listener = new  user event listener (  )  {  @ override public void user created (   user user   map <  string  object >  params )  {  user cache . put ( user . get username (  )  user )  ;   }  @ override public void user deleting (   user user   map <  string  object >  params )  {  user cache . remove ( user . get username (  )  )  ;   }  @ override public void user modified (   user user   map <  string  object >  params )  {  user cache . put ( user . get username (  )  user )  ;   }   }   ;   user event dispatcher . add listener ( user listener )  ;   }  
@ test public void   (  )  {   observable . sequence equal (  observable . just ( 1 )   observable . just ( 2 )  )  . to observable (  )  . test (  )  . assert result ( false )  ;   }  
public byte[]   (  )  {  return dest hash ;   }  
public  string   (  )  {  return "pkcs#8" ;   }  
public   ( sax transformer factory factory boolean allow entities boolean allow declarations )  {  this . factory = factory ;  this . allow entities = allow entities ;  this . allow dtd declarations = allow declarations ;  try  {  factory . set feature ( xml constants . feature   secure   processing true )  ;  factory . set feature (  feature keys . allow   external   functions  boolean . true )  ;   }  catch  (   transformer configuration exception ex )   {  log . error ( " error" ex )  ;   }   }  
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  presence manager = server . get presence manager (  )  ;   }  
@ override public  string   (  )  {  return  ( value  =  =  null  ?  "null" :  string . value of ( value )  )   +   ( sql type  =  =  null  ?  "" : "  ( type "  +  sql type  +  " ) " )  ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  mock transport . expect ( null " - err from the  mock  transport . " )  ;  try  {   pop3 store .  pop3 folder folder = m store . new  pop3 folder ( "inbox" )  ;  folder . open (  open mode . read   write )  ;  fail ( " should have thrown exception" )  ;   }  catch  (   messaging exception me )   {   }  mock transport . expect ( "quit" "" )  ;  mock transport . expect close (  )  ;  setup open folder ( mock transport 0 "uidl" )  ;  mock transport . expect ( "quit" "" )  ;  m store . check settings (  )  ;   }  
@ test public void   (  )  {  final  disposable s = mock (  disposable . class )  ;   observable <  integer >  o =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integ
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 3 )  ;   flowable <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1  <  2 ;   }   }   )
private  map <  string  string >    (  string username )  {  username = jid . unescape node ( username )  ;   map <  string  string >  map = new  hash map <  >  (  )  ;   dir context ctx = null ;  try  {   string userdn = manager . find userdn ( username )  ;  ctx = manager . get context ( manager . get users basedn ( username )  )  ;   attributes attrs = ctx . get attributes ( userdn template . get attributes (  )  )  ;  for  (   string attribute : template . get attributes (  )  )   {  javax . naming . directory .  attribute attr = attrs . get ( attribute )  ;   string value ;  if  ( attr  =  =  null )   {   log . debug ( " ldapv card provider:  no ldap value found for attribute '"  +  attribute  +  "'" )  ;  value = "" ;   }  else  {   object ob = attrs . get ( attribute )  . get (  )  ;   log . debug ( " ldapv card provider:  found attribute "  +  attribute  +  " of type: " +  ob . get class (  )  )  ;  if  ( ob instanceof  string )   {  value =  (  string ) ob ;   }  else  {  value =  base64 . encode bytes (  ( byte[] ) ob )  ;   }   }   log . debug ( " ldapv card provider:  ldap attribute '"  +  attribute  +  "' =  > '" +  value +  "'" )  ;  map . put ( attribute value )  ;   }  return map ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return  collections . empty map (  )  ;   }  finally  {  try  {  if  ( ctx  !  =  null )   {  ctx . close (  )  ;   }   }  catch  (   exception e )   {   }   }   }  
@ override public  list <  header value >    (  string name )  {  return header values . get (  header name . wrap ( name )  )  ;   }  
@ before public void   (  )  {  repose info logic = new  repose info logic (  )  ;   }  
private static  string   (  string raw )  {  return  string util . sanitize xml string ( raw )  ;   }  
public  eddsa parameter spec   (  )  {  return spec ;   }  
public int   (  )  {  return ds count ;   }  
@ override public  boolean   (  )  {  return false ;   }  
public   (  thread thread reference  object thread key )  {  this . thread reference = thread reference ;  this . lock key = thread key ;   }  
private synchronized void   (  )  {  if  (    writer  !  =  null )  return ;  if  (  system version . is android (  )  )   {  try  {   class <  ?  extends  log writer >  clazz =  class . for name ( "net . i2p . util .  android log writer" )  . as subclass (  log writer . class )  ;   constructor <  ?  extends  log writer >  ctor = clazz . get declared constructor (  log manager . class )  ;     writer = ctor . new instance ( this )  ;   }  catch  (   class not found exception e )   {   }  catch  (   instantiation exception e )   {   }  catch  (   illegal access exception e )   {   }  catch  (   invocation target exception e )   {   }  catch  (   no such method exception e )   {   }   }  if  (    writer  =  =  null )     writer = new  file log writer ( this )  ;     writer . set flush interval (    flush interval * 1000 )  ;   thread t = new i2p thread (    writer " log writer" )  ;  t . set daemon ( true )  ;  t . start (  )  ;   }  
@ override public  collection <  string >    (  )  {  return null ;   }  
@ test ( timeout = 5000 expected =  null pointer exception . class )  public void   (  )  {   completable c =  completable . merge array ( normal . completable null )  ;  c . blocking await (  )  ;   }  
@ override public void   (  packet packet  session session boolean read boolean processed )  {  if  (  ! processed )   {  jid from = packet . get from (  )  ;  jid to = packet . get to (  )  ;  if  (  ( from  =  =  null ||  ! ignore list . contains ( from
  (  peer coordinator coordinator )  {  this . coordinator = coordinator ;   }  
public void   ( int port )  {     remote port = port ;   }  
public static void   ( int listen port )  {  sam bridge . main ( new  string[] { "0 . 0 . 0 . 0" listen port  +  "" }  )  ;   }  
@ override public  iterable <  network interface >    (  )  throws  socket exception  {  return new  enumeration iterable <  >  (  network interface . get network interfaces (  )  )  ;   }  
@ override public  iterator <  integer >    (  )  {  return new  iterator <  integer >  (  )  {  @ override public void remove (  )  {   }  @ override public  integer next (  )  {  return generated . get and increment (  )  ;   }  @ override public boolea
static  < t > boolean   (  object source  function <  ?  super t  ?  extends  completable source >  mapper  completable observer observer )  {  if  ( source instanceof  callable )   {  @ suppress warnings ( "unchecked" )   callable < t >  call =  (  callable < t >  ) source ;   completable source cs = null ;  try  {  t item = call . call (  )  ;  if  ( item  !  =  null )   {  cs =  object helper . require non null ( mapper . apply ( item )  " the mapper returned a null  completable source" )  ;   }   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   empty disposable . error ( ex observer )  ;  return true ;   }  if  ( cs  =  =  null )   {   empty disposable . complete ( observer )  ;   }  else  {  cs . subscribe ( observer )  ;   }  return true ;   }  return false ;   }  
private  class loader   (  )  {   class loader parent =  thread . current thread (  )  . get context class loader (  )  ;  if  ( parent  =  =  null )   {  parent = this . get class (  )  . get class loader (  )  ;  if  ( parent  =  =  null )   {  parent =  class loader . get system class loader (  )  ;   }   }  return parent ;   }  
public   ( jid roomjid  string name )  {  this . jid = roomjid ;  this . name = name ;   }  
public  subscriber   (  string name )  {   subscriber list sub list = get subscriber list (  )  ;  int sub list cnt = sub list . size (  )  ;  for  ( int n = 0 ;  n  <  sub list cnt ;  n +  +  )   {   subscriber sub = sub list . get subscriber ( n )  ;  if  ( sub  =  =  null )  continue ;   string sid = sub . getsid (  )  ;  if  ( sid  =  =  null )  continue ;  if  ( sid . equals ( name )   =  =  true )  return sub ;   }  return null ;   }  
public   (  router context ctx  client app manager mgr  string args[] )  {     context = ctx ;     mgr = mgr ;  if  ( args . length  =  =  0 )   {     listen port =  integer . to string ( default   listen   port )  ;   }  else  {  boolean ssl = false ;  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )   {  if  ( args[i] . equals ( " - s" )  )  ssl = true ;  else if  (  (  ! ssl )  &&    listen port  =  =  null )     listen port = args[i] ;  else if  (  (  ! ssl )  &&    listen host  =  =  null )     listen host = args[i] ;  else if  ( ssl &&    ssl listen port  =  =  null )     ssl listen port = args[i] ;  else if  ( ssl &&    ssl listen host  =  =  null )     ssl listen host = args[i] ;  else if  (    web apps dir  =  =  null )     web apps dir = args[i] ;  else  {   system . err . println ( usage )  ;  throw new  illegal argument exception ( usage )  ;   }   }   }  if  (    listen host  =  =  null )     listen host =  port mapper . default   host ;  if  (    ssl listen host  =  =  null )     ssl listen host =    listen host ;  if  (    web apps dir  =  =  null )     web apps dir = default   webapps   dir ;  if  (    listen port  =  =  null &&    ssl listen port  =  =  null )   {   system . err . println ( usage )  ;  throw new  illegal argument exception ( usage )  ;   }     state = initialized ;   }  
private boolean   (  string ver attribute )  {  return entity capabilities map . contains key ( ver attribute )  ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;  if  ( source mode  =  =  none )   {  try  {  on after next . accept ( t )  ;   }  catch  (   throwable ex )   {  fail ( ex )  ;   }   }   }  
@ test public void   (  )  throws io exception  {  run analysis ( "unmapped   mate" "minimum   insert   size = 0" "maximum   insert   size = 0" )  ;   }  
protected boolean   ( final byte b )  {  for  ( int i = 0 ;  i  <  delimiters . length ;  i +  +  )   {  if  ( b  =  =  delimiters[i] )   {  return true ;   }   }  return false ;   }  
public   (  flowable < t >  source  bi predicate <  ?  super  integer  ?  super  throwable >  predicate )  {  super ( source )  ;  this . predicate = predicate ;   }  
public   (  flowable < t >  source  function <  ?  super t  ?  extends  publisher <  ?  extends u >  >  mapper boolean delay errors int max concurrency int buffer size )  {  super ( source )  ;  this . mapper = mapper ;  this . delay errors = delay errors ;  this . max concurrency = max concurrency ;  this . buffer size = buffer size ;   }  
private void   (  string app )  {   console update manager mgr =  update handler . update manager (    context )  ;  if  ( mgr  =  =  null )   {  add form error ( " update manager not registered  cannot check" )  ;  return ;   }  if  (  ! verify proxy (  )  )  return ;  mgr . check ( plugin app )  ;  add form notice (    t ( " checking plugin  { 0 }  for updates" app )  )  ;  try  {   thread . sleep ( 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  
void   (  observable source <  ?  > [] others int n )  {   with latest inner observer[] observers = this . observers ;   atomic reference <  disposable >  s = this . d ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {  if  (  disposable helper . is disposed ( s . get (  )  )  || done )   {  return ;   }  others[i] . subscribe ( observers[i] )  ;   }   }  
  (  observer <  ?  super t >  actual int skip )  {  super ( skip )  ;  this . actual = actual ;  this . skip = skip ;   }  
public boolean   (  )  {  return is method ( http . get )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >  debounce sel = new  function <  integer  observable <  integer >  >  (  )  {  @ override public  obs
public byte[]   (  )  {  if  ( packet bytes  !  =  null )  return packet bytes ;   datagram packet packet = get datagram packet (  )  ;  int packet len = packet . get length (  )  ;   string packet data = new  string ( packet . get data (  )  0 packet len )  ;  packet bytes = packet data . get bytes (  )  ;  return packet bytes ;   }  
public static void   ( final  string[] argv )  {  new  collect alignment summary metrics (  )  . instance main with exit ( argv )  ;   }  
@ override public void   (  )  {  for  (   scheduled thread pool executor e : new  array list <  scheduled thread pool executor >  ( pools . key set (  )  )  )   {  if  ( e . is shutdown (  )  )   {  pools . remove ( e )  ;   }  else  {  e . purge (  )  ;
@ override public boolean   (  )  {  return size (  )   =  =  0 ;   }  
  (  observer <  ?  super  notification < t >  >  actual )  {  this . actual = actual ;   }  
@ override public boolean   (  object o )  {  if  ( o  =  =  this )  return true ;  if  (  !  ( o instanceof  forward port )  )  return false ;   forward port f =  (  forward port ) o ;  return  ( f . name . equals ( name )  )  && f . isip6  =  =  isip6 &
private static void   (  string sam host int sam port  string con options )  {  test transfer ( sam host sam port con options )  ;   }  
void   (  switch map inner observer sender )  {  if  ( inner . compare and set ( sender null )  )   {  if  ( done )   {   throwable ex = errors . terminate (  )  ;  if  ( ex  =  =  null )   {  downstream . on complete (  )  ;   }  else  {  downstream . on error ( ex )  ;   }   }   }   }  
@ test public void   (  )  {   composite disposable cd = new  composite disposable (  )  ;   disposable d1 =  disposables . empty (  )  ;  assert false ( cd . delete ( d1 )  )  ;   disposable d2 =  disposables . empty (  )  ;  cd . add ( d2 )  ;  assert f
public  node affiliate   ( jid jid )  {   node affiliate node affiliate = add affiliation ( jid  node affiliate .  affiliation . outcast )  ;  remove subscriptions ( jid )  ;  return node affiliate ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
public int   (  )  {  return portb ;   }  
public  type   (  )  {  return  type . count ;   }  
private static  throwable   (  throwable ex )  {   throwable root = ex . get cause (  )  ;  if  ( root  =  =  null )   {  return null ;   }  else  {  while  ( true )   {  if  ( root . get cause (  )   =  =  null )   {  return root ;   }  else  {  root = root . get cause (  )  ;   }   }   }   }  
public void   ( final  packet packet )  {   system . out . println ( " received: "  +  packet . toxml (  )  )  ;  if  ( packet instanceof  jingle channeliq )   {  final  jingle channeliq request =  (  jingle channeliq ) packet ;  if  ( request . is request (  )  )   {  connection . send packet ( create udp channel ( request )  )  ;   }   }  else if  ( packet instanceof  jingle trackeriq )   {  final  jingle trackeriq iq =  (  jingle trackeriq ) packet ;  if  ( iq . is request (  )  )   {  final  jingle trackeriq result = create known nodes (  )  ;  result . set packetid ( packet . get packetid (  )  )  ;  result . set from ( packet . get to (  )  )  ;  result . set to ( packet . get from (  )  )  ;  connection . send packet ( result )  ;   }   }   }  
private void   (  http servlet request http request  servlet response servlet response )  {  final  http servlet response wrapper wrapped response = new  http servlet response wrapper (  (  http servlet response ) servlet response mutable passthrough )  ;  try  {  if  ( is response ok ( wrapped response )  )   {  container filter chain . do filter ( http request wrapped response )  ;   }  if  ( is response ok ( wrapped response )  )   {  router . route ( new  http servlet request wrapper ( http request )  wrapped response )  ;   }  split response headers ( wrapped response )  ;   }  catch  (   exception ex )   {  log . error ( " failure in filter within container filter chain .   reason: "  +  ex . get message (  )  ex )  ;  wrapped response . send error (  http servlet response . sc   internal   server   error )  ;   }  finally  {  wrapped response . commit to response (  )  ;   }   }  
private void   (  )  {  while  (  ( current iterator  =  =  null ||  ! current iterator . has next (  )  )  && this . intervals . has next (  )  )   {  if  ( current iterator  !  =  null )  current closeable iterator . close (  )  ;  final  interval interval = this . intervals . next (  )  ;  final  interval previous interval = this . last interval ;  this . current closeable iterator = this . reader . query ( interval . get contig (  )  interval . get start (  )  interval . get end (  )  )  ;  this . current iterator = this . current closeable iterator . stream (  )  . filter ( ctx  -  >  null  =  =  previous interval ||  ! overlaps interval ( ctx previous interval )  )  . iterator (  )  ;  this . last interval = interval ;   }   }  
public  interval   (  )  {  return new  interval ( contig (  )  start (  )  stop (  )  )  ;   }  
@ override public int   (  )  {  int result = local . hash code (  )  ;  result = 31 * result  +  remote . hash code (  )  ;  return result ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set fail on non blocking scheduler ( true )  ;   observable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  . map ( new  function <  integer  integer >  (  )  {  @ override public 
public  string   (  )  {  return " update  delivery  status" ;   }  
public  collection <  string >    (  string parent name )  {   object[] keys = properties . key set (  )  . to array (  )  ;   array list <  string >  results = new  array list <  string >  (  )  ;  for  ( int i = 0  n = keys . length ;  i  <  n ;  i +  +  )   {   string key =  (  string ) keys[i] ;  if  ( key . starts with ( parent name )  )   {  if  ( key . equals ( parent name )  )   {  continue ;   }  if  ( key . substring ( parent name . length (  )  )  . last index of ( " . " )   =  =  0 )   {  results . add ( properties . get ( key )  )  ;   }   }   }  return  collections . unmodifiable collection ( results )  ;   }  
public void   (  list <  macro group >  macro groups )  {  this . macro groups = macro groups ;   }  
public void   (  )  {  text iterator . close (  )  ;   }  
public static boolean   (  router context ctx  tunnel pool pool  pooled tunnel creator config cfg  build executor exec )  {  prepare ( ctx cfg )  ;  if  ( cfg . get length (  )   <  =  1 )   {  build zero hop ( ctx pool cfg exec )  ;  return true ;   }   log log = ctx . log manager (  )  . get log (  build requestor . class )  ;  cfg . set tunnel pool ( pool )  ;   tunnel info paired tunnel = null ;   hash far end = cfg . get far end (  )  ;   tunnel manager facade mgr = ctx . tunnel manager (  )  ;  boolean is inbound = pool . get settings (  )  . is inbound (  )  ;  if  ( pool . get settings (  )  . is exploratory (  )  ||  ! use paired tunnels ( ctx )  )   {  if  ( is inbound )  paired tunnel = mgr . select outbound exploratory tunnel ( far end )  ;  else paired tunnel = mgr . select inbound exploratory tunnel ( far end )  ;   }  else  {  if  ( is inbound )  paired tunnel = mgr . select outbound tunnel ( pool . get settings (  )  . get destination (  )  far end )  ;  else paired tunnel = mgr . select inbound tunnel ( pool . get settings (  )  . get destination (  )  far end )  ;  if  ( paired tunnel  =  =  null )   {  if  ( is inbound )   {  paired tunnel = mgr . select outbound tunnel (  )  ;  if  ( paired tunnel  !  =  null && paired tunnel . get length (  )   <  =  1 && mgr . get outbound settings (  )  . get length (  )   >  0 && mgr . get outbound settings (  )  . get length (  )   +  mgr . get outbound settings (  )  . get length variance (  )   >  0 )   {  paired tunnel = null ;   }   }  else  {  paired tunnel = mgr . select inbound tunnel (  )  ;  if  ( paired tunnel  !  =  null && paired tunnel . get length (  )   <  =  1 && mgr . get inbound settings (  )  . get length (  )   >  0 && mgr . get inbound settings (  )  . get length (  )   +  mgr . get inbound settings (  )  . get length variance (  )   >  0 )   {  paired tunnel = null ;   }   }  if  ( paired tunnel  !  =  null && log . should log (  log . info )  )  log . info ( " couldn't find a paired tunnel for "  +  cfg  +  "  using exploratory tunnel" )  ;   }   }  if  ( paired tunnel  =  =  null )   {  if  ( log . should log (  log . warn )  )  log . warn ( " tunnel build failed  as we couldn't find a paired tunnel for "  +  cfg )  ;  exec . build complete ( cfg pool )  ;  int ms = pool . get settings (  )  . is exploratory (  )   ?  250 : 25 ;  try  {   thread . sleep ( ms )  ;   }  catch  (   interrupted exception ie )   {   }  return false ;   }   tunnel build message msg = create tunnel build message ( ctx pool cfg paired tunnel exec )  ;  if  ( msg  =  =  null )   {  if  ( log . should log (  log . warn )  )  log . warn ( " tunnel build failed  as we couldn't create the tunnel build message for "  +  cfg )  ;  exec . build complete ( cfg pool )  ;  return false ;   }  if  ( cfg . is inbound (  )  )   {  if  ( log . should log (  log . info )  )  log . info ( " sending the tunnel build request "  +  msg . get unique id (  )   +  " out the tunnel " +  paired tunnel +  " to " +  cfg . get peer ( 0 )  +  " for " +  cfg +  " waiting for the reply of " +  cfg . get reply message id (  )  )  ;  ctx . tunnel dispatcher (  )  . dispatch outbound ( msg paired tunnel . get send tunnel id ( 0 )  cfg . get peer ( 0 )  )  ;   }  else  {  if  ( log . should log (  log . info )  )  log . info ( " sending the tunnel build request directly to "  +  cfg . get peer ( 1 )   +  " for " +  cfg +  " waiting for the reply of " +  cfg . get reply message id (  )  +  " with msg id = " +  msg . get unique id (  )  )  ;  msg . set message expiration ( ctx . clock (  )  . now (  )   +  build   msg   timeout  +  ctx . random (  )  . next long ( 20 * 1000 )  )  ;   router info peer = ctx . net db (  )  . lookup router info locally ( cfg . get peer ( 1 )  )  ;  if  ( peer  =  =  null )   {  if  ( log . should log (  log . warn )  )  log . warn ( " could not find the next hop to send the outbound request to: "  +  cfg )  ;  exec . build complete ( cfg pool )  ;  return false ;   }   out net message out msg = new  out net message ( ctx msg ctx . clock (  )  . now (  )   +  first   hop   timeout priority peer )  ;  out msg . set on failed send job ( new  tunnel build first hop fail job ( ctx pool cfg exec )  )  ;  ctx . out net message pool (  )  . add ( out msg )  ;   }  return true ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write safeutf ( out domain )  ;   externalizable util . get instance (  )  . write boolean ( out permission  !  =  null )  ;  if  ( permis
public   ( i2p app context context )  {  super ( context  message status message . message   type )  ;   }  
double   ( int ds index )  throws  rrd exception  {  return  util .  xml . get child value as double ( ds nodes[ds index] "max" )  ;   }  
double   ( int arc index int ds index )  throws  rrd exception  {   node cdp node =  util .  xml . get first child node ( arc nodes[arc index] "cdp   prep" )  ;   node[] ds nodes =  util .  xml . get child nodes ( cdp node "ds" )  ;  return  util .  xml . get child value as double ( ds nodes[ds index] "value" )  ;   }  
public void   (  hash dest  lease set set )  {  if  (    manager  !  =  null )     manager . request lease set ( dest set )  ;   }  
private final int   (  )  {  return    builders . size (  )  ;   }  
private void   (  reconfigure session message message )  {   session id id = message . get session id (  )  ;   session config cfg =    runner . get config ( id )  ;  if  ( cfg  =  =  null )   {   list <  session id >  current =    runner . get session ids (  )  ;   string msg = " reconfigure session invalid session: "  +  id  +  " current: " +  current ;  if  (    log . should log (  log . error )  )     log . error ( msg )  ;     runner . disconnect client ( msg )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " updating options  -  old: "  +  cfg  +  " new: " +  message . get session config (  )  )  ;  if  (  ! message . get session config (  )  . get destination (  )  . equals ( cfg . get destination (  )  )  )   {     log . error ( " dest mismatch" )  ;  send status message ( id  session status message . status   invalid )  ;     runner . stop running (  )  ;  return ;   }   hash dest = cfg . get destination (  )  . calculate hash (  )  ;  cfg . get options (  )  . put all ( message . get session config (  )  . get options (  )  )  ;   client tunnel settings settings = new  client tunnel settings ( dest )  ;   properties props = new  properties (  )  ;  props . put all ( cfg . get options (  )  )  ;  settings . read from properties ( props )  ;     context . tunnel manager (  )  . set inbound settings ( dest settings . get inbound settings (  )  )  ;     context . tunnel manager (  )  . set outbound settings ( dest settings . get outbound settings (  )  )  ;  send status message ( id  session status message . status   updated )  ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  open folder with message ( mock transport )  ;  try  {  mock transport . expect ( "uidl" " + ok sending uidl list" )  ;  mock transport . expect ( null "bad - data"  +  " "  +  "the - uidl" )  ;  mock transport . expect ( null " . " )  ;   message[] messages = m folder . get messages ( 1 1 null )  ;  fail ( " bad uidl should cause get messages (  )  to throw . " )  ;   }  catch  (   messaging exception me )   {   }  assert false ( "folder should be 'closed' after an io error" m folder . is open (  )  )  ;  check one unread ( mock transport )  ;   }  
@ override public int   (  )  {  int count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con = get connection (  )  ;  pstmt = con . prepare statement ( group countsql )  ;  rs = pstmt . execute quer
public static boolean   ( i2p app context ctx  news entry entry )  {   string id = entry . id ;  if  ( id  =  =  null )  return false ;   string name = id to name ( ctx id )  ;   file dir = new  file ( ctx . get config dir (  )  dir )  ;   file file = new  file ( dir name )  ;  return file . delete (  )  ;   }  
@ test public void   (  )  {  assert equals ( "http: /  / rackspacecloud . com / " tokenizer . get service root href (  )  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source1 =  publish subject . create (  )  ;   publish subject <  integer >  source2 =  publish subject . create (  )  ;   observable <  integer >  m =  observable . merge ( source1 . group join 
@ test ( expected =  null pointer exception . class )  public void   (  )  {   future task <  object >  f = new  future task <  object >  (  functions . empty   runnable null )  ;  f . run (  )  ;   single . from future ( f )  . blocking get (  )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ send message expires message: " )  ;  buf . append ( "\n\t session id: " )  . append (    session id )  ;  buf . append ( "\n\t nonce: " )  . append 
private void   (  )  throws  messaging exception  {  if  (  ! is open (  )  )   {  throw new  messaging exception ( " folder "  +  m name  +  " is not open . " )  ;   }   }  
@ test public void   (  )  {  for  ( int times = 0 ;  times  <  100 ;  times +  +  )   {  int observable count = 100 ;  int max concurrent = 2  +   ( times % 10 )  ;   atomic integer subscription count = new  atomic integer ( 0 )  ;   list <  flowable <  
@ override public int   (  )  {  return    socket . get local port (  )  ;   }  
public void   (  )  {  for  (   update task t :    downloaders . key set (  )  )   {  t . shutdown (  )  ;   }     downloaders . clear (  )  ;   }  
@ test public void   (  )  {   async subject <  object >  p =  async subject . create (  )  ;   disposable bs =  disposables . empty (  )  ;  p . on subscribe ( bs )  ;  assert false ( bs . is disposed (  )  )  ;  p . on complete (  )  ;  bs =  disposable
@ override public void   (  )  {  request ( 2 )  ;   }  
private void   (  string spoof host )  {     spoof host =  ( spoof host  !  =  null && spoof host . trim (  )  . length (  )   >  0 )   ?  spoof host . trim (  )  : null ;  get tunnel (  )  . get context (  )  . stat manager (  )  . create rate stat ( "i2ptunnel . httpserver . blocking handle time" "how long the blocking handle takes to complete" "i2p tunnel . http server" new long[] { 60 * 1000 10 * 60 * 1000 3 * 60 * 60* 1000 }  )  ;   }  
@ override public  single source <  boolean >    (  maybe <  object >  f )  throws  exception  {  return f . contains ( 1 )  ;   }  
public void   (  hash from )  {     from = from ;   }  
@ override public  object   (  string source  parse position pos )  {  return null ;   }  
@ benchmark public void   ( final  input thousand input )  throws  interrupted exception  {   flowable <  flowable <  integer >  >  os = input . observable . map ( new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable < 
public static void   (  object array[] )  {  for  ( int i = 0 ;  i  <  array . length  /  2 ;  i +  +  )   {   object temp = array[i] ;  array[i] = array[array . length  -  i  -  1] ;  array[array . length  -  i  -  1] = temp ;   }   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {   functions . to function ( new  function3 <  integer  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer t1   integer t2  
@ override public void   (  object notification lite )  {   timed node <  object >  n = new  timed node <  object >  ( notification lite  long . max   value )  ;   timed node <  object >  t = tail ;  tail = n ;  size +  +  ;  t . lazy set ( n )  ;  trim f
@ test public void   (  )  {   publish processor <  object >  other =  publish processor . create (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  atomic integer subscribed = new  atomic integer (  )  ;   flo
private void   ( boolean enable )  {   client app manager mgr =    context . client app manager (  )  ;  if  ( mgr  !  =  null )   {  try  {   client app dtg = mgr . get registered app ( "desktopgui" )  ;  if  ( dtg  !  =  null )   {  if  ( enable )   {  if  ( dtg . get state (  )   =  =   client app state . stopped )   {  dtg . startup (  )  ;  add form notice (    t ( " enabled system tray" )  )  ;   }   }  else  {  if  ( dtg . get state (  )   =  =   client app state . running )   {  dtg . shutdown ( null )  ;  add form notice (    t ( " disabled system tray" )  )  ;   }   }   }  else if  ( enable )   {  if  (  boolean . value of (  system . get property ( "java . awt . headless" )  )  )   {  add form error (    t ( " restart required to take effect" )  )  ;   }  else  {  dtg = new net . i2p . desktopgui .  main (    context mgr null )  ;  dtg . startup (  )  ;  add form notice (    t ( " enabled system tray" )  )  ;   }   }   }  catch  (   throwable t )   {  if  ( enable )  add form error (    t ( " failed to start systray" )   +  ": "  +  t )  ;  else add form error (    t ( " failed to stop systray" )   +  ": "  +  t )  ;   }   }  boolean saved =    context . router (  )  . save config (  router console runner . prop   dtg   enabled  boolean . to string ( enable )  )  ;  if  ( saved )  add form notice (    t ( " configuration saved successfully" )  )  ;  else add form error (    t ( " error saving the configuration  ( applied but not saved )   -  please see the error logs" )  )  ;   }  
public static  string   ( byte buf[] int len )  {  if  ( buf  =  =  null )  buf = empty   buffer ;   string builder out = new  string builder (  )  ;  if  ( len  >  buf . length )   {  for  ( int i = 0 ;  i  <  len  -  buf . length ;  i +  +  )  out . append ( "00" )  ;   }  int min =  math . min ( buf . length len )  ;  for  ( int i = 0 ;  i  <  min ;  i +  +  )   {  int bi = buf[i] & 0xff ;  if  ( bi  <  16 )  out . append ( '0' )  ;  out . append (  integer . to hex string ( bi )  )  ;   }  return out . to string (  )  ;   }  
private static  map <  string  host address >    (  string encoded value )  {   map <  string  host address >  answer = new  hash map <  >  (  )  ;   string tokenizer st = new  string tokenizer ( encoded value " {  }  :" )  ;  while  ( st . has more elements (  )  )   {   string key = st . next token (  )  ;  answer . put ( key new  host address ( st . next token (  )   integer . parse int ( st . next token (  )  )  )  )  ;   }  return answer ;   }  
public  node info   (  node info n info )  {   node info rv =    node map . put if absent ( n info . getnid (  )  n info )  ;  if  ( rv  !  =  null )     kad . add ( rv . getnid (  )  )  ;  else    kad . add ( n info . getnid (  )  )  ;  return rv ;   }  
@ override public int   (  )  {  return  ( int ) get delay seconds (  )   +  get delivery mode (  )   +   data helper . hash code ( get destination (  )  )  +   data helper . hash code ( get encryption key (  )  )  +   data helper . hash code ( get router
@ override public long   (  string prop name long default val )  {  if  (    router  !  =  null )   {   string val =    router . get config setting ( prop name )  ;  if  ( val  !  =  null )   {  long rv = default val ;  try  {  rv =  long . parse long ( v
public void   ( jid originating resource  presence presence )  {  presence . set to ( originating resource )  ;  routing table . route packet ( originating resource presence false )  ;  if  (  !  session manager . is other resource presence enabled (  )  )   {  return ;   }  jid searchjid = new jid ( originating resource . get node (  )  originating resource . get domain (  )  null )  ;   list < jid >  addresses = routing table . get routes ( searchjid null )  ;  for  (  jid address : addresses )   {  if  (  ! originating resource . equals ( address )  )   {  presence . set to ( address )  ;  routing table . route packet ( address presence false )  ;   }   }   }  
public   (  router context enclosing context )  {  super ( enclosing context )  ;   }  
public void   ( i2cp message msg )  throws  interrupted exception  {     out . put ( msg )  ;   }  
@ test public void   (  )  {   list <  tuple2 <  integer  string >  >  expected tuples = expected . map ( i  -  >  new  tuple2 <  >  ( i "t2"  +  i )  )  ;  java . util .  list <  tuple2 <  integer  string >  >  tuple projection = db rule . get shared han
public   (  observable source < t >  source long index )  {  this . source = source ;  this . index = index ;   }  
public void   ( int timeout )  {  if  (    log . should log (  log . debug )  )     log . debug ( " changing read timeout from "  +     read timeout  +  " to " +  timeout )  ;     read timeout = timeout ;   }  
@ override public boolean   (  object obj )  {  if  ( obj  =  =  null ||  !  ( obj instanceof  reply tunnel )  )  return false ;  return this . h . equals (  (  (  reply tunnel ) obj )  . h )  && this . id . equals (  (  (  reply tunnel ) obj )  . id )  ;
public  rate stat   (  )  {  return    stat ;   }  
private void   (  reply waiter waiter  list < be value >  error )  throws  invalidb encoding exception  {  int error code = error . get ( 0 )  . get int (  )  ;   string error string = error . get ( 1 )  . get string (  )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " rcvd error from: "  +  waiter  +  " num: " +  error code +  " msg: " +  error string )  ;  waiter . got reply ( error code error string )  ;   }  
@ override public  input stream   (  )  {  check not destroyed (  )  ;  try  {  return new  file input stream ( m file )  ;   }  catch  (   file not found exception e )   {   log utils . w (  logging . log   tag " imap temp file literal:  temp file not fo
static void   ( sq lite database db int old version int new version )  {  try  {  db . execsql ( "drop table "  +   attachment . table   name )  ;   }  catch  (  sql exception e )   {   }  create attachment table ( db )  ;   }  
private void   ( iq request packet  collection <  roster item >  items  string subdomain )  {  iq response = iq . create resultiq ( request packet )  ;  response . set to ( subdomain )  ;   element query = new  default element ( q name . get ( "query" "jabber:iq:roster" )  )  ;  for  (   roster item i : items )   {   string jid = i . get jid (  )  . to string (  )  ;  if  (  ! jid . equals ( subdomain )  && jid . contains ( subdomain )  )   {   log . debug ( " roster exchange for external component "  +  subdomain  +  " .   sending user " +  i . get jid (  )  . to string (  )  )  ;   element item = new  default element ( "item" null )  ;  item . add ( new  default attribute ( "jid" i . get jid (  )  . to string (  )  )  )  ;  item . add ( new  default attribute ( "name" i . get nickname (  )  )  )  ;  item . add ( new  default attribute ( "subscription" "both" )  )  ;  for  (   string s : i . get groups (  )  )   {   element group = new  default element ( "group" )  ;  group . set text ( s )  ;  item . add ( group )  ;   }  query . add ( item )  ;   }   }  response . set child element ( query )  ;  dispatch packet ( response )  ;   }  
private   (  string conference id  string media preference  string display name )  throws  socket exception  {  this . conference id = conference id ;  member list = new  array list (  )  ;  try  {  set media info ( media preference )  ;   }  catch  (   parse exception e )   {   logger . println ( conference id  +  ":  can't set meeting media setting to "  +  media preference +  ": " +  e . get message (  )  )  ;   }  this . display name = display name ;  if  ( use single sender  =  =  true )   {  if  ( lone conference sender  =  =  null )   {  lone conference sender = new  conference sender ( conference list )  ;   }  conference sender = lone conference sender ;   }  else  {  conference sender = new  conference sender ( this )  ;   }  if  ( lone receiver port  !  =  0 )   {  if  ( lone conference receiver  =  =  null )   {  lone conference receiver = new  conference receiver ( " singleton" lone receiver port )  ;   }  conference receiver = lone conference receiver ;   }  else  {  conference receiver = new  conference receiver ( conference id 0 )  ;   }   }  
@ override public void   (  )  {  health check service proxy . deregister (  )  ;  log . info ( " {  } : {  }   -  -   destroying  power filter bean" cluster id node id )  ;  event service . squelch ( application deployment listener  application deploymen
private  histogram <  integer >    (  )  {  final  histogram <  double >  cvs = new  histogram <  double >  (  )  ;  final  histogram <  double >  five prime skews = new  histogram <  double >  (  )  ;  final  histogram <  double >  three prime skews = new  histogram <  double >  (  )  ;  final  histogram <  double >  gap bases per kb = new  histogram <  double >  (  )  ;  final  histogram <  double >  five to three skews = new  histogram <  double >  (  )  ;   string prefix = null ;  if  ( this . metrics . read   group  !  =  null )   {  prefix = this . metrics . read   group  +  " . " ;   }  else if  ( this . metrics . library  !  =  null )   {  prefix = this . metrics . library  +  " . " ;   }  else if  ( this . metrics . sample  !  =  null )   {  prefix = this . metrics . sample  +  " . " ;   }  else  {  prefix = " all    reads . " ;   }  final  histogram <  integer >  normalized coverage by normalized position = new  histogram <  integer >  ( "normalized   position" prefix  +  "normalized   coverage" )  ;  final  map <  gene .  transcript int[] >  transcripts = pick transcripts ( coverage by transcript )  ;  final double transcript count = transcripts . size (  )  ;  for  (  final  map .  entry <  gene .  transcript int[] >  entry : transcripts . entry set (  )  )   {  final  gene .  transcript tx = entry . get key (  )  ;  final double[] coverage ;   {  final double[] tmp =  math util . promote ( entry . get value (  )  )  ;  if  ( tx . get gene (  )  . is positive strand (  )  )  coverage = tmp ;  else coverage = copy and reverse ( tmp )  ;   }  final double mean =  math util . mean ( coverage 0 coverage . length )  ;  final double stdev =  math util . stddev ( coverage 0 coverage . length mean )  ;  final double cv = stdev  /  mean ;  cvs . increment ( cv )  ;   {  final int prime   bases = 100 ;  final double five prime coverage =  math util . mean ( coverage 0 prime   bases )  ;  final double three prime coverage =  math util . mean ( coverage coverage . length  -  prime   bases coverage . length )  ;  five prime skews . increment ( five prime coverage  /  mean )  ;  three prime skews . increment ( three prime coverage  /  mean )  ;  five to three skews . increment (  math util . divide ( five prime coverage three prime coverage )  )  ;   }   {  final int last index = coverage . length  -  1 ;  for  ( int percent = 0 ;  percent  <  =  100 ;   +  + percent )   {  final double p = percent  /  100d ;  final int start =  ( int )  math . max ( 0 last index *  ( p  -  0 . 005 )  )  ;  final int end =  ( int )  math . min ( last index last index *  ( p  +  0 . 005 )  )  ;  final int length = end  -  start  +  1 ;  double sum = 0 ;  for  ( int i = start ;  i  <  =  end ;   +  + i )  sum +  = coverage[i] ;  final double normalized =  ( sum  /  length )   /  mean ;  normalized coverage by normalized position . increment ( percent normalized  /  transcript count )  ;   }   }   }  this . metrics . median   cv   coverage = cvs . get median (  )  ;  this . metrics . median   5prime   bias = five prime skews . get median (  )  ;  this . metrics . median   3prime   bias = three prime skews . get median (  )  ;  this . metrics . median   5prime   to   3prime   bias = five to three skews . get median (  )  ;  return normalized coverage by normalized position ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  observable . empty (  )   observable . concat array delay error (  )  )  ;   }  
public  mix data source   (  )  {  return mix data source ;   }  
@ test public void   (  )  {   flowable <  integer >  src =  flowable . just ( 1 2 42 5 3 1 )  ;  src . skip while ( less   than   five )  . subscribe ( w )  ;   in order in order = in order ( w )  ;  in order . verify ( w never (  )  )  . on next ( any i
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber <  integer >  ts = pp . parallel ( 1 ) 
public void   (  )  {   string result1 =  mime utility . fold and encode2 ( short   supplemental " subject: " . length (  )  )  ;   string result2 =  mime utility . fold and encode2 ( long   supplemental " subject: " . length (  )  )  ;   string result3 =  mime utility . fold and encode2 ( long   supplemental   2 " subject: " . length (  )  )  ;  assert equals ( "short supplemental" short   supplemental   encoded result1 )  ;  assert equals ( "long supplemental" long   supplemental   encoded result2 )  ;  assert equals ( "long supplemental 2" long   supplemental   encoded   2 result3 )  ;   }  
@ override public void   ( final long message id final int response )  throws  remote exception  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m service . send meeting response ( message id response )
private void   (  eddsa private key priv key )  {  int b = priv key . get params (  )  . get curve (  )  . get field (  )  . getb (  )  ;  digest . update ( priv key . geth (  )  b  /  8 b  /  4  -  b  /  8 )  ;   }  
@ deprecated public  selectable channel   (  )  {  return null ;   }  
@ test public void   (  )  {   atomic reference <  throwable >  on error = new  atomic reference <  throwable >  (  )  ;  try  {   safe observer <  string >  safe observer = new  safe observer <  string >  ( observer   onnext   fail ( on error )  )  ;  sa
@ override public void   ( t t )  {  value = t ;   }  
@ override public boolean   (  )  {  return is closed ;   }  
public  service client response   (  string uri  map <  string  string >  headers  string body  media type content media type )  {   http post post = new  http post ( uri )  ;   map <  string  string >  request headers = new  hash map <  >  (  )  ;  request headers . put all ( headers )  ;   string local content type = content media type . get type (  )   +  " / "  +  content media type . get subtype (  )  ;  request headers . put (  http headers . content   type local content type )  ;  if  (  ! request headers . contains key (  http headers . accept )  )   {  request headers . put (  http headers . accept  media type . application   xml )  ;   }  set headers ( post request headers )  ;  if  ( body  !  =  null &&  ! body . is empty (  )  )   {  post . set entity ( new  input stream entity ( new  byte array input stream ( body . get bytes (  )  )  body . length (  )  )  )  ;   }  return execute ( post )  ;   }  
public void   (  string id double attenuation )  throws  parse exception  {  synchronized  ( whisper groups )   {   whisper group whisper group = find whisper group ( id )  ;  if  ( whisper group  =  =  null )   {   logger . println ( " whisper group "  +  id  +  " doesn't exist" )  ;  throw new  parse exception ( " whisper group "  +  id  +  " doesn't exist" 0 )  ;   }  whisper group . set attenuation ( attenuation )  ;   }   }  
@ override public void   (  )  {  try  {   presence presence = get room (  )  . update occupant ( this )  ;  if  ( presence  !  =  null )   {  answer = presence . get element (  )  ;   }   }  catch  (   not allowed exception e )   {   }   }  
public  locale   (  )  {  return m locale ;   }  
public  el gamal parameter spec   (  )  {  return spec ;   }  
public void   ( iq iq  string sessionid )  {  final iq reply = iq . create resultiq ( iq )  ;   string transcriptxml = null ;  try  {   element transcript = reply . set child element ( "transcript" "http: /  / jivesoftware . com / protocol / workgroup" )  ;  transcript . add attribute ( "sessionid" sessionid )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   transcript )  ;  pstmt . set string ( 1 sessionid )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  transcriptxml =  db connection manager . get large text field ( rs 1 )  ;   }   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  if  ( transcriptxml  !  =  null )   {   document element =  document helper . parse text ( transcriptxml )  ;  for  (  iterator <  element >  it = element . get root element (  )  . element iterator (  )  ;  it . has next (  )  ;   )   {   element packet = it . next (  )  ;  transcript . add ( packet . create copy (  )  )  ;   }   }  workgroup . send ( reply )  ;   }  catch  (   exception ex )   {   log . error ( " there was an error retrieving the following transcript .   sessionid  =  "  +  sessionid  +  "  transcript = " +  transcriptxml ex )  ;  reply . set child element ( iq . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  workgroup . send ( reply )  ;   }   }  
void   (  )  {  if  ( once . compare and set ( false true )  )   {  parent . emit ( index value )  ;   }   }  
@ override protected  position info   (  )  {  final byte x byte = byte iterator . next (  )  ;  final byte y byte = byte iterator . next (  )  ;  final float x pos =  unsigned type util . u byte to int ( x byte )   /  10f  +  x offset ;  final float y po
public double   ( int index )  throws io exception  {  int array index =  ( pointer . get (  )   +  index )  % rows ;  return values . get ( array index )  ;   }  
public   (  flowable < t >  source  publisher < u >  first timeout indicator  function <  ?  super t  ?  extends  publisher < v >  >  item timeout indicator  publisher <  ?  extends t >  other )  {  super ( source )  ;  this . first timeout indicator = first timeout indicator ;  this . item timeout indicator = item timeout indicator ;  this . other = other ;   }  
@ override public void   (  )  {  us . subscribe ( ts2 )  ;   }  
  (  concat map single subscriber <  ?  r >  parent )  {  this . parent = parent ;   }  
@ override public void   (  observer <  ?  super t >  t )  {  source . subscribe ( new  do on each observer < t >  ( t on next on error on complete on after terminate )  )  ;   }  
public int[]   (  )  {  int[] cycles = new int[total cycles] ;  int cycle index = 0 ;  for  (  final  range range : cycle index ranges )   {  for  ( int i = range . start ;  i  <  =  range . end ;  i +  +  )   {  cycles[cycle index +  + ] = i  +  1 ;   }   }  return cycles ;   }  
public   (  )  {  try  {  manager =  crowd manager . get instance (  )  ;   }  catch  (   exception e )   {  log . error ( " failure to load the  crowd manager" e )  ;   }   }  
private int   ( final int ref start final int block length final int idx final boolean is negative )  {  return is negative  ?  ref start  +   ( block length  -  1 )   -  idx  -  1 : ref start  +  idx ;   }  
private static void   (  http servlet response response byte[] image data  string content type )  throws io exception  {   servlet output stream os = response . get output stream (  )  ;  response . set content type ( content type )  ;  os . write ( image data )  ;  os . flush (  )  ;  os . close (  )  ;   }  
@ test public void   (  )  throws  exception  {  try  (  input stream in = get class (  )  . get resource as stream ( " / org / jivesoftware / admin /  admin console test . admin - sidebar - 02 . xml" )  )  {   admin console . add model ( "test2" in )  ; 
@ test public void   (  )  {   single . zip (  single . just ( 1 )   single . just ( 2 )   single . just ( 3 )   single . just ( 4 )   single . just ( 5 )   single . just ( 6 )   single . just ( 7 )   single . just ( 8 )   single . just ( 9 )  new  functi
public i2np message   (  )  {  return    msg ;   }  
public synchronized  list <  string >    (  )  {   list <  string >  msgs = new  array list <  string >  (  )  ;     controllers lock . read lock (  )  . lock (  )  ;  try  {  for  ( int i = 0 ;  i  <     controllers . size (  )  ;  i +  +  )   {   tunnel controller controller =    controllers . get ( i )  ;  controller . stop tunnel (  )  ;  msgs . add all ( controller . clear messages (  )  )  ;   }  if  (    log . should log (  log . info )  )     log . info (    controllers . size (  )   +  " controllers stopped" )  ;   }  finally  {     controllers lock . read lock (  )  . unlock (  )  ;   }  return msgs ;   }  
public void   (  date date range max )  {  this . date range max = date range max ;   }  
@ override public void   (  throwable t )  {  parent . inner error ( this t )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  maybe . empty (  )   (  (  has upstream maybe source <  object >  )  (  maybe . empty (  )  . contains ( 0 )  )  )  . source (  )  )  ;   }  
@ override public void   ( long n )  {   subscription helper . deferred request ( this requested n )  ;   }  
@ override public void   (  context context  intent intent )  {   email broadcast processor service . process device policy message ( context device   admin   message   enabled )  ;   }  
@ test ( timeout = 2000 )  public void   (  )  {   observable <  long >  source =  observable . interval ( 40 40  time unit . milliseconds scheduler )  ;   observable <  list <  long >  >  result = source . buffer ( 100  time unit . milliseconds scheduler
@ test public void   (  )  {  final  map <  integer  file >  filters = new  hash map <  >  (  )  ;  filters . put ( 1101 tile   1101   filter )  ;  final  locs file reader locs file reader = new  locs file reader ( new  file ( "testdata / picard / illumin
@ override public  input stream   (  message envelope message envelope )  {   byte array output stream output stream = new  byte array output stream (  )  ;  try  {  jaxb context jaxb context = jaxb context . new instance ( "org . openrepose . core . http
public  optional <  repose cluster >    (  system model system model )  {  for  (   repose cluster cluster : system model . get repose cluster (  )  )   {  if  ( cluster . get id (  )  . equals ( cluster id )  && get local node ( cluster )  . is present (  )  )   {  return  optional . of ( cluster )  ;   }   }  return  optional . empty (  )  ;   }  
public   (  )  {  super ( " email intent service" )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
public int   (  )  {  return this . length ;   }  
@ test public void   (  )  {  final  atomic reference <  flowable <  integer >  >  ref = new  atomic reference <  flowable <  integer >  >  (  )  ;   flowable . range ( 1 5 )  . publish ( new  function <  flowable <  integer >   publisher <  integer >  > 
@ override public t   ( int index )  {  t v = list . remove ( index )  ;  lazy set ( list . size (  )  )  ;  return v ;   }  
public  list <  string >    (  string stat group )  {  return multi stat groups . get ( stat group )  ;   }  
public void   (  job job )  {     on failed send = job ;   }  
@ override public void   ( sa mv3 handler handler boolean verbose )  throws sam exception  {  throw new sam exception ( "master session" )  ;   }  
@ test public void   (  )  throws  exception  {   lease lease = new  lease (  )  ;  lease . set end date ( new  date ( 1000 * 60 * 2 )  )  ;  byte h[] = new byte[ hash . hash   length] ;  lease . set gateway ( null )  ;   structure test tst = new  tunnel 
@ override public void   (  )  {  throw new  runtime exception (  )  ;   }  
private boolean   ( long objectid  object data )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( delete   queue )  ;  if  (  (  boolean ) data )   {  pstmt . set int ( 1 group   type )  ;   }  else  {  pstmt . set int ( 1 agent   type )  ;   }  pstmt . set long ( 2 objectid )  ;  pstmt . set long ( 3 id )  ;  pstmt . execute update (  )  ;  return true ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return false ;   }  
@ override public  column mappers   (  )  {  return new  column mappers ( this )  ;   }  
public   (  flowable < t >  source  scheduler scheduler boolean delay error int prefetch )  {  super ( source )  ;  this . scheduler = scheduler ;  this . delay error = delay error ;  this . prefetch = prefetch ;   }  
public  < t >  socket channel   (  socket option < t >  name t value )  {  return this ;   }  
public t[]   ( t[] array )  {  t v = get value (  )  ;  if  ( v  =  =  null )   {  if  ( array . length  !  =  0 )   {  array[0] = null ;   }  return array ;   }  if  ( array . length  =  =  0 )   {  array =  arrays . copy of ( array 1 )  ;   }  array[0] = v ;  if  ( array . length  !  =  1 )   {  array[1] = null ;   }  return array ;   }  
@ override public  integer   (  integer a  integer b )  throws  exception  {  return a  +  b ;   }  
@ suppress warnings (  { "rawtypes" "unchecked" }  )  @ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;   flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  
private   (  context context  setup data fragment setup data boolean settings mode )  {  super ( context )  ;  m setup data = setup data ;  m settings mode = settings mode ;   }  
@delete @ path ( " /  { room name } " )  public  response   ( @ path param ( "room name" )   string room name @ default value ( "conference" )  @ query param ( "servicename" )   string service name )  throws  service exception  {  muc room controller . ge
@ override public  iterator <  flowable <  object >  >    (  )  {  return null ;   }  
@ override public void   (  handle handle  string savepoint name )  {  throw new  unsupported operation exception ( " savepoints not supported" )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  @ backpressure support (  backpressure kind . full )  @ experimental public final  completable   (  function <  ?  super t  ?  extends  completable source >  mapper int prefetch )  { 
@ test public void   (  )  {   behavior processor <  integer >  bp =  behavior processor . create (  )  ;  bp . on next ( 1 )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  behavior subscription <  integer >  bs
@ override public void   (  throwable e )  {  thrown . set ( e )  ;   }  
public  string   (  )  {  if  (    helper  =  =  null )  return "" ;   string builder buf = new  string builder ( 512 )  ;  buf . append ( " < h3 >  < a href = \" / peers\" target = \"   top\" title = \"" )  . append (    t ( " show all current peer connections" )  )  . append ( "\" > " )  . append (    t ( " peers" )  )  . append ( " <  / a >  <  / h3 >  < hr class = \"b\" > \n"  +  " < table id = \"sb   peers\" > \n"  +  " < tr title = \"" )  . append (    t ( " peers we've been talking to in the last few minutes / last hour" )  )  . append ( "\" > "  +  " < td align = \"left\" >  < b > " )  . append (    t ( " active" )  )  . append ( ": <  / b >  <  / td >  < td align = \"right\" > " )  ;  int active =    helper . get active peers (  )  ;  buf . append ( active )  . append (  summary helper . thinsp )  . append (  math . max ( active    helper . get active profiles (  )  )  )  . append ( " <  / td >  <  / tr > \n"  +  " < tr title = \"" )  . append (    t ( " the number of peers available for building client tunnels" )  )  . append ( "\" > "  +  " < td align = \"left\" >  < b > " )  . append (    t ( " fast" )  )  . append ( ": <  / b >  <  / td >  < td align = \"right\" > " )  . append (    helper . get fast peers (  )  )  . append ( " <  / td >  <  / tr > \n"  +  " < tr title = \"" )  . append (    t ( " the number of peers available for building exploratory tunnels" )  )  . append ( "\" > "  +  " < td align = \"left\" >  < b > " )  . append (    t ( " high capacity" )  )  . append ( ": <  / b >  <  / td >  < td align = \"right\" > " )  . append (    helper . get high capacity peers (  )  )  . append ( " <  / td >  <  / tr > \n"  +  " < tr title = \"" )  . append (    t ( " the number of peers available for network database inquiries" )  )  . append ( "\" > "  +  " < td align = \"left\" >  < b > " )  . append (    t ( " integrated" )  )  . append ( ": <  / b >  <  / td >  < td align = \"right\" > " )  . append (    helper . get well integrated peers (  )  )  . append ( " <  / td >  <  / tr > \n"  +  " < tr title = \"" )  . append (    t ( " the total number of peers in our network database" )  )  . append ( "\" > "  +  " < td align = \"left\" >  < b > " )  . append (    t ( " known" )  )  . append ( ": <  / b >  <  / td >  < td align = \"right\" > " )  . append (    helper . get all peers (  )  )  . append ( " <  / td >  <  / tr > \n"  +  " <  / table > \n" )  ;  return buf . to string (  )  ;   }  
public static  < t r > void   (  function <  observable < t >   ?  extends  single source < r >  >  transform )  {   list <  throwable >  errors = track plugin errors (  )  ;  try  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   observable < t >  source = new  observable < t >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super t >  observer )  {  try  {   disposable d1 =  disposables . empty (  )  ;  observer . on subscribe ( d1 )  ;   disposable d2 =  disposables . empty (  )  ;  observer . on subscribe ( d2 )  ;  b[0] = d1 . is disposed (  )  ;  b[1] = d2 . is disposed (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }   }   ;   single source < r >  out = transform . apply ( source )  ;  out . subscribe (  no op consumer . instance )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " first disposed ? " false b[0] )  ;  assert equals ( " second not disposed ? " true b[1] )  ;  assert error ( errors 0  illegal state exception . class " disposable already set ! " )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  finally  {   rx java plugins . reset (  )  ;   }   }  
public   (  single source < t >  source  function <  ?  super t  ?  extends  completable source >  mapper )  {  this . source = source ;  this . mapper = mapper ;   }  
@ override public  string   (  )  {  return "[ mailbox "  +  m id  +  ": " +  m display name +  "]" ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . repeat when ( new  function <  observable <  object >   observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   observable <  object >  
@ override public void   (  socket address endpoint int backlog )  {  throw new  unsupported operation exception (  )  ;   }  
boolean   (  hash h )  {  int num tunnels = this . context . tunnel manager (  )  . get participating count (  )  ;  int limit =  math . max ( min   limit  math . min ( max   limit num tunnels * percent   limit  /  100 )  )  ;  return this . counter . increment ( h )   >  limit ;   }  
private void   ( byte message[] int payload offset int payload length )  {     message = message ;     payload begin offset = payload offset ;     payload length = payload length ;   }  
@ override public int   ( byte source[] int offset )  throws  data format exception  {  throw new  runtime exception ( " data already set" )  ;   }  
@ override public  string   (  )  {  return "oes "  +     remote host id  +  ' ' +     current state ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  h . create update ( "insert into something  ( id  name )  v
private static long   (  )  {  return  system . current time millis (  )  ;   }  
@ override public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write serializable ( out  (  default element ) presence . get element (  )  )  ;   externalizable util 
@ test public void   (  )  {   flowable <  integer >  on next =  flowable . from iterable (  arrays . as list ( 1 2 3 )  )  ;   flowable <  integer >  on complete =  flowable . from iterable (  arrays . as list ( 4 )  )  ;   flowable <  integer >  on erro
@ test public void   (  )  {  final  file indel output file = new  file ( output   data   path "split - vcfs - test - indels - delete - me . vcf" )  ;  final  file snp output file = new  file ( output   data   path "split - vcfs - test - snps - delete - m
public void   (  session session  date logoff date )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con = get connection (  )  ;  pstmt = con . prepare statement ( set   offline )  ;  pstmt . set string ( 1 session . get address (  )  . get node (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( " unable to update user status for "  +  session . get address (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
@ override public  extensions   (  )  {  return new  extensions ( this )  ;   }  
public synchronized  exception   (  )  {  return this . exception ;   }  
@ non null @ override public  worker   (  )  {  return new  scheduled worker ( executor . get (  )  )  ;   }  
@ override public int   ( int m )  {  return 0 ;   }  
private  string   (  )  {   string builder sb = new  string builder ( 200 )  ;  sb . append ( " <  ? xml version = '1 . 0' encoding = '" )  ;  sb . append ( charset )  ;  sb . append ( "' ?  > " )  ;  if  ( socket reader . connection . is flash client (  )  )   {  sb . append ( " < flash:stream xmlns:flash = \"http: /  / www . jabber . com / streams / flash\" " )  ;   }  else  {  sb . append ( " < stream:stream " )  ;   }  sb . append ( "xmlns:stream = \"http: /  / etherx . jabber . org / streams\" xmlns = \"" )  ;  sb . append ( socket reader . get namespace (  )  )  . append ( '\"' )  ;  if  ( socket reader . get extra namespaces (  )   !  =  null )   {  sb . append ( ' ' )  ;  sb . append ( socket reader . get extra namespaces (  )  )  ;   }  sb . append ( " from = \"" )  ;  sb . append ( socket reader . session . get server name (  )  )  ;  sb . append ( "\" id = \"" )  ;  sb . append ( socket reader . session . get streamid (  )  . to string (  )  )  ;  sb . append ( "\" xml:lang = \"" )  ;  sb . append ( socket reader . session . get language (  )  . to language tag (  )  )  ;  sb . append ( "\" version = \"" )  ;  sb . append (  session . major   version )  . append ( ' . ' )  . append (  session . minor   version )  ;  sb . append ( "\" > " )  ;  return sb . to string (  )  ;   }  
@ test public void   (  )  {  test helper ( "group   same   coord . sam" "diff   coords . sam" 0 5 0 0 0 0 0 false )  ;   }  
private static final int   ( int a int b )  {  return  ( a  !  =  0 && b  !  =  0 )   ?     alog[ (    log[a & 0xff]  +     log[b & 0xff] )  % 255] : 0 ;   }  
private iq   (  object object iq iq boolean flag )  {   log . info ( " rayo component handle on off speaker command" )  ;  iq reply = iq . create resultiq ( iq )  ;   string call id = iq . get to (  )  . get node (  )  ;   string speaker id = jid . escape node ( iq . get from (  )  . to barejid (  )   +  " / speaker" )  ;   call handler call handler =  call handler . find call ( call id )  ;   call handler spkr handler =  call handler . find call ( speaker id )  ;  if  ( call handler  !  =  null )   {  if  ( spkr handler  !  =  null )   {   log . info ( " rayo component handle on off speaker command  found call "  +  call id )  ;  bridge mixers ( spkr handler call handler flag iq . get from (  )  )  ;   }   }  else  {   conference manager cm =  conference manager . get conference ( call id "pcmu / 8000 / 1" call id false )  ;  if  ( spkr handler  !  =  null )   {   log . info ( " rayo component handle on off speaker command  found conference "  +  call id )  ;   call participant sp = spkr handler . get call participant (  )  ;   string spkr mixer = sp . get conference id (  )  ;   string call mixer = call id ;  bridge mixers ( spkr mixer speaker id call mixer call id flag iq . get from (  )  )  ;   }   }  return reply ;   }  
private void   (  )  {  final  set <  fastq writer >  fastq writers = new  hash set <  >  (  )  ;  fastq writers . add ( first of pair )  ;  fastq writers . add ( unpaired )  ;  if  ( second of pair . is initialized (  )  )   {  fastq writers . add ( second of pair . get (  )  )  ;   }  for  (  final  fastq writer fastq writer : fastq writers )   {  fastq writer . close (  )  ;   }   }  
@ setup public void   (  )  {   integer[] array = new  integer[times] ;   arrays . fill ( array 777 )  ;  final  iterable <  integer >  list =  arrays . as list ( 1 2 )  ;  flowable =  flowable . from array ( array )  . flat map iterable ( new  function <
@ override protected void   (  completable observer s )  {  try  {   completable observer sw = on lift . apply ( s )  ;  source . subscribe ( sw )  ;   }  catch  (   null pointer exception ex )   {  throw ex ;   }  catch  (   throwable ex )   {   exceptio
@ test public void   (  )  {  io exception expected exception = new io exception ( "fake exception" )  ;   flowable <  string >  flowable1 = create flowable ( new  string[] {  }  2000 new io exception ( "fake exception" )  )  ;   flowable <  string >  flo
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . from iterable ( null )  ;   }  
public   ( byte[] nodeid  streamid streamid )  {  super ( nodeid null )  ;  this . streamid = streamid ;   }  
public synchronized  session key   (  )  {  return    mac key ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . range ( 1 5 )  . buffer ( 1  time unit . days  schedulers . single (  )  )  )  ;   test helper . check disposed (  observable . range ( 1 5 )  . buffer ( 2 1  time unit . days  sc
@ override void   (  )  {  long time limit = scheduler . now ( unit )   -  max age ;   node prev = get (  )  ;   node next = prev . get (  )  ;  int e = 0 ;  for  (  ;   ;   )   {  if  ( next  !  =  null )   {  if  ( size  >  limit )   {  e +  +  ;  size 
@ test public void   (  )  {   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  int num retries = 2 ;   flowable <  string >  origin =  flowable . unsafe create ( new  func with errors ( num retries )  )  ;  origin . retry when (
private static void   (  set <  string >  a )  {  if  ( a . is empty (  )  )   {   system . out . println ( "none" )  ;   }  else  {  for  (   string s : a )   {   system . out . println ( s )  ;   }   }   }  
@ override public int   (  )  {  return  objects . hash ( value )  ;   }  
@ test public void   (  )  {   single subject <  integer >  ss =  single subject . create (  )  ;  assert false ( ss . has value (  )  )  ;  assert null ( ss . get value (  )  )  ;  assert false ( ss . has throwable (  )  )  ;  assert null ( ss . get thro
@ test ( expected =  null pointer exception . class )  public void   (  )  {  error . repeat until ( null )  ;   }  
public boolean   (  )  {  return restart needed ;   }  
protected static  list <  string >    (  tunnel controller group tcg int tunnel  tunnel config config )  {   tunnel controller cur = get controller ( tcg tunnel )  ;   properties props = config . get config (  )  ;   list <  string >  msgs = new  array list <  string >  (  )  ;   string type = props . get property (  tunnel controller . prop   type )  ;  if  (  tunnel controller . type   std   client . equals ( type )  ||  tunnel controller . type   irc   client . equals ( type )  )   {  if  (  boolean . parse boolean ( props . get property ( opt  +  i2p tunnel client base . prop   use   ssl )  )  )   {   string intfc = props . get property (  tunnel controller . prop   intfc )  ;   set <  string >  alt names = new  hash set <  string >  ( 4 )  ;  if  ( intfc  !  =  null &&  ! intfc . equals ( "0 . 0 . 0 . 0" )  &&  ! intfc . equals ( "::" )  &&  ! intfc . equals ( "0:0:0:0:0:0:0:0" )  )  alt names . add ( intfc )  ;   string tgts = props . get property (  tunnel controller . prop   dest )  ;  if  ( tgts  !  =  null )   {  alt names . add ( intfc )  ;   string[] hosts =  data helper . split ( tgts "[  ]" )  ;  for  (   string h : hosts )   {  int colon = h . index of ( ':' )  ;  if  ( colon  >  =  0 )  h = h . substring ( 0 colon )  ;  alt names . add ( h )  ;  if  (  ! h . ends with ( " . b32 . i2p" )  )   {   hash hash =  convert to hash . get hash ( h )  ;  if  ( hash  !  =  null )  alt names . add ( hash . to base32 (  )  )  ;   }   }   }  try  {  boolean created = ssl client util . verify key store ( props opt alt names )  ;  if  ( created )   {   string name = props . get property (  tunnel controller . prop   name "" )  ;  msgs . add ( " created new self - signed certificate for tunnel "  +  name )  ;   }   }  catch  (  io exception ioe )   {  msgs . add ( " failed to create new self - signed certificate for tunnel "  +  get tunnel name ( tcg tunnel )   +  "  check logs: " +  ioe )  ;   }   }   }  if  ( cur  =  =  null )   {  cur = new  tunnel controller ( props "" true )  ;  tcg . add controller ( cur )  ;  if  ( cur . get start on load (  )  )  cur . start tunnel background (  )  ;   }  else  {  cur . set config ( props "" )  ;   }  if  (  boolean . parse boolean ( cur . get shared client (  )  )  &&  tunnel controller . is client ( cur . get type (  )  )  )   {   list <  tunnel controller >  controllers = tcg . get controllers (  )  ;  for  ( int i = 0 ;  i  <  controllers . size (  )  ;  i +  +  )   {   tunnel controller c = controllers . get ( i )  ;  if  ( c  =  =  cur )  continue ;  if  (  boolean . parse boolean ( c . get shared client (  )  )  &&  tunnel controller . is client ( c . get type (  )  )  )   {   properties c opt = c . get config ( "" )  ;  config . update tunnel quantities ( c opt )  ;  c opt . set property ( "option . inbound . nickname"  tunnel config . shared   client   nickname )  ;  c opt . set property ( "option . outbound . nickname"  tunnel config . shared   client   nickname )  ;  c . set config ( c opt "" )  ;   }   }   }  return msgs ;   }  
@ test public void   (  )  {   maybe subject <  integer >  ms =  maybe subject . create (  )  ;   disposable d =  disposables . empty (  )  ;  ms . on subscribe ( d )  ;  assert false ( d . is disposed (  )  )  ;  ms . on complete (  )  ;  d =  disposable
public  string[]   (  map <  string  ?  >  props )  {  final  set <  string >  result = get mechanism names set ( props )  ;  return result . to array ( new  string[result . size (  ) ] )  ;   }  
@ override public void   ( jid jid  string message )  {  try  {  yahoo session . send message ( get transport (  )  . convertjid toid ( jid )  message )  ;   }  catch  (  io exception e )   {   log . debug ( " failed to send message to yahoo user . " )  ;
private int[]   ( byte[] read int number of hashes int skipped bases int min read length )  {  final int[] hash values = new int[number of hashes] ;  for  ( int i = 0 ;  i  <  number of hashes ;   +  + i )   {  hash values[i] = 1 ;  int position = skipped bases  +  i ;  while  ( position  <  min read length )   {  hash values[i] = 31 * hash values[i]  +  read[position] ;  position +  = number of hashes ;   }   }  return hash values ;   }  
public static void   (  string name )  {  if  ( openfire properties  =  =  null )   {  load openfire properties (  )  ;   }  openfire properties . delete property ( name )  ;   }  
@ test public void   (  )  {   blocking flowable iterator <  integer >  it = new  blocking flowable iterator <  integer >  ( 128 )  ;  try  {   thread . current thread (  )  . interrupt (  )  ;  it . has next (  )  ;   }  catch  (   runtime exception ex )
boolean   (  node originating node )  {  if  (  ! node . is collection node (  )  )   {  return false ;   }  if  (  ! can send events (  )  )   {  return false ;   }  if  (  type . nodes  !  =  type )   {  return false ;   }  if  ( get depth (  )   =  =  1 &&  ! node . is child node ( originating node )  )   {  return false ;   }  if  ( get depth (  )   =  =  0 &&  ! node . is descendant node ( originating node )  )   {  return false ;   }  return true ;   }  
@ override public void   (  )  {  parent . inner complete ( this )  ;   }  
public  date   (  )  {  return time ;   }  
private  collection <  group >    (  string group names )  {   collection <  group >  answer = new  hash set <  >  (  )  ;  for  (   string group name : parse group names ( group names )  )   {  try  {  answer . add (  group manager . get instance (  )  . get group ( group name )  )  ;   }  catch  (   group not found exception e )   {   }   }  return answer ;   }  
private void   ( long allocated  list <  pending gateway message >  pending  string title )  {  if  (    log . should log (  log . info )  )   {  long highest delay = 0 ;   string builder buf = new  string builder ( 128 )  ;  buf . append (    name )  . append ( ": " )  ;  buf . append ( title )  ;  buf . append ( "  -  allocated: " )  . append ( allocated )  ;  buf . append ( " pending: " )  . append ( pending . size (  )  )  ;  if  (    pending since  >  0 )  buf . append ( " delay: " )  . append ( get delay amount ( false )  )  ;  for  ( int i = 0 ;  i  <  pending . size (  )  ;  i +  +  )   {   pending gateway message cur pending = pending . get ( i )  ;  buf . append ( " [" )  . append ( i )  . append ( "]:" )  ;  buf . append ( cur pending . get offset (  )  )  . append ( ' / ' )  . append ( cur pending . get data (  )  . length )  . append ( ' / ' )  ;  buf . append ( cur pending . get lifetime (  )  )  ;  if  ( cur pending . get lifetime (  )   >  highest delay )  highest delay = cur pending . get lifetime (  )  ;   }     log . info ( buf . to string (  )  )  ;   }   }  
private static  input stream   (  string resource name )  {   file file = new  file (  jive globals . get home directory (  )   +   file . separator  +  "resources" +   file . separator +  "spank" +   file . separator +  "scripts" resource name )  ;  try  {  return new  file input stream ( file )  ;   }  catch  (   file not found exception e )   {  return null ;   }   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public static  list <  published item >    (  leaf node node int max rows )  {   lock item lock =  cache factory . get lock ( item   cache item cache )  ;  try  {  item lock . lock (  )  ;  flush pending items (  )  ;   }  finally  {  item lock . unlock (  )  ;   }   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  int max = max   rows   fetch ;  int max published = node . get max published items (  )  ;  if  ( max rows  !  =   - 1 )  max = max published  =  =   - 1  ?   math . min ( max rows max   rows   fetch )  :  math . min ( max rows max published )  ;  else if  ( max published  !  =   - 1 )  max =  math . min ( max   rows   fetch max published )  ;  java . util .  linked list <  published item >  results = new java . util .  linked list <  >  (  )  ;  boolean descending =  jive globals . get boolean property ( "xmpp . pubsub . order . descending" false )  ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   items )  ;  pstmt . set max rows ( max )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  rs = pstmt . execute query (  )  ;  int counter = 0 ;  while  ( rs . next (  )  &&  ( counter  <  max )  )   {   string itemid = rs . get string ( 1 )  ;  jid publisher = new jid ( rs . get string ( 2 )  )  ;   date creation date = new  date (  long . parse long ( rs . get string ( 3 )  . trim (  )  )  )  ;   published item item = new  published item ( node publisher itemid creation date )  ;  if  ( rs . get string ( 4 )   !  =  null )   {  item . set payloadxml ( rs . get string ( 4 )  )  ;   }  if  ( descending )  results . add ( item )  ;  else results . add first ( item )  ;  counter +  +  ;   }   }  catch  (   exception sqle )   {  log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return results ;   }  
public  string   (  )  {  return body ;   }  
@ override public void   ( t t )  {  queue . offer ( t )  ;  drain (  )  ;   }  
private  cursor   ( final  mailbox mailbox final int delta message count )  {  if  ( mailbox  !  =  null )   {   refresh status monitor . get instance ( get context (  )  )  . monitor refresh status ( mailbox . m id new  refresh status monitor .  callback (  )  {  @ override public void on refresh completed (  long mailbox id  int result )  {  final int sync value = ui provider . create sync value (  email content . sync   status   user result )  ;  final  content values values = new  content values (  )  ;  values . put (  mailbox . ui   sync   status ui provider .  sync status . no   sync )  ;  values . put (  mailbox . ui   last   sync   result sync value )  ;  m database . update (  mailbox . table   name values where   id new  string[] {  string . value of ( mailbox id )  }  )  ;  notifyui folder ( mailbox . m id mailbox . m account key )  ;   }  @ override public void on timeout (  long mailbox id )  {   }   }   )  ;  start sync ( mailbox delta message count )  ;   }  return null ;   }  
@ override public void   (  )  {  validate fields (  )  ;   }  
public  input stream   (  )  {  return is ;   }  
public   (  )  {     context = i2p app context . get global context (  )  ;  properties = new  ordered properties (  )  ;   }  
public int   (  )  {  return out of sequence packets ;   }  
@ override public  set < k >    (  )  {  return cache . key set (  )  ;   }  
@ override public  string   (  )  {  return " { lazy bean property arguments \""  +  object  +  "\"" ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . just ( 1 )  . take ( 1 )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ override public void on next (   integer t )  {  throw new  test exce
public void   (  )  {  session listeners . clear (  )  ;   }  
public boolean   (  )  {  return len  >  =  max   size ;   }  
public   ( boolean rev  string lang )  {  super ( rev lang )  ;   }  
@ override public final void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;   subscription helper . cancel ( subscription )  ;   }   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   completable subject cs =  completable subject . create (  )  ;   test observer <  void >  to = ps . concat map completable (  functions . just function (
private  string   ( ssl eep get .  proxy type type )  {  switch  ( type )   {  case http: return "https" ;  case socks4: return "socks 4 / 4a" ;  case socks5: return "socks 5" ;  case internal: return "i2p  outproxy" ;  default : return type . to string (  )  ;   }   }  
private boolean   ( boolean recheck )  throws io exception  {  synchronized  ( this )   {     is checking = true ;  try  {  return locked   check create files ( recheck )  ;   }  finally  {     is checking = false ;   }   }   }  
 string   (  )  throws io exception  {  return "accum value:"  +  accum value . get (  )   +  " nan steps:" +  nan steps . get (  )  +  "\n" ;   }  
public final  disposable   (  )  {   connect consumer cc = new  connect consumer (  )  ;  connect ( cc )  ;  return cc . disposable ;   }  
public   ( int prime size )  {  this . prime size = prime size ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;   }  
@ override public void   (  throwable t )  {  ts1 . on error ( t )  ;   }  
protected void   (  dest lookup message message )  {     context . job queue (  )  . add job ( new  lookup dest job (    context    runner message . get hash (  )     runner . get dest hash (  )  )  )  ;   }  
 list <  duplicate set >    ( final int max edit distance to join )  {   graph utils .  graph <  integer >  umi graph = new  graph utils .  graph <  >  (  )  ;  for  ( int i = 0 ;  i  <  num umis ;  i +  +  )   {  umi graph . add node ( i )  ;  for  ( int j = i  +  1 ;  j  <  num umis ;  j +  +  )   {  if  (  string util . is within hamming distance ( umi[i] umi[j] max edit distance to join )  )   {  umi graph . add edge ( i j )  ;   }   }   }  final  map <  integer  integer >  umi cluster map = umi graph . cluster (  )  ;  for  ( int i = 0 ;  i  <  num umis ;  i +  +  )   {  duplicate setid[i] = umi cluster map . get ( i )  ;   }  final  map <  integer  list < sam record >  >  duplicate sets = new  hash map <  >  (  )  ;  final  map <  string  integer >  duplicate sets from umis = get duplicate sets from umis (  )  ;  for  (  sam record rec : records )   {  final  string umi =  umi util . get sanitizedumi ( rec umi tag )  ;  final  integer duplicate set index = duplicate sets from umis . get ( umi )  ;  if  ( duplicate sets . contains key ( duplicate set index )  )   {  duplicate sets . get ( duplicate set index )  . add ( rec )  ;   }  else  {  final  list < sam record >  n = new  array list <  >  (  )  ;  n . add ( rec )  ;  duplicate sets . put ( duplicate set index n )  ;   }   }  final  list <  duplicate set >  duplicate set list = new  array list <  >  (  )  ;  for  (  final  map .  entry <  integer  list < sam record >  >  entry : duplicate sets . entry set (  )  )   {  final  duplicate set ds = new  duplicate set (  )  ;  final  list < sam record >  record list = entry . get value (  )  ;  record list . for each ( ds::add )  ;  long max count = 0 ;   string assigned umi = null ;   string fewestn umi = null ;  long n count = 0 ;  for  (  sam record rec : record list )   {  final  string umi =  umi util . get sanitizedumi ( rec umi tag )  ;  if  ( umi . contains ( "n" )  )   {  int count =  string utils . count matches ( umi "n" )  ;  if  ( n count  =  =  0 )   {  n count = count ;  fewestn umi = umi ;   }  else if  ( count  <  n count )   {  n count = count ;  fewestn umi = umi ;   }   }  else if  ( umi counts . get ( umi )   >  max count )   {  max count = umi counts . get ( umi )  ;  assigned umi = umi ;   }   }  if  ( assigned umi  =  =  null )   {  assigned umi = fewestn umi ;   }  for  (  final sam record rec : record list )   {  if  ( allow missing umis && rec . get string attribute ( umi tag )  . is empty (  )  )   {  rec . set attribute ( umi tag null )  ;   }  else  {  rec . set attribute ( assigned umi tag assigned umi )  ;   }   }  duplicate set list . add ( ds )  ;   }  return duplicate set list ;   }  
void   ( boolean send item subscribe )  {  this . send item subscribe = send item subscribe ;   }  
@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   phone bean phone bean =  (  phone bean ) o ;  return id  =  =  phone bean . id &&  ob
public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
@ test public void   (  )  {  final  flowable <  string >  o1 =  flowable . unsafe create ( new  test error flowable ( "four" null "six" )  )  ;  final  flowable <  string >  o2 =  flowable . unsafe create ( new  test error flowable ( "one" "two" null )  
public int   (  )  {  return    r port ;   }  
public  throwable   ( long timeout  time unit unit )  {  if  ( get count (  )   !  =  0 )   {  try  {   blocking helper . verify non blocking (  )  ;  if  (  ! await ( timeout unit )  )   {  dispose (  )  ;  throw  exception helper . wrap or throw ( new  timeout exception (  )  )  ;   }   }  catch  (   interrupted exception ex )   {  dispose (  )  ;  throw  exception helper . wrap or throw ( ex )  ;   }   }  return error ;   }  
@ override public void   (  string streamid )  {  this . streamid = streamid ;   }  
public static void   ( boolean use stun )  {  sip config . use stun = use stun ;   }  
public  remote session locator   (  )  {  return remote session locator ;   }  
 string   (  )  {  return content encoding ;   }  
@ data provider ( name = " " )  public  object[][] bad argument combinationsdata (  )  {  return new  object[][] {  {  filter sam reads .  filter . include javascript "read   list   file" }   {  filter sam reads .  filter . exclude aligned "read   list   
public long   (  )  {   peer coordinator coord = coordinator ;  if  ( coord  !  =  null )   {  long r = get remaining length (  )  ;  if  ( r  <  =  0 )  return 0 ;  long n = coord . get needed length (  )  ;  return r  -  n ;   }  else if  ( storage  !  =  null )   {  return storage . get skipped length (  )  ;   }  return 0 ;   }  
private boolean   ( int first item index int result count int page size boolean reverse )  {  if  ( reverse )   {  if  ( first item index  =  =  0 )   {  return true ;   }   }  else  {  if  (  ( first item index  +  page size )   >  =  result count )   {  return true ;   }   }  return false ;   }  
@ override public boolean   (  )  {  return subscribers . get (  )   =  =  terminated && error  !  =  null ;   }  
private void   ( boolean force )  {  if  ( state . compare and set (  state . open  state . closed )  )   {  if  ( session  !  =  null )   {  session . set status (  session . status   closed )  ;   }  if  (  ! force )   {  boolean allowed to write = false ;  try  {  request writing (  )  ;  allowed to write = true ;  write started (  )  ;  writer . write ( " <  / stream:stream > " )  ;  if  ( flash client )   {  writer . write ( '\0' )  ;   }  writer . flush (  )  ;   }  catch  (   exception e )   {   log . debug ( " failed to deliver stream close tag: "  +  e . get message (  )  )  ;   }  write finished (  )  ;  if  ( allowed to write )   {  release writing (  )  ;   }   }  close connection (  )  ;  notify close listeners (  )  ;   }   }  
private long   (  )  {  synchronized  (    fortuna )   {  return  (  ( long ) next bits ( 32 )   <  <  32 )   +  next bits ( 32 )  ;   }   }  
public  string   (  )  {  return call answered treatment ;   }  
public  thread   (  )  {  return thread reference ;   }  
public void   ( i2np message msg  hash to router  tunnel id to tunnel )  {  if  ( to router  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping msg at obep with unsupported delivery instruction type local" )  ;  return ;   }  if  (    log . should log (  log . debug )  )     log . debug ( "outbound tunnel "  +     config  +  " received a full message: " +  msg +  " to be forwarded on to " +  to router . to base64 (  )  . substring ( 0 4 )  +   ( to tunnel  !  =  null  ?  ":"  +  to tunnel . get tunnel id (  )  : "" )  )  ;  int size = msg . get message size (  )  ;  boolean to us =    context . router hash (  )  . equals ( to router )  ;  if  (  (  ! to us )  &&    context . tunnel dispatcher (  )  . should drop participating message (  tunnel dispatcher .  location . obep msg . get type (  )  size )  )  return ;  if  (  ! to us )     context . bandwidth limiter (  )  . sent participating message ( size )  ;     out distributor . distribute ( msg to router to tunnel )  ;   }  
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  integer >   object >  (  )  {  @ override public  object apply (   flowable <  integer >  o )  throws  exception  {  return o . flat map iterable ( new  
public  direction   (  )  {  return direction ;   }  
public short   (  string parameter name )  throws sql exception  {  return cstmt . get short ( parameter name )  ;   }  
public void   (  )  {  user manager = null ;  presence manager = null ;  try  {  component manager . remove component ( subdomain )  ;  component manager = null ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( 1l 1l  time unit . seconds null )  ;   }  
private void   (  string subdomain )  {  subdomains . add ( subdomain )  ;   }  
@ override public void   (  string column label byte x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public void   ( int remote port )  {  this . remote port = remote port ;   }  
@ before public void   (  )  throws io exception  {  header values = new  hash map <  >  (  )  ;  header values . put ( " header1" " value1" )  ;  header values . put ( " header2" " value21  value22" )  ;  header values . put ( " header3" " value3 ; q = 3
@ test ( expected =  null pointer exception . class )  public void   (  )  {   unicast processor . create ( 5 null )  ;   }  
protected void   (  packet packet )  {   log . debug ( " sending package to  packet router: \n"  +  packet . to string (  )   +  "\n" )  ;     router . route ( packet )  ;   }  
public  map <  string  filter type >    (  )  {  return  collections . unmodifiable map ( registered filters )  ;   }  
void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public boolean   ( int[] linear data )  {  speech detector calls +  +  ;  long start =  current time . get time (  )  ;  int n samples =  ( linear data . length  /  8 )  * 8 ;  long sq = 0 ;  for  ( int i = 0 ;  i  <  =  n samples  -  8 ;  i +  = 8 )   {  double avg =  ( double )  (  (  ( byte )  ( linear data[i  +  0]  >  >  8 )   +   ( byte )  ( linear data[i  +  1]  >  >  8 )   +   ( byte )  ( linear data[i  +  2]  >  >  8 )  +   ( byte )  ( linear data[i  +  3]  >  >  8 )  +   ( byte )  ( linear data[i  +  4]  >  >  8 )  +   ( byte )  ( linear data[i  +  5]  >  >  8 )  +   ( byte )  ( linear data[i  +  6]  >  >  8 )  +   ( byte )  ( linear data[i  +  7]  >  >  8 )  )   /  8 .  )  ;  avg /  = media info . get channels (  )  ;  sum +  =  ( avg * avg )  ;  cnt +  +  ;   }  speech detector time +  =  (  current time . get time (  )   -  start )  ;  return  ( speaking changed (  )  )  ;   }  
@ test public void   (  )  throws  interrupted exception  {   system . out . println ( " main  thread: "  +   thread . current thread (  )  . get name (  )  )  ;   flowable <  string >  obs =  flowable . just ( "one" "null" "two" "three" "four" )  ;   sub
public boolean   ( int tunnel )  {  return get boolean property ( tunnel i2p tunnelhttp client . prop   referer )  ;   }  
  (  keyed stack lock update lock  object update key  string property int sleep time  thread next thread boolean join thread )  {  super ( update lock update key )  ;  this . property = property ;  this . sleep time = sleep time ;  this . next thread = next thread ;  this . join thread = join thread ;   }  
@ override public void   (  string transfer digest  proxy transfer proxy transfer )  throws  unauthorized exception  {   file transfer transfer = retrieve file transfer ( transfer digest )  ;  if  ( is match proxy transfer (  )  && transfer  =  =  null ) 
public int   (  )  {  int rv = 0 ;  synchronized  (    inbound messages )   {  for  (  iterator <  inbound message state >  iter =    inbound messages . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   inbound message state state = iter . next (  )  ;  if  ( state . is expired (  )  ||    dead )   {  iter . remove (  )  ;   }  else  {  if  ( state . is complete (  )  )   {     log . error ( "inbound message is complete  but wasn't handled inline ?  "  +  state  +  " with " +  this )  ;  iter . remove (  )  ;   }  else  {  rv +  +  ;   }   }   }   }  return rv ;   }  
@ xml element public boolean   (  )  {  return registration enabled ;   }  
@ post construct public void   (  )  {  security audit log controller =  security audit log controller . get instance (  )  ;   }  
public   (  string msg  throwable nested throwable )  {  super ( msg )  ;  this . nested throwable = nested throwable ;   }  
int   ( boolean ipv6 )  {   router address addr = get current address ( ipv6 )  ;  if  ( addr  !  =  null )   {  int rv = addr . get port (  )  ;  if  ( rv  >  0 )  return rv ;   }  return get requested port ( ipv6 )  ;   }  
public final static  string   (  string input )  {  if  ( input  =  =  null )  return null ;   string out str ;  out str = input . replace ( "&amp ; " "&" )  ;  out str = out str . replace ( "&lt ; " " < " )  ;  out str = out str . replace ( "&gt ; " " > " )  ;  out str = out str . replace ( "&apos ; " "\'" )  ;  out str = out str . replace ( "&quot ; " "\"" )  ;  return out str ;   }  
private sam record   (  )  {  while  (  ! output buffer . is empty (  )  && output buffer . can emit (  )  )   {  final sam record record = output buffer . next (  )  . get record (  )  ;  if  (  ! remove duplicates ||  ! record . get duplicate read flag (  )  )   {  return record ;   }   }  return null ;   }  
private  string   (  )  {  return settings . get chat setting (  key enum . bye   message )  . get value (  )  ;   }  
public  string   (  )  {  return destination ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   integer v )  {  return just1 ;   }   }   
@ test ( expected =  no such element exception . class )  public void   (  )  {   blocking observable iterator <  integer >  it = new  blocking observable iterator <  integer >  ( 128 )  ;  it . on complete (  )  ;  it . next (  )  ;   }  
private void   (  )  {  destroy responses (  )  ;  m parser = new  imap response parser ( m transport . get input stream (  )  m discourse )  ;   }  
public  date   (  )  {  return offer time ;   }  
public void   (  request request )  {  final  offer offer = new  offer ( request queue get agent rejection timeout (  )  )  ;  offer . set timeout ( info . get offer timeout (  )  )  ;  offers . add ( offer )  ;   thread offer thread = new  thread ( " dispatch offer  -  queue: "  +  queue . get name (  )  )  {  @ override public void run (  )  {  dispatch ( offer )  ;  offers . remove ( offer )  ;   }   }   ;  offer thread . start (  )  ;   }  
@ override protected void   (  subscriber <  ?  super u >  s )  {  if  (  flowable scalarx map . try scalarx map subscribe ( source s mapper )  )   {  return ;   }  source . subscribe ( subscribe ( s mapper delay errors max concurrency buffer size )  )  ;
public  localmuc room   (  )  {   multi user chat service muc service = xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( subdomain )  ;  if  ( muc service  =  =  null )   {  throw new  illegal argument exception ( "muc service not found for subdomain: "  +  subdomain )  ;   }   localmuc room room =  (  localmuc room ) muc service . get chat room ( room name )  ;  if  ( room  =  =  null )   {  throw new  illegal argument exception ( " room not found: "  +  room name )  ;   }  return room ;   }  
public   (  string name )  {     role name = name ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;   flowable . range ( 1 5 )  . filter (  functions . always true (  )  )  . subscribe ( ts )  ;  ts . assert of (  subscriber fusio
private void   (  writer out  tunnel pool in  tunnel pool out pool )  throws io exception  {  if  ( in  =  =  null || out pool  =  =  null )  return ;   string irname = in . get rate name (  )  ;   string orname = out pool . get rate name (  )  ;   rate stat irs =    context . stat manager (  )  . get rate ( irname )  ;   rate stat ors =    context . stat manager (  )  . get rate ( orname )  ;  if  ( irs  =  =  null || ors  =  =  null )  return ;   rate ir = irs . get rate ( 5 * 60 * 1000l )  ;   rate or = ors . get rate ( 5 * 60 * 1000l )  ;  if  ( ir  =  =  null || or  =  =  null )  return ;  final  string tgd =    t ( " graph  data" )  ;  final  string tcg =    t ( " configure  graph  display" )  ;  if  ( or . get summary listener (  )   !  =  null )   {  out . write ( " < a href = \"graph ? stat = "  +  orname  +  " . 300000&amp ; w = 600&amp ; h = 200\" > " +  " < img src = \" / themes / console / images / outbound . png\" alt = \"" +  tgd +  "\" title = \"" +  tgd +  "\" >  <  / a > " )  ;   }  else  {  out . write ( " < a href = \"configstats#"  +  orname  +  "\" > " +  " < img src = \" / themes / console / images / outbound . png\" alt = \"" +  tcg +  "\" title = \"" +  tcg +  "\" >  <  / a > " )  ;   }  if  ( ir . get summary listener (  )   !  =  null )   {  out . write ( " < a href = \"graph ? stat = "  +  irname  +  " . 300000&amp ; w = 600&amp ; h = 200\" > " +  " < img src = \" / themes / console / images / inbound . png\" alt = \"" +  tgd +  "\" title = \"" +  tgd +  "\" >  <  / a >  " )  ;   }  else  {  out . write ( " < a href = \"configstats#"  +  irname  +  "\" > " +  " < img src = \" / themes / console / images / inbound . png\" alt = \"" +  tcg +  "\" title = \"" +  tcg +  "\" >  <  / a > " )  ;   }   }  
public static  mailbox   (  context context long id )  {  return  email content . restore content with id ( context  mailbox . class  mailbox . content   uri  mailbox . content   projection id )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just ( 1 )  . to flowable (  backpressure strategy . error )  )  ;   }  
private  servlet request   (  servlet request request )  {  if  (  !  ( request instanceof  http servlet request )  )   {  logger . log debug ( " can't compress non - http request" )  ;  return null ;   }   http servlet request http request =  (  http servlet request ) request ;   string content encoding = http request . get header (  compressing http servlet response . content   encoding   header )  ;  if  ( content encoding  =  =  null ||  string utils . equals ignore case ( content encoding  compressing stream factory . no   encoding )  )   {  logger . log debug ( " request is not compressed  so not decompressing" )  ;  return null ;   }  if  (  !  compressing stream factory . is supported request content encoding ( content encoding )  )   {  logger . log debug ( " can't decompress request with encoding: "  +  content encoding )  ;  return null ;   }  if  (  compressing stream factory . no   encoding . equals ignore case ( content encoding )  )   {  logger . log debug ( " can't decompress request with encoding: "  +  content encoding )  ;  return null ;   }  return new  compressed http servlet request ( http request  compressing stream factory . get factory for content encoding ( content encoding )  context )  ;   }  
public void   (  )  {  synchronized  ( whisper group )   {  previous contribution = current contribution ;  current contribution = null ;  contribution valid = false ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . just ( 5 1 2 4 3 )  . to sorted list ( 4 )  . to observable (  )  . test (  )  . assert result (  arrays . as list ( 1 2 3 4 5 )  )  ;   }  
@ small test public void   (  )  {   account account1 =  provider test utils . setup account ( "account - save" true m mock context )  ;  long account1 id = account1 . m id ;   account account2 =  account . restore account with id ( m mock context account
public  peer profile   (  file file )  {   hash peer = get hash ( file . get name (  )  )  ;  try  {  if  ( peer  =  =  null )   {     log . error ( " the file "  +  file . get name (  )   +  " is not a valid hash" )  ;  return null ;   }   peer profile profile = new  peer profile (    context peer )  ;   properties props = new  properties (  )  ;  load props ( props file )  ;  long last sent to successfully = get long ( props "last sent to successfully" )  ;  if  ( is expired ( last sent to successfully )  )   {  if  (    log . should log (  log . info )  )     log . info ( " dropping old profile "  +  file . get name (  )   +  "  since we haven't heard from them in a long time" )  ;  file . delete (  )  ;  return null ;   }  else if  ( file . get name (  )  . ends with ( old   suffix )  )   {   string new name = file . get absolute path (  )  ;  new name = new name . substring ( 0 new name . length (  )   -  old   suffix . length (  )  )   +  suffix ;  boolean success = file . rename to ( new  file ( new name )  )  ;  if  (  ! success )  file . delete (  )  ;   }  profile . set capacity bonus (  ( int ) get long ( props "capacity bonus" )  )  ;  profile . set integration bonus (  ( int ) get long ( props "integration bonus" )  )  ;  profile . set speed bonus (  ( int ) get long ( props "speed bonus" )  )  ;  profile . set last heard about ( get long ( props "last heard about" )  )  ;  profile . set first heard about ( get long ( props "first heard about" )  )  ;  profile . set last send successful ( get long ( props "last sent to successfully" )  )  ;  profile . set last send failed ( get long ( props "last failed send" )  )  ;  profile . set last heard from ( get long ( props "last heard from" )  )  ;  profile . set tunnel test time average ( get float ( props "tunnel test time average" )  )  ;  profile . set peak throughputk bps ( get float ( props "tunnel peak throughput" )  )  ;  profile . set peak tunnel throughputk bps ( get float ( props "tunnel peak tunnel throughput" )  )  ;  profile . set peak tunnel1m throughputk bps ( get float ( props "tunnel peak tunnel1m throughput" )  )  ;  profile . get tunnel history (  )  . load ( props )  ;  if  ( get long ( props "db history . last lookup successful" )   >  0 || get long ( props "db history . last lookup failed" )   >  0 || get long ( props "db history . last store successful" )   >  0 || get long ( props "db history . last store failed" )   >  0 )   {  profile . expanddb profile (  )  ;  profile . getdb history (  )  . load ( props )  ;  profile . get db introduction (  )  . load ( props "db introduction" true )  ;  profile . get db response time (  )  . load ( props "db response time" true )  ;   }  profile . get tunnel create response time (  )  . load ( props "tunnel create response time" true )  ;  profile . get tunnel test response time (  )  . load ( props "tunnel test response time" true )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " loaded the profile for "  +  peer . to base64 (  )   +  " from " +  file . get name (  )  )  ;  fixup first heard about ( profile )  ;  return profile ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error loading properties from "  +  file . get absolute path (  )  e )  ;  file . delete (  )  ;  return null ;   }   }  
private void   (  )  {  for  (   module module : modules . values (  )  )   {  try  {  logger . debug ( " starting module: "  +  module . get name (  )  )  ;  module . start (  )  ;   }  catch  (   exception e )   {  logger . error ( " an exception occurred while starting module ' {  } ' . " module . get name (  )  e )  ;   }   }   }  
@ override public void   (  )  {  try  {   thread . sleep ( 5000 )  ;   system . exit ( 0 )  ;   }  catch  (   interrupted exception e )   {   }   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
@ override public  flowable < u >    (  )  {  return  rx java plugins . on assembly ( new  flowable collect < t u >  ( source initial supplier collector )  )  ;   }  
public   (  abstract locus iterator < t  abstract locus info < t >  >  iterator  reference sequence file walker ref walker  abstract wgs metrics collector < t >  collector  progress logger progress )  {  this . iterator = iterator ;  this . collector = collector ;  this . ref walker = ref walker ;  this . progress = progress ;   }  
public void   ( byte[] iv )  {  if  ( iv . length  !  =  reply   iv   length )  throw new  illegal argument exception (  )  ;     replyiv = iv ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;  final  publish processor <  integer >  timeout =  publish processor . create (  )  ;   function <  integer  flowable <  integer >  >  timeout func
public static  sel datagram channel   ( final  datagram listener datagram listener final  socket address local address )  throws io exception  {  synchronized  ( executor service )   {  if  ( selector  =  =  null )   {  init (  )  ;   }   }  final  datagram channel dc =  datagram channel . open (  )  ;  dc . configure blocking ( false )  ;  dc . socket (  )  . bind ( local address )  ;  final  sel datagram channel c = new  sel datagram channel ( dc datagram listener )  ;  synchronized  ( obj )   {  selector . wakeup (  )  ;  dc . register ( selector  selection key . op   read c )  ;   }  return c ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . merge (  arrays . as list (  maybe . just ( 1 )   maybe . just ( 2 )   maybe . just ( 3 )  )  )  . test (  )  . assert result ( 1 2 3 )  ;   }  
@ test public void   (  )  throws io exception  {  byte[] bytes = new byte[ ( stream   data1  +  stream   data2 )  . length (  ) ] ;   string expected = stream   data1  +  stream   data2 ;  int read length = combined stream . read ( bytes )  ;  assert equ
public  call event listener   (  )  {  return null ;   }  
public   (  string s )  {  super ( s )  ;   }  
public void   (  string treatment id )  {  synchronized  ( conference manager )   {  synchronized  ( member treatments )   {  if  ( treatment id  =  =  null )   {  member treatments . clear (  )  ;  if  ( current treatment  !  =  null )   {  current treatment . stop treatment (  )  ;   }  return ;   }  for  ( int i = 0 ;  i  <  member treatments . size (  )  ;  i +  +  )   {   treatment manager treatment manager =  (  treatment manager ) member treatments . get ( i )  ;  if  ( treatment manager . get id (  )  . equals ( treatment id )  )   {  if  ( treatment manager  =  =  current treatment )   {  treatment manager . stop treatment (  )  ;   }  else  {  member treatments . remove ( i )  ;   }  return ;   }   }   }   }   }  
public void   ( final double xff )  throws  rrd exception  io exception  {  if  ( xff  <  0d || xff  >  =  1d )   {  throw new  rrd exception ( " invalid xff supplied  ( "  +  xff  +  " )   must be  >  =  0 and  <  1" )  ;   }  this . xff . set ( xff )  ;   }  
@ xml element decl ( namespace = "http: /  / docs . openrepose . org / repose / unmarshaller - test / v0 . 0" name = "unmarshaller - test" )  public jaxb element <  unmarshaller validator test impl >    (  unmarshaller validator test impl value )  {  retu
@ test public void   (  )  {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable .  <  integer > error ( new  test exception (  )  )  . concat with (  maybe .  <  integer > from action ( new  action (  )  {  @ 
public void   ( boolean resolve )  {  this . resolve entity refs = resolve ;   }  
@ test public void   (  )  throws  exception  {  assert that exception of type (  force rollback . class )  . is thrown by (  (  )   -  >   {  service . in propagation required ( outer  -  >   {  final  handle h =  jdbi util . get handle ( outer )  ;  h .
private void   ( int reply code int address type  inet address inet addr  string domain name int bind port  data output stream out )  throws io exception  {   byte array output stream reps = new  byte array output stream (  )  ;   data output stream dreps = new  data output stream ( reps )  ;  dreps . write ( socks   version   5 )  ;  dreps . write ( reply code )  ;  dreps . write ( 0x00 )  ;  dreps . write ( address type )  ;  switch  ( address type )   {  case  address type . ipv4: dreps . write ( inet addr . get address (  )  )  ;  break ;  case  address type . domainname: dreps . write byte ( domain name . length (  )  )  ;  dreps . write bytes ( domain name )  ;  break ;  default :    log . error ( "unknown address type passed to send reply (  )   ( "  +   integer . to hex string ( address type )   +  " )  ! " )  ;  return ;   }  dreps . write short ( bind port )  ;  byte[] reply = reps . to byte array (  )  ;  if  (    log . should log (  log . debug )  )   {     log . debug ( " sending request reply:\n"  +   hex dump . dump ( reply )  )  ;   }  out . write ( reply )  ;   }  
  (  consumer <  ?  super  notification < t >  >  on notification )  {  this . on notification = on notification ;   }  
@ test public void   (  )  throws  exception  {  final  collection < x509 certificate >  input = new  array list <  >  (  )  ;  final  collection < x509 certificate >  result =  certificate utils . filter valid ( input )  ;   assert . assert true ( result
public void   (  string s )  {     config . set outproxy auth ( true )  ;   }  
public void   ( i2np message msg  hash target  tunnel id tunnel )  {  if  (    log . should log (  log . debug )  )     log . debug ( "ibmd for "  +     client  +  " to " +  target +  "  /  " +  tunnel +  " : " +  msg )  ;  int type = msg . get type (  )  ;  if  (    client  !  =  null )   {  switch  ( type )   {  case  database search reply message . message   type: break ;  case  database store message . message   type:  database store message dsm =  (  database store message ) msg ;  if  ( dsm . get entry (  )  . get type (  )   =  =   database entry . key   type   routerinfo )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping dsm down a tunnel for "  +     client  +  ": " +  msg )  ;   hash key = dsm . get key (  )  ;  if  (    context . router hash (  )  . equals ( key )  )  return ;   router info ri =  (  router info ) dsm . get entry (  )  ;  if  (  ! key . equals ( ri . get identity (  )  . get hash (  )  )  )  return ;  if  (  ! ri . is valid (  )  )  return ;   router info oldri =    context . net db (  )  . lookup router info locally ( key )  ;  if  ( oldri  !  =  null && oldri . get published (  )   <  ri . get published (  )  &&  !  floodfill network database facade . is floodfill ( ri )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " updating caps for ri "  +  key  +  " from \"" +  oldri . get capabilities (  )  +  "\" to \"" +  ri . get capabilities (  )  +  '"' )  ;     context . peer manager (  )  . set capabilities ( key ri . get capabilities (  )  )  ;   }  return ;   }  else if  ( dsm . get reply token (  )   !  =  0 )   {     context . stat manager (  )  . add rate data ( "tunnel . drop dangerous client tunnel message" 1 type )  ;     log . error ( " dropping ls dsm w /  reply token down a tunnel for "  +     client  +  ": " +  msg )  ;  return ;   }  else  {   (  (  lease set ) dsm . get entry (  )  )  . set received as reply (  )  ;   }  break ;  case  delivery status message . message   type: case  garlic message . message   type: case  tunnel build reply message . message   type: case  variable tunnel build reply message . message   type: break ;  default :    context . stat manager (  )  . add rate data ( "tunnel . drop dangerous client tunnel message" 1 type )  ;     log . error ( " dropped dangerous message down a tunnel for "  +     client  +  ": " +  msg new  exception ( "cause" )  )  ;  return ;   }   }  else  {  switch  ( type )   {  case  database store message . message   type:  database store message dsm =  (  database store message ) msg ;  if  ( dsm . get reply token (  )   !  =  0 )   {     context . stat manager (  )  . add rate data ( "tunnel . drop dangerous expl tunnel message" 1 type )  ;     log . error ( " dropping dsm w /  reply token down a expl .  tunnel: "  +  msg )  ;  return ;   }  if  ( dsm . get entry (  )  . get type (  )   =  =   database entry . key   type   leaseset )   (  (  lease set ) dsm . get entry (  )  )  . set received as reply (  )  ;  break ;  case  database search reply message . message   type: case  delivery status message . message   type: case  garlic message . message   type: case  tunnel build reply message . message   type: case  variable tunnel build reply message . message   type: break ;  default :    context . stat manager (  )  . add rate data ( "tunnel . drop dangerous expl tunnel message" 1 type )  ;     log . error ( " dropped dangerous message down expl tunnel: "  +  msg new  exception ( "cause" )  )  ;  return ;   }   }  if  (  ( target  =  =  null )  ||  (  ( tunnel  =  =  null )  &&  (    context . router hash (  )  . equals ( target )  )  )  )   {  if  ( type  =  =   garlic message . message   type )   {     context . in net message pool (  )  . handle replies ( msg )  ;     receiver . receive (  (  garlic message ) msg )  ;   }  else  {  if  (    log . should log (  log . info )  )     log . info ( "distributing inbound tunnel message into our in net message pool: "  +  msg )  ;     context . in net message pool (  )  . add ( msg null null )  ;   }   }  else  {   tunnel info out =    context . tunnel manager (  )  . select outbound tunnel (    client target )  ;  if  ( out  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( "no outbound tunnel to send the client message for "  +     client  +  ": " +  msg )  ;  return ;   }  if  (    log . should log (  log . debug )  )     log . debug ( "distributing ib tunnel msg type "  +  type  +  " back out " +  out +  " targetting " +  target )  ;   tunnel id out id = out . get send tunnel id ( 0 )  ;  if  ( out id  =  =  null )   {  if  (    log . should log (  log . error )  )     log . error ( "strange ?  outbound tunnel has no outbound id ?  "  +  out  +  " failing to distribute " +  msg )  ;  return ;   }  long exp =    context . clock (  )  . now (  )   +  20 * 1000 ;  if  ( msg . get message expiration (  )   <  exp )  msg . set message expiration ( exp )  ;     context . tunnel dispatcher (  )  . dispatch outbound ( msg out id tunnel target )  ;   }   }  
@ override public void   (  plugin manager manager  file plugin directory )  {  directory watcher . start (  )  ;   property event dispatcher . add listener ( this )  ;   }  
public static x509 certificate   (  )  throws  exception  {  return generate test certificate ( true false 0 )  ;   }  
private  outbound session   (  public key target  session key key )  {  if  (    log . should log (  log . info )  )     log . info ( " new ob session  sesskey: "  +  key  +  " target: " +  to string ( target )  )  ;   outbound session sess = new  outbound session (    context    log target key )  ;  add session ( sess )  ;  return sess ;   }  
@ test public void   (  )  {   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   single . just ( "a" )  . merge with (  single . just ( "b" )  )  . subscribe ( ts )  ;  ts . assert value sequence (  arrays . as list ( "a" "b" )
public  cluster wrapper   (  string id )  {  return domains . get ( id )  ;   }  
public  array list <  string >    (  )  {  return contacts ;   }  
@ override protected  string[]   (  )  {  if  ( minimum   pct  <  0 || minimum   pct  >  0 . 5 )   {  return new  string[] { "minimum   pct was set to "  +  minimum   pct  +  " .   it must be between 0 and 0 . 5 so all data categories don't get discarded 
@ override public long   ( long n )  throws io exception  {  return original stream . skip ( n )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  completable observer[] co =  { null }  ;   completable . merge array delay error (  completable . complete (  )  new  completable (  ) 
public void   (  )  {  result =  (  (  outgoing server session ) get session (  )  )  . check outgoing domain pair ( local remote )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   new  function <  object  single <  integer >  >  (  )  {  @ ov
public  string   (  string name )  {  while  ( true )   {  try  {  synchronized  (    naming reply lock )   {   string val =    naming replies . remove ( name )  ;  if  ( val  =  =  null )   {     naming reply lock . wait (  )  ;   }  else  {  if  ( sam reader . sam client event listener . naming   reply   invalid   key . equals ( val )  )  return null ;  else if  ( sam reader . sam client event listener . naming   reply   key   not   found . equals ( val )  )  return null ;  else return val ;   }   }   }  catch  (   interrupted exception ie )   {  return null ;   }   }   }  
@ override public  bundle   (  host auth compat host auth com )  throws  remote exception  {  return null ;   }  
public void   (  inet address address )  {  m local address = address ;   }  
private static void   (  context context  hash map <  string  imap folder >  folder map )  {  for  (   imap folder imap folder : folder map . values (  )  )   {  imap folder . save ( context )  ;   }   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . cancel (  )  ;  on error ( e )  ;  return ;   }  if  ( b 
@ test public void   (  )  {   flowable . just ( 1 2 3 4 5 6 7 8 9 10 )  . test (  )  . assert result ( 1 2 3 4 5 6 7 8 9 10 )  ;   }  
public boolean   ( int id  string dest  properties props )  throws i2p exception   connect exception   no route to host exception   data format exception   interruptedio exception  sam invalid direction exception  io exception  {  if  (  ! can create )   {  if  (    log . should log (  log . debug )  )     log . debug ( " trying to create an outgoing connection using a receive - only session" )  ;  throw new sam invalid direction exception ( " trying to create connections through a receive - only session" )  ;   }  if  ( check socket handler id ( id )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " the specified id  ( "  +  id  +  " )  is already in use" )  ;  return false ;   }   destination d = sam utils . get dest ( dest )  ;  i2p socket options opts = socket mgr . build options ( props )  ;  if  ( props . get property ( i2p socket options . prop   connect   timeout )   =  =  null )  opts . set connect timeout ( 60 * 1000 )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " connecting new i2p socket .  .  . " )  ;  i2p socket i2ps = socket mgr . connect ( d opts )  ;  create socket handler ( i2ps id )  ;  recv . notify stream outgoing connection ( id "ok" null )  ;  return true ;   }  
public static double   ( final double[] depth distribution final double[] quality distribution final int sample size final double log odds threshold final boolean with logging )  {  final int n =  math . min ( depth distribution . length max   considered   depth  +  1 )  ;  if  ( with logging )  log . info ( " creating  roulette  wheel" )  ;  final  roulette wheel quality sampler = new  roulette wheel ( quality distribution )  ;  if  ( with logging )  log . info ( " calculating quality sums from quality sampler" )  ;  final  list <  array list <  integer >  >  quality sums = quality sampler . sample cumulative sums ( n sample size with logging )  ;  final  array list <  double >  quality sum thresholds = new  array list <  >  ( n )  ;  final double log   10 =  math . log10 ( 2 )  ;  for  ( int n = 0 ;  n  <  n ;  n +  +  )  quality sum thresholds . add ( 10 *  ( n * log   10  +  log odds threshold )  )  ;  if  ( with logging )  log . info ( " calculating theoretical het sensitivity" )  ;  final  list <  array list <  double >  >  probability to exceed threshold = proportions above thresholds ( quality sums quality sum thresholds )  ;  final  list <  array list <  double >  >  alt depth distribution = het alt depth distribution ( n )  ;  double result = 0 . 0 ;  for  ( int n = 0 ;  n  <  n ;  n +  +  )   {  for  ( int m = 0 ;  m  <  =  n ;  m +  +  )   {  result +  = depth distribution[n] * alt depth distribution . get ( n )  . get ( m )  * probability to exceed threshold . get ( m )  . get ( n )  ;   }   }  return result ;   }  
void   ( int port )  {   message m = new  message (  message . port port )  ;  add message ( m )  ;   }  
private void   ( i2np message message body )  {  if  ( dispatch   direct )   {  do short circuit tunnel gateway ( message body )  ;   }  else  {  synchronized  (    pending gateway messages )   {     pending gateway messages . add ( message body )  ;     pending gateway messages . notify all (  )  ;   }  if  (  !    dispatch threaded )     context . job queue (  )  . add job (    short circuit gateway job )  ;   }   }  
@ override public  list <  presence >    ( jid jid muc role send role )  throws  forbidden exception   conflict exception  {  final jid barejid = jid . as barejid (  )  ;  lock . write lock (  )  . lock (  )  ;  try  {  muc role .  affiliation old affilia
public   (  router context ctx )  {     log = ctx . log manager (  )  . get log ( get class (  )  )  ;     pending connections = new  linked hash set < ntcp connection >  ( 16 )  ;     runners = new  array list <  runner >  ( 5 )  ;     live writes = new  hash set < ntcp connection >  ( 5 )  ;     write after live = new  hash set < ntcp connection >  ( 5 )  ;   }  
public  trust store   (  )  {  return trust store ;   }  
public  string   (  )  {  return home pager ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish subject 
public   ( long read limit  input stream delegate stream )  {  this . delegate stream = delegate stream ;  this . read limit = read limit ;   }  
@ xml element ( name = "user" )  @ json property ( value = "users" )  public  list <  user entity >    (  )  {  return users ;   }  
public static void   (  context context  intent broadcast intent )  {   intent i = new  intent ( context  email broadcast processor service . class )  ;  i . set action ( action   broadcast )  ;  i . put extra (  intent . extra   intent broadcast intent )  ;  context . start service ( i )  ;   }  
@ override public  entropy harvester   (  )  {  return this ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  behavior processor <  object >  p =  behavior processor . create (  )  ;  final  test subscriber <  object >  ts = p . test (  )  ;   ru
@ test public void   (  )  {  final  atomic boolean unsubscribed = new  atomic boolean ( false )  ;   action unsubscribe action = new  action (  )  {  @ override public void run (  )  {  unsubscribed . set ( true )  ;   }   }   ;   flowable . just ( 1 )  
public  string   (  )  {  return username ;   }  
@ test public void   (  )  {   string[] items = new  string[] { "one" "two" "three" }  ;  assert equals (  (  long ) 3l  flowable . from array ( items )  . count (  )  . blocking get (  )  )  ;  assert equals ( "two"  flowable . from array ( items )  . sk
@ override public void   (  jdbi db )  {  db . register extension ( new  sql object factory (  )  )  ;   }  
public static  < t extends  data structure >  list < t >    (  collection < t >  data structures )  {  if  ( data structures  =  =  null )  return  collections . empty list (  )  ;   array list < t >  rv = new  array list < t >  ( data structures )  ;  sort structure list ( rv )  ;  return rv ;   }  
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  object >   object >  (  )  {  @ override public  object apply (   flowable <  object >  f )  throws  exception  {  return f . materialize (  )  ;   }   }
@ test public void   (  )  {   blocking observable iterator <  integer >  it = new  blocking observable iterator <  integer >  ( 128 )  ;  assert false ( it . is disposed (  )  )  ;  it . dispose (  )  ;  assert true ( it . is disposed (  )  )  ;   }  
@ test ( timeout = 10000 )  public void   (  )  {  final  list <  integer >  list = new  array list <  integer >  (  )  ;   flowable . range ( 1 100 )  . take last ( 50 )  . subscribe ( new  default subscriber <  integer >  (  )  {  @ override public void
public   (  string style int port )  {  this . style = style ;  this . port = port ;   }  
public void   ( final  string str )  {  try  {  dos . writeutf ( str )  ;   }  catch  (  io exception e )   {  throw new  runtimeio exception ( e )  ;   }   }  
@ override public void   (  )  {  s . on complete (  )  ;   }  
@ test public void   (  )  {   flowable <  string >  src =  flowable . just ( "a" "b" "c" )  ;  src . first ( "default" )  . to flowable (  )  . subscribe ( w )  ;  verify ( w times ( 1 )  )  . on next ( any string (  )  )  ;  verify ( w times ( 1 )  )  .
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on backpressure drop ( null )  ;   }  
@ parameterized .  parameters ( name = "accept self signed certificates =  { 0 }  check validity =  { 1 } " )  public static  iterable <  object[] >    (  )  {  final  list <  object[] >  constructor arguments = new  array list <  >  (  )  ;  constructor 
public int   (  )  {  return sample rate ;   }  
private boolean   (  )  {     cur read state . receive block (    decrypt block buf )  ;  if  (    cur read state . get size (  )   >  buffer   size )   {  if  (    log . should log (  log . warn )  )     log . warn ( "i2np message too big  -  size: "  +     cur read state . get size (  )   +  "  dropping " +  to string (  )  )  ;     context . stat manager (  )  . add rate data ( "ntcp . corrupt too largei2np"    cur read state . get size (  )  )  ;  close (  )  ;  return false ;   }  else  {  return true ;   }   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  take last timed subscriber < t >  ( s count time unit scheduler buffer size delay error )  )  ;   }  
@ test ( data provider = "search duplicates data provider" )  public void   (  elc duplicates finder duplicates finder  histogram <  integer >  duplication histo  histogram <  integer >  optical histo  array list <  paired read sequence >  dupes int dup h
public long   (  )  {  return id ;   }  
@ override public  destination info   (  )  {  return new  destination info logic ( this )  ;   }  
public   (  )  {  this . sort order =  sort order . descending ;  this . sort field =  sort field . date ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public final void   ( @ non null  disposable resource )  {   object helper . require non null ( resource "resource is null" )  ;  resources . add ( resource )  ;   }  
@ override @ pre destroy public void   (  )  {  log . debug ( " artifact manager going down ! " )  ;  class loader context map . clear (  )  ;  try  {  event service . squelch ( this  application artifact event . class )  ;  if  ( container configuration 
public byte[]   (  )  {  return nodeid ;   }  
public  certificate store configuration   (  connection type type )  throws io exception  {  final  string key store type = get key store type ( type )  ;  final  string password = get identity store password ( type )  ;  final  string location = get identity store location ( type )  ;  final  file file = canonicalize ( location )  ;  return new  certificate store configuration ( key store type file password . to char array (  )  )  ;   }  
public void   ( boolean val )  {     shared client = val ;   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   completable c = error . completable . do on terminate ( new  action (  )  {  @ override public void run (  )  {  calls . get and increment (  )  
@ override public void   (  )  {  ps2 . on error ( ex2 )  ;   }  
@ override public  presence   (  )  {  return null ;   }  
public static  set <  string >    ( x509 certificate cert )  {   set <  string >  rv = new  hash set <  string >  ( 8 )  ;  try  {   collection <  list <  ?  >  >  c = cert . get subject alternative names (  )  ;  if  ( c  !  =  null )   {  for  (   list <  ?  >  list : c )   {  try  {  rv . add (  (  string ) list . get ( 1 )  )  ;   }  catch  (   class cast exception cce )   {   }   }   }   }  catch  (   general security exception gse )   {   }  return rv ;   }  
public void   (  string group search filter )  {  this . group search filter = group search filter ;  properties . put ( "ldap . group search filter" group search filter )  ;   }  
@ nullable @ suppress warnings ( "unchecked" )  @ override public r   (  )  throws  exception  {   object e = queue . poll (  )  ;  if  ( e  =  =  null )   {  return null ;   }  t[] a =  ( t[] ) queue . poll (  )  ;  r r =  object helper . require non nul
@ override public int   (  )  {  return  ints . checked cast (  math . min ( start  +  width basis . stop (  )  )  )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . skip last ( 1  time unit . days new  test scheduler (  )  true )  . test (  )  . assert failure (  test exception . class )  ;   }  
public boolean   (  )  {  try  {  return inf . finished (  )  ;   }  catch  (   runtime exception e )   {  return true ;   }   }  
public void   (  )  {  synchronized  (    wants pumping )   {     backlogged . remove (    ptg )  ;  if  (    wants pumping . add (    ptg )  )     wants pumping . notify (  )  ;   }   }  
@ test public void   (  )  {   notification <  integer >  notification =  notification . create on error ( new  test exception (  )  )  ;  assert null ( notification . get value (  )  )  ;  assert true ( notification . get error (  )  . to string (  )  no
  (  observer <  ?  super t >  actual long timeout  time unit unit  scheduler .  worker worker )  {  this . actual = actual ;  this . timeout = timeout ;  this . unit = unit ;  this . worker = worker ;  this . task = new  sequential disposable (  )  ;  this . upstream = new  atomic reference <  disposable >  (  )  ;   }  
@ override public void   (  )  {  s . cancel (  )  ;  s =  subscription helper . cancelled ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test helper . assert composite exceptions (  maybe . error ( new  test exception (  )  )  . on error complete ( new  predicate <  throwable >  (  )  {  @ override public boolean test (   
public   (  flowable < t >  source long timeout  time unit unit  scheduler scheduler )  {  super ( source )  ;  this . timeout = timeout ;  this . unit = unit ;  this . scheduler = scheduler ;   }  
@ override public void   ( final  disposable d )  {   disposable helper . replace ( parent d )  ;   }  
@ benchmark public void   (  blackhole bh )  {  bp range . subscribe ( new  perf subscriber ( bh )  )  ;   }  
public static void   (  simple queue <  ?  >  q )  {  try  {  q . offer ( null )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   unsupported operation exception ex )   {   }  try  {  q . offer ( null null )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   unsupported operation exception ex )   {   }   }  
private static  mail   (  file f boolean is drafts )  {   string name = f . get name (  )  ;   string uidl ;  boolean header only ;  if  ( name . ends with ( full   suffix )  )   {  uidl =  base64 . decode to string ( name . substring ( file   prefix . length (  )  name . length (  )   -  full   suffix . length (  )  )  )  ;  header only = false ;   }  else if  ( name . ends with ( hdr   suffix )  )   {  uidl =  base64 . decode to string ( name . substring ( file   prefix . length (  )  name . length (  )   -  hdr   suffix . length (  )  )  )  ;  header only = true ;   }  else  {  return null ;   }  if  ( uidl  =  =  null )  return null ;   buffer rb = read ( f )  ;  if  ( rb  =  =  null )  return null ;   mail mail ;  if  ( is drafts )  mail = new  draft ( uidl )  ;  else mail = new  mail ( uidl )  ;  if  ( header only )  mail . set header ( rb )  ;  else mail . set body ( rb )  ;  return mail ;   }  
public boolean   (  )  {  return    append ;   }  
private void   ( int[] data boolean use fast mix )  {  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )   {  if  ( data[i]  !  =  0 )   {   logger . println ( " call "  +  member  +  "  non - zero data at " +  i )  ;   logger . println ( " call "  +  member  +  " use fast mix " +  use fast mix )  ;   logger . println ( " call "  +  member  +  " " +  to abbreviated string (  )  )  ;  if  ( mix descriptors . size (  )   !  =  2 && use fast mix  =  =  true )   {   logger . println ( "use fast mix should be false !  !  ! " )  ;   }  break ;   }   }   }  
@ override public void   (  )  {   user event dispatcher . remove listener ( event handler )  ;   }  
@ override public v   ( k key v value )  {  v prior value = super . put if absent ( key value )  ;  if  (  ! value . equals ( prior value )  )   {  sync groups ( value values add )  ;  if  ( prior value  =  =  null )   {  sync groups ( key keys add )  ;  
public synchronized void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "u pnp  stop" )  ;     should be running = false ;     rescanner . cancel (  )  ;  if  (    is running )     upnp . terminate (  )  ;     is running = false ;     detected address = null ;  if  (    log . should log (  log . debug )  )     log . debug ( "u pnp  stop  done" )  ;   }  
public  abstract application context   (  string cluster id  string node id )  {   annotation config application context node context = new  annotation config application context (  )  ;  node context . set parent ( get core context (  )  )  ;  node context . set display name ( cluster id  +  " - "  +  node id +  " - context" )  ;   properties props = new  properties (  )  ;  props . put (  repose spring properties . strip spring value stupidity (  repose spring properties . node . node   id )  node id )  ;  props . put (  repose spring properties . strip spring value stupidity (  repose spring properties . node . cluster   id )  cluster id )  ;   properties property source mps = new  properties property source ( cluster id  +  " - "  +  node id +  " - " +  "props" props )  ;  node context . get environment (  )  . get property sources (  )  . add first ( mps )  ;  if  ( log . is trace enabled (  )  )   {  for  (   property source source : node context . get environment (  )  . get property sources (  )  )   {   enumerable property source eps =  (  enumerable property source ) source ;  log . trace ( "node context  -   property names for  {  } :  {  } " eps . get name (  )  eps . get property names (  )  )  ;   }   }   property sources placeholder configurer prop config = new  property sources placeholder configurer (  )  ;  prop config . set environment ( node context . get environment (  )  )  ;  node context . add bean factory post processor ( prop config )  ;   string node service package = conf . get string ( "node spring context path" )  ;  log . debug ( " creating node service context for  {  }  -  {  } " cluster id node id )  ;  log . debug ( " node service annotation scanning package  {  } " node service package )  ;  node context . scan ( node service package )  ;  node context . refresh (  )  ;  return node context ;   }  
public static  file   ( final  map <  integer  ?  extends  collection <  tile >  >  lane tiles final  file output directory final  string output prefix final  metrics file <  metric base  comparable <  ?  >  >  phasing metrics file final  string file extension final boolean is nova seq )  {  lane tiles . for each (  ( key value )   -  >   illumina phasing metrics . get phasing metrics for tiles ( key . long value (  )  value  ! is nova seq )  . for each ( phasing metrics file::add metric )  )  ;  return write metrics ( phasing metrics file output directory output prefix  illumina phasing metrics . get extension (  )   +  file extension )  ;   }  
@ suppress warnings ( "unused" )  @ test public void   (  )  {   observable <  movie >  horror movies =  observable .  <  movie > just ( new  horror movie (  )  )  ;   observable <  movie >  reduce result = horror movies . scan ( new  bi function <  movie
@ override public  string   (  )  {  return name ;   }  
public   ( int ssrc )  {  super ( ssrc true )  ;  setssrc   1 ( ssrc )  ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  node id =  externalizable util . get instance (  )  . read safeutf ( in )  ;  service id =  externalizable util . get instance (  )  . read safeutf ( in )  
public   (  router context ctx  hash peer  iterative search job job )  {  super ( ctx )  ;     peer = peer ;     search = job ;   }  
public static rtp packet   (  byte bytes[] )  throws  exception  {  if  (  array extensions . get length ( bytes )  . int value (  )   <  12 ||  ( bytes[0] . byte value (  )  & 0xc0 )   !  =  128 )  return null ;   boolean flag =  boolean . value of (  ( bytes[0] . byte value (  )  & 0x20 )   =  =  32 )  ;   boolean flag2 =  boolean . value of (  ( bytes[0] . byte value (  )  & 0x10 )   =  =  16 )  ;   byte num = new  byte (  ( byte )  ( bytes[0] . byte value (  )  & 0xf )  )  ;   boolean flag3 =  boolean . value of (  ( bytes[1] . byte value (  )  & 0x80 )   =  =  128 )  ;   byte num2 = new  byte (  ( byte )  ( bytes[1] . byte value (  )  & 0x7f )  )  ;   integer num3 =  bit assistant . to integer from short network ( bytes  integer . value of ( 2 )  )  ;   long num4 =  bit assistant . to long from integer network ( bytes  integer . value of ( 4 )  )  ;   long num5 =  bit assistant . to long from integer network ( bytes  integer . value of ( 8 )  )  ;   integer start index =  integer . value of ( 12 )  ;   long num array[] = null ;  if  ( num . byte value (  )   >  0 )   {  num array = new  long[num . byte value (  ) ] ;  for  (  integer num7 =  integer . value of ( 0 )  ;  num7 . int value (  )   <  num . byte value (  )  ;   )   {  num array[num7 . int value (  ) ] =  bit assistant . to long from integer network ( bytes start index )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;   integer integer = num7 ;   integer integer1 = num7 =  integer . value of ( num7 . int value (  )   +  1 )  ;   integer    tmp = integer ;   }   }   integer num8 =  integer . value of ( 0 )  ;   long num array2[] = null ;  if  ( flag2 . boolean value (  )  )   {  num8 =  bit assistant . to integer from short network ( bytes start index )  ;  start index =  integer . value of ( start index . int value (  )   +  2 )  ;   integer num9 =  bit assistant . to integer from short network ( bytes start index )  ;  start index =  integer . value of ( start index . int value (  )   +  2 )  ;  if  ( num9 . int value (  )   >  0 )   {  num array2 = new  long[num9 . int value (  ) ] ;  for  (  integer num7 =  integer . value of ( 0 )  ;  num7 . int value (  )   <  num9 . int value (  )  ;   )   {  num array2[num7 . int value (  ) ] =  bit assistant . to long from integer network ( bytes start index )  ;  start index =  integer . value of ( start index . int value (  )   +  4 )  ;   integer integer2 = num7 ;   integer integer3 = num7 =  integer . value of ( num7 . int value (  )   +  1 )  ;   integer    tmp1 = integer2 ;   }   }   }  rtp packet packet = new rtp packet (  bit assistant . sub array ( bytes start index )  )  ;  packet . set payload type ( num2 )  ;  packet . set padding ( flag )  ;  packet . set marker ( flag3 )  ;  packet . set sequence number ( num3 )  ;  packet . set timestamp ( num4 )  ;  packet . set synchronization source ( num5 )  ;  packet . set contributing sources ( num array )  ;  packet . set extension header ( num8 )  ;  packet . set extension ( num array2 )  ;  return packet ;   }  
static  < t r > boolean   (  object source  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper  observer <  ?  super r >  observer )  {  if  ( source instanceof  callable )   {  @ suppress warnings ( "unchecked" )   callable < t >  call =  (  callable < t >  ) source ;   single source <  ?  extends r >  cs = null ;  try  {  t item = call . call (  )  ;  if  ( item  !  =  null )   {  cs =  object helper . require non null ( mapper . apply ( item )  " the mapper returned a null  single source" )  ;   }   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   empty disposable . error ( ex observer )  ;  return true ;   }  if  ( cs  =  =  null )   {   empty disposable . complete ( observer )  ;   }  else  {  cs . subscribe (  single to observable . create ( observer )  )  ;   }  return true ;   }  return false ;   }  
@ override public void   ( int one byte )  throws io exception  {  if  ( one byte  =  =  '\n' )   {  if  ( last char  !  =  '\r' )   {  super . write ( '\r' )  ;   }   }  super . write ( one byte )  ;  last char = one byte ;   }  
@ override public void   (  servlet request request  servlet response response )  throws  servlet exception  io exception  {  if  ( proxy service  =  =  null )   {  log . warn ( " request  proxy  service is not set .  .  .  ignoring request" )  ;  return 
public static  plugin manager   (  )  {  return plugin manager ;   }  
@ override public void   ( @ non null  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  if  ( s  =  =  null )   {   throwable npe = new  null pointer exception ( " subscription not set ! " )  ;  try  {
public int   (  )  {  return requests . size (  )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  o 
@ test public void   (  )  {  try  {   rx java plugins . set fail on non blocking scheduler ( true )  ;   observable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  . map ( new  function <  integer  integer >  (  )  {  @ override public 
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . from array ( 1 null )  . blocking last (  )  ;   }  
public  socket   (  )  throws socks exception  {  setup server (  )  ;  return client sock ;   }  
public boolean   (  )  {  return get proxy host (  )   !  =  null ;   }  
@ test public void   (  )  {   flowable <  integer >  on next =  flowable . error ( new  test exception (  )  )  ;   flowable <  integer >  on complete =  flowable . from iterable (  arrays . as list ( 4 )  )  ;   flowable <  integer >  on error =  flowab
@ test ( timeout = 5000 expected =  null pointer exception . class )  public void   (  )  {   completable c =  completable . merge ( new  iterable <  completable >  (  )  {  @ override public  iterator <  completable >  iterator (  )  {  return null ;   }
@ suppress warnings ( "deprecation" )  @ test public void   (  )  throws  exception  {  final long periods[] = new long[] { 10 }  ;   rate stat rs = new  rate stat ( "test" "test  rate stat getters etc" "tests" periods )  ;  try  {  rs . add rate ( 1000 )
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  last observer < t >  ( observer )  )  ;   }  
@ override public void   (  subscriber <  ?  super t > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )   subscriber <  ?  super t > [] parents = new  subscrib
@ override public void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;  set . dispose (  )  ;  if  ( get and increment (  )   =  =  0 )   {  queue . clear (  )  ;   }   }   }  
@ test public void   (  )  {  handle . execute ( "insert into intervals ( id  foo )  values (  ?    ?  ) " 4  duration . zero )  ;   duration d = handle . create query ( "select foo from intervals where id =  ? " )  . bind ( 0 4 )  . map to (  duration . 
public void   (  plugin manager manager  file plugin directory )  {   log . info ( "["  +  name  +  "] initialize " +  name +  " plugin resources" )  ;  try  {  openfire = new  openfire (  )  ;  openfire . start (  )  ;   jmx helper . register ( openfire objectname   openfire )  ;   log . info ( "["  +  name  +  "]  .  .  started openfire server detector . " )  ;   }  catch  (   exception e )   {   log . debug ( "cannot start openfire server detector: "  +  e . get message (  )  e )  ;   }  try  {  packet counter = new  packet counter (  )  ;  packet counter . start (  )  ;   jmx helper . register ( packet counter objectname   packet   counter )  ;   log . info ( "["  +  name  +  "]  .  .  started stanza counter . " )  ;   }  catch  (   exception e )   {   log . debug ( "cannot start stanza counter: "  +  e . get message (  )  e )  ;   }  try  {  client = new  core thread pool (  (  (  connection manager impl ) xmpp server . get instance (  )  . get connection manager (  )  )  . get socket acceptor (  )  )  ;  client . start (  )  ;   jmx helper . register ( client objectname   core   client   threadpool )  ;   log . info ( "["  +  name  +  "]  .  .  started client thread pool monitor . " )  ;   }  catch  (   exception e )   {   log . debug ( "cannot start client thread pool monitor: "  +  e . get message (  )  e )  ;   }  try  {  database = new  database pool (  )  ;  database . start (  )  ;   jmx helper . register ( database objectname   databasepool )  ;   log . info ( "["  +  name  +  "]  .  .  started database pool monitor . " )  ;   }  catch  (   exception e )   {   log . debug ( "cannot start database pool monitor: "  +  e . get message (  )  e )  ;   }  try  {  try  {   log . info ( "["  +  name  +  "] starting jolokia" )  ;  context = new  web app context ( null plugin directory . get path (  )   +  " / classes" " / jolokia" )  ;  final  list <  container initializer >  initializers = new  array list <  >  (  )  ;  initializers . add ( new  container initializer ( new  jasper initializer (  )  null )  )  ;  context . set attribute ( "org . eclipse . jetty . container initializers" initializers )  ;  context . set attribute (  instance manager . class . get name (  )  new  simple instance manager (  )  )  ;  context . set welcome files ( new  string[] { "index . html" }  )  ;   log . info ( "["  +  name  +  "] starting hawtio" )  ;  context2 = new  web app context ( null plugin directory . get path (  )   +  " / classes / hawtio" " / hawtio" )  ;  final  list <  container initializer >  initializers2 = new  array list <  >  (  )  ;  initializers2 . add ( new  container initializer ( new  jasper initializer (  )  null )  )  ;  context2 . set attribute ( "org . eclipse . jetty . container initializers" initializers2 )  ;  context2 . set attribute (  instance manager . class . get name (  )  new  simple instance manager (  )  )  ;  context2 . set welcome files ( new  string[] { "index . html" }  )  ;  if  (  jive globals . get boolean property ( "xmpp . jmx . secure" true )  )   {   security handler security handler = basic auth ( "jmxweb" )  ;  if  ( security handler  !  =  null )  context . set security handler ( security handler )  ;   security handler security handler2 = basic auth ( "jmxweb" )  ;  if  ( security handler2  !  =  null )  context2 . set security handler ( security handler2 )  ;   }   http bind manager . get instance (  )  . add jetty handler ( context )  ;   http bind manager . get instance (  )  . add jetty handler ( context2 )  ;   }  catch  (   exception e )   {   log . error ( " an error has occurred" e )  ;   }   }  catch  (   exception e )   {   log . error ( " error initializing  jmx web  plugin" e )  ;   }  if  (  jive globals . get boolean property ( "jmxweb . email . monitoring" true )  )   {   log . info ( "["  +  name  +  "] starting email monitoring" )  ;  email scheduler = new  email scheduler (  )  ;  email scheduler . start monitoring (  )  ;   log . info ( "["  +  name  +  "] started monitoring" )  ;   }   }  
public void   (  date date )  {     date = date ;   }  
private  decaying bloom filter   (  )  {  long max memory =  system version . get max memory (  )  ;  int m ;  if  (  system version . is android (  )  ||  system version . isarm (  )  || max memory  <  96 * 1024 * 1024l )   {  m = 17 ;   }  else if  ( ctx . get property (  router throttle impl . prop   max   tunnels  router throttle impl . default   max   tunnels )   >   router throttle impl . default   max   tunnels && max memory  >  256 * 1024 * 1024l )   {  m = 23 ;   }  else if  ( max memory  >  256 * 1024 * 1024l )   {  m = 22 ;   }  else if  ( max memory  >  128 * 1024 * 1024l )   {  m = 21 ;   }  else  {  m = 19 ;   }  if  ( log . should info (  )  )  log . info ( " selected  bloom filter m  =  "  +  m )  ;  return new  decaying bloom filter ( ctx 60 * 60 * 1000 32 " tunnelbmp" m )  ;   }  
public   (  call event listener request handler  call participant cp )  {  this . request handler = request handler ;  this . cp = cp ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . empty (  )  . on terminate detach (  )  . subscribe ( to )  ;  to . assert no values (  )  ;  to . assert no errors (  )  ;  to . assert 
public void   ( jid tojid jid fromjid  message message )  {  if  ( message . get body (  )   !  =  null )   {  if  (  cluster manager . is senior cluster member (  )  )   {  conversation manager . process message ( fromjid tojid message . get body (  )  message . toxml (  )  new  date (  )  )  ;   }  else  {   conversation events queue events queue = conversation manager . get conversation events queue (  )  ;  events queue . add chat event ( conversation manager . get conversation key ( fromjid tojid )   conversation event . chat message received ( tojid fromjid conversation manager . is message archiving enabled (  )   ?  message . get body (  )  : null new  date (  )  )  )  ;   }   }   }  
private  string   (  )  {  return settings . get chat setting (  key enum . welcome   message )  . get value (  )  ;   }  
public void   (  )  {  assert true (  account settings utils . match provider ( "foo . com" "foo . com" )  )  ;  assert false (  account settings utils . match provider ( "foo . co" "foo . com" )  )  ;  assert false (  account settings utils . match provider ( "" "foo . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "fo ?  . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "f ?  ?  . com" )  )  ;  assert true (  account settings utils . match provider ( "fzz . com" "f ?  ?  . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" " ?  ?  ?  .  ?  ?  ? " )  )  ;  assert false (  account settings utils . match provider ( "foo . com" " ?  ?  ?  .  ?  ?  ?  ? " )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "* . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "foo . *" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "* . *" )  )  ;  assert false (  account settings utils . match provider ( "foo . com" "fox . *" )  )  ;  assert true (  account settings utils . match provider ( "foo . com" "* .  ?  ?  ? " )  )  ;  assert false (  account settings utils . match provider ( "foo . com" "* .  ? " )  )  ;  assert false (  account settings utils . match provider ( "foo . bar . com" "food . barge . comb" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "foo . bar . com" )  )  ;  assert false (  account settings utils . match provider ( "foo . bar . com" "foo . bar . gag . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "foo . * . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "foo . * . *" )  )  ;  assert false (  account settings utils . match provider ( "foo . bar . com" "foo . bar . * . *" )  )  ;  assert false (  account settings utils . match provider ( "foo . bar . com" "foo . bar . *com" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "* . bar . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "* . * . com" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "* . * . *" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "foo . bar . *" )  )  ;  assert true (  account settings utils . match provider ( "foo . bar . com" "foo .  ?  ?  ?  . *" )  )  ;  assert false (  account settings utils . match provider ( "foo . bar . com" "foo . * ?  ?  . *" )  )  ;   }  
@ override public  flowable <  boolean >    (  )  {  return  rx java plugins . on assembly ( new  flowable any < t >  ( source predicate )  )  ;   }  
public   (  )  {  super ( " personal  eventing  handler" )  ;  info = new iq handler info ( "pubsub" "http: /  / jabber . org / protocol / pubsub" )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source1 =  publish subject . create (  )  ;   publish subject <  integer >  source2 =  publish subject . create (  )  ;   observable <  integer >  duration1 =  observable .  <  integer > error (
@ before public void   (  )  {  digest = mock (  message digest . class )  ;  when ( digest . digest (  )  )  . then return ( digest bytes )  ;  stream = new  message digester output stream ( digest )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . just ( 1 )  . with latest from (  arrays . as list (  observable . just ( 2 )   observable . just ( 3 )  )  new  function <  object[]  object >  (  )  {  @ override public  o
@ override public  string   (  )  {  return description ;   }  
private boolean   (  )  {  try  {  boolean rv =    buckets lock . write lock (  )  . try lock ( 3000  time unit . milliseconds )  ;  if  (  (  ! rv )  &&    log . should log (  log . warn )  )     log . warn ( "no lock  size is: "  +     buckets lock . get queue length (  )  new  exception ( "rats" )  )  ;  return rv ;   }  catch  (   interrupted exception ie )   {   }  return false ;   }  
public static boolean   (  string host int port boolean isssl enabled  string user  string password  string folder name )  {   folder folder = open folder ( host port isssl enabled user password folder name )  ;  boolean success = folder  !  =  null && folder . is open (  )  ;  close folder ( folder null )  ;  return success ;   }  
public void   ( int x int y )  {  int offset = y * row size  +   ( x  /  32 )  ;  bits[offset]& = ~ ( 1  <  <   ( x & 0x1f )  )  ;   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . on terminate detach (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
private void   ( int flags )  {     flags = flags ;   }  
public  collection <  request queue >    (  )  {  final  list <  request queue >  queue list = new  array list <  request queue >  ( queues . values (  )  )  ;   collections . sort ( queue list queue comparator )  ;  return  collections . unmodifiable list ( queue list )  ;   }  
public int   (  string page name int default value )  {  return get page property ( page name "console . rows   per   page" default value )  ;   }  
@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {  statement . set string ( position uuid . to string (  )  )  ;   }  
public   (  router context ctx )  {     context = ctx ;   }  
public  handle   (  )  {  transactions . begin ( this )  ;  log . trace ( " handle [ {  } ] begin transaction" this )  ;  return this ;   }  
public  signing public key   (  )  {  return    signing key ;   }  
@ override public boolean   ( t e )  {  boolean added = super . add if absent ( e )  ;  if  ( added )   {  sync groups ( e add )  ;   }  return added ;   }  
@ before class @ suppress warnings ( "unchecked" )  public static void   (  )  throws jaxb exception  {  xml transformer = new  stream to jaxb transform ( jaxb context . new instance ( org . openrepose . filters . versioning . schema .  object factory . c
public   ( final  file file )  {  bfr = new  barcode file reader ( file )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . concat with (  maybe . just ( 2 )  )  . test (  )  . assert no errors (  )  . assert complete (  )  . assert values ( 1 2 )  ;   }  
public boolean   (  )  {   string protocol =  bridge . get default protocol (  )  ;  if  ( cp . get protocol (  )   !  =  null )   {  protocol = cp . get protocol (  )  ;   }  if  ( protocol . equals ignore case ( " web rtc" )  || protocol . equals ignore case ( " rtmfp" )  || protocol . equals ignore case ( " speaker" )  )   {  return true ;   }  synchronized  ( wait call answer lock )   {  if  ( done || reason call ended  !  =  null )   {  return false ;   }  try  {  wait call answer lock . wait (  )  ;   }  catch  (   interrupted exception e )   {   }   }  if  ( done || reason call ended  !  =  null )   {  return false ;   }  return true ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  mergen sync streams ofn ( 1000 1000 )  . subscribe ( ts )  ;  ts . await terminal event (  )  ;  ts . assert no errors (  )  ;  assert equals ( 1
public  list < i2np message >    (  )  {   list < i2np message >  rv =    received ;     received = new  array list < i2np message >  (  )  ;  return rv ;   }  
@ check return value @ scheduler support (  scheduler support . none )  @ experimental public final  < r >  observable < r >    (  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper int prefetch )  {   object helper . require n
public static void   (  string[] args )  {   system . out . println ( "64 bit : "  +  is64 bit (  )  )  ;   system . out . println ( " java 6 : "  +  is java6 (  )  )  ;   system . out . println ( " java 7 : "  +  is java7 (  )  )  ;   system . out . println ( " java 8 : "  +  is java8 (  )  )  ;   system . out . println ( " java 9 : "  +  is java9 (  )  )  ;   system . out . println ( " java 10 : "  +  is java10 (  )  )  ;   system . out . println ( " android : "  +  is android (  )  )  ;  if  ( is android (  )  )   system . out . println ( "  version: "  +  get android version (  )  )  ;   system . out . println ( " apache : "  +  is apache (  )  )  ;   system . out . println ( "arm : "  +  isarm (  )  )  ;   system . out . println ( " cores : "  +  get cores (  )  )  ;   system . out . println ( " gentoo : "  +  is gentoo (  )  )  ;   system . out . println ( "gnu : "  +  isgnu (  )  )  ;   system . out . println ( " linux  svc: "  +  is linux service (  )  )  ;   system . out . println ( " mac : "  +  is mac (  )  )  ;   system . out . println ( " openjdk : "  +  is openjdk (  )  )  ;   system . out . println ( " slow : "  +  is slow (  )  )  ;   system . out . println ( " windows : "  +  is windows (  )  )  ;   system . out . println ( " wrapper : "  +  has wrapper (  )  )  ;   system . out . println ( "x86 : "  +  isx86 (  )  )  ;   system . out . println ( " max mem : "  +  get max memory (  )  )  ;   }  
@ override public void   (  string hashed key byte[] id final  serializable value final int ttl final  time unit time unit  remote behavior remote behavior )  {  perform action ( hashed key id new  datastore action (  )  {  @ override public  object perfo
@ override protected void   ( final  byte buffer buffer )  {  buffer . put int ( 1 )  ;  buffer . put float ( 1 . 0f )  ;  buffer . put int ( 1 )  ;  for  ( int count = 0 ;  count  <  tiles . size (  )  ;  count +  +  )   {  buffer . put float ( 5 . 0f  +
@ override public void   (  )  {  s . on subscribe ( bs2 )  ;   }  
@ override public void   (  throwable e )  {  lazy set (  disposable helper . disposed )  ;  try  {  on error . accept ( e )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( new  composite except
public long   (  )  {  return  data helper . from long (    data off   send   tunnel 4 )  ;   }  
public synchronized void   (  )  {  change state ( starting )  ;     current news =  persist news . load (    context )  ;  if  (    log . should warn (  )  )     log . warn ( " initialized with "  +     current news . size (  )   +  " entries" )  ;  change state ( running )  ;  if  (    cmgr  !  =  null )     cmgr . register ( this )  ;   }  
@ test @ ignore ( " null values are not allowed" )  public void   (  )  {   observable <  string >  w =  observable . from iterable (  arrays . as list ( "one" null "three" )  )  ;   single <  list <  string >  >  observable = w . to list (  )  ;   single
@ test public void   (  )  {   date date = new  date (  )  ;   calendar calendar = new  gregorian calendar (  time zone . get time zone ( "gmt" )  )  ;  calendar . set time ( date )  ;  long start =  system . current time millis (  )  ;  for  ( int i = 0 
@ override public void   (  completable observer s )  {  throw new  illegal argument exception (  )  ;   }  
long   (  )  {  return last byte write ;   }  
@ test public void   (  )  {  assert invalid domain name ( "www . my   company . com" " contains non - ldh characters" )  ;  assert invalid domain name ( "www .  - dash . com" " has leading or trailing hyphen" )  ;  assert invalid domain name ( "www . das
@ test public void   (  )  {   test helper . check disposed (  observable . switch on next (  observable . just (  observable . just ( 1 )  )  . hide (  )  )  )  ;   }  
@ override public void   ( final  throwable e )  {  set . add ( scheduler . schedule direct ( new  on error ( e )  delay error  ?  delay : 0 unit )  )  ;   }  
public void   ( ssdp packet ssdp packet )  {  int listener size = device search response listener list . size (  )  ;  for  ( int n = 0 ;  n  <  listener size ;  n +  +  )   {   search response listener listener =  (  search response listener ) device search response listener list . get ( n )  ;  try  {  listener . device search response received ( ssdp packet )  ;   }  catch  (   exception e )   {   debug . warning ( " search response listener returned an error:" e )  ;   }   }   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public  binary writer   (  )  {  return f ;   }  
public   (  snark s )  {  snark = s ;   }  
@ non null public  observable < t >    (  )  {  return  rx java plugins . on assembly ( new  observable ref count < t >  ( this )  )  ;   }  
public  string   (  )  {  if  (  !    is running )  return " < h3 >  < a name = \"upnp\" >  <  / a > "  +     t ( "u pnp is not enabled" )   +  " <  / h3 > \n" ;  return    upnp . render statushtml (  )  ;   }  
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  completable subject cs =  completable subject . create (  )  ;   test observer <  void >  to = pp . switch map completable delay error ( 
public void   (  object obj )  {  b = obj ;   }  
private void   (  string conference id )  {  try  {   log . info ( " jitsi  videobridge  detaching .  . "  +  conference id )  ;   call handler call handler =  call handler . find call ( "colibri - "  +  conference id )  ;  if  ( call handler  !  =  null )   {   call handler . hangup ( "colibri - "  +  conference id " detaching from  jitsi  videobridge" )  ;   }   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  
public long   (  )  {  return    enqueue time ;   }  
@ test public void   (  )  {   observable . just ( 1 2 3 )  . element at or error ( 3 )  . test (  )  . assert no values (  )  . assert error (  no such element exception . class )  ;   }  
public long   (  )  {  return    receive charlie time ;   }  
@ test ( timeout = 2000 )  @ ignore ( " publish processor no longer emits without requests so this test fails due to the race of on complete and request" )  public void   (  )  {   scheduler .  worker w =  schedulers . new thread (  )  . create worker (  
@ test public void   (  )  throws  exception  {  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  h . create update ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  . execute (  )  
public synchronized boolean   ( o element )  {  if  ( elements  =  =  null )  return false ;  return elements[elements . length  -  1] . equals ( element )  ;   }  
@ test public void   (  )  throws  exception  {   system . out . println ( "skip" )  ;  long n = 0l ;   byte buffer input stream instance = null ;  long exp result = 0l ;  long result = instance . skip ( n )  ;  assert equals ( exp result result )  ;  fai
@ override public void   (  string property  map <  string  object >  params )  {  process property value change ( property params )  ;   }  
public synchronized  adapter marker   ( final int min pair match bases )  {  this . min pair match bases = min pair match bases ;  return this ;   }  
public  string   (  )  {  return toxml string ( true )  ;   }  
public   (  command command  string[] args )  {  this . my command = command ;  this . args =  arrays . copy of ( args args . length )  ;   }  
public void   (  string event name  object args )  {  if  (    ignore )  return ;  if  ( args  =  =  null )   {  args = "[null value]" ;   }     events . put ( event name args )  ;  synchronized  (    events )   {     events . notify all (  )  ;   }  for  (   event dispatcher e :    attached )   {  e . notify event ( event name args )  ;   }   }  
  ( int max size )  {  this . max size =  object helper . verify positive ( max size "max size" )  ;   node <  object >  h = new  node <  object >  ( null )  ;  this . tail = h ;  this . head = h ;   }  
public void   ( i2p server socket sock )  {  for  ( int i = 0 ;  i  <     handlers ;  i +  +  )   {  i2p thread t = new i2p thread ( new  client runner ( sock )  )  ;  t . set name ( " handler "  +  i )  ;  t . set daemon ( false )  ;  t . start (  )  ;   }   }  
@ override public  observable <  integer >    (  integer v )  throws  exception  {  return  observable . range ( 1 50 )  . reduce ( second )  . to observable (  )  ;   }  
  (  callable <  ?  extends  connectable flowable < u >  >  connectable factory  function <  ?  super  flowable < u >   ?  extends  publisher < r >  >  selector )  {  this . connectable factory = connectable factory ;  this . selector = selector ;   }  
@ check return value @ scheduler support (  scheduler support . none )  @ backpressure support (  backpressure kind . full )  public static  completable   (  publisher <  ?  extends  completable source >  sources int max concurrency )  {  return merge0 ( 
public void   (  )  {   garlic message receiver recv = new  garlic message receiver ( get context (  )  this )  ;  recv . receive (    message )  ;   }  
public boolean   (  version other version )  {  return this . compare to ( other version )   >  0 ;   }  
@ test public void   (  )  {   test helper . check utility class (  exceptions . class )  ;   }  
@ override public void   ( oscar buddy oscar buddy )  {   string legacy id = get transport (  )  . convertjid toid ( oscar buddy . getjid (  )  )  ;  for  (   buddy item i : oscar buddy . get buddy items (  )  )   {  if  ( i . get screenname (  )  . equal
@ override public void   (  )  {  inner complete ( this )  ;   }  
public void   ( boolean drawy grid )  {  this . drawy grid = drawy grid ;   }  
public  pf data   (  )  {  final boolean next value = reader . next (  )  ;  return new  pf data (  )  {  public boolean is pf (  )  {  return next value ;   }   }   ;   }  
public synchronized  nio socket acceptor   (  )  {  return socket acceptor ;   }  
public int   (  )  {  return decodes ;   }  
public void   (  string builder buf )  {  buf . append ( " < b > dht tracker: <  / b >  " )  . append (    torrent count )  . append ( " torrents " )  . append (    peer count )  . append ( " peers " )  . append (  data helper . format duration (    expire time )  )  . append ( " expiration < br > " )  ;   }  
  (  subscriber <  ?  super  notification < t >  >  actual )  {  super ( actual )  ;   }  
@ test public void   (  )  {   maybe . concat ( new  crashing mapped iterable <  maybe <  integer >  >  ( 100 1 100 new  function <  integer  maybe <  integer >  >  (  )  {  @ override public  maybe <  integer >  apply (   integer v )  throws  exception  
public int   (  )  {  return total requests not compressed ;   }  
private  string   (  )  {  return get service type (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  sampler =  publish subject . create (  )  ;   observable <  integer >  m = source . sample ( sampler )  ;  m . subscrib
public  string   (  )  {  return  merge sam files . class . get simple name (  )  ;   }  
@ test public void   (  )  throws  exception  {  check internal operator naming ( " observable" " producer" )  ;   }  
public static  < t >  connectable flowable < t >    (  flowable < t >  source final int buffer size )  {  final  atomic reference <  publish subscriber < t >  >  curr = new  atomic reference <  publish subscriber < t >  >  (  )  ;   publisher < t >  on subscribe = new  flowable publisher < t >  ( curr buffer size )  ;  return  rx java plugins . on assembly ( new  flowable publish < t >  ( on subscribe source curr buffer size )  )  ;   }  
private  duplication metrics   ( final sam record record )  {  final  string library =  library id generator . get library name ( header record )  ;   duplication metrics metrics = library id generator . get metrics by library ( library )  ;  if  ( metrics  =  =  null )   {  metrics = new  duplication metrics (  )  ;  metrics . library = library ;  library id generator . add metrics by library ( library metrics )  ;   }  return metrics ;   }  
public void   (  packet packet )  {   interceptor manager interceptor manager =  workgroup interceptor manager . get instance (  )  ;  try  {  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false false )  ;   workgroup manager . get instance (  )  . send ( packet )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  packet false true )  ;   }  catch  (   packet rejected exception e )   {   log . warn ( " packet was not sent "  +  "due to interceptor rejection: "  +  packet . toxml (  )  e )  ;   }   }  
@ test public void   (  )  {   completable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  throw new  test exception (  )  ;   }   }   new  function <  object  completable source >  (  )  {  @ overr
public udp address   (  )  {  return    remote address ;   }  
@ override public void   (  )  {  done = true ;  drain (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  ps . on complete (  )  ;   publish subject <  integer >  ps2 =  publish subject . create (  )  ;  ps2 . subscribe ( ps )  ;  assert false ( ps2 . has obse
@ override public void   (  integer value )  {  assert false ( qd . is empty (  )  )  ;  qd . clear (  )  ;  assert true ( qd . is empty (  )  )  ;  qd . dispose (  )  ;   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer ( 3 )  ;  final  atomic integer number of subscribe calls = new  atomic integer ( 0 )  ;   completable . from action ( new  action (  )  {  @ override public void run
public i2cp message   (  )  {  return    in . poll (  )  ;   }  
public  random source   (  )  {  if  (  !    random initialized )  initialize random (  )  ;  return    random ;   }  
@ override public void   (  observer <  ?  super t >  t )  {   switch if empty observer < t >  parent = new  switch if empty observer < t >  ( t other )  ;  t . on subscribe ( parent . arbiter )  ;  source . subscribe ( parent )  ;   }  
private boolean   (  mail mail )  {   buffer rb = mail . get body (  )  ;  if  ( rb  !  =  null )   {   file f = get full file ( mail . uidl )  ;  if  ( f . exists (  )  )  return true ;  boolean rv = write ( rb f )  ;  if  ( rv )  get header file ( mail . uidl )  . delete (  )  ;  return rv ;   }  rb = mail . get header (  )  ;  if  ( rb  !  =  null )   {   file f = get header file ( mail . uidl )  ;  if  ( f . exists (  )  )  return true ;  boolean rv = write ( rb f )  ;  return rv ;   }  return false ;   }  
public  collection <  group >    ( jid user )  {   string key = user . to barejid (  )  ;   collection <  string >  group names =  (  collection <  string >  ) group meta cache . get ( key )  ;  if  ( group names  =  =  null )   {  synchronized  ( key . intern (  )  )   {  group names =  (  collection <  string >  ) group meta cache . get ( key )  ;  if  ( group names  =  =  null )   {  group names = provider . get group names ( user )  ;  group meta cache . put ( key group names )  ;   }   }   }  return new  group collection ( group names )  ;   }  
public int   (  )  throws sql exception  {  return pstmt . execute update (  )  ;   }  
@ override public void   (  string username  string name )  throws  user not found exception  {  throw new  unsupported operation exception ( " setting user name not implemented by this version of user provider" )  ;   }  
int   (  )  {  return observers . get (  )  . length ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  list <  object >  >  >  (  )  {  @ override public  observable source <  list <  object >  >  apply (   obse
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   single . error ( new  test exception ( " outer" )  )  . do on subscribe ( new  consumer <  disposable >  (  )  {  @ override public void acce
private long   (  )  {  return    executor . get completed task count (  )  ;   }  
@ test public void   (  )  {   observable <  string >  w =  observable . just ( "one" "two" "three" )  ;   observable <  string >  take = w . take while ( new  predicate <  string >  (  )  {  int index ;  @ override public boolean test (   string input ) 
@ test public void   (  )  {   observer <  integer >  consumer = new  disposable observer <  integer >  (  )  {  @ override public void on next (   integer t )  {   }  @ override public void on error (   throwable t )  {   }  @ override public void on com
public double   ( long timestamp )  {  if  ( interpolation method  =  =  interpolate   regression )   {  return b0  +  b1 * timestamp ;   }  int count = timestamps . length ;  if  ( timestamp  <  timestamps[0] || timestamp  >  timestamps[count  -  1] )   {  return  double .  nan ;   }  int start index = last index used ;  if  ( timestamp  <  timestamps[last index used] )   {  start index = 0 ;   }  for  ( int i = start index ;  i  <  count ;  i +  +  )   {  if  ( timestamps[i]  =  =  timestamp )   {  return values[i] ;   }  if  ( i  <  count  -  1 && timestamps[i]  <  timestamp && timestamp  <  timestamps[i  +  1] )   {  last index used = i ;  switch  ( interpolation method )   {  case interpolate   left: return values[i] ;  case interpolate   right: return values[i  +  1] ;  case interpolate   linear: double slope =  ( values[i  +  1]  -  values[i] )   /   ( timestamps[i  +  1]  -  timestamps[i] )  ;  return values[i]  +  slope *  ( timestamp  -  timestamps[i] )  ;  default : return  double .  nan ;   }   }   }  return  double .  nan ;   }  
public void   (  string password )  {  this . password = password ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   publisher <  boolean >  >  (  )  {  @ override public  publisher <  boolean >  apply (   flowable <  object >  o )  throws  exception
public  string   (  )  {  return name ;   }  
@ override public int   (  data input in  collection <  ?  extends  serializable >  value  class loader loader )  throws io exception  {  return 0 ;   }  
public  string   (  )  {  return name ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   atomic long requested = new  atomic long ( 1 )  ;  assert equals ( 0  backpressure helper . produced cancel ( requested 2 )  )  ;   test helper
@ override protected void   (  observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 1 )  ;  observer . on next ( 2 )  ;  observer . on error ( new  test exception (  )  )  ;  obser
@ test public void   (  )  {   flowable . just ( 1 )  . debounce (  functions . just function (  flowable . empty (  )  )  )  . test (  )  . assert result ( 1 )  ;   }  
public void   (  session session )  {  for  (   persistence manager pm : persistence managers )   {  pm . set online ( session )  ;   }   }  
public  data structure   (  )  {  return new  router identity (  )  ;   }  
protected void   (  )  {     context = i2p app context . get global context (  )  ;   object o = yk generator . class ;   }  
public   ( byte[] nodeid jid address )  {  super ( nodeid address )  ;   }  
public int   (  )  {  return min port ;   }  
public long   ( long n )  {  return  backpressure helper . produced cancel ( this n )  ;   }  
private void   (  )  {  for  (   string prop :    ctx . get property names (  )  )   {  if  (  ! prop . starts with ( prop   pfx )  )  continue ;   string key =    ctx . get property ( prop )  ;  if  ( key  =  =  null || key . length (  )   !  =  44 )  continue ;   string hb = prop . substring ( prop   pfx . length (  )  )  ;  hb = hb . replace ( "$" " = " )  ;   hash dest = new  hash (  )  ;   session key sk = new  session key (  )  ;  try  {  dest . from base64 ( hb )  ;  sk . from base64 ( key )  ;  super . put ( dest sk )  ;   }  catch  (   data format exception dfe )   {  continue ;   }   }   }  
void   ( int x int y double angle )  {  gd . translate ( x y )  ;  gd . rotate ( angle )  ;   }  
@ xml element public boolean   (  )  {  return persistent ;   }  
public   (  string element  attributes impl attrs )  {  this . element = element ;  this . attrs = attrs ;   }  
private void   (  )  {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  succeeded search for key "  +     state . get target (  )  +  " after querying " +     state . get attempted (  )  . size (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( get job id (  )   +  ":  state of successful search: "  +     state )  ;  if  (    keep stats )   {  long time = get context (  )  . clock (  )  . now (  )   -     state . get when started (  )  ;  get context (  )  . stat manager (  )  . add rate data ( "net db . success time" time )  ;  get context (  )  . stat manager (  )  . add rate data ( "net db . success peers"    state . get attempted (  )  . size (  )  time )  ;   }  if  (    on success  !  =  null )  get context (  )  . job queue (  )  . add job (    on success )  ;     facade . search complete (    state . get target (  )  )  ;  handle deferred ( true )  ;  resend (  )  ;   }  
  (  replay subject <  string >  subject )  {  this . subject = subject ;   }  
@ override public  string   (  )  {  return name ;   }  
public void   ( final int big duplicate set size )  {  this . big duplicate set size = big duplicate set size ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to multimap ( null )  ;   }  
public boolean   (  )  {  return is sandy compatible ;   }  
public synchronized static void   (  )  {  if  (    instance  !  =  null )     instance . stop (  )  ;  try  {   thread . sleep ( 3000 )  ;   }  catch  (   interrupted exception ie )   {   }   system . exit ( 1 )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer counter = new  atomic integer (  )  ;   connectable flowable <  string >  o =  flowable .  <  string > unsafe create ( new  publisher <  string >  (  )  {  @ override publi
void   (  session id sid  message id id long nonce )  {  if  (    dont sendmsm || nonce  =  =  0 )  return ;  if  (    log . should log (  log . debug )  )     log . debug ( " acking message send [accepted]"  +  id  +  "  /  " +  nonce +  " for session id " +  sid )  ;   message status message status = new  message status message (  )  ;  status . set message id ( id . get message id (  )  )  ;  status . set session id ( sid . get session id (  )  )  ;  status . set size ( 0l )  ;  status . set nonce ( nonce )  ;  status . set status (  message status message . status   send   accepted )  ;  try  {  do send ( status )  ;     accepted pending . remove ( id )  ;   }  catch  (  i2cp message exception ime )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error writing out the message status message" ime )  ;   }   }  
public void   (  packet packet )  {  try  {  if  ( packet instanceof iq )   {  if  ( process (  ( iq ) packet )  )   {  return ;   }   }  try  {   workgroup workgroup = get workgroup ( packet . get to (  )  )  ;  workgroup . process ( packet )  ;   }  catch  (   user not found exception e )   {  if  ( packet instanceof  presence )   {  if  (  (  (  presence ) packet )  . get type (  )   =  =   presence .  type . error )   {  return ;   }   presence reply = new  presence (  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( packet . get from (  )  )  ;  reply . set from ( packet . get to (  )  )  ;  reply . set error (  packet error .  condition . not   authorized )  ;  send ( reply )  ;   }  else if  ( packet instanceof iq )   {  if  (  (  ( iq ) packet )  . get type (  )   =  =  iq .  type . error )   {  return ;   }  iq reply = iq . create resultiq (  ( iq ) packet )  ;  reply . set child element (  (  ( iq ) packet )  . get child element (  )  . create copy (  )  )  ;  reply . set error (  packet error .  condition . not   authorized )  ;  send ( reply )  ;   }  else  {  if  (  (  (  message ) packet )  . get type (  )   =  =   message .  type . error )   {  return ;   }   message reply = new  message (  )  ;  reply . setid ( packet . getid (  )  )  ;  reply . set to ( packet . get from (  )  )  ;  reply . set from ( packet . get to (  )  )  ;  reply . set error (  packet error .  condition . not   authorized )  ;  send ( reply )  ;   }   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
@ test public void   (  )  {   single . just ( 1 )  . map ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (  final  integer integer )  throws  exception  {  return null ;   }   }   )
public void   (  string f )  {  try  {     port =  integer . parse int ( f )  ;   }  catch  (   number format exception nfe )   {   }   }  
public void   (  string nonce )  {  synchronized  ( nonces )   {  nonces . add ( 0 nonce )  ;  if  ( nonces . size (  )   >  max   nonces )   {  nonces . remove ( max   nonces )  ;   }   }   }  
public static  string   (  )  {  return sip config . stun server ;   }  
@ test public void   (  )  {  final  string template = "% >  ! 100 200 300 { somevar format1 format2 } i" ;  final  log argument group extractor expected =  log argument group extractor . instance ( " > " " ! 100 200 300" "somevar" "format1 format2" "i" )
public void   (  message id id )  {     message id = id ;   }  
  (  window boundary main subscriber < t b  ?  >  parent )  {  this . parent = parent ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  other =  publish processor . create (  )  ;   flowable <  integer >  result = source . with latest from ( other c
public void   (  )  {  int n sockets = size (  )  ;  for  ( int n = 0 ;  n  <  n sockets ;  n +  +  )   {  ssdp search response socket sock = getssdp search response socket ( n )  ;  sock . start (  )  ;   }   }  
public boolean   ( byte iv data[] int iv offset byte payload[] int payload offset )  {  if  (    filter  =  =  null )  return true ;  byte[] buf =  simple byte cache . acquire (  hop processor . iv   length )  ;   data helper . xor ( iv data iv offset payload payload offset buf 0  hop processor . iv   length )  ;  boolean dup =    filter . add ( buf )  ;   simple byte cache . release ( buf )  ;  if  ( dup )     context . stat manager (  )  . add rate data ( "tunnel . duplicateiv" 1 )  ;  return  ! dup ;   }  
public   (  member member  long joined time )  {  hostname = member . get socket address (  )  . get host string (  )  ;  nodeid =  nodeid . get instance (  string utils . get bytes ( member . get uuid (  )  )  )  ;  this . joined time = joined time ;  senior member =  cluster manager . get senior cluster member (  )  . equals (  string utils . get bytes ( member . get uuid (  )  )  )  ;   }  
@ override public  boolean   (  )  {  return false ;   }  
@ override protected  string   (  )  {  return " clocs file reader ( file = "  +  get file (  )  . get name (  )   +  "  lane = " +  get lane (  )  +  "  tile = " +  get tile (  )  +  "  current bin = " +  current bin +  "  num bins = " +  num bins +  "  
public   ( int port  string name  string address boolean is secure  string algorithm  type type )  {  this . port = port ;  this . names . add ( name )  ;  this . address = address ;  this . secure = is secure ;  this . algorithm = algorithm ;  this . type = type ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }   array deque < c >  bs = buffers ;  int i = index ;  if  ( i +  +   =  =  0 )   {  c b ;  try  {  b =  object helper . require non null ( buffer supplier . call (  )  " the buffer suppli
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write int ( out event . ordinal (  )  )  ;   externalizable util . get instance (  )  . write safeutf ( out service )  ;   externalizable 
@ test public void   (  )  {   single . just ( 1 )  . to maybe (  )  . to single (  )  . test (  )  . assert result ( 1 )  ;   }  
public   (  string name long nonce )  {  this . hash = null ;  this . name = name ;  this . nonce = nonce ;   }  
@ override public  data structure   (  )  throws  data format exception  {   date and flags daf = new  date and flags (  )  ;  daf . set date ( 0 )  ;  daf . set flags ( 0 )  ;  return daf ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe . from single (  publish processor . create (  )  . single or error (  )  )  )  ;   }  
@ override public  output stream   (  )  throws io exception  {   output stream rv =    socket . get output stream (  )  ;  if  ( rv  !  =  null )  return rv ;  throw new io exception ( " no stream" )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  test observer . create (  )  ;  to . assert not terminated (  )  ;  to . on error ( null )  ;  try  {  to . assert not terminated (  )  ;  throw new  runtime exception ( " should have thrown
@ override public void   (  disposable d )  {  if  (  disposable helper . set once ( this d )  )   {  actual . on subscribe ( this )  ;   }   }  
private void   (  transport transport )  {  if  ( transport  =  =  null )  return ;   transport old =    transports . put ( transport . get style (  )  transport )  ;  if  ( old  !  =  null && old  !  =  transport &&    log . should log (  log . warn )  )     log . warn ( " replacing transport "  +  transport . get style (  )  )  ;  transport . set listener ( this )  ;   }  
public boolean   ( iq packet )  {  return false ;   }  
public void   (  )  {  if  ( m )   {  m = false ;  if  ( k  !  =  null )  k . on disconnection ( this )  ;   }   }  
public static void   ( muc room room )  {  if  (  ! room . is persistent (  )  ||  ! room . was saved todb (  )  )   {  return ;   }   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( update   subject )  ;  pstmt . set string ( 1 room . get subject (  )  )  ;  pstmt . set long ( 2 room . getid (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  completable . complete (  )  . and then (  single . just ( 1 )  )  )  ;   }  
boolean   (  )  {  u b ;  try  {  b =  object helper . require non null ( buffer supplier . call (  )  " empty buffer supplied" )  ;   }  catch  (   throwable t )   {   exceptions . throw if fatal ( t )  ;  buffer = null ;  if  ( s  =  =  null )   {   empty disposable . error ( t actual )  ;   }  else  {  s . dispose (  )  ;  actual . on error ( t )  ;   }  return false ;   }  buffer = b ;  return true ;   }  
private boolean   (  input stream in )  throws io exception  {  int c = in . read (  )  ;  if  ( c  =  =  ' - ' )   {  c = in . read (  )  ;  if  ( c  !  =  ' - ' )   {  if  (    log . should debug (  )  )     log . debug ( " unexpected char after boundary - : "  +  c )  ;  return true ;   }  c = in . read (  )  ;  if  ( c  =  =   - 1 )   {  return true ;   }  if  ( c  !  =  '\r' )   {  if  (    log . should debug (  )  )     log . debug ( " unexpected char after boundary -  - : "  +  c )  ;  return true ;   }  c = in . read (  )  ;  if  ( c  !  =  '\n' )  if  (    log . should debug (  )  )     log . debug ( " unexpected char after boundary -  - \\r: "  +  c )  ;  return true ;   }  else if  ( c  =  =  '\r' )   {  c = in . read (  )  ;  if  ( c  !  =  '\n' )  if  (    log . should debug (  )  )     log . debug ( " unexpected char after boundary\\r: "  +  c )  ;   }  else  {  if  (    log . should debug (  )  )     log . debug ( " unexpected char after boundary: "  +  c )  ;   }  return c  =  =   - 1 ;   }  
public  transport session < b >    (  )  {  return transport session ref . get (  )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  element at subscriber < t >  ( s index default value error on fewer )  )  ;   }  
public static void   (  sender callback listener listener )  {  synchronized  ( sender callback list )   {  sender callback list . add ( listener )  ;   }   }  
public v   ( k key )  {  if  ( n keys  =  =  0 )   {  return null ;   }  if  ( keys[n keys  -  1] . compare to ( key )   <  0 )   {  if  ( next  =  =  null )   {  return null ;   }  return next . get ( key )  ;   }  int loc = binary search ( key )  ;  if  ( loc  <  0 )   {  return null ;   }  return vals[loc] ;   }  
public long   (  )  {  return creation stamp ;   }  
@ test public void   (  )  {   single <  integer >  observable =  flowable . just ( 1 2 3 4 5 6 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . last ( 8 )  ;  
public long   (  )  {  return wanted bytes ;   }  
private boolean   ( final  physical location lhs final  physical location rhs final int distance )  {  return lhs  !  =  rhs && lhs . has location (  )  && rhs . has location (  )  && lhs . get read group (  )   =  =  rhs . get read group (  )  && lhs . get tile (  )   =  =  rhs . get tile (  )  &&  math . abs ( lhs . getx (  )   -  rhs . getx (  )  )   <  =  distance &&  math . abs ( lhs . gety (  )   -  rhs . gety (  )  )   <  =  distance ;   }  
public void   (  string source byte[] data int offset int len )  {  if  (  ( offset  =  =  0 )  &&  ( len  =  =  data . length )  )   {  set seed ( data )  ;   }  else  {  set seed (    context . sha (  )  . calculate hash ( data offset len )  . get data (  )  )  ;   }   }  
static void   (  cyclic barrier cb )  {  try  {  cb . await (  )  ;   }  catch  (   interrupted exception ex )   {  ex . print stack trace (  )  ;   }  catch  (   broken barrier exception ex )   {  ex . print stack trace (  )  ;   }   }  
private  histogram <  integer >    ( final int depth final int count )  {  final  histogram <  integer >  histogram = new  histogram <  >  (  )  ;  histogram . increment ( depth count )  ;  return histogram ;   }  
public boolean   (  string parameter name )  throws sql exception  {  return cstmt . get boolean ( parameter name )  ;   }  
public  macro group   ( int location )  {  return macro groups . get ( location )  ;   }  
public  string   (  )  {  try  {  if  (    out  !  =  null )   {  render statushtml (    out )  ;  return "" ;   }  else  {   string writer sw = new  string writer ( 32 * 1024 )  ;  render statushtml ( sw )  ;  return sw . to string (  )  ;   }   }  catch  (  io exception ioe )   {  ioe . print stack trace (  )  ;  return "" ;   }   }  
public void   (  message payload message msg )  {   long mid =  long . value of ( msg . get message id (  )  )  ;     available messages . put ( mid msg )  ;  long id = msg . get message id (  )  ;  byte data[] = msg . get payload (  )  . get unencrypted data (  )  ;  if  (  ( data  =  =  null )  ||  ( data . length  <  =  0 )  )   {  if  (    log . should log (  log . crit )  )     log . log (  log . crit get prefix (  )   +  "add new message of a message with no unencrypted data" new  exception ( " empty message" )  )  ;   }  else  {  int size = data . length ;     availability notifier . available ( id size )  ;  if  (    log . should log (  log . info )  )     log . info ( get prefix (  )   +  " notified availability for session "  +     session id +  "  message " +  id )  ;   }   }  
public int   (  )  {  return  email service version . current ;   }  
public   (  inet address host int port  string destination  logging l  event dispatcher notify this i2p tunnel tunnel )  {  super ( destination l notify this tunnel )  ;  this . sink = new udp sink ( host port )  ;  set sink ( this . sink )  ;  this . pinger = new  pinger (  )  ;  this . pinger . set sink ( this )  ;   }  
@ before public void   (  )  throws  exception  {  datastore = mock (  datastore . class )  ;  rate limit cache = new  managed rate limit cache ( datastore )  ;  default config . set uri ( " . *" )  ;  default config . set uri regex ( " . *" )  ;  default
void   (  )  {  if  (  !    store lock . compare and set ( false true )  )  return ;  try  {   set <  hash >  peers = select peers (  )  ;  for  (   hash peer : peers )   {  store profile ( peer )  ;   }   }  finally  {     store lock . set ( false )  ;   }   }  
@ override protected void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 2 )  ;  s . on error ( new  test exception (  )  )  ;   }  
  (  observer <  ?  super u >  actual  callable < u >  buffer supplier long timespan  time unit unit int max size boolean restart on max size  worker w )  {  super ( actual new  mpsc linked queue < u >  (  )  )  ;  this . buffer supplier = buffer supplier ;  this . timespan = timespan ;  this . unit = unit ;  this . max size = max size ;  this . restart timer on max size = restart on max size ;  this . w = w ;   }  
private void   (  gif89 frame gf )  throws io exception  {  disp dim . width =  math . max ( disp dim . width gf . get width (  )  )  ;  disp dim . height =  math . max ( disp dim . height gf . get height (  )  )  ;  color table . process pixels ( gf )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on dispose ( null )  ;   }  
@ override public boolean   (  integer v )  {  return true ;   }  
private  proxy transfer   (  string transfer digest  socket target socket )  throws io exception  {   proxy transfer provider ;  try  {   class c =  class utils . for name ( class name )  ;  provider =  (  proxy transfer ) c . new instance (  )  ;   }  catch  (   exception e )   {   log . error ( " error loading proxy transfer provider: "  +  class name e )  ;  provider = new  default proxy transfer (  )  ;   }  provider . set transfer digest ( transfer digest )  ;  provider . set output stream ( target socket . get output stream (  )  )  ;  return provider ;   }  
public void   (  )  {  fetch news (  )  ;  if  ( should fetch devsu3 (  )  )   {  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  if  (  !    mgr . is check in progress (  )  &&  !    mgr . is update in progress (  )  )     mgr . check ( router   dev   su3 )  ;   }  if  ( should fetch unsigned (  )  )   {  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  if  (  !    mgr . is check in progress (  )  &&  !    mgr . is update in progress (  )  )     mgr . check ( router   unsigned )  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  ts . on subscribe (  empty subscription . instance )  ;  ts . on error ( new  test exception (  )  )  ;  ts . on error ( new  test exception (  )
public void   (  string home pager )  {  this . home pager = home pager ;   }  
public  list <  string >    (  )  {  return  arrays . as list (  arrays . copy of ( country code country code . length )  )  ;   }  
public static long   ( long account id int type )  {  return  ( account id  <  <  32 )   +  type ;   }  
public double   (  )  {  return l expected sample ;   }  
public synchronized  router identity   (  )  {  if  (  !    verification attempted )   {  verify identity (  )  ;     verification attempted = true ;   }  return    received confirmed identity ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . skip ( 1  time unit . seconds null )  ;   }  
@ before public void   (  )  {  observer =  test helper . mock subscriber (  )  ;  test scheduler = new  test scheduler (  )  ;  subject =  publish processor . create (  )  ;  observable = subject . time interval ( test scheduler )  ;   }  
@ override public  string   (  )  {  return  core version . version ;   }  
public long   (  )  {  return    seq num ;   }  
@ override public  string   (  )  {  return natural language name ;   }  
public static void   ( int sender threads )  {  if  ( sender threads  <  1 )   {  sender threads = 1 ;   }  else if  ( sender threads  >   runtime . get runtime (  )  . available processors (  )  )   {  sender threads =  runtime . get runtime (  )  . available processors (  )  ;   }   conference sender . sender threads = sender threads ;   }  
public int   (  )  {  return record   count ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;  sub id =  externalizable util . get instance (  )  . read safeutf ( in )  ;  owner =  ( jid )  externalizable util . get in
public   (  yahoo session session )  {  this . yahoo session ref = new  weak reference <  yahoo session >  ( session )  ;   }  
private byte[]   (  )  {   map <  string be value >  info = create info map (  )  ;  if  (    log . should log (  log . debug )  )   {   string builder buf = new  string builder ( 128 )  ;  buf . append ( "info: " )  ;  for  (   map .  entry <  string be value >  entry : info . entry set (  )  )   {   string key = entry . get key (  )  ;   object val = entry . get value (  )  ;  buf . append ( key )  . append ( ' = ' )  ;  buf . append ( val . to string (  )  )  ;   }     log . debug ( buf . to string (  )  )  ;   }  byte[] info bytes = b encoder . bencode ( info )  ;   message digest digest = sha1 . get instance (  )  ;  byte hash[] = digest . digest ( info bytes )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "info hash: "  +  i2p snark util . to hex ( hash )  )  ;  return hash ;   }  
public   (  string s  buffer buffer )  {  send = s ;  mode =  mode . rb ;  rb = buffer ;   }  
@ check return value @ scheduler support (  scheduler support . custom )  public static  < t >  observable < t >    (  future <  ?  extends t >  future  scheduler scheduler )  {   object helper . require non null ( scheduler "scheduler is null" )  ;   obs
@ override public void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;  other . dispose (  )  ;  s . cancel (  )  ;  if  ( enter (  )  )   {  queue . clear (  )  ;   }   }   }  
@ test public void   (  )  {  h . execute ( "create table user  ( id int  name varchar ) " )  ;  h . execute ( "create table phone  ( id int  user   id int  phone varchar ) " )  ;  h . prepare batch ( "insert into user  ( id  name )  values  (  ?    ?  ) 
@ override public  string   (  )  {  return "[ big integer field element val = "  +  bi  +  "]" ;   }  
@ override public  string[]   (  map <  string  ?  >  props )  {  final  set <  string >  result = new  hash set <  >  (  )  ;  for  (  final  mechanism mechanism : all mechanisms )   {  if  ( props  !  =  null )   {  if  ( mechanism . allows anonymous &&
  (  )  {  m map = new  hash map < t  integer >  (  )  ;   }  
public int   (  )  {  return    local port ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . concat array delay error (  maybe . empty (  )   maybe . just ( 1 )   maybe . error ( new  test exception (  )  )  )  . test (  )  . assert failure (  test exception . class 1 )  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp1 =  publish processor . create (  )  ;  final  pu
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   test subscriber <  integer >  ts = 
public  string   (  )  {  return service name ;   }  
@ override public jid   (  )  {  return new jid ( null get service domain (  )  null )  ;   }  
boolean   (  )  {  int needed = get adjusted total quantity (  )  ;  int fallbacks = 0 ;  synchronized  (    tunnels )   {  for  ( int i = 0 ;  i  <     tunnels . size (  )  ;  i +  +  )   {   tunnel info info =    tunnels . get ( i )  ;  if  ( info . get length (  )   <  =  1 &&  +  + fallbacks  >  =  needed )  return false ;   }   }  return true ;   }  
  (  filter config filter config )  throws  servlet exception  {  assert filter config  !  =  null ;  debug = read boolean value ( filter config "debug" )  ;   string java util delegate name = filter config . get init parameter ( "java util logger" )  ;  if  ( java util delegate name  !  =  null )   {  logger = new  compressing filter logger impl ( filter config . get servlet context (  )  debug java util delegate name true )  ;   }  else  {   string jakarta commons delegate name = filter config . get init parameter ( "jakarta commons logger" )  ;  logger = new  compressing filter logger impl ( filter config . get servlet context (  )  debug jakarta commons delegate name false )  ;   }  logger . log debug ( " debug logging statements are enabled" )  ;  compression threshold = read compression threshold value ( filter config )  ;  if  ( logger . is debug (  )  )   {  logger . log debug ( " using compressing threshold: "  +  compression threshold )  ;   }  servlet context = filter config . get servlet context (  )  ;  assert this . servlet context  !  =  null ;  if  ( read boolean value ( filter config "stats enabled" )  )   {  stats = new  compressing filter stats (  )  ;  ensure stats in context (  )  ;  logger . log debug ( " stats are enabled" )  ;   }  else  {  stats = null ;  logger . log debug ( " stats are disabled" )  ;   }   string include content types string = filter config . get init parameter ( "include content types" )  ;   string exclude content types string = filter config . get init parameter ( "exclude content types" )  ;  if  ( include content types string  !  =  null && exclude content types string  !  =  null )   {  throw new  illegal argument exception ( " can't specify both include content types and exclude content types" )  ;   }  if  ( include content types string  =  =  null )   {  include content types = false ;  content types = parse content types ( exclude content types string )  ;   }  else  {  include content types = true ;  content types = parse content types ( include content types string )  ;   }  if  (  ! content types . is empty (  )  )   {  logger . log debug ( " filter will "  +   ( include content types  ?  "include" : "exclude" )   +  " only these content types: " +  content types )  ;   }   string include path patterns string = filter config . get init parameter ( "include path patterns" )  ;   string exclude path patterns string = filter config . get init parameter ( "exclude path patterns" )  ;  if  ( include path patterns string  !  =  null && exclude path patterns string  !  =  null )   {  throw new  illegal argument exception ( " can't specify both include path patterns and exclude path patterns" )  ;   }  if  ( include path patterns string  =  =  null )   {  include path patterns = false ;  path patterns = parse patterns ( exclude path patterns string )  ;   }  else  {  include path patterns = true ;  path patterns = parse patterns ( include path patterns string )  ;   }  if  (  ! path patterns . is empty (  )  && logger . is debug (  )  )   {  logger . log debug ( " filter will "  +   ( include path patterns  ?  "include" : "exclude" )   +  " only these file patterns: " +  path patterns )  ;   }   string include user agent patterns string = filter config . get init parameter ( "include user agent patterns" )  ;   string exclude user agent patterns string = filter config . get init parameter ( "exclude user agent patterns" )  ;  if  ( include user agent patterns string  !  =  null && exclude user agent patterns string  !  =  null )   {  throw new  illegal argument exception ( " can't specify both include user agent patterns and exclude user agent patterns" )  ;   }  if  ( include user agent patterns string  =  =  null )   {  include user agent patterns = false ;  user agent patterns = parse patterns ( exclude user agent patterns string )  ;   }  else  {  include user agent patterns = true ;  user agent patterns = parse patterns ( include user agent patterns string )  ;   }  if  (  ! user agent patterns . is empty (  )  && logger . is debug (  )  )   {  logger . log debug ( " filter will "  +   ( include user agent patterns  ?  "include" : "exclude" )   +  " only these  user -  agent patterns: " +  user agent patterns )  ;   }   }  
public  list <  string >    (  )  {  return proxies . get ( default )  ;   }  
private static void   ( final  context c final long message id )  throws  illegal state exception  {  final  content values empty values = new  content values ( 2 )  ;  empty values . put null (  body columns . html   content )  ;  empty values . put null (  body columns . text   content )  ;  write body files ( c message id empty values )  ;   }  
private  object   ( java . sql .  array array  statement context ctx )  throws sql exception  {   list <  object >  list = new  array list <  >  (  )  ;  try  (  result set rs = array . get result set (  )  )  {  while  ( rs . next (  )  )   {  list . add ( element mapper . map ( rs 2 ctx )  )  ;   }   }   object ary =  array . new instance ( component type list . size (  )  )  ;  if  ( component type . is primitive (  )  )   {  for  ( int i = 0 ;  i  <  list . size (  )  ;  i +  +  )   {   array . set ( ary i list . get ( i )  )  ;   }  return ary ;   }  return list . to array (  (  object[] ) ary )  ;   }  
public static  mock transport   (  context context )  {  return new  mock transport ( context new  host auth (  )  )  ;   }  
public static  file   (  string filename )  {  if  (  environment . get external storage state (  )  . equals (  environment . media   mounted )  )   {   file directory =  environment . get external storage directory (  )  ;   file file = new  file ( directory filename )  ;  if  (  ! file . exists (  )  )   {  return file ;   }  int index = filename . last index of ( ' . ' )  ;   string name = filename ;   string extension = "" ;  if  ( index  !  =   - 1 )   {  name = filename . substring ( 0 index )  ;  extension = filename . substring ( index )  ;   }  for  ( int i = 2 ;  i  <   integer . max   value ;  i +  +  )   {  file = new  file ( directory name  +  ' - '  +  i +  extension )  ;  if  (  ! file . exists (  )  )   {  return file ;   }   }  return null ;   }  return null ;   }  
@ override public  enumeration <  string >    (  )  {  return context . get servlet names (  )  ;   }  
@ override public void   (  throwable e )  {   assert . fail ( e . get message (  )  )  ;   }  
@ override protected  collection <  class >    (  )  {  return  arrays . as list (  (  class )  traffic monitor . class )  ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable . just ( 1 )  . single element (  )  ;   maybe observer <  integer >  observer =  test helper . mock maybe observer (  )  ;  o . subscribe ( observer )  ;   in order in order = in order ( 
private synchronized void   (  client app state state  exception e )  {     state = state ;  if  (    mgr  !  =  null )     mgr . notify ( this state null e )  ;   }  
@ test ( timeout = 2000 )  public void   (  )  {   flowable <  integer >  source =  flowable . just ( 1 )  . repeat (  )  ;   flowable <  list <  integer >  >  result = source . buffer ( 2 )  . take ( 1 )  ;   subscriber <  object >  o =  test helper . mo
public void   (  string source )  {  this . source = source ;   }  
@ override public void   (  )  {  new  thread ( this " attachment service" )  . start (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  maybe subject <  integer >  cs =  maybe subject . create (  )  ;  final  test subscribe
public int   ( int tunnel int default variance )  {  return    helper . get tunnel variance out ( tunnel default variance )  ;   }  
@ override public void   (  string major  string minor  properties params )  {     log . error ( " unhandled message: ["  +  major  +  "] [" +  minor +  "] [" +  params +  "]" )  ;   }  
public void   (  )  {  final  string local address =  jive globals . get property ( jn   pub   ip   property  localip resolver . get localip (  )  )  ;   localip resolver . set override ip ( local address )  ;  final  inet socket address public address =  publicip resolver . get public address ( "stun . l . google . com" 19302 )  ;  has publicip = public address  !  =  null && public address . get address (  )  . get host address (  )  . equals ( local address )  ;   }  
@ override public void   (  certificate cert  collection <  string >  unresolved crit exts )  throws  cert path validator exception  {   log . debug ( "ocsp checker: check called" )  ;   input stream in = null ;   output stream out = null ;  try  {  x509 
@ data provider ( name = " " )  public  object[][] test adapter list truncation data provider (  )  {   object[][] ret = new  object[ illumina adapter pair . values (  )  . length][] ;  for  ( int i = 0 ;  i  <  ret . length ;   +  + i )   {  ret[i] = new
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  final  single post complete subscriber <  integer  inte
@ override public long   (  )  {  return 0 ;   }  
private boolean   (  properties props )  {  if  (    authorized )  return true ;  if  (    enforce auth &&    context . get boolean property ( prop   auth )  )   {   string user = null ;   string pw = null ;  if  ( props  !  =  null )   {  user = props . get property ( "i2cp . username" )  ;  pw = props . get property ( "i2cp . password" )  ;   }  if  ( user  =  =  null || user . length (  )   =  =  0 || pw  =  =  null || pw . length (  )   =  =  0 )   {     log . log always (  log . warn "i2cp authentication failed" )  ;     runner . disconnect client ( " authorization required  specify i2cp . username and i2cp . password in options" )  ;     authorized = false ;  return false ;   }   password manager mgr = new  password manager (    context )  ;  if  (  ! mgr . check hash ( prop   auth user pw )  )   {     log . log always (  log . warn "i2cp authentication failed  user: "  +  user )  ;     runner . disconnect client ( " authorization failed  user  =  "  +  user )  ;     authorized = false ;  return false ;   }  if  (    log . should log (  log . info )  )     log . info ( "i2cp auth success user: "  +  user )  ;   }     authorized = true ;  return true ;   }  
void   (  )  {  write started =  - 1 ;   }  
public  message input stream   (  )  {  return    input stream ;   }  
private  string   (  meta info info )  {   list <  list <  string >  >  files = info . get files (  )  ;  if  (  ( files  !  =  null )  &&  ( files . size (  )   >  max   files   per   torrent )  )   {  return    t ( " too many files in \" { 0 } \"  (  { 1 }  )  ! " info . get name (  )  files . size (  )  )  ;   }  else if  (  ( files  =  =  null )  &&  ( info . get name (  )  . ends with ( " . torrent" )  )  )   {  return    t ( " torrent file \" { 0 } \" cannot end in \" . torrent\" ! " info . get name (  )  )  ;   }  else if  ( info . get pieces (  )   <  =  0 )   {  return    t ( " no pieces in \" { 0 } \" ! " info . get name (  )  )  ;   }  else if  ( info . get pieces (  )   >   storage . max   pieces )   {  return    t ( " too many pieces in \" { 0 } \"  limit is  { 1 }  ! " info . get name (  )   storage . max   pieces )  ;   }  else if  ( info . get piece length ( 0 )   >   storage . max   piece   size )   {  return    t ( " pieces are too large in \" { 0 } \"  (  { 1 } b )  ! " info . get name (  )   data helper . format size2 ( info . get piece length ( 0 )  )  )   +  ' '  +     t ( " limit is  { 0 } b"  data helper . format size2 (  storage . max   piece   size )  )  ;   }  else if  ( info . get total length (  )   <  =  0 )   {  return    t ( " torrent \" { 0 } \" has no data ! " info . get name (  )  )  ;   }  else if  ( info . get total length (  )   >   storage . max   total   size )   {   system . out . println ( "torrent info: "  +  info . to string (  )  )  ;   list <  long >  lengths = info . get lengths (  )  ;  if  ( lengths  !  =  null )  for  ( int i = 0 ;  i  <  lengths . size (  )  ;  i +  +  )   system . out . println ( " file "  +  i  +  " is " +  lengths . get ( i )  +  " long . " )  ;  return    t ( " torrents larger than  { 0 } b are not supported yet \" { 1 } \" ! "  storage . max   total   size info . get name (  )  )  ;   }  else  {  return null ;   }   }  
public   ( int local port boolean own dest  logging l  event dispatcher notify this  string handler name i2p tunnel tunnel  string pkf )  throws  illegal argument exception  {  super ( local port  +  "  ( uninitialized ) " notify this tunnel )  ;     client id =       client id . increment and get (  )  ;  this . local port = local port ;  this . l = l ;     own dest = own dest ;     handler name = handler name ;     context = tunnel . get context (  )  ;  init stats (  )  ;     log =    context . log manager (  )  . get log ( get class (  )  )  ;  if  ( pkf  !  =  null )   {   file key file = new  file ( pkf )  ;  if  (  ! key file . is absolute (  )  )  key file = new  file (    context . get config dir (  )  pkf )  ;  this . priv key file = key file . get absolute path (  )  ;   }  boolean dcc enabled =  ( this instanceof i2p tunnelirc client )  &&  boolean . parse boolean ( tunnel . get client options (  )  . get property ( i2p tunnelirc client . prop   dcc )  )  ;  if  (  ! dcc enabled )  tunnel . get client options (  )  . set property ( "i2cp . dont publish lease set" "true" )  ;  if  ( tunnel . get client options (  )  . get property ( "i2p . streaming . answer pings" )   =  =  null )  tunnel . get client options (  )  . set property ( "i2p . streaming . answer pings" "false" )  ;   }  
public void   (  mode value )  {  mode = value ;   }  
public void   (  string gadu telephone )  {  this . gadu telephone = gadu telephone ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts =  flowable . just ( 1 )  . flat map maybe (  functions . just function ( pp . single element (  )  )  )  . test (  
private void   (  mock transport mock transport )  throws  messaging exception  {  open folder with message ( mock transport )  ;  setup uidl sequence ( mock transport 1 )  ;   message[] messages = m folder . get messages ( 1 1 null )  ;  assert equals ( 1 messages . length )  ;  assert equals ( get single messageuid ( 1 )  messages[0] . get uid (  )  )  ;  setup list sequence ( mock transport 1 )  ;   fetch profile fp = new  fetch profile (  )  ;  fp . add (  fetch profile .  item . flags )  ;  fp . add (  fetch profile .  item . envelope )  ;  m folder . fetch ( messages fp null )  ;  assert equals ( per   message   size messages[0] . get size (  )  )  ;   mime message message =  (  mime message ) messages[0] ;  message . get recipients (  recipient type . to )  ;  message . get recipients (  recipient type . cc )  ;  message . get recipients (  recipient type . bcc )  ;  setup single message ( mock transport 1 false )  ;  fp = new  fetch profile (  )  ;  fp . add (  fetch profile .  item . body )  ;  m folder . fetch ( messages fp null )  ;  check fetched message ( messages[0] 1 false )  ;   }  
public   (  observable source < t >  source long timespan long timeskip  time unit unit  scheduler scheduler  callable < u >  buffer supplier int max size boolean restart timer on max size )  {  super ( source )  ;  this . timespan = timespan ;  this . timeskip = timeskip ;  this . unit = unit ;  this . scheduler = scheduler ;  this . buffer supplier = buffer supplier ;  this . max size = max size ;  this . restart timer on max size = restart timer on max size ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  ps . on complete (  )  ;   }  
@ test public void   (  )  {   observable . empty (  )  . first or error (  )  . to observable (  )  . test (  )  . assert no values (  )  . assert error (  no such element exception . class )  ;   }  
@ override public void   (  )  {  super . cancel (  )  ;   disposable helper . dispose ( other disposable )  ;   }  
public static  format converter   (  string name )  {  if  (  string utils . is blank ( name )  )   {  return null ;   }  return conversion   map . get ( name )  ;   }  
@ override public void   (  session data data  element command )  {   element note = command . add element ( "note" )  ;  if  (  group manager . get instance (  )  . is read only (  )  )   {  note . add attribute ( "type" "error" )  ;  note . set text ( "
@ setup public void   (  )  {   scheduler s =  schedulers . single (  )  ;   scheduler s2 = new  single scheduler (  )  ;   callable <  integer >  c = new  callable <  integer >  (  )  {  @ override public  integer call (  )  throws  exception  {  return 
@ test public void   (  )  {   observable . just ( 0 )  . switch map ( new  function <  object  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   object v )  throws  exception  {  return  observable .
@ override public boolean   (  object key )  {  return properties . contains key ( key )  ;   }  
public void   ( boolean is conference silenced )  {  if  ( trace call ||  logger . log level  >  =   logger . log   info )   {   logger . println ( " call "  +  cp  +  " conference silenced is now " +  is conference silenced )  ;   }  cp . set conference silenced ( is conference silenced )  ;  attenuate whisper groups (  )  ;  adjust private mix descriptors (  )  ;   }  
public void   (  )  {   interceptor manager . get instance (  )  . remove interceptor ( interceptor )  ;  interceptor = null ;  router = null ;  server name = null ;  white list = null ;   }  
private final  session key   (  big integer my private value  big integer public peer value )  {  long start =  system . current time millis (  )  ;   session key key = new  session key (  )  ;   big integer exchanged key = public peer value . mod pow ( my private value  crypto constants . elgp )  ;  byte buf[] = exchanged key . to byte array (  )  ;  byte val[] = new byte[ session key . keysize   bytes] ;  if  ( buf . length  <  2 *  session key . keysize   bytes )   {   system . arraycopy ( buf 0 val 0  math . min ( buf . length  session key . keysize   bytes )  )  ;  byte remaining[] = new byte[ session key . keysize   bytes] ;  sha256 generator . get instance (  )  . calculate hash ( buf 0 buf . length remaining 0 )  ;     extra exchanged bytes . set data ( remaining )  ;   }  else  {   system . arraycopy ( buf 0 val 0  session key . keysize   bytes )  ;   random source . get instance (  )  . harvester (  )  . feed entropy ( "dh" buf val . length buf . length  -  val . length )  ;  byte remaining[] = new byte[buf . length  -  val . length] ;   system . arraycopy ( buf val . length remaining 0 remaining . length )  ;     extra exchanged bytes . set data ( remaining )  ;   }  key . set data ( val )  ;  long end =  system . current time millis (  )  ;  long diff = end  -  start ;  i2p app context . get global context (  )  . stat manager (  )  . add rate data ( "crypto . dh calculate session time" diff )  ;  return key ;   }  
private static void   (  string host int port  string con options  string dest name )  {  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;   string req = "session create style = raw destination = "  +  dest name  +  " " +  con options +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . info ( " response to creating the session with destination "  +  dest name  +  ": " +  line )  ;     log . debug ( " the above should contain session status result = ok" )  ;  s . close (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
@ override public  string   (  )  {   string builder str = format as string (  )  ;  return str . to string (  )  ;   }  
@ override public  observable < u >    (  )  {  return  rx java plugins . on assembly ( new  observable collect < t u >  ( source initial supplier collector )  )  ;   }  
public void   ( boolean b )  {  this . enabled = b ;   }  
private  source   (  string source name )  throws  rrd exception  {   source source = sources . get ( source name )  ;  if  ( source  !  =  null )   {  return source ;   }  throw new  rrd exception ( " unknown source: "  +  source name )  ;   }  
public void   ( boolean enabled )  {  rejection notification enabled = enabled ;   jive globals . set property ( rejection   notification   enabled   property enabled  ?  "true" : "false" )  ;   }  
public boolean   (  )  {     cancelled = true ;  return super . cancel (  )  ;   }  
public void   (  )  {  final  context c = m mock context ;   account a =  provider test utils . setup account ( "acct1" true c )  ;   mailbox bi =  provider test utils . setup mailbox ( "b1" a . m id true c  mailbox . type   inbox )  ;   mailbox bm =  provider test utils . setup mailbox ( "b2" a . m id true c  mailbox . type   mail )  ;  assert equals ( "b1"  mailbox . get display name ( c bi . m id )  )  ;  assert equals ( "b2"  mailbox . get display name ( c bm . m id )  )  ;  assert equals ( null  mailbox . get display name ( c 999999 )  )  ;   }  
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   observable . just ( 1 )  . do on dispose ( new  action (  )  {  @ override public void run (  )  throws  exception  {  calls[0] +  +  ;   }   }   )  . unsubscribe on (  schedulers . single (  )
@ override public  string   (  )  {  return null ;   }  
@ override public void   (  string type final byte[] data )  {  new  thread (  )  {  @ override public void run (  )  {   avatar avatar = get avatar (  )  ;  v card v card = new v card (  )  ;  try  {  v card . load ( conn )  ;  v card . set avatar ( data
public synchronized  region   ( long ipnum )  {   region record = new  region (  )  ;  int seek   region ;  if  ( database type  =  =   database info . region   edition   rev0 )   {  seek   region = seek country ( ipnum )   -  state   begin   rev0 ;  char[] ch = new char[2] ;  if  ( seek   region  >  =  1000 )   {  record . country code = "us" ;  record . country name = " united  states" ;  ch[0] =  ( char )  (  (  ( seek   region  -  1000 )   /  26 )   +  65 )  ;  ch[1] =  ( char )  (  (  ( seek   region  -  1000 )  % 26 )   +  65 )  ;  record . region = new  string ( ch )  ;   }  else  {  record . country code = country code[seek   region] ;  record . country name = country name[seek   region] ;  record . region = "" ;   }   }  else if  ( database type  =  =   database info . region   edition   rev1 )   {  seek   region = seek country ( ipnum )   -  state   begin   rev1 ;  char[] ch = new char[2] ;  if  ( seek   region  <  us   offset )   {  record . country code = "" ;  record . country name = "" ;  record . region = "" ;   }  else if  ( seek   region  <  canada   offset )   {  record . country code = "us" ;  record . country name = " united  states" ;  ch[0] =  ( char )  (  (  ( seek   region  -  us   offset )   /  26 )   +  65 )  ;  ch[1] =  ( char )  (  (  ( seek   region  -  us   offset )  % 26 )   +  65 )  ;  record . region = new  string ( ch )  ;   }  else if  ( seek   region  <  world   offset )   {  record . country code = "ca" ;  record . country name = " canada" ;  ch[0] =  ( char )  (  (  ( seek   region  -  canada   offset )   /  26 )   +  65 )  ;  ch[1] =  ( char )  (  (  ( seek   region  -  canada   offset )  % 26 )   +  65 )  ;  record . region = new  string ( ch )  ;   }  else  {  record . country code = country code[ ( seek   region  -  world   offset )   /  fips   range] ;  record . country name = country name[ ( seek   region  -  world   offset )   /  fips   range] ;  record . region = "" ;   }   }  return record ;   }  
public int   (  )  {  return wait ;   }  
public long   (  )  {  return media proxy . get lifetime (  )  ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts =  flowable . never (  )  . test (  )  . await count ( 1  test wait strategy . sleep   1ms 50 )  ;  assert true ( ts . is timeout (  )  )  ;  ts . clear timeout (  )  ;  assert false ( ts . is
@ override protected void   (  )  {  super . on resume (  )  ;  if  ( m force create )   {  m force create = false ;  proceed (  )  ;   }   }  
public void   (  )  {  if  (    runner . is dead (  )  )  return ;   abuse reason res = new  abuse reason (  )  ;  res . set reason (    reason )  ;   abuse severity sev = new  abuse severity (  )  ;  sev . set severity (    severity )  ;   report abuse message msg = new  report abuse message (  )  ;  msg . set reason ( res )  ;   session id id =    runner . get session id (    dest . calculate hash (  )  )  ;  if  ( id  =  =  null )  return ;  msg . set session id ( id )  ;  msg . set severity ( sev )  ;  try  {     runner . do send ( msg )  ;   }  catch  (  i2cp message exception ime )   {     log . error ( " error reporting abuse" ime )  ;   }   }  
public  string   (  )  {  return node id ;   }  
public static void   (  string args[] )  {   string proxy host = "127 . 0 . 0 . 1" ;  int proxy port = 4444 ;  long size = 56 ;   string save as = null ;   string username = null ;   string password = null ;  boolean error = false ;   getopt g = new  getopt ( "partialeepget" args "p:cl:o:u:x:" )  ;  try  {  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 'p':  string s = g . get optarg (  )  ;  int colon = s . index of ( ':' )  ;  if  ( colon  >  =  0 )   {  proxy host = s . substring ( 0 colon )  ;   string port = s . substring ( colon  +  1 )  ;  proxy port =  integer . parse int ( port )  ;   }  else  {  proxy host = s ;   }  break ;  case 'c': proxy host = "" ;  proxy port = 0 ;  break ;  case 'l': size =  long . parse long ( g . get optarg (  )  )  ;  break ;  case 'o': save as = g . get optarg (  )  ;  break ;  case 'u': username = g . get optarg (  )  ;  break ;  case 'x': password = g . get optarg (  )  ;  break ;  case ' ? ': case ':': default : error = true ;  break ;   }   }   }  catch  (  runtime exception e )   {  e . print stack trace (  )  ;  error = true ;   }  if  ( error || args . length  -  g . get optind (  )   !  =  1 )   {  usage (  )  ;   system . exit ( 1 )  ;   }   string url = args[g . get optind (  ) ] ;  if  ( save as  =  =  null )  save as = suggest name ( url )  ;   output stream out ;  try  {  out = new  file output stream ( save as )  ;   }  catch  ( io exception ioe )   {   system . err . println ( " failed to create output file "  +  save as )  ;  out = null ;   system . exit ( 1 )  ;   }   eep get get = new  partial eep get ( i2p app context . get global context (  )  proxy host proxy port out url size )  ;  if  ( username  !  =  null )   {  if  ( password  =  =  null )   {  try  {   buffered reader r = new  buffered reader ( new  input stream reader (  system . in )  )  ;  do  {   system . err . print ( " proxy password: " )  ;  password = r . read line (  )  ;  if  ( password  =  =  null )  throw new io exception (  )  ;  password = password . trim (  )  ;   }  while  ( password . length (  )   <  =  0 )  ;   }  catch  ( io exception ioe )   {   system . exit ( 1 )  ;   }   }  get . add authorization ( username password )  ;   }  get . add status listener ( get . new cli status listener ( 1024 40 )  )  ;  if  ( get . fetch ( 45 * 1000  - 1 60 * 1000 )  )   {   system . err . println ( " last -  modified: "  +  get . get last modified (  )  )  ;   system . err . println ( " etag: "  +  get . gete tag (  )  )  ;   }  else  {   system . err . println ( " failed "  +  url )  ;   system . exit ( 1 )  ;   }   }  
public boolean   (  string addr int port ssdp search request req )  {  return post ( addr port req . to string (  )  )  ;   }  
private void   (  observer <  string >  observer )  {  verify ( observer times ( 1 )  )  . on next ( "one" )  ;  verify ( observer times ( 1 )  )  . on next ( "two" )  ;  verify ( observer times ( 1 )  )  . on next ( "three" )  ;  verify ( observer times ( 1 )  )  . on error ( test exception )  ;  verify ( observer  mockito . never (  )  )  . on complete (  )  ;   }  
@ override public void   (  observer <  ?  super t >  s )  {  source . subscribe ( new  skip while observer < t >  ( s predicate )  )  ;   }  
public boolean   (  )  {  return locked ;   }  
@ test ( data provider = "check samples crosscheck all with mapping data" )  public void   ( final  list <  file >  files1 final  list <  file >  files2 final  file input sample map final  file second input sample map final int expected ret val final int 
@ override public boolean   (  )  {  return is initialized ;   }  
@ override public void   (  throwable t1 )  {  t1 . print stack trace (  )  ;   }  
public  string   (  )  {  return    name ;   }  
@ suppress warnings (  { "rawtypes" "unchecked" }  )  @ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  behavior subject <  object >  p =  behavior subject . create default (  (  object 
public long   (  )  {  return    lifetime rejected . get (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   observable <  integer >  source =  observable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override publi
public int   (  )  {  return c  -  a ;   }  
  (  thread factory thread factory )  {  super ( thread factory )  ;  this . expiration time = 0l ;   }  
@ test public void   (  )  {   observable . just ( 5 1 2 4 3 )  . sorted ( new  comparator <  integer >  (  )  {  @ override public int compare (   integer a   integer b )  {  return b  -  a ;   }   }   )  . test (  )  . assert result ( 5 4 3 2 1 )  ;   }
public void   (  graphics g )  {  draw ( rate vector g  color . blue )  ;  draw ( window size vector g  color . green )  ;   }  
@ override public void   (  adapter view <  ?  >  parent  view view int position long id )  {  final  object item = m adapter . get item ( position )  ;  if  ( item instanceof  folder row )   {  update (  (  folder row ) item )  ;   }   }  
@ override public void   (  )  {  if  ( tile index  !  =  null )   {  seek to tile ( current tile )  ;   }   }  
private void   (  string treatment )  {  try  {  incoming call handler . play treatment to call ( treatment )  ;   }  catch  (  io exception e )   {   logger . println ( " call "  +  incoming call handler  +  "  can't play treatment " +  treatment )  ;   }  last message played = treatment ;   }  
public boolean   (  )  {  return processed ;   }  
public void   (  string mode )  {     ntcp autoip = mode ;   }  
@ test public void   (  )  {   ordered properties options = new  ordered properties (  )  ;  options . set property ( "hostname" "localhost" )  ;  options . set property ( "portnum" "1234" )  ;   router address addr = new  router address ( " blah" options
@ test public void   (  )  {   test helper . check double on subscribe completable ( new  function <  completable  completable source >  (  )  {  @ override public  completable source apply (   completable m )  throws  exception  {  return m . on terminat
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic boolean run = new  atomic boolean (  )  ;   completable c = normal . completable . start with (  completable . from callable ( new  callable <  object >  (  )  {  @ override public  object ca
public static synchronized void   (  string msg )  {  println ( "error: "  +  msg )  ;   }  
@ suppress warnings ( "unchecked" )  public iq   ( iq packet )  throws  unauthorized exception  {  iq reply = iq . create resultiq ( packet )  ;   element pref request = packet . get child element (  )  ;   log . debug ( " received pref request from  {  }
public  sql statements   (  template engine template engine )  {  this . template engine = template engine ;  return this ;   }  
private boolean   (  packet packet boolean read boolean processed )  {  return patterns enabled &&  ! processed && read&&  ( packet instanceof  message ||  ( filter status enabled && packet instanceof  presence )  )  ;   }  
void   ( long nonce )  {  for  (   lookup waiter w :    pending lookups )   {  if  ( nonce  =  =  w . nonce )   {  synchronized  ( w )   {  w . notify all (  )  ;   }   }   }   }  
public void   (  string treatment )  {  if  ( new conference manager  =  =  null )   {  return ;   }  try  {  new conference manager . add treatment ( "joinclick . au" )  ;   }  catch  (  io exception e )   {   logger . println ( " call "  +  this  +  " unable to play treatment " +  treatment +  " " +  e . get message (  )  )  ;   }   }  
private void   ( int peer count )  {  if  (    is idle &&    log . should log (  log . info )  )     log . info ( " restoring tunnels on activity" )  ;     is idle = false ;   map <  string  string >  opts =    util . geti2cp options (  )  ;   string i = opts . get ( "inbound . quantity" )  ;  if  ( i  =  =  null )  i =  integer . to string (  snark manager . default   tunnel   quantity )  ;   string o = opts . get ( "outbound . quantity" )  ;  if  ( o  =  =  null )  o =  integer . to string (  snark manager . default   tunnel   quantity )  ;   string ib = opts . get ( "inbound . backup quantity" )  ;  if  ( ib  =  =  null )  ib = "0" ;   string ob = opts . get ( "outbound . backup quantity" )  ;  if  ( ob  =  =  null )  ob = "0" ;  int in  out ;  try  {  in =  integer . parse int ( i )  ;   }  catch  (   number format exception nfe )   {  in = 3 ;   }  try  {  out =  integer . parse int ( o )  ;   }  catch  (   number format exception nfe )   {  out = 3 ;   }  int target =  math . max ( peer count  /  2 2 )  ;  if  ( target  <  in && in  >  2 )   {  in = target ;  i =  integer . to string ( in )  ;   }  if  ( target  <  out && out  >  2 )   {  out = target ;  o =  integer . to string ( out )  ;   }  if  (  !  (    last in . equals ( i )  &&    last out . equals ( o )  )  )  set tunnels ( i o ib ob )  ;   }  
@ override public  completable   (  flowable <  object >  f )  throws  exception  {  return f . concat map completable (  functions . just function (  completable . complete (  )  )  )  ;   }  
public void   (  )  {  if  (    dead )  return ;  if  (  !    message status map . is empty (  )  )   {  for  (  iterator <  connection >  iter =    message status map . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   connection con = iter . next (  )  ;  if  (  ! con . get is connected (  )  || con . get lifetime (  )   >  2 * 60 * 1000l )  iter . remove (  )  ;   }   }  schedule ( remove   expired   time )  ;   }  
@ override public void   ( final  completable observer s )  {  final  composite disposable set = new  composite disposable (  )  ;  final  atomic integer wip = new  atomic integer ( sources . length  +  1 )  ;  final  atomic throwable error = new  atomic 
@ override protected int   (  )  {  final  file summary metrics file = new  file ( output  +  summary   metrics   file   extension )  ;  final  file detailed metrics file = new  file ( output  +  detailed   metrics   file   extension )  ;  final  file con
private static  method handles .  lookup   (  class <  ?  >  clazz )  {  if  ( private   lookup   in  !  =  null )   {  try  {  return  (  method handles .  lookup ) private   lookup   in . invoke ( null clazz  method handles . lookup (  )  )  ;   }  catch  (   illegal access exception| invocation target exception e )   {   string message =  string . format ( " error invoking  method handles . private lookup in ( %s . class   method handles . lookup (  )  )  in jdk 9 +  runtime" clazz )  ;  throw new  runtime exception ( message e )  ;   }   }  return private lookups . compute if absent ( clazz type  -  >   {  try  {  final  constructor <  method handles .  lookup >  constructor =  method handles .  lookup . class . get declared constructor (  class . class int . class )  ;  if  (  ! constructor . is accessible (  )  )   {  constructor . set accessible ( true )  ;   }  return constructor . new instance ( type  method handles .  lookup . public |  method handles .  lookup . private |  method handles .  lookup . protected|  method handles .  lookup . package )  ;   }  catch  (   reflective operation exception e )   {  throw new  runtime exception ( e )  ;   }   }   )  ;   }  
private  string   (  )  {  if  (  (    action  =  =  null )  ||  (    action . trim (  )  . length (  )   <  =  0 )  ||  ( " cancel" . equals (    action )  )  )  return "" ;  if  (    group  =  =  null )  return " error  -  tunnels are not initialized yet" ;  if  (  !    context . get boolean property ( prop   pw   enable )  &&  ! have nonce (    cur nonce )  )  return    t ( " invalid form submission  probably because you used the 'back' or 'reload' button on your browser .   please resubmit . " )   +  ' '  +     t ( " if the problem persists  verify that you have cookies enabled in your browser . " )  ;  if  ( " stop all" . equals (    action )  )   {  stop all (  )  ;  return "" ;   }  else if  ( " start all" . equals (    action )  )   {  start all (  )  ;  return "" ;   }  else if  ( " restart all" . equals (    action )  )   {  restart all (  )  ;  return "" ;   }  else if  ( " reload configuration" . equals (    action )  )   {  return reload config (  )  ;   }  else if  ( "stop" . equals (    action )  )   {  return stop (  )  ;   }  else if  ( "start" . equals (    action )  )   {  return start (  )  ;   }  else if  ( " save changes" . equals (    action )  ||  (    action . to lower case (  locale . us )  . index of ( "s <  / span > ave" )   >  =  0 )  )   {  save changes (  )  ;  return "" ;   }  else if  ( " delete this proxy" . equals (    action )  ||  (    action . to lower case (  locale . us )  . index of ( "d <  / span > elete" )   >  =  0 )  )   {  delete tunnel (  )  ;  return "" ;   }  else if  ( " estimate" . equals (    action )  )   {  return  private key file . estimate hash cash time (    hash cash value )  ;   }  else if  ( " modify" . equals (    action )  )   {  return modify destination (  )  ;   }  else if  ( " generate" . equals (    action )  )   {  return generate new encryption key (  )  ;   }  else if  ( " clear" . equals (    action )  )   {     messages . clear through (    msgid )  ;  return "" ;   }  else  {  return " action "  +     action  +  " unknown" ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp0 =  publish proces
public void   ( final  read ends for mate cigar end )  {  final  physical location for mate cigar location = new  physical location for mate cigar ( end )  ;  if  ( physical locations . contains ( location )  )   {  read ends . remove ( end )  ;  physical locations . remove ( location )  ;   }   }  
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 3 2 5 4 )  ;   flowable <  list <  integer >  >  observable = w . to sorted list ( new  comparator <  integer >  (  )  {  @ override public int compare (   integer t1   integer
public  string   (  string name )  {   parameter param = get parameter ( name )  ;  if  ( param  =  =  null )  return "" ;  return param . get value (  )  ;   }  
@ override public boolean   (  )  throws  exception  {  return true ;   }  
@ test public void   (  )  throws  exception  {   string expected = get file as string ( json   versions   identity )  ;   string actual = transform xml to format ( versions xml file reader new  media type (  mime type . application   json  - 1 )  new  co
@ test public void   (  )  {  final  string[] key = new  string[] { "uninitialized" }  ;  final  list <  string >  values = new  array list <  string >  (  )  ;   flowable . just ( "a" "b" "c" )  . group by ( new  function <  string  string >  (  )  {  @ 
@ override protected void   (  )  {  while  (    stay alive )   {  while  (    do run )   {  i2cp message msg = null ;  try  {  msg = in . take (  )  ;  if  ( msg . get type (  )   =  =   poisoni2cp message . message   type )   {     listener . disconnect
@ test public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic reference <  throwable >  caught error = new  atomic reference <  throwable >  (  )  ;   flowable <  long >  o =  fl
protected int   (  )  {  io util . assert inputs are valid ( input )  ;  io util . assert file is writable ( output )  ;  io util . assert file is writable ( metrics   file )  ;  final  sam header and iterator header and iterator = open inputs ( true )  ;  final sam file header header = header and iterator . header ;  final sam file header output header = header . clone (  )  ;  if  ( output header . get sort order (  )   !  =  sam file header .  sort order . coordinate )   {  throw new  picard exception ( " this program requires inputs in coordinate  sort order" )  ;   }  comment . for each ( output header::add comment )  ;  final  map <  string  string >  chained pg ids = get chained pg ids ( output header )  ;  final sam file writer out = new sam file writer factory (  )  . makesam orbam writer ( output header false output )  ;  final sam record duplicate comparator comparator = new sam record duplicate comparator (  collections . singleton list ( header and iterator . header )  )  ;  comparator . set scoring strategy ( this . duplicate   scoring   strategy )  ;  final  closeable iterator <  duplicate set >  iterator = get duplicate set iterator ( header and iterator comparator )  ;  final  progress logger progress = new  progress logger ( log  ( int ) 1e6 " read" )  ;  int num duplicates = 0 ;  library id generator = new  library id generator ( header and iterator . header )  ;  for  (  final  duplicate set duplicate set : new  iterable adapter <  >  ( iterator )  )   {  final sam record representative = duplicate set . get representative (  )  ;  final boolean do optical duplicate tracking =  ( this . read   name   regex  !  =  null )  && is paired and both mapped ( representative )  && representative . get first of pair flag (  )  ;  final  set <  string >  duplicate read ends seen = new  hash set <  >  (  )  ;  final  list <  read ends >  duplicate read ends = new  array list <  >  (  )  ;  for  (  final sam record record : duplicate set . get records (  )  )   {  final  string library =  library id generator . get library name ( header record )  ;   duplication metrics metrics = library id generator . get metrics by library ( library )  ;  if  ( metrics  =  =  null )   {  metrics = new  duplication metrics (  )  ;  metrics . library = library ;  library id generator . add metrics by library ( library metrics )  ;   }  if  ( record . is secondary or supplementary (  )  )   {   +  + metrics . secondary   or   supplementary   rds ;   }  else  {  if  ( record . get read unmapped flag (  )  )   {   +  + metrics . unmapped   reads ;   }  else if  (  ! record . get read paired flag (  )  || record . get mate unmapped flag (  )  )   {   +  + metrics . unpaired   reads   examined ;   }  else  {   +  + metrics . read   pairs   examined ;   }  if  ( record . get duplicate read flag (  )  )   {  if  (  ! record . get read paired flag (  )  || record . get mate unmapped flag (  )  )   {   +  + metrics . unpaired   read   duplicates ;   }  else  {   +  + metrics . read   pair   duplicates ;   }  num duplicates +  +  ;   }  if  ( do optical duplicate tracking && is paired and both mapped ( record )  &&  ! duplicate read ends seen . contains ( record . get read name (  )  )  )   {  final  read ends for simple mark duplicates with mate cigar read end = new  read ends for simple mark duplicates with mate cigar (  )  ;  if  ( record . get first of pair flag (  )  )   {  read end . orientation for optical duplicates =  read ends . get orientation byte ( record . get read negative strand flag (  )  record . get mate negative strand flag (  )  )  ;   }  else  {  read end . orientation for optical duplicates =  read ends . get orientation byte ( record . get mate negative strand flag (  )  record . get read negative strand flag (  )  )  ;   }  if  ( optical duplicate finder . add location information ( record . get read name (  )  read end )  )   {  if  ( null  !  =  record . get read group (  )  )   {  final short index = library id generator . get library id ( record )  ;  read end . set library id ( index )  ;   }   }  duplicate read ends . add ( read end )  ;  duplicate read ends seen . add ( record . get read name (  )  )  ;   }   }  if  (  ! this . remove   duplicates ||  ! record . get duplicate read flag (  )  )   {  if  ( program   record   id  !  =  null )   {  record . set attribute ( sam tag . pg . name (  )  chained pg ids . get ( record . get string attribute ( sam tag . pg . name (  )  )  )  )  ;   }  out . add alignment ( record )  ;  progress . record ( record )  ;   }   }  if  ( this . read   name   regex  !  =  null && 1  <  duplicate read ends . size (  )  )   {   abstract mark duplicates command line program . track optical duplicates ( duplicate read ends duplicate read ends . get ( 0 )  optical duplicate finder library id generator )  ;   }   }  iterator . close (  )  ;  out . close (  )  ;  if  ( this . read   name   regex  =  =  null )   {  log . warn ( " skipped optical duplicate cluster discovery ;  library size estimation may be inaccurate ! " )  ;   }  else  {  log . info ( " found "  +   ( this . library id generator . get number of optical duplicate clusters (  )  )   +  " optical duplicate clusters . " )  ;   }  log . info ( " processed "  +  progress . get count (  )   +  " records" )  ;  log . info ( " marking "  +  num duplicates  +  " records as duplicates . " )  ;  finalize and write metrics ( library id generator )  ;  return 0 ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  boundary =  publish subject . create (  )  ;  final  observer <  object >  o =  test helper . mock observer (  )  ;  fi
@ override public void   (  )  throws  exception  {  counter . get and increment (  )  ;   }  
public void   ( boolean enable )  throws sql exception  {  stmt . set escape processing ( enable )  ;   }  
@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  folder )  )   {  return false ;   }   folder that =  (  folder ) obj ;  return this . id  =  =  that . id &&  objects . equals ( this . name that . name )  &&  objects . equals ( 
@ test public void   (  )  {   maybe <  integer >  error =  maybe . error ( new  runtime exception (  )  )  ;   maybe . just ( 1 )  . amb with ( error )  . test (  )  . assert value ( 1 )  ;   }  
@ xml element public  string   (  )  {  return subject ;   }  
@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . execute ( "create table stuff  ( ts timestamp  d date ) " )  ;   }  
@ before test void   (  )  throws io exception  {  final  string read name = "testbarcode" ;  temp sam file =  vcf test utils . create temporary indexed file ( " collect wgs metrics" " . bam" )  ;  final  file temp sam file unsorted =  file . create temp 
public  array list <  gateway session >    (  string username )  {   array list <  gateway session >  userconnections = new  array list <  gateway session >  (  )  ;  for  (   map .  entry <  string  map <  string  long >  >  transport : transport sessions . entry set (  )  )   {  if  ( transport . get value (  )  . contains key ( username )  )   {   timestamp stamp = new  timestamp ( transport . get value (  )  . get ( username )  )  ;   date date = new  date ( stamp . get time (  )  )  ;  userconnections . add ( new  gateway session ( username transport . get key (  )  date )  )  ;   }   }  return userconnections ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  open =  publish processor . create (  )  ;  final  publish processor <  integer >  close =  publish processor . c
@ test public void   (  )  {   test helper . check bad source observable ( new  function <  observable <  object >   object >  (  )  {  @ override public  object apply (   observable <  object >  o )  throws  exception  {  return o . window (  observable 
@ override public boolean   (  )  {  return done ;   }  
public  string   (  )  {  return get state variable node (  )  . get node value ( datatype )  ;   }  
private  < t > void   ( final  subscriber < t >  observer long delay final  throwable error )  {  inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  observer . on error ( error )  ;   }   }   delay  time unit . milliseconds )  ;   }  
private i2p socket   ( i2psocks tunnel tun  string proxy )  throws io exception  i2p exception  {   properties overrides = new  properties (  )  ;  overrides . set property ( "option . i2p . streaming . connect delay" "1000" )  ;  i2p socket options proxy opts = tun . build options ( overrides )  ;   destination dest =    context . naming service (  )  . lookup ( proxy )  ;  if  ( dest  =  =  null )  throw new socks exception ( " outproxy not found" )  ;  i2p socket dest sock = tun . createi2p socket ( dest proxy opts )  ;   output stream out = null ;   input stream in = null ;  try  {  out = dest sock . get output stream (  )  ;  in = dest sock . get input stream (  )  ;  boolean auth avail =  boolean . parse boolean ( props . get property ( i2p tunnelhttp client base . prop   outproxy   auth )  )  ;   string config user = null ;   string configpw = null ;  if  ( auth avail )   {  config user = props . get property ( i2p tunnelhttp client base . prop   outproxy   user   prefix  +  proxy )  ;  configpw = props . get property ( i2p tunnelhttp client base . prop   outproxy   pw   prefix  +  proxy )  ;  if  ( config user  =  =  null || configpw  =  =  null )   {  config user = props . get property ( i2p tunnelhttp client base . prop   outproxy   user )  ;  configpw = props . get property ( i2p tunnelhttp client base . prop   outproxy   pw )  ;   }   }  socks5 client . connect ( in out conn host name conn port config user configpw )  ;   }  catch  (  io exception e )   {  try  {  dest sock . close (  )  ;   }  catch  (  io exception ioe )   {   }  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  if  ( out  !  =  null )  try  {  out . close (  )  ;   }  catch  (  io exception ioe )   {   }  throw e ;   }  return dest sock ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  name )  )   {  return false ;   }   name that =  (  name ) obj ;  return this . value . equals ( that . value )  ;   }  
private void   (  string host int port long period  string prefix )  throws io exception  {   graphite graphite = new  graphite ( host port )  ;   graphite reporter reporter =  graphite reporter . for registry ( metric registry )  . prefixed with (  metric registry . name ( prefix  net utilities . best guess hostname (  )  )  )  . build ( graphite )  ;  reporter . start ( period  time unit . seconds )  ;  synchronized  ( list graphite )   {  list graphite . add ( reporter )  ;   }   }  
  ( double max diff rate int max read length int min identical bases  optical duplicate finder optical duplicate finder )  {  this . max diff rate = max diff rate ;  this . min identical bases = min identical bases ;  this . optical duplicate finder = optical duplicate finder ;  this . max read length =  ( max read length  <  =  0 )   ?   integer . max   value : max read length ;   }  
@ test public void   (  )  throws  exception  {  run standard test ( 1 "single barcode alt name . " "multiplexed   positive   rgtags . params" 1 "25t8b25t" basecalls   dir test   data   dir )  ;   }  
public static void   ( boolean shared secret allowed )  {   jive globals . set property ( "xmpp . auth . shared secret enabled" shared secret allowed  ?  "true" : "false" )  ;   }  
@ override protected void   (  http servlet request request  http servlet response response )  throws  servlet exception  io exception  {  if  (  ! is authenticated ( request response )  )  return ;   string path = request . get path info (  )  ;   log . 
public static synchronized void   ( dht nodes nodes boolean save all  file file )  {  if  ( nodes . size (  )   <  =  0 )  return ;   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  persistdht . class )  ;  int count = 0 ;  long max age = save all  ?  0 : i2p app context . get global context (  )  . clock (  )  . now (  )   -  max   age ;   print writer out = null ;  try  {  out = new  print writer ( new  buffered writer ( new  output stream writer ( new  secure file output stream ( file )  "iso - 8859 - 1" )  )  )  ;  out . println ( "# dht nodes  format is nid: hash: destination:port" )  ;  for  (   node info ni : nodes . values (  )  )   {  if  ( ni . last seen (  )   <  max age )  continue ;  out . println ( ni . to persistent string (  )  )  ;  count +  +  ;   }  if  ( out . check error (  )  )  throw new io exception ( " failed write to "  +  file )  ;   }  catch  (  io exception ioe )   {  if  ( log . should log (  log . warn )  )  log . warn ( " error writing the dht  file" ioe )  ;   }  finally  {  if  ( out  !  =  null )  out . close (  )  ;   }  if  ( log . should log (  log . info )  )  log . info ( " stored "  +  count  +  " nodes to " +  file )  ;   }  
@ override public  maybe source < t >    (  )  {  return source ;   }  
private  clove set   ( byte data[] )  throws  data format exception  {  int offset = 0 ;  int num cloves = data[offset] & 0xff ;  offset +  +  ;  if  (    log . should log (  log . debug )  )     log . debug ( "# cloves to read: "  +  num cloves )  ;  if  ( num cloves  <  =  0 || num cloves  >  max   cloves )  throw new  data format exception ( "bad clove count "  +  num cloves )  ;   garlic clove[] cloves = new  garlic clove[num cloves] ;  for  ( int i = 0 ;  i  <  num cloves ;  i +  +  )   {   garlic clove clove = new  garlic clove (    context )  ;  offset +  = clove . read bytes ( data offset )  ;  cloves[i] = clove ;   }   certificate cert =  certificate . create ( data offset )  ;  offset +  = cert . size (  )  ;  long msg id =  data helper . from long ( data offset 4 )  ;  offset +  = 4 ;  long expiration =  data helper . from long ( data offset 8 )  ;   clove set set = new  clove set ( cloves cert msg id expiration )  ;  return set ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on success ( null )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . retry (  (  bi predicate <  integer  throwable >  ) null )  ;   }  
@ override public  string   (  )  {  return get class (  )  . get simple name (  )  ;   }  
public void   (  client message msg )  {   ( new  handle job ( msg )  )  . run job (  )  ;   }  
public   (  pattern pattern k key )  {  this . pattern = pattern ;  this . key = key ;   }  
@ test ( expected =  test exception . class )  public void   (  )  {   completable c =  completable . concat ( new  iterable iterator next throws (  )  )  ;  c . blocking await (  )  ;   }  
public int[]   (  )  {  return output substructure . get cycles (  )  ;   }  
public  string   (  )  {  return  estimate library complexity . class . get simple name (  )  ;   }  
@ override  string   (  )  {  return "jabber:server" ;   }  
void   (  disposable d )  {   disposable helper . replace ( this d )  ;   }  
public  set <  string >    (  )  {  return new  hash set <  string >  (    snarks . key set (  )  )  ;   }  
 session   (  )  {  if  ( session type  =  =   session type . client )   {  return xmpp server . get instance (  )  . get routing table (  )  . get client route ( address )  ;   }  else if  ( session type  =  =   session type . component )   {  return  session manager . get instance (  )  . get component session ( address . get domain (  )  )  ;   }  else if  ( session type  =  =   session type . connection manager )   {  return  session manager . get instance (  )  . get connection multiplexer session ( address )  ;   }  else if  ( session type  =  =   session type . outgoing server )   {   log . error ( " trying to write raw data to a server session across the cluster: "  +  address . to string (  )  )  ;  return null ;   }  else if  ( session type  =  =   session type . incoming server )   {  return  session manager . get instance (  )  . get incoming server session ( streamid )  ;   }   log . error ( " found unknown session type: "  +  session type )  ;  return null ;   }  
@ override public boolean   (  collection <  ?  >  c )  {  throw new  unsupported operation exception (  )  ;   }  
public void   (  data output out  map <  string  string >  string map )  throws io exception  {  strategy . write string map ( out string map )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  src =  publish processor . create (  )  ;   flowable <  integer >  dst = src . hide (  )  ;  assert false ( dst instanceof  publish processor )  ;   subscriber <  object >  o =  test helper . 
@ override public boolean   (  string local domain  string remote domain )  {  if  (  ! using server dialback )   {  return false ;   }   server dialback method = new  server dialback ( get connection (  )  local domain )  ;  if  ( method . authenticate d
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . with latest from (  flowable . just ( 1 )  new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply ( 
public void   (  session listener session listener )  {  session listeners . add ( session listener )  ;   }  
@ deprecated public long   (  )  {  return    expiration ;   }  
protected void   (  hash key  set <  hash >  router hashes  hash to peer  tunnel id reply tunnel )  {  if  (    log . should log (  log . debug )  )     log . debug ( " sending closest routers to key "  +  key  +  ": # peers  =  " +  router hashes . size (  )  +  " tunnel " +  reply tunnel )  ;   database search reply message msg = new  database search reply message ( get context (  )  )  ;  msg . set from hash ( get context (  )  . router hash (  )  )  ;  msg . set search key ( key )  ;  int i = 0 ;  for  (   hash h : router hashes )   {  msg . add reply ( h )  ;  if  (  +  + i  >  =  max   routers   returned )  break ;   }  get context (  )  . stat manager (  )  . add rate data ( "net db . lookups handled" 1 )  ;  send message ( msg to peer reply tunnel )  ;   }  
@ test public void   (  )  {  try  {   flowable . just ( 1 )  . repeat (  - 99 )  ;  fail ( " should have thrown" )  ;   }  catch  (   illegal argument exception ex )   {  assert equals ( "times  >  =  0 required but it was  - 99" ex . get message (  )  )
@ test public void   (  )  {   observable <  integer >  source =  observable . just ( 0 1 2 3 4 5 6 )  ;   observable <  integer >  m = source . group by ( fail ( 0 )  dbl )  . flat map ( flatten   integer )  ;   test observer <  integer >  to = new  test
public   ( byte data[] )  {  super ( data )  ;   }  
  ( int person id  string fruit )  {  this . person id = person id ;  this . fruit = fruit ;   }  
public   (  single source <  ?  extends t >  source  function <  ?  super  throwable  ?  extends  single source <  ?  extends t >  >  next function )  {  this . source = source ;  this . next function = next function ;   }  
public static  list <  host address >    (  string domain int default port )  {   list <  host address >  results = new  linked list <  >  (  )  ;  if  ( dns override  !  =  null )   {   host address host address = dns override . get ( domain )  ;  if  ( host address  =  =  null )   {  host address = dns override . get ( "*" )  ;   }  if  ( host address  !  =  null )   {  results . add ( host address )  ;  return results ;   }   }  results . add all ( srv lookup ( "xmpp - server" "tcp" domain )  )  ;  if  ( results . is empty (  )  )   {  results . add all ( srv lookup ( "jabber" "tcp" domain )  )  ;   }  if  ( results . is empty (  )  )   {  results . add ( new  host address ( domain default port )  )  ;   }  return results ;   }  
@ override public void   (  )  {  lists . add ( new  array list < t >  ( list )  )  ;  list . clear (  )  ;   }  
void   (  )  {  m discourse . log last discourse (  )  ;   }  
public boolean   (  )  {  unsubscribe (  )  ;  ssdp notify socket list ssdp notify socket list = getssdp notify socket list (  )  ;  ssdp notify socket list . stop (  )  ;  ssdp notify socket list . close (  )  ;  ssdp notify socket list . clear (  )  ;  ssdp search response socket list ssdp search response socket list = getssdp search response socket list (  )  ;  ssdp search response socket list . stop (  )  ;  ssdp search response socket list . close (  )  ;  ssdp search response socket list . clear (  )  ;  http server list http server list = gethttp server list (  )  ;  http server list . stop (  )  ;  http server list . close (  )  ;  http server list . clear (  )  ;   disposer disposer = get device disposer (  )  ;  if  ( disposer  !  =  null )   {  disposer . stop (  )  ;  set device disposer ( null )  ;   }   renew subscriber renew sub = get renew subscriber (  )  ;  if  ( renew sub  !  =  null )   {  renew sub . stop (  )  ;  set renew subscriber ( null )  ;   }   device list dl = get device list (  )  ;  for  ( int i = 0 ;  i  <  dl . size (  )  ;  i +  +  )   {  remove device ( dl . get device ( i )  )  ;   }  return true ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   single . zip array ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] v )  {  return null ;   }  
@ test public void   (  )  {  test helper ( "genomic   sorted . sam" "genomic   sorted . sam" 2 0 0 0 0 0 0 true )  ;   }  
private int   (  list <  tunnel pool >  wanted int allowed )  {  for  ( int i = 0 ;  i  <  wanted . size (  )  ;  i +  +  )   {   tunnel pool pool = wanted . get ( 0 )  ;  if  ( pool . get settings (  )  . get length (  )   =  =  0 )   {   pooled tunnel creator config cfg = pool . configure new tunnel (  )  ;  if  ( cfg  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " configuring short tunnel "  +  i  +  " for " +  pool +  ": " +  cfg )  ;  build tunnel ( pool cfg )  ;  if  ( cfg . get length (  )   >  1 )   {  allowed -  -  ;   }  wanted . remove ( i )  ;  i -  -  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " configured a null tunnel" )  ;   }   }   }  return allowed ;   }  
private void   ( final  subscriber <  ?  >  observer int delay )  {  inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  observer . on complete (  )  ;   }   }   delay  time unit . milliseconds )  ;   }  
public static void   (  connection con )  {  if  ( con  !  =  null )   {  try  {  con . close (  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  final  maybe subject <  integer >  ms1 =  maybe subject . create (  )  ;  final  maybe subject <  integer >  ms2 =  maybe subject . create (  )  ;   test 
@ test public void   (  )  {   maybe . just ( 1 )  . map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  throws  exception  {  throw new io exception (  )  ;   }   }   )  . test (  )  . assert failure ( io e
public int[]   (  )  {  return previous contribution ;   }  
@ override public void   ( t t )  {  complete ( t )  ;   }  
private void   (  )  {   log . debug ( " stopping executor service .  .  . " )  ;  executor . shutdown (  )  ;  try  {  if  (  ! executor . await termination ( 2  time unit . seconds )  )   {   log . debug ( " forcing a shutdown for the executor service  ( after a two - second timeout has elapsed .  .  . " )  ;  executor . shutdown now (  )  ;   }   }  catch  (   interrupted exception e )   {   }   }  
private void   (  byte buffer buf )  throws io exception  {   byte buffer tls buffer ;   byte buffer tls output ;  do  {  tls buffer =  byte buffer . allocate (  math . min ( buf . remaining (  )  wrapper . get app buff size (  )  )  )  ;  tls output =  byte buffer . allocate ( wrapper . get net buff size (  )  )  ;  while  ( tls buffer . has remaining (  )  && buf . has remaining (  )  )   {  tls buffer . put ( buf . get (  )  )  ;   }  tls buffer . flip (  )  ;  wrapper . wrap ( tls buffer tls output )  ;  tls output . flip (  )  ;  write to socket ( tls output )  ;  tls output . clear (  )  ;   }  while  ( buf . has remaining (  )  )  ;   }  
public boolean   (  )  {  return get state (  )   =  =   call state . established || get state (  )   =  =   call state . ending ;   }  
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  final  spsc linked array queue <  object[] >  q = queue ;  final  observer <  ?  super r >  a = actual ;  final boolean delay error = this . delay error ;  int missed = 1 ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  clear ( q )  ;  return ;   }  if  (  ! delay error && errors . get (  )   !  =  null )   {  cancel sources (  )  ;  clear ( q )  ;  a . on error ( errors . terminate (  )  )  ;  return ;   }  boolean d = done ;   object[] s = q . poll (  )  ;  boolean empty = s  =  =  null ;  if  ( d && empty )   {  clear ( q )  ;   throwable ex = errors . terminate (  )  ;  if  ( ex  =  =  null )   {  a . on complete (  )  ;   }  else  {  a . on error ( ex )  ;   }  return ;   }  if  ( empty )   {  break ;   }  r v ;  try  {  v =  object helper . require non null ( combiner . apply ( s )  " the combiner returned a null value" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  errors . add throwable ( ex )  ;  cancel sources (  )  ;  clear ( q )  ;  ex = errors . terminate (  )  ;  a . on error ( ex )  ;  return ;   }  a . on next ( v )  ;   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
@ test public void   (  )  {   single . equals (  single . just ( 1 )   single . just ( 1 )  . hide (  )  )  . test (  )  . assert result ( true )  ;   single . equals (  single . just ( 1 )   single . just ( 2 )  )  . test (  )  . assert result ( false )
@ test public void   (  )  {  final  list <  string >  errors = new  array list <  string >  (  )  ;   revert sam .  validation util . validate output params not by read group ( writable path null errors )  ;   assert . assert equals ( errors . size (  ) 
public int   (  hash l  hash r )  {   system . arraycopy ( l . get data (  )  0 data 0  hash . hash   length )  ;  byte[] tb = tmp . get data (  )  ;  sha256 generator . get instance (  )  . calculate hash ( data 0 2 *  hash . hash   length tb 0 )  ;   big integer ll =  hash distance . get distance (    hash tmp )  ;   system . arraycopy ( r . get data (  )  0 data 0  hash . hash   length )  ;  sha256 generator . get instance (  )  . calculate hash ( data 0 2 *  hash . hash   length tb 0 )  ;   big integer rr =  hash distance . get distance (    hash tmp )  ;  return ll . compare to ( rr )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject . create (  )  . single or error (  )  . filter (  functions . always true (  )  )  )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public boolean   (  )  {  return is bulldozer compatible ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . never (  )  . on backpressure latest (  )  )  ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;   element packet element =  (  element )  externalizable util . get instance (  )  . read serializable ( in )  ;  presence =
@ test public final void   (  )  throws  interrupted exception  {  final  atomic integer count received = new  atomic integer (  )  ;  final  atomic integer count generated = new  atomic integer (  )  ;  final  count down latch latch = new  count down lat
@ override public void   (  throwable t )  {  if  (  ! try on error ( t )  )   {   rx java plugins . on error ( t )  ;   }   }  
public void   (  session data data  element command )  {  data . set stage ( data . get stage (  )   -  1 )  ;  add stage information ( data command )  ;  add stage actions ( data command )  ;   }  
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public static  < t s >  flowable < t >    (  callable < s >  initial state  bi function < s  emitter < t >  s >  generator  consu
@ test public void   (  )  {  assert equals ( "\n\t\r\\&quot ; &apos ;  / &amp ; &lt ; &gt ; " new  http log formatter ( "%m"  http log formatter state . xml )  . format ( request response )  )  ;   }  
private void   (  node parent node )  throws  rrd exception  {  validate tags only once ( parent node new  string[] { "show   grid" "grid   step" "label   factor" }  )  ;  boolean show grid = true ;  double grid step =  double .  nan ;  int not   set =  integer . min   value  label factor = not   set ;   node[] child nodes = get child nodes ( parent node )  ;  for  (   node child node : child nodes )   {   string node name = child node . get node name (  )  ;  if  ( node name . equals ( "show   grid" )  )   {  show grid = get value as boolean ( child node )  ;   }  else if  ( node name . equals ( "grid   step" )  )   {  grid step = get value as double ( child node )  ;   }  else if  ( node name . equals ( "label   factor" )  )   {  label factor = get value as int ( child node )  ;   }   }  rrd graph def . set drawy grid ( show grid )  ;  if  (  !  double . is nan ( grid step )  && label factor  !  =  not   set )   {  rrd graph def . set value axis ( grid step label factor )  ;   }  else if  (  !  double . is nan ( grid step )  || label factor  !  =  not   set )   {  throw new  rrd exception ( " incomplete value axis settings" )  ;   }   }  
private synchronized void   (  )  {     fragments . shutdown (  )  ;  if  (    pusher  !  =  null )     pusher . shutdown (  )  ;  if  (    handler  !  =  null )     handler . shutdown (  )  ;  for  (  udp endpoint endpoint :    endpoints )   {  endpoint . shutdown (  )  ;     endpoints . remove ( endpoint )  ;   }  if  (    establisher  !  =  null )     establisher . shutdown (  )  ;  if  (    refiller  !  =  null )     refiller . shutdown (  )  ;     inbound fragments . shutdown (  )  ;     intro manager . reset (  )  ;  udp packet . clear cache (  )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " starting ssu transport listening" )  ;     intro key = new  session key ( new byte[ session key . keysize   bytes] )  ;   system . arraycopy (    context . router hash (  )  . get data (  )  0    intro key . get data (  )  0  session key . keysize   bytes )  ;   string bind to =    context . get property ( prop   bind   interface )  ;  if  ( bind to  =  =  null )   {   string fixed host =    context . get property ( prop   external   host )  ;  if  ( fixed host  !  =  null && fixed host . length (  )   >  0 )   {   transport util . i pv6 config cfg = geti pv6 config (  )  ;   set <  string >  my addrs ;  if  ( cfg  =  =  ipv6   disabled )  my addrs =  addresses . get addresses ( false false )  ;  else my addrs =  addresses . get addresses ( false true )  ;   string builder buf = new  string builder (  )  ;   string[] bta =  data helper . split ( fixed host "[  ;  \r\n\t]" )  ;  for  ( int i = 0 ;  i  <  bta . length ;  i +  +  )   {   string bt = bta[i] ;  if  ( bt . length (  )   <  =  0 )  continue ;  try  {   inet address[] all =  inet address . get all by name ( bt )  ;  for  ( int j = 0 ;  j  <  all . length ;  j +  +  )   {   inet address ia = all[j] ;  if  ( cfg  =  =  ipv6   only &&  ( ia instanceof  inet4 address )  )   {  if  (    log . should warn (  )  )     log . warn ( " configured for i pv6 only  not binding to configured i pv4 host "  +  bt )  ;  continue ;   }   string test addr = ia . get host address (  )  ;  if  ( my addrs . contains ( test addr )  )   {  if  ( buf . length (  )   >  0 )  buf . append ( ' ' )  ;  buf . append ( test addr )  ;   }  else  {  if  (    log . should warn (  )  )     log . warn ( " not a local address  not binding to configured ip "  +  test addr )  ;   }   }   }  catch  (   unknown host exception uhe )   {  if  (    log . should warn (  )  )     log . warn ( " not binding to configured host "  +  bt  +  "  -  " +  uhe )  ;   }   }  if  ( buf . length (  )   >  0 )   {  bind to = buf . to string (  )  ;  if  (    log . should warn (  )  &&  ! fixed host . equals ( bind to )  )     log . warn ( " expanded external host config \""  +  fixed host  +  "\" to \"" +  bind to +  '"' )  ;   }   }   }   set <  inet address >  bind to addrs = new  hash set <  inet address >  ( 4 )  ;  if  ( bind to  !  =  null )   {   string[] bta =  data helper . split ( bind to "[  ;  \r\n\t]" )  ;  for  ( int i = 0 ;  i  <  bta . length ;  i +  +  )   {   string bt = bta[i] ;  if  ( bt . length (  )   <  =  0 )  continue ;  try  {  bind to addrs . add (  inet address . get by name ( bt )  )  ;   }  catch  (   unknown host exception uhe )   {     log . error ( " invalid ssu bind interface specified ["  +  bt  +  "]" uhe )  ;   }   }   }  int port ;  int oldi port =    context . get property ( prop   internal   port  - 1 )  ;  int old bind port = get listen port ( false )  ;  int olde port =    context . get property ( prop   external   port  - 1 )  ;  if  ( oldi port  >  0 )  port = oldi port ;  else if  ( old bind port  >  0 )  port = old bind port ;  else port = olde port ;  if  (  ! bind to addrs . is empty (  )  &&    log . should log (  log . warn )  )     log . warn ( " binding only to "  +  bind to addrs )  ;  if  (    log . should log (  log . info )  )     log . info ( " binding to the port: "  +  port )  ;  if  (    endpoints . is empty (  )  )   {  if  ( bind to addrs . is empty (  )  )   {  udp endpoint endpoint = new udp endpoint (    context this port null )  ;     endpoints . add ( endpoint )  ;  setmtu ( null )  ;   }  else  {  for  (   inet address bind to addr : bind to addrs )   {  udp endpoint endpoint = new udp endpoint (    context this port bind to addr )  ;     endpoints . add ( endpoint )  ;  setmtu ( bind to addr )  ;   }   }   }  else  {  for  (  udp endpoint endpoint :    endpoints )   {  if  ( endpoint . isi pv4 (  )  )   {  endpoint . set listen port ( port )  ;  break ;   }   }   }  if  (    establisher  =  =  null )     establisher = new  establishment manager (    context this )  ;  if  (    handler  =  =  null )     handler = new  packet handler (    context this    establisher    inbound fragments    test manager    intro manager )  ;  if  ( use   priority &&    refiller  =  =  null )     refiller = new  outbound refiller (    context    fragments    outbound messages )  ;  int new port =  - 1 ;  for  (  udp endpoint endpoint :    endpoints )   {  try  {  endpoint . startup (  )  ;  if  ( new port  <  0 && endpoint . isi pv4 (  )  )   {  new port = endpoint . get listen port (  )  ;   }  if  (    log . should log (  log . warn )  )     log . warn ( " started "  +  endpoint )  ;   }  catch  (   socket exception se )   {     endpoints . remove ( endpoint )  ;     log . error ( " failed to start "  +  endpoint se )  ;   }   }  if  (    endpoints . is empty (  )  )   {     log . log (  log . crit " unable to open udp port" )  ;  set reachability status (  status . hosed )  ;  return ;   }  if  ( new port  >  0 &&  ( new port  !  =  port || new port  !  =  oldi port || new port  !  =  olde port )  )   {   map <  string  string >  changes = new  hash map <  string  string >  (  )  ;  changes . put ( prop   internal   port  integer . to string ( new port )  )  ;  changes . put ( prop   external   port  integer . to string ( new port )  )  ;     context . router (  )  . save config ( changes null )  ;   }     handler . startup (  )  ;     fragments . startup (  )  ;     inbound fragments . startup (  )  ;     pusher = new  packet pusher (    context    fragments    endpoints )  ;     pusher . startup (  )  ;     establisher . startup (  )  ;  if  ( use   priority )     refiller . startup (  )  ;     expire event . set is alive ( true )  ;     reachability status =  status . unknown ;     test event . set is alive ( true )  ;     test event . reschedule ( 10 * 1000 )  ;  if  ( new port  >  0 && bind to addrs . is empty (  )  )   {  for  (   inet address ia : get saved local addresses (  )  )   {  if  ( ia . get address (  )  . length  =  =  16 )   {     last inboundi pv6 =    context . clock (  )  . now (  )  ;  if  (  ! isi pv6 firewalled (  )  )  set reachability status (  status . ipv4   unknown   ipv6   ok true )  ;   }  else  {  if  (  ! isi pv4 firewalled (  )  )  set reachability status (  status . ipv4   ok   ipv6   unknown )  ;   }  rebuild external address ( ia . get host address (  )  new port false )  ;   }   }  else if  ( new port  >  0 &&  ! bind to addrs . is empty (  )  )   {  for  (   inet address ia : bind to addrs )   {  if  ( ia . get address (  )  . length  =  =  16 )   {     last inboundi pv6 =    context . clock (  )  . now (  )  ;  if  (  ! isi pv6 firewalled (  )  )  set reachability status (  status . ipv4   unknown   ipv6   ok true )  ;   }  else  {  if  (  ! isi pv4 firewalled (  )  )  set reachability status (  status . ipv4   ok   ipv6   unknown )  ;   }  rebuild external address ( ia . get host address (  )  new port false )  ;   }   }  if  ( isi pv4 firewalled (  )  )   {  if  (    last inboundi pv6  >  0 )  set reachability status (  status . ipv4   firewalled   ipv6   unknown )  ;  else set reachability status (  status . reject   unsolicited )  ;   }  rebuild external address ( false )  ;   }  
public static sam handler   (  socket channel s  properties i2cp props sam bridge parent )  throws sam exception  {   string line ;   log log = i2p app context . get global context (  )  . log manager (  )  . get log ( sam handler factory . class )  ;  try  {   socket sock = s . socket (  )  ;  sock . set keep alive ( true )  ;   string builder buf = new  string builder ( 128 )  ;   read line . read line ( sock buf hello   timeout )  ;  sock . set so timeout ( 0 )  ;  line = buf . to string (  )  ;   }  catch  (   socket timeout exception e )   {  throw new sam exception ( " timeout waiting for hello version" e )  ;   }  catch  (  io exception e )   {  throw new sam exception ( " error reading from socket" e )  ;   }  catch  (   runtime exception e )   {  throw new sam exception ( " unexpected error" e )  ;   }  if  ( log . should debug (  )  )  log . debug ( " new message received: ["  +  line  +  ']' )  ;   properties props = sam utils . parse params ( line )  ;  if  (  ! "hello" . equals ( props . remove ( sam utils . command )  )  ||  ! "version" . equals ( props . remove ( sam utils . opcode )  )  )   {  throw new sam exception ( " must start with hello version" )  ;   }   string min ver = props . get property ( "min" )  ;  if  ( min ver  =  =  null )   {  min ver = "1" ;   }   string max ver = props . get property ( "max" )  ;  if  ( max ver  =  =  null )   {  max ver = "99 . 99" ;   }   string ver = choose best version ( min ver max ver )  ;  if  ( ver  =  =  null )   {  sam handler . write string ( "hello reply result = noversion\n" s )  ;  return null ;   }  if  (  boolean . parse boolean ( i2cp props . get property ( sam bridge . prop   auth )  )  )   {   string user = props . get property ( "user" )  ;   string pw = props . get property ( "password" )  ;  if  ( user  =  =  null || pw  =  =  null )   {  if  ( user  =  =  null )  log . log always (  log . warn "sam authentication failed" )  ;  else log . log always (  log . warn "sam authentication failed  user: "  +  user )  ;  throw new sam exception ( "user and password required" )  ;   }   string savedpw = i2cp props . get property ( sam bridge . prop   pw   prefix  +  user  +  sam bridge . prop   pw   suffix )  ;  if  ( savedpw  =  =  null )   {  log . log always (  log . warn "sam authentication failed  user: "  +  user )  ;  throw new sam exception ( " authorization failed" )  ;   }   password manager pm = new  password manager ( i2p app context . get global context (  )  )  ;  if  (  ! pm . check hash ( savedpw pw )  )   {  log . log always (  log . warn "sam authentication failed  user: "  +  user )  ;  throw new sam exception ( " authorization failed" )  ;   }   }  if  (  ! sam handler . write string ( "hello reply result = ok version = "  +  ver  +  "\n" s )  )  throw new sam exception ( " error writing to socket" )  ;  int ver major = get major ( ver )  ;  int ver minor = get minor ( ver )  ;  sam handler handler ;  try  {  switch  ( ver major )   {  case 1: handler = new sa mv1 handler ( s ver major ver minor i2cp props parent )  ;  break ;  case 2: handler = new sa mv2 handler ( s ver major ver minor i2cp props parent )  ;  break ;  case 3: handler = new sa mv3 handler ( s ver major ver minor i2cp props parent )  ;  break ;  default : log . error ( "bug !   trying to initialize the wrong sam version ! " )  ;  throw new sam exception ( "bug !   ( in handler instantiation ) " )  ;   }   }  catch  ( io exception e )   {  log . error ( " error creating the handler for version "  +  ver major e )  ;  throw new sam exception ( "io exception caught during sam handler instantiation" )  ;   }  return handler ;   }  
@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt bean )   -  >   {  final  string prefix =  (  (  bind methods ) anno
private void   (  )  {  long now =    context . clock (  )  . now (  )  ;  if  (    reset sent on . get (  )   +  10 * 1000  >  now )  return ;  if  (    reset received . get (  )  )  return ;     reset sent on . set ( now )  ;  if  (  (    remote peer  =  =  null )  ||  (    send stream id . get (  )   <  =  0 )  )  return ;   packet local reply = new  packet local (    context    remote peer this )  ;  reply . set flag (  packet . flag   reset )  ;  reply . set flag (  packet . flag   signature   included )  ;  reply . set send stream id (    send stream id . get (  )  )  ;  reply . set receive stream id (    receive stream id . get (  )  )  ;  reply . set optional from (  )  ;  reply . set local port (    local port )  ;  reply . set remote port (    remote port )  ;  if  (    outbound queue . enqueue ( reply )  )   {     unacked packets received . set ( 0 )  ;     last send time =    context . clock (  )  . now (  )  ;  reset activity timer (  )  ;   }   }  
private static void   ( final  context context )  {  synchronized  ( s notification delayed message lock )   {  if  ( s notification delayed message pending )   {  s refresh all needed = true ;   }  else  {  ensure handler exists (  )  ;  s notification handler . send message delayed ( android . os .  message . obtain ( s notification handler notification   delayed   message context )  notification   delay )  ;  s notification delayed message pending = true ;  refresh all notifications internal ( context )  ;   }   }   }  
@ override public  maybe source <  object >    (  maybe <  object >  m )  throws  exception  {  return m . take until (  maybe . never (  )  )  ;   }  
protected static void   (  string media source )  {  sip config . media source = media source ;   }  
@ override public void   (  handle handle )  {  delegate . begin ( handle )  ;   }  
private final void   ( byte orig[] int offset )  {     context . aes (  )  . encrypt block ( orig offset    config . getiv key (  )  orig offset )  ;   }  
protected static void   ( final sam record read1 final sam record read2 )  {  if  (  !  ( read1 . get read unmapped flag (  )  || read2 . get read unmapped flag (  )  )  )   {  if  ( read1 . get read negative strand flag (  )   !  =  read2 . get read negative strand flag (  )  )   {  final sam record pos =  ( read1 . get read negative strand flag (  )  )   ?  read2 : read1 ;  final sam record neg =  ( read1 . get read negative strand flag (  )  )   ?  read1 : read2 ;  if  ( pos . get alignment start (  )   <  neg . get alignment end (  )  )   {  final int pos diff = pos . get alignment end (  )   -  neg . get alignment end (  )  ;  final int neg diff = pos . get alignment start (  )   -  neg . get alignment start (  )  ;  if  ( pos diff  >  0 )   {  final  list <  cigar element >  elems = new  array list <  >  ( pos . get cigar (  )  . get cigar elements (  )  )  ;   collections . reverse ( elems )  ;  final int clipped = length of soft clipping ( elems . iterator (  )  )  ;  final int clip from = pos . get read length (  )   -  pos diff  -  clipped  +  1 ;   cigar util . soft clip3 prime end of read ( pos  math . min ( pos . get read length (  )  clip from )  )  ;  remove nm md and uq tags ( pos )  ;   }  if  ( neg diff  >  0 )   {  final int clipped = length of soft clipping ( neg . get cigar (  )  . get cigar elements (  )  . iterator (  )  )  ;  final int clip from = neg . get read length (  )   -  neg diff  -  clipped  +  1 ;   cigar util . soft clip3 prime end of read ( neg  math . min ( neg . get read length (  )  clip from )  )  ;  remove nm md and uq tags ( neg )  ;   }   }   }   }   }  
private static  string   (  string s  object o  object o2 )  {  return  messages . get string ( s o o2 )  ;   }  
@ test public void   (  )  {  assert true ( new  composite exception (  (  throwable[] ) null )  . get exceptions (  )  . get ( 0 )  instanceof  null pointer exception )  ;  assert true ( new  composite exception (  (  iterable <  throwable >  ) null )  .
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . just ( 1 3 5 7 9 7 5 3 1 )  ;  observable . filter ( is   even )  . take ( 1 )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w times
private static byte[]   (  string oid )  {   byte array output stream baos = new  byte array output stream ( 16 )  ;  baos . write ( 0x06 )  ;  baos . write ( 0 )  ;   string[] f =  data helper . split ( oid "[ . ]" )  ;  if  ( f . length  <  2 )  throw new  illegal argument exception ( "length: "  +  f . length )  ;  baos . write (  ( 40 *  integer . parse int ( f[0] )  )   +   integer . parse int ( f[1] )  )  ;  for  ( int i = 2 ;  i  <  f . length ;  i +  +  )   {  int v =  integer . parse int ( f[i] )  ;  if  ( v  >  =  128 * 128 * 128 || v  <  0 )  throw new  illegal argument exception (  )  ;  if  ( v  >  =  128 * 128 )  baos . write (  ( v  >  >  14 )  | 0x80 )  ;  if  ( v  >  =  128 )  baos . write (  ( v  >  >  7 )  | 0x80 )  ;  baos . write ( v & 0x7f )  ;   }  byte[] rv = baos . to byte array (  )  ;  if  ( rv . length  >  129 )  throw new  illegal argument exception (  )  ;  rv[1] =  ( byte )  ( rv . length  -  2 )  ;  return rv ;   }  
@ test public void   (  )  {   flowable <  string >  w =  flowable . just ( "one" "fail" "two" "three" "fail" )  ;  w = w . map ( new  function <  string  string >  (  )  {  @ override public  string apply (   string s )  {  if  ( "fail" . equals ( s )  )
public static  string   ( long bytes )  {  float val = bytes ;  int scale = 0 ;  while  ( val  >  =  1024 . 0f )   {  scale +  +  ;  val /  = 1024 . 0f ;   }   decimal format fmt = new  decimal format ( "##0 . 00" )  ;   string str = fmt . format ( val )  ;  switch  ( scale )   {  case 1: return str  +  " ki" ;  case 2: return str  +  " mi" ;  case 3: return str  +  " gi" ;  case 4: return str  +  " ti" ;  case 5: return str  +  " pi" ;  case 6: return str  +  " ei" ;  case 7: return str  +  " zi" ;  case 8: return str  +  " yi" ;  default : return  long . to string ( bytes )  ;   }   }  
@ override public  subscriber <  ?  super  long >    ( final  subscriber <  ?  super  long >  child )  {  return new  default subscriber <  long >  (  )  {  @ override public void on complete (  )  {   }  @ override public void on error (   throwable e ) 
public  double   (  )  {  a (  )  ;  h h = g (  )  ;  if  ( h  =  =  com . jcumulus . server . rtmfp . flow . h .  null )   {  f . d ( 1 )  ;  return  double . value of ( 0 . 0d )  ;   }  if  ( h  !  =  com . jcumulus . server . rtmfp . flow . h .  number )   {  d . error (  ( new  string builder (  )  )  . append ( " type " )  . append ( h )  . append ( " is not a amf  number type" )  . to string (  )  )  ;  return  double . value of ( 0 . 0d )  ;   }  else  {  f . d ( 1 )  ;  return  double . value of ( f . b (  )  )  ;   }   }  
void   (  )  {   toolkit t =  toolkit . get default toolkit (  )  ;   dimension screen size = t . get screen size (  )  ;   dimension frame size = get preferred size (  )  ;  double x =  ( screen size . get width (  )   -  frame size . get width (  )  )   /  2 ;  double y =  ( screen size . get height (  )   -  frame size . get height (  )  )   /  2 ;  set location (  ( int ) x  ( int ) y )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  rp =  replay subject . create with time and size ( 1  time unit . days  schedulers . single (  )  2 )  ;  rp . on next ( 1 )  ;  rp . on next ( 2 )  ;  rp . on next ( 3 )  ;  rp . on next ( 4 )  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable processor <  integer >  subject =  replay processor . create (  )  ;  subject . on next ( null )  ;  subject . blocking subscribe (  )  ;   }  
public static boolean   (  certificate cert  file file )  {   output stream os = null ;  try  {  os = new  secure file output stream ( file )  ;  export cert ( cert os )  ;  return true ;   }  catch  (   certificate encoding exception cee )   {  error ( " error writing x509  certificate "  +  file . get absolute path (  )  cee )  ;  return false ;   }  catch  (  io exception ioe )   {  error ( " error writing x509  certificate "  +  file . get absolute path (  )  ioe )  ;  return false ;   }  finally  {  try  {  if  ( os  !  =  null )  os . close (  )  ;   }  catch  (  io exception foo )   {   }   }   }  
public   (  blocking queue < i2cp message >  in  blocking queue < i2cp message >  out )  {     in = in ;     out = out ;   }  
boolean   (  )  {  return is registered ;   }  
public static  string   (  collection <  string >  collection )  {  if  ( collection  =  =  null || collection . is empty (  )  )   {  return "" ;   }   string builder buf = new  string builder (  )  ;   string delim = "" ;  for  (   string element : collection )   {  buf . append ( delim )  ;  buf . append ( element )  ;  delim = " " ;   }  return buf . to string (  )  ;   }  
@ test public void   (  )  {   maybe . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  throw new  unsupported operation exception (  )  ;   }   }   )  . test (  )  . assert failure (  unsupported operation exception . class )  ;
@ override protected void   (  maybe observer <  ?  super t >  observer )  {   disposable d =  disposables . empty (  )  ;  observer . on subscribe ( d )  ;  if  (  ! d . is disposed (  )  )   {  try  {  runnable . run (  )  ;   }  catch  (   throwable ex
  (  string name )  {  m cache = null ;  m name = name ;   }  
public   (  )  {  this . message strategy = xmpp server . get instance (  )  . get offline message strategy (  )  ;   }  
@ override public void   (  integer t )  {  try  {   thread . sleep ( 100 )  ;   }  catch  (   interrupted exception e )   {   }   }  
public void   (  )  {  boolean g = false ;  i2p socket sess socket = null ;  int conn = 0 ;  try  {  try  {  server socket . set so timeout ( 50 )  ;  while  ( lives . get (  )  )   {  try  {  sess socket = server socket . accept (  )  ;  g = true ;   }  catch  (   connect exception ce )   {  g = false ;   }  catch  (   socket timeout exception ste )   {  g = false ;   }  if  ( g )   {  g = false ;  conn +  +  ;  i2 ptotcp conn   c = new i2 ptotcp ( sess socket info database lives )  ;   thread t = new i2p app thread ( conn   c  thread . current thread (  )  . get name (  )   +  " i2 ptotcp "  +  conn )  ;  t . start (  )  ;   }   }   }  catch  (  i2p exception e )   {   system . out . println ( " exception "  +  e )  ;   }   }  finally  {  try  {  server socket . close (  )  ;   }  catch  (  i2p exception ex )   {   }   }   }  
public  string   (  long serviceid )  {  return load service subdomain ( serviceid )  ;   }  
@ override public  object   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  boundary =  publish subject . create (  )  ;   observer <  object >  o =  test helper . mock observer (  )  ;   in orde
public void   (  )  {  for  ( int i = 0 ;  i  <  5 ;  i +  +  )   {   object keys[] =  key generator . get instance (  )  . generatepki keypair (  )  ;   public key pub key =  (  public key ) keys[0] ;   private key priv key =  (  private key ) keys[1] ;  byte[] msg = new byte[400] ;   random source . get instance (  )  . next bytes ( msg )  ;   session key key =    context . session key manager (  )  . get current key ( pub key )  ;  if  ( key  =  =  null )  key =    context . session key manager (  )  . create session ( pub key )  ;  byte[] encrypted =    context . el gamalaes engine (  )  . encrypt ( msg pub key key null null 1024 )  ;  byte[] decrypted = null ;  try  {  decrypted =    context . el gamalaes engine (  )  . decrypt ( encrypted priv key    context . session key manager (  )  )  ;   }  catch  (   data format exception dfe )   {  dfe . print stack trace (  )  ;  fail (  )  ;   }  assert true (  data helper . eq ( msg decrypted )  )  ;   }   }  
public static  string   (  string str )  {  str = newlinere . matcher ( str )  . replace all ( "\\\n" )  ;  str = htmlre . matcher ( str )  . replace all ( "" )  ;  str = org . jivesoftware . util .  string utils . unescape fromxml ( str )  ;  return str ;   }  
public   (  maybe source <  ?  extends t > [] sources )  {  this . sources = sources ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;  final  publish subject <  integer >  timeout =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >  timeout func = new
private  file   (  string host int port  string user  string pass  string folder )  throws io exception  {   file f = new  secure directory (    context . get config dir (  )  dir   susi )  ;  if  (  ! f . exists (  )  &&  ! f . mkdir (  )  )  throw new io exception ( " cannot create "  +  f )  ;  f = new  secure directory ( f dir   cache )  ;  if  (  ! f . exists (  )  &&  ! f . mkdir (  )  )  throw new io exception ( " cannot create "  +  f )  ;  f = new  secure directory ( f cache   prefix  +   base64 . encode ( user  +  host  +  port )  )  ;  if  (  ! f . exists (  )  &&  ! f . mkdir (  )  )  throw new io exception ( " cannot create "  +  f )  ;   file base = new  secure directory ( f folder )  ;  if  (  ! base . exists (  )  &&  ! base . mkdir (  )  )  throw new io exception ( " cannot create "  +  base )  ;  for  ( int i = 0 ;  i  <  b64 . length (  )  ;  i +  +  )   {  f = new  secure directory ( base dir   prefix  +  b64 . char at ( i )  )  ;  if  (  ! f . exists (  )  &&  ! f . mkdir (  )  )  throw new io exception ( " cannot create "  +  f )  ;   }  return base ;   }  
@ override public i binder   (  intent intent )  {  return m sync adapter . get sync adapter binder (  )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . filter (  functions . always true (  )  )  . filter (  functions . always true (  )  )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
private void   (  )  throws  rrd exception  {  int hour  minute = 0 ;  scanner . save state (  )  ;  if  ( token . value . length (  )   >  2 )   {  return ;   }  hour =  integer . parse int ( token . value )  ;  token = scanner . next token (  )  ;  if  ( token . id  =  =   time token . slash )   {  token = scanner . restore state (  )  ;  return ;   }  if  ( token . id  =  =   time token . colon || token . id  =  =   time token . dot )   {  expect token (  time token . number " parsing hh:mm or hh . mm syntax  expecting mm as number  got none" )  ;  minute =  integer . parse int ( token . value )  ;  if  ( minute  >  59 )   {  throw new  rrd exception ( " parsing hh:mm or hh . mm syntax  got mm  =  "  +  minute  +  "  (  > 59 !  ) " )  ;   }  token = scanner . next token (  )  ;  if  ( token . id  =  =   time token . dot )   {  token = scanner . restore state (  )  ;  return ;   }   }  if  ( token . id  =  =   time token . am || token . id  =  =   time token . pm )   {  if  ( hour  >  12 )   {  throw new  rrd exception ( " there cannot be more than 12 am or pm hours" )  ;   }  if  ( token . id  =  =   time token . pm )   {  if  ( hour  !  =  12 )   {  hour +  = 12 ;   }   }  else  {  if  ( hour  =  =  12 )   {  hour = 0 ;   }   }  token = scanner . next token (  )  ;   }  else if  ( hour  >  23 )   {  token = scanner . restore state (  )  ;  return ;   }  spec . hour = hour ;  spec . min = minute ;  spec . sec = 0 ;  if  ( spec . hour  =  =  24 )   {  spec . hour = 0 ;  spec . day +  +  ;   }   }  
public void   ( boolean choke )  {   peer state s = state ;  if  ( s  !  =  null )  s . set choking ( choke )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
public   (  string value )  {  this . value = value ;   }  
@ override public void   (  )  {  if  ( crash dispose )   {  throw new  test exception ( "cancel (  ) " )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable processor <  integer >  subject =  async processor . create (  )  ;  subject . on next ( null )  ;  subject . blocking subscribe (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  maybe < t >    (  predicate <  ?  super  throwable >  predicate )  {  return retry (  long . max   value predicate )  ;   }  
public void   ( final int x )  {  if  ( x is set (  )  )   {  if  ( this . x  !  =  x )   {  throw new  picard exception ( "x value mismatch for "  +  this  +  " : " +  this . x +  "  !  =  " +  x )  ;   }   }  else  {  this . x = x ;   }   }  
public  string   (  string code )  {  return    code to name . get ( code )  ;   }  
private  naming service   (  )  {   naming service root =    context . naming service (  )  ;   naming service rv = search naming service ( root get file name (  )  )  ;  return rv  !  =  null  ?  rv : root ;   }  
public static void   (  string args[] )  {  try  {   inet address local address =  inet address . get local host (  )  ;   sip account sip account = new  sip account ( "" "" "" "" "" "" "" false )  ;  sip test sip test = new sip test ( local address sip account )  ;  sip test . test ( 3000 2 )  ;   }  catch  (   unknown host exception e )   {  e . print stack trace (  )  ;   }   }  
public   ( i2p app context ctx i2p session session )  {  super ( ctx session )  ;   }  
public long   (  )  {  return downloaded . get (  )  ;   }  
public  field element   (  field element val )  {  return new  big integer field element ( f bi . multiply (  (  (  big integer field element ) val )  . bi )  )  . mod ( f . getq (  )  )  ;   }  
public void   (  )  throws  exception  {  setup copy messages ( true )  ;  m copy mock . expect ( get copy messages pattern (  )  new  string[] { "*  no  some error occured during the copy" get next tag ( true )   +  " ok [copyuid 777 11 12 45 46] uid copy completed" }  )  ;   message update callback counter cb = new  message update callback counter (  )  ;  m folder . copy messages ( m copy messages m copy to folder cb )  ;  assert equals ( 0 cb . message not found called )  ;  assert equals ( 2 cb . message uid change called )  ;   }  
protected void   (  session data data  element command )  {   element actions = command . add element ( "actions" )  ;   list <  action >  valid actions = get actions ( data )  ;  for  (   ad hoc command .  action action : valid actions )   {  actions . add element ( action . name (  )  )  ;   }   action execute action = get execute action ( data )  ;  actions . add attribute ( "execute" execute action . name (  )  )  ;  data . set allowed actions ( valid actions )  ;  data . set execute action ( execute action )  ;   }  
public   (  )  {  charsets =  arrays . as list ( new  charset[] { utf7charset imap4charset utf7o charset }  )  ;   }  
public  tunnel id   (  )  {  return    reply tunnel ;   }  
public  string   (  )  {  return ds name ;   }  
@post @ path ( " / " )  public  response   (  string body @ context  http servlet request request )  {  return provider . get end service ( default   response   code request body )  ;   }  
@ test public void   (  )  {   behavior processor <  object >  as =  behavior processor . create (  )  ;  assert false ( as . has value (  )  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as
@ scheduler support (  scheduler support . none )  @ check return value @ backpressure support (  backpressure kind . full )  public static  < t r >  flowable < r >    (  iterable <  ?  extends  publisher <  ?  extends t >  >  sources  function <  ?  supe
@ override public  transport session <  my spaceim buddy >    (  registration registration jid jid  presence type presence type  string verbose status  integer priority )  {   transport session <  my spaceim buddy >  session = new  my spaceim session ( re
public void   (  runnable task )  {     final shutdown tasks . add ( task )  ;   }  
public static  string   (  context context )  {  final  string device id ;  try  {   telephony manager tm =  (  telephony manager ) context . get system service (  context . telephony   service )  ;  if  ( tm  =  =  null )   {  return null ;   }  device id = tm . get device id (  )  ;  if  ( device id  =  =  null )   {  return null ;   }   }  catch  (   exception e )   {   log utils . d (  logging . log   tag " error in  telephony manager . get device id (  ) : "  +  e . get message (  )  )  ;  return null ;   }  return  utility . get small hash ( device id )  ;   }  
@ override public  integer   (  integer a  integer b )  throws  exception  {  return a  +  b ;   }  
@ test public void   (  )  {   test scheduler sch = new  test scheduler (  )  ;   single subject <  integer >  subj =  single subject . create (  )  ;  subj . timeout ( 1  time unit . seconds sch  single . just ( 1 )  )  . test ( true )  . assert empty ( 
@ override public  string   (  )  {  return "scram - sha - 1" ;   }  
public int   (  )  {  synchronized  ( state lock )   {  try  {  state lock . wait (  )  ;   }  catch  (   interrupted exception ex )   {  ex . print stack trace (  )  ;   }  return call state ;   }   }  
public int   (  )  {  return  (  (    len  +  3 )   /  4 )  * 4 ;   }  
public int   (  )  {  return executor . get maximum pool size (  )  ;   }  
@ test public void   (  )  throws  exception  {  mock columns ( "long field" )  ;   long expected = 1l ;  mock long result ( expected )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field (  )  )  
public  string   (  )  {   string dispatch path = request path ;  if  ( dispatch path . starts with ( context )  )   {  dispatch path = dispatch path . substring ( context . length (  )  )  ;   }  return dispatch path ;   }  
@ override public void   (  connection close listener listener )  {  if  ( close listener  =  =  listener )   {  close listener = null ;   }   }  
@ override public void   (  )  throws  illegal state exception  {  super . start (  )  ;   }  
public static  list < o auth provider >    ( final  context context )  {  try  {   list < o auth provider >  providers = new  array list < o auth provider >  (  )  ;  final  xml resource parser xml = context . get resources (  )  . get xml ( r . xml . oauth )  ;  int xml event type ;  o auth provider provider = null ;  while  (  ( xml event type = xml . next (  )  )   !  =   xml resource parser . end   document )   {  if  ( xml event type  =  =   xml resource parser . start   tag && "provider" . equals ( xml . get name (  )  )  )   {  try  {  provider = new o auth provider (  )  ;  provider . id = get xml attribute ( context xml "id" )  ;  provider . label = get xml attribute ( context xml "label" )  ;  provider . auth endpoint = get xml attribute ( context xml "auth   endpoint" )  ;  provider . token endpoint = get xml attribute ( context xml "token   endpoint" )  ;  provider . refresh endpoint = get xml attribute ( context xml "refresh   endpoint" )  ;  provider . response type = get xml attribute ( context xml "response   type" )  ;  provider . redirect uri = get xml attribute ( context xml "redirect   uri" )  ;  provider . scope = get xml attribute ( context xml "scope" )  ;  provider . state = get xml attribute ( context xml "state" )  ;  provider . client id = get xml attribute ( context xml "client   id" )  ;  provider . client secret = get xml attribute ( context xml "client   secret" )  ;  providers . add ( provider )  ;   }  catch  (   illegal argument exception e )   {   log utils . w (  logging . log   tag "providers line: "  +  xml . get line number (  )   +  " ;   domain contains multiple globals" )  ;   }   }   }  return providers ;   }  catch  (   exception e )   {   log utils . e (  logging . log   tag " error while trying to load provider settings . " e )  ;   }  return null ;   }  
@ test public void   (  )  {   maybe <  integer >  observable =  flowable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single element (  )  ;   m
private static iq   ( iq packet )  {  iq reply packet = iq . create resultiq ( packet )  ;   element reply = reply packet . set child element ( "query" namespace   jabber   iq   search )  ;  final  data form unavailable form = new  data form (  data form .  type . cancel )  ;  unavailable form . set title (  locale utils . get localized string ( "advance . user . search . title" "search" )  )  ;  unavailable form . add instruction (  locale utils . get localized string ( "search . service   unavailable" "search" )  )  ;  reply . add ( unavailable form . get element (  )  )  ;  return reply packet ;   }  
public  string   (  )  {  return config table (  search helper . prop   engines  search helper . engines   default )  ;   }  
  (  string message )  {  super ( message )  ;   }  
public int   (  )  throws sql exception  {  return cstmt . get query timeout (  )  ;   }  
public  per tile cycle parser <  mock cycled illumina data >    (  )  {  final  cycle illumina file map file map = get illumina file maps ( default   tiles cycles )  ;  return new  mock per tile cycle parser ( new  file ( " fake file" )  1 file map output   mapping )  ;   }  
@ test public void   (  )  {   test scheduler sch = new  test scheduler (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   flowable replay <  integer >  co =  (  flowable replay <  integer >  ) source . replay ( 1  ti
sa mv3 datagram server   (  properties props )  throws io exception  {   string host = props . get property ( prop   datagram   host default   datagram   host )  ;  int port ;   string port str = props . get property ( prop   datagram   port default   datagram   port )  ;  try  {  port =  integer . parse int ( port str )  ;   }  catch  (   number format exception e )   {  port = default   datagram   port   int ;   }  synchronized  (    v3dg server lock )   {  if  (    v3dg server  =  =  null )   {     v3dg server = new sa mv3 datagram server ( this host port props )  ;     v3dg server . start (  )  ;   }  else  {  if  (    v3dg server . get port (  )   !  =  port ||  !    v3dg server . get host (  )  . equals ( host )  )  throw new io exception ( " already have v3  datagram server with host = "  +  host  +  " port = " +  port )  ;   }  return    v3dg server ;   }   }  
public void   (  )  {   imap list list = new  imap list (  )  ;  assert true ( list . is list (  )  )  ;  assert false ( list . is string (  )  )  ;  assert true ( list . is empty (  )  )  ;  assert equals ( 0 list . size (  )  )  ;  list . add ( string   1 )  ;  assert false ( list . is empty (  )  )  ;  assert equals ( 1 list . size (  )  )  ;  list . add ( string   2 )  ;  assert equals ( 2 list . size (  )  )  ;  list . add ( list   1 )  ;  assert equals ( 3 list . size (  )  )  ;   }  
private static final  string   (  string s )  {  return s ;   }  
@ data provider ( name = "test best fragment mapq strategy" )  public  object[][]   (  )  {  return new  object[][] {  { "single alignment first end" new int[] { 12 }  new int[0] 12  - 1 }   { "single alignment second end" new int[0] new int[] { 12 }   - 
@ test public void   (  )  {   observable <  string >  subject =  observable . from array ( new  string[] { "zero" "one" "two" "three" "four" "five" }  )  ;   observable <  observable <  string >  >  windowed = subject . window ( 3 1 )  ;   list <  list <
  (  subscriber <  ?  super  integer >  actual int index int end )  {  super ( index end )  ;  this . actual = actual ;   }  
private void   (  )  {  try  {   runtime . get runtime (  )  . exec ( "uninstall   i2p   service   winnt . bat" )  ;  add form notice (    t ( " service removed" )  )  ;   }  catch  (  io exception ioe )   {  add form error (    t ( " warning: unable to remove the service" )   +  "  -  "  +  ioe . get message (  )  )  ;   }   }  
public void   (  group shared group )  {  shared groups . remove ( shared group . get name (  )  )  ;  invisible shared groups . remove ( shared group . get name (  )  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ test public void   (  )  throws  exception  {   merger bi function <  integer >  merger = new  merger bi function <  integer >  ( new  comparator <  integer >  (  )  {  @ override public int compare (   integer o1   integer o2 )  {  return o1 . compare 
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;   flowable . range ( 1 2 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )
public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write safeutf ( out streamid . getid (  )  )  ;   }  
public synchronized ssl context   (  )  throws  no such algorithm exception   key management exception   key store exception   unrecoverable key exception  {  final ssl context ssl context = ssl context . get instance ( "tl sv1" )  ;  ssl context . init ( get key managers (  )  get trust managers (  )  new  secure random (  )  )  ;  return ssl context ;   }  
public static  collector <  integer  ?   optional int >    (  )  {  return to optional (  optional int::empty  optional int::of )  ;   }  
@ test public void   (  )  {  handle . register column mapper ( user name factory )  ;  handle . register row mapper (  constructor mapper . factory (  named user . class )  )  ;   named user bob = handle . create query ( "select id  name from user where 
public void   (  )  {   thread this thread =  thread . current thread (  )  ;   control point ctrl point = get control point (  )  ;  while  ( device search response thread  =  =  this thread )   {   thread . yield (  )  ;  ssdp packet packet = receive (  )  ;  if  ( packet  =  =  null )  break ;  if  ( ctrl point  !  =  null )  ctrl point . search response received ( packet )  ;   }   }  
public static  account setup outgoing fragment   ( boolean settings mode )  {  final  account setup outgoing fragment f = new  account setup outgoing fragment (  )  ;  f . set arguments ( get args ( settings mode )  )  ;  return f ;   }  
public   ( int start int count )  {  this . start = start ;  this . end =  ( long ) start  +  count ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ test public void   (  )  {   eddsa private key spec key = new  eddsa private key spec ( zero   seed ed25519 )  ;  assert that ( key . get seed (  )  is ( equal to ( zero   seed )  )  )  ;  assert that ( key . geta (  )  . to byte array (  )  is ( equal 
@ override public  handler decorators   (  )  {  return new  handler decorators ( this )  ;   }  
@delete @ path ( " /  { username } " )  public  response   ( @ path param ( "username" )   string username )  throws  service exception  {  plugin . enable user ( username )  ;  return  response . status (  response .  status . ok )  . build (  )  ;   }  
public   (  context context )  {  super ( context )  ;   }  
protected static void   (  string s )  {  synchronized  (    cache )   {     cache . remove ( s )  ;   }   }  
public long   (  )  {  return    last store successful ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   null new  consumer <  object >  (  )  {  @ override public
@ override protected void   (  observer <  ?  super u >  t )  {  source . subscribe ( new  buffer exact boundary observer < t u b >  ( new  serialized observer < u >  ( t )  buffer supplier boundary )  )  ;   }  
@ override public  set <  string >    (  string path )  {  return context . get resource paths ( path )  ;   }  
public  string   (  )  {  return this . code ;   }  
public boolean   (  )  {  return y  !  =   - 1 ;   }  
@ test public void   (  )  {  final  disposable underlying = mock (  disposable . class )  ;  serial disposable . set ( underlying )  ;  assert same ( underlying serial disposable . get (  )  )  ;  final  disposable another = mock (  disposable . class ) 
@ test public void   (  )  {   observable . range ( 1 1000 )  . take last ( 1  time unit . days )  . take ( 500 )  . observe on (  schedulers . single (  )  true 1 )  . test (  )  . await done ( 5  time unit . seconds )  . assert subscribed (  )  . assert
public static int   (  file dir  key store ks )  {  info ( " looking for x509  certificates in "  +  dir . get absolute path (  )  )  ;  int added = 0 ;  if  ( dir . exists (  )  && dir . is directory (  )  )   {   file[] files = dir . list files (  )  ;  if  ( files  !  =  null )   {   cert store cs =  cert util . loadcr ls (  )  ;  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {   file f = files[i] ;  if  (  ! f . is file (  )  )  continue ;   string alias = f . get name (  )  . to lower case (  locale . us )  ;  if  ( alias . ends with ( " . crt" )  || alias . ends with ( " . pem" )  || alias . ends with ( " . key" ) || alias . ends with ( " . der" ) || alias . ends with ( " . key" ) || alias . ends with ( " . p7b" ) || alias . ends with ( " . p7c" ) || alias . ends with ( " . pfx" ) || alias . ends with ( " . p12" ) || alias . ends with ( " . cer" )  )  alias = alias . substring ( 0 alias . length (  )   -  4 )  ;  boolean success = add cert ( f alias ks cs )  ;  if  ( success )  added +  +  ;   }   }   }  return added ;   }  
@ override protected  class <  ?  >    ( final  object stream class desc )  throws  class not found exception  {  return load class ( desc . get name (  )  )  ;   }  
@ override public  collection <  string >    ( jid user )  {   set <  string >  answer = new  hash set <  >  (  )  ;   collection <  string >  user groups = get group names ( user )  ;  answer . add all ( user groups )  ;  for  (   string user group : use
@ override public final  flowable emitter < t >    (  )  {  return new  serialized emitter < t >  ( this )  ;   }  
public static boolean   (  )  {  return bc   available ;   }  
private void   (  conference member old member )  {   array list private mixes for me = old member . get private mixes for me (  )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( old member  +  " private mixes for me "  +  old member . get private mixes for me (  )  . size (  )  )  ;   }   conference member[] pm array for me =  (  conference member[] ) private mixes for me . to array ( new  conference member[0] )  ;  for  ( int i = 0 ;  i  <  pm array for me . length ;  i +  +  )   {   conference member m = pm array for me[i] ;   mix manager mix manager = m . get mix manager (  )  ;  synchronized  ( mix manager )   {   mix descriptor[] mix descriptors =  (  mix descriptor[] ) mix manager . get mix descriptors (  )  . to array ( new  mix descriptor[0] )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( "member with pm "  +  m  +  " descriptors before .  .  . " )  ;  mix manager . show descriptors (  )  ;   }  for  ( int j = 0 ;  j  <  mix descriptors . length ;  j +  +  )   {   mix descriptor md = mix descriptors[j] ;  if  ( md . is private mix (  )   =  =  false )   {   logger . println ( this  +  "  skipping md for "  +  md )  ;  continue ;   }   member receiver mr =  (  member receiver ) md . get mix data source (  )  ;  if  ( mr . get member (  )   !  =  old member )   {   logger . println ( this  +  " md "  +  md +  " not an md for old member " +  mr )  ;  continue ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( "setting pm for "  +  m  +  " to new member " +  this . get member receiver (  )  )  ;   }  m . remove private mix ( old member )  ;  synchronized  ( mix map )   {  m . apply private mix ( this md . get spatial values (  )  )  ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( "member with pm "  +  m  +  " descriptors after .  .  . " )  ;  mix manager . show descriptors (  )  ;   }  break ;   }   }   }   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c =  completable . concat (  collections . singleton ( normal . completable )  )  ;  c . blocking await (  )  ;  normal . assert subscriptions ( 1 )  ;   }  
public   ( muc room muc room  history strategy history strategy )  {  this . room = muc room ;  this . is non anonymous room = muc room . can anyone discoverjid (  )  ;  this . history strategy = history strategy ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . sync )  ;   observable . range ( 1 5 )  . hide (  )  . do finally ( this )  . subscribe ( to )  ;   observer fusion . assert fusion ( to  queue
@ test public void   (  )  {   test helper . check disposed (  observable . never (  )  . last element (  )  . to observable (  )  )  ;   test helper . check disposed (  observable . never (  )  . last element (  )  )  ;   test helper . check disposed (  
@ test public void   (  )  {   test scheduler sch = new  test scheduler (  )  ;   test subscriber <  list <  object >  >  ts =  flowable . never (  )  . buffer ( 1  time unit . milliseconds sch )  . test ( 1l true )  ;  sch . advance time by ( 1  time uni
@ override public  string   (  )  {   string builder rv = new  string builder ( 128 )  ;  rv . append ( " waiting for net db confirm from " )  . append (    peer )  . append ( "  found ?  " )  ;  rv . append (    found )  . append ( " waiting for " )  . a
public static  string   (  )  {   console update manager mgr =  console update manager . get instance (  )  ;  if  ( mgr  =  =  null )  return null ;   string rv = mgr . get update downloaded ( router   signed   su3 )  ;  if  ( rv  !  =  null )  return rv ;  return mgr . get update downloaded ( router   signed )  ;   }  
@ override protected  object   (  string param )  {  throw new  unsupported operation exception ( "engine set parameter unsupported" )  ;   }  
@ test public void   (  )  {  assert that (  group element . p2 ( curve zero one one )  is ( equal to ( p2   zero )  )  )  ;   }  
@ test public void   (  )  {   subject <  string >  obs =  publish subject . create (  )  ;   iterator <  string >  it = next ( obs )  . iterator (  )  ;  fire on next in new thread ( obs "one" )  ;  assert true ( it . has next (  )  )  ;  assert true ( i
@ override public  folder[]   (  )  throws  messaging exception  {   imap connection connection = get connection (  )  ;  try  {  final  hash map <  string  imap folder >  mailboxes = new  hash map <  string  imap folder >  (  )  ;  connection . execute s
public static boolean   ( final  illumina metrics code metrics code )  {  return  ( metrics code . equals ( phasing   base )  || metrics code . equals ( prephasing   base )  )  ;   }  
@ test public void   (  )  {  final  atomic reference <  string >  v = new  atomic reference <  string >  (  )  ;   single . just ( " hello  world ! " )  . subscribe ( new  single observer <  string >  (  )  {  @ override public void on subscribe (   disp
@ override public boolean   (  )  {  return is cancelled . get (  )  ;   }  
private  object   (  element element )  {  return new  public command (  )  ;   }  
public void   (  string s )  {  synchronized  (    messages )   {     messages . add ( s )  ;  while  (    messages . size (  )   >  10 )     messages . remove ( 0 )  ;   }  if  (    log . should log (  log . info )  )     log . info ( s )  ;   }  
public void   (  string value )  {  get state variable node (  )  . set node ( default   value value )  ;   }  
@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  big integer field element )  )  return false ;   big integer field element fe =  (  big integer field element ) obj ;  return bi . equals ( fe . bi )  ;   }  
private  rrd db   (  def def )  throws io exception   rrd exception  {   string path = def . get path (  )   backend = def . get backend (  )  ;  if  ( pool used && backend  =  =  null )   {  return  rrd db pool . get instance (  )  . request rrd db ( path )  ;   }  else if  ( backend  !  =  null )   {  return new  rrd db ( path true  rrd backend factory . get factory ( backend )  )  ;   }  else  {  return new  rrd db ( path true )  ;   }   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  nodeid =  externalizable util . get instance (  )  . read byte array ( in )  ;  handler =  ( jid )  externalizable util . get instance (  )  . read serializ
@ test public void   (  )  {   observable . just ( 1 )  . replay ( 1 1  time unit . milliseconds )  . auto connect (  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 )  ;   }  
public void   (  )  throws  exception  {  final  string content = "abc" ;  do literal test ( new  imap memory literal ( create fixed length input stream ( content )  )  content )  ;   }  
public void   (  )  {  mutex . lock (  )  ;   }  
@ before public void   (  )  throws  exception  {  service ports = mock (  list . class )  ;  i = 1 ;  inet socket address = new  inet socket address ( i )  ;  cluster member = new  cluster member ( inet socket address i )  ;  cluster members = new  linke
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  other =  publish processor . create (  )  ;   flowable <  integer >  m = source . skip until ( other )  ;  m . su
public int   (  )  {  int pc = peers  =  =  null  ?  0 : peers . size (  )  ;  return  math . max ( pc complete  +  incomplete  -  1 )  ;   }  
public void   (  session error event event )  {   log . debug ( " error from yahoo: "  +  event . get message (  )   +  "   code:" +  event . get code (  )  )  ;  get session (  )  . get transport (  )  . send message ( get session (  )  . getjid (  )  get session (  )  . get transport (  )  . getjid (  )   locale utils . get localized string ( "gateway . yahoo . error" "kraken" )   +  " "  +  event . get message (  )   message .  type . error )  ;   }  
private static byte[]   ( byte[] array )  {  for  ( int i = 0 ;  i  <  array . length ;  i +  +  )   {  array[i] =  ( byte )  ( i %  byte . max   value )  ;   }  return array ;   }  
static  comment   ( long id  string content )  {  return new  comment ( id content )  ;   }  
public  boolean   (  )  {  return    lost packet id plus2 ;   }  
void   ( b b )  {  queue . offer ( new  window operation < t b >  ( null b )  )  ;  if  ( enter (  )  )   {  drain loop (  )  ;   }   }  
@ override public void   (  )  {  o . on complete (  )  ;   }  
private boolean   ( int value )  {   spinner adapter sa = m check frequency view . get adapter (  )  ;  for  ( int i = 0 ;  i  <  sa . get count (  )  ;   +  + i )   {   spinner option so =  (  spinner option ) sa . get item ( i )  ;  if  ( so  !  =  null &&  (  (  integer ) so . value )   =  =  value )   {  return true ;   }   }  return false ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . default if empty ( 2 )  . test (  )  . assert result ( 1 )  ;   }  
@ override public void   (  presence type presence type  string verbose status )  {  try  {  if  ( is logged in (  )  )   {  yahoo session . set status (  (  (  yahoo transport ) get transport (  )  )  . convertxmpp status to yahoo ( presence type )  )  ;
long[]   (  )  {  return fetch data . get timestamps (  )  ;   }  
@ override public  flowable < u >    (  )  {  return  rx java plugins . on assembly ( new  flowable to list < t u >  ( source collection supplier )  )  ;   }  
@ override public  set <  auth provider >    (  )  {  final  set <  auth provider >  result = new  linked hash set <  >  (  )  ;  result . add ( admin provider )  ;  result . add ( user provider )  ;  return result ;   }  
public  destination   (  )  {  return    my destination ;   }  
static void   (  string basepath  string basepackage )  throws  exception  {   file[] observables = new  file ( basepath  +  "observable / " )  . list files (  )  ;  int count = 0 ;  for  (   file f : observables )   {  if  (  ! f . get name (  )  . ends with ( " . java" )  )   {  continue ;   }   class <  ?  >  clazz =  class . for name ( basepackage  +  "observable . "  +  f . get name (  )  . replace ( " . java" "" )  )  ;   string cn = f . get name (  )  . replace ( " . java" "" )  . replace ( " observable" " flowable" )  ;   file f2 = new  file ( basepath  +  " / flowable / "  +  cn +  " . java" )  ;  if  (  ! f2 . exists (  )  )   {  continue ;   }   class <  ?  >  clazz2 =  class . for name ( basepackage  +  "flowable . "  +  cn )  ;   set <  string >  methods2 = new  hash set <  string >  (  )  ;  for  (   method m : clazz2 . get methods (  )  )   {  methods2 . add ( m . get name (  )  )  ;   }  for  (   method m : clazz . get methods (  )  )   {  if  (  ! methods2 . contains ( m . get name (  )  )  &&  ! methods2 . contains ( m . get name (  )  . replace ( " observable" " flowable" )  )  )   {  count +  +  ;   system . out . println (  )  ;   system . out . print ( "java . lang .  runtime exception: missing  >  " )  ;   system . out . println ( m . get name (  )  )  ;   system . out . print ( " at " )  ;   system . out . print ( clazz . get name (  )  )  ;   system . out . print ( "  ( " )  ;   system . out . print ( clazz . get simple name (  )  )  ;   system . out . print ( " . java:" )  ;   list <  string >  lines = read all lines ( f )  ;  int j = 1 ;  for  ( int i = 1 ;  i  <  =  lines . size (  )  ;  i +  +  )   {  if  ( lines . get ( i  -  1 )  . contains ( "public void "  +  m . get name (  )   +  " ( " )  )   {  j = i ;   }   }   system . out . print ( j )  ;   system . out . println ( " ) " )  ;   system . out . print ( " at " )  ;   system . out . print ( clazz2 . get name (  )  )  ;   system . out . print ( "  ( " )  ;   system . out . print ( clazz2 . get simple name (  )  )  ;  lines = read all lines ( f2 )  ;   system . out . print ( " . java:" )  ;   system . out . print ( lines . size (  )   -  1 )  ;   system . out . println ( " ) " )  ;   }   }   }   system . out . println (  )  ;   system . out . println ( count )  ;   }  
@ test public void   (  )  throws io exception  {  stream . close stream (  )  ;  verify ( digest )  . digest (  )  ;   }  
@ override public  object   (  integer a  integer b )  throws  exception  {  return a  +  b ;   }  
@ test @ ignore ( "null values are not allowed" )  public void   (  )  {   single <  boolean >  observable =  flowable . just ( "a" "b" null )  . contains ( null )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  
@ test public void   (  )  {  final  disposable s = mock (  disposable . class )  ;   observable <  integer >  o =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integ
public int   ( int tunnel )  {  return    helper . get post total max ( tunnel )  ;   }  
public static boolean   ( int value )  {  return value  =  =  0x9 || value  =  =  0xa || value  =  =  0xd ||  ( value  >  =  0x20 && value  <  =  0xd7ff )  ||  ( value  >  =  0xe000 && value  <  =  0xfffd )  ||  ( value  >  =  0x10000 && value  <  =  0x10ffff )  ;   }  
public  data structure   (  )  {  return new  destination (  )  ;   }  
public static void   (  throwable e  subscriber <  ?  >  s )  {  s . on subscribe ( instance )  ;  s . on error ( e )  ;   }  
private static  string   (  string username  string list name )  {  return username  +  list name ;   }  
@ override protected void   (  observer <  ?  super r >  s )  {  source . subscribe ( new  flat map maybe observer < t r >  ( s mapper delay errors )  )  ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c =  completable . error ( new  callable <  throwable >  (  )  {  @ override public  throwable call (  )  {  throw new  test exception (  )  ;   }   }   )  ;
public   (  node node )  {  super ( node )  ;   }  
public final static  inet address[]   ( int ipfilter  string[] interfaces )  {   enumeration <  network interface >  nis ;  if  ( interfaces  !  =  null )   {   vector <  network interface >  iflist = new  vector <  network interface >  (  )  ;  for  ( int i = 0 ;  i  <  interfaces . length ;  i +  +  )   {   network interface ni ;  try  {  ni =  network interface . get by name ( interfaces[i] )  ;   }  catch  (   socket exception e )   {  continue ;   }  if  ( ni  !  =  null )  iflist . add ( ni )  ;   }  nis = iflist . elements (  )  ;   }  else  {  try  {  nis =  network interface . get network interfaces (  )  ;   }  catch  (   socket exception e )   {  return null ;   }   }   array list <  inet address >  addresses = new  array list <  inet address >  (  )  ;  while  ( nis . has more elements (  )  )   {   network interface ni = nis . next element (  )  ;   enumeration <  inet address >  addrs = ni . get inet addresses (  )  ;  while  ( addrs . has more elements (  )  )   {   inet address addr = addrs . next element (  )  ;  if  (  (  ( ipfilter & local   bitmask )   =  =  0 )  && addr . is loopback address (  )  )  continue ;  if  (  (  ( ipfilter & ipv4   bitmask )   !  =  0 )  && addr instanceof  inet4 address )   {  addresses . add ( addr )  ;   }  else if  (  (  ( ipfilter & ipv6   bitmask )   !  =  0 )  && addr instanceof  inet address )   {  addresses . add ( addr )  ;   }   }   }  return addresses . to array ( new  inet address[] {  }  )  ;   }  
public void   (  string group description field )  {  this . group description field = group description field ;  properties . put ( "ldap . group description field" group description field )  ;   }  
@ test public void   (  )  throws  exception  {   object bean = new  object (  )  {  @ suppress warnings ( "unused" )  public  string get bar (  )  throws  illegal access exception  {  throw new  illegal access exception (  )  ;   }   }   ;  exception . e
private long   (  )  {  long receive id ;  synchronized  (    recently closed )   {   long rcvid ;  do  {  receive id =    context . random (  )  . next long (  packet . max   stream   id  -  1 )   +  1 ;  rcvid =  long . value of ( receive id )  ;   }  while  (    recently closed . contains key ( rcvid )  ||    connection by inbound id . contains key ( rcvid )  )  ;     recently closed . put ( rcvid dummy )  ;   }  return receive id ;   }  
@ override public  iterator <  string >    (  )  {  return  collections . singleton ( "jabber:iq:privacy" )  . iterator (  )  ;   }  
@ override public  bean info[]   (  )  {  return null ;   }  
public void   ( long message id long inner message id long tunnel id  string type )  {  if  (  !    do log )  return ;  add entry ( get prefix (  )   +  "message "  +  message id +  " / " +  inner message id +  " on " +  tunnel id +  " as " +  type )  ;   }  
@ override public int   (  timed runnable o )  {  if  ( time  =  =  o . time )   {  return  object helper . compare ( count o . count )  ;   }  return  object helper . compare ( time o . time )  ;   }  
@ setup public void   (  )  {   integer[] source array = new  integer[count] ;   arrays . fill ( source array 777 )  ;   observable <  integer >  source =  observable . from array ( source array )  ;  observable plain = source . switch map ( new  function
public int   (  )  {  return min drift ;   }  
@ override public void   (  observer <  ?  super u >  a u v )  {  actual . on next ( v )  ;   }  
@ suppress warnings ( "pmd .  constructor calls overridable method" )  @ override public  list <  header name >    (  )  {  return header names ;   }  
@ benchmark public void   (  blackhole bh )  {  obs flat map completable as obs0 . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   behavior subject . create default ( 1 )  . debounce ( new  function <  integer  observable source <  object >  >  (  )  {  @ override public  
private static void   (  string session name  string host int port  string con options )  {     log . info ( "\n\n testing "  +  session name  +  "\n\n\n" )  ;  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;     log . debug ( "line read for valid version: "  +  line )  ;   string req = "session create style = stream destination = "  +  session name  +  " " +  con options +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . info ( " response to creating the session with destination "  +  session name  +  ": " +  line )  ;  req = "stream connect id = 42 destination = "  +     alice  +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . info ( " response to the stream connect from "  +  session name  +  " to  alice: " +  line )  ;   properties props = sam utils . parse params ( line )  ;     log . info ( "props  =  "  +  props )  ;   string result = props . get property ( "result" )  ;  if  (  !  ( "ok" . equals ( result )  )  )   {     log . error ( " unable to connect ! " )  ;  return ;   }  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  req = "stream send id = 42 size = 10\n blah blah !  ! " ;     log . info ( "\n**  sending  blah blah !  ! " )  ;  out . write (  data helper . getascii ( req )  )  ;  out . flush (  )  ;  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  req = "stream send id = 42 size = 10\n foo bar baz ! " ;     log . info ( "\n**  sending  foo bar baz ! " )  ;  out . write (  data helper . getascii ( req )  )  ;  out . flush (  )  ;     log . info ( " sending close" )  ;  req = "stream close id = 42\n" ;  out . write (  data helper . getascii ( req )  )  ;  out . flush (  )  ;  synchronized  (    counter lock )   {     close counter +  +  ;   }  try  {   thread . sleep ( 30 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  s . close (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
@ pre destroy public void   (  )  {  shutdown (  )  ;  configuration service . unsubscribe from ( "system - model . cfg . xml" system model listener )  ;  configuration service . unsubscribe from ( "container . cfg . xml" container configuration listener 
public  string   (  )  {  return major  +  " . "  +  minor ;   }  
@ suppress warnings ( "squid:s1244" )  private static  map <  string  string >    ( double quality factor )  {  final  map <  string  string >  parameters = new  hash map <  >  (  )  ;  if  ( quality factor  !  =  default   quality )   {  parameters . put
@ test public void   (  )  {  final  atomic boolean unsubscribed = new  atomic boolean ( false )  ;   flowable . just ( 1 )  . concat with (  flowable .  <  integer > never (  )  )  . do on cancel ( new  action (  )  {  @ override public void run (  )  { 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  subject <  integer >  s =  publish subject .  <  integer > create (  )  . to serialized (  )  ;   test observer <  integer >  to = s . t
private void   (  )  {  if  (    released after  >  0 )   {   runtime exception e = new  runtime exception ( "double free in  fragmented message" )  ;     log . error ( "fm release fragments (  ) " e )  ;  throw e ;   }     released after = get lifetime (  )  ;  for  ( int i = 0 ;  i  <  =     high fragment num ;  i +  +  )   {   byte array ba =    fragments[i] ;  if  (  ( ba  !  =  null )  &&  ( ba . get data (  )  . length  =  =   trivial preprocessor . preprocessed   size )  )   {     cache . release ( ba )  ;     fragments[i] = null ;   }   }   }  
@ override public void   (  )  {  if  (  ! xmpp server . get instance (  )  . is shutting down (  )  )   {   cluster manager . shutdown (  )  ;   }   }  
public  instant   ( long amount to add  temporal unit unit )  {  return now = now . plus ( amount to add unit )  ;   }  
public  cycle illumina file map   ( final  list <  integer >  tiles final int[] cycles )  {  final  set <  integer >  filtered cycles = remove non existent cycles ( cycles )  ;  return cycle file map . keep ( tiles filtered cycles )  ;   }  
public   ( int error code )  {  super (  )  ;  this . error code = error code ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ override public int   (  object a  object b )  {  return  (  (  comparable ) a )  . compare to ( b )  ;   }  
private int   (  )  {  if  (    full  =  =  2 )  return 1 ;  if  (    full  =  =  3 )  return 2 ;  if  (    full  =  =  1 )  return 3 ;  return 0 ;   }  
@ test public void   (  )  throws  exception  {  final  atomic integer on subscribed = new  atomic integer (  )  ;  final  atomic integer count before = new  atomic integer (  )  ;  final  atomic integer count after = new  atomic integer (  )  ;  final  a
@ test public void   (  )  {   attributes impl exp result = new  attributes impl (  )  ;  exp result . add attribute ( "" "date" "date" "java . lang .  string" "25 - dec - 05" )  ;   attributes impl result = instance . get attributes (  )  ;  assert equal
  (  subscriber <  ?  super r >  actual  function <  ?  super t left  ?  extends  publisher < t left end >  >  left end  function <  ?  super t right  ?  extends  publisher < t right end >  >  right end  bi function <  ?  super t left  ?  super t right  ?  extends r >  result selector )  {  this . actual = actual ;  this . requested = new  atomic long (  )  ;  this . disposables = new  composite disposable (  )  ;  this . queue = new  spsc linked array queue <  object >  ( buffer size (  )  )  ;  this . lefts = new  linked hash map <  integer t left >  (  )  ;  this . rights = new  linked hash map <  integer t right >  (  )  ;  this . error = new  atomic reference <  throwable >  (  )  ;  this . left end = left end ;  this . right end = right end ;  this . result selector = result selector ;  this . active = new  atomic integer ( 2 )  ;   }  
public boolean   (  object value )  {  return map . contains value ( value )  ;   }  
private void   (  )  {   set <  peer state >  not yet = new  hash set <  peer state >  (  )  ;  while  (    alive )   {   peer state peer = null ;  long now = 0 ;  long remaining =  - 1 ;  long wanted = 0 ;  while  (    alive )   {   peer state cur = null ;  try  {  if  ( not yet . is empty (  )  )  cur =    peers toack . take (  )  ;  else cur =    peers toack . poll (  )  ;   }  catch  (   interrupted exception ie )   {   }  if  ( cur  !  =  null )   {  if  ( cur . get they relay to us as (  )   =  =  poison   ps )  return ;  wanted = cur . get wantedack send since (  )  ;  now =    context . clock (  )  . now (  )  ;  long delta = wanted  +  ack frequency ( now  -  cur . get lastack send (  )  cur . getrtt (  )  )   -  now ;  if  ( wanted  <  =  0 )   {  not yet . remove ( cur )  ;   }  else if  (  ( delta  <  =  0 )  ||  ( cur . unsentack threshold reached (  )  )  )   {  peer = cur ;  not yet . remove ( cur )  ;  try  {     peers toack . add all ( not yet )  ;   }  catch  (   no such element exception nsee )   {   }  not yet . clear (  )  ;  break ;   }  else  {  boolean added = not yet . add ( cur )  ;  if  ( added &&    log . should log (  log . debug )  )     log . debug ( " pending ack  ( delta  =  "  +  delta  +  " )  for " +  cur )  ;   }   }  else if  (  ! not yet . is empty (  )  )   {  try  {     peers toack . add all ( not yet )  ;   }  catch  (   runtime exception e )   {   }  if  (    log . should log (  log . debug )  )     log . debug ( "sleeping  pending size  =  "  +  not yet . size (  )  )  ;  not yet . clear (  )  ;  try  {   thread . sleep ( 5  +   ( ack   frequency  /  3 )  )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  if  ( peer  !  =  null )   {  long last send = peer . get lastack send (  )  ;   list < ack bitfield >  ack bitfields = peer . retrieveack bitfields ( false )  ;  if  ( wanted  <  0 )   {  if  (    log . should log (  log . warn )  )     log . warn ( "why are we acking something they dont want ?  remaining = "  +  remaining  +  "  peer = " +  peer +  "  bitfields = " +  ack bitfields )  ;  continue ;   }  if  (  ! ack bitfields . is empty (  )  )   {     context . stat manager (  )  . add rate data ( "udp . sendack count" ack bitfields . size (  )  )  ;  if  ( remaining  >  0 )     context . stat manager (  )  . add rate data ( "udp . sendack remaining" remaining )  ;  if  ( last send  <  0 )  last send = now  -  1 ;     context . stat manager (  )  . add rate data ( "udp . ack frequency" now  -  last send now  -  wanted )  ;  udp packet ack =    builder . buildack ( peer ack bitfields )  ;  ack . mark type ( 1 )  ;  ack . set fragment count (  - 1 )  ;  ack . set message type (  packet builder . type   ack )  ;  if  (    log . should log (  log . info )  )     log . info ( " sending "  +  ack bitfields  +  " to " +  peer )  ;     transport . send ( ack )  ;  if  (  ( wanted  >  0 )  &&  ( wanted  <  =  peer . get wantedack send since (  )  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " rerequesting ack for peer "  +  peer )  ;  ack peer ( peer )  ;   }   }  else  {     context . stat manager (  )  . add rate data ( "udp . abortack" 1 )  ;   }   }   }   }  
public   (  string path )  {     path = path ;   }  
public void   ( final  illumina metric counts counts )  {  this . tile to cluster histogram . add histogram ( counts . tile to cluster histogram )  ;  this . tile to pf cluster histogram . add histogram ( counts . tile to pf cluster histogram )  ;   }  
@ override public  maybe <  ?  extends  integer >    (  integer v )  throws  exception  {  return  maybe . empty (  )  ;   }  
@ test public void   (  )  {  final  array list <  list <  integer >  >  lists = new  array list <  list <  integer >  >  (  )  ;   observable . concat (  observable . just ( 1 2 3 4 5 6 )  . window ( 3 )  . map ( new  function <  observable <  integer > 
@ override public boolean   (  throwable e )  throws  exception  {  return e instanceof  test exception || e instanceof  composite exception ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  ps . on next ( 2 )  ;  ps . on next ( 3 )  ;   }   }  
public  string   ( int tunnel )  {  return    helper . get alt private key file ( tunnel )  ;   }  
  (  completable observer actual )  {  this . actual = actual ;   }  
public final iq handler info   (  )  {  return info ;   }  
public  string   (  )  {  return group member field ;   }  
public  state variable   (  string name )  {  return get state variable ( null name )  ;   }  
private static  collection <  string >    (  string strings )  {   collection <  string >  decoded strings = new  array list <  >  (  )  ;   string tokenizer tokenizer = new  string tokenizer ( strings . trim (  )  " " )  ;  while  ( tokenizer . has more tokens (  )  )   {  decoded strings . add ( tokenizer . next token (  )  )  ;   }  return decoded strings ;   }  
@ override public  string   (  )  {  return null ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . debounce ( 1 null )  ;   }  
public int   (  )  {  return  ( optopt )  ;   }  
public void   (  sink sink )  {  this . sink = sink ;   }  
public void   (  storage storage )  {  if  ( coordinator  !  =  null )  coordinator . set wanted pieces (  )  ;   }  
@ override protected void   (  )  {  launch browser (  )  ;   }  
@ override public void   (  string username  date creation date )  throws  user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {  try  {   flowable . never (  )  . rebatch requests (  - 99 )  ;  fail ( " didn't throw iae" )  ;   }  catch  (   illegal argument exception ex )   {  assert equals ( "buffer size  >  0 required but it was  - 99" ex . get mess
public  iterator < e >    (  )  {  return new as iterator (  )  ;   }  
  ( int capacity hint  runnable on terminate boolean delay error )  {  this . queue = new  spsc linked array queue < t >  (  object helper . verify positive ( capacity hint "capacity hint" )  )  ;  this . on terminate = new  atomic reference <  runnable >  (  object helper . require non null ( on terminate "on terminate" )  )  ;  this . delay error = delay error ;  this . actual = new  atomic reference <  observer <  ?  super t >  >  (  )  ;  this . once = new  atomic boolean (  )  ;  this . wip = new  unicast queue disposable (  )  ;   }  
public  string   (  )  {  return server ;   }  
@ override public  boolean   (  )  {  final  content values cv = new  content values (  )  ;  cv . put (  email content .  account columns . display   name m account . get display name (  )  )  ;  cv . put (  email content .  account columns . sender   na
public static  permission policy   (  )  {  try  {  return  permission policy . value of (  jive globals . get property (  connection settings .  server . permission   settings  permission policy . blacklist . to string (  )  )  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return  permission policy . blacklist ;   }   }  
boolean   ( final char ch )  {  if  ( ch  >  =  128 )  return false ;  return inverse alphabet[ch]  >  =  0 ;   }  
public  date   (  )  {  return    end ;   }  
@ test public void   (  )  {   flowable <  string >  o =  flowable . error ( new  callable <  throwable >  (  )  {  @ override public  throwable call (  )  {  return new  runtime exception (  )  ;   }   }   )  ;  o . count (  )  . to flowable (  )  . subs
@ override public void   ( t t )  {  item = t ;   }  
@ override public int   (  )  {  return f . hash code (  )  ^ d . hash code (  )  ^ i . hash code (  )  ;   }  
@ override @ suppress warnings ( "squid:s00112" )  public void   (  servlet request servlet request  servlet response servlet response  filter chain filter chain )  throws io exception   servlet exception  {   http servlet response wrapper mutable respons
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . last or error (  )  . to flowable (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
synchronized void   ( boolean interest )  {  if  ( interest  !  =  interesting )   {  if  (    log . should log (  log . debug )  )     log . debug ( peer  +  " set interesting ( "  +  interest +  " ) " )  ;  interesting = interest ;  out . send interest ( interest )  ;  if  ( interesting &&  ! choked )  request ( true )  ;   }   }  
public boolean   (  )  {  return false ;   }  
public static  string   ( byte[] b )  {   string builder buf = new  string builder ( 40 )  ;  for  ( int i = 0 ;  i  <  b . length ;  i +  +  )   {  int bi = b[i] & 0xff ;  if  ( bi  <  16 )  buf . append ( '0' )  ;  buf . append (  integer . to hex string ( bi )  )  ;   }  return buf . to string (  )  ;   }  
public  sub type   (  )  {  return sub status ;   }  
public void   (  string exception stack )  {  this . exception stack = exception stack ;   }  
public static  < t > boolean   (  atomic reference <  throwable >  field  throwable exception )  {  for  (  ;   ;   )   {   throwable current = field . get (  )  ;  if  ( current  =  =  terminated )   {  return false ;   }   throwable update ;  if  ( current  =  =  null )   {  update = exception ;   }  else  {  update = new  composite exception ( current exception )  ;   }  if  ( field . compare and set ( current update )  )   {  return true ;   }   }   }  
@ test public void   (  )  throws  interrupted exception  {  try  {   flowable . never (  )  . test (  )  . await done ( 1  time unit . milliseconds )  . assert result ( 1 )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   assertion error ex )   {
  (  join subscription base < t >  parent int prefetch )  {  this . parent = parent ;  this . prefetch = prefetch ;  this . limit = prefetch  -   ( prefetch  >  >  2 )  ;   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper int buffer size boolean delay errors )  {  this . actual = actual ;  this . mapper = mapper ;  this . buffer size = buffer size ;  this . delay errors = delay errors ;  this . error = new  atomic throwable (  )  ;   }  
@ override public  integer   (  )  {  throw new  test exception (  )  ;   }  
@ test ( data provider = " s" )  public void simple test ( final  string vcf final  string bam final  map <  string  object >  field value map )  throws io exception   no such field exception   illegal access exception  {  final  collect independent repli
@ override public  string   (  )  {  return get version string (  )  ;   }  
private static  string   ( final  class <  ?  >  type )  {  return "argument must be one of the following:  iterable  or an array / varargs  ( primitive or complex type )  ;  was "  +  type . get name (  )   +  " instead" ;   }  
public   (  pub sub service service  collection node parent node  string nodeid jid creator )  {  super ( service parent node nodeid creator )  ;   default node configuration default configuration = service . get default node configuration ( true )  ;  this . persist published items = default configuration . is persist published items (  )  ;  this . max published items = default configuration . get max published items (  )  ;  this . max payload size = default configuration . get max payload size (  )  ;  this . send item subscribe = default configuration . is send item subscribe (  )  ;   }  
@ override public x509 certificate[]   (  )  {  return null ;   }  
@ override public void   ( final  paired read sequence val )  {  if  (  !  ( val instanceof  paired read sequence with barcodes )  )   {  throw new  picard exception ( " val was not a  paired read sequence with barcodes" )  ;   }  final  paired read seque
private void   (  )  {   integer id ;   set <  integer >  key set ;   iterator <  integer >  iter ;  synchronized  ( handlers map )   {  key set = handlers map . key set (  )  ;  iter = key set . iterator (  )  ;  while  ( iter . has next (  )  )   {  id = iter . next (  )  ;  handlers map . get ( id )  . stop running (  )  ;  senders map . get ( id )  . shut down gracefully (  )  ;   }  handlers map . clear (  )  ;  senders map . clear (  )  ;   }   }  
@ test ( timeout = 1000 expected =  no such element exception . class )  public void   (  )  {   observable <  long >  source =  observable .  <  long > empty (  )  ;   iterable <  long >  iter = source . blocking latest (  )  ;   iterator <  long >  it =
@ override public void   (  string property  map params )  {  if  ( "plugin . httpfileupload . max file size" . equals ( property )  )   {   slot manager . get instance (  )  . set max file size (  jive globals . get long property ( "plugin . httpfileuplo
@ test ( expected = io exception . class )  public void   (  )  throws io exception  {  stream . available (  )  ;   }  
@ override default  map < k v >    (  )  {  return new  linked hash map <  >  (  )  ;   }  
public int   (  )  {  return this . ssdp port ;   }  
@ override public void   (  throwable e )  {   object helper . require non null ( e "on error called with null .   null values are generally not allowed in 2 . x operators and sources . " )  ;  if  ( once . compare and set ( false true )  )   {  this . er
@ before public void   (  )  {  concat2 strings = new  bi function <  string  string  string >  (  )  {  @ override public  string apply (   string t1   string t2 )  {  return t1  +  " - "  +  t2 ;   }   }   ;  s1 =  publish subject . create (  )  ;  s2 =
private static  string   (  string hello msg )  {  return " <  ? xml version = \"1 . 0\" encoding = \"utf - 8\" ?  > \n"  +  "\n"  +  " < element > \n" +  "  < hello > "  +  hello msg  +  " <  / hello > \n" +  "  < goodbye >  see ya .  <  / goodbye > \n" +  " <  / element > \n" ;   }  
@ test public void   (  )  {   maybe . error (  functions . just callable ( new  test exception (  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . with latest from (  flowable . just ( 2 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  throws
@ override public void   (  )  throws  exception  {  list . add ( "on complete" )  ;   }  
public void   (  inet socket address send address )  {  if  ( member address  =  =  null || member address . equals ( send address )  )   {  return ;   }   logger . println ( " call "  +  cp  +  " member address changed from " +  member address +  " to " +  send address )  ;  member address = send address ;   }  
public synchronized long   (  )  {  return this . barcode to record collection . size (  )  ;   }  
public  string   (  )  {  return home mobile ;   }  
int   (  )  {  return    outboundk bytes per second ;   }  
  (  string .  .  .  values )  {  this . values = values ;   }  
@ override public void   (  )  {   disposable d = get and set (  disposable helper . disposed )  ;  if  ( d  !  =   disposable helper . disposed )   {  this . ds = d ;  scheduler . schedule direct ( this )  ;   }   }  
private void   ( final  http servlet request wrapper request )  {   query parameters params = get query parameters (  )  ;  if  ( params  =  =  null )   {  return ;   }  if  ( params . get parameter (  )   !  =  null )   {   string builder sb = new  string builder (  )  ;  for  (   name value pair param : params . get parameter (  )  )   {  if  ( sb . length (  )   >  0 )   {  sb . append ( "&" )  ;   }  sb . append ( param . get name (  )  )  . append ( " = " )  . append ( param . get value (  )   !  =  null  ?  param . get value (  )  : "" )  ;   }  request . set query string ( sb . to string (  )  )  ;   }   }  
public void   (  session arg0 net . sf . jml . net .  message message )  throws  exception  {   log . debug ( "msn:  session message received for "  +  get session (  )  . get registration (  )  . get username (  )   +  " : " +  message )  ;  if  ( message . to string (  )  . starts with ( "out oth" )  )   {  get session (  )  . set login status (  transport login status . disconnected )  ;  get session (  )  . set failure status (  connection failure reason . locked   out )  ;  get session (  )  . session disconnected no reconnect (  locale utils . get localized string ( "gateway . msn . otherloggedin" "kraken" )  )  ;   }  else if  ( message . to string (  )  . starts with ( "out sdh" )  )   {  get session (  )  . set login status (  transport login status . disconnected )  ;  get session (  )  . set failure status (  connection failure reason . locked   out )  ;  get session (  )  . session disconnected no reconnect (  locale utils . get localized string ( "gateway . msn . disconnect" "kraken" )  )  ;   }   }  
public boolean   (  destination dest  client tunnel settings settings  destination existing client )  {  if  ( dest . get signing public key (  )  . equals ( existing client . get signing public key (  )  )  )  throw new  illegal argument exception ( "signing key must differ" )  ;  if  (  ! dest . get public key (  )  . equals ( existing client . get public key (  )  )  )  throw new  illegal argument exception ( "encryption key mismatch" )  ;   hash h = dest . calculate hash (  )  ;   hash e = existing client . calculate hash (  )  ;  synchronized  ( this )   {   tunnel pool inbound =    client inbound pools . get ( h )  ;   tunnel pool outbound =    client outbound pools . get ( h )  ;  if  ( inbound  !  =  null || outbound  !  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( "already have alias "  +  dest . to base32 (  )  )  ;  return false ;   }   tunnel pool e inbound =    client inbound pools . get ( e )  ;   tunnel pool e outbound =    client outbound pools . get ( e )  ;  if  ( e inbound  =  =  null || e outbound  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( "primary not found "  +  existing client )  ;  return false ;   }  e inbound . get settings (  )  . get aliases (  )  . add ( h )  ;  e outbound . get settings (  )  . get aliases (  )  . add ( h )  ;   tunnel pool settings new in = settings . get inbound settings (  )  ;   tunnel pool settings new out = settings . get outbound settings (  )  ;  new in . set alias of ( e )  ;  new out . set alias of ( e )  ;  inbound = new  aliased tunnel pool (    context this new in e inbound )  ;  outbound = new  aliased tunnel pool (    context this new out e outbound )  ;     client inbound pools . put ( h inbound )  ;     client outbound pools . put ( h outbound )  ;  inbound . startup (  )  ;  outbound . startup (  )  ;   }  if  (    log . should log (  log . warn )  )     log . warn ( " added "  +  dest . to base32 (  )   +  " as alias for " +  existing client . to base32 (  )  +  " with settings " +  settings )  ;  return true ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  observer )  {  observer . on subscribe (  dispo
public void   ( int size )  {  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( "begin size "  +  size )  ;   }   }  
@ override public void   (  presence type presence type  string verbose status )  {  if  (  ! is logged in (  )  )   {   log . debug ( " creating msn session for "  +  registration . get username (  )  )  ;  set pending presence and status ( presence type
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    ( final  publisher <  ?  extends t >  next )  {   object helper . require non null ( next "next i
public final static  node   (  )  {   node env node = new  node ( soap . xmlns  +  soap . delim  +  soap . envelope )  ;  env node . set attribute ( "xmlns"  +  soap . delim  +  soap . xmlns soap . xmlns   url )  ;  env node . set attribute ( soap . xmlns  +  soap . delim  +  "encoding style" soap . encstyle   url )  ;   node body node = new  node ( soap . xmlns  +  soap . delim  +  soap . body )  ;  env node . add node ( body node )  ;  return env node ;   }  
public  string   (  )  {  return plc . get class (  )  . get canonical name (  )  ;   }  
public   ( jaxb context context )  {  json transform = new  stream to xslt transform (  transform helper . get templates from input stream (  limits entity stream transformer . class . get resource as stream ( json   xsl   location )  )  )  ;  combiner = new  combined limits transformer (  transform helper . get templates from input stream (  limits entity stream transformer . class . get resource as stream ( combiner   xsl   location )  )  context limits   object   factory )  ;  entiy transform = new  jaxb to stream transform ( context )  ;   }  
@ override protected void   (  single observer <  ?  super t >  subscriber )  {  other . subscribe ( new  other observer < t u >  ( subscriber source )  )  ;   }  
@ test public void   (  )  {   single <  boolean >  o =  observable . sequence equal (  observable . just ( "one" "two" "three" )   observable . just ( "one" "two" "three" "four" )  )  ;  verify result ( o false )  ;   }  
public static  string   ( long bytes boolean non breaking )  {   string space = non breaking  ?  "&#8239 ; " : " " ;  if  ( bytes  <  1024 )  return bytes  +  space ;  double val = bytes ;  int scale = 0 ;  while  ( val  >  =  1024 )   {  scale +  +  ;  val /  = 1024 ;   }   decimal format fmt = new  decimal format ( "##0 . ##" )  ;  if  ( val  >  =  200 )   {  fmt . set maximum fraction digits ( 0 )  ;   }  else if  ( val  >  =  20 )   {  fmt . set maximum fraction digits ( 1 )  ;   }   string str = fmt . format ( val )   +  space ;  switch  ( scale )   {  case 1: return str  +  " ki" ;  case 2: return str  +  " mi" ;  case 3: return str  +  " gi" ;  case 4: return str  +  " ti" ;  case 5: return str  +  " pi" ;  case 6: return str  +  " ei" ;  case 7: return str  +  " zi" ;  case 8: return str  +  " yi" ;  default : return bytes  +  space ;   }   }  
@ override public  string   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ test ( timeout = 2000 )  public void   (  )  {  int num = 10 ;  final  atomic integer count = new  atomic integer (  )  ;  int value =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (  final 
public   (  transaction handler delegate )  {  super ( delegate )  ;   }  
@ test public void   (  )  {  final  list <  string >  list = new  array list <  string >  (  )  ;  final  list <  list <  string >  >  lists = new  array list <  list <  string >  >  (  )  ;   observable <  string >  source =  observable . unsafe create 
@ override public void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;  s . dispose (  )  ;   }   }  
public static void   (  string args[] )  {   router context ctx = new  router context ( null )  ;   profile organizer organizer = new  profile organizer ( ctx )  ;  organizer . set us (  hash . fake   hash )  ;   profile persistence helper helper = new  profile persistence helper ( ctx )  ;  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )   {   peer profile profile = helper . read profile ( new java . io .  file ( args[i] )  )  ;  if  ( profile  =  =  null )   {   system . err . println ( " could not load profile "  +  args[i] )  ;  continue ;   }  organizer . add profile ( profile )  ;   }  organizer . reorganize (  )  ;   decimal format fmt = new  decimal format ( "0 000 . 0" )  ;  fmt . set positive prefix ( " + " )  ;  for  (   hash peer : organizer . select all peers (  )  )   {   peer profile profile = organizer . get profile ( peer )  ;  if  (  ! profile . get is active (  )  )   {   system . out . println ( " peer "  +  profile . get peer (  )  . to base64 (  )  . substring ( 0 4 )   +  " [" +   ( organizer . is fast ( peer )   ?  "if + r" : organizer . is high capacity ( peer )   ?  "ir " : organizer . is failing ( peer )   ?  "ix " : "i " )  +  "]: " +  "\t  speed:\t" +  fmt . format ( profile . get speed value (  )  )  +  "  capacity:\t" +  fmt . format ( profile . get capacity value (  )  )  +  "  integration:\t" +  fmt . format ( profile . get integration value (  )  )  +  "  active ? \t" +  profile . get is active (  )  +  "  failing ? \t" +  profile . get is failing (  )  )  ;   }  else  {   system . out . println ( " peer "  +  profile . get peer (  )  . to base64 (  )  . substring ( 0 4 )   +  " [" +   ( organizer . is fast ( peer )   ?  "f + r " : organizer . is high capacity ( peer )   ?  "r " : organizer . is failing ( peer )   ?  "x " : " " )  +  "]: " +  "\t  speed:\t" +  fmt . format ( profile . get speed value (  )  )  +  "  capacity:\t" +  fmt . format ( profile . get capacity value (  )  )  +  "  integration:\t" +  fmt . format ( profile . get integration value (  )  )  +  "  active ? \t" +  profile . get is active (  )  +  "  failing ? \t" +  profile . get is failing (  )  )  ;   }   }   system . out . println ( " thresholds:" )  ;   system . out . println ( " speed: "  +  num ( organizer . get speed threshold (  )  )   +  "  ( " +  organizer . count fast peers (  )  +  " fast peers ) " )  ;   system . out . println ( " capacity: "  +  num ( organizer . get capacity threshold (  )  )   +  "  ( " +  organizer . count high capacity peers (  )  +  " reliable peers ) " )  ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   replay processor <  string >  src =  replay processor . create (  )  ;  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  final  subscriber <  object >  o =  test helper . mock subscriber (  )  ;   in order 
@ test public void   (  )  throws  transformer exception  {   string href = "otherdata" ;   string base = "base" ;  uri resolver additional = mock ( uri resolver . class )  ;   source source = mock (  source . class )  ;  when ( additional . resolve ( any
@ test public void   (  )  throws  exception  {  run standard test ( 1 "multiplexed barcode2 . " "barcode . params" 1 "25t8b4m4m17t" basecalls   dir test   data   dir   with   4m4m   index )  ;   }  
private int   (  )  {  return 0 ;   }  
public boolean   (  object key )  {  boolean result = true ;  try  {  map . unlock ( key )  ;   }  catch  (   illegal monitor state exception e )   {  logger . error ( " falied to release cluster lock" e )  ;  result = false ;   }  return result ;   }  
@ override protected void   (  maybe observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  obs . set ( observer )  ;   }  
@ override public void   (  )  {  log . debug ( "[task]  modify subscription :  {  } " to string (  )  )  ;   pub sub persistence manager . load subscription ( get service (  )  get node (  )  get subscription id (  )  )  ;   }  
@ override public void   (  filter config filter config )  throws  servlet exception  {  log . trace ( "api  validator filter initializing .  .  . " )  ;  config file name = new  filter config helper ( filter config )  . get filter config ( default   conf
public  string   (  )  {  return stanza ;   }  
@ override public void   (  disposable s )  {  parent . set other ( s )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public  rule   ( int id )  {  return db rule manager . get rule by id ( id )  ;   }  
@ override public  server socket channel   (  )  {  return null ;   }  
@ override public  dialog   (  bundle saved instance state )  {  final  uri uri = get arguments (  )  . get parcelable ( quick   response   content   uri )  ;  final boolean create = get arguments (  )  . get boolean ( quick   response   create )  ;   str
@ test public void   (  )  {  final  test scheduler scheduler = new  test scheduler (  )  ;   rx java plugins . set computation scheduler handler ( new  function <  scheduler  scheduler >  (  )  {  @ override public  scheduler apply (   scheduler v )  thr
protected static  credential   ( final json object json )  {  try  {  final  credential c = new  credential (  )  ;  c . m provider id = json . get string ( provider   column )  ;  c . m access token = json . opt string ( access   token   column )  ;  c . m refresh token = json . opt string ( refresh   token   column )  ;  c . m expiration = json . opt int ( expiration   column 0 )  ;  return c ;   }  catch  (  final json exception e )   {   log utils . d (  log utils . tag e " exception while deserializing  credential" )  ;   }  return null ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  completable   (  completable source .  .  .  sources )  {   object helper . require non null ( sources "sources is null" )  ;  if  ( sources . length  =  =  0 )   {  re
public  server transaction   ( int status  request request  server transaction server transaction )  {  try  {   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response:  starting response sending process . " )  ;  if  ( server transaction  =  =  null )  server transaction = udp sip provider . get new server transaction ( request )  ;   response response = message factory . create response ( status request )  ;  if  ( request . get header (  expires header . name )   !  =  null )  response . set header ( request . get header (  expires header . name )  )  ;   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response:  preparing \" contact\" header .  .  . " )  ;  try  {   sipuri contacturi = address factory . create sipuri ( null  inet address . get local host (  )  . get host address (  )  )  ;  contacturi . set port ( sip port )  ;   address contact address = address factory . create address ( contacturi )  ;   contact header contact header = header factory . create contact header ( contact address )  ;  response . add header ( contact header )  ;   }  catch  (   exception e )   {   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response:  exception occured when adding  contact header . " e )  ;   }   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response:  sending response: " +  response . to string (  )  )  ;  server transaction . send response ( response )  ;   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response:  response sent ! " )  ;  return server transaction ;   }  catch  (   exception ex )   {   log . debug ( " simple session ( "  +  jid . get node (  )   +  " )  . send response: " ex )  ;   }  return null ;   }  
public   (  )  {  super ( " rayo: xep 0327  -   resume  record" )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;  final  atomic boolean added = new  atomic boolean (  )  ;   bi consumer <  object  integer >  throw on first only = new  bi consumer <  object  integer >  (  )  {  
public static synchronized void   (  )  {  try  {  if  ( bw  !  =  null )   {  bw . flush (  )  ;  bw . close (  )  ;   }   }  catch  (  io exception e )   {   }  bw = null ;  try  {  if  ( fw  !  =  null )   {  fw . flush (  )  ;  fw . close (  )  ;   }   }  catch  (  io exception e )   {   }  fw = null ;   }  
public boolean   (  )  {  if  (    context . get boolean property ( prop   hidden )  )  return true ;   string h =    context . get property ( prop   hidden   hidden )  ;  if  ( h  !  =  null )  return  boolean . parse boolean ( h )  ;  return    context . comm system (  )  . is in bad country (  )  ;   }  
@ override public  string   (  )  {   string rv = "bs level height: "  +  levels . length  +  " page: " +  level page +  " span: " +  bottom +  " in skiplist " +  bsl ;  if  ( is killed )  rv +  = " killed" ;  return rv ;   }  
public   (  )  {  try  {  set time span (  util . get timestamps ( default   start default   end )  )  ;   }  catch  (   rrd exception e )   {  throw new  runtime exception ( e )  ;   }   string fontdir property =  system . get property ( "jrobin . fontdir" )  ;  if  ( fontdir property  !  =  null && fontdir property . length (  )   !  =  0 )   {  font dir = new  file ( fontdir property )  ;   }  fonts[fonttag   default] = new  font ( default   font   name  font . plain 8 )  ;  fonts[fonttag   title] = new  font ( default   font   name  font . plain 9 )  ;  fonts[fonttag   axis] = new  font ( default   font   name  font . plain 7 )  ;  fonts[fonttag   unit] = new  font ( default   font   name  font . plain 8 )  ;  fonts[fonttag   legend] = new  font ( default   font   name  font . plain 8 )  ;  fonts[fonttag   watermark] = new  font ( default   font   name  font . plain 1 )  . derive font ( 5 . 5f )  ;   }  
public void   (  )  {  boolean result = false ;  try  {  blocking load from disk (  )  ;  if  (  ! mails . is empty (  )  )  result = true ;  if  (    log . should debug (  )  )     log . debug ( " folder loaded: "  +  folder name )  ;   }  finally  {  synchronized  (  mail cache . this )   {  if  (    load in progress  =  =     nml )     load in progress = null ;     is loaded = true ;   }     nml . found new mail ( result )  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1  flowable . buffer size (  )  * 2 )  . delay (  flowable . defer ( new  callable <  flowable <  long >  >  (  )  {  @ overr
@ test public void   (  )  {   observable <  integer >  on next =  observable . from iterable (  arrays . as list ( 1 2 3 )  )  ;   observable <  integer >  on complete =  observable . from iterable (  arrays . as list ( 4 )  )  ;   observable <  integer 
@ test public void   (  )  {   test resource maybe observer <  integer >  rmo = new  test resource maybe observer <  integer >  (  )  ;  assert false ( rmo . is disposed (  )  )  ;  assert equals ( 0 rmo . start )  ;  assert null ( rmo . value )  ;  asser
@ test public void   (  )  {   test observer <  void >  to =  observable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  { 
public long   (  )  {  if  ( cis  !  =  null )  return cis . get read (  )   -   ( size  -  pos )  ;  return 0 ;   }  
public long   (  )  {  return data store . get accumulated response size (  )  ;   }  
public void   (  hash peer )  {  if  (  !    do log )  return ;  if  ( peer  =  =  null )  return ;  add entry ( " unbanlist "  +  peer . to base64 (  )  )  ;   }  
@ override public void   (  )  {  super . cancel (  )  ;  s . cancel (  )  ;   }  
public   ( final vcf file reader reader final  interval list intervals )  {  this . reader = reader ;  this . intervals = intervals . uniqued (  )  . iterator (  )  ;  this . advance (  )  ;   }  
public void   ( iq packet  workgroup workgroup  string sessionid )  {  iq reply = iq . create resultiq ( packet )  ;   string notes = get notes ( sessionid )  ;  if  ( notes  =  =  null )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  workgroup . send ( reply )  ;  return ;   }   element note = reply . set child element ( "chat - notes" "http: /  / jivesoftware . com / protocol / workgroup" )  ;  note . add element ( "sessionid" )  . set text ( sessionid )  ;  note . add element ( "text" )  . set text ( notes )  ;  workgroup . send ( reply )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  parent . inner error ( t )  ;   }  
private void   (  router info ri )  {   foo message data = new  foo message (    us new byte[] { 0x0 0x1 0x2 0x3 }  )  ;   out net message out = new  out net message (    us data    us . clock (  )  . now (  )   +  10 * 1000 100 ri )  ;   system . out . println ( "send: "  +   base64 . encode ( data . get data (  )  )   +  " to " +  ri . get identity (  )  . calculate hash (  )  )  ;  out . set on failed send job ( null )  ;  out . set on send job ( new  afterack (  )  )  ;     us . out net message pool (  )  . add ( out )  ;   }  
public   (  )  {  try  {  store watcher =  file systems . get default (  )  . new watch service (  )  ;  executor service . submit ( new  runnable (  )  {  @ override public void run (  )  {  while  (  ! executor service . is shutdown (  )  )   {  final  watch key key ;  try  {  key = store watcher . poll ( 5  time unit . seconds )  ;   }  catch  (   interrupted exception e )   {  continue ;   }  if  ( key  =  =  null )   {  continue ;   }  for  (  final  watch event <  ?  >  event : key . poll events (  )  )   {  final  watch event .  kind <  ?  >  kind = event . kind (  )  ;  if  ( kind  =  =   standard watch event kinds . overflow )   {  continue ;   }  synchronized  ( watched stores )   {  final  watch event <  path >  ev =  (  watch event <  path >  ) event ;  final  path changed file =  (  (  path ) key . watchable (  )  )  . resolve ( ev . context (  )  )  ;  for  (  final  certificate store store : watched stores . key set (  )  )   {  final  path store file = store . get configuration (  )  . get file (  )  . to path (  )  . normalize (  )  ;  if  ( store file . equals ( changed file )  )   {  try  ( final  file input stream is = new  file input stream ( changed file . to file (  )  )  )  {  final  key store tmp store =  key store . get instance ( store . get configuration (  )  . get type (  )  )  ;  tmp store . load ( is store . get configuration (  )  . get password (  )  )  ;   }  catch  (  eof exception e )   {   log . debug ( " the keystore is still being modified .   ignore for now .  a new event should be thrown later . " e )  ;  break ;   }  catch  (   exception e )   {   log . debug ( " can't read the modified keystore with this config .   continue iterating over configs . " e )  ;  continue ;   }   log . info ( "a file system change was detected .  a ( nother )  certificate store that is backed by file ' {  } ' will be reloaded . " store file )  ;  try  {  store . reload (  )  ;   }  catch  (   certificate store config exception e )   {   log . warn ( " an unexpected exception occurred while trying to reload a certificate store that is backed by file ' {  } ' ! " store file e )  ;   }   }   }   }   }  key . reset (  )  ;   }   }   }   )  ;   }  catch  (   unsupported operation exception e )   {  store watcher = null ;   log . info ( " this file system does not support watching file system objects for changes and events .   changes to  openfire certificate stores made outside of  openfire might not be detected .  a restart of  openfire might be required for these to be applied . " )  ;   }  catch  (  io exception e )   {  store watcher = null ;   log . warn ( " an exception occured while trying to create a service that monitors the  openfire certificate stores for changes .   changes to  openfire certificate stores made outside of  openfire might not be detected .  a restart of  openfire might be required for these to be applied . " e )  ;   }   }  
@ override public int   (  )  throws io exception  {  return  ( int )  math . min ( maxx  -  count super . available (  )  )  ;   }  
@ test public void   (  )  {   observable . sequence equal (  observable . range ( 1 20 )   observable . range ( 1 20 )  2 )  . to observable (  )  . test (  )  . assert result ( true )  ;   }  
@ override public void   ( final t value )  {  this . value = value ;  dispose (  )  ;   }  
public int   (  )  {  return    fragment number ;   }  
public  destination   (  hash h )  {  synchronized  ( bad dests )   {  return bad dests . get ( h )  ;   }   }  
@ override public boolean   (  object obj )  {  if  ( obj instanceof  hash cash )  return to string (  )  . equals ( obj . to string (  )  )  ;  else return super . equals ( obj )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public  collection   (  )  {  if  ( breadcrumbs  =  =  null )   {  breadcrumbs = new  array list (  )  ;   }  return breadcrumbs ;   }  
@ test public void   (  )  {   function <  integer  integer >  error = new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer t1 )  {  throw new  test exception (  )  ;   }   }   ;   flowable <  integer >  result =  flo
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ override public void on next (   integer t )  {  if  ( t  =  =  1 )   
public  optional <  sql array type <  ?  >  >    (  type element type )  {  return factories . stream (  )  . flat map ( factory  -  >  to stream ( factory . build ( element type registry )  )  )  . find first (  )  ;   }  
public   (  conference member member with mix  conference member member double[] spatial values )  {  this . member with mix = member with mix ;  this . member = member ;  this . spatial values = spatial values ;   }  
@ test public void   (  )  {  test helper ( "genomic   sorted . sam" "chr21 . sam" 0 0 0 0 0 0 0 false )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;  pp . ignore elements (  )  . test ( true )  ;  assert false ( pp . has subscribers (  )  )  ;   }  
public   b (  )  {  n . c ( com . jcumulus . server . rtmfp . n . g )  ;  return n ;   }  
@ test public void   (  )  {  assert that (  array utilities . null safe copy (  (  object[] ) null )  equal to ( null )  )  ;   }  
public   (  )  {  m base uri = content   uri ;   }  
@ override public boolean   (  object o )  {  return  ( o instanceof v6 entry )  && compare to (  ( v6 entry ) o )   =  =  0 ;   }  
@ override public byte[]   ( byte[] outgoing int offset int len )  throws  sasl exception  {  if  (  ! is complete (  )  )   {  throw new  illegal state exception ( " authentication exchange not completed . " )  ;   }  throw new  illegal state exception (
@ override public void   (  dialog interface dialog int which boolean is checked )  {  final  folder row row =  (  folder row ) m adapter . get item ( which )  ;  m checked state . clear (  )  ;  is checked = true ;  m checked state . put ( row . get fold
@ override public void   (  subscription d )  {  if  (  subscription helper . validate ( upstream d )  )   {  upstream = d ;  downstream . on subscribe ( this )  ;  queue . offer ( next   window )  ;  drain (  )  ;  d . request (  long . max   value )  ; 
@ test public void   (  )  {  final  flowable processor <  integer >  ps =  publish processor .  <  integer > create (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  {  @ override public void on next (   integer t )  {
@ test public void   (  )  {   test helper . check disposed (  maybe . sequence equal (  maybe . just ( 1 )   maybe . just ( 1 )  )  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  observer )  {  observer . on subscribe (  dispo
  (  single observer <  ?  super r >  actual  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper )  {  this . actual = actual ;  this . mapper = mapper ;   }  
@ test public void   (  )  {   behavior subject <  string >  subject =  behavior subject . create default ( "default" )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "o
private long   ( boolean should stat )  {  long rv =  - 1 ;  long default amount = get send delay (  )  ;  if  (    pending since  >  0 )  rv =    pending since  +  default amount  -     context . clock (  )  . now (  )  ;  if  ( rv  >  default amount )  rv = default amount ;  if  ( should stat )     context . stat manager (  )  . add rate data ( "tunnel . batch delay amount" rv )  ;  return rv ;   }  
public   ( final  string run barcode )  {  this . run barcode = run barcode ;   }  
  ( final  variant processor .  accumulator processor )  {  this . processor = processor ;   }  
public  string   (  )  {  return service name  +  " . "  +  xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  completable subject cs =  completable subject . create (  )  ;   test observer <  integer >  to = ps . merge with ( cs )  . test (  )  ;  ass
@ test public void   (  )  {   behavior processor . create default ( 1 )  . window (  functions . just callable (  flowable . error ( new  test exception (  )  )  )  )  . test (  )  . assert value count ( 1 )  . assert not complete (  )  . assert error ( 
public boolean   (  )  {  return is pentium3 compatible ;   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  detach maybe observer < t >  ( observer )  )  ;   }  
static void   (  param ignore ignore )  {   string key = ignore . to string (  )  ;   list <  param ignore >  list = ignores . get ( key )  ;  if  ( list  =  =  null )   {  list = new  array list <  param ignore >  (  )  ;  ignores . put ( key list )  ;   }  list . add ( ignore )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . request ( 3 )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable .  <  integer > unsafe create ( new  publisher <  int
public  list <  hash >    ( int how many boolean prefer connected )  {   list <  hash >  rv = new  array list <  hash >  ( how many )  ;   list <  hash >  badff = new  array list <  hash >  ( how many )  ;   list <  hash >  unconnectedff = new  array list <  hash >  ( how many )  ;  int found = 0 ;  long now =    context . clock (  )  . now (  )  ;  for  (  iterator <  hash >  iter = new  random iterator <  hash >  (    floodfill matches )  ;   ( found  <  how many )  && iter . has next (  )  ;   )   {   hash entry = iter . next (  )  ;   router info info =    context . net db (  )  . lookup router info locally ( entry )  ;  if  ( info  !  =  null && now  -  info . get published (  )   >  3 * 60 * 60* 1000 )   {  badff . add ( entry )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " skipping  published a while ago: "  +  entry )  ;   }  else  {   peer profile prof =    context . profile organizer (  )  . get profile ( entry )  ;  if  ( prof  !  =  null && now  -  prof . get last send failed (  )   <  30 * 60 * 1000 )   {  badff . add ( entry )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " skipping  recent failed send: "  +  entry )  ;   }  else if  ( prefer connected &&  !    context . comm system (  )  . is established ( entry )  )   {  unconnectedff . add ( entry )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " skipping  unconnected: "  +  entry )  ;   }  else  {  rv . add ( entry )  ;  found +  +  ;   }   }   }  for  ( int i = 0 ;  found  <  how many && i  <  unconnectedff . size (  )  ;  i +  +  )   {  rv . add ( unconnectedff . get ( i )  )  ;  found +  +  ;   }  for  ( int i = 0 ;  found  <  how many && i  <  badff . size (  )  ;  i +  +  )   {  rv . add ( badff . get ( i )  )  ;  found +  +  ;   }  for  ( int i = rv . size (  )  ;  i  <  how many ;  i +  +  )   {  if  (    sorted . is empty (  )  )  break ;   hash entry =    sorted . first (  )  ;  rv . add ( entry )  ;     sorted . remove ( entry )  ;   }  return rv ;   }  
@ override public void   (  )  {  rooms = new  array list <  >  (  )  ;  for  (   multi user chat service muc service : xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat services (  )  )   {  for  (  muc room room 
public void   (  )  {   wrapper manager . remove wrapper event listener (    listener )  ;   }  
public void   ( i2p session arg0 )  {     running = false ;  thread . interrupt (  )  ;   }  
@ test public void   (  )  throws io exception  {  byte[] value =  { 1 2 3 4 5 }  ;  int i = 3 ;  int i1 = 7 ;  splitter . write ( value i i1 )  ;  verify ( stream1 )  . write ( eq ( value )  eq ( i )  eq ( i1 )  )  ;  verify ( stream2 )  . write ( eq ( v
private void   ( final sam record read final  integer mate number final  fastq writer writer final int bases to trim final  integer max bases to write )  {  final  string seq header = mate number  =  =  null  ?  read . get read name (  )  : read . get read name (  )   +  " / "  +  mate number ;   string read string = read . get read string (  )  ;   string base qualities = read . get base quality string (  )  ;  if  ( clipping   attribute  !  =  null )   {   integer clip point =  (  integer ) read . get attribute ( clipping   attribute )  ;  if  ( clip point  !  =  null && clip point  <  clipping   min   length )   {  clip point =  math . min ( read string . length (  )  clipping   min   length )  ;   }  if  ( clip point  !  =  null )   {  if  ( clipping   action . equals ignore case ( clip   trim )  )   {  read string = clip ( read string clip point null  ! read . get read negative strand flag (  )  )  ;  base qualities = clip ( base qualities clip point null  ! read . get read negative strand flag (  )  )  ;   }  else if  ( clipping   action . equals ignore case ( clip   to   n )  )   {  read string = clip ( read string clip point clip   to   n . char at ( 0 )   ! read . get read negative strand flag (  )  )  ;   }  else  {  final char new qual = sam utils . phred to fastq ( new byte[] {  ( byte )  integer . parse int ( clipping   action )  }  )  . char at ( 0 )  ;  base qualities = clip ( base qualities clip point new qual  ! read . get read negative strand flag (  )  )  ;   }   }   }  if  ( re   reverse && read . get read negative strand flag (  )  )   {  read string =  sequence util . reverse complement ( read string )  ;  base qualities =  string util . reverse string ( base qualities )  ;   }  if  ( bases to trim  >  0 )   {  read string = read string . substring ( bases to trim )  ;  base qualities = base qualities . substring ( bases to trim )  ;   }  if  ( quality  !  =  null )   {  final byte[] quals = sam utils . fastq to phred ( base qualities )  ;  final int quality trim index =  math . max ( 1  trimming util . find quality trim point ( quals quality )  )  ;  if  ( quality trim index  <  quals . length )   {  read string = read string . substring ( 0 quality trim index )  ;  base qualities = base qualities . substring ( 0 quality trim index )  ;   }   }  if  ( max bases to write  !  =  null && max bases to write  <  read string . length (  )  )   {  read string = read string . substring ( 0 max bases to write )  ;  base qualities = base qualities . substring ( 0 max bases to write )  ;   }  writer . write ( new  fastq record ( seq header read string "" base qualities )  )  ;   }  
public  type   (  )  {  return type ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   single . zip (  arrays . as list ( null  single . just ( 1 )  )  new  function <  object[]  object >  (  )  {  @ override public  object ap
@ override public void   (  mock transport mock transport )  throws  exception  {  mock transport . expectio exception (  )  ;  final  folder folder = m store . get folder ( "test" )  ;  folder . open (  open mode . read   write )  ;   }  
public  linked list node < e >    ( e object )  {  return new  linked list node <  >  ( object head . next head )  ;   }  
public static  list <  string >    (  )  throws  no such algorithm exception   key management exception  {  final ssl context context = ssl context . get instance ( "tl sv1" )  ;  context . init ( null null null )  ;  return  arrays . as list ( context . createssl engine (  )  . get supported protocols (  )  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  intege
@ override public void   (  )  {  if  ( in completable )   {  actual . on complete (  )  ;   }  else  {  in completable = true ;  upstream =  subscription helper . cancelled ;   completable source cs = other ;  other = null ;  cs . subscribe ( this )  ;  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  completable source other )  {   object helper . require non null ( other "other is null" )  ;  return concat array ( this other )  ;   }  
@ test public void   (  )  {   flowable <  integer >  oi =  flowable . from iterable (  arrays . as list ( 1 2 )  )  ;   test subscriber <  integer >  o = new  test subscriber <  integer >  (  )  ;  oi . subscribe ( o )  ;  o . assert values ( 1 2 )  ;  o
@post @ path ( " /  { jid } " )  public  response   ( @ default value ( "conference" )  @ query param ( "servicename" )   string service name @ path param ( "jid" )   string jid @ path param ( "room name" )   string room name )  throws muc service excepti
public int   ( byte target[] int offset )  {  int cur = offset ;   system . arraycopy (    public key . get data (  )  0 target cur  public key . keysize   bytes )  ;  cur +  =  public key . keysize   bytes ;  if  (    padding  !  =  null )   {   system . arraycopy (    padding 0 target cur    padding . length )  ;  cur +  =    padding . length ;   }  int spk trunc =  math . min (  signing public key . keysize   bytes    signing key . length (  )  )  ;   system . arraycopy (    signing key . get data (  )  0 target cur spk trunc )  ;  cur +  = spk trunc ;  cur +  =    certificate . write bytes ( target cur )  ;  return cur  -  offset ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timestamp (  time unit . seconds null )  ;   }  
@ override public boolean   ( jid creator )  {  if  ( is node creation restricted (  )  &&  ! is service admin ( creator )  )   {  return false ;   }  return true ;   }  
@ small test public void   (  )  {   account account =  provider test utils . setup account ( "testaccount" true m mock context )  ;  long account id = account . m id ;   policy initial = setup policy ( 10  policy . password   mode   simple 0 0 false 0 0 
private static int   ( long index int mask )  {  return calc direct offset (  ( int ) index & mask )  ;   }  
public boolean   (  )  {  return private call ;   }  
public static  byte[]   (  float value )  {   byte bytes[] = get float bytes ( value )  ;  if  ( is little endian (  )  . boolean value (  )  )  reverse ( bytes )  ;  return bytes ;   }  
public  date   (  )  {  return    date ;   }  
public boolean   (  )  {  return true ;   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  drain loop (  )  ;   }   }  
@ test public void   (  )  {  final  list <  integer >  list = new  array list <  integer >  (  )  ;   flowable .  <  integer > error ( new  test exception (  )  )  . subscribe ( new  consumer <  integer >  (  )  {  @ override public void accept (   integ
@ test public void   (  )  {   single . zip (  single . just ( 1 )   single . just ( 2 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  throws  exception  {  return null ;   }   }   )
@ override public boolean   (  inet address address )  throws  socket exception  {  return get interface for ( address )   !  =  null ;   }  
@ override public void   (  throwable e )  {  to . on error ( e )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request ( prefetch  -  1 )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publisher <  integer > [] sources = new  publisher[] {  flowable . just ( 1 )  null  flowable . range ( 2 3 )   flowable . error ( new  test exception (  )  )   flowable . empty (  )  }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;   observable queue drain <  integer  integer >  qd = new  observable queue drain <  integer  inte
@ override public  string   (  )  {  return name ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts1 = new  test subscriber <  integer >  (  )  ;   test subscriber <  integer >  ts2 = new  test subscriber <  integer >  ( ts1 )  ;  ts2 . on complete (  )  ;  ts1 . assert complete (  )  ;   }
public void   (  string cmd )  throws  interrupted exception  io exception  {  long timeout = ping   timeout ;  int count = ping   count ;  boolean count ping = false ;  boolean report times = true ;   string host list file = null ;  int local port = 0 ;  int remote port = 0 ;  boolean error = false ;   string[] argv =  data helper . split ( cmd " " )  ;   getopt g = new  getopt ( "ping" argv "t:m:n:chl:f:p:" )  ;  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 't': timeout =  long . parse long ( g . get optarg (  )  )  ;  if  ( timeout  <  100 )  timeout* = 1000 ;  break ;  case 'm': max   simul   pings =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'n': count =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'c': count ping = true ;  count = cping   count ;  break ;  case 'h': if  ( host list file  !  =  null )  error = true ;  else host list file = "hosts . txt" ;  break ;  case 'l': if  ( host list file  !  =  null )  error = true ;  else host list file = g . get optarg (  )  ;  break ;  case 'f': local port =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case 'p': remote port =  integer . parse int ( g . get optarg (  )  )  ;  break ;  case ' ? ': case ':': default : error = true ;   }   }  int remaining = argv . length  -  g . get optind (  )  ;  if  ( error || remaining  >  1 ||  ( remaining  <  =  0 && host list file  =  =  null )  ||  ( remaining  >  0 && host list file  !  =  null )  )   {   system . out . println ( usage (  )  )  ;  return ;   }  if  ( host list file  !  =  null )   {   buffered reader br = null ;  try  {  br = new  buffered reader ( new  input stream reader ( new  file input stream ( host list file )  "utf - 8" )  )  ;   string line ;   list <  ping handler >  ping handlers = new  array list <  ping handler >  (  )  ;  int i = 0 ;  while  (  ( line = br . read line (  )  )   !  =  null )   {  if  ( line . starts with ( "#" )  )  continue ;  if  ( line . starts with ( " ; " )  )  continue ;  if  ( line . starts with ( " ! " )  )  continue ;  if  ( line . index of ( ' = ' )   !  =   - 1 )   {  line = line . substring ( 0 line . index of ( ' = ' )  )  ;   }   ping handler ph = new  ping handler ( line count local port remote port timeout count ping report times )  ;  ph . start (  )  ;  ping handlers . add ( ph )  ;  if  (  +  + i  >  1 )  report times = false ;   }  br . close (  )  ;  for  (  thread t : ping handlers )  t . join (  )  ;  return ;   }  finally  {  if  ( br  !  =  null )  try  {  br . close (  )  ;   }  catch  ( io exception ioe )   {   }   }   }   string host = argv[g . get optind (  ) ] ;   thread t = new  ping handler ( host count local port remote port timeout count ping report times )  ;  t . start (  )  ;  t . join (  )  ;   }  
public  string   (  )  {   string buffer str = new  string buffer (  )  ;  str . append ( get status line string (  )  )  ;  str . append ( get header string (  )  )  ;  return str . to string (  )  ;   }  
public jid   (  )  {  return fromjid ;   }  
@ override public boolean   (  )  {  return false ;   }  
public   (  cancellable cancellable )  {  super ( cancellable )  ;   }  
@ override public byte[]   ( byte[] outgoing int offset int len )  throws  sasl exception  {  if  ( is complete (  )  )   {  throw new  illegal state exception ( "scram - sha - 1 does not support integrity or privacy" )  ;   }  else  {  throw new  illegal
@ test public void   (  )  {   publish subject <  string >  ps1 =  publish subject . create (  )  ;   publish subject <  string >  ps2 =  publish subject . create (  )  ;   publish subject <  string >  ps3 =  publish subject . create (  )  ;   publish sub
@ override public boolean   (  string name  string node jid senderjid )  {  return true ;   }  
@ override public void   (  )  {  to . cancel (  )  ;   }  
public void   ( int tunnel depth )  {     tunnel depth out = tunnel depth ;   }  
public  string   (  string realm  string user )  {   string pfx = realm ;  if  ( user  !  =  null && user . length (  )   >  0 )  pfx +  = ' . '  +  user ;  return    context . get property ( pfx  +  prop   pw )  ;   }  
public long[]   (  )  {  long rv[] = new long[   frequencies . length] ;  for  ( int i = 0 ;  i  <     frequencies . length ;  i +  +  )  rv[i] =    frequencies[i] . get period (  )  ;  return rv ;   }  
@ test public void   (  )  {  final byte[] expected bytes = new byte[16] ;  for  ( int i = 0 ;  i  <  expected bytes . length ;  i +  +  )   {  expected bytes[i] = 1 ;   }  final uuid uuid = uuid . from string ( uuid encoding provider . get instance (  ) 
public void   (  connection con )  {  if  ( con . get next send time (  )   <  =  0 )  return ;  long time till send = con . get next send time (  )   -     context . clock (  )  . now (  )  ;  if  ( time till send  <  =  0 )   {  con . set next send time (  - 1 )  ;  con . send available (  )  ;   }  else  {  reschedule ( time till send con )  ;   }   }  
@ override public void   (  account account )  {  m setup data . set account ( account )  ;   }  
@ override public byte[]   (  data input in )  throws io exception  {  return new byte[0] ;   }  
public   ( final  string host final int porta )  throws io exception  {  final int portb = porta  +  2 ;  addressa = new  inet socket address ( host porta )  ;  addressb = new  inet socket address ( host portb )  ;  channela =  sel datagram channel . open ( null addressa )  ;  channelb =  sel datagram channel . open ( null addressb )  ;  channela . set datagram listener ( new  datagram listener (  )  {  public void datagram received (  final  sel datagram channel channel  final  byte buffer buffer  final  socket address address )  {  last receiveda = address ;  last received timea =  system . current time millis (  )  ;  if  ( last receivedb  !  =  null )   {  try  {  buffer . flip (  )  ;  channelb . send ( buffer last receivedb )  ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }   }   }   )  ;  channelb . set datagram listener ( new  datagram listener (  )  {  public void datagram received (  final  sel datagram channel channel  final  byte buffer buffer  final  socket address address )  {  last receivedb = address ;  last received timeb =  system . current time millis (  )  ;  if  ( last receiveda  !  =  null )   {  try  {  buffer . flip (  )  ;  channela . send ( buffer last receiveda )  ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }   }   }   )  ;  this . porta = porta ;  this . portb = portb ;   socket address addressa    = new  inet socket address ( host porta  +  1 )  ;   socket address addressb    = new  inet socket address ( host portb  +  1 )  ;  channela    =  sel datagram channel . open ( null addressa    )  ;  channelb    =  sel datagram channel . open ( null addressb    )  ;  channela    . set datagram listener ( new  datagram listener (  )  {  public void datagram received (  final  sel datagram channel channel  final  byte buffer buffer  final  socket address address )  {  last receiveda    = address ;  if  ( last receivedb     !  =  null )   {  try  {  buffer . flip (  )  ;  channelb    . send ( buffer last receivedb    )  ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }   }   }   )  ;  channelb    . set datagram listener ( new  datagram listener (  )  {  public void datagram received (  final  sel datagram channel channel  final  byte buffer buffer  final  socket address address )  {  last receivedb    = address ;  if  ( last receiveda     !  =  null )   {  try  {  buffer . flip (  )  ;  channela    . send ( buffer last receiveda    )  ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }   }   }   )  ;  this . ip = host ;   }  
public void   (  string host )  {     config . set client host ( host )  ;   }  
@ test public void   (  )  {   observer <  long >  observer =  test helper . mock observer (  )  ;   observable . range long ( 2 3 )  . subscribe ( observer )  ;  verify ( observer times ( 1 )  )  . on next ( 2l )  ;  verify ( observer times ( 1 )  )  . o
private boolean   (  destination dest int to port  map <  string  object >  map boolean repliable )  {  if  (    session . is closed (  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not sending message  session is closed" )  ;  return false ;   }  if  ( dest . calculate hash (  )  . equals (    my node info . get hash (  )  )  )  throw new  illegal argument exception ( "don't send to ourselves" )  ;  byte[] payload = b encoder . bencode ( map )  ;  if  (    log . should log (  log . debug )  )   {   byte array input stream bais = new  byte array input stream ( payload )  ;  try  {     log . debug ( " sending to: "  +  dest . calculate hash (  )   +  ' ' +  b decoder . bdecode ( bais )  . to string (  )  )  ;   }  catch  (  io exception ioe )   {   }   }  int from port =    q port ;  if  ( repliable )   {  i2p datagram maker dg maker = new i2p datagram maker (    session )  ;  payload = dg maker . makei2p datagram ( payload )  ;  if  ( payload  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( "dgm fail" )  ;  return false ;   }   }   send message options opts = new  send message options (  )  ;  opts . set date (    context . clock (  )  . now (  )   +  60 * 1000 )  ;  opts . set tags to send ( send   crypto   tags )  ;  opts . set tag threshold ( low   crypto   tags )  ;  if  (  ! repliable )  opts . set send lease set ( false )  ;  try  {  boolean success =    session . send message ( dest payload 0 payload . length repliable  ?  i2p session . proto   datagram : i2p session . proto   datagram   raw from port to port opts )  ;  if  ( success )   {     tx pkts . increment and get (  )  ;     tx bytes . add and get ( payload . length )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( "send message fail" )  ;   }  return success ;   }  catch  (  i2p session exception ise )   {  if  (    log . should log (  log . warn )  )     log . warn ( "send message fail" ise )  ;  return false ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject . create (  )  . take while (  functions . always true (  )  )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . for each while ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  {  return true ;   }   }   new  consumer <  throwable >  (  )  {  
@ override public int   (  )  {  if  ( manager . is debug enabled (  )  )   {   log . debug ( " ldap group provider:  trying to get the number of groups in the system . " )  ;   }  if  ( group count  !  =   - 1 &&  system . current time millis (  )   <  e
public static double   ( final double .  .  .  in )  {  if  ( in . length  =  =  0 )   {  throw new  illegal argument exception ( " attempting to find the median of an empty array" )  ;   }  final double[] data =  arrays . copy of ( in in . length )  ;   arrays . sort ( data )  ;  final int middle = data . length  /  2 ;  return data . length % 2  =  =  1  ?  data[middle] :  ( data[middle  -  1]  +  data[middle] )   /  2 . 0 ;   }  
public   (  string id )  {  this . id = id ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( id  +  ": jitter manager "  +  " min size " +  min jitter buffer size +  " max size " +  max jitter buffer size )  ;   }  plc factory =  plc factory . get instance (  )  ;  plc = plc factory . create plc ( plc class name )  ;  plc . set id ( id )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts = pp . timeout ( 1  time unit . days  flowable . just ( 2 )  )  . take ( 1 )  . test (  )  ;  assert true ( pp . has
@ nullable @ override public  integer   (  )  throws  exception  {  long i = index ;  if  ( i  !  =  end )   {  index = i  +  1 ;  return  ( int ) i ;   }  lazy set ( 1 )  ;  return null ;   }  
public int   (  )  {  long after = lv consumer index (  )  ;  while  ( true )   {  final long before = after ;  final long current producer index = lv producer index (  )  ;  after = lv consumer index (  )  ;  if  ( before  =  =  after )   {  return  ( int )  ( current producer index  -  after )  ;   }   }   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  open folder with message ( mock transport )  ;  setup uidl sequence ( mock transport 2 )  ;   message[] messages = m folder . get messages ( 1 2 null )  ;  assert equals ( 2 messages . length )  ;  setup list sequence ( mock transport 2 )  ;   fetch profile fp = new  fetch profile (  )  ;  fp . add (  fetch profile .  item . flags )  ;  fp . add (  fetch profile .  item . envelope )  ;  m folder . fetch ( messages fp null )  ;  for  (   message message : messages )   {  message . get recipients (  recipient type . to )  ;  message . get recipients (  recipient type . cc )  ;  message . get recipients (  recipient type . bcc )  ;   }   message[] single message = new  message[] { messages[0] }  ;  setup single message top ( mock transport 1 true true )  ;  fp = new  fetch profile (  )  ;  fp . add (  fetch profile .  item . body   sane )  ;  m folder . fetch ( single message fp null )  ;  check fetched message ( single message[0] 1 false )  ;  single message[0] = messages[1] ;  setup single message top ( mock transport 2 true false )  ;  fp = new  fetch profile (  )  ;  fp . add (  fetch profile .  item . body   sane )  ;  m folder . fetch ( single message fp null )  ;  check fetched message ( single message[0] 2 false )  ;   }  
@ deprecated @ override public void   ( int size )  {  throw new  illegal argument exception ( "unsupported" )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   maybe . unsafe create (  maybe . just ( 1 )  )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
 set <  string >    (  entry event <  string  collection <  directed presence >  >  event jid handler )  {   collection <  directed presence >  value = event . get value (  )  ;  for  (   directed presence directed presence : value )   {  if  ( directed presence . get handler (  )  . equals ( handler )  )   {  return directed presence . get receivers (  )  ;   }   }  return  collections . empty set (  )  ;   }  
@ override public void   (  content handler handler )  throws sax exception  {  handler . start element ( jsonx   uri get local name (  )  get qname (  )  get attributes (  )  )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public int   (  )  {  return  ( int )    actual length ;   }  
@ test public void   (  )  {   observable . empty (  )  . last or error (  )  . to observable (  )  . test (  )  . assert failure (  no such element exception . class )  ;   }  
private static  body   (  input stream in  string content transfer encoding int size  message retrieval listener listener )  throws io exception  {  in =  mime utility . get input stream for content transfer encoding ( in content transfer encoding )  ;   binary temp file body temp body = new  binary temp file body (  )  ;   output stream out = temp body . get output stream (  )  ;  try  {  byte[] buffer = new byte[copy   buffer   size] ;  int n = 0 ;  int count = 0 ;  while  (  - 1  !  =   ( n = in . read ( buffer )  )  )   {  out . write ( buffer 0 n )  ;  count +  = n ;  if  ( listener  !  =  null )   {  if  ( size  =  =  0 )   {  listener . load attachment progress (  ( int )  math . ceil ( 100 *  ( 1  -  1 . 0  /  count )  )  )  ;   }  else  {  listener . load attachment progress ( count * 100  /  size )  ;   }   }   }   }  catch  (   base64 data exception bde )   {   string warning = "\n\n"  +   imap service . get message decode error string (  )  ;  out . write ( warning . get bytes (  )  )  ;   }  finally  {  out . close (  )  ;   }  return temp body ;   }  
@ test public void   (  )  {   thread . current thread (  )  . interrupt (  )  ;  final int[] calls =  { 0 }  ;  assert same (  empty disposable . instance  schedulers . trampoline (  )  . schedule direct ( new  runnable (  )  {  @ override public void ru
public  tunnel id   (  )  {  if  (    tunnel id obj  =  =  null )     tunnel id obj = new  tunnel id (    tunnel id )  ;  return    tunnel id obj ;   }  
public  consolidation function type   (  )  {  return type ;   }  
public static  string[]   (  )  {  return new  string[] { x   ttl }  ;   }  
private static long   ( final  string file path final  input stream input stream )  {  final byte[] header = new byte[header   size] ;  try  {  final int header bytes read = input stream . read ( header )  ;  if  ( header bytes read  !  =  header   size )   {  throw new  picard exception ( " malformed file  expected header of size "  +  header   size  +  " but received " +  header bytes read )  ;   }   }  catch  (  final io exception ioe )   {  throw new  picard exception ( " unable to read header for file  ( "  +  file path  +  " ) " ioe )  ;   }  final  byte buffer header buf =  byte buffer . wrap ( header )  ;  header buf . order (  byte order . little   endian )  ;  return  unsigned type util . u int to long ( header buf . get int (  )  )  ;   }  
@ override public void   (  )  {  connection . send command ( new  quit command (  )  )  ;  clean up (  )  ;  session disconnected no reconnect ( null )  ;   }  
int   (  )  {  return alignment ;   }  
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   subscriber <  ?  super r >  downstream = this . downstream ;   error mode error mode = this . error mode ;   simple plain queue < t >  queue = this . queue ;   atomic throwable errors = this . errors ;   atomic long requested = this . requested ;  int limit = prefetch  -   ( prefetch  >  >  1 )  ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  queue . clear (  )  ;  item = null ;   }  int s = state ;  if  ( errors . get (  )   !  =  null )   {  if  ( error mode  =  =   error mode . immediate ||  ( error mode  =  =   error mode . boundary && s  =  =  state   inactive )  )   {  queue . clear (  )  ;  item = null ;   throwable ex = errors . terminate (  )  ;  downstream . on error ( ex )  ;  return ;   }   }  if  ( s  =  =  state   inactive )   {  boolean d = done ;  t v = queue . poll (  )  ;  boolean empty = v  =  =  null ;  if  ( d && empty )   {   throwable ex = errors . terminate (  )  ;  if  ( ex  =  =  null )   {  downstream . on complete (  )  ;   }  else  {  downstream . on error ( ex )  ;   }  return ;   }  if  ( empty )   {  break ;   }  int c = consumed  +  1 ;  if  ( c  =  =  limit )   {  consumed = 0 ;  upstream . request ( limit )  ;   }  else  {  consumed = c ;   }   single source <  ?  extends r >  ss ;  try  {  ss =  object helper . require non null ( mapper . apply ( v )  " the mapper returned a null  single source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  upstream . cancel (  )  ;  queue . clear (  )  ;  errors . add throwable ( ex )  ;  ex = errors . terminate (  )  ;  downstream . on error ( ex )  ;  return ;   }  state = state   active ;  ss . subscribe ( inner )  ;  break ;   }  else if  ( s  =  =  state   result   value )   {  long e = emitted ;  if  ( e  !  =  requested . get (  )  )   {  r w = item ;  item = null ;  downstream . on next ( w )  ;  emitted = e  +  1 ;  state = state   inactive ;   }  else  {  break ;   }   }  else  {  break ;   }   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
void   (  throwable ex )  {  if  ( error . add throwable ( ex )  )   {   disposable helper . dispose ( main disposable )  ;  drain (  )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
@ test public void   (  )  {   test helper . check double on subscribe completable ( new  function <  completable  completable source >  (  )  {  @ override public  completable source apply (   completable c )  throws  exception  {  return c . observe on 
void   (  disposable d )  {   disposable helper . replace ( this d )  ;   }  
public long   ( int fragment num )  throws  data format exception  {  int fragment begin = get fragment begin ( fragment num )  ;  return  data helper . from long (    message fragment begin 4 )  ;   }  
public   (  http client user manager user manager )  {  this . decommissioner = new  client decommissioner ( user manager )  ;  this . decomm thread = new  thread ( decommissioner )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source1 =  publish subject . create (  )  ;   publish subject <  integer >  source2 =  publish subject . create (  )  ;   bi function <  integer  observable <  integer >   integer >  fail = new 
@ override public  string   (  string parameter )  {   string value = super . get parameter ( parameter )  ;  if  ( parameter . starts with ( nofilter )  )  return value ;   string rv = stripxss ( value parameter value pattern )  ;  if  ( value  !  =  nul
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   observer <  ?  super r >  downstream = this . downstream ;   error mode error mode = this . error mode ;   simple plain queue < t >  queue = this . queue ;   atomic throwable errors = this . errors ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  queue . clear (  )  ;  item = null ;   }  int s = state ;  if  ( errors . get (  )   !  =  null )   {  if  ( error mode  =  =   error mode . immediate ||  ( error mode  =  =   error mode . boundary && s  =  =  state   inactive )  )   {  queue . clear (  )  ;  item = null ;   throwable ex = errors . terminate (  )  ;  downstream . on error ( ex )  ;  return ;   }   }  if  ( s  =  =  state   inactive )   {  boolean d = done ;  t v = queue . poll (  )  ;  boolean empty = v  =  =  null ;  if  ( d && empty )   {   throwable ex = errors . terminate (  )  ;  if  ( ex  =  =  null )   {  downstream . on complete (  )  ;   }  else  {  downstream . on error ( ex )  ;   }  return ;   }  if  ( empty )   {  break ;   }   maybe source <  ?  extends r >  ms ;  try  {  ms =  object helper . require non null ( mapper . apply ( v )  " the mapper returned a null  maybe source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  upstream . dispose (  )  ;  queue . clear (  )  ;  errors . add throwable ( ex )  ;  ex = errors . terminate (  )  ;  downstream . on error ( ex )  ;  return ;   }  state = state   active ;  ms . subscribe ( inner )  ;  break ;   }  else if  ( s  =  =  state   result   value )   {  r w = item ;  item = null ;  downstream . on next ( w )  ;  state = state   inactive ;   }  else  {  break ;   }   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
@ override public  observable source <  object >    (  observable <  object >  o )  throws  exception  {  return o . take until (  functions . always false (  )  )  ;   }  
@ test public void   (  )  {  s2 . on next ( "1" )  ;  s2 . on next ( "2" )  ;  s2 . on complete (  )  ;  s1 . on next ( "a" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s1 . on next ( "b" )  ;  in order . verify ( observer
@ test public void   (  )  throws  exception  {   string expected = versions xml file reader ;   string actual = transform xml to format ( versions xml file reader new  media type (  mime type . application   xml  - 1 )  new  content transformer (  json f
@ override public void   (  )  {  if  ( is closed )   {  return ;   }  conn . close (  )  ;   }  
public   (  file basecall directory  file barcodes directory int lane  read structure read structure  bcl quality evaluation strategy bcl quality evaluation strategy )  {  this . basecall directory = basecall directory ;  this . barcodes directory = barcodes directory ;  this . bcl quality evaluation strategy = bcl quality evaluation strategy ;  this . lane = lane ;  this . format to data types = null ;  this . available tiles = null ;  this . file util = null ;  output mapping = new  output mapping ( read structure )  ;   pattern lane tile regex =  pattern . compile (  parameterized file util . escape periods (  parameterized file util . make lane tile regex ( " . filter" lane )  )  )  ;   file lane dir = new  file ( basecall directory  illumina file util . long lane str ( lane )  )  ;   list <  integer >  tiles = new  array list <  >  (  )  ;   file[] filter files = get tiled files ( lane dir lane tile regex )  ;  for  (   file filter file : filter files )   {   matcher tile matcher = lane tile regex . matcher ( filter file . get name (  )  )  ;  if  ( tile matcher . matches (  )  )   {  tiles . add (  integer . value of ( tile matcher . group ( 1 )  )  )  ;   }   }  io util . assert files are readable (  arrays . as list ( filter files )  )  ;  tiles . sort (  new illumina basecalls converter . tile   number   comparator )  ;  available tiles = tiles ;   }  
@ override protected void   (  single observer <  ?  super t >  s )  {   throwable error ;  try  {  error =  object helper . require non null ( error supplier . call (  )  " callable returned null throwable .   null values are generally not allowed in 2 .
@ test public void   (  )  {  scan (  completable . class )  ;   }  
private iq   (  object object iq iq boolean mute )  {   log . info ( " rayo component handle on off talk command" )  ;  iq reply = iq . create resultiq ( iq )  ;   string call id = iq . get to (  )  . get node (  )  ;   string speaker id = jid . escape node ( iq . get from (  )  . to barejid (  )   +  " / speaker" )  ;   string bridge call id = "call - "  +  call id  +  speaker id ;   string bridge speaker id = "spkr - "  +  speaker id  +  call id ;   call handler call handler =  call handler . find call ( bridge call id )  ;   call handler call handler2 =  call handler . find call ( bridge speaker id )  ;  if  ( call handler  !  =  null )   {   call handler spkr handler =  call handler . find call ( speaker id )  ;  if  ( spkr handler  !  =  null )   {   member receiver member receiver = spkr handler . get member receiver (  )  ;   member sender member sender = call handler . get member sender (  )  ;  if  (  ! mute )   {  member receiver . set channel ( new  speaker channel ( call handler . get member receiver (  )  )  )  ;   }  else  {  member receiver . set channel ( null )  ;   }   call participant cp = spkr handler . get call participant (  )  ;  cp . set muted ( mute )  ;   }   }  else  {  reply . set error (  packet error .  condition . item   not   found )  ;   }  return reply ;   }  
@ test public void   (  )  {   throwable error = new  throwable (  )  ;   flowable <  string >  obs =  flowable . error ( error )  ;   subscriber <  boolean >  observer =  test helper . mock subscriber (  )  ;  obs . all ( new  predicate <  string >  (  )
public void   (  string id )  {  set header ( http . sid  subscription . tosid header string ( id )  )  ;   }  
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . "  +  get type (  )  . to string (  )   +  " . registration" "kraken" )  ;   }  
@ override public boolean   (  )  {  return iter . has next (  )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return observable convert . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public  parallel flowable   (  parallel flowable pf )  throws  exception  {  return new  parallel from publisher <  integer >  (  flowable . just ( 2 )  2 2 )  ;   }  
public byte[]   (  )  {  if  (  ! ed dsa spec . equals (  eddsa named curve table . get by name (  eddsa named curve table . curve   ed25519   sha512 )  )  )  return null ;  int totlen = 15  +   abyte . length ;  byte[] rv = new byte[totlen] ;  int idx = 0 ;  rv[idx +  + ] = 0x30 ;  rv[idx +  + ] =  ( byte )  ( 13  +   abyte . length )  ;  rv[idx +  + ] = 0x30 ;  rv[idx +  + ] = 8 ;  rv[idx +  + ] = 0x06 ;  rv[idx +  + ] = 3 ;  rv[idx +  + ] =  ( 1 * 40 )   +  3 ;  rv[idx +  + ] = 101 ;  rv[idx +  + ] = 100 ;  rv[idx +  + ] = 0x0a ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 0x03 ;  rv[idx +  + ] =  ( byte )  ( 1  +   abyte . length )  ;  rv[idx +  + ] = 0 ;   system . arraycopy (  abyte 0 rv idx  abyte . length )  ;  return rv ;   }  
@ test public void   (  )  {   flowable <  string >  source =  flowable . just ( "a" "b" "cc" "dd" )  ;   function <  string  integer >  length func err = new  function <  string  integer >  (  )  {  @ override public  integer apply (   string t1 )  {  if
@ override public void   ( boolean encrypted )  {  throw new  runtime exception ( "immutable" )  ;   }  
@ override public long   (  )  {  return 1 ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . single element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  mergen async streams ofn ( 1000 1000 )  . subscribe ( to )  ;  to . await terminal event (  )  ;  to . assert no errors (  )  ;  assert equals ( 1000
public  string   (  )  {  return " load  router  info" ;   }  
public void   (  string affiliation )  {  this . affiliation = affiliation ;   }  
public void   (  plugin manager manager  file plugin directory )  {   email listener . get instance (  )  . start (  )  ;   }  
@ override public void   (  throwable e )  {  this . on error = true ;   }  
@ override public void   (  async event async event )  throws io exception  {   log . debug ( "error event "  +  async event )  ;   log . warn ( " unhandled  async listener error: "  +  async event . get throwable (  )  )  ;  connection queue . remove ( c
public void   (  throwable e )  {  observer . on error ( e )  ;   }  
 queue <  log record >    (  )  {  return    records ;   }  
@ override public void   ( t t )  {  if  ( value  =  =  null )   {  value = t ;  s . cancel (  )  ;  count down (  )  ;   }   }  
private static final  string   (  string s )  {  return s ;   }  
private  http client   (  )  {   http client container client response = null ;  try  {  client response = http client service . get client ( connection pool id )  ;  return client response . get http client (  )  ;   }  finally  {  if  ( client response  !  =  null )   {  http client service . release client ( client response )  ;   }   }   }  
private void   (  )  {     mgr . check available ( news 60 * 1000 )  ;   }  
void   (  throwable e )  {   subscription helper . cancel ( upstream )  ;  if  ( errors . add throwable ( e )  )   {  done = true ;  drain (  )  ;   }  else  {   rx java plugins . on error ( e )  ;   }   }  
public int   (  )  {  return size ;   }  
public int   (  )  {  return    cost ;   }  
public int   (  )  {  return get integer value ( http   socket   timeout 20000 )  ;   }  
public void   (  entry listener listener )  {   string registration id = registrations . get ( listener )  ;  if  ( registration id  !  =  null )   {  map . remove entry listener ( registration id )  ;   }   }  
public void   (  )  {   node scpd node = getscpd node (  )  ;  if  ( scpd node  =  =  null )  return ;   string scpd xml = scpd node . to string (  )  ;  int config id = u pnp . caluculate config id ( scpd xml )  ;  scpd node . set attribute ( config   id config id )  ;   }  
public  string   (  )  {  return get allowed value range node (  )  . get node value ( maximum )  ;   }  
public  inet socket address   (  )  {  return new  inet socket address (  bridge . get private host (  )  datagram channel . socket (  )  . get local port (  )  )  ;   }  
@ override public final boolean   (  )  {  return move to position ( get count (  )   -  1 )  ;   }  
@ override void   (  data processor dproc )  {  dproc . add datasource ( name m   source name m   percentile m   includenan )  ;   }  
protected   ( final  string path final boolean read only )  throws io exception   illegal state exception  {  super ( path read only )  ;  if  ( file  !  =  null )   {  m   ch = file . get channel (  )  ;  m   byte buffer =  byte buffer . allocate (  ( int ) m   ch . size (  )  )  ;  m   ch . read ( m   byte buffer 0 )  ;   }  else  {  throw new  illegal state exception ( " file in base class is null . " )  ;   }   }  
@ override public void   (  )  {  m   lcbciv = 0 ;  super . clean up (  )  ;   }  
public org . openrepose . core . systemmodel . config .  filter   (  )  {  return filter config ;   }  
@ override public  string   (  )  {  return " group member added" ;   }  
@ ignore ( " the target is an enum" )  @ test public void   (  )  {   test helper . check utility class (  blocking flowable most recent . class )  ;   }  
public  database entry   (  hash key )  {  return null ;   }  
public void   (  account account )  {  final  intent intent =  account server settings activity . get intent for incoming ( get activity (  )  account )  ;  get activity (  )  . start activity ( intent )  ;   }  
@ override public void   (  view v )  {  switch  ( v . get id (  )  )   {  case r . id . clear   webview   cache: clear web view cache (  )  ;  break ;  case r . id . clear   migration   state: clear migration state (  )  ;  break ;   }   }  
@ override public boolean   (  )  {  return on error  !  =  this ;   }  
protected void   ( final  call state call state final  contingency state[] .  .  .  concordance state arrays )  {  if  ( concordance state arrays . length  !  =   truth state . values (  )  . length )   {  throw new  picard exception ( " length mismatch between concordance state arrays and  truth state . values (  ) " )  ;   }  for  ( int i = 0 ;  i  <  concordance state arrays . length ;  i +  +  )   {  scheme . put ( new  truth and call states (  truth state . values (  ) [i] call state )  concordance state arrays[i] )  ;   }   }  
@ override public final boolean   (  )  {  return done ;   }  
public void   (  )  throws io exception  {   account account1 =  provider test utils . setup account ( "attachment - query" false m mock context )  ;  account1 . save ( m mock context )  ;  final long message1 id = 1 ;  final long message2 id = 2 ;  final long message3 id = 3 ;  final long message4 id = 4 ;   attachment new attachment1 =  provider test utils . setup attachment ( message1 id "file1" 100 true m mock context )  ;   attachment new attachment2 =  provider test utils . setup attachment ( message2 id "file2" 200 true m mock context )  ;   attachment new attachment3 =  provider test utils . setup attachment ( message2 id "file3" 100 true m mock context )  ;   attachment new attachment4 =  provider test utils . setup attachment ( message3 id "file4" 100 true m mock context )  ;  create attachment file ( account1 new attachment1 . m id )  ;  create attachment file ( account1 new attachment2 . m id )  ;  create attachment file ( account1 new attachment3 . m id )  ;   file attachments dir =  attachment utilities . get attachment directory ( m mock context account1 . m id )  ;  assert equals ( 3 attachments dir . list files (  )  . length )  ;   attachment utilities . delete all attachment files ( m mock context account1 . m id message4 id )  ;  assert equals ( 3 attachments dir . list files (  )  . length )  ;   attachment utilities . delete all attachment files ( m mock context account1 . m id message3 id )  ;  assert equals ( 3 attachments dir . list files (  )  . length )  ;   attachment utilities . delete all attachment files ( m mock context account1 . m id message2 id )  ;  assert equals ( 1 attachments dir . list files (  )  . length )  ;   attachment utilities . delete all attachment files ( m mock context account1 . m id message1 id )  ;  assert equals ( 0 attachments dir . list files (  )  . length )  ;   }  
public static  streamid   (  string name )  {  return new  basic streamid ( name )  ;   }  
public boolean   (  )  {  return flag set ( udp packet . data   flag   want   reply )  ;   }  
@ override protected void   (  http servlet request request  http servlet response response )  throws  servlet exception  io exception  {  do get ( request response )  ;   }  
public void   (  string port )  {     tcp port =  ( port  !  =  null  ?  port . trim (  )  : null )  ;   }  
@ override public  iterator <  string >    (  )  {  return  collections . singleton ( "jabber:iq:roster" )  . iterator (  )  ;   }  
@ override public void   (  string result  string id  string message )  {  synchronized  (    stream status lock )   {  if  ( sam reader . sam client event listener . session   status   ok . equals ( result )  )     stream status ok =  boolean . true ;  e
private void   (  )  {  if  ( is closed )   {  return ;   }  is closed = true ;  try  {  synchronized  ( connection queue )   {  for  (   http connection to close : connection queue )   {  try  {  if  (  ! to close . is closed (  )  )   {  if  (  ! pending elements . is empty (  )  && to close . get request id (  )   =  =  last requestid  +  1 )   {  synchronized  ( pending elements )   {  deliver ( to close pending elements )  ;  last requestid = to close . get request id (  )  ;  pending elements . clear (  )  ;   }   }  else  {  to close . deliver body ( null true )  ;   }   }   }  catch  (   http connection closed exception e )   {   }  catch  (  io exception e )   {   log . debug ( " an unexpected exception occurred while closing a session . " e )  ;   }   }   }  synchronized  ( pending elements )   {  for  (   deliverable deliverable : pending elements )   {  fail delivery ( deliverable . get packets (  )  )  ;   }  pending elements . clear (  )  ;   }   }  finally  {  for  (   session listener listener : listeners )   {  listener . session closed ( this )  ;   }  this . listeners . clear (  )  ;   }   }  
private void   (  subscriber <  string >  observer )  {  verify ( observer times ( 1 )  )  . on next ( "one" )  ;  verify ( observer times ( 1 )  )  . on next ( "two" )  ;  verify ( observer times ( 1 )  )  . on next ( "three" )  ;  verify ( observer  mockito . never (  )  )  . on error ( any (  throwable . class )  )  ;  verify ( observer times ( 1 )  )  . on complete (  )  ;   }  
@ deprecated public static  boolean   (  input stream in )  throws  data format exception  io exception  {  int val = in . read (  )  ;  switch  ( val )   {  case  - 1: throw new eof exception ( "eof reading boolean" )  ;  case 0: return  boolean . false 
protected void   (  get bandwidth limits message message )  {  if  (    log . should log (  log . info )  )     log . info ( " got bw  limits request" )  ;  int in =    context . bandwidth limiter (  )  . get inboundk bytes per second (  )  * 4  /  7 ;  int out =    context . bandwidth limiter (  )  . get outboundk bytes per second (  )  * 4  /  7 ;   bandwidth limits message msg = new  bandwidth limits message ( in out )  ;  try  {     runner . do send ( msg )  ;   }  catch  (  i2cp message exception ime )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error writing bw limits msg" ime )  ;   }   }  
private static  string   (  class <  ?  >  clazz )  {  return clazz . get name (  )  . replace ( ' . ' ' / ' )   +  template   group   extension ;   }  
@ override public void   (  jdbi jdbi )  {  jdbi . register collector ( new  vavr collector factory (  )  )  ;  jdbi . register row mapper ( new  vavr tuple row mapper factory (  )  )  ;  jdbi . register argument ( new  vavr value argument factory (  )  )
public  cluster data   (  )  {  if  (  ! has next (  )  )   {  throw new  no such element exception (  )  ;   }  final  cluster data cluster = new  cluster data ( output read types )  ;  cluster . set lane ( lane )  ;  cluster . set tile ( parsers[0] . get tile of next cluster (  )  )  ;  for  ( int i = 0 ;  i  <  parsers . length ;  i +  +  )   {  final  illumina data il data = parsers[i] . next (  )  ;  for  (  final  illumina data type il data type : data types[i] )   {  switch  ( il data type )   {  case  position: add data ( cluster  (  positional data ) il data )  ;  break ;  case pf: add data ( cluster  (  pf data ) il data )  ;  break ;  case  barcodes: add data ( cluster  (  barcode data ) il data )  ;  break ;  case  base calls: add read data ( cluster num reads  (  base data ) il data )  ;  break ;  case  quality scores: add read data ( cluster num reads  (  quality data ) il data )  ;  break ;  default : throw new  picard exception ( " unknown data type "  +  il data type  +  " requested by  illumina data provider factory" )  ;   }   }   }  return cluster ;   }  
@ override public  throwable   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
public static  rate limiting configuration   (  )  {  final  rate limiting configuration new cfg = new  rate limiting configuration (  )  ;  final  request endpoint endpoint = new  request endpoint (  )  ;  endpoint . set include absolute limits (  boolean . true )  ;  endpoint . set uri regex ( " / v1 . 0 / limits /  ? " )  ;  new cfg . set request endpoint ( endpoint )  ;  new cfg . get limit group (  )  . add ( new configured limit group ( default   user   role default   uri default   uri   regex default   limit   group   id )  )  ;  new cfg . get limit group (  )  . add ( new multi method configured limit group ( default   user   role multi   method   uri multi   method   uri   regex multi   method   limit   group   id )  )  ;  return new cfg ;   }  
public void   ( boolean can change nickname )  {  this . can change nickname = can change nickname ;   }  
  (  type return type )  {  this . return type = return type ;   }  
public void   (  )  {  final  host auth before = new  host auth (  )  ;  before . m protocol = "imap" ;  before . m address = "dhoff@example . com" ;  before . m port = 1337 ;  before . m flags = 293847 ;  before . set login ( "dhoff" "daknightrida" )  ;  before . m domain = "example . com" ;  before . m client cert alias = "i'm a client cert alias" ;  before . m server cert = new byte[] {  ( byte ) 0xff  ( byte ) 0xaa }  ;  before . m credential key = 9873425 ;  before . m credential =  credential . empty ;  before . ensure loaded ( get context (  )  )  ;  final  host auth after =  host auth . from json ( before . to json (  )  )  ;  assert equals ( before . m protocol after . m protocol )  ;  assert equals ( before . m address after . m address )  ;  assert equals ( before . m port after . m port )  ;  assert equals ( before . m flags after . m flags )  ;  assert true (  arrays . equals ( before . get login (  )  after . get login (  )  )  )  ;  assert equals ( before . m domain after . m domain )  ;  assert equals ( before . m client cert alias after . m client cert alias )  ;  assert equals ( before . m credential after . m credential )  ;  assert null ( after . m server cert )  ;  assert equals (  - 1 after . m credential key )  ;   }  
private void   (  pub sub service service iq iq  element configure element  string nodeid )  {   node node = service . get node ( nodeid )  ;  if  ( node  =  =  null )   {  send error packet ( iq  packet error .  condition . item   not   found null )  ;  return ;   }  if  (  ! node . is admin ( iq . get from (  )  )  )   {  send error packet ( iq  packet error .  condition . forbidden null )  ;  return ;   }   data form completed form = get sent configuration form ( configure element )  ;  if  ( completed form  !  =  null )   {  try  {  node . configure ( completed form )  ;   cache factory . do cluster task ( new  refresh node task ( node )  )  ;  router . route ( iq . create resultiq ( iq )  )  ;   }  catch  (   not acceptable exception e )   {  send error packet ( iq  packet error .  condition . not   acceptable null )  ;   }   }  else  {  send error packet ( iq  packet error .  condition . bad   request null )  ;   }   }  
public   ( final  path input file final  string read group final  string sample alias )  {  this . input file = input file ;  this . read group = read group ;  this . sample alias = sample alias ;   }  
public void   ( final  metrics file < metric   type  histogram   key >  file )  {  for  (  final  distributor collector : output ordered distributors )   {  collector . add to file ( file )  ;   }   }  
void   ( int piece )  {   peer state s = state ;  if  ( s  !  =  null )  s . cancel piece ( piece )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   flowable . just ( 1 )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  throws  exception  {  throw e ;
private void   (  string data )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( "insert into "  +  table name  +  "  ( ownerid name prop value )  values  (  ?   ?   ?  ) " )  ;  pstmt . set long ( 1 id )  ;  pstmt . set string ( 2 data )  ;   db connection manager . set large text field ( pstmt 3 properties . get ( data )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public static long   (  router context ctx )  {  return ctx . router (  )  . get shutdown time remaining (  )  ;   }  
public static int[]   ( final int windows final  file reference sequence final int window size )  {  final  reference sequence file ref file =  reference sequence file factory . get reference sequence file ( reference sequence )  ;   reference sequence ref ;  final int[] windows by gc = new int[windows] ;  while  (  ( ref = ref file . next sequence (  )  )   !  =  null )   {  final byte[] ref bases = ref . get bases (  )  ;   string util . to upper case ( ref bases )  ;  final int ref length = ref bases . length ;  final int last window start = ref length  -  window size ;  final  calculate gc state state = new  gc bias utils (  )  . new  calculate gc state (  )  ;  for  ( int i = 1 ;  i  <  last window start ;   +  + i )   {  final int window end = i  +  window size ;  final int gc bin = calculate gc ( ref bases i window end state )  ;  if  ( gc bin  !  =   - 1 )  windows by gc[gc bin] +  +  ;   }   }  return windows by gc ;   }  
@ xml element public  string   (  )  {  return description ;   }  
public   ( i2p app context ctx  connection con )  {     context = ctx ;     log = ctx . log manager (  )  . get log (  connection data receiver . class )  ;     connection = con ;   }  
  (  )  {   node n = new  node ( null 0 )  ;  tail = n ;  set ( n )  ;   }  
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts =  flowable . range ( 1 2 )  . flat map single ( new  function <  integer  single source <  integer >  >  (  )
public final static int   (  properties props  string prefix  string name )  {   string val = props . get property ( prefix  +  name )  ;  if  ( val  !  =  null )   {  try  {  int rv =  integer . parse int ( val )  ;  return rv  >  =  0  ?  rv : 0 ;   }  catch  (   number format exception nfe )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  persistence helper . class )  ;  log . warn ( " error formatting "  +  val nfe )  ;   }   }  return 0 ;   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  return  completable . complete (
public final boolean   (  )  {  return cancelled ;   }  
@ test public void   (  )  {   test helper . check disposed (  single . just ( 1 )  . unsubscribe on (  schedulers . single (  )  )  )  ;   }  
@ test public void   (  )  {   flowable . merge delay error (  flowable . just ( 1 )   flowable . just ( 2 )   flowable . just ( 3 )  )  . test (  )  . assert result ( 1 2 3 )  ;   }  
public void   ( int hour )  {  this . hour = hour ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable plain . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . error ( new  test exception (  )  )  . on error resume next ( new  function <  throwable  observable <  object >  >  (  )  {  @ override public  observable <  obje
public void   (  )  throws io exception  {  socket . close (  )  ;   }  
boolean   (  inner subscriber < t >  producer )  {  for  (  ;   ;   )   {   inner subscriber < t > [] c = subscribers . get (  )  ;  if  ( c  =  =  terminated )   {  return false ;   }  int len = c . length ;  @ suppress warnings ( "unchecked" )   inner subscriber < t > [] u = new  inner subscriber[len  +  1] ;   system . arraycopy ( c 0 u 0 len )  ;  u[len] = producer ;  if  ( subscribers . compare and set ( c u )  )   {  return true ;   }   }   }  
@ post construct public void   (  )  {  plugin =  user service pluginng . get instance (  )  ;   }  
public boolean   (  )  {  try  {  if  ( sock in  !  =  null )  sock in . close (  )  ;  if  ( sock out  !  =  null )  sock out . close (  )  ;  get socket (  )  . close (  )  ;   }  catch  (   exception e )   {  return false ;   }  return true ;   }  
@ override public boolean   (  object o )  {  return this  =  =  o ;   }  
public void   ( boolean required )  {  this . required = required ;   }  
public synchronized long   (  )  {  return    offset ;   }  
public void   (  )  {  find tag end ( " < tag foo = \"bar\"@  /  >   < blah blah > " "tag" )  ;  find tag end ( " < tag foo = \"bar\" > some text@ <  / tag > some more text" "tag" )  ;  find tag end ( " < tag foo = \"bar\" > some more text but no end tag" "tag" )  ;  find tag end ( " < tag foo = \"bar\" > some more text but no end tag" "tag " )  ;   }  
public long   (  )  {  return  system . current time millis (  )   -     created ;   }  
public void   (  string value )  {  observer . on next ( value )  ;   }  
public uri   (  )  {  return this . uri ;   }  
protected  uri   (  )  {  throw new  unsupported operation exception ( " subclasses must override this method for content observation to work" )  ;   }  
public  byte buffer   (  buffer buffer )  {  final  byte buffer deallocatable direct byte buffer ;  if  ( buffer  !  =  null && buffer . is direct (  )  )   {  final  class <  ?  >  buffer class = buffer . get class (  )  ;  final  field attachment or byte buffer field = attachment or byte buffer field map  =  =  null  ?  null : attachment or byte buffer field map . get ( buffer class )  ;  final  buffer attachment buffer or byte buffer ;  if  ( attachment or byte buffer field  =  =  null )  attachment buffer or byte buffer = null ;  else  {   object attached object or byte buffer ;  final boolean attached object or byte buffer field was accessible = attachment or byte buffer field . is accessible (  )  ;  try  {  attachment or byte buffer field . set accessible ( true )  ;  attached object or byte buffer = attachment or byte buffer field . get ( buffer )  ;   }  catch  (   illegal argument exception| illegal access exception iae )   {  attached object or byte buffer = null ;   }  finally  {  attachment or byte buffer field . set accessible ( attached object or byte buffer field was accessible )  ;   }  if  ( attached object or byte buffer instanceof  buffer )  attachment buffer or byte buffer =  (  buffer ) attached object or byte buffer ;  else attachment buffer or byte buffer = null ;   }  if  ( attachment buffer or byte buffer  =  =  null )   {  if  ( buffer instanceof  byte buffer && deallocatable buffer class set . contains ( buffer class )  )  deallocatable direct byte buffer =  (  byte buffer ) buffer ;  else  {  deallocatable direct byte buffer = null ;  final  string buffer class name = buffer class . get name (  )  ;  logger . warn ( " no deallocatable buffer has been found for an instance of the class "  +  buffer class name  +  " whereas it is a direct nio buffer" )  ;   }   }  else  {  deallocatable direct byte buffer = find deallocatable buffer ( attachment buffer or byte buffer )  ;   }   }  else  {  deallocatable direct byte buffer = null ;   }  return deallocatable direct byte buffer ;   }  
@ test public void   (  )  throws  exception  {  expect ( "select ''" literal quoted   text eof )  ;   }  
public  service   (  )  {  return new  service ( get service node (  )  )  ;   }  
@ override public boolean   (  )  {  return cancelled ;   }  
  (  subscriber <  ?  super t >  actual  consumer <  ?  super t >  on next  consumer <  ?  super  throwable >  on error  action on complete  action on after terminate )  {  super ( actual )  ;  this . on next = on next ;  this . on error = on error ;  this . on complete = on complete ;  this . on after terminate = on after terminate ;   }  
@ override public int   (  )  {  int total = 0 ;  for  (  muc room room : localmuc room manager . get rooms (  )  )   {  total = total  +  room . get occupants count (  )  ;   }  return total ;   }  
@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind ( "name"  optional . of ( new  name ( "eric" )  )  )  . map to bean (  something . cl
public void   (  conn processor exception event event )  {   log . debug ( event . get type (  )   +  " flap error: "  +  event . get exception (  )  . get message (  )  +  " " +  event . get reason (  )  event . get exception (  )  )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public void   (  string name )  throws  unauthorized exception  {  this . name = name ;   }  
public void   ( i2p session session )  {  if  (    log . should log (  log . warn )  )     log . warn ( "i2p session disconnected" )  ;     manager . disconnect all hard (  )  ;  if  (    restart pending )   {     manager . get connection handler (  )  . set restart pending (  )  ;     restart pending = false ;   }  else  {     manager . get connection handler (  )  . set active ( false )  ;   }  for  (  i2p socket manager .  disconnect listener lsnr :    listeners )   {  lsnr . session disconnected (  )  ;   }     listeners . clear (  )  ;   }  
@ override public  integer   (  )  throws  number format exception  {  return  integer . value of ( s )  ;   }  
public int[]   (  )  {  if  ( complete (  )  || metainfo . get files (  )   =  =  null )  return null ;  int[] rv = new int[metainfo . get pieces (  ) ] ;  int file = 0 ;  long pc end =  - 1 ;  long file end =    torrent files . get ( 0 )  . length  -  1 ;  for  ( int i = 0 ;  i  <  rv . length ;  i +  +  )   {  pc end +  = piece   size ;  int pri =    torrent files . get ( file )  . priority ;  while  ( file end  <  =  pc end && file  <     torrent files . size (  )   -  1 )   {  file +  +  ;   torrent file tf =    torrent files . get ( file )  ;  long old file end = file end ;  file end +  = tf . length ;  if  ( tf . priority  >  pri && old file end  <  pc end )  pri = tf . priority ;   }  rv[i] = pri ;   }  return rv ;   }  
@ test public void   (  )  throws  exception  {   public key public key = new  public key (  )  ;  public key . to string (  )  ;  exception . expect (  data format exception . class )  ;  exception . expect message ( " no data to write out" )  ;  public 
public long   (  )  {  return    lifetime agreed to . get (  )  ;   }  
@ override public boolean   (  collection <  ?  >  c )  {  return list . contains all ( c )  ;   }  
public int   (  )  {   stat manager mgr =    context . stat manager (  )  ;   rate stat rs = mgr . get rate ( "bw . recv rate" )  ;  int recv = 0 ;  if  ( rs  !  =  null )  recv =  ( int ) rs . get rate ( 1 * 60 * 1000 )  . get average value (  )  ;  return recv ;   }  
public void   ( muc room task task )  {  task queue . add ( task )  ;   }  
protected int   ( byte out[] int cur index )  throws i2np message exception  {  if  (    key  =  =  null )  throw new i2np message exception ( " key in reply to not specified" )  ;  if  (    from  =  =  null )  throw new i2np message exception ( " no 'from' address specified ! " )  ;   system . arraycopy (    key . get data (  )  0 out cur index  hash . hash   length )  ;  cur index +  =  hash . hash   length ;   data helper . to long ( out cur index 1    peer hashes . size (  )  )  ;  cur index +  +  ;  for  ( int i = 0 ;  i  <  get num replies (  )  ;  i +  +  )   {   system . arraycopy ( get reply ( i )  . get data (  )  0 out cur index  hash . hash   length )  ;  cur index +  =  hash . hash   length ;   }   system . arraycopy (    from . get data (  )  0 out cur index  hash . hash   length )  ;  cur index +  =  hash . hash   length ;  return cur index ;   }  
@ override void   (  type variable <  ?  >  t )  {  visit ( t . get bounds (  )  )  ;   }  
 cluster task   (  string text )  {  return new  deliver raw text task ( this address text )  ;   }  
@ non null @ override public  disposable   ( @ non null  runnable action long delay time @ non null  time unit unit )  {  if  ( tasks . is disposed (  )  )   {  return  empty disposable . instance ;   }  return thread worker . schedule actual ( action del
@ test public void   (  )  throws  exception  {  final  string suffix = " . 1 . fastq" ;  final  file output fastq1 =  file . create temp file ( "non barcoded . " suffix )  ;  output fastq1 . delete on exit (  )  ;  final  string output prefix = output fa
@ override public  handles   (  )  {  return new  handles ( this )  ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register row mapper factory impl (  )  ;   register row mapper factories register row mapper factories =  (  regi
public int   (  )  {  throw new  unsupported operation exception (  )  ;   }  
private void   (  string service name )  {  if  ( service name  =  =  null )   {  throw new  null pointer exception ( " service name cannot be null" )  ;   }  if  ( this . service name . equals ( service name )  )   {  return ;   }  try  {  component manager . remove component ( this . service name )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  component manager . add component ( service name sip component )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  this . service name = service name ;   }  
public synchronized void   (  string .  .  .  algorithms )  throws  certificate store config exception  {  for  (   string algorithm : algorithms )   {   log . debug ( " verifying that a domain certificate  (  {  }  algorithm )  is available in this store . " algorithm )  ;  if  (  ! contains domain certificate ( algorithm )  )   {   log . debug ( " store does not contain a domain certificate  (  {  }  algorithm )  .  a self - signed certificate will be generated . " algorithm )  ;  add self signed domain certificate ( algorithm )  ;   }   }   }  
@ override public boolean   (  )  {  return subscription . get (  )   =  =   subscription helper . cancelled ;   }  
public boolean   (  )  {  return u ;   }  
@ override public void   (  object object  throwable throwable )  {   log . debug ( object . to string (  )  throwable )  ;   }  
@ override public void   (  loader <  cursor >  loader  cursor data )  {  adapter . swap cursor ( data )  ;   }  
@ test public void   (  )  throws  exception  {  final  message message = new  message (  )  ;  message . add child element ( "unittest" "unit:test:namespace" )  ;  final  list <  packet >  packets = new  array list <  >  (  )  ;  packets . add ( message 
@ test public void   (  )  throws  exception  {   target host info target host info = new  target host info ( invalid target host )  ;  assert null ( " returned url was null as expected" target host info . get proxied host url (  )  )  ;   }  
@ override public  observable <  string >    (  throwable t1 )  {  return  observable .  <  string > error ( t1 )  ;   }  
@ test public void   (  )  {   observable . empty (  )  . timeout ( 1  time unit . days  observable . just ( 1 )  )  . test (  )  . assert result (  )  ;   }  
@ override public  flowable <  object >    (  )  {  return  flowable . unsafe create ( new  publisher <  object >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  object >  observer )  {  observer . on subscribe ( new  boolean subscr
public  string   (  )  {  return sql ;   }  
public void   (  string literal  string[] responses )  {  expect ( "^"  +   pattern . quote ( literal )   +  "$" responses )  ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set fail on non blocking scheduler ( true )  ;   observable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  . map ( new  function <  integer  integer >  (  )  {  @ override public 
  (  single observer <  ?  super  boolean >  actual  object value )  {  this . actual = actual ;  this . value = value ;   }  
public boolean   (  )  {  return presence   unknown   resource   id  =  =  m presence res id ;   }  
void   (  config registry config )  {  this . config . set ( config )  ;   }  
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   subscriber <  ?  super r >  downstream = this . downstream ;   atomic throwable errors = this . errors ;   atomic reference <  switch map maybe observer < r >  >  inner = this . inner ;   atomic long requested = this . requested ;  long emitted = this . emitted ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  if  ( errors . get (  )   !  =  null )   {  if  (  ! delay errors )   {   throwable ex = errors . terminate (  )  ;  downstream . on error ( ex )  ;  return ;   }   }  boolean d = done ;   switch map maybe observer < r >  current = inner . get (  )  ;  boolean empty = current  =  =  null ;  if  ( d && empty )   {   throwable ex = errors . terminate (  )  ;  if  ( ex  !  =  null )   {  downstream . on error ( ex )  ;   }  else  {  downstream . on complete (  )  ;   }  return ;   }  if  ( empty || current . item  =  =  null || emitted  =  =  requested . get (  )  )   {  break ;   }  inner . compare and set ( current null )  ;  downstream . on next ( current . item )  ;  emitted +  +  ;   }  this . emitted = emitted ;  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
private boolean   ( int value )  {   char sequence[] values = m check frequency . get entry values (  )  ;  for  (   char sequence list value : values )   {  if  ( list value  !  =  null &&  integer . parse int ( list value . to string (  )  )   =  =  value )   {  return true ;   }   }  return false ;   }  
public long   (  )  {  return presence . get (  )  ;   }  
  (  string id boolean read only )  throws io exception  {  super ( id )  ;  this . read only = read only ;   connection con = null ;   prepared statement pstmt = null ;   prepared statement insert stmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( jdbc   select )  ;  pstmt . set string ( 1 id )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  buffer = rs . get bytes ( "bytes" )  ;   }  else  {  insert stmt = con . prepare statement ( jdbc   insert )  ;  insert stmt . set string ( 1 id )  ;  insert stmt . set long ( 2  system . current time millis (  )  )  ;  insert stmt . set bytes ( 3 null )  ;  insert stmt . execute update (  )  ;   }   }  catch  (   exception e )   {   log . error ( " error while accessing information in database: "  +  e )  ;   }  finally  {   db connection manager . close statement ( insert stmt )  ;   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ check return value @ backpressure support (  backpressure kind . unbounded   in )  @ scheduler support (  scheduler support . none )  public static  < t >  completable   ( final  publisher < t >  publisher )  {   object helper . require non null ( publi
@ test public void   (  )  throws  exception  {   action unsubscribe = mock (  action . class )  ;   observable <  integer >  o =  observable . just ( 1 )  . do on dispose ( unsubscribe )  . cache (  )  ;  o . subscribe (  )  ;  o . subscribe (  )  ;  o .
public jid   (  string username )  {  if  ( username . index of ( " / " )   >   - 1 )   {  username = username . substring ( 0 username . index of ( " / " )  )  ;   }  if  (  jive globals . get boolean property ( "plugin . gateway . tweak . percenthack" false )  )   {  return new jid ( username . replace ( '@' '%' )  . replace ( " " "" )  this . jid . get domain (  )  null )  ;   }  else  {  return new jid ( jid . escape node ( username . replace ( " " "" )  )  this . jid . get domain (  )  null )  ;   }   }  
public  node   (  )  {  return xsl ;   }  
public  mime message   (  )  {  if  ( session  =  =  null )   {  create session (  )  ;   }  return new  mime message ( session )  ;   }  
void   (  )  {  waiting . set ( 1 )  ;   }  
private sam record   ( final sam record record )  {  if  ( found unmappedeof reads )   {  final sam record unmapped record = backing iterator . next (  )  ;  if  (  ! record . is secondary or supplementary (  )  )   {  final  duplication metrics metrics = get metrics ( record )  ;   +  + metrics . unmapped   reads ;   }  if  (  ! output buffer . is empty (  )  )   {  throw new  picard exception ( " encountered unmapped reads at the end of the file  but the alignment start buffer was not empty . " )  ;   }  return unmapped record ;   }  else  {  found unmappedeof reads = true ;  reference index = header . get sequence dictionary (  )  . get sequences (  )  . size (  )  ;  try polling the to mark queue ( true null )  ;  return mark duplicates and get the next available (  )  ;   }   }  
@ test public void   (  )  throws  exception  {  final  string input = " < stream:stream to = 'example . com' xmlns:stream = 'http: /  / etherx . jabber . org / streams' version = '1 . 0' >  < message xmlns = 'jabber:client' from = 'juliet@example . com' 
@ override public  string   (  )  {  return " group modified" ;   }  
@ override public  input stream   (  )  throws io exception  {   input stream rv =    socket . get input stream (  )  ;  if  ( rv  !  =  null )  return rv ;  throw new io exception ( " no stream" )  ;   }  
private static void   (  remote server configuration configuration )  {  configurations cache . put ( configuration . get domain (  )  configuration )  ;  java . sql .  connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( add   configuration )  ;  pstmt . set string ( 1 configuration . get domain (  )  )  ;  pstmt . set int ( 2 configuration . get remote port (  )  )  ;  pstmt . set string ( 3 configuration . get permission (  )  . to string (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  flowable . empty (  )   flowable . zip array (  functions .  <  object[] > identity (  )  false 16 )  )  ;   }  
@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . execute ( "create table user  ( "  +  "uid integer not null "  +  "name varchar not null" +  " ) " )  ;  h . execute ( "create table article  ( "  +  "aid integer not null "  +  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;  final int[] call =  { 0 0 }  ;   unicast processor <  integer >  up =  unicast processor . create (  )  ;  up . do on next ( new 
public static final void   (  exception e )  {  if  (    log  !  =  null )     log . warn ( "" e )  ;   }  
@ before public void   (  )  throws  exception  {  db = db rule . get jdbi (  )  ;  h = db . open (  )  ;  h . execute ( "create table foo  ( bar uuid ) " )  ;   }  
public void   (  request information info )  {  this . info = info ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test observer <  object >  to =  maybe . zip (  arrays . as list ( pp . single element (  )  pp . single element
public  data structure   (  )  {  return new  message status message (  )  ;   }  
public void   ( i2p socket manager .  disconnect listener lsnr )  {     connection manager . get message handler (  )  . add disconnect listener ( lsnr )  ;   }  
public void   ( boolean val )  {  if  ( val )     boolean options . add ( i2p tunnel server . prop   use   ssl )  ;  else    boolean options . remove ( i2p tunnel server . prop   use   ssl )  ;   }  
public void   (  )  {     is running = true ;  while  (    is running &&  !    manager . is shutdown (  )  )   {  try  {  handle inbound request (  )  ;   }  catch  (   runtime exception e )   {     log . log (  log . crit "b0rked in the tunnel handler" e )  ;   }   }  if  (    log . should log (  log . warn )  )     log . warn ( " done handling" )  ;     is running = false ;   }  
@ test ( expected =  test exception . class )  public void   (  )  {  perform test using with resource factory error ( true )  ;   }  
public   (  maybe source < t >  source  single source <  ?  extends t >  other )  {  this . source = source ;  this . other = other ;   }  
public void   ( int max jitter buffer size )  {  if  ( max jitter buffer size  <  =  0 )   {   logger . println ( id  +  " invalid max jitter buffer size "  +  max jitter buffer size +  " .   using default value " +  " of " +  default   max   jitter   buffer   size )  ;  max jitter buffer size = default   max   jitter   buffer   size ;   }  if  ( max jitter buffer size  <  min jitter buffer size )   {  this . max jitter buffer size = min jitter buffer size ;  return ;   }  this . max jitter buffer size = max jitter buffer size ;   }  
public void   (  string username )  throws  service exception  {   user user = get and check user ( username )  ;  user manager . delete user ( user )  ;  roster manager . delete roster ( server . createjid ( username null )  )  ;   }  
public  application artifact event   (  )  {  return event ;   }  
@ test public void   (  )  {   horror movie horror movie1 = new  horror movie (  )  ;   movie movie = new  movie (  )  ;   media media = new  media (  )  ;   horror movie horror movie2 = new  horror movie (  )  ;   observable <  movie >  o1 =  observable 
static void   ( sq lite database db int old version int new version )  {  try  {  db . execsql ( "drop table "  +   account . table   name )  ;   }  catch  (  sql exception e )   {   }  create account table ( db )  ;   }  
@ override protected void   (  observer <  ?  super u >  t )  {  source . subscribe ( new  buffer boundary supplier observer < t u b >  ( new  serialized observer < u >  ( t )  buffer supplier boundary supplier )  )  ;   }  
@ test public void   (  )  {   publish processor <  string >  pp1 =  publish processor . create (  )  ;   publish processor <  string >  pp2 =  publish processor . create (  )  ;   publish processor <  string >  pp3 =  publish processor . create (  )  ;  
public boolean   (  )  {  return b ;   }  
public static  string   (  tunnel controller group tcg int tunnel )  {   tunnel controller tun = get controller ( tcg tunnel )  ;  return tun  !  =  null  ?  tun . get name (  )  : null ;   }  
private void   (  )  {  try  {   inet address primary =  inet address . get by name ( primary address )  ;   inet address secondary =  inet address . get by name ( secondary address )  ;  if  ( primary  !  =  null && secondary  !  =  null )   {  stun server = new  stun server ( primary port primary secondary port secondary )  ;  stun server . start (  )  ;   }  else  {  set local enabled ( false )  ;   }   }  catch  (   socket exception e )   {   log . error ( " disabling stun server" e )  ;  set local enabled ( false )  ;   }  catch  (   unknown host exception e )   {   log . error ( " disabling stun server" e )  ;  set local enabled ( false )  ;   }   }  
public void   (  string roomname  localmuc room room )  {  rooms . put ( roomname room )  ;   group event dispatcher . add listener ( room )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish subject <  integer >  ps =  publish subject .
public void   (  string description )  throws  unauthorized exception  {  this . description = description ;   }  
public  key pair   (  )  {  if  (  ! initialized )  initialize ( default   strength  random source . get instance (  )  )  ;   key generator kg =  key generator . get instance (  )  ;   simple data structure[] keys = kg . generatepki keys (  )  ;   public key pub key =  (  public key ) keys[0] ;   private key priv key =  (  private key ) keys[1] ;   el gamal public key epub key = new  el gamal public key impl ( new  native big integer ( 1 pub key . get data (  )  )  elg params )  ;   el gamal private key epriv key = new  el gamal private key impl ( new  native big integer ( 1 priv key . get data (  )  )  elg params )  ;  return new  key pair ( epub key epriv key )  ;   }  
public  set <  string >    (  )  {  return  collections . unmodifiable set ( this . column label indices . key set (  )  )  ;   }  
 hash set <  string >    (  string serialized )  throws json exception  {   hash set <  string >  result = new  hash set <  string >  (  )  ;  if  (  !  text utils . is empty ( serialized )  )   {  json array arr = new json array ( serialized )  ;  for  ( int i = 0  len = arr . length (  )  ;  i  <  len ;  i +  +  )   {  result . add (  (  string ) arr . get ( i )  )  ;   }   }  return result ;   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer (  )  ;   completable . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  atomic integer . increment and get (  )  ;   }   }   )  . test (  )
public static byte[]   ( byte[] salt  string password int iters )  throws  sasl exception  {   mac mac = create sha1 hmac ( password . get bytes (  standard charsets . utf   8 )  )  ;  mac . update ( salt )  ;  mac . update ( new byte[] { 0 0 0 1 }  )  ;  byte[] result = mac . do final (  )  ;  byte[] previous = null ;  for  ( int i = 1 ;  i  <  iters ;  i +  +  )   {  mac . update ( previous  !  =  null  ?  previous : result )  ;  previous = mac . do final (  )  ;  for  ( int x = 0 ;  x  <  result . length ;  x +  +  )   {  result[x]^ = previous[x] ;   }   }  return result ;   }  
private static  string   (  string line  string old string  string new string boolean ignore case int[] count )  {  if  ( line  =  =  null )   {  return null ;   }   string lc line = ignore case  ?  line . to lower case (  )  : line ;   string lc old string = ignore case  ?  old string . to lower case (  )  : old string ;  int i = 0 ;  if  (  ( i = lc line . index of ( lc old string i )  )   >  =  0 )   {  int counter = 1 ;  char[] line2 = line . to char array (  )  ;  char[] new string2 = new string . to char array (  )  ;  int o length = old string . length (  )  ;   string builder buf = new  string builder ( line2 . length )  ;  buf . append ( line2 0 i )  . append ( new string2 )  ;  i +  = o length ;  int j = i ;  while  (  ( i = lc line . index of ( lc old string i )  )   >  0 )   {  counter +  +  ;  buf . append ( line2 j i  -  j )  . append ( new string2 )  ;  i +  = o length ;  j = i ;   }  buf . append ( line2 j line2 . length  -  j )  ;  count[0] = counter ;  return buf . to string (  )  ;   }  return line ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 5 )  . flat map iterable ( mapper )  . subscribe ( ts )  ;  ts . assert values ( 1 2 2 3 3 4 4 5 5 6 )  ;  ts . assert no e
private  long   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( " parameter at %d does not exist" pos )  )  ;   }  return null ;   }  if  ( obj instanceof java . util .  date )   {  return  (  ( java . util .  date ) obj )  . get time (  )  ;   }  else  {  throw new  illegal argument exception (  string . format ( " parameter at %d is not  date but %s" pos obj . get class (  )  )  )  ;   }   }  
@ override public void   (  )  {  subscriber . on complete (  )  ;   }  
public  list <  long >    (  )  {  synchronized  ( this )   {  if  (    message ids  !  =  null )  return new  array list <  long >  (    message ids )  ;  else return new  array list <  long >  (  )  ;   }   }  
public void   (  connection type type  certificate store configuration configuration boolean create if absent )  throws  certificate store config exception  {  if  ( type  =  =  null )   {  throw new  illegal argument exception ( " argument 'type' cannot be null . " )  ;   }  if  ( configuration  =  =  null )   {  throw new  illegal argument exception ( " argument 'configuration' cannot be null . " )  ;   }  final  certificate store configuration old config = type to trust store . get ( type )  ;  if  ( old config  =  =  null ||  ! old config . equals ( configuration )  )   {  if  (  ! trust stores . contains key ( configuration )  )   {  final  trust store store = new  trust store ( configuration create if absent )  ;  trust stores . put ( configuration store )  ;  store watcher . watch ( store )  ;   }  type to trust store . put ( type configuration )  ;  if  ( old config  !  =  null &&  ! type to trust store . contains value ( old config )  )   {  final  trust store store = trust stores . remove ( old config )  ;  if  ( store  !  =  null )   {  store watcher . unwatch ( store )  ;   }   }  final  connection manager impl connection manager =  (  (  connection manager impl ) xmpp server . get instance (  )  . get connection manager (  )  )  ;  for  (   connection listener connection listener : connection manager . get listeners ( type )  )   {  try  {  connection listener . set trust store configuration ( configuration )  ;   }  catch  (   runtime exception e )   {   log . warn ( " an exception occurred while trying to update the trust store configuration for connection type '"  +  type  +  "'" e )  ;   }   }   }   jive globals . set property ( type . get prefix (  )   +  "truststore" configuration . get file (  )  . get path (  )  )  ;   jive globals . set property ( type . get prefix (  )   +  "trustpass" new  string ( configuration . get password (  )  )  )  ;   }  
@ data provider ( name = " " )  public  object[][] bad version files (  )  {  return new  object[][] {  { "fastq - sanger / sanger   full   range   as   sanger - 63 . fastq"  fastq quality format .  illumina }   { "fastq - solexa / s   1   sequence . txt"
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic boolean run = new  atomic boolean (  )  ;   completable c = normal . completable . and then (  completable . from callable ( new  callable <  object >  (  )  {  @ override public  object call
void   ( int index  object o )  {  values . set ( index o )  ;   }  
@ override public void   (  account account )  {  final  intent intent = new  intent (  intent . action   view  email provider . get incoming settings uri ( account . get id (  )  )  )  ;  final  string account name = account . get display name (  )  ;  f
public void   (  )  {  interceptor manager . remove interceptor ( this )  ;  if  ( debug )   {   log . debug ( "destroy  callback on offline plugin . " )  ;   }   }  
public boolean   (  )  {   string sid = getsid (  )  ;  return  ( sid  !  =  null && 0  <  sid . length (  )  )   ?  true : false ;   }  
@ override public void   (  session data session data  element command )  {   element note = command . add element ( "note" )  ;   map <  string  list <  string >  >  data = session data . get data (  )  ;   string username ;  try  {  username = get ( dat
@ suppress warnings ( "unchecked" )    (  atomic reference <  publish subscriber < t >  >  current int buffer size )  {  this . subscribers = new  atomic reference <  inner subscriber < t > [] >  ( empty )  ;  this . current = current ;  this . should con
public   (  string k  host txt entry v )  {  key = k ;  value = v ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . concat map ( new  function <  integer  observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   integer v )  {  return null ;   }   }   )
@ override public void   (  )  {   subscription helper . cancel ( this )  ;   }  
@ override public void   (  disposable d )  {  this . u = d ;   }  
@ test public void   (  )  {  int num retries = 1 ;  int num failures = 2 ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   flowable <  string >  origin =  flowable . unsafe create ( new  func with errors ( num failures )  ) 
public void   (  )  throws  exception  {  int[] sizes =  { 16 24 32 }  ;  for  ( int j = 0 ;  j  <  sizes . length ;  j +  +  )   {  byte[] kb = new byte[sizes[j]] ;  byte[] pt = new byte[16] ;  int i ;  for  ( i = 0 ;  i  <  sizes[j] ;  i +  +  )  kb[i] =  ( byte ) i ;  for  ( i = 0 ;  i  <  16 ;  i +  +  )  pt[i] =  ( byte ) i ;   object key =  cryptix rijndael    algorithm . make key ( kb 16 )  ;  byte[] ct = new byte[16] ;   cryptix rijndael    algorithm . block encrypt ( pt ct 0 0 key 16 )  ;  byte[] cpt = new byte[16] ;   cryptix rijndael    algorithm . block decrypt ( ct cpt 0 0 key 16 )  ;  assert true (  data helper . eq ( pt cpt )  )  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0 )  ;   flowable . range ( 1 5 )  . concat map iterable ( mapper )  . subscribe ( ts )  ;  ts . assert no values (  )  ;  ts . assert no errors (  )  ;
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . combine latest ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] v )  {  return 1 ;   }   }   128  (  observable <  obje
public boolean   (  string hostname  destination d  properties options )  {  return false ;   }  
public boolean   (  )  {  final  string property name = type . get prefix (  )   +  "certificate . accept - selfsigned" ;  final boolean default value = false ;  if  ( type . get fallback (  )   =  =  null )   {  return  jive globals . get boolean property ( property name default value )  ;   }  else  {  return  jive globals . get boolean property ( property name get connection listener ( type . get fallback (  )  )  . accept self signed certificates (  )  )  ;   }   }  
public static  available plugin   (  element plugin )  {   string plugin name = plugin . attribute value ( "name" )  ;   version latest version = null ;   string latest version value = plugin . attribute value ( "latest" )  ;  if  ( latest version value  !  =  null &&  ! latest version value . is empty (  )  )   {  latest version = new  version ( latest version value )  ;   }  url icon = null ;   string icon value = plugin . attribute value ( "icon" )  ;  if  ( icon value  !  =  null &&  ! icon value . is empty (  )  )   {  try  {  icon = new url ( icon value )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to create icon url from value ' {  } ' for plugin  {  }  . " icon value plugin name e )  ;   }   }  url readme = null ;   string readme value = plugin . attribute value ( "readme" )  ;  if  ( readme value  !  =  null &&  ! readme value . is empty (  )  )   {  try  {  readme = new url ( readme value )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to create readme url from value ' {  } ' for plugin  {  }  . " readme value plugin name e )  ;   }   }  url changelog = null ;   string changelog value = plugin . attribute value ( "changelog" )  ;  if  ( changelog value  !  =  null &&  ! changelog value . is empty (  )  )   {  try  {  changelog = new url ( changelog value )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to create changelog url from value ' {  } ' for plugin  {  }  . " changelog value plugin name e )  ;   }   }  url download url = null ;   string download url value = plugin . attribute value ( "url" )  ;  if  ( download url value  !  =  null &&  ! download url value . is empty (  )  )   {  try  {  download url = new url ( download url value )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to create download url from value ' {  } ' for plugin  {  }  . " download url value plugin name e )  ;   }   }   string license = plugin . attribute value ( "license type" )  ;   string description = plugin . attribute value ( "description" )  ;   string author = plugin . attribute value ( "author" )  ;   version min server version = null ;   string min server version value = plugin . attribute value ( "min server version" )  ;  if  ( min server version value  !  =  null &&  ! min server version value . is empty (  )  )   {  min server version = new  version ( min server version value )  ;   }   version prior to server version = null ;   string prior to server version value = plugin . attribute value ( "prior to server version" )  ;  if  ( prior to server version value  !  =  null &&  ! prior to server version value . is empty (  )  )   {  prior to server version = new  version ( prior to server version value )  ;   }   java spec version min java version = null ;   string min java version value = plugin . attribute value ( "min java version" )  ;  if  ( min java version value  !  =  null &&  ! min java version value . is empty (  )  )   {  min java version = new  java spec version ( min java version value )  ;   }  long file size =  - 1 ;   string file size value = plugin . attribute value ( "file size" )  ;  if  ( file size value  !  =  null &&  ! file size value . is empty (  )  )   {  file size =  long . parse long ( file size value )  ;   }   string canonical = download url value  !  =  null  ?  download url value . substring ( download url value . last index of ( ' / ' )   +  1 download url value . last index of ( ' . ' )  )  : null ;  return new  available plugin ( plugin name canonical description latest version author icon changelog readme license min server version prior to server version min java version download url file size )  ;   }  
@ override public boolean   (  )  {  return get (  )   =  =  0 ;   }  
  (  context context  string name )  {  super ( context name null database   version )  ;  m context = context ;   }  
@ test public void   (  )  {   observable . concat delay error (  observable . just (  observable . just ( 1 )   observable . just ( 2 )   observable . just ( 3 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )   observ
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . from future ( new  future task <  object >  ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return null ;   }   }   ) 
@ override protected boolean   (  element doc )  {  if  ( "db" . equals ( doc . get namespace prefix (  )  )  && "result" . equals ( doc . get name (  )  )  )   {  if  (  !  (  (  local incoming server session ) session )  . validate subsequent domain ( d
@ override public  flowable <  object >    (  )  throws  exception  {  if  (  +  + count  >  1 )   {  return  flowable . never (  )  ;   }  return  ( new  flowable <  object >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super
public  string   (  )  {  return    base logfilename ;   }  
public int   (  job l  job r )  {  if  ( l . equals ( r )  )  return 0 ;  long ld = l . get timing (  )  . get start after (  )   -  r . get timing (  )  . get start after (  )  ;  if  ( ld  <  0 )  return  - 1 ;  if  ( ld  >  0 )  return 1 ;  ld = l . get job id (  )   -  r . get job id (  )  ;  if  ( ld  <  0 )  return  - 1 ;  if  ( ld  >  0 )  return 1 ;  return l . hash code (  )   -  r . hash code (  )  ;   }  
public void   (  )  throws io exception  {  for  (   torrent file tf :    torrent files )   {  try  {  tf . closeraf (  )  ;   }  catch  (  io exception ioe )   {     log . error ( " error closing "  +  tf ioe )  ;   }   }  changed = false ;   }  
public synchronized void   (  )  throws io exception  {  if  (    state  !  =  initialized )  return ;  change state ( starting )  ;  synchronized  (    handlers )   {     handlers . clear (  )  ;   }  load keys (  )  ;  try  {  open socket (  )  ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . error )  )     log . error ( " error starting sam bridge on "  +   (    listen host  =  =  null  ?  "0 . 0 . 0 . 0" :    listen host )   +  ":" +     listen port e )  ;  change state ( start   failed e )  ;  throw e ;   }  start thread (  )  ;   }  
public  list <  destination >    (  string hostname  properties lookup options  list <  properties >  stored options )  {   properties props = stored options  !  =  null  ?  new  properties (  )  : null ;   destination d = lookup ( hostname lookup options props )  ;   list <  destination >  rv ;  if  ( d  !  =  null )   {  rv =  collections . singleton list ( d )  ;  if  ( stored options  !  =  null )  stored options . add ( props . is empty (  )   ?  null : props )  ;   }  else  {  rv = null ;   }  return rv ;   }  
public void   (  string parameter name  reader reader )  throws sql exception  {  cstmt . set clob ( parameter name reader )  ;   }  
public  set <  hash >    (  )  {   object counter <  hash >  lc = new  object counter <  hash >  (  )  ;  int tunnel count = count tunnels per peer ( lc )  ;   set <  hash >  rv = new  hash set <  hash >  (  )  ;  if  ( tunnel count  >  =  4 &&    context . router (  )  . get uptime (  )   >  10 * 60 * 1000 )   {  int max =    context . get property ( "router . max tunnel percentage" default   max   pct   tunnels )  ;  for  (   hash h : lc . objects (  )  )   {  if  ( lc . count ( h )   >  0 &&  ( lc . count ( h )   +  1 )  * 100  /   ( tunnel count  +  1 )   >  max )  rv . add ( h )  ;   }   }  return rv ;   }  
public boolean   ( int tunnel )  {  return    helper . get proxy auth ( tunnel )   !  =  "false" ;   }  
public static  string   ( final byte[][] barcodes )  {  return byte array to string ( barcodes barcode   delimiter )  ;   }  
@ test public void   (  )  throws  exception  {  final  document web xml =  web xml utils . as document ( new  file (  web xml utils test . class . get resource ( " / org / jivesoftware / util / test - web . xml" )  . touri (  )  )  )  ;  final  string fi
@ override public iq handler info   (  )  {  return info ;   }  
  (  string value )  {  m value = value ;   }  
@ test public void   (  )  throws  interrupted exception  {   observable <  string >  obs =  observable . just ( "one" "null" "two" "three" "four" )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;   in order in order = in order 
private void   ( jid from jid to  string body  string file name  string type )  {   log . info ( " rayo component send message "  +  from  +  " " +  to +  " " +  body +  " " +  file name )  ;  int port =  http bind manager . get instance (  )  . get http bind unsecure port (  )  ;   message packet = new  message (  )  ;  packet . set to ( to )  ;  packet . set from ( from )  ;  packet . set type ( "chat" . equals ( type )   ?   message .  type . chat :  message .  type . groupchat )  ;  if  ( file name  !  =  null )   {   string url = "http: /  / "  +  get domain (  )   +  ":" +  port +  " / rayo / recordings / " +  file name ;  packet . set thread ( url )  ;  body = body  +  " "  +  url ;   }  packet . set body ( body )  ;  send packet ( packet )  ;   }  
private static  < t >  observable converter < a < t  ?  >  b < t >  >    (  )  {  return new  observable converter < a < t  ?  >  b < t >  >  (  )  {  @ override public b < t >  apply (   observable < a < t  ?  >  >  a )  {  return new b < t >  (  )  {   }   ;   }   }   ;   }  
@ test public void   (  )  {  final  interval list interval list = new  interval list ( header )  ;  final vcf file reader reader = get reader ( ceu   trios   snps   vcf )  ;  final  iterator <  variant context >  iterator = new  by interval list variant 
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {  final jaxb element jaxb element = xml transformer . transform (  content transformer test . class . get resource as stream ( xml   version )  )  ;  assert true ( jaxb element . get declare
public void   (  )  {  if  ( in  !  =  null )   {  try  {  in . close (  )  ;   }  catch  (  io exception e )   {   }   }   }  
void   ( double[] values )  {  this . values = values ;   }  
public  map <  string  sorted set <  string >  >    (  )  {   map <  string  sorted set <  string >  >  groups = new  hash map <  string  sorted set <  string >  >  ( 32 )  ;  for  (   frequency stat stat :    frequency stats . values (  )  )   {   string gname = stat . get group name (  )  ;   sorted set <  string >  names = groups . get ( gname )  ;  if  ( names  =  =  null )   {  names = new  tree set <  string >  (  collator . get instance (  )  )  ;  groups . put ( gname names )  ;   }  names . add ( stat . get name (  )  )  ;   }  for  (   rate stat stat :    rate stats . values (  )  )   {   string gname = stat . get group name (  )  ;   sorted set <  string >  names = groups . get ( gname )  ;  if  ( names  =  =  null )   {  names = new  tree set <  string >  (  collator . get instance (  )  )  ;  groups . put ( gname names )  ;   }  names . add ( stat . get name (  )  )  ;   }  return groups ;   }  
public static void   (  context context  setup data fragment setup data )  {  final  account account = setup data . get account (  )  ;  final  credential cred = account . m host auth send . m credential ;  if  ( cred  !  =  null )   {  if  ( cred . is saved (  )  )   {  cred . update ( context cred . to content values (  )  )  ;   }  else  {  cred . save ( context )  ;  account . m host auth send . m credential key = cred . m id ;   }   }  account . m host auth send . update ( context account . m host auth send . to content values (  )  )  ;   account backup restore . backup ( context )  ;   }  
@ override public void   (  )  {  while  (  ! executor service . is shutdown (  )  )   {   path last changed certificate chain = null ;  long last change certificate chain = 0 ;   path last changed private key = null ;  long last change private key = 0 ; 
public   (  flowable < t >  source long n )  {  super ( source )  ;  this . n = n ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public  collection <  conversation >    ( int conversation timeout )  {  throw new  unsupported operation exception ( "mam - muc cannot perform this operation" )  ;   }  
public void   ( boolean prompt credentials )  {  this . prompt credentials = prompt credentials ;   }  
private int   (  )  {  int count = 0 ;  synchronized  (    lock )   {  try  {  for  (   file f :    files )   {  count = read blocklist file ( f count )  ;   }   }  catch  (   out of memory error oom )   {     log . log (  log . crit "oom processing the blocklist" )  ;  disable (  )  ;  return 0 ;   }   }  for  (   hash peer :    peer blocklist . key set (  )  )   {   string reason ;   string comment =    peer blocklist . get ( peer )  ;  if  ( comment  !  =  null )  reason =    x ( " banned by router hash:  { 0 } " )  ;  else reason =    x ( " banned by router hash" )  ;     context . banlist (  )  . banlist router forever ( peer reason comment )  ;   }     peer blocklist . clear (  )  ;  return count ;   }  
public   ( i2p app context context  file file )  {     context = context ;     file = file ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . concat map iterable ( new  function <  integer  iterable <  object >  >  (  )  {  @ override public  iterable <  object >  apply (   integer v )  {  return null ;   }   
@ test public void   (  )  {   observable <  integer >  source =  observable . range ( 1 5 )  ;   observable <  integer >  delayed = source . delay ( 500l  time unit . milliseconds scheduler )  ;  delayed = delayed . do on each ( new  consumer <  notifica
private  message selector   (  )  {  return new  test message selector (    test message key    timeout ms  +  get context (  )  . clock (  )  . now (  )  )  ;   }  
public int   (  )  {  return    networkid ;   }  
@ test public void   (  )  throws io exception  {  final  file vcf file = new  file ( test   data   dir "ceu trio   plus   fake . vcf" )  ;  final  file vcf index file = new  file ( test   data   dir "ceu trio   plus   fake . vcf . idx" )  ;  if  ( vcf fi
public static  call filter   (  string username  string numa  string numb  string call type  date from date  date upto date )  {   array list <  string >  conditions = new  array list <  string >  ( 10 )  ;   array list <  string >  values = new  array list <  string >  ( 10 )  ;  if  ( username  !  =  null &&  ! username . trim (  )  . equals ( "" )  )   {  conditions . add ( " username  =   ?  " )  ;  values . add ( username . trim (  )  )  ;   }  if  ( numa  !  =  null &&  ! numa . trim (  )  . equals ( "" )  )   {  conditions . add ( " address from  =   ?  " )  ;  values . add ( numa . trim (  )  )  ;   }  if  ( numb  !  =  null &&  ! numb . trim (  )  . equals ( "" )  )   {  conditions . add ( " address to  =   ?  " )  ;  values . add ( numb . trim (  )  )  ;   }  if  ( from date  !  =  null )   {  conditions . add ( " datetime  >  =   ?  " )  ;  values . add (  string . value of ( from date . get time (  )  )  )  ;   }  if  ( upto date  !  =  null )   {  conditions . add ( " datetime  <  =   ?  " )  ;  values . add (  string . value of ( upto date . get time (  )  )  )  ;   }  if  ( call type  !  =  null &&  ! call type . trim (  )  . equals ( "" )  &&  ! call type . trim (  )  . equals ( "all" )  )   {  conditions . add ( " calltype  =   ?  " )  ;  values . add ( call type . trim (  )  )  ;   }   string builder str = new  string builder (  )  ;  for  (   string aux : conditions )   {  if  ( str . length (  )   >  0 )  str . append ( "and" )  ;  str . append ( aux )  ;   }  return new  call filter ( str . to string (  )  values )  ;   }  
public long   ( byte encrypted[] )  {   tunnel data message msg = new  tunnel data message (    context )  ;  msg . set data ( encrypted )  ;  msg . set tunnel id (    config . get config ( 0 )  . get send tunnel (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "received encrypted  sending out "  +     config  +  ": " +  msg )  ;   router info ri =    next hop cache ;  if  ( ri  =  =  null )  ri =    context . net db (  )  . lookup router info locally (    config . get peer ( 1 )  )  ;  if  ( ri  !  =  null )   {     next hop cache = ri ;  send ( msg ri )  ;  return msg . get unique id (  )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( "lookup of "  +     config . get peer ( 1 )   +  " required for " +  msg )  ;     context . net db (  )  . lookup router info (    config . get peer ( 1 )  new  send job (    context msg )  new  failed job (    context )  max   lookup   time )  ;  return  - 1 ;   }   }  
public   (  transport type type  string description  string classname  component manager component manager  transport session router session router )  {  this . description = description ;  this . type = type ;  this . name of class = classname ;  this . component manager = component manager ;  this . session router = session router ;  enabled =  jive globals . get boolean property ( "plugin . gateway . "  +  this . type . to string (  )   +  " . enabled" false )  ;  sub domain =  jive globals . get property ( "plugin . gateway . "  +  this . type . to string (  )   +  " . subdomain" this . type . to string (  )  )  ;   }  
private   (  )  {  throw new  assertion error (  )  ;   }  
private static jaxb context   (  )  {  try  {  return jaxb context . new instance ( httpx   package  httpx marshaller utility . class . get class loader (  )  )  ;   }  catch  (  jaxb exception ex )   {  throw new  httpx exception ( " error creating jaxb context for httpx" ex )  ;   }   }  
public  string   ( int tunnel )  {  return    helper . get tunnel type ( tunnel )  ;   }  
private boolean   ( final  string sequence name )  {  return  ( sequence   names  !  =  null )  &&  (  ! sequence   names . is empty (  )  )  &&  (  ! sequence   names . contains ( sequence name )  )  ;   }  
@ test public void   (  )  {   immutable list <  integer >  list = db rule . get shared handle (  )  . create query ( "select int value from something" )  . collect into ( new  generic type <  immutable list <  integer >  >  (  )  {   }   )  ;  assert tha
@ test public void   (  )  {  fetch from ( "http: /  / "  +  stats   host  +  ":81" true )  ;   }  
@ register join row mapper (  {  user . class  article . class }  )  @ sql query ( "select * from user natural join author natural join article" )   stream <  join row >    (  )  ;  
public static  list <  string >    (  )  {  if  ( openfire properties  =  =  null )   {  load openfire properties (  )  ;   }  return openfire properties . get all property names (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay ( 1 null )  ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . single ( 100 )  . test (  )  . assert result ( 1 )  ;   observable . empty (  )  . single ( 100 )  . test (  )  . assert result ( 100 )  ;   }  
@ override public void   (  )  {  first . cancel (  )  ;  second . cancel (  )  ;  if  ( get and increment (  )   =  =  0 )   {  first . clear (  )  ;  second . clear (  )  ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to =  test observer . create (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;  to . on complete (  )  ;  try  {  to . assert values only (  )  ;  fail (  )  ;   }  catch  (   assertion
@ override public void   ( t value )  {  if  (  ! done )   {  t v = this . value ;  if  ( v  =  =  null )   {  this . value = value ;   }  else  {  try  {  this . value =  object helper . require non null ( reducer . apply ( v value )  " the reducer retur
@ test public void   (  )  {  assert not null ( regex list . find ( match   against )  )  ;   }  
public void   (  string s )  {  if  ( s  !  =  null )   {  try  {     config . set total day (  integer . parse int ( s . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
@ test ( data provider = "divide method fail test cases" expected exceptions =  runtime exception . class )  public void   ( final double[] lhs final double[] rhs )  {  divide ( lhs rhs )  ;   }  
@ override public final int   ( int mode )  {  return mode & sync ;   }  
public  nio socket acceptor   (  )  {  if  ( connection acceptor  =  =  null ||  !  ( connection acceptor instanceof mina connection acceptor )  )   {  return null ;   }  return  (  ( mina connection acceptor ) connection acceptor )  . get socket acceptor (  )  ;   }  
@ override public void   (  bundle out state )  {  super . on save instance state ( out state )  ;  out state . put boolean ( state   key   loaded m loaded )  ;   }  
@ override public void   ( t t )  {  final  array deque <  unicast subject < t >  >  ws = windows ;  long i = index ;  long s = skip ;  if  ( i % s  =  =  0 &&  ! cancelled )   {  wip . get and increment (  )  ;   unicast subject < t >  w =  unicast subje
private void   ( boolean dispose eagerly )  {  final  runnable unsubscribe = mock (  runnable . class )  ;   callable <  disposable >  resource factory = new  callable <  disposable >  (  )  {  @ override public  disposable call (  )  {  return  disposables . from runnable ( unsubscribe )  ;   }   }   ;   function <  disposable  observable <  integer >  >  observable factory = new  function <  disposable  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   disposable subscription )  {  return  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integer >  t1 )  {  throw new  test exception (  )  ;   }   }   )  ;   }   }   ;  try  {   observable . using ( resource factory observable factory dispose subscription dispose eagerly )  . blocking last (  )  ;  fail ( " should throw a  test exception when the observable factory throws it" )  ;   }  catch  (   test exception e )   {  verify ( unsubscribe times ( 1 )  )  . run (  )  ;   }   }  
@ override public  string   (  )  {  return " group admin removed" ;   }  
@ test public void   (  )  throws  exception  {   private key private key = new  private key (  )  ;  private key . to string (  )  ;  exception . expect (  data format exception . class )  ;  exception . expect message ( " no data to write out" )  ;  pri
protected boolean   (  string opcode  properties props )  {   string dest = "bug ! " ;  try  {  if  ( opcode . equals ( "create" )  )   {  if  (  ( raw session  !  =  null )  ||  ( datagram session  !  =  null )  ||  ( stream session  !  =  null )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " trying to create a session  but one still exists" )  ;  return write string ( session   error " session already exists" )  ;   }  if  ( props . is empty (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " no parameters specified in session create message" )  ;  return write string ( session   error " no parameters for session create" )  ;   }  dest =  (  string ) props . remove ( "destination" )  ;  if  ( dest  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( "session destination parameter not specified" )  ;  return write string ( session   error "destination not specified" )  ;   }   string dest keystream = null ;  if  ( dest . equals ( "transient" )  )   {     log . debug ( "transient destination requested" )  ;   byte array output stream priv = new  byte array output stream ( 640 )  ;  sam utils . gen random key ( priv null )  ;  dest keystream =  base64 . encode ( priv . to byte array (  )  )  ;   }  else  {  dest keystream = bridge . get keystream ( dest )  ;  if  ( dest keystream  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " custom destination specified ["  +  dest  +  "] but it isn't known  creating a new one" )  ;   byte array output stream baos = new  byte array output stream ( 640 )  ;  sam utils . gen random key ( baos null )  ;  dest keystream =  base64 . encode ( baos . to byte array (  )  )  ;  bridge . add keystream ( dest dest keystream )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " custom destination specified ["  +  dest  +  "] and it is already known" )  ;   }   }   string style =  (  string ) props . remove ( "style" )  ;  if  ( style  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( "session style parameter not specified" )  ;  return write string ( session   error " no session style specified" )  ;   }  props . set property ( i2p client . prop   reliability i2p client . prop   reliability   none )  ;  if  ( style . equals ( "raw" )  )   {  raw session = new sam raw session ( dest keystream props this )  ;  raw session . start (  )  ;   }  else if  ( style . equals ( "datagram" )  )   {  datagram session = new sam datagram session ( dest keystream props this )  ;  datagram session . start (  )  ;   }  else if  ( style . equals ( "stream" )  )   {   string dir =  (  string ) props . remove ( "direction" )  ;  if  ( dir  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " no direction parameter in stream session  defaulting to both" )  ;  dir = "both" ;   }  else if  (  ! dir . equals ( "create" )  &&  ! dir . equals ( "receive" )  &&  ! dir . equals ( "both" )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " unknown direction parameter value: ["  +  dir  +  "]" )  ;  return write string ( session   error " unknown direction parameter" )  ;   }  stream session = newsam stream session ( dest keystream dir props )  ;  stream session . start (  )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " unrecognized session style: \""  +  style  +  "\"" )  ;  return write string ( session   error " unrecognized session style" )  ;   }  return write string ( "session status result = ok destination = "  +  dest  +  "\n" )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " unrecognized session message opcode: \""  +  opcode  +  "\"" )  ;  return write string ( session   error " unrecognized opcode" )  ;   }   }  catch  (   data format exception e )   {     log . error ( " invalid sam destination specified" e )  ;  return write string ( "session status result = invalid   key" e . get message (  )  )  ;   }  catch  (  i2p session exception e )   {     log . error ( " failed to start sam session" e )  ;  return write string ( session   error e . get message (  )  )  ;   }  catch  (  sam exception e )   {     log . error ( " failed to start sam session" e )  ;  return write string ( session   error e . get message (  )  )  ;   }  catch  (  io exception e )   {     log . error ( " failed to start sam session" e )  ;  return write string ( session   error e . get message (  )  )  ;   }   }  
public static void   (  test subscriber <  ?  >  ts int index  class <  ?  extends  throwable >  clazz  string message )  {   throwable ex = ts . errors (  )  . get ( 0 )  ;  if  ( ex instanceof  composite exception )   {   composite exception ce =  (  composite exception ) ex ;   list <  throwable >  cel = ce . get exceptions (  )  ;  assert true ( cel . get ( index )  . to string (  )  clazz . is instance ( cel . get ( index )  )  )  ;  assert equals ( message cel . get ( index )  . get message (  )  )  ;   }  else  {  fail ( ex . to string (  )   +  ": not a  composite exception" )  ;   }   }  
@ test ( data provider = "vcfs to fingerprint" )  void   (  file file  file genotypes )  throws io exception  {  tester ( false file genotypes )  ;   }  
@ override public void   (  bundle saved instance state )  {  super . on activity created ( saved instance state )  ;  final  view view = get view (  )  ;  final  setup data fragment setup data =  (  (  setup data fragment .  setup data container ) get ac
@ override public void   (  throwable t )  {  parent . on error ( t )  ;   }  
@ override public  completable source   (  )  {  return source ;   }  
public static  row mapper factory   (  class <  ?  >  type  string prefix )  {  return  row mapper factory . of ( type  bean mapper . of ( type prefix )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   new  function <  integer  object >  (  )  
@ override public  object   (  )  throws  clone not supported exception  {  return super . clone (  )  ;   }  
@ test public void   (  )  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  @ suppress warnings ( "unch
public static void   (  string[] args )  {   getopt g = new  getopt ( " persistent data store" args "i:o:c:" )  ;   string in =  system . get property ( "user . home" )   +  " /  . i2p" ;   string out = "net db" ;  int count = 200 ;  boolean error = false ;  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 'i': in = g . get optarg (  )  ;  break ;  case 'o': out = g . get optarg (  )  ;  break ;  case 'c':  string scount = g . get optarg (  )  ;  try  {  count =  integer . parse int ( scount )  ;   }  catch  (  number format exception nfe )   {  error = true ;   }  break ;  case ' ? ': case ':': default : error = true ;   }   }  if  ( error )   {  usage (  )  ;   system . exit ( 1 )  ;   }   properties props = new  properties (  )  ;  props . set property (  geoip . prop   geoip   dir  system . get property ( "user . dir" )   +  " / installer / resources" )  ;   geoip geoip = new  geoip ( new i2p app context ( props )  )  ;   file conf dir = new  file ( in )  ;   file db dir = new  file ( conf dir "net db" )  ;  if  (  ! db dir . exists (  )  )   {   system . out . println ( " netdb directory "  +  db dir  +  " does not exist" )  ;   system . exit ( 1 )  ;   }   file my file = new  file ( conf dir "router . info" )  ;   file to dir = new  file ( out )  ;  to dir . mkdirs (  )  ;   input stream fis = null ;   hash me = null ;  try  {  fis = new  buffered input stream ( new  file input stream ( my file )  )  ;   router info ri = new  router info (  )  ;  ri . read bytes ( fis true )  ;  me = ri . get identity (  )  . get hash (  )  ;   }  catch  ( io exception e )   {   }  catch  (  data format exception e )   {   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  ( io exception ioe )   {   }   }  int router count = 0 ;   list <  file >  to read = new  array list <  file >  ( 2048 )  ;  for  ( int j = 0 ;  j  <   base64 . alphabet   i2p . length (  )  ;  j +  +  )   {   file subdir = new  file ( db dir  persistent data store . dir   prefix  +   base64 . alphabet   i2p . char at ( j )  )  ;   file[] files = subdir . list files (  persistent data store . ri   filter )  ;  if  ( files  =  =  null )  continue ;  router count +  = files . length ;  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {  to read . add ( files[i] )  ;   }   }  if  ( to read . is empty (  )  )   {   system . out . println ( " no files to copy in "  +  db dir )  ;   system . exit ( 1 )  ;   }   collections . shuffle ( to read )  ;  int copied = 0 ;  long too old =  system . current time millis (  )   -  7 * 24 * 60* 60* 1000l ;   map <  string  string >  ip map = new  hash map <  string  string >  ( count )  ;  for  (  file file : to read )   {  if  ( copied  >  =  count )  break ;   hash key =  persistent data store . get router info hash ( file . get name (  )  )  ;  if  ( key  =  =  null )   {   system . out . println ( " skipping bad "  +  file )  ;  continue ;   }  if  ( key . equals ( me )  )   {   system . out . println ( " skipping my ri" )  ;  continue ;   }  fis = null ;  try  {  fis = new  buffered input stream ( new  file input stream ( file )  )  ;   router info ri = new  router info (  )  ;  ri . read bytes ( fis true )  ;  try  {  fis . close (  )  ;   }  catch  ( io exception ioe )   {   }  fis = null ;  if  ( ri . get published (  )   <  too old )   {   system . out . println ( " skipping too old "  +  key )  ;  continue ;   }  if  ( ri . get capabilities (  )  . contains ( "u" )  )   {   system . out . println ( " skipping unreachable "  +  key )  ;  continue ;   }  if  ( ri . get capabilities (  )  . contains ( "k" )  )   {   system . out . println ( " skipping slow "  +  key )  ;  continue ;   }   collection <  router address >  addrs = ri . get addresses (  )  ;  if  ( addrs . is empty (  )  )   {   system . out . println ( " skipping hidden "  +  key )  ;  continue ;   }  boolean has intro = false ;  boolean hasi pv4 = false ;  boolean dupip = false ;  for  (  router address addr : addrs )   {  if  ( "ssu" . equals ( addr . get transport style (  )  )  && addr . get option ( "ihost0" )   !  =  null )   {  has intro = true ;  break ;   }   string host = addr . get host (  )  ;  if  ( host  !  =  null && host . contains ( " . " )  )   {  hasi pv4 = true ;  geoip . add ( host )  ;   string old = ip map . put ( host file . get name (  )  )  ;  if  ( old  !  =  null &&  ! old . equals ( file . get name (  )  )  )   {  dupip = true ;  break ;   }   }   }  if  ( dupip )   {   system . out . println ( " skipping dup ip "  +  key )  ;  continue ;   }  if  ( has intro )   {   system . out . println ( " skipping introduced "  +  key )  ;  continue ;   }  if  (  ! hasi pv4 )   {   system . out . println ( " skipping i pv6 - only "  +  key )  ;  continue ;   }   file to file = new  file ( to dir file . get name (  )  )  ;  boolean ok =  file util . copy ( file to file true true )  ;  if  ( ok )  copied +  +  ;  else  system . out . println ( " failed copy of "  +  file  +  " to " +  to dir )  ;   }  catch  ( io exception e )   {   system . out . println ( " skipping bad "  +  file )  ;   }  catch  (  data format exception e )   {   system . out . println ( " skipping bad "  +  file )  ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  ( io exception ioe )   {   }   }   }  if  ( copied  >  0 )   {  geoip . blocking lookup (  )  ;  for  (  map .  entry <  string  string >  e : ip map . entry set (  )  )   {   string co = geoip . get ( e . get key (  )  )  ;  if  ( co  !  =  null )   {  if  (  bad countries . contains ( co )  )   {   string name = e . get value (  )  ;   file to file = new  file ( to dir name )  ;  if  ( to file . delete (  )  )   {   string full = geoip . full name ( co )  ;  if  ( full  =  =  null )  full = co ;   system . out . println ( " skipping "  +  full  +  ": " +  name )  ;  copied -  -  ;   }   }   }   }   }  if  ( copied  >  0 )   {   system . out . println ( " copied "  +  copied  +  " router info files to " +  to dir )  ;   }  else  {   system . out . println ( " failed to copy any files to "  +  to dir )  ;   system . exit ( 1 )  ;   }   }  
@ inject public   (  optional <  metrics service >  metrics service )  {  local datastore manager = new eh cache datastore manager ( metrics service )  ;  distributed managers = new  hash map <  >  (  )  ;   }  
private  mailbox   ( final long account id final int mailbox type )  {   mailbox mailbox =  mailbox . restore mailbox of type ( get context (  )  account id mailbox type )  ;  if  ( mailbox  =  =  null )   {  mailbox = create mailbox ( account id mailbox type )  ;   }  return mailbox ;   }  
@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  int fetch size =  (  (  fetch size ) annotation )  . value (  )  ;  return stmt  -  >   (  (  query ) stmt )  . set fetch size ( fetch size )  ;  
@ test public void   (  )  {   flowable <  string >  obs =  flowable . just ( "one" "two" "three" )  ;   iterator <  string >  it = obs . blocking iterable (  )  . iterator (  )  ;  assert equals ( true it . has next (  )  )  ;  assert equals ( "one" it .
@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public   (  )  {   jive globals . migrate property ( property   adminprovider   classname )  ;   jive globals . migrate property ( property   userprovider   classname )  ;  admin provider = instantiate provider ( property   adminprovider   classname )  ;  user provider = instantiate provider ( property   userprovider   classname )  ;   }  
public static void   ( final  string[] args )  {  new  mark duplicates (  )  . instance main with exit ( args )  ;   }  
public void   ( ssdp packet packet )  {  get device data (  )  . setssdp packet ( packet )  ;   }  
public static boolean   (  component c )  {  if  ( c . has focus (  )  )   {  return true ;   }  else  {  if  ( c instanceof  container )   {   container cont =  (  container ) c ;  int n = cont . get component count (  )  ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {   component child = cont . get component ( i )  ;  if  ( is ancestor of focused component ( child )  )  return true ;   }   }   }  return false ;   }  
private static  < t >  single converter < a < t  ?  >  b < t >  >    (  )  {  return new  single converter < a < t  ?  >  b < t >  >  (  )  {  @ override public b < t >  apply (   single < a < t  ?  >  >  a )  {  return new b < t >  (  )  {   }   ;   }   }   ;   }  
@ test public void   (  )  throws  exception  {  final  string expected one = "expected one"  expected two = "expected two" ;  final  event listener <  test event  string >  listener = e  -  >   {  switch  ( e . type (  )  )   {  case one: if  ( event fir
public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write safeutf ( out local )  ;   externalizable util . get instance (  )  . write safeutf ( out remote )  ;   }  
private static  date   (  string date text )  {  boolean useutc = false ;  if  ( date text . ends with ( "z" )  )   {  useutc = true ;   }   date date = new  date (  )  ;  try  {  if  ( useutc )   {  ldap date format . set time zone (  time zone . get time zone ( "utc" )  )  ;   }  else  {  ldap date format . set time zone (  time zone . get default (  )  )  ;   }  date = ldap date format . parse ( date text )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  return date ;   }  
@ test public void   (  )  throws  exception  {   class loader class loader =  thread . current thread (  )  . get context class loader (  )  ;  final  atomic integer load count = new  atomic integer ( 0 )  ;   thread . current thread (  )  . set context 
final void   (  node n )  {  set ( n )  ;   }  
@ benchmark public void   (  blackhole bh )  {  flow flat map maybe as flow1 . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ override public void   (  )  {  co . on complete (  )  ;   }  
public synchronized void   ( boolean is alive )  {     alive = is alive ;  if  ( is alive )   {  long delay =    context . random (  )  . next int ( 2 * test   frequency )  ;  reschedule ( delay )  ;   }  else  {  cancel (  )  ;   }   }  
public   (  router context context int port )  {     ctx = context ;     log = context . log manager (  )  . get log (  client manager . class )  ;     listeners = new  array list <  client listener runner >  (  )  ;     runners = new  concurrent hash map <  destination  client connection runner >  (  )  ;     runners by hash = new  concurrent hash map <  hash  client connection runner >  (  )  ;     pending runners = new  hash set <  client connection runner >  (  )  ;     runner session ids = new  hash set <  session id >  (  )  ;     port = port ;     client timestamper = new  client timestamper (  )  ;     ctx . stat manager (  )  . create rate stat ( "client . request lease set success" " how frequently the router requests successfully a new lease set ? " " client messages" new long[] { 60 * 60 * 1000 }  )  ;     ctx . stat manager (  )  . create rate stat ( "client . request lease set timeout" " how frequently the router requests a new lease set but gets no reply ? " " client messages" new long[] { 60 * 60 * 1000 }  )  ;     ctx . stat manager (  )  . create rate stat ( "client . request lease set dropped" " how frequently the router requests a new lease set but the client drops ? " " client messages" new long[] { 60 * 60 * 1000 }  )  ;   }  
public void   (  element doc )  {   server dialback . verify received key ( doc get connection (  )  )  ;   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  maybe subject <  integer >  cs =  maybe subject . create (  )  ;   test observer <  integer >  to = ps . merge with ( cs )  . test (  )  ;  a
@ override public  element   (  )  {  return null ;   }  
@ test public void   (  )  {   flowable . empty (  )  . parallel (  )  . sequential (  )  . test ( 0 )  . assert result (  )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return observable plain . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public  path   (  )  {  return input file ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject . create (  )  . debounce ( 1  time unit . seconds new  test scheduler (  )  )  )  ;   test helper . check disposed (  publish subject . create (  )  . debounce (  functions . 
public  certificate   (  )  {  return    cert ;   }  
@ override public long   (  )  {  if  (    is running &&    active )   {  long time =    ctx . clock (  )  . now (  )   -     started ;  if  ( time  >  1000 )   {  long rv =  (    transferred * 1000 )   /  time ;  if  ( rv  >  =  100 )  return rv ;   }   
@ override public  string   (  http servlet request request  http servlet response response )  {  return request . get method (  )  ;   }  
@ test public void   (  )  {  h . execute ( "create table schedule  ( start time  stop time ) " )  ;   local time start =  local time . of ( 8 30 0 )  ;   local time stop =  local time . of ( 10 30 0 )  ;  h . execute ( "insert into schedule  ( start  sto
@ test public void   (  )  {  final  test exception ex = new  test exception (  )  ;  final  test exception ex2 = new  test exception (  )  ;  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {   list <  throwable >  errors =  t
private void   (  )  {   file cfg file =    location file ;  if  (  ! cfg file . exists (  )  )   {  if  (  !    already noticed missing config )   {     already noticed missing config = true ;   }  parse config ( new  properties (  )  )  ;  update limits (  )  ;  return ;   }     already noticed missing config = false ;  if  (  (    config last read  >  0 )  &&  (    config last read  >  =  cfg file . last modified (  )  )  )   {  return ;   }   properties p = new  properties (  )  ;  try  {   data helper . load props ( p cfg file )  ;     config last read =    context . clock (  )  . now (  )  ;   }  catch  (  io exception ioe )   {   system . err . println ( " error loading logger config from "  +  cfg file . get absolute path (  )  )  ;   }  parse config ( p )  ;  update limits (  )  ;   }  
public  collection <  local incoming server session >    (  )  {  return incoming server sessions . values (  )  ;   }  
@ override public void   (  parcel dest int flags )  {  dest . write long ( m id )  ;  dest . write string ( m provider id )  ;  dest . write string ( m access token )  ;  dest . write string ( m refresh token )  ;  dest . write long ( m expiration )  ;  
@ override public boolean   (  )  {  return  log . is error enabled (  )  ;   }  
public void   (  )  throws  exception  {   byte array output stream out = new  byte array output stream (  )  ;  i2p client client = i2p client factory . create client (  )  ;   destination d = client . create destination ( out )  ;  i2p session session = client . create session ( new  byte array input stream ( out . to byte array (  )  )  null )  ;  i2p datagram maker dm = new i2p datagram maker ( session )  ;  byte[] dg = dm . makei2p datagram (  data helper . getascii ( " what's the deal with 42 ? " )  )  ;  i2p datagram dissector dd = new i2p datagram dissector (  )  ;  dd . loadi2p datagram ( dg )  ;  byte[] x = dd . get payload (  )  ;  assert true (  data helper . eq ( x  data helper . getascii ( " what's the deal with 42 ? " )  )  )  ;  x = dd . extract payload (  )  ;  assert true (  data helper . eq ( x  data helper . getascii ( " what's the deal with 42 ? " )  )  )  ;  assert equals ( d dd . get sender (  )  )  ;  assert equals ( d dd . extract sender (  )  )  ;   }  
public int   (  )  {  if  (    handler  !  =  null )  return    handler . get complete count (  )  ;  else return 0 ;   }  
private static void   ( final  context context final long mailbox id final  bundle extras final  sync result sync result final boolean ui refresh final int delta message count )  {   temp directory . set temp directory ( context )  ;   mailbox mailbox =  mailbox . restore mailbox with id ( context mailbox id )  ;  if  ( mailbox  =  =  null )  return ;   account account =  account . restore account with id ( context mailbox . m account key )  ;  if  ( account  =  =  null )  return ;   content resolver resolver = context . get content resolver (  )  ;   string protocol = account . get protocol ( context )  ;  if  (  ( mailbox . m type  !  =   mailbox . type   outbox )  &&  ! loads from server ( context mailbox protocol )  )   {  resolver . delete (  message . updated   content   uri  message columns . mailbox   key  +  " =  ? " new  string[] {  long . to string ( mailbox . m id )  }  )  ;  return ;   }   log utils . d ( tag " about to sync mailbox: "  +  mailbox . m display name )  ;   uri mailbox uri =  content uris . with appended id (  mailbox . content   uri mailbox id )  ;   content values values = new  content values (  )  ;  final int sync status = ui refresh  ?   email content . sync   status   user :  email content . sync   status   background ;  values . put (  mailbox . ui   sync   status sync status )  ;  resolver . update ( mailbox uri values null null )  ;  try  {  int last sync result ;  try  {   string legacy imap protocol = context . get string ( r . string . protocol   legacy   imap )  ;  if  ( mailbox . m type  =  =   mailbox . type   outbox )   {   email service stub . send mail impl ( context account . m id )  ;   }  else  {  last sync result = ui provider . create sync value ( sync status  email content . last   sync   result   success )  ;   email service status . sync mailbox status ( resolver extras mailbox id  email service status . in   progress 0 last sync result )  ;  final int status ;  if  ( protocol . equals ( legacy imap protocol )  )   {  status =  imap service . synchronize mailbox synchronous ( context account mailbox delta message count  !  =  0 ui refresh )  ;   }  else  {  status =  pop3 service . synchronize mailbox synchronous ( context account mailbox delta message count )  ;   }   email service status . sync mailbox status ( resolver extras mailbox id status 0 last sync result )  ;   }   }  catch  (   messaging exception e )   {  final int type = e . get exception type (  )  ;  switch  ( type )   {  case  messaging exception . ioerror: last sync result = ui provider . create sync value ( sync status  email content . last   sync   result   connection   error )  ;   email service status . sync mailbox status ( resolver extras mailbox id  email service status . failure 0 last sync result )  ;  sync result . stats . num io exceptions +  +  ;  break ;  case  messaging exception . authentication   failed: last sync result = ui provider . create sync value ( sync status  email content . last   sync   result   auth   error )  ;   email service status . sync mailbox status ( resolver extras mailbox id  email service status . failure 0 last sync result )  ;  sync result . stats . num auth exceptions +  +  ;  break ;  case  messaging exception . server   error: last sync result = ui provider . create sync value ( sync status  email content . last   sync   result   server   error )  ;   email service status . sync mailbox status ( resolver extras mailbox id  email service status . failure 0 last sync result )  ;  break ;  default : last sync result = ui provider . create sync value ( sync status  email content . last   sync   result   internal   error )  ;   email service status . sync mailbox status ( resolver extras mailbox id  email service status . failure 0 last sync result )  ;   }   }   }  finally  {  values . put (  mailbox . ui   sync   status  email content . sync   status   none )  ;  values . put (  mailbox . sync   time  system . current time millis (  )  )  ;  resolver . update ( mailbox uri values null null )  ;   }   }  
@ override @ suppress warnings ( "unchecked" )  public void   ( byte[] nodeid )  {   object result =  cache factory . do synchronous cluster task ( new  get new member rooms request (  )  nodeid )  ;  if  ( result instanceof  list <  ?  >  )   {   list < 
public  string   (  )  {  final  simple date format formatter = new  simple date format ( "e  dd mmm yyyy hh:mm:ss z" )  ;  formatter . set time zone ( gmt   timezone )  ;  return formatter . format ( utc time )  ;   }  
@ xml element public  string   (  )  {  return room name ;   }  
public void   (  calendar cal )  {   date date = new  date ( cal )  ;  set header ( http . date date . get date string (  )  )  ;   }  
public synchronized long   (  )  {  return    count ;   }  
public void   (  peer peer  list <  request >  partials )  {  if  (    log . should log (  log . info )  )     log . info ( " partials received from "  +  peer  +  ": " +  partials )  ;  if  ( halted || completed (  )  )   {  for  (   request req : partials )   {   partial piece pp = req . get partial piece (  )  ;  pp . release (  )  ;   }  return ;   }  synchronized  ( wanted pieces )   {  for  (   request req : partials )   {   partial piece pp = req . get partial piece (  )  ;  if  ( req . off  >  0 )   {  int idx = partial pieces . index of ( pp )  ;  if  ( idx  <  0 )   {  partial pieces . add ( pp )  ;  if  (    log . should log (  log . info )  )     log . info ( " saving orphaned partial piece  ( new )  "  +  pp )  ;   }  else if  ( idx  >  =  0 && pp . get downloaded (  )   >  partial pieces . get ( idx )  . get downloaded (  )  )   {  partial pieces . get ( idx )  . release (  )  ;  partial pieces . set ( idx pp )  ;  if  (    log . should log (  log . info )  )     log . info ( " saving orphaned partial piece  ( bigger )  "  +  pp )  ;   }  else  {  pp . release (  )  ;  if  (    log . should log (  log . info )  )     log . info ( " discarding partial piece  ( not bigger ) "  +  pp )  ;   }  int max = get max connections (  )  ;  if  ( partial pieces . size (  )   >  max )   {   collections . sort ( partial pieces )  ;   partial piece gone = partial pieces . remove ( max )  ;  gone . release (  )  ;  if  (    log . should log (  log . info )  )     log . info ( " discarding orphaned partial piece  ( list full ) "  +  gone )  ;   }   }  else  {  pp . release (  )  ;   }  mark unrequested ( peer pp . get piece (  )  )  ;   }  if  (    log . should log (  log . info )  )     log . info ( " partial list size now: "  +  partial pieces . size (  )  )  ;   }   }  
public  string   (  )  {  return url ;   }  
public void   ( int min port )  {  this . min port = min port ;   }  
@ test public void   (  )  {   replay processor <  integer >  rp =  replay processor . create with time and size ( 1  time unit . days  schedulers . single (  )  2 )  ;  rp . on next ( 1 )  ;  rp . on next ( 2 )  ;  rp . on next ( 3 )  ;  rp . on next ( 4
@ override protected void   ( final sam record rec final  reference sequence ref )  {  if  (  ( pf   reads   only )  &&  ( rec . get read fails vendor quality check flag (  )  )  )   {  return ;   }  if  (  ( aligned   reads   only )  &&  ( rec . get read
public void   (  string second party call id )  {  this . second party call id = second party call id ;   }  
@ test public void   (  )  {   flowable <  movie >  horror movies =  flowable .  <  movie > just ( new  horror movie (  )  )  ;   flowable <  movie >  reduce result2 = horror movies . reduce ( new  bi function <  movie  movie  movie >  (  )  {  @ override
private static double[]   ( double[] raw values )  {  int n = raw values . length ;  double[] values = new double[n] ;   system . arraycopy ( raw values 0 values 0 n )  ;  return values ;   }  
public  string   (  )  {   node node = get fault actor node (  )  ;  if  ( node  =  =  null )  return "" ;  return node . get value (  )  ;   }  
@ override public  map <  object  object >    (  )  throws  exception  {  return new  hash map <  object  object >  (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    ( final  consumer <  ?  super  disposable >  on subscribe final  action on dispose )  {   object helper . require non null ( on subscribe "on subscri
public void   (  tunnel gateway message msg )  {  long before =    context . clock (  )  . now (  )  ;   tunnel gateway gw =    inbound gateways . get ( msg . get tunnel id (  )  )  ;  if  ( gw  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( "dispatch where we are the inbound gateway: "  +  gw  +  ": " +  msg )  ;  long min time = before  -   router . clock   fudge   factor ;  long max time = before  +  max   future   expiration ;  if  (  ( msg . get message expiration (  )   <  min time )  ||  ( msg . get message (  )  . get message expiration (  )   <  min time )  ||  ( msg . get message expiration (  )   >  max time ) ||  ( msg . get message (  )  . get message expiration (  )   >  max time )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not dispatching a gateway message for tunnel "  +  msg . get tunnel id (  )  . get tunnel id (  )   +  " as the wrapper's expiration is in " +   data helper . format duration ( msg . get message expiration (  )   -  before )  +  " and / or the content's expiration is in " +   data helper . format duration ( msg . get message (  )  . get message expiration (  )   -  before )  +  " with message id " +  msg . get unique id (  )  +  " / " +  msg . get message (  )  . get unique id (  )  +  " and message type " +  msg . get message (  )  . get class (  )  . get simple name (  )  )  ;  return ;   }     context . message history (  )  . tunnel dispatched ( msg . get unique id (  )  msg . get message (  )  . get unique id (  )  msg . get tunnel id (  )  . get tunnel id (  )  "inbound gateway" )  ;  gw . add ( msg )  ;     context . stat manager (  )  . add rate data ( "tunnel . dispatch inbound" 1 )  ;   }  else  {     context . message history (  )  . dropped tunnel gateway message unknown ( msg . get unique id (  )  msg . get tunnel id (  )  . get tunnel id (  )  )  ;  int level =  (    context . router (  )  . get uptime (  )   >  10 * 60 * 1000  ?   log . warn :  log . info )  ;  if  (    log . should log ( level )  )     log . log ( level "no matching tunnel for id = "  +  msg . get tunnel id (  )  . get tunnel id (  )   +  ": gateway message expiring in " +   data helper . format duration ( msg . get message expiration (  )   -     context . clock (  )  . now (  )  )  +  " / " +   data helper . format duration ( msg . get message (  )  . get message expiration (  )   -     context . clock (  )  . now (  )  )  +  " message id " +  msg . get unique id (  )  +  " / " +  msg . get message (  )  . get unique id (  )  +  " message type: " +  msg . get message (  )  . get class (  )  . get simple name (  )  +  " existing  =  " +     inbound gateways . size (  )  )  ;   }   }  
@ override public  string   (  )  {  return " parsed sql { "  +  "sql = '"  +  sql  +  '\'' +  "  parameters = " +  parameters +  ' } ' ;   }  
@ override protected void   (  get bandwidth limits message message )  {  int limit = 1024 * 1024 ;   bandwidth limits message msg = new  bandwidth limits message ( limit limit )  ;  try  {     runner . do send ( msg )  ;   }  catch  (  i2cp message excep
private void   (  selection key key )  {  ntcp connection con =  ( ntcp connection ) key . attachment (  )  ;  try  {  while  ( true )   {   byte buffer buf = con . get next write buf (  )  ;  if  ( buf  !  =  null )   {  if  ( buf . remaining (  )   <  =  0 )   {  con . remove write buf ( buf )  ;  continue ;   }  int written = con . get channel (  )  . write ( buf )  ;  if  ( written  =  =  0 )   {  if  (  ( buf . remaining (  )   >  0 )  ||  (  ! con . is write buf empty (  )  )  )   {   }  else  {  key . interest ops ( key . interest ops (  )  & ~ selection key . op   write )  ;   }  break ;   }  else if  ( buf . remaining (  )   >  0 )   {  break ;   }  else  {  con . remove write buf ( buf )  ;   }   }  else  {  if  ( key . is valid (  )  )  key . interest ops ( key . interest ops (  )  & ~ selection key . op   write )  ;  break ;   }   }   }  catch  (   cancelled key exception cke )   {  if  (    log . should log (  log . warn )  )     log . warn ( "error writing on "  +  con cke )  ;     context . stat manager (  )  . add rate data ( "ntcp . write error" 1 )  ;  con . close (  )  ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . warn )  )     log . warn ( "error writing on "  +  con ioe )  ;     context . stat manager (  )  . add rate data ( "ntcp . write error" 1 )  ;  con . close (  )  ;   }   }  
@ test public void   (  )  {   observable . range ( 1 2 )  . replay (  integer . max   value )  . auto connect (  )  . test (  )  . assert result ( 1 2 )  ;   }  
public  string   (  )  {  return name ;   }  
public static void   ( final  string[] argv )  {  new  extract illumina barcodes (  )  . instance main with exit ( argv )  ;   }  
public static void   (  byte buffer buf )  {  if  ( buf . capacity (  )   <  buf   size )   {  i2p app context . get global context (  )  . log manager (  )  . get log (  event pumper . class )  . error ( " bad size "  +  buf . capacity (  )  new  exception (  )  )  ;  return ;   }  buf . clear (  )  ;  int extra =    buf cache . size (  )  ;  boolean cached = extra  <     num bufs ;  if  ( cached )   {     buf cache . offer ( buf )  ;  if  ( extra  >  min   bufs )   {        consecutive extra +  +  ;  if  (       consecutive extra  >  =  20 )   {  if  (    num bufs  >  min   bufs )     num bufs -  -  ;        consecutive extra = 0 ;   }   }   }   }  
public void   ( long when )  {     next send time = when ;   }  
@ benchmark public  object   (  blackhole bh )  {  return observable convert . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override void   (  )  {  get context (  )  . message registry (  )  . unregister pending (    onm )  ;  get context (  )  . profile manager (  )  . db lookup failed (    to )  ;   }  
public boolean   ( int tunnel )  {  return    helper . get reduce on idle ( tunnel false )  ;   }  
protected byte[]   (  )  {  try  {  final  string line = reader . read line (  )  ;  if  ( next line  !  =  null &&  ! is comment ( next line . get bytes (  )  )  )   {  current line number = next line number ;  current line = next line ;   }  if  ( line  !  =  null )   {  next line number +  +  ;  next line = line ;  return line . get bytes (  )  ;   }  if  (  ! inputs . is empty (  )  )   {  advance file (  )  ;  return read next line (  )  ;   }  return null ;   }  catch  (   runtimeio exception ioe )   {  throw new  picard exception ( " error reading from file "  +  current file name ioe )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  atomic reference <  flowable <  integer >  >  ref = new  a
@ override public int   (  )  {  return skey . hash code (  )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . zip with ( just1 null )  ;   }  
@ override public void   (  disposable s )  {   disposable helper . set once ( this s )  ;   }  
public void   ( final int maximalpl difference )  {  this . maximalpl difference = maximalpl difference ;   }  
public   ( pkcs8 encoded key spec spec )  throws  invalid key spec exception  {  this ( new  eddsa private key spec ( decode ( spec . get encoded (  )  )   eddsa named curve table . get by name (  eddsa named curve table . curve   ed25519   sha512 )  )  )  ;   }  
public void   (  string s )  {  if  ( s  !  =  null )   {  try  {     config . set post ban time (  integer . parse int ( s . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
@ test public void   (  )  {  try  {   replay processor . create with size (  - 99 )  ;  fail ( " didn't throw  illegal argument exception" )  ;   }  catch  (   illegal argument exception ex )   {  assert equals ( "max size  >  0 required but it was  - 99
@ test public void   (  )  throws  exception  {   signature sgr = new  eddsa engine (  message digest . get instance ( "sha - 512" )  )  ;   eddsa public key spec pub key = new  eddsa public key spec ( test   pk  eddsa named curve table . get by name ( "e
@ override public void   (  )  {  done = true ;  parent . drain (  )  ;   }  
public void   (  )  {   logger . println ( " call "  +  member  +  " descriptors " +  mix descriptors . size (  )  )  ;  for  ( int i = 0 ;  i  <  mix descriptors . size (  )  ;  i +  +  )   {   mix descriptor mix descriptor =  (  mix descriptor ) mix descriptors . get ( i )  ;   logger . println ( mix descriptor . to string (  )  )  ;   }   }  
public void   ( long mailbox id  callback callback )  {  synchronized  ( m mailbox sync )   {  if  (  ! m mailbox sync . contains key ( mailbox id )  )  m mailbox sync . put ( mailbox id false )  ;  m handler . post delayed ( new  remove refresh status runnable ( mailbox id callback )  remove   refresh   status   delay   ms )  ;   }   }  
@ test public void   (  )  {   test helper . check utility class (  flowable blocking subscribe . class )  ;   }  
private void   (  list < b skip levels < k v >  >  next init )  {  boolean fail = false ;  for  ( int i = 0 ;  i  <  lps . length ;  i +  +  )   {  int lp = lps[i] ;  if  ( lp  !  =  0 )   {  levels[i] = bsl . level hash . get (  integer . value of ( lp )  )  ;  if  ( levels[i]  =  =  null )   {  try  {  b skip levels < k v >  lev = new b skip levels < k v >  ( bf lp bsl )  ;  levels[i] = lev ;  next init . add ( lev )  ;   }  catch  (  io exception ioe )   {  bf . log . error ( " corrupt database  bad level "  +  i  +  " at page " +  lp ioe )  ;  levels[i] = null ;  fail = true ;  continue ;   }   }  k our key = key (  )  ;  k next key = levels[i] . key (  )  ;  if  ( our key  !  =  null && next key  !  =  null && our key . compare to ( next key )   >  =  0 )   {  bf . log . warn ( " corrupt database  level out of order "  +  this  +  ' ' +  print (  )  +  " i  =  " +  i +  ' ' +  levels[i] )  ;   }   }  else  {  if  ( bf . log . should log (  log . warn )  )  bf . log . warn ( this  +  " i  =  "  +  i +  " of " +  lps . length +  "  /  " +  levels . length +  " valid levels but page is zero" )  ;  levels[i] = null ;  fail = true ;   }   }  if  ( fail && bf . file . can write (  )  )   {  bf . log . error ( " repairing corruption of "  +  this  +  ' ' +  print (  )  )  ;  flush (  )  ;   }   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   completable c = normal . completable . do on complete ( new  action (  )  {  @ override public void run (  )  {  calls . get and increment (  )  
public float   (  )  {  return byte written throughput ;   }  
@ override public void   (  group group  map params )  {   groupjid groupjid = group . getjid (  )  ;  try  {  add none ( groupjid get role (  )  )  ;   }  catch  (   exception ex )   {   log . error ( " failed to remove deleted group from affiliation lis
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   publisher <  object >  >  (  )  {  @ override public  publisher <  object >  apply (   flowable <  object >  o )  throws  exception  
public boolean   (  )  {  return follow referrals ;   }  
@ override public void   (  )  {  m counter +  +  ;   }  
public boolean   ( int tunnel )  {  return get boolean property ( tunnel "persistent client key" )  ;   }  
@ test public void   (  )  {  final  inet socket address address = mock (  inet socket address . class )  ;  final  cluster member cluster member = new  cluster member ( address 1000 )  ;  cluster member . set offline (  )  ;  assert false ( "a cluster me
public int   (  )  {  synchronized  (    state lock )   {  return    graceful exit code ;   }   }  
public  blocklist entries   (  )  {  return    blocklist entries ;   }  
@ override public iq   ( iq packet )  throws  packet exception   unauthorized exception  {   client session session = session manager . get session ( packet . get from (  )  )  ;  iq reply = null ;  if  ( session  =  =  null )   {   log . error ( " error 
@ test public void   (  )  {   flowable . just ( 1 )  . hide (  )  . observe on (  schedulers . computation (  )  )  . observe on (  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 )  ;   }  
  ( final  class <  ?  >  clazz final  string description )  {  this . clazz =  (  class <  primary alignment selection strategy >  ) clazz ;  this . description = description ;   }  
public void   ( int index double value )  throws io exception  {  int array index =  ( pointer . get (  )   +  index )  % rows ;  values . set ( array index value )  ;   }  
private void   ( long account id  string ticker  string title  string content text  intent intent int notification id )  {  final  notification compat .  builder builder = create base account notification builder ( account id ticker title content text intent null true needs ongoing notification ( notification id )  )  ;  m notification manager . notify ( notification id builder . build (  )  )  ;   }  
@ test public void   (  )  {   observable <  string >  base =  observable . just ( "a" "b" "c" )  ;   observable <  string >  do on each = base . do on each ( side effect observer )  ;  do on each . subscribe ( subscribed observer )  ;  verify ( subscribe
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  object >  source =  publish subject . create (  )  ;   observable <  object >  result = source . take last ( 1000  time unit . milliseconds schedule
public static void   (  context context )  {   preferences prefs =  preferences . get preferences ( context )  ;  int debug logging = prefs . get enable debug logging (  )   ?   email service proxy . debug   bit : 0 ;  int exchange logging = prefs . get enable exchange logging (  )   ?   email service proxy . debug   exchange   bit : 0 ;  int file logging = prefs . get enable exchange file logging (  )   ?   email service proxy . debug   file   bit : 0 ;  int enable strict mode = prefs . get enable strict mode (  )   ?   email service proxy . debug   enable   strict   mode : 0 ;  int debug bits = debug logging | exchange logging | file logging| enable strict mode ;   email service utils . set remote services logging ( context debug bits )  ;   }  
@ override public boolean   (  )  {  return is persistent (  )  && saved todb ;   }  
public static  string   (  http servlet request request  string name boolean empty stringsok )  {   string temp = request . get parameter ( name )  ;  if  ( temp  !  =  null )   {  if  ( temp . equals ( "" )  &&  ! empty stringsok )   {  return null ;   }  else  {  return temp ;   }   }  else  {  return null ;   }   }  
  (  completable observer actual )  {  this . cs = actual ;   }  
public void   ( int parameter index  reader value )  throws sql exception  {  pstmt . setn character stream ( parameter index value )  ;   }  
public void   (  )  throws io exception  {  while  (  ! initialhs complete )   {  initialhs complete = do handshake ( null )  ;   }   }  
private boolean   (  media info m1  media info m2 )  {  if  ( m1 . get sample rate (  )   >  m2 . get sample rate (  )  && m1 . get channels (  )   >  =  m2 . get channels (  )  )   {  return true ;   }  if  ( m1 . get sample rate (  )   =  =  m2 . get sample rate (  )  && m1 . get channels (  )   >  m2 . get channels (  )  )   {  return true ;   }  return false ;   }  
public static void   (  string subdomain )  throws  modification not allowed exception  {  for  (   external component manager listener listener : listeners )   {  listener . component blocked ( subdomain )  ;   }  delete configuration fromdb ( get configuration ( subdomain false )  )  ;   external component configuration config = new  external component configuration ( subdomain false  permission . blocked null )  ;  add configuration ( config )  ;   string domain = subdomain  +  " . "  +  xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;   session session =  session manager . get instance (  )  . get component session ( domain )  ;  if  ( session  !  =  null )   {   log . debug ( " closing session for external component ' {  } ' as the domain is being blocked .   affected session:  {  } " domain session )  ;  session . close (  )  ;   }   }  
public   (  router context context )  {     context = context ;     log = context . log manager (  )  . get log (  job queue . class )  ;     context . stat manager (  )  . create rate stat ( "job queue . ready jobs" " how many ready and waiting jobs there are ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . dropped jobs" " how many jobs do we drop due to insane overload ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . queued jobs" " how many scheduled jobs are there ? " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job run" " how long jobs take" " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job run slow" " how long jobs that take over a second take" " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create required rate stat ( "job queue . job lag" " job run delay  ( ms ) " " job queue" new long[] { 60 * 1000l 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     context . stat manager (  )  . create rate stat ( "job queue . job wait" " how long does a job sit on the job queue ? " " job queue" new long[] { 60 * 60 * 1000l 24 * 60 * 60* 1000l }  )  ;     ready jobs = new  linked blocking queue <  job >  (  )  ;     timed jobs = new  tree set <  job >  ( new  job comparator (  )  )  ;     job lock = new  object (  )  ;     queue runners = new  concurrent hash map <  integer  job queue runner >  ( runners )  ;     job stats = new  concurrent hash map <  string  job stats >  (  )  ;     pumper = new  queue pumper (  )  ;   }  
public void   (  string user )  {  white list . remove ( user . trim (  )  . to lower case (  )  )  ;  if  ( white list . size (  )   =  =  0 )   {   jive globals . delete property ( white   list )  ;   }  else  {   jive globals . set property ( white   list list tocsv ( white list )  )  ;   }   }  
@ test public void   (  )  {   collect wgs metrics collect wgs metrics = new  collect wgs metrics (  )  ;  collect wgs metrics . include   bq   histogram = true ;   fast wgs metrics collector collector = new  fast wgs metrics collector ( collect wgs metri
private static void   ( int x start int y start  byte matrix matrix )  throws  writer exception  {  for  ( int x = 0 ;  x  <  8 ;   +  + x )   {  if  (  ! is empty ( matrix . get ( x start  +  x y start )  )  )   {  throw new  writer exception (  )  ;   }  matrix . set ( x start  +  x y start 0 )  ;   }   }  
public boolean   (  )  {  return was available ;   }  
@ test public void   (  )  throws  exception  {  int sub count = 3 ;  final  count down latch upper latch = new  count down latch ( sub count )  ;  final  count down latch lower latch = new  count down latch ( sub count )  ;  final  count down latch on ne
public long   (  )  {  return    key established time ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . combine latest delay error ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] a )  throws  exception  {  return a ;   }   }   128  flo
@ override public  object   (  )  throws  exception  {  return 1 ;   }  
public  string   (  writer out )  throws io exception  {  render router infohtml ( out  (  string ) null )  ;  return "" ;   }  
@ override public void   (  )  throws  illegal state exception  {  super . start (  )  ;  local session manager . start (  )  ;  int period = 3 * 60 * 1000 ;   task engine . get instance (  )  . schedule at fixed rate ( new  detached cleanup task (  )  pe
  (  input stream in  discourse logger discourse logger int literal keep in memory threshold )  {  if  ( debug   log   raw   stream &&  debug utils . debug )   {  in = new  logging input stream ( in )  ;   }  m in = new  peekable input stream ( in )  ;  m discourse logger = discourse logger ;  m literal keep in memory threshold = literal keep in memory threshold ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return  arrays . as list ( v v
public boolean   (  )  {  synchronized  (    state lock )   {  return states   alive . contains (    state )  ;   }   }  
public void   ( boolean enabled  string recording file  string recording type )  throws io exception  {  if  ( enabled  =  =  false )   {  synchronized  ( recording lock )   {  if  ( audio recorder  !  =  null )   {  audio recorder . done (  )  ;  audio recorder = null ;   }  this . recording file = null ;   }  return ;   }  if  ( audio recorder  =  =  null )   {  synchronized  ( recording lock )   {  audio recorder = new  recorder ( recording file "au" media info )  ;   logger . println ( "starting conference recorder for "  +  recording file  +  " " +  media info )  ;  this . recording file = recording file ;   }   }   }  
@ override public iq   ( iq packet )  throws  unauthorized exception  {  iq reply = iq . create resultiq ( packet )  ;  return reply ;   }  
@ test public void   (  )  {   test helper . assert bad request reported (  flowable . zip (  flowable . just ( 1 )   flowable . just ( 1 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . sametime . password" "kraken" )  ;   }  
@ test public void   (  )  {   test subscriber <  boolean >  ts = new  test subscriber <  boolean >  (  )  ;  final  illegal argument exception ex = new  illegal argument exception (  )  ;   flowable . just ( " boo ! " )  . all ( new  predicate <  string 
public  list <  list <  string >  >    (  )  {  return announce   list ;   }  
@ non null public static  scheduler   ( @ non null  scheduler default scheduler )  {   function <  ?  super  scheduler  ?  extends  scheduler >  f = on new thread handler ;  if  ( f  =  =  null )   {  return default scheduler ;   }  return apply ( f defau
private void   ( boolean forget test )  {     current test complete = true ;   peer test state test =    current test ;  boolean isi pv6 = test . isi pv6 (  )  ;   status status ;  if  ( test . get alice port from charlie (  )   >  0 )   {  if  (  ( test . get alice port (  )   =  =  test . get alice port from charlie (  )  )  &&  ( test . get aliceip (  )   !  =  null )  &&  ( test . get aliceip from charlie (  )   !  =  null ) &&  ( test . get aliceip (  )  . equals ( test . get aliceip from charlie (  )  )  )  )   {  status = isi pv6  ?   status . ipv4   unknown   ipv6   ok :  status . ipv4   ok   ipv6   unknown ;   }  else  {  status = isi pv6  ?   status . ipv4   unknown   ipv6   firewalled :  status . ipv4   snat   ipv6   unknown ;   }   }  else if  ( test . get receive charlie time (  )   >  0 )   {  status =  status . unknown ;   }  else if  ( test . get receive bob time (  )   >  0 )   {  status = isi pv6  ?   status . ipv4   unknown   ipv6   firewalled :  status . ipv4   firewalled   ipv6   unknown ;   }  else  {  status =  status . unknown ;   }  if  (    log . should log (  log . info )  )     log . info ( " test complete: "  +  test )  ;  honor status ( status isi pv6 )  ;  if  ( forget test )     current test = null ;   }  
public  router address   (  )  {  return    rem addr ;   }  
@ suppress warnings ( "unchecked" )  void   (  )  {   object resource = get and set ( this )  ;  if  ( resource  !  =  this )   {  try  {  disposer . accept (  ( d ) resource )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ; 
@ test public void   (  )  {  assert that (  iterable like . is empty ( new  object[] {  }  )  )  . is true (  )  ;   }  
protected static  string   (  async context context )  {   string remote address = null ;  if  ( context . get request (  )   !  =  null && context . get request (  )  . get remote addr (  )   !  =  null )   {  remote address = context . get request (  )  . get remote addr (  )  ;   }  if  ( remote address  =  =  null || remote address . trim (  )  . length (  )   =  =  0 )   {  remote address = " < unknown address > " ;   }  return remote address ;   }  
@ deprecated public  server port   (  )  {  if  ( connection acceptor  =  =  null )   {  return null ;   }  final int port = get port (  )  ;  final  string name = get bind address (  )  . get host name (  )  ;  final  string address = get bind address ( 
@ override public void   (  emitter <  object >  e )  throws  exception  {  e . on complete (  )  ;  e . on complete (  )  ;   }  
@ override public void   (  )  {  parent . inner complete ( this )  ;   }  
public  string   (  )  {  return first conference member treatment ;   }  
public static void   (  user event listener listener )  {  if  ( listener  =  =  null )   {  throw new  null pointer exception (  )  ;   }  listeners . add ( listener )  ;   }  
public void   (  string uidl )  {  to delete . remove ( uidl )  ;   }  
public void   (  string context id )  {  try  {     context =  context helper . get context ( context id )  ;   }  catch  (   throwable t )   {  t . print stack trace (  )  ;   }   }  
public   (  localmuc room room  collection < muc role >  occupants )  {  this . room = room ;  for  (  muc role occupant : occupants )   {  this . occupants . add ( new  occupant added event ( room occupant )  )  ;   }   }  
@ test public void   (  )  {  int num failures = 20 ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   flowable <  string >  origin =  flowable . unsafe create ( new  func with errors ( num failures )  )  ;  origin . retry (  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to multimap ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   new  function <  integer  object >  (
protected  array list <  paired read sequence >    ( int seqs size boolean is optical duplicates )  {   array list <  paired read sequence >  seq = new  array list <  >  ( seqs size )  ;  for  ( int i = 0 ;  i  <  seqs size ;  i +  +  )   {  seq . add ( generate paired read sequence ( is optical duplicates )  )  ;   }  return seq ;   }  
public void   (  destination dest byte[] data )  {  if  ( dest  =  =  null || data . length  <  1 )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  ( log . should warn (  )  )  log . warn ( "bad subscription from "  +  dest )  ;   }  else  {  byte ctrl = data[0] ;  if  ( ctrl  =  =  0 )   {  if  (  ! this . subscriptions . contains ( dest )  )   {   system . out . println ( " add subscription: "  +  dest . to base64 (  )  . substring ( 0 4 )  )  ;  this . subscriptions . add ( dest )  ;  this . multi . add ( dest )  ;   }   }  else if  ( ctrl  =  =  1 )   {   system . out . println ( " remove subscription: "  +  dest . to base64 (  )  . substring ( 0 4 )  )  ;  boolean removed = this . subscriptions . remove ( dest )  ;  if  ( removed )  multi . remove ( dest )  ;   }  else  {   log log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  ( log . should warn (  )  )  log . warn ( "bad subscription from "  +  dest )  ;   }   }   }  
@ override public void   ( long idx )  {  if  ( index . compare and set ( idx  long . max   value )  )   {   disposable helper . dispose ( upstream )  ;   observable source <  ?  extends t >  f = fallback ;  fallback = null ;  f . subscribe ( new  observa
@ override boolean   (  packet packet )  {  return true ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return true ;   }  
@ override public void   (  )  {  try  {  if  ( server socket  !  =  null )   {  server socket . close (  )  ;   }   }  catch  (  io exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . utc )  ;  h . execute ( "insert into stuff ( ts )  values  (  ?  ) " dt )  ;  assert that ( h . create query ( "select ts from s
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return 1  /  v  >  0 ;   }   }    parallel failure handling .
@ override public void   (  string username  string password )  throws  user not found exception   unsupported operation exception  {  if  ( allow update && set passwordsql  !  =  null )   {  set password value ( username password )  ;   }  else  {  throw
  (  string .  .  .  values )  {  values to return = values ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . window ( 1  time unit . days  schedulers . single (  )  2 true )  . flat map (  functions .  <  flowable <  integer >  > identity (  )  )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;  final  publish subject <  integer >  timeout =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >  timeout func = new
public int   (  )  {  fifo bandwidth limiter bw =    context . bandwidth limiter (  )  ;  return  ( int ) bw . get receive bps (  )  ;   }  
@ override protected void   (  subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  observer . on complete (  )  ;  observer . on complete (  )  ;   }  
public   ( int ssrc )  {  super ( ssrc false )  ;  setssrc   1 ( ssrc )  ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
public static void   (  meter .  .  .  meters )  {  for  (   meter meter : meters )   {  meter . mark (  )  ;   }   }  
public  field element   (  )  {  return qm2 ;   }  
@ override public  packet error .  condition   (  )  {  return  packet error .  condition . not   authorized ;   }  
public   (  flowable < t >  source )  {  super ( source )  ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
public boolean   ( final  truth state truth state final  call state call state )  {  return truth state  =  =   truth state . missing || call state  =  =   call state . missing ;   }  
public void   (  registration event evt )  {  set result (  result .  successfully )  ;  try  {  sip manager . unregister (  )  ;   }  catch  (   communications exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
public int   (  )  {  return 0 ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 2 3 4 5 6 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . first ( 8 )  . to 
private void   (  string message  http servlet response response  print writer out )  {  response . set content type ( "text / xml" )  ;  out . println ( " < result > "  +  message  +  " <  / result > " )  ;  out . flush (  )  ;   }  
public  icon   (  )  {   icon smallest icon = null ;   icon list icon list = get icon list (  )  ;  int icon count = icon list . size (  )  ;  for  ( int n = 0 ;  n  <  icon count ;  n +  +  )   {   icon icon = icon list . get icon ( n )  ;  if  ( null  =  =  smallest icon )   {  smallest icon = icon ;  continue ;   }  if  ( icon . get width (  )   <  smallest icon . get width (  )  )  smallest icon = icon ;   }  return smallest icon ;   }  
@ override public void   (  )  {  s . cancel (  )  ;   }  
@ override public void   (  subscription s )  {  @ suppress warnings ( "unchecked" )   queue subscription <  integer >  qs =  (  queue subscription <  integer >  ) s ;  try  {  assert null ( qs . poll (  )  )  ;   }  catch  (   exception ex )   {  throw n
@ override public void   (  )  {  super . start running (  )  ;  if  ( open )   {  i2p socket address addr = pick destination (  )  ;  if  ( addr  !  =  null )   {   string svc = null ;   string hostname = addr . get host name (  )  ;  if  ( "smtp . postm
public  diploid genotype   ( final  snp snp final  diploid haplotype haplotype )  {  if  (  ! contains ( snp )  )  throw new  illegal argument exception ( " snp is not part of haplotype "  +  snp )  ;  return snp . get genotype ( haplotype )  ;   }  
@ override public  void   (  )  {  return null ;   }  
 time token   ( int new id )  {  assert token . id  =  =   time token . months   minutes ;  assert new id  =  =   time token . months || new id  =  =   time token . minutes ;  return token = new  time token ( token . value new id )  ;   }  
boolean   (  )  {   string us =    context . comm system (  )  . get our country (  )  ;  return us  !  =  null &&  (    big countries . contains ( us )  ||    context . get property (  capacity calculator . prop   country   bonus )   !  =  null )  && us . equals (    context . comm system (  )  . get country (    peer )  )  ;   }  
public void   ( boolean started support )  {  this . started support = started support ;   }  
public synchronized void   (  )  {     handler . restart (  )  ;     executor . restart (  )  ;  shutdown exploratory (  )  ;  startup (  )  ;   }  
public  snp   (  )  {  return snp ;   }  
@ override public  runnable   ( final  runnable actual )  throws  exception  {  return new  runnable (  )  {  @ override public void run (  )  {  decorated called . count down (  )  ;  actual . run (  )  ;   }   }   ;   }  
public static int   (  string string )  {  if  ( string  =  =  null )   {  return 0 ;   }  return 4  +  string . get bytes (  )  . length ;   }  
private  string   (  destination d )  {   tunnel pool settings in =    context . tunnel manager (  )  . get inbound settings ( d . calculate hash (  )  )  ;   string name =  ( in  !  =  null  ?  in . get destination nickname (  )  : null )  ;  if  ( name  =  =  null )   {   tunnel pool settings out =    context . tunnel manager (  )  . get outbound settings ( d . calculate hash (  )  )  ;  name =  ( out  !  =  null  ?  out . get destination nickname (  )  : null )  ;  if  ( name  =  =  null )  name = d . calculate hash (  )  . to base64 (  )  . substring ( 0 6 )  ;  else name =    t ( name )  ;   }  else  {  name =    t ( name )  ;   }  return name ;   }  
public void   (  )  {  try  {   input stream in =    socket . get input stream (  )  ;   output stream out =    socket . get output stream (  )  ;  in = new  buffered input stream ( in )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " handling socket from "  +     socket . get peer destination (  )  . calculate hash (  )  )  ;  peeracceptor . connection (    socket in out )  ;   }  catch  (   peer acceptor .  protocol exception ihe )   {     bad counter . increment (    socket . get peer destination (  )  . calculate hash (  )  )  ;  if  (    log . should log (  log . info )  )     log . info ( " protocol error from "  +     socket . get peer destination (  )  . calculate hash (  )  ihe )  ;  try  {     socket . close (  )  ;   }  catch  (  io exception ignored )   {   }   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . debug )  )     log . debug ( " error handling connection from "  +     socket . get peer destination (  )  . calculate hash (  )  ioe )  ;  try  {     socket . close (  )  ;   }  catch  (  io exception ignored )   {   }   }   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  for  ( int i = 1 ;  i  <  10 ;  i +  +  )   {  ps . on next ( i )  ;   }  ps . on complete (  )  ;   }   }  
public   (  publisher < t >  source  callable < r >  seed supplier  bi function < r  ?  super t r >  reducer )  {  this . source = source ;  this . seed supplier = seed supplier ;  this . reducer = reducer ;   }  
@ override protected  list <  action >    (  session data data )  {  return null ;   }  
private boolean   (  )  {  if  ( ctx . get boolean property ( "router . explore high capacity" )  )  return true ;  int active = ctx . comm system (  )  . count active peers (  )  ;  if  ( active  <  min   active   peers   startup )  return false ;  if  ( ctx . router (  )  . get uptime (  )   <  =   (  system version . is android (  )   ?  15 * 60 * 1000 : 5 * 60 * 1000 )  )  return true ;  if  ( ctx . router (  )  . graceful shutdown in progress (  )  )  return true ;  if  ( active  <  min   active   peers )  return false ;  int fail pct ;  if  ( ctx . router (  )  . get uptime (  )   <  =  11 * 60 * 1000 )   {  fail pct = 100  -  min   nonfailing   pct ;   }  else  {  fail pct = get exploratory fail percentage (  )  ;  if  ( fail pct  >  100  -  min   nonfailing   pct )  fail pct = 100  -  min   nonfailing   pct ;   }  return  ( fail pct  >  =  ctx . random (  )  . next int ( 100 )  )  ;   }  
public boolean   (  )  {   string buffer name = new  string buffer ( " cyber . http server / " )  ;  http server thread = new  thread ( this name . to string (  )  )  ;  http server thread . start (  )  ;  return true ;   }  
public void   (  string namespace )  {  if  ( local server features . add ( namespace )  )   {   lock lock =  cache factory . get lock ( namespace server features )  ;  try  {  lock . lock (  )  ;   set <  nodeid >  nodei ds = server features . get ( namespace )  ;  if  ( nodei ds  =  =  null )   {  nodei ds = new  hash set <  >  (  )  ;   }  nodei ds . add ( xmpp server . get instance (  )  . get nodeid (  )  )  ;  server features . put ( namespace nodei ds )  ;   }  finally  {  lock . unlock (  )  ;   }   }   }  
public void   (  )  throws  throwable  {   intent i = get test intent ( " name" "eas: /  / user:password@server . com" "eas: /  / user:password@server . com" )  ;  set activity intent ( i )  ;  get activity and fields (  )  ;  boolean has push = frequency spinner has value (  account . check   interval   push )  ;  assert true ( has push )  ;   }  
public   (  publisher <  ?  extends  completable source >  sources int prefetch )  {  this . sources = sources ;  this . prefetch = prefetch ;   }  
@ override public synchronized int   (  )  throws io exception  {  if  ( in  <  0 && timeout  >  0 &&  !    closed by reader )   {  long now =  system . current time millis (  )  ;  long end = now  +  timeout ;  while  ( true )   {  if  (    closed by wri
@ override public void   (  )  {   session manager sm = xmpp server . get instance (  )  . get session manager (  )  ;  for  (   client session session : sm . get sessions (  )  )   {  if  ( session instanceof  local session )   {   object ws =  (  (  loc
public   (  string name )  {  this . name = name ;  this . values = new  linked list <  >  (  )  ;   }  
public   (  multi user chat service service )  {  this . subdomain = service . get service name (  )  ;  this . description = service . get description (  )  ;  this . is hidden = service . is hidden (  )  ;  rooms = new  array list <  >  (  )  ;  for  (  muc room room : service . get chat rooms (  )  )   {   localmuc room local room =  (  localmuc room ) room ;  if  (  ! room . get occupants (  )  . is empty (  )  )   {  rooms . add ( new  room info ( local room local room . get occupants (  )  )  )  ;   }   }   }  
private sam record   ( final sam file header aligned header final sam record unmapped rec final  hit spec hit spec final int hit index )  {  final sam record rec = new sam record ( aligned header )  ;  rec . set read name ( unmapped rec . get read name (  )  )  ;  rec . set read bases ( unmapped rec . get read bases (  )  )  ;  rec . set base qualities ( unmapped rec . get base qualities (  )  )  ;  rec . set mapping quality ( hit spec . mapq )  ;  if  (  ! hit spec . primary )  rec . set not primary alignment flag ( true )  ;  final  cigar cigar = new  cigar (  )  ;  final int read length = rec . get read length (  )  ;  if  ( hit spec . filtered )   {  cigar . add ( new  cigar element ( read length  -  4  cigar operator . m )  )  ;  cigar . add ( new  cigar element ( 1  cigar operator . i )  )  ;  cigar . add ( new  cigar element ( 1  cigar operator . m )  )  ;  cigar . add ( new  cigar element ( 1  cigar operator . i )  )  ;  cigar . add ( new  cigar element ( 1  cigar operator . m )  )  ;   }  else  {  cigar . add ( new  cigar element ( read length  cigar operator . m )  )  ;   }  rec . set cigar ( cigar )  ;  rec . set reference name ( big sequence name )  ;  rec . set attribute ( sam tag . hi . name (  )  hit index )  ;  rec . set alignment start ( hit index  +  1 )  ;  return rec ;   }  
private  string   (  )  {  if  ( is root device (  )   =  =  false )  return getudn (  )  ;  return getudn (  )   +  "::"  +  upnp   rootdevice ;   }  
@ test public void   (  )  {  final int expected count = 3 ;  final  atomic integer count = new  atomic integer (  )  ;  for  ( int i = 0 ;  i  <  expected count ;  i +  +  )   {   flowable . just (  boolean . true  boolean . false )  . take while ( new  
@ override public  object   ( long timeout  time unit unit )  throws  interrupted exception   execution exception   timeout exception  {  return null ;   }  
public static boolean   (  roster roster  roster item item boolean persistent )  {  boolean answer = persistent ;  if  (  ! listeners . is empty (  )  )   {  for  (   roster event listener listener : listeners )   {  if  (  ! listener . adding contact ( roster item persistent )  )   {  answer = false ;   }   }   }  return answer ;   }  
@ data provider public  object[][]   (  )  {  return new  object[][] { new  object[] { 15 . 0 3 . 0 5 . 0 }  new  object[] { 15 . 0 0 . 0 0 . 0 }  }  ;   }  
@ override public void   ( final  subscriber <  ?  super  string >  observer )  {   system . out . println ( " test observable subscribed to  .  .  . " )  ;  observer . on subscribe ( s )  ;  t = new  thread ( new  runnable (  )  {  @ override public void
public  string   (  )  {  return " allow admins to control the updating of the  spark im  client . " ;   }  
public void   ( jid recipient  packet packet )  {   log . debug ( " presence sent to unreachable address: "  +  packet . toxml (  )  )  ;   }  
private static  observer <  string >    ( final  atomic reference <  throwable >  on error )  {  return new  default observer <  string >  (  )  {  @ override public void on complete (  )  {   }  @ override public void on error (   throwable e )  {  on error . set ( e )  ;   }  @ override public void on next (   string args )  {   }   }   ;   }  
boolean   (  hash peer )  {  return    state . was attempted ( peer )  ;   }  
@ override protected void   (  subscriber <  ?  super u >  s )  {  if  (  flowable scalarx map . try scalarx map subscribe ( source s mapper )  )   {  return ;   }  source . subscribe (  flowable flat map . subscribe ( s mapper delay errors max concurrenc
public static  list <  array list <  double >  >    ( final  list <  array list <  integer >  >  lists final  list <  double >  thresholds )  {  final  array list <  array list <  double >  >  result = new  array list <  >  (  )  ;  for  (  final  array list <  integer >  list : lists )   {  final  array list <  double >  new row = new  array list <  >  (  collections . n copies ( thresholds . size (  )  0 . 0 )  )  ;   collections . sort ( list )  ;  int n = 0 ;  int j = 0 ;  while  ( n  <  thresholds . size (  )  && j  <  list . size (  )  )   {  if  ( thresholds . get ( n )   >  list . get ( j )  )  j +  +  ;  else new row . set ( n +  +   ( double )  ( list . size (  )   -  j )   /  list . size (  )  )  ;   }  result . add ( new row )  ;   }  return result ;   }  
public  hash   (  )  {  if  (    key  !  =  null )  return    key ;  if  (    db entry  !  =  null )  return    db entry . get hash (  )  ;  return null ;   }  
public void   (  )  {  final  imap response ok = build response ( "tag" false new  imap simple string ( "ok" )  )  ;  final  imap response search = build response ( null false new  imap simple string ( "search" )  new  imap simple string ( "1" )  )  ;  final  imap response exists = build response ( null false new  imap simple string ( "3" )  new  imap simple string ( "exists" )  )  ;  final  imap response tagged   exists = build response ( "tag" false new  imap simple string ( "1" )  new  imap simple string ( "exists" )  )  ;  assert true ( search . is data response ( 0  imap constants . search )  )  ;  assert true ( exists . is data response ( 1  imap constants . exists )  )  ;  assert false ( search . is data response ( 1  imap constants . search )  )  ;  assert false ( exists . is data response ( 0  imap constants . exists )  )  ;  assert false ( exists . is data response ( 1  imap constants . fetch )  )  ;  assert false ( tagged   exists . is data response ( 1  imap constants . exists )  )  ;   }  
private void   (  )  {  i2cp message msg ;  if  (    reqid  >  =  0 )  msg = new  host reply message (    sessid  host reply message . result   failure    reqid )  ;  else msg = new  dest reply message (    hash )  ;  try  {     runner . do send ( msg )  ;   }  catch  (  i2cp message exception ime )   {   }   }  
public void   (  storage storage int num boolean checked )  {  if  (  ! all checked &&  ! checking )   {  checking = true ;   }  if  (  ! checking )   {  if  (    log . should log (  log . info )  )     log . info ( " got "  +   ( checked  ?  "" : "bad " )   +  "piece: " +  num )  ;  if  ( complete listener  !  =  null )  complete listener . got piece ( this )  ;   }   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on error ( t )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable <  integer >  source =  flowable . create ( new  flowable on subscribe <  integer >  (  )  {  @ override public void subscribe (   flowable emitter
@ override public void   ( final  metrics file <  total number metric  integer >  total number metric integer metrics file )  {  total number metric integer metrics file . add metric ( metric )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . switch map single (  functions . just function (  single . just ( 1 )  )  )  . test ( 0 )  . assert empty (  )  . request more ( 1 )  . assert result ( 1 )  ;   }  
  (  subscriber <  ?  super v >  actual  iterator < u >  iterator  bi function <  ?  super t  ?  super u  ?  extends v >  zipper )  {  this . actual = actual ;  this . iterator = iterator ;  this . zipper = zipper ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable <  integer >  source =  flowable . create ( new  flowable on subscribe <  integer >  (  )  {  @ override public void subscribe (   flowable emitter
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 2 3 )  ;  int value = o . reduce ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer t1   integer t2 )  {  return t1  +
public boolean   ( int i )  {  return  ( bits[i  /  32] &  ( 1  <  <   ( i & 0x1f )  )  )   !  =  0 ;   }  
public boolean   (  )  {  return persist published items ;   }  
@ test public void   (  )  {   maybe . merge delay error (  flowable . just (  maybe . empty (  )   maybe . just ( 1 )   maybe . error ( new  test exception (  )  )  )  )  . test (  )  . assert failure (  test exception . class 1 )  ;   maybe . merge dela
 rrd db   (  )  {  return    db ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  o 
@ test public void   (  )  {  double error ;  double predict ;  prepare limiter (  - 1  - 1  - 1  - 1 )  ;  long ms = test outbound throttle ( num   kb * 1024 1 * 1024 )  ;  prepare limiter (  - 1 32  - 1 32 * 1024 )  ;  ms = test outbound throttle ( num 
public void   (  update task task  string reason  throwable t )  {  if  (    log . should log (  log . warn )  )     log . warn ( " attempt failed "  +  task  +  " for " +  task . get type (  )  +  ": " +  reason t )  ;   }  
@ test public void   (  )  {   value v1 = new  value (  )  ;   value v2 = new  value (  )  ;   open hash set <  value >  set = new  open hash set <  value >  (  )  ;  assert true ( set . add ( v1 )  )  ;  assert false ( set . add ( v1 )  )  ;  assert fals
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;   subscriber <  integer >  o1 =  test helper . mock subscriber (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 
@ experimental public static  < t >  single observer < t >    (  observer <  ?  super t >  downstream )  {  return new  single to observable observer < t >  ( downstream )  ;   }  
@ override public boolean   (  string name  string value )  {  return false ;   }  
public void   (  out net message msg )  {  try  {     executor . execute ( new  runnable event ( msg )  )  ;   }  catch  (   rejected execution exception ree )   {     log . warn ( "ntcp send finisher stopped  discarding msg . after send (  ) " )  ;   }   }  
public void   (  )  {   byte array output stream output stream = null ;  try  {   string host =  jive globals . get property ( "mail . smtp . host" "localhost" )  ;   string port =  jive globals . get property ( "mail . smtp . port" "25" )  ;   string username =  jive globals . get property ( "mail . smtp . username" )  ;   string password =  jive globals . get property ( "mail . smtp . password" )  ;   string debug enabled =  jive globals . get property ( "mail . debug" )  ;  boolean ssl enabled =  jive globals . get boolean property ( "mail . smtp . ssl" true )  ;   properties props = new  properties (  )  ;  props . put ( "mail . smtp . host" host )  ;  props . put ( "mail . smtp . auth" port )  ;  props . set property ( "mail . smtp . sendpartial" "true" )  ;  props . set property ( "mail . debug" debug enabled )  ;  if  ( ssl enabled )   {   security . set property ( "ssl .  socket factory . provider" ssl   factory )  ;  props . set property ( "mail . smtp . socket factory . class" ssl   factory )  ;  props . set property ( "mail . smtp . socket factory . fallback" "true" )  ;   }  if  ( username  !  =  null )   {  props . put ( "mail . smtp . auth" "true" )  ;   }   session session =  session . get instance ( props )  ;  output stream = new  byte array output stream (  )  ;  create pdf attachment ( output stream )  ;  byte[] bytes = output stream . to byte array (  )  ;   byte array data source data source = new  byte array data source ( bytes "application / pdf" )  ;   mime body part pdf body part = new  mime body part (  )  ;  pdf body part . set data handler ( new  data handler ( data source )  )  ;  pdf body part . set file name ( " result summary . pdf" )  ;   mime multipart multipart = new  mime multipart (  )  ;  multipart . add body part ( pdf body part )  ;   mime message msg = new  mime message ( session )  ;   default admin provider default admin provider = new  default admin provider (  )  ;  java . util .  list < jid >  admin list = default admin provider . get admins (  )  ;  java . util .  list <  string >  admin list emails = new  array list <  string >  (  )  ;   user manager manager =  user manager . get instance (  )  ;   log . info ( " number of  admins "  +  admin list . size (  )  )  ;  for  ( int i = 0 ;  i  <  admin list . size (  )  ;  i +  +  )   {   user user ;  try  {  user = manager . get user ( admin list . get ( i )  . get node (  )  . to string (  )  )  ;   log . info ( " admin  emails: "  +  user . get email (  )  )  ;  admin list emails . add ( user . get email (  )  )  ;   }  catch  (   exception ex )   {  continue ;   }   }   internet address[] recipients = new  internet address[admin list emails . size (  ) ] ;  for  ( int i = 0 ;  i  <  admin list emails . size (  )  ;  i +  +  )   {  recipients[i] = new  internet address ( admin list emails . get ( i )  . to string (  )  )  ;   }  msg . set from ( new  internet address ( "no - reply@openfire . org" " openfire  admin" )  )  ;  msg . set recipients ( javax . mail .  message .  recipient type . to recipients )  ;  msg . set subject ( "monitoring report  -  "  +  new  simple date format ( "mm / dd / yyyy hh:mm:ss" )  . format ( new  date (  )  )  )  ;  msg . set content ( multipart )  ;  if  ( username  !  =  null )   {  url name url = new url name ( "smtp" host  integer . parse int ( port )  "" username password )  ;   transport transport = new com . sun . mail . smtp . smtp transport ( session url )  ;  transport . connect ( host  integer . parse int ( port )  username password )  ;  transport . send message ( msg msg . get recipients (  mime message .  recipient type . to )  )  ;   }  else  transport . send ( msg )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   system . out . println ( " could not send email" )  ;   }   }  
public void   (  )  {  wrong rtp timestamp +  +  ;   }  
@ override public  argument   (  duration duration  config registry config )  {  final boolean is negative = duration . is negative (  )  ;  if  ( is negative )   {  duration = duration . negated (  )  ;   }  final long days = duration . to days (  )  ;  
private  request   (  string destination )  throws  invalid argument exception   parse exception  {   string dest username = destination ;   string dest host = sip host ;  if  ( destination . index of ( "@" )   =  =  0 || destination . index of ( "@" )   =  =  destination . length (  )   -  1 )   {  throw new  invalid argument exception ( " the address provided is invalid ! " )  ;   }  else if  ( destination . index of ( "@" )   >  0 )   {  dest username = destination . substring ( 0 destination . index of ( "@" )  )  ;  dest host = destination . substring ( destination . index of ( "@" )   +  1 )  ;   }   sipuri dest uri = address factory . create sipuri ( dest username dest host )  ;  return prepare request (  request type . subscribe dest uri null dest uri null 1l )  ;   }  
@ test public void   (  )  {   behavior processor <  string >  processor =  behavior processor . create default ( "default" )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  processor . subscribe ( observer )  ;  processor 
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  try  {  on complete . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }   }  
@ override public void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  if  ( i  <  500 )   {  try  {   thread . sleep ( 1 )  ;   }  catch  (   interrupted exception e )   {  e . print stack trace ( 
@ override public void   (  string property  map <  string  object >  params )  {  if  ( property . equals ( "xmpp . pubsub . enabled" )  )   {  boolean enabled =  boolean . parse boolean (  (  string ) params . get ( "value" )  )  ;  enable service ( ena
public  properties   (  )  {  return null ;   }  
@ override public boolean   (  )  {  return is cancelled (  )  || is done . get (  )  ;   }  
public void   (  string id )  {  this . id = id ;   }  
@ test public void   (  )  {   observable . from iterable ( new  crashing iterable ( 1 100 100 )  )  . test (  )  . assert failure and message (  test exception . class "iterator (  ) " )  ;   }  
@ override protected void   (  )  throws  xml pull parser exception  io exception  {   xml pull parser xpp = socket reader . reader . getxpp parser (  )  ;  xpp . set input ( new  input stream reader ( socket reader . connection . gettls stream handler ( 
@ override public void   (  )  {  bh . consume ( true )  ;   }  
@ override public int   (  )  {  final  account account = m setup data . get account (  )  ;  if  ( m delete policy view . get visibility (  )   =  =   view . visible )   {  account . set delete policy (  (  integer )  (  (  spinner option ) m delete poli
void   ( r item )  {  this . item = item ;  this . state = state   result   value ;  drain (  )  ;   }  
void   (  )  {  if  ( wip . get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   simple queue < t >  q = queue ;  int upstream consumed = consumed ;  int local limit = limit ;  boolean can request = source mode  !  =   queue subscription . sync ;   atomic reference <  multicast subscription < t > [] >  subs = subscribers ;   multicast subscription < t > [] array = subs . get (  )  ;  outer: for  (  ;   ;   )   {  int n = array . length ;  if  ( q  !  =  null && n  !  =  0 )   {  long r =  long . max   value ;  for  (   multicast subscription < t >  ms : array )   {  long u = ms . get (  )   -  ms . emitted ;  if  ( u  !  =   long . min   value )   {  if  ( r  >  u )   {  r = u ;   }   }  else  {  n -  -  ;   }   }  if  ( n  =  =  0 )   {  r = 0 ;   }  while  ( r  !  =  0 )   {  if  ( is disposed (  )  )   {  q . clear (  )  ;  return ;   }  boolean d = done ;  if  ( d &&  ! delay error )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error all ( ex )  ;  return ;   }   }  t v ;  try  {  v = q . poll (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   subscription helper . cancel ( s )  ;  error all ( ex )  ;  return ;   }  boolean empty = v  =  =  null ;  if  ( d && empty )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error all ( ex )  ;   }  else  {  complete all (  )  ;   }  return ;   }  if  ( empty )   {  break ;   }  boolean subscribers change = false ;  for  (   multicast subscription < t >  ms : array )   {  long msr = ms . get (  )  ;  if  ( msr  !  =   long . min   value )   {  if  ( msr  !  =   long . max   value )   {  ms . emitted +  +  ;   }  ms . actual . on next ( v )  ;   }  else  {  subscribers change = true ;   }   }  r -  -  ;  if  ( can request &&  +  + upstream consumed  =  =  local limit )   {  upstream consumed = 0 ;  s . get (  )  . request ( local limit )  ;   }   multicast subscription < t > [] fresh array = subs . get (  )  ;  if  ( subscribers change || fresh array  !  =  array )   {  array = fresh array ;  continue outer ;   }   }  if  ( r  =  =  0 )   {  if  ( is disposed (  )  )   {  q . clear (  )  ;  return ;   }  boolean d = done ;  if  ( d &&  ! delay error )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error all ( ex )  ;  return ;   }   }  if  ( d && q . is empty (  )  )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  error all ( ex )  ;   }  else  {  complete all (  )  ;   }  return ;   }   }   }  consumed = upstream consumed ;  missed = wip . add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }  if  ( q  =  =  null )   {  q = queue ;   }  array = subs . get (  )  ;   }   }  
private static void   (  print writer out  string folder name int page int pages boolean output hidden )  {  out . println ( " < table id = \"pagenav\" >  < tr >  < td > " )  ;   string name = folder name . equals ( dir   folder )   ?  " inbox" : folder name ;  out . println (    t ( " folder" )   +  ": "  +     t ( name )  +  "&nbsp ; &nbsp ; &nbsp ; &nbsp ; " )  ;  out . println ( button ( switch   to    t ( " change to  folder" )  )  )  ;  show folder select ( out folder name false )  ;  if  ( pages  >  1 )   {  if  ( output hidden )  out . println ( " < input type = \"hidden\" name = \""  +  cur   page  +  "\" value = \"" +  page +  "\" > " )  ;   string t1 =    t ( " first" )  ;   string t2 =    t ( " previous" )  ;  if  ( page  <  =  1 )   {  out . println ( button2 ( firstpage t1 )   +  "&nbsp ; "  +  button2 ( prevpage t2 )  )  ;   }  else  {  if  ( output hidden )  out . println ( " < input type = \"hidden\" name = \""  +  prev   page   num  +  "\" value = \"" +   ( page  -  1 )  +  "\" > " )  ;  out . println ( button ( firstpage t1 )   +  "&nbsp ; "  +  button ( prevpage t2 )  )  ;   }  out . println ( " <  / td >  < td > "  +     t ( " page  { 0 }  of  { 1 } " page pages )   +  " <  / td >  < td > " )  ;  t1 =    t ( " next" )  ;  t2 =    t ( " last" )  ;  if  ( page  >  =  pages )   {  out . println ( button2 ( nextpage t1 )   +  "&nbsp ; "  +  button2 ( lastpage t2 )  )  ;   }  else  {  if  ( output hidden )  out . println ( " < input type = \"hidden\" name = \""  +  next   page   num  +  "\" value = \"" +   ( page  +  1 )  +  "\" > " )  ;  out . println ( button ( nextpage t1 )   +  "&nbsp ; "  +  button ( lastpage t2 )  )  ;   }   }  out . println ( " <  / td >  <  / tr >  <  / table > " )  ;   }  
protected void   (  inet socket address isa byte media payload byte receive payload byte telephone event payload  inet socket address rtcp address )  {  call handler . set endpoint address ( isa media payload receive payload telephone event payload rtcp address )  ;   }  
public static  comparator <  file and index >    ( int type i2p snark servlet servlet )  {  boolean rev = type  <  0 ;   comparator <  file and index >  rv ;  switch  ( type )   {  case  - 1: case 0: case 1: default : rv = new  file name comparator (  )  ;  if  ( rev )  rv =  collections . reverse order ( rv )  ;  break ;  case  - 5: case 5: rv = new fai size comparator ( rev )  ;  break ;  case  - 10: case 10: rv = new fai remaining comparator ( rev )  ;  break ;  case  - 12: case 12: rv = new fai type comparator ( rev servlet )  ;  break ;  case  - 13: case 13: rv = new fai priority comparator ( rev )  ;  break ;   }  return rv ;   }  
@ override public void   (  )  throws  servlet exception  {  super . init (  )  ;     css path = get init parameter ( "css path" )  ;  if  (    css path  =  =  null )   {   string dir = base   theme   path  +     context . get property ( prop   theme   na
@ test ( timeout = 10000 )  public void   (  )  {  for  ( int i = 0 ;  i  <  50 ;  i +  +  )   {  final  replay processor <  string >  processor =  replay processor . create (  )  ;  final  atomic reference <  string >  value1 = new  atomic reference <  s
public  session key manager   (  )  {  if  (  !    session key manager initialized )  initialize session key manager (  )  ;  return    session key manager ;   }  
@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;  handle . configure (  tuple mappers . class c  -  >  c . set column ( 2 "integer val
public static void   (  subscriber <  ?  >  s )  {  s . on subscribe ( instance )  ;  s . on complete (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . request ( 3 )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable .  <  integer > unsafe create ( new  publisher <  int
@ test public void   (  )  {   string test group name = " test  group  ( 1 ) " ;   string test domain name = "localhost" ;   string test base32 group name =  string utils . encode base32 ( test group name )  ;  jid test jid = new jid ( test base32 group n
@ override public boolean   (  )  {  return true ;   }  
@ override public int   (  )  {  int rv = 0 ;  if  (    gateway  !  =  null )  rv +  =    gateway . hash code (  )  ;  if  (    tunnel  !  =  null )  rv +  = 7 *    tunnel . get tunnel id (  )  ;  return rv ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  integer >   flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   flowable <  integer >  c )  throws  exception
public  collection <  node subscription >    (  )  {  return node . get subscriptions ( jid )  ;   }  
public void   (  input stream in )  throws  data format exception  io exception  {  if  (    transport style  !  =  null )  throw new  illegal state exception (  )  ;     cost =  ( short )  data helper . read long ( in 1 )  ;     expiration =  data helper . read long ( in 8 )  ;     transport style =  data helper . read string ( in )  ;  if  (    transport style . equals ( "ssu" )  )     transport style = "ssu" ;  else if  (    transport style . equals ( "ntcp" )  )     transport style = "ntcp" ;   data helper . read properties ( in    options )  ;   }  
@ test ( expected exceptions =  illegal argument exception . class )  public void   (  )  throws  exception  {  final  file output file =  file . create temp file ( "add comments to bam test . mew line"  bam file io utils . bam   file   extension )  ;  ou
public i2cp message queue   (  )  throws i2p session exception  {  if  (  !    is started )  throw new i2p session exception ( " router client manager is shut down" )  ;   linked blocking queue < i2cp message >  in = new  linked blocking queue < i2cp message >  ( internal   queue   size )  ;   linked blocking queue < i2cp message >  out = new  linked blocking queue < i2cp message >  ( internal   queue   size )  ;  i2cp message queue my queue = new i2cp message queue impl ( in out )  ;  i2cp message queue his queue = new i2cp message queue impl ( out in )  ;   client connection runner runner = new  queued client connection runner (    ctx this my queue )  ;  register connection ( runner )  ;  return his queue ;   }  
public boolean   ( k bucket < t >  kbucket t to add )  {  return false ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c =  completable . merge (  arrays . as list ( normal . completable normal . completable normal . completable )  )  ;  c . blocking await (  )  ;  normal . assert subscriptions ( 3 )  ;   }  
private void   (  connection con  packet packet )  {  if  ( i2p socket manager full . pcap writer  !  =  null &&    context . get boolean property ( i2p socket manager full . prop   pcap )  )  packet . logtcp dump ( con )  ;  if  ( packet . is flag set (  packet . flag   echo )  )   {  if  ( packet . get send stream id (  )   >  0 )   {  if  ( con . get options (  )  . get answer pings (  )  )  receive ping ( con packet )  ;  else if  (    log . should log (  log . warn )  )     log . warn ( " dropping  echo packet on existing con: "  +  packet )  ;   }  else if  ( packet . get receive stream id (  )   >  0 )   {  receive pong ( packet )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " echo packet received with no stream i ds: "  +  packet )  ;   }  packet . release payload (  )  ;  return ;   }  if  ( is valid match ( con . get send stream id (  )  packet . get receive stream id (  )  )  )   {  try  {  con . get packet handler (  )  . receive packet ( packet con )  ;   }  catch  (  i2p exception ie )   {  if  (    log . should log (  log . warn )  )     log . warn ( " received forged packet for "  +  con ie )  ;   }   }  else  {  if  ( packet . is flag set (  packet . flag   reset )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( "receive reset: "  +  packet )  ;  try  {  con . get packet handler (  )  . receive packet ( packet con )  ;   }  catch  (  i2p exception ie )   {  if  (    log . should log (  log . warn )  )     log . warn ( " received forged reset for "  +  con ie )  ;   }   }  else  {  if  (  ( con . get send stream id (  )   <  =  0 )  ||  ( con . get send stream id (  )   =  =  packet . get receive stream id (  )  )  ||  ( packet . get sequence num (  )   <  =   connection options . min   window   size )  )   {  long old id = con . get send stream id (  )  ;  if  ( packet . is flag set (  packet . flag   synchronize )  )   {  if  ( old id  <  =  0 )   {  con . set send stream id ( packet . get receive stream id (  )  )  ;   }  else if  ( old id  =  =  packet . get receive stream id (  )  )   {   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " received a syn with the wrong i ds  con = "  +  con  +  " packet = " +  packet )  ;  send reset ( packet )  ;  packet . release payload (  )  ;  return ;   }   }  try  {  con . get packet handler (  )  . receive packet ( packet con )  ;   }  catch  (  i2p exception ie )   {  if  (    log . should log (  log . error )  )     log . error ( " received forged packet for "  +  con  +  " / " +  old id +  ": " +  packet ie )  ;  con . set send stream id ( old id )  ;   }   }  else if  ( packet . is flag set (  packet . flag   synchronize )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " receive a syn packet with the wrong i ds  sending reset: "  +  packet )  ;  send reset ( packet )  ;  packet . release payload (  )  ;   }  else  {  if  (  ! con . get reset sent (  )  )   {  if  (    log . should log (  log . warn )  )   {   string builder buf = new  string builder ( 512 )  ;  buf . append ( " received a packet on the wrong stream: " )  ;  buf . append ( packet )  ;  buf . append ( "\nthis connection:\n" )  ;  buf . append ( con )  ;  buf . append ( "\nall connections:" )  ;  for  (   connection cur :    manager . list connections (  )  )   {  buf . append ( '\n' )  . append ( cur )  ;   }     log . warn ( buf . to string (  )  new  exception ( " wrong stream" )  )  ;   }   }  packet . release payload (  )  ;   }   }   }   }  
public   (  string message )  {  super ( message )  ;   }  
public  string   (  )  {  return with ;   }  
public final static void   (  string builder buf  string prefix  string name  string description long value )  {   string when =  data helper . format duration ( value )  ;  add ( buf prefix name description  +  ' '  +  when value )  ;   }  
@ override public  string   (  string raw name  statement context ctx )  {  return "#"  +  raw name ;   }  
@ test public void   (  )  throws  malformedurl exception  {  when ( original request . get server name (  )  )  . then return ( "myhost . com" )  ;  when ( original request . get server port (  )  )  . then return ( 80 )  ;  when ( original request . get
@ test public void   (  )  {  for  ( int times = 0 ;  times  <  100 ;  times +  +  )   {  int observable count = 100 ;  int max concurrent = 2  +   ( times % 10 )  ;   atomic integer subscription count = new  atomic integer ( 0 )  ;   list <  observable <
public int   (  )  {  return    type ;   }  
protected void   (  )  {     reorganize lock . read lock (  )  . lock (  )  ;   }  
@ override public int   (  )  {  return i2p session . port   any ;   }  
public static  user property provider   (  string property name )  {  final  string class name =  jive globals . get property ( property name )  ;  if  ( class name  =  =  null )   {   log . debug ( " property ' {  } ' is undefined .   skipping . " property name )  ;  return null ;   }   log . debug ( " about to to instantiate an  user property provider ' {  } ' based on the value of property ' {  } ' . " class name property name )  ;  try  {  final  class c =  class utils . for name ( class name )  ;  final  user property provider provider =  (  user property provider ) c . new instance (  )  ;   log . debug ( " instantiated  user property provider ' {  } '" class name )  ;  return provider ;   }  catch  (   exception e )   {   log . error ( " unable to load  user property provider ' {  } ' .   users in this provider will be disabled . " class name e )  ;  return null ;   }   }  
  (  unicast subject < t >  w b open )  {  this . w = w ;  this . open = open ;   }  
public  session key   ( byte salt[] byte passphrase[] )  {  byte salted[] = new byte[16  +  passphrase . length] ;   system . arraycopy ( salt 0 salted 0  math . min ( salt . length 16 )  )  ;   system . arraycopy ( passphrase 0 salted 16 passphrase . length )  ;  byte h[] =    context . sha (  )  . calculate hash ( salted )  . get data (  )  ;  for  ( int i = 1 ;  i  <  pbe   rounds ;  i +  +  )     context . sha (  )  . calculate hash ( h 0  hash . hash   length h 0 )  ;  return new  session key ( h )  ;   }  
public  datagram packet   (  )  {  return dgm packet ;   }  
@ test ( data provider = "  data provider" )  public void test fix vcf header ( final int check firstn records final  file replacement header final boolean enforce sample samples )  throws io exception  {  run fix vcf header ( check firstn records replace
public static  session event   (  session session  string user  string resource )  {  return new  session event ( session session   auth   failure " user: "  +  user  +  "  resource: " +  resource )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . from iterable (  arrays . as list ( 1 2 3 4 )  )  . concat map ( new  function <  integer  observable source <  integer >  >  (  )  {  
@ test public void   (  )  {   string media type string = "text / xml" ;   mime type returned media type =  mime type . guess media type from string ( media type string )  ;  assert equals ( returned media type . get name (  )  media type string )  ;   } 
@ test public void   (  )  throws  document exception  io exception   xml pull parser exception  {   string chatxml = " < message to = \"doe@127 . 0 . 0 . 1 /  adium\" type = \"chat\" id = \"i chat   e8b5ed64\" from = \"bob@127 . 0 . 0 . 1 / frodo\" > "  
@ override protected void   (  observer <  ?  super  integer >  s )  {  s . on subscribe (  disposables . empty (  )  )  ;  to . cancel (  )  ;  s . on next ( 1 )  ;  s . on complete (  )  ;   }  
@ test public void   (  )  {   single . using ( new  callable <  integer >  (  )  {  @ override public  integer call (  )  throws  exception  {  throw new  test exception (  )  ;   }   }    functions . just function (  single . just ( 1 )  )   functions .
@ override public  string   (  )  {  return type ;   }  
@ test public void   (  )  {   behavior subject <  integer >  source =  behavior subject . create (  )  ;  final  observer <  object >  o =  test helper . mock observer (  )  ;   in order in order = in order ( o )  ;  source . on next ( 1 )  ;  source . s
@ override public  observable source <  object >    (  single <  object >  s )  throws  exception  {  return s . to observable (  )  ;   }  
public   (  router context ctx  tunnel data message msg )  {  super ( ctx )  ;     msg = msg ;   }  
@ override public void   (  )  {  s . on complete (  )  ;   }  
private void   ( long id )  {  notifyui ( uiprovider   conversation   notifier  long . to string ( id )  )  ;   mailbox mailbox =  mailbox . restore mailbox with id ( get context (  )  id )  ;  if  ( mailbox  =  =  null )   {   log utils . w ( tag " no mailbox for notification: "  +  id )  ;  return ;   }  if  ( mailbox . m type  =  =   mailbox . type   inbox )   {  notifyui ( uiprovider   conversation   notifier  email provider . combined mailbox id (  mailbox . type   inbox )  )  ;   }  notify widgets ( id )  ;   }  
@ override public void   (  )  {  if  ( high quality depth histogram  =  =  null || unfiltered depth histogram  =  =  null )  throw new  picard exception ( " depth histogram is required when deriving metrics . " )  ;  if  ( unfiltered baseq histogram  !  
public  tunnel id   (  )  {  return    tunnel id ;   }  
  (  multi user chat service chatservice  string roomname  packet router packet router )  {  this . muc service = chatservice ;  this . name = roomname ;  this . natural language name = roomname ;  this . description = roomname ;  this . router = packet router ;  this . start time =  system . current time millis (  )  ;  this . creation date = new  date ( start time )  ;  this . modification date = new  date ( start time )  ;  this . empty date = new  date ( start time )  ;  this . can occupants change subject = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . can occupants change subject" false )  ;  this . max users = muc persistence manager . get int property ( muc service . get service name (  )  "room . max users" 30 )  ;  this . public room = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . public room" true )  ;  this . persistent = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . persistent" false )  ;  this . moderated = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . moderated" false )  ;  this . members only = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . members only" false )  ;  this . can occupants invite = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . can occupants invite" false )  ;  this . can anyone discoverjid = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . can anyone discoverjid" true )  ;  this . log enabled = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . log enabled" false )  ;  this . login restricted to nickname = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . login restricted to nickname" false )  ;  this . can change nickname = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . can change nickname" true )  ;  this . registration enabled = muc persistence manager . get boolean property ( muc service . get service name (  )  "room . registration enabled" true )  ;  room history = new muc room history ( this new  history strategy ( muc service . get history strategy (  )  )  )  ;  this . iq owner handler = new iq owner handler ( this packet router )  ;  this . iq admin handler = new iq admin handler ( this packet router )  ;  this . locked time = start time ;  roles to broadcast presence . add ( "moderator" )  ;  roles to broadcast presence . add ( "participant" )  ;  roles to broadcast presence . add ( "visitor" )  ;   }  
@ override public  integer   (  )  {  return generated . get and increment (  )  ;   }  
@ override public void   (  list <  long >  pv )  {   system . out . println ( pv )  ;   }  
private void   ( iq packet )  {   workgroup settings settings = new  workgroup settings (  )  ;  iq reply packet = null ;   element child = packet . get child element (  )  ;   element data element =  (  element ) child . element iterator (  )  . next (  )  ;  if  ( data element  !  =  null )   {  if  ( iq .  type . get . equals ( packet . get type (  )  )  )   {  reply packet = iq . create resultiq ( packet )  ;   element data stored = settings . get ( workgroup . getjid (  )  . to barejid (  )  data element )  ;  data stored . set parent ( null )  ;  child . remove ( data element )  ;  child . set parent ( null )  ;  reply packet . set child element ( child )  ;  child . add ( data stored )  ;   }   }  else  {  reply packet = iq . create resultiq ( packet )  ;  reply packet . set child element ( "query" "jabber:iq:private" )  ;   }  workgroup . send ( reply packet )  ;   }  
public void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( " running the udp sender" )  ;  while  (    keep running )   {  udp packet packet = get next packet (  )  ;  if  ( packet  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " packet to send known: "  +  packet )  ;  long acquire time =    context . clock (  )  . now (  )  ;  int size = packet . get packet (  )  . get length (  )  ;  if  ( size  >  0 )   {  fifo bandwidth limiter .  request req = packet . get bandwidth request (  )  ;  if  ( req  !  =  null )   {  int wait count = 0 ;  while  ( req . get pending requested (  )   >  0 && wait count +  +   <  5 )   {  req . wait for next allocation (  )  ;   }  if  ( wait count  >  =  5 )   {  req . abort (  )  ;     context . stat manager (  )  . add rate data ( "udp . send failsafe" 1 )  ;   }   }   }  long afterbw =    context . clock (  )  . now (  )  ;  if  ( packet . get message type (  )   >  =   packet builder . type   first )     context . stat manager (  )  . add rate data ( "udp . send packet size . "  +  packet . get message type (  )  size packet . get fragment count (  )  )  ;  try  {   datagram packet dp = packet . get packet (  )  ;     socket . send ( dp )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " sent the packet "  +  packet )  ;  long throttle time = afterbw  -  acquire time ;  if  ( throttle time  >  10 )     context . stat manager (  )  . add rate data ( "udp . sendbw throttle time" throttle time acquire time  -  packet . get begin (  )  )  ;  if  ( packet . get marked type (  )   =  =  1 )     context . stat manager (  )  . add rate data ( "udp . sendack time" throttle time packet . get lifetime (  )  )  ;     context . stat manager (  )  . add rate data ( "udp . push time" packet . get lifetime (  )  packet . get lifetime (  )  )  ;     context . stat manager (  )  . add rate data ( "udp . send packet size" size packet . get lifetime (  )  )  ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error sending to "  +  packet . get packet (  )  . get address (  )  ioe )  ;     context . stat manager (  )  . add rate data ( "udp . send exception" 1 packet . get lifetime (  )  )  ;  if  (    socket . is closed (  )  )   {  if  (    keep running )   {     keep running = false ;     endpoint . fail (  )  ;   }   }   }  packet . release (  )  ;   }   }  if  (    log . should log (  log . warn )  )     log . warn ( " stop sending on "  +     endpoint )  ;     outbound queue . clear (  )  ;   }  
private static void   ( byte[] buf  string what  output stream out )  throws io exception  {   print writer wr = new  print writer ( new  output stream writer ( out "utf - 8" )  )  ;  wr . println ( " -  -  -  -  - begin "  +  what  +  " -  -  -  -  - " )  ;   string b64 =  base64 . encode ( buf true )  ;  for  ( int i = 0 ;  i  <  b64 . length (  )  ;  i +  = line   length )   {  wr . println ( b64 . substring ( i  math . min ( i  +  line   length b64 . length (  )  )  )  )  ;   }  wr . println ( " -  -  -  -  - end "  +  what  +  " -  -  -  -  - " )  ;  wr . flush (  )  ;  if  ( wr . check error (  )  )  throw new io exception ( " failed write to "  +  out )  ;   }  
public static void   (  string args[] )  {  boolean rebuild = false ;  if  ( args  !  =  null )   {  boolean error = false ;   getopt g = new  getopt ( "router" args "" )  ;  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  default : error = true ;   }   }  int remaining = args . length  -  g . get optind (  )  ;  if  ( remaining  >  1 )   {  error = true ;   }  else if  ( remaining  =  =  1 )   {  rebuild = args[g . get optind (  ) ] . equals ( "rebuild" )  ;   ;  if  (  ! rebuild )  error = true ;   }  if  ( error )  throw new  illegal argument exception (  )  ;   }   system . out . println ( " starting i2p "  +   router version . full   version )  ;   router r ;  try  {  r = new  router (  )  ;   }  catch  (  illegal state exception ise )   {   system . exit (  - 1 )  ;  return ;   }  if  ( rebuild )   {  r . rebuild new identity (  )  ;   }  else  {   install update . install updates ( r )  ;  r . run router (  )  ;   }   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends r >  on next mapper  function <  ?  super  throwable  ?  extends r >  on error mapper  callable <  ?  extends r >  on complete supplier )  {  super ( actual )  ;  this . on next mapper = on next mapper ;  this . on error mapper = on error mapper ;  this . on complete supplier = on complete supplier ;   }  
public void   (  )  {  mutex . lock (  )  ;   }  
@ suppress warnings ( "unchecked" )  public void   (  string property  map params )  {  property deleted ( property params )  ;   }  
public  string   (  )  {  return uri ;   }  
@ suppress warnings ( "unchecked" )  @ test @ ignore ( "concat ( a  b   .  .  .  )  replaced by concat array ( t .  .  .  ) " )  public void   (  )  throws  exception  {  for  ( int i = 2 ;  i  <  10 ;  i +  +  )   {   class <  ?  > [] clazz = new  class[
public static  map <  string  string >    (  )  {  if  ( group to super category  =  =  null )   {  group to super category = new  hash map <  >  (  )  ;  group to super category . put ( doc   cat   base   calling doc   supercat   tools )  ;  group to super category . put ( doc   cat   diagnostics   and   qc doc   supercat   tools )  ;  group to super category . put ( doc   cat   intervals   manipulation doc   supercat   tools )  ;  group to super category . put ( doc   cat   other doc   supercat   tools )  ;  group to super category . put ( doc   cat   read   data   manipulation doc   supercat   tools )  ;  group to super category . put ( doc   cat   reference doc   supercat   tools )  ;  group to super category . put ( doc   cat   read   data   manipulation doc   supercat   tools )  ;  group to super category . put ( doc   cat   variant   filtering doc   supercat   tools )  ;  group to super category . put ( doc   cat   variant   evaluation doc   supercat   tools )  ;  group to super category . put ( doc   cat   variant   manipulation doc   supercat   tools )  ;  group to super category . put ( doc   cat   test doc   supercat   exclude )  ;   }  return group to super category ;   }  
@ data provider ( name = " " )  public  object[][] failing verify tiles (  )  {  return new  object[][] {  { new  integer[] { 1 }  new  integer[] { 2 }  }   { new  integer[] { 2 }  new  integer[] { 1 }  }   { new  integer[] { 4 }  new  integer[] { 5 }  } 
static  vcf file segment   ( final sam sequence record sequence final  file vcf )  {  return new  sequence sized chunk ( sequence vcf )  ;   }  
private boolean   (  )  throws io exception  {  final byte[] png   magic =  { 0x4e 0x47 0x0d 0x0a 0x1a 0x0a }  ;  byte[] a = new byte[27] ;  if  ( read ( a )   !  =  27 )   {  return false ;   }  if  (  ! equals ( a 0 png   magic 0 6 )  )   {  return false ;   }  format = format   png ;  width = get int big endian ( a 14 )  ;  height = get int big endian ( a 18 )  ;  bits per pixel = a[22] & 0xff ;  int color type = a[23] & 0xff ;  if  ( color type  =  =  2 || color type  =  =  6 )   {  bits per pixel* = 3 ;   }  progressive =  ( a[26] & 0xff )   !  =  0 ;  return true ;   }  
public   (  string server name  offline message store offline messages store v card manager v card manager  private storage private storage  user manager user manager  roster item provider roster item provider )  {  super (  )  ;  this . server name = server name ;  this . offline messages store = offline messages store ;  this . v card manager = v card manager ;  this . user manager = user manager ;  this . roster item provider = roster item provider ;   }  
  ( e val )  {  sp value ( val )  ;   }  
@delete @ path ( " / group /  { groupname } " )  public  response   ( @ path param ( "groupname" )   string groupname @ default value ( "conference" )  @ query param ( "servicename" )   string service name @ path param ( "room name" )   string room name )
  (  completable observer t )  {  this . actual = t ;   }  
public boolean   (  string hostname  destination d  properties options )  {  return false ;   }  
@ non null @ override public  worker   (  )  {  return new  slow inner ( actual . create worker (  )  )  ;   }  
public  list <  chat setting >    (  chat settings .  setting type type )  {  final  list <  chat setting >  return list = new  array list <  chat setting >  (  )  ;  for  (   chat setting setting : settings list . values (  )  )   {  if  ( setting . get type (  )   =  =  type )   {  return list . add ( setting )  ;   }   }   collections . sort ( return list chat setting comparator )  ;  return return list ;   }  
public   (  registration registration jid jid  base transport < b >  transport  integer priority )  {  this . jid = new jid ( jid . to barejid (  )  )  ;  this . registration = registration ;  this . transport ref = new  weak reference <  base transport < b >  >  ( transport )  ;  muc session manager = new muc transport session manager < b >  ( this )  ;  add resource ( jid . get resource (  )  priority )  ;  load avatar (  )  ;   log . debug ( " created "  +  transport . get type (  )   +  " session for " +  jid +  " as '" +  registration . get username (  )  +  "'" )  ;  set supported feature (  supported feature . vcardtemp )  ;   }  
private static  string   (  string username )  {  final  list <  string >  args = new  array list <  >  (  )  ;  args . add ( username )  ;  args . add (  jive globals . format date time ( new java . util .  date (  )  )  )  ;  return  locale utils . get localized string ( "log . marker   inserted   by" args )  ;   }  
@ override public iq   ( iq packet )  throws  unauthorized exception  {  return xmpp server . get instance (  )  . getiqpep handler (  )  . handleiq ( packet )  ;   }  
@ suppress warnings ( "deprecation" )  @ test public void   (  )  throws  exception  {  byte[] temp = null ;   byte array output stream baos = new  byte array output stream (  )  ;   data helper . write boolean ( baos  boolean . true )  ;  temp = baos . t
private void   (  )  {  if  ( allow on match && mask enabled )   {  content filter . set mask ( mask )  ;   }  else  {  content filter . clear mask (  )  ;   }   }  
public   (  router context ctx  hash peer  router info pinfo int mask )  {  super ( 4 )  ;  if  ( pinfo  =  =  null )  return ;  byte[] commip = ctx . comm system (  )  . getip ( peer )  ;  if  ( commip  !  =  null )  add ( maskedip ( commip mask )  )  ;   collection <  router address >  paddr = pinfo . get addresses (  )  ;  for  (   router address pa : paddr )   {  byte[] pib = pa . getip (  )  ;  if  ( pib  =  =  null )  continue ;  add ( maskedip ( pib mask )  )  ;  int port = pa . get port (  )  ;  if  ( port  >  0 )  add ( "p"  +  port )  ;  if  ( pa . get cost (  )   =  =  2 && "ntcp" . equals ( pa . get transport style (  )  )  )  add ( " = cost2" )  ;   }   string family = pinfo . get option ( "family" )  ;  if  ( family  !  =  null )   {  add ( 'x'  +  family )  ;   }   }  
public void   (  event listener listener )  {  event listener list . add ( listener )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . single element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public void   (  subscriber <  ?  super  long >  s )  {  if  ( s instanceof  conditional subscriber )   {  s . on subscribe ( new  range conditional subscription (  (  conditional subscriber <  ?  super  long >  ) s start end )  )  ;   }  else 
public void   (  string val )  {  if  ( val  !  =  null )   {  try  {     config . set reduce count (  integer . parse int ( val . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
@ setup public void   (  )  {   integer[] array = new  integer[times] ;   arrays . fill ( array 777 )  ;   flowable <  integer >  source =  flowable . from array ( array )  ;  final  bi function <  integer  integer  integer >  second = new  bi function < 
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c =  completable . defer ( new  callable <  completable >  (  )  {  @ override public  completable call (  )  {  return error . completable ;   }   }   )  ; 
@ override public boolean   (  )  {  return is cancelled (  )  || is done . get (  )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  observer )  {  observer
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts = pp . ignore elements (  )  .  <  integer > to flowable (  )  . test (  )  ;  assert true ( pp . has subscribers ( 
@ override public void   (  )  {  if  ( cancelled )   {  return ;   }  cancelled = true ;  cancel all (  )  ;  if  ( get and increment (  )   =  =  0 )   {  queue . clear (  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . range ( 1 5 )  . buffer ( 1 1  time unit . minutes )  . test (  )  . assert result (  arrays . as list ( 1 2 3 4 5 )  )  ;   }  
private static long   ( byte ip1[] byte ip2[] )  {  long entry = 0 ;  for  ( int i = 0 ;  i  <  4 ;  i +  +  )  entry| =  (  ( long )  ( ip2[i] & 0xff )  )   <  <   (  ( 3  -  i )  * 8 )  ;  for  ( int i = 0 ;  i  <  4 ;  i +  +  )  entry| =  (  ( long )  ( ip1[i] & 0xff )  )   <  <   ( 32  +   (  ( 3  -  i )  * 8 )  )  ;  return entry ;   }  
private void   (  )  {  try  {  final  file single locs file = new  file ( intensity dir  abstract illumina position file reader . s   locs   file )  ;  final  file writer writer = new  file writer ( single locs file )  ;  writer . write ( " this is a test string . " )  ;  writer . close (  )  ;   }  catch  (  final io exception e )   {  e . print stack trace (  )  ;   }   }  
public  snark   (  string name byte[] ih  string trackerurl boolean update status boolean auto start  file data dir  complete listener listener )  {   string dir path = data dir  !  =  null  ?  data dir . get absolute path (  )  : get data dir (  )  . get path (  )  ;   snark torrent = new  snark (    util name ih trackerurl listener    peer coordinator set    connection acceptor false dir path )  ;  synchronized  (    snarks )   {   snark snark = get torrent by info hash ( ih )  ;  if  ( snark  !  =  null )   {  add message (    t ( " torrent with this info hash is already running:  { 0 } " snark . get base name (  )  )  )  ;  return null ;   }     magnets . add ( name )  ;  if  ( update status )  save magnet status ( ih dir path trackerurl name )  ;     snarks . put ( name torrent )  ;   }  if  ( auto start )   {  start torrent ( ih )  ;  if  ( false )  add message (    t ( " fetching  { 0 } " name )  )  ;  dht dht =    util . getdht (  )  ;  boolean should warn =    util . connected (  )  &&    util . get open trackers (  )  . is empty (  )  &&  (  (  !    util . should usedht (  )  )  || dht  =  =  null || dht . size (  )   <  =  0 )  ;  if  ( should warn )   {  add message (    t ( " open trackers are disabled and we have no dht peers .  "  +  " fetch of  { 0 }  may not succeed until you start another torrent  enable open trackers  or enable dht . " name )  )  ;   }   }  else  {  add message (    t ( " adding  { 0 } " name )  )  ;   }  return torrent ;   }  
@ test public void   (  )  {   flowable . range ( 1 1024 )  . concat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . ju
public   (  observable source <  ?  extends t >  main  observable source < u >  other )  {  this . main = main ;  this . other = other ;   }  
public void   ( long end msg )  {     congestion window end = end msg ;   }  
public boolean   (  hop config cfg )  {  if  (    log . should log (  log . info )  )     log . info ( " joining as participant: "  +  cfg )  ;   tunnel id recv id = cfg . get receive tunnel (  )  ;   tunnel participant participant = new  tunnel participant (    context cfg new  hop processor (    context cfg    validator )  )  ;  synchronized  (    join participant lock )   {  if  (    participating config . put if absent ( recv id cfg )   !  =  null )  return false ;  if  (    participants . put if absent ( recv id participant )   !  =  null )   {     participating config . remove ( recv id )  ;  return false ;   }   }     context . message history (  )  . tunnel joined ( "participant" cfg )  ;     context . stat manager (  )  . add rate data ( "tunnel . join participant" 1 )  ;  if  ( cfg . get expiration (  )   >     last participating expiration )     last participating expiration = cfg . get expiration (  )  ;     leave job . add ( cfg )  ;  return true ;   }  
@ test public void   (  )  {  int num failures = 1 ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   flowable <  string >  origin =  flowable . unsafe create ( new  func with errors ( num failures )  )  ;  origin . retry ( 3 
void   (  node child )  {   message message = new  message (  )  ;   element event = message . add child element ( "event" "http: /  / jabber . org / protocol / pubsub#event" )  ;   element item = event . add element ( "items" )  . add element ( "item" )  ;  item . add attribute ( "id" child . get nodeid (  )  )  ;  if  ( deliver payloads )   {  item . add ( child . get metadata form (  )  . get element (  )  )  ;   }  broadcast collection node event ( child message )  ;   }  
@ override public boolean   ( final android . os .  message message )  {   log utils . d ( log   tag " delayed notification processing" )  ;  synchronized  ( s notification delayed message lock )   {  s notification delayed message pending = false ;  fina
public int   (  )  {  return    send ack delay ;   }  
public synchronized  string[]   (  )  {  return rrd map . key set (  )  . to array ( new  string[0] )  ;   }  
@ override public void   (  session data data  element command )  {   element note = command . add element ( "note" )  ;   list <  string >  nodei ds = data . get data (  )  . get ( "pubsub#node" )  ;  if  ( nodei ds . is empty (  )  )   {  note . add att
public  call participant   (  )  {  return handset ;   }  
@ test public void   (  )  {   lease set subj = new  lease set (  )  ;  exception . expect (  index out of bounds exception . class )  ;  subj . get lease ( 0 )  ;   }  
@ override public boolean   (  object o )  {  if  ( cancelled )   {  return true ;   }  if  (  notification lite . is complete ( o )  )   {  actual . on complete (  )  ;  return true ;   }  else if  (  notification lite . is error ( o )  )   {  actual . o
public void   ( i2p session arg0  string arg1  throwable arg2 )  {   log log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  log . error ( arg1 arg2 )  ;     running = false ;  thread . interrupt (  )  ;   }  
@ override public  string   (  string raw name  statement context ctx )  {  return ":"  +  raw name ;   }  
@ test public void   (  )  {  final  atomic integer counter = new  atomic integer (  )  ;   observable . range ( 1 5 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  counter . get 
@ test public void   (  )  throws  exception  {  check internal operator naming ( " observable" " flowable" " observable from publisher" )  ;   }  
@ override public void   (  observer <  ?  super  boolean >  s )  {   equal coordinator < t >  ec = new  equal coordinator < t >  ( s buffer size first second comparer )  ;  s . on subscribe ( ec )  ;  ec . subscribe (  )  ;   }  
private static int   (  )  {  return  jive globals . get int property ( "workgroup . search . pending . transcripts" 5 )  ;   }  
  (  subscription s )  {  this . s = s ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just ( 1 )  . zip with (  arrays . as list ( 1 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  throws  exc
public  presence   (  string sender  string jid )  throws  user not found exception  {  if  ( jid  =  =  null )   {  throw new  user not found exception ( " target jid not found in request" )  ;   }  jid targetjid = new jid ( jid )  ;  if  ( targetjid . get domain (  )   =  =  null || xmpp server . get instance (  )  . is remote ( targetjid )  )   {  throw new  user not found exception ( " domain does not matches local server domain" )  ;   }  if  (  ! hostname . equals ( targetjid . get domain (  )  )  )   {  presence manager . probe presence ( componentjid targetjid )  ;  int count = 0 ;   presence presence = probed presence . get ( jid )  ;  while  ( presence  =  =  null )   {  if  ( count  >  300 )   {  throw new  user not found exception ( " request for component presence has timed - out . " )  ;   }  try  {   thread . sleep ( 100 )  ;   }  catch  (   interrupted exception e )   {   }  presence = probed presence . get ( jid )  ;  count +  +  ;   }  probed presence . remove ( jid )  ;  return presence ;   }  if  ( targetjid . get node (  )   =  =  null ||  !  user manager . get instance (  )  . is registered user ( targetjid . get node (  )  )  )   {  throw new  user not found exception ( " username is null" )  ;   }  if  (  ! is presence public (  )  )   {  if  ( sender  =  =  null )   {  throw new  user not found exception ( " sender is null" )  ;   }  else  {  jid senderjid = new jid ( sender )  ;  if  (  ! senderjid . get node (  )  . equals ( targetjid . get node (  )  )  &&  ! presence manager . can probe presence ( new jid ( sender )  targetjid . get node (  )  )  )   {  throw new  user not found exception ( " sender is not allowed to probe this user" )  ;   }   }   }   user user = user manager . get user ( targetjid . get node (  )  )  ;  return presence manager . get presence ( user )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
private void   ( int[] c )  {   system . out . println ( "\nleft "  +  c . length )  ;  for  ( int i = 0 ;  i  <  c . length ;  i +  = 2 )   {   system . out . print (  integer . to hex string ( c[i] & 0xff )   +  " " )  ;   }   system . out . println ( "\n\nright "  +  c . length )  ;  for  ( int i = 1 ;  i  <  c . length ;  i +  = 2 )   {   system . out . print (  integer . to hex string ( c[i] & 0xff )   +  " " )  ;   }   system . out . println ( "\n" )  ;   }  
private static void   (  )  {   encryptor key encryptor = new  aes encryptor (  )  ;   string encrypted key = security properties . get property ( encryption   key   current )  ;  if  ( encrypted key  =  =  null || encrypted key . is empty (  )  )   {  current key = null ;   }  else  {  current key = key encryptor . decrypt ( encrypted key )  ;   }   string new key = security properties . get property ( encryption   key   new false )  ;  if  ( new key  !  =  null )   {   log . info ( " detected new encryption key ;  updating encrypted properties" )  ;   string old key = security properties . get property ( encryption   key   old )  ;  if  ( old key  =  =  null )   {  if  ( current key  !  =  null )   {   log . warn ( " old encryption key was not provided ;  ignoring new encryption key" )  ;  return ;   }   }  else  {  if  (  ! old key . equals ( current key )  )   {   log . warn ( " old encryption key does not match current encryption key ;  ignoring new encryption key" )  ;  return ;   }   }  if  ( properties  =  =  null )   {  properties =  jive properties . get instance (  )  ;   }   map <  string  string >  openfire props = new  hash map <  >  (  )  ;  for  (   string xml prop : openfire properties . get all property names (  )  )   {  if  ( is property encrypted ( xml prop )  )   {  openfire props . put ( xml prop openfire properties . get property ( xml prop )  )  ;   }   }  current key = new key  =  =  null || new key . is empty (  )   ?  null : new key ;  property encryptor = null ;  for  (   string property name : security properties . get properties ( encrypted   property   names true )  )   {   log . info ( " updating encrypted value for "  +  property name )  ;  if  ( openfire props . contains key ( property name )  )   {  openfire properties . set property ( property name openfire props . get ( property name )  )  ;   }  else if  (  ! reset property ( property name )  )   {   log . warn ( " failed to reset encrypted property value for "  +  property name )  ;   }   }  security properties . delete property ( encryption   key   new )  ;  security properties . delete property ( encryption   key   old )  ;   }  security properties . set property ( encryption   key   current key encryptor . encrypt ( current key )  )  ;   }  
@ override public  string   (  )  {  return " something { "  +  "id = "  +  id  +  "  name = '" +  name +  '\'' +  "  integer value = " +  integer value +  "  int value = " +  int value +  ' } ' ;   }  
public   (  localmuc room room )  {  this . room = room ;   }  
@ override public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  maybe < t >    ( final  maybe source <  ?  extends t >  next )  {   object helper . require non null ( next "next is null" )  ;  return  rx java plugins . on assembly ( 
public void   (  connection event listener lsnr )  {  if  ( lsnr  =  =  null )  return ;  listeners . add ( lsnr )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
protected void   ( int[] families )  {  this . snac families = families . clone (  )  ;   arrays . sort ( snac families )  ;   }  
@ override public void   ( char[] ch int start int length )  throws sax exception  {  super . ignorable whitespace ( ch start length )  ;   }  
public  string   (  )  {  return    filter ;   }  
@ override public  collection < jid >    (  )  {  return  collections . unmodifiable collection ( allowed to create )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flat map ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return null ;   }   }   )  . test (
public   (  )  {  set status code ( http status . ok )  ;  set cache control (  device . default   lease   time )  ;  set header ( http . server u pnp . get server name (  )  )  ;  set header ( http . ext "" )  ;   }  
public void   (  )  {  final  context c = m mock context ;   account a =  provider test utils . setup account ( "acct" true c )  ;   message m1 =  provider test utils . setup message ( "1" a . m id 1 true true c false false )  ;   message m2 =  provider test utils . setup message ( "1" a . m id 2 true true c false false )  ;   provider test utils . assert account equal ( "x" a  account . get account for message id ( c m1 . m id )  )  ;   provider test utils . assert account equal ( "x" a  account . get account for message id ( c m2 . m id )  )  ;   }  
public static void   (  )  {  s instance = null ;   }  
@ test public void   (  )  throws  exception  {   signing private key signing private key = new  signing private key (  )  ;   byte array input stream in = new  byte array input stream (  data helper . getascii ( "short" )  )  ;  exception . expect ( eof 
private void   (  file key dir )  {  sync private key ( key dir )  ;  sync public key ( key dir )  ;   sig type type =  create router info job . get sig type config ( get context (  )  )  ;  sync signing key ( key dir type )  ;  sync verification key ( key dir type )  ;   }  
@ override protected void   (  observer <  ?  super t >  t )  {   replay disposable < t >  rp = new  replay disposable < t >  ( t state )  ;  t . on subscribe ( rp )  ;  state . add child ( rp )  ;  if  (  ! once . get (  )  && once . compare and set ( fa
private void   (  document pool document pool  list <  string >  uris )  {  for  (   string uri : uris )   {   document info document info = document pool . find ( uri )  ;  if  ( document info  !  =  null )   {  log . trace ( " removing document  {  } " uri )  ;  document pool . discard ( document info )  ;   }  else  {  log . trace ( " tried to remove document  {  }  but wasn't present . " uri )  ;   }   }   }  
public void   (  externalizable util strategy strategy )  {  this . strategy = strategy ;   }  
@ override public void   (  subscriber <  ?  super  long >  o )  {   system . out . println ( "*********  start  source  data ***********" )  ;  for  ( long l = 1 ;  l  <  =  10000 ;  l +  +  )   {  o . on next ( l )  ;   }   system . out . println ( "***
@ override public void   (  )  {  s . cancel (  )  ;  done = true ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  if  (  ! once . get (  )  && once . compare and set ( false true )  )   {  s . on subscribe ( wip )  ;  actual . set ( s )  ;  if  ( cancelled )   {  actual . lazy set ( null )  ;   }  els
  (  subscriber <  ?  super c >  actual  publisher <  ?  extends  open >  buffer open  function <  ?  super  open  ?  extends  publisher <  ?  extends  close >  >  buffer close  callable < c >  buffer supplier )  {  this . actual = actual ;  this . buffer supplier = buffer supplier ;  this . buffer open = buffer open ;  this . buffer close = buffer close ;  this . queue = new  spsc linked array queue < c >  ( buffer size (  )  )  ;  this . subscribers = new  composite disposable (  )  ;  this . requested = new  atomic long (  )  ;  this . upstream = new  atomic reference <  subscription >  (  )  ;  this . buffers = new  linked hash map <  long c >  (  )  ;  this . errors = new  atomic throwable (  )  ;   }  
public static  byte[]   (  long value )  {  byte bytes[] = new byte[8] ;   byte buffer . wrap ( bytes )  . put long ( value . long value (  )  )  ;  return bytes to array ( bytes )  ;   }  
@ override protected void   (  subscriber <  ?  super r >  s )  {  source . subscribe ( new  flat map iterable observer < t r >  ( s mapper )  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  maybe < r >    ( final  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper )  {   object helper . require non null ( mapper "mapper is 
@ override public void   (  subscription s )  {  sa . set subscription ( s )  ;   }  
public  string   (  )  {  return name ;   }  
public  sql array types   (  sql array argument strategy argument strategy )  {  this . argument strategy = argument strategy ;  return this ;   }  
@ override public void   ( t t )  {   completable source c ;  try  {  c =  object helper . require non null ( mapper . apply ( t )  " the mapper returned a null  completable source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( e
public void   (  string host )  {   jive globals . set property ( "plugin . email . listener . host" host )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . error (  (  callable <  throwable >  ) null )  ;   }  
@ override public void   ( long n )  {   subscription helper . deferred request ( s requested n )  ;   }  
public   (  disposable resource )  {  this (  )  ;  this . resource . lazy set ( resource )  ;   }  
  (  subscriber <  ?  super t >  actual long count  subscription arbiter sa  publisher <  ?  extends t >  source )  {  this . actual = actual ;  this . sa = sa ;  this . source = source ;  this . remaining = count ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable observable <  integer >  co =  observable .  <  integer > empty (  )  . publish (  )  ;   runnable r1 = new  runnable (  )  
@ suppress warnings ( "unchecked" )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    (  observable source <  ?  extends t >  .  .  .  sources )  {   object helper . require non null ( sourc
private static final  string   (  string s )  {  return s ;   }  
@ override public void   ( final long message id final long attachment id final int status code final int progress )  {  debug trace ( log   tag " service callback for attachment #%d" attachment id )  ;  final  download request req = m downloads in progre
@ override public  string   (  )  {  return  collect sequencing artifact metrics . class . get simple name (  )  ;   }  
public   (  path file )  throws io exception  {  this . file = file ;  if  (  files . not exists ( file )  )   {   path temp file ;  temp file = file . get parent (  )  . resolve ( file . get file name (  )   +  " . tmp" )  ;  if  (  files . exists ( temp file )  )   {   log . error ( "warning: "  +  file . get file name (  )   +  " was not found  but temp file from " +  "previous write operation was .   attempting automatic recovery . " +  "  please check file for data consistency . " )  ;   files . move ( temp file file  standard copy option . replace   existing )  ;   }  else  {  throw new  no such file exception ( "xml properties file does not exist: "  +  file . get file name (  )  )  ;   }   }  if  (  !  files . is readable ( file )  )   {  throw new io exception ( "xml properties file must be readable: "  +  file . get file name (  )  )  ;   }  if  (  !  files . is writable ( file )  )   {  throw new io exception ( "xml properties file must be writable: "  +  file . get file name (  )  )  ;   }  try  (  reader reader =  files . new buffered reader ( file  standard charsets . utf   8 )  )  {  build doc ( reader )  ;   }   }  
@ override public void   (  throwable e )  {  parent . inner error ( e )  ;   }  
public   (  )  {  super ( i2p app context . get global context (  )  . simple timer2 (  )  get max idle (  )   +  5 * 1000 )  ;   }  
public boolean   (  )  {  return enabled ;   }  
@ test public void   (  )  {  final  disposable[] disposable =  { null }  ;   observable . just ( 1 )  . hide (  )  . concat map completable ( completable complete (  )  )  . subscribe ( new  completable observer (  )  {  @ override public void on subscri
public  log manager   (  )  {  if  (  !    log manager initialized )  initialize log manager (  )  ;  return    log manager ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . hide (  )  . concat map ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   integer v )  throws  exception  {  throw
public void   (  hash peer long response time ms int severity )  {   peer profile data = get profile ( peer )  ;  data . set last heard from (    context . clock (  )  . now (  )  )  ;  data . get tunnel history (  )  . increment rejected ( severity )  ;   }  
public  object   (  )  {  sip alert info alertinfo =  ( sip alert info ) super . clone (  )  ;  if  ( name pair  !  =  null )  alertinfo . name pair = this . name pair ;  return alertinfo ;   }  
@ test public void   (  )  {   completable . never (  )  . timeout ( 1  time unit . milliseconds  completable . error ( new  test exception (  )  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert failure (  test exception . class )  ;  
@ override public void   (  subscription s )  {  serial . set subscription ( s )  ;   }  
@ override public void   ( t t )  {  value = t ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception 
public boolean   (  )  {  return violation notification byim enabled ;   }  
@ override public void   ( byte[] data )  {  super . set data ( data )  ;     base64ed = null ;     cached hash code = super . hash code (  )  ;   }  
private byte[]   ( byte data[]  session key key  private key target private key  set <  session tag >  found tags  session key used key  session key found key )  throws  data format exception  {  byte preiv[] =  simple byte cache . acquire ( 32 )  ;   system . arraycopy ( data 0 preiv 0 32 )  ;  byte[] iv = half hash ( preiv )  ;   simple byte cache . release ( preiv )  ;  byte decrypted[] = decryptaes block ( data 32 data . length  -  32 key iv preiv found tags found key )  ;   simple byte cache . release ( iv )  ;  if  ( decrypted  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " decrypting looks negative .  .  .  existing key fails with existing tag  lets try as a new one" )  ;  byte rv[] = decrypt new session ( data target private key found tags used key found key )  ;  if  (    log . should log (  log . warn )  )   {  if  ( rv  =  =  null )     log . warn ( " decrypting failed with a known existing tag as either an existing message or a new session" )  ;  else    log . warn ( " decrypting suceeded as a new session  even though it used an existing tag ! " )  ;   }  return rv ;   }  used key . set data ( key . get data (  )  )  ;  return decrypted ;   }  
void   (  print stream s )  {  s . print ( "\t\t\t < ds >  < value >  " )  ;  s . print ( value )  ;  s . print ( "  <  / value >   < unknown   datapoints >  " )  ;  s . print ( unknown datapoints )  ;  s . println ( "  <  / unknown   datapoints >  <  / ds > " )  ;   }  
default  < t >  result iterable < t >    (  class < t >  type )  {  return map (  bean mapper . of ( type )  )  ;   }  
private  media info   (  string media preference )  throws  parse exception  {  if  ( media preference  =  =  null )   {  if  ( media info  !  =  null )   {  return media info ;   }  return  sdp manager . find media info (  rtp packet . pcmu   encoding 8000 1 )  ;   }  int ix ;  int encoding =  rtp packet . pcmu   encoding ;  int sample rate = 8000 ;  int channels = 1 ;  try  {  if  ( media preference . index of ( "pcmu / " )   =  =  0 )   {  encoding =  rtp packet . pcmu   encoding ;  media preference = media preference . substring ( 5 )  ;   }  else if  ( media preference . index of ( "pcm / " )   =  =  0 )   {  encoding =  rtp packet . pcm   encoding ;  media preference = media preference . substring ( 4 )  ;   }  else if  ( media preference . index of ( "speex / " )   =  =  0 )   {  encoding =  rtp packet . speex   encoding ;  media preference = media preference . substring ( 6 )  ;   }  else if  ( media preference . index of ( "pcm" )   =  =  0 )   {   }  else  {   logger . println ( " invalid media specification "  +  media preference )  ;   }  if  (  ( ix = media preference . index of ( " / " )  )   <  0 )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  else  {  sample rate =  integer . parse int ( media preference . substring ( 0 ix )  )  ;  channels =  integer . parse int ( media preference . substring ( ix  +  1 )  )  ;   }   }  catch  (   index out of bounds exception e )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  catch  (   number format exception e )   {   logger . println ( " invalid media specification "  +  media preference )  ;   }  if  ( sample rate  =  =  8000 && channels  =  =  1 && encoding  =  =   rtp packet . pcm   encoding )   {  encoding =  rtp packet . pcmu   encoding ;   }   media info media info =  sdp manager . find media info ( encoding sample rate channels )  ;   logger . println ( "conference "  +  conference id  +  " using media settings " +  media info )  ;  conference start time =  system . current time millis (  )  ;  return media info ;   }  
@ test @ ignore ( " failed operator may leave the child subscriber in an inconsistent state which prevents further error delivery . " )  public void   (  )  {   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   flowable . just 
public void   (  hash peer  tunnel id tunnel )  {  if  (  !    do log )  return ;  if  (  ( tunnel  =  =  null )  ||  ( peer  =  =  null )  )  return ;   string builder buf = new  string builder ( 128 )  ;  buf . append ( get prefix (  )  )  ;  buf . append ( "tunnel [" )  . append ( tunnel . get tunnel id (  )  )  . append ( "] timed out on [" )  ;  buf . append ( get name ( peer )  )  . append ( "]" )  ;  add entry ( buf . to string (  )  )  ;   }  
public static  repose container props   (  string[] args )  throws  parse exception  {   options options = new  options (  )  ;   command line parser parser = new  basic parser (  )  ;   option port opt = new  option ( "p" true " repose port to listen on" )  ;   option rootwar opt = new  option ( "w" true " location of root . war" )  ;   option config dir opt = new  option ( "d" true " location of the configuration directory" )  ;   option cluster id opt = new  option ( "c" true " cluster id of the node being launched" )  ;   option node id opt = new  option ( "n" true " node id of the node being launched" )  ;   option application wars opt = new  option ( "war" true "" )  ;  port opt . set required ( true )  ;  rootwar opt . set required ( true )  ;  cluster id opt . set required ( true )  ;  node id opt . set required ( true )  ;  options . add option ( port opt )  . add option ( rootwar opt )  . add option ( config dir opt )  . add option ( cluster id opt )  . add option ( node id opt )  . add option ( application wars opt )  ;  final  command line cmdline ;  cmdline = parser . parse ( options args )  ;  return new  repose container props ( cmdline . get option value ( "p" )  cmdline . get option value ( "w" )  cmdline . get option value ( "d" )  cmdline . get option value ( "c" )  cmdline . get option value ( "n" )  cmdline . get option values ( "war" )  )  ;   }  
@ override public void   (  )  {  try  {   system . out . println ( "running  test observable thread" )  ;  for  (   string s : values )   {  if  ( "exception" . equals ( s )  )   {  throw new  exception ( " forced  exception" )  ;   }  else if  ( "runtim
protected void   (  )  {  if  (    state . completed (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( get job id (  )   +  ":  already completed" )  ;  return ;   }  if  (    state . is aborted (  )  )   {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  search aborted" )  ;     state . complete (  )  ;  fail (  )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  searching: "  +     state )  ;  if  ( is local (  )  )   {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  key found locally" )  ;     state . complete (  )  ;  succeed (  )  ;   }  else if  ( is expired (  )  )   {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  key search expired" )  ;     state . complete (  )  ;  fail (  )  ;   }  else if  (    state . get attempted (  )  . size (  )   >  max   peers   queried )   {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  too many peers quried" )  ;     state . complete (  )  ;  fail (  )  ;   }  else  {  continue search (  )  ;   }   }  
public void   (  public key encryption key )  {  if  (    signature  !  =  null )  throw new  illegal state exception (  )  ;     encryption key = encryption key ;   }  
public   ( i2p app context ctx )  {  super (  )  ;     context = ctx ;     port mapper = ctx . port mapper (  )  ;     listen hosts = new  hash set <  string >  ( 8 )  ;  set min gzip size ( 64 * 1024 )  ;  if  (    context . get boolean property default true ( prop   gzip )  )   {  add included mime types ( "application / xhtml + xml" "application / xml" "text / css" "text / html" "text / plain" )  ;   }  else  {  add included mime types ( "xyzzy" )  ;   }   }  
private  imap element   (  )  throws io exception   messaging exception  {  final int next = peek (  )  ;  switch  ( next )   {  case ' ( ': return parse list ( ' ( ' ' ) ' )  ;  case '[': return parse list ( '[' ']' )  ;  case '"': read byte (  )  ;  return new  imap simple string ( read until ( '"' )  )  ;  case ' { ': return parse literal (  )  ;  case '\r': read byte (  )  ;  expect ( '\n' )  ;  return null ;  case '\n': read byte (  )  ;  return null ;  default : return parse bare string (  )  ;   }   }  
private int   (  data input stream in  data output stream out )  throws io exception  {  int socks ver = in . read unsigned byte (  )  ;  if  ( socks ver  !  =  socks   version   5 )   {     log . debug ( "error in socks5 request  ( protocol  !  =  5 ?  ) " )  ;  throw new socks exception ( " invalid protocol version in request: "  +  socks ver )  ;   }  int command = in . read unsigned byte (  )  ;  switch  ( command )   {  case  command . connect: break ;  case  command . bind:    log . debug ( "bind command is not supported ! " )  ;  send request reply (  reply . command   not   supported  address type . domainname null "0 . 0 . 0 . 0" 0 out )  ;  throw new socks exception ( "bind command not supported" )  ;  case  command . udp   associate: break ;  default :    log . debug ( "unknown command in request  ( "  +   integer . to hex string ( command )   +  " ) " )  ;  send request reply (  reply . command   not   supported  address type . domainname null "0 . 0 . 0 . 0" 0 out )  ;  throw new socks exception ( " invalid command in request" )  ;   }  in . read byte (  )  ;  address type = in . read unsigned byte (  )  ;  switch  ( address type )   {  case  address type . ipv4:  string builder builder = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  4 ;   +  + i )   {  int octet = in . read unsigned byte (  )  ;  builder . append (  integer . to string ( octet )  )  ;  if  ( i  !  =  3 )   {  builder . append ( " . " )  ;   }   }  conn host name = builder . to string (  )  ;   string mapped domain name = get mapped domain name forip ( conn host name )  ;  if  ( mapped domain name  !  =  null )   {     log . debug ( "ipv4 address "  +  conn host name  +  " was mapped to domain name " +  mapped domain name )  ;  address type =  address type . domainname ;  conn host name = mapped domain name ;   }  else if  ( command  !  =   command . udp   associate )     log . warn ( "ipv4 address type in request: "  +  conn host name  +  " .   is your client secure ? " )  ;  break ;  case  address type . domainname:  {  int addr len = in . read unsigned byte (  )  ;  if  ( addr len  =  =  0 )   {     log . debug ( "0 - sized address length ? " )  ;  throw new socks exception ( " illegal domainname length" )  ;   }  byte addr[] = new byte[addr len] ;  in . read fully ( addr )  ;  conn host name =  data helper . getutf8 ( addr )  ;   }     log . debug ( "domainname address type in request: "  +  conn host name )  ;  break ;  case  address type . ipv6: if  ( command  !  =   command . udp   associate )   {     log . warn ( "ip v6 address type in request !   is your client secure ? "  +  "  ( i pv6 is not supported  anyway : -  ) " )  ;  send request reply (  reply . address   type   not   supported  address type . domainname null "0 . 0 . 0 . 0" 0 out )  ;  throw new socks exception ( "ipv6 addresses not supported" )  ;   }  break ;  default :    log . debug ( "unknown address type in request  ( "  +   integer . to hex string ( command )   +  " ) " )  ;  send request reply (  reply . address   type   not   supported  address type . domainname null "0 . 0 . 0 . 0" 0 out )  ;  throw new socks exception ( " invalid addresses type in request" )  ;   }  conn port = in . read unsigned short (  )  ;  if  ( conn port  =  =  0 )   {     log . debug ( "trying to connect to tcp port 0 ?   dropping ! " )  ;  send request reply (  reply . connection   not   allowed   by   ruleset  address type . domainname null "0 . 0 . 0 . 0" 0 out )  ;  throw new socks exception ( " invalid port number in request" )  ;   }  return command ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < u >  observable < u >    ( final  function <  ?  super t  ?  extends  iterable <  ?  extends u >  >  mapper int prefetch )  {   object helper . require non null ( mapp
@ test public void   (  )  {   test helper . check double on subscribe single ( new  function <  single <  object >   single source <  object >  >  (  )  {  @ override public  single source <  object >  apply (   single <  object >  v )  throws  exception
public double   ( final double log value )  {  return  math . pow ( base log value )  ;   }  
public void   (  string base )  {     url base = base ;   }  
@ override protected void   (  completable observer observer )  {  source . subscribe ( observer )  ;   }  
public static boolean   (  string url  string exclude )  {  if  ( exclude . ends with ( "*" )  )   {  if  ( url . starts with ( exclude . substring ( 0 exclude . length (  )   -  1 )  )  )   {  if  (  ! url . contains ( " .  . " )  &&  ! url . to lower case (  )  . contains ( "%2e" )  )   {  return true ;   }   }   }  else if  ( exclude . contains ( " ? " )  )   {  if  ( url . equals ( exclude )  )   {  return true ;   }   }  else  {  int param index = url . index of ( " ? " )  ;  if  ( param index  !  =   - 1 )   {  url = url . substring ( 0 param index )  ;   }  if  ( url . equals ( exclude )  )   {  return true ;   }   }  return false ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  inner subscriber < t >  ( s predicate )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . range ( 1 5 )  . buffer ( 5 1 )  . test (  )  . assert result (  arrays . as list ( 1 2 3 4 5 )   arrays . as list ( 2 3 4 5 )   arrays . as list ( 3 4 5 )   arrays . as list (
public boolean   ( byte[] ip )  {   integer key ;  if  ( ip . length  =  =  4 )  key = to int ( ip )  ;  else key =  integer . value of (  sip hash . hash code ( ip )  )  ;  return    counter . increment ( key )   >     max ;   }  
@ test public void   (  )  {  assert equals ( instance2 . get name (  )  name )  ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   flowable <  long >  source =  flowable . interval ( 1  time unit . seconds scheduler )  . take ( 10 )  ;   iterable <  long >  iter = source . bloc
@ override protected boolean   (  folder folder )  {  return folder . supports capability (  folder capabilities . can   accept   moved   messages )  || folder . is trash (  )  ;   }  
public void   (  )  {   account saved1 =  provider test utils . setup account ( "test backup1" false m mock context )  ;  saved1 . m host auth recv =  provider test utils . setup host auth ( "legacy - recv" 0 false m mock context )  ;  saved1 . m host auth send =  provider test utils . setup host auth ( "legacy - send" 0 false m mock context )  ;  saved1 . save ( m mock context )  ;   account saved2 =  provider test utils . setup account ( "test backup2" false m mock context )  ;  saved2 . m host auth recv =  provider test utils . setup host auth ( "legacy - recv" 0 false m mock context )  ;  saved2 . m host auth send =  provider test utils . setup host auth ( "legacy - send" 0 false m mock context )  ;  saved2 . save ( m mock context )  ;  assert equals ( 2  email content . count ( m mock context  account . content   uri )  )  ;  assert equals ( 4  email content . count ( m mock context  host auth . content   uri )  )  ;   account backup restore . backup ( m mock context )  ;   content resolver cr = m mock context . get content resolver (  )  ;  cr . delete (  account . content   uri null null )  ;  cr . delete (  host auth . content   uri null null )  ;  assert equals ( 0  email content . count ( m mock context  account . content   uri )  )  ;  assert equals ( 0  email content . count ( m mock context  host auth . content   uri )  )  ;  get provider (  )  . shutdown (  )  ;  assert equals ( 2  email content . count ( m mock context  account . content   uri )  )  ;  assert equals ( 4  email content . count ( m mock context  host auth . content   uri )  )  ;   cursor c = cr . query (  account . content   uri  account . content   projection null null "   id asc" )  ;  assert not null ( c )  ;  assert true ( c . move to next (  )  )  ;   account restored = new  account (  )  ;  restored . restore ( c )  ;   host auth recv =  host auth . restore host auth with id ( m mock context restored . m host auth key recv )  ;  assert not null ( recv )  ;   host auth send =  host auth . restore host auth with id ( m mock context restored . m host auth key send )  ;  assert not null ( send )  ;   provider test utils . assert host auth equal ( "backup" saved1 . m host auth recv recv false )  ;   provider test utils . assert host auth equal ( "backup" saved1 . m host auth send send false )  ;  assert restored account equal ( saved1 restored )  ;  assert true ( c . move to next (  )  )  ;  restored = new  account (  )  ;  restored . restore ( c )  ;  recv =  host auth . restore host auth with id ( m mock context restored . m host auth key recv )  ;  assert not null ( recv )  ;  send =  host auth . restore host auth with id ( m mock context restored . m host auth key send )  ;  assert not null ( send )  ;   provider test utils . assert host auth equal ( "backup" saved2 . m host auth recv recv false )  ;   provider test utils . assert host auth equal ( "backup" saved2 . m host auth send send false )  ;  assert restored account equal ( saved2 restored )  ;   }  
@ test public void   (  )  {   observable <  integer >  src =  observable . just ( 1 2 3 4 3 2 1 )  ;  src . skip while ( less   than   five )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w never (  )  )  . on 
@ override public synchronized  list <  published item >    ( int recent items )  {   list <  published item >  published items =  pub sub persistence manager . get published items ( this recent items )  ;  if  ( last published  !  =  null )   {  boolean 
@ override public boolean   (  integer t1 )  {  return t1 % 2  =  =  0 ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer (  (  callable <  observable <  integer >  >  ) null )  ;   }  
public void   (  object obj )  {     prepared key = obj ;   }  
public void   (  node node )  {  scpd node = node ;   }  
public   (  templates    transformation templates )  {  super (    transformation templates )  ;   }  
private  router address   (  )  {   router address addr = createntcp address (  )  ;  if  ( addr  !  =  null )   {  if  ( addr . get port (  )   <  =  0 )   {  addr = null ;  if  (    log . should log (  log . error )  )     log . error ( "ntcp address is outbound only  since the ntcp configuration is invalid" )  ;   }  else  {  if  (    log . should log (  log . info )  )     log . info ( "ntcp address configured: "  +  addr )  ;   }   }  else  {  if  (    log . should log (  log . info )  )     log . info ( "ntcp address is outbound only" )  ;   }  return addr ;   }  
public static  string   ( final  string filename )  {  final  string demo dir = getj robin demo directory (  )  ;  if  ( demo dir  !  =  null )   {  return demo dir  +  filename ;   }  else  {  return null ;   }   }  
public   (  router context ctx )  {     context = ctx ;     id =       id . increment and get (  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;  final  single <  integer >  cached = pp . single (  - 99 )  . cache (  )  ;   single observer <  integer >  double disposer = new  single observer <  
public static  uri   ( long account id )  {  final  uri .  builder base uri =  uri . parse ( "auth: /  / "  +   email content . email   package   name  +  " . account   settings / outgoing / " )  . build upon (  )  ;   intent utilities . set account id ( base uri account id )  ;  return base uri . build (  )  ;   }  
public   ( int sequence boolean is missing  object data )  {  this . sequence = sequence ;  this . is missing = is missing ;  this . data = data ;   }  
@ test public void   (  )  {   maybe subject . create (  )  . subscribe ( new  maybe observer <  object >  (  )  {  @ override public void on subscribe (   disposable d )  {  assert false ( d . is disposed (  )  )  ;  d . dispose (  )  ;  d . dispose (  )
public void   (  )  {  boolean should proxy =    context . get property (  config update handler . prop   should   proxy   news  config update handler . default   should   proxy   news )  ;   string proxy host =    context . get property (  config update handler . prop   proxy   host  config update handler . default   proxy   host )  ;  int proxy port =  config update handler . proxy port (    context )  ;  if  ( should proxy && proxy port  =  =   config update handler . default   proxy   port   int && proxy host . equals (  config update handler . default   proxy   host )  &&    context . port mapper (  )  . get port (  port mapper . svc   http   proxy )   <  0 )   {  if  (    log . should warn (  )  )     log . warn ( " cannot fetch news  -  http client tunnel not running" )  ;  return ;   }  if  ( should proxy &&    context . comm system (  )  . is dummy (  )  )   {  if  (    log . should warn (  )  )     log . warn ( " cannot fetch news  -  vm  comm system" )  ;  return ;   }  for  (  uri uri :    urls )   {     currenturi = add lang ( uri )  ;   string newsurl =    currenturi . to string (  )  ;  if  (    temp file . exists (  )  )     temp file . delete (  )  ;  try  {   eep get get ;  if  ( should proxy )  get = new  eep get (    context true proxy host proxy port 0    temp file . get absolute path (  )  newsurl true null    last modified )  ;  else if  ( "https" . equals ( uri . get scheme (  )  )  )  get = new ssl eep get (    context    temp file . get absolute path (  )  newsurl )  ;  else get = new  eep get (    context false null 0 0    temp file . get absolute path (  )  newsurl true null    last modified )  ;  get . add status listener ( this )  ;  long start =    context . clock (  )  . now (  )  ;     new last modified = start ;  if  ( get . fetch (  )  )   {  int status = get . get status code (  )  ;  if  ( status  =  =  200 || status  =  =  304 )   {   map <  string  string >  opts = new  hash map <  string  string >  ( 2 )  ;  opts . put (  news helper . prop   last   checked  long . to string ( start )  )  ;  if  ( status  =  =  200 &&    is newer )  opts . put (  news helper . prop   last   updated  long . to string (    new last modified )  )  ;     context . router (  )  . save config ( opts null )  ;  return ;   }   }   }  catch  (   throwable t )   {     log . error ( " error fetching the news" t )  ;   }   }   }  
public void   (  string subject )  {  this . subject = subject ;   }  
public static int   (  )  {  return private sip port ;   }  
private  string   (  string announce byte[] infohash )  {  if  ( announce  !  =  null &&  ( announce . starts with ( "http: /  / y rgrgtlg" )  || announce . starts with ( "http: /  / 8 eojzi kr" )  || announce . starts with ( "http: /  / lnq6yobt" ) || announce . starts with ( "http: /  / tracker2 . postman . i2p / " ) || announce . starts with ( "http: /  / ahsplxkbhemefwvvml7qovzl5a2b5xo5i7lyai7ntdunvcyfdtna . b32 . i2p / " )  )  )   {  for  (   tracker t :    manager . get trackers (  )  )   {   string aurl = t . announceurl ;  if  (  !  ( aurl . starts with ( announce )  ||  ( announce . starts with ( "http: /  / lnq6yobt" )  && aurl . starts with ( "http: /  / tracker2 . postman . i2p / " )  )  ||  ( announce . starts with ( "http: /  / ahsplxkbhemefwvvml7qovzl5a2b5xo5i7lyai7ntdunvcyfdtna . b32 . i2p / " )  && aurl . starts with ( "http: /  / tracker2 . postman . i2p / " )  )  )  )  continue ;   string baseurl = url encode ( t . baseurl )  ;   string name =  data helper . escapehtml ( t . name )  ;   string builder buf = new  string builder ( 128 )  ;  buf . append ( " < a href = \"" )  . append ( baseurl )  . append ( "details . php ? dllist = 1&amp ; filelist = 1&amp ; info   hash = " )  . append (  tracker client . urlencode ( infohash )  )  . append ( "\" title = \"" )  . append (    t ( " details at  { 0 }  tracker" name )  )  . append ( "\" target = \"   blank\" > " )  ;  return buf . to string (  )  ;   }   }  return null ;   }  
void   (  string print line )  {  print lines . add ( print line )  ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {   class <  ?  >  clazz = get erased type ( type )  ;  return clazz . is enum (  )   ?   optional . o
@ test public void   (  )  {  assert true ( resource pool . use ( new  resource context <  target  boolean >  (  )  {  @ override public  boolean perform (   target resource )  {  return true ;   }   }   )  )  ;   }  
public   ( long delay  time unit unit  scheduler scheduler )  {  this . delay = delay ;  this . unit = unit ;  this . scheduler = scheduler ;   }  
public boolean   (  )  {  return  jive globals . get boolean property ( "xmpp . server . session . allowmultiple" true )  ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  < u >  flowable < u >    ( final  class < u >  clazz )  {   object helper . require non null ( clazz "cla
@ override public void   (  loader <  cursor >  loader )  {  adapter . swap cursor ( null )  ;   }  
@ override public  string   (  )  {  return get class (  )  . get simple name (  )   +  " [ ( service = "  +  service id +  " )    ( node id = " +  node id +  " )    ( owner = " +  owner +  " )   ( subscriber = " +  sub jid +  " )   ( state = " +  state +
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . safe subscribe ( new  safe observer <  integer >  ( to )  )  ;  to . assert result ( 1 )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . error (  (  callable <  throwable >  ) null )  ;   }  
public  string   (  )  {  return disco identity ;   }  
public  string   (  )  {  return event suburi ;   }  
@ override public boolean   (  integer a  integer b )  throws  exception  {  throw new  test exception (  )  ;   }  
public static long[]   (  string timeperiod )  {  if  ( null  =  =  timeperiod )  timeperiod = "last60minutes" ;   date from date = null ;   date to date = null ;  long data points = 60 ;   calendar cal =  calendar . get instance (  )  ;   date now = cal . get time (  )  ;  cal . set (  calendar . hour 0 )  ;  cal . set (  calendar . minute 0 )  ;  cal . set (  calendar . second 0 )  ;  cal . set (  calendar . millisecond 0 )  ;  cal . set (  calendar . day   of   week cal . get first day of week (  )  )  ;   date this week start = cal . get time (  )  ;   date this week end = now ;  cal . add (  calendar . millisecond  - 1 )  ;   date last week end = cal . get time (  )  ;  cal . add (  calendar . millisecond 1 )  ;  cal . add (  calendar . day   of   year  - 7 )  ;   date last week start = cal . get time (  )  ;  cal . set time ( now )  ;  cal . set (  calendar . hour 0 )  ;  cal . set (  calendar . minute 0 )  ;  cal . set (  calendar . second 0 )  ;  cal . set (  calendar . millisecond 0 )  ;  cal . set (  calendar . day   of   month cal . get minimum (  calendar . day   of   month )  )  ;   date this month start = cal . get time (  )  ;   date this month end = now ;  cal . add (  calendar . millisecond  - 1 )  ;   date last month end = cal . get time (  )  ;  cal . add (  calendar . millisecond 1 )  ;  cal . add (  calendar . month  - 1 )  ;   date last month start = cal . get time (  )  ;  cal . set time ( now )  ;  cal . add (  calendar . month  - 2 )  ;  cal . set (  calendar . hour 0 )  ;  cal . set (  calendar . minute 0 )  ;  cal . set (  calendar . second 0 )  ;  cal . set (  calendar . millisecond 0 )  ;   date last3 months start = cal . get time (  )  ;   date last3 months end = now ;  cal . set time ( now )  ;  cal . add (  calendar . day   of   year  - 6 )  ;  cal . set (  calendar . hour 0 )  ;  cal . set (  calendar . minute 0 )  ;  cal . set (  calendar . second 0 )  ;  cal . set (  calendar . millisecond 0 )  ;   date last7 days start = cal . get time (  )  ;   date last7 days end = now ;  cal . set time ( now )  ;  cal . add (  calendar . minute  - 60 )  ;   date last60 minutes start = cal . get time (  )  ;   date last60 minutes end = now ;  cal . set time ( now )  ;  cal . add (  calendar . hour  - 23 )  ;   date last24 hours start = cal . get time (  )  ;   date last24 hours end = now ;  cal . set time ( now )  ;  if  ( "thisweek" . equals ( timeperiod )  )   {  from date = this week start ;  to date = this week end ;  data points = 7 ;   }  else if  ( "last7days" . equals ( timeperiod )  )   {  from date = last7 days start ;  to date = last7 days end ;  data points = 7 ;   }  else if  ( "lastweek" . equals ( timeperiod )  )   {  from date = last week start ;  to date = last week end ;  data points = 7 ;   }  else if  ( "thismonth" . equals ( timeperiod )  )   {  from date = this month start ;  to date = this month end ;  data points = 30 ;   }  else if  ( "lastmonth" . equals ( timeperiod )  )   {  from date = last month start ;  to date = last month end ;  data points = 30 ;   }  else if  ( "last3months" . equals ( timeperiod )  )   {  from date = last3 months start ;  to date = last3 months end ;  data points =  ( long )  math . ceil (  ( to date . get time (  )   -  from date . get time (  )  )   /  week )  ;   }  else if  ( "last60minutes" . equals ( timeperiod )  )   {  from date = last60 minutes start ;  to date = last60 minutes end ;  data points = 60 ;   }  else if  ( "last24hours" . equals ( timeperiod )  )   {  from date = last24 hours start ;  to date = last24 hours end ;  data points = 48 ;   }  else  {   string[] dates = timeperiod . split ( "to" )  ;  if  ( dates . length  >  0 )   {   date format form date formatter = new  simple date format ( "mm / dd / yy" )  ;   string from date param = dates[0] ;   string to date param = dates[1] ;  if  ( from date param  !  =  null )   {  try  {  from date = form date formatter . parse ( from date param )  ;   }  catch  (   exception e )   {   }   }  if  ( to date param  !  =  null )   {  try  {  to date = form date formatter . parse ( to date param )  ;   calendar adjusted =  calendar . get instance (  )  ;  adjusted . set time ( to date )  ;  adjusted . set (  calendar . hour   of   day 23 )  ;  adjusted . set (  calendar . minute 59 )  ;  adjusted . set (  calendar . second 59 )  ;  adjusted . set (  calendar . millisecond 999 )  ;  to date = adjusted . get time (  )  ;   }  catch  (   exception e )   {   }   }  data points = discover data points ( from date to date )  ;   }   }  if  ( null  =  =  from date && null  =  =  to date )   {  return new long[] { last60 minutes start . get time (  )  last60 minutes end . get time (  )  data points }  ;   }  else if  ( null  =  =  from date )   {  return new long[] { 0 to date . get time (  )  data points }  ;   }  else if  ( null  =  =  to date )   {  return new long[] { from date . get time (  )  now . get time (  )  data points }  ;   }  else  {  return new long[] { from date . get time (  )  to date . get time (  )  data points }  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  observable . range ( 1 5 )  . to flowable (  backpressure strategy . latest )  . test ( 0 )  ;  ts . request ( 1 )  ;  ts . assert result ( 5 )  ;   }  
protected void   (  attributes attributes )  throws io exception  {  for  ( int i = 0  size = attributes . get length (  )  ;  i  <  size ;  i +  +  )   {  write attribute ( attributes i )  ;   }   }  
public  string   (  )  {  return with ;   }  
public void   ( boolean force end transactions )  {  this . force end transactions = force end transactions ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   burst . item ( 1 )  . create (  )  . collect ( callable list creator (  )  bi consumer throws ( e )  )  . test (  )  . assert error ( e )  . assert not complete ( 
public void   (  string action )  {  set string header ( soapaction action )  ;   }  
@ suppress warnings ( " types" )  @ test ( expected =  unsupported operation exception . class )  public void raw (  )  {  new  generic type (  )  {   }   ;   }  
  (  subscriber <  ?  super t >  actual  function <  ?  super t  ?  extends  publisher <  ?  >  >  item timeout indicator )  {  this . actual = actual ;  this . item timeout indicator = item timeout indicator ;  this . task = new  sequential disposable (  )  ;  this . upstream = new  atomic reference <  subscription >  (  )  ;  this . requested = new  atomic long (  )  ;   }  
public void   (  string room name  localmuc role role )  {  roles . put ( room name role )  ;   }  
public int   (  )  {  return e ;   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
@ test public void   (  )  {   test exception ex = new  test exception (  )  ;  assert same ( ex  completable . error ( ex )  . blocking get (  )  )  ;   }  
@ override public void   (  transformer exception te )  {  log . warn ( te . get message and location (  )  )  ;   }  
public static void   (  locale new locale )  {  locale = new locale ;  setxml property ( "locale" locale . to string (  )  )  ;  time format = null ;  date format = null ;  date time format = null ;   }  
public void   ( final boolean allow duplicate reads )  {  this . allow duplicate reads = allow duplicate reads ;   }  
@ override public boolean   (  )  {  return  subscription helper . is cancelled ( get (  )  )  ;   }  
@ override public boolean   (  integer v1  integer v2 )  {  return false ;   }  
public  string   (  )  {  return  jive globals . get home directory (  )  ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integer >  t1 )  {  t1 . on subscribe (  disposables . 
@ deprecated public void   (  string name )  {     config . remove ( name )  ;     context . remove property ( name )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . on terminate detach (  )  . test (  )  . assert result (  )  ;   }  
private void   (  adapter pair ret sam record .  .  .  reads )  {  if  ( ret  !  =  null &&  ! threshold reached )   {  if  (  ! pre adapter pruned records . contains key ( ret )  )   {  pre adapter pruned records . put ( ret new  array list <  >  (  )  )  ;   }   arrays . stream ( reads )  . for each ( read  -  >  pre adapter pruned records . get ( ret )  . add ( read )  )  ;  tally found adapter ( ret )  ;   }   }  
public  connection   (  )  {  return connection ;   }  
public   (  callable <  ?  extends  maybe source <  ?  extends t >  >  maybe supplier )  {  this . maybe supplier = maybe supplier ;   }  
@ before public void   (  )  {  stream1 =  input stream merger . wrap ( stream   data1 )  ;  stream2 =  input stream merger . wrap ( stream   data2 )  ;  stream3 =  input stream merger . wrap ( stream   data3 )  ;  combined stream =  (  input stream merge
protected   (  )  {  this . type =  generic types . find generic parameter ( get class (  )   generic type . class )  . or else throw (  (  )   -  >  new  unsupported operation exception ( " missing generic type parameter . " )  )  ;   }  
private static  action   ( final  list <  string >  events )  {  return new  action (  )  {  @ override public void run (  )  {  events . add ( "completed" )  ;   }   }   ;   }  
protected   ( i2p app context ctx  main main boolean use swing )  {     app context = ctx ;     main = main ;     use swing = use swing ;   }  
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  @ suppress warnings ( "unchecked" )  @ experimental public static  < t >  flowable < t >    (  single source <  ?  extends t >  s
public  string   (  )  {  return    tracker ;   }  
@ override public  list <  integer >    (  )  throws  exception  {  if  (  +  + calls  =  =  2 )   {  to . cancel (  )  ;   }  return new  array list <  integer >  (  )  ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  u u ;  try  {  u =  object helper . require non null ( iterator . next (  )  " the iterator returned a null value" )  ;   }  catch  (   throwable e )   {  error ( e )  ;  return ;   }  v
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;   subscriber <  object >  sub = new  subscriber <  object >  (  )  {   subscription s ;  @ override public void on subscribe (   subscription s )  {  this .
public  mix descriptor   (  conference member member )  {  synchronized  ( mix manager )   {   mix descriptor mix descriptor =  (  mix descriptor ) mix manager . find mix descriptor (  (  mix data source ) member . get member receiver (  )  )  ;  return mix descriptor ;   }   }  
@ override public void   (  )  {  for  (   configuration resource resource : watch map . values (  )  )   {  try  {  if  ( resource . updated (  )  )   {  event manager . new event (  configuration event . update resource )  ;  log . info ( " updated "  +
private boolean   (  )  {   string pref =    context . get property ( prop   prefer   udp default   prefer   udp )  ;  return  ( pref  !  =  null )  &&  ! "false" . equals ( pref )  ;   }  
@ override public  view   (  layout inflater inflater  view group container  bundle saved instance state )  {  if  (  logging . debug   lifecycle &&  debug utils . debug )   {   log utils . d (  logging . log   tag " debug fragment on create view" )  ;   
@ override public void   (  long a long )  {  cancel (  )  ;   }  
public void   (  )  {  assert equals ( ""  imap store . decode folder name ( "" null )  )  ;  assert equals ( "a"  imap store . decode folder name ( "a" null )  )  ;  assert equals ( "xyz"  imap store . decode folder name ( "xyz" null )  )  ;  assert equals ( "\u65e5\u672c\u8a9e"  imap store . decode folder name ( "& ze vnl iqe - " null )  )  ;  assert equals ( " ! \u65e5\u672c\u8a9e ! "  imap store . decode folder name ( " ! & ze vnl iqe -  ! " null )  )  ;  assert equals ( ""  imap store . decode folder name ( "" "" )  )  ;  assert equals ( "a"  imap store . decode folder name ( "a" "" )  )  ;  assert equals ( "xyz"  imap store . decode folder name ( "xyz" "" )  )  ;  assert equals ( "\u65e5\u672c\u8a9e"  imap store . decode folder name ( "& ze vnl iqe - " "" )  )  ;  assert equals ( " ! \u65e5\u672c\u8a9e ! "  imap store . decode folder name ( " ! & ze vnl iqe -  ! " "" )  )  ;  assert equals ( ""  imap store . decode folder name ( "[ gmail] / " "[ gmail] / " )  )  ;  assert equals ( "a"  imap store . decode folder name ( "[ gmail] / a" "[ gmail] / " )  )  ;  assert equals ( "xyz"  imap store . decode folder name ( "[ gmail] / xyz" "[ gmail] / " )  )  ;  assert equals ( "\u65e5\u672c\u8a9e"  imap store . decode folder name ( "[ gmail] / & ze vnl iqe - " "[ gmail] / " )  )  ;  assert equals ( " ! \u65e5\u672c\u8a9e ! "  imap store . decode folder name ( "[ gmail] /  ! & ze vnl iqe -  ! " "[ gmail] / " )  )  ;  assert equals ( "inbox / "  imap store . decode folder name ( "inbox / " "[ gmail] / " )  )  ;  assert equals ( "inbox / a"  imap store . decode folder name ( "inbox / a" "[ gmail] / " )  )  ;  assert equals ( "inbox / xyz"  imap store . decode folder name ( "inbox / xyz" "[ gmail] / " )  )  ;  assert equals ( "inbox / \u65e5\u672c\u8a9e"  imap store . decode folder name ( "inbox / & ze vnl iqe - " "[ gmail] / " )  )  ;  assert equals ( "inbox /  ! \u65e5\u672c\u8a9e ! "  imap store . decode folder name ( "inbox /  ! & ze vnl iqe -  ! " "[ gmail] / " )  )  ;   }  
private boolean   (  )  {  return  boolean . value of (    context . get property ( "should send" "false" )  )  . boolean value (  )  ;   }  
public  read structure   (  )  {  return output read structure ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . request ( 3 )  ;  final  atomic long requested1 = new  atomic long (  )  ;  final  atomic long reques
public void   ( i2p session session  string message  throwable error )  {  if  (    log . should log (  log . debug )  )     log . debug ( "i2p error: "  +  message error )  ;  close (  )  ;   }  
public  string   (  )  {  return old nick ;   }  
private static void   (  string host int port  string con options )  {     log . info ( "\n\n starting up  alice" )  ;  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;     log . debug ( "line read for valid version: "  +  line )  ;   string req = "session create style = stream destination =  alice "  +  con options  +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . info ( " response to creating the session with destination  alice: "  +  line )  ;  req = "naming lookup name = me\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;   properties props = sam utils . parse params ( line )  ;   string value = props . get property ( "value" )  ;  if  ( value  =  =  null )   {     log . error ( " no value for me found !  ["  +  line  +  "]" )  ;  return ;   }  else  {     log . info ( " alice is located at "  +  value )  ;   }     alice = value ;  i2p thread alice thread = new i2p thread ( new  alice runner ( reader out s )  )  ;  alice thread . set name ( " alice" )  ;  alice thread . start (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic reference <  object >  exception = new  atomic reference <  object >  (  )  ;  final  count down latch latch = new  count down latch ( 1 )  ;   flowable . just ( 1 )  . subscribe o
public  update type   (  )  {  return    type ;   }  
@ override public int   (  )  {  return username . hash code (  )  ;   }  
public  string   (  )  {  return action ;   }  
public boolean   (  )  {  return  jive globals . get boolean property ( http   bind   cors   enabled http   bind   cors   enabled   default )  ;   }  
private e   ( e rv )  {  synchronized  ( this )   {  boolean ok   to   drop = update vars ( rv )  ;  if  (    dropping )   {  if  (  ! ok   to   drop )   {     dropping = false ;   }  else if  (    now  >  =     drop   next )   {  while  (    now  >  =     drop   next &&    dropping && rv . get priority (  )   <  =     last dropped priority )   {  drop ( rv )  ;     count +  +  ;  rv = super . poll (  )  ;  ok   to   drop = update vars ( rv )  ;  if  (  ! ok   to   drop )   {     dropping = false ;   }  else  {  control   law (    drop   next )  ;   }   }   }   }  else if  ( ok   to   drop && rv . get priority (  )   <  dont   drop   priority &&  (    now  -     drop   next  <  interval ||    now  -     first   above   time  >  =  interval )  )   {  drop ( rv )  ;     last dropped priority = rv . get priority (  )  ;  rv = super . poll (  )  ;  update vars ( rv )  ;     dropping = true ;  if  (    now  -     drop   next  <  interval )     count =    count  >  2  ?     count  -  2 : 1 ;  else    count = 1 ;  control   law (    now )  ;   }   }  return rv ;   }  
  (  disposable s  string .  .  .  values )  {  this . s = s ;  this . values = values ;   }  
private void   (  )  {   filename filter filter = new  filename filter (  )  {  @ override public boolean accept (   file dir   string name )  {  return name . starts with ( "jive . audit - " )  && name . ends with ( " . log" )  ;   }   }   ;   file[] files = base folder . list files ( filter )  ;  if  ( files  =  =  null )   {   log . debug ( " path ' {  } ' does not denote a directory  or an io exception occured while trying to list its content . " base folder )  ;  return ;   }  long total length = 0 ;  for  (   file file : files )   {  total length = total length  +  file . length (  )  ;   }  if  ( total length  >  max total size )   {   list <  file >  sorted files = new  array list <  >  (  arrays . as list ( files )  )  ;   collections . sort ( sorted files new  comparator <  file >  (  )  {  @ override public int compare (   file o1   file o2 )  {  return o1 . get name (  )  . compare to ( o2 . get name (  )  )  ;   }   }   )  ;  while  ( total length  >  max total size &&  ! sorted files . is empty (  )  )   {   file file to delete = sorted files . remove ( 0 )  ;  total length = total length  -  file to delete . length (  )  ;  if  ( file to delete . equals ( current audit file )  )   {  close (  )  ;   }  if  (  ! file to delete . delete (  )  )   {   log . warn ( " unable to delete file ' {  } ' as part of regular log rotation based on size of files  (  openfire failed to clean up after itself )  ! " file to delete )  ;   }   }   }   }  
public void   (  string str )  {  seth ( str )  ;   }  
public void   ( long up )  {  uploaded . set ( up )  ;   }  
public void   (  im event im event )  {   log . error ( " same time:  failed to open im session: "  +  im event )  ;   }  
public void   (  string date )  {  this . date = date ;   }  
@ override public  list <  integer >    (  )  {  return new  array list <  integer >  (  )  ;   }  
private void   (  )  {  im . unitsexponent = gdef . units exponent ;  im . base = gdef . base ;  if  (  ! gdef . logarithmic )   {  final char symbol[] =  { 'a' 'f' 'p' 'n' 'u' 'm' ' ' 'k' 'm' 'g' 't' 'p' 'e' }  ;  int symbcenter = 6 ;  double digits ;  if  ( im . unitsexponent  !  =   integer . max   value )   {  digits =  math . floor ( im . unitsexponent  /  3 . 0 )  ;   }  else  {  digits =  math . floor (  math . log (  math . max (  math . abs ( im . minval )   math . abs ( im . maxval )  )  )   /   math . log ( im . base )  )  ;   }  im . magfact =  math . pow ( im . base digits )  ;  if  (  (  ( digits  +  symbcenter )   <  symbol . length )  &&  (  ( digits  +  symbcenter )   >  =  0 )  )   {  im . symbol = symbol[ ( int ) digits  +  symbcenter] ;   }  else  {  im . symbol = ' ? ' ;   }   }   }  
@ test public void   (  )  {  final  throwable[] error =  { null }  ;   flowable . create ( new  flowable on subscribe <  integer >  (  )  {  @ override public void subscribe (   flowable emitter <  integer >  e )  throws  exception  {  e = e . serialize 
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  single subject <  integer >  cs =  single subject . create (  )  ;   test subscriber <  integer >  ts = pp . merge with ( cs )  . subscri
@ override public  cursor   (  uri uri  string[] projection  string selection  string[] selection args  string sort order )  {  long calling id =  binder . clear calling identity (  )  ;  try  {  if  ( projection  =  =  null )   {  projection = new  strin
@ test public void   (  )  {   completable . from observable (  observable . just ( 1 )  )  . test (  )  . assert result (  )  ;   }  
public  message id   (  )  {  return    message id ;   }  
public void   ( int delay ms )  {     connect delay = delay ms ;   }  
@ test public void   (  )  {   list <  inet address >  cluster members =  access list determinator . get cluster members ( sys config "repose cluster" )  ;  assert that ( " should have two cluster members" cluster members . size (  )  equal to ( 2 )  )  ;
@ setup public void   (  )  {   integer[] values = new  integer[times] ;   arrays . fill ( values 777 )  ;   flowable <  integer >  fsource =  flowable . from array ( values )  ;  flow flat map flowable1 = fsource . flat map ( new  function <  integer  pu
public synchronized void   (  )  {   log . info ( " shutting down .   unloading all loaded plugins .  .  . " )  ;  plugin monitor . stop (  )  ;  for  (   map .  entry <  string  plugin >  plugin : plugins loaded . entry set (  )  )   {  try  {  plugin . get value (  )  . destroy plugin (  )  ;   log . info ( " unloaded plugin ' {  } ' . " plugin . get key (  )  )  ;   }  catch  (   exception e )   {   log . error ( " an exception occurred while trying to unload plugin ' {  } ':" plugin . get key (  )  e )  ;   }   }  plugins loaded . clear (  )  ;  plugin dirs . clear (  )  ;  plugin metadata . clear (  )  ;  classloaders . clear (  )  ;  plugin development . clear (  )  ;  child plugin map . clear (  )  ;  failure to load count . clear (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0 )  ;   disposable d =  disposables . empty (  )  ;   queue drain subscriber <  integer  integer  integer >  qd = create ordered ( ts d )  ;  ts . on s
public final  locale   (  )  {  return locale ;   }  
void   (  )  {  int expired = 0 ;  for  (  iterator < ntcp connection >  iter =    establishing . iterator (  )  ;  iter . has next (  )  ;   )   {  ntcp connection con = iter . next (  )  ;  if  ( con . is closed (  )  || con . is established (  )  )   {  iter . remove (  )  ;   }  else if  ( con . get time since created (  )   >  establish   timeout )   {  iter . remove (  )  ;  con . close (  )  ;  expired +  +  ;   }   }  if  ( expired  >  0 )     context . stat manager (  )  . add rate data ( "ntcp . outbound establish failed" expired )  ;   }  
public  data structure   (  )  throws  data format exception  {   get date message msg = new  get date message ( "0 . 8 . 13 - 0" )  ;  return msg ;   }  
private   (  )  {   internal component manager . get instance (  )  . add listener ( this )  ;  xmpp server server = xmpp server . get instance (  )  ;  server name = server . get server info (  )  . getxmpp domain (  )  ;  routing table = server . get routing table (  )  ;   interceptor manager . get instance (  )  . add interceptor ( this )  ;  packets task = new  process packets task (  )  ;   task engine . get instance (  )  . schedule ( packets task 5000 5000 )  ;   }  
@ override public  completable   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
void   (  string s )  {     last error = s ;   }  
@ override public t   (  )  throws  exception  {  return  object helper . require non null ( callable . call (  )  " the callable returned a null value" )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return e instanceof  test exception || e instanceof  composite exception ;   }  
public void   (  )  {  last request time = 0 ;  tracker problems = null ;  stop = false ;  started = false ;  register fails = 0 ;  consecutive fails = 0 ;  seen peers = 0 ;   }  
public  string   (  )  {  return  (  string ) b ;   }  
public static  email service   (  )  {  return instance ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public void   (  agent session agent session )  {  boolean removed = session list . remove ( agent session )   !  =  null ;  if  ( removed )   {  for  (   agent session listener listener : listener list )   {  listener . notify session removed ( agent session )  ;   }   }   }  
@ override protected void   (  )  {  multi collector . finish (  )  ;  write results to files (  )  ;   }  
@ override public void   (  )  {  validate fields (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  subject <  integer >  s =  publish subject .  <  integer > create (  )  . to serialized (  )  ;   test observer <  integer >  to = s . t
public   (  conference member member  call participant cp  datagram channel datagram channel )  throws io exception  {  this . member = member ;  this . cp = cp ;  this . datagram channel = datagram channel ;  synchronized  ( member number lock )   {  my member number = member number +  +  ;   }  encryption key = cp . get encryption key (  )  ;  encryption algorithm = cp . get encryption algorithm (  )  ;  if  ( encryption key  !  =  null )   {  try  {  if  ( encryption key . length (  )   <  8 )   {  encryption key +  =  string . value of (  system . current time millis (  )  )  ;   }  if  ( encryption key . length (  )   >  8 && encryption algorithm . equals ( "des" )  )   {  encryption key = encryption key . substring ( 0 8 )  ;   }  byte[] key bytes = encryption key . get bytes (  )  ;   secret key spec secret key = new  secret key spec ( key bytes encryption algorithm )  ;  decrypt cipher =  cipher . get instance ( encryption algorithm )  ;  decrypt cipher . init (  cipher . decrypt   mode secret key )  ;   logger . println ( " call "  +  cp  +  "  voice data will be decrypted " +  "using " +  encryption algorithm )  ;   }  catch  (   exception e )   {   logger . println ( " call "  +  cp  +  "  crypto initialization failed " +  e . get message (  )  )  ;  throw new io exception ( "  crypto initialization failed "  +  e . get message (  )  )  ;   }   }  time started =  logger . get date (  )  ;   }  
public static  integer   (  byte value[]  integer start index )  {  return  integer . value of (  byte buffer . wrap ( bytes from array ( value )  )  . get int ( start index . int value (  )  )  )  ;   }  
@ test public void   (  )  throws  exception  {   file base =  maybe no2 dot0 since . find source ( " flowable" )  ;  if  ( base  =  =  null )   {  return ;   }  base = base . get parent file (  )  ;   queue <  file[] >  files = new  array deque <  file[]
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;  pp . publish ( new  function <  flowable <  integer >   flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   flowabl
@ override public void   (  certificate store store )  {  restart needed = true ;   }  
private void   (  print writer out  http servlet request req )  throws io exception  {   string builder buf = new  string builder ( 1024 )  ;  buf . append ( " < form action = \""  +     context path  +  " / configure\" method = \"post\" > \n" +  " < div class = \"configsectionpanel\" >  < div class = \"snark config\" > \n" )  ;  write hidden inputs ( buf req " save2" )  ;  buf . append ( " < span class = \"snark config title\" > " )  ;  to theme img ( buf "config" )  ;  buf . append ( ' ' )  ;  buf . append (    t ( " trackers" )  )  ;  buf . append ( " <  / span >  < hr > \n"  +  " < table class = \"trackerconfig\" >  < tr >  < th title = \"" )  . append (    t ( " select trackers for removal from i2p snark's known list" )  )  . append ( "\" >  <  / th >  < th > " )  . append (    t ( " name" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " website url" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " standard" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " open" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " private" )  )  . append ( " <  / th >  < th > " )  . append (    t ( " announce url" )  )  . append ( " <  / th >  <  / tr > \n" )  ;   list <  string >  open trackers =    manager . util (  )  . get open trackers (  )  ;   list <  string >  private trackers =    manager . get private trackers (  )  ;  for  (   tracker t :    manager . get sorted trackers (  )  )   {   string name = t . name ;   string homeurl = t . baseurl ;   string announceurl = t . announceurl . replace ( "&#61 ; " " = " )  ;  boolean is private = private trackers . contains ( t . announceurl )  ;  boolean is known open =    manager . util (  )  . is known open tracker ( t . announceurl )  ;  boolean is open = is known open || open trackers . contains ( t . announceurl )  ;  buf . append ( " < tr class = \"known tracker\" >  < td >  < input type = \"checkbox\" class = \"optbox\" id = \"" )  . append ( name )  . append ( "\" name = \"delete   " )  . append ( name )  . append ( "\" title = \"" )  . append (    t ( " mark tracker for deletion" )  )  . append ( "\" > "  +  " <  / td >  < td >  < label for = \"" )  . append ( name )  . append ( "\" > " )  . append ( name )  . append ( " <  / label >  <  / td >  < td > " )  . append ( urlify ( homeurl 35 )  )  . append ( " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"0\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  (  !  ( is open || is private )  )  buf . append ( " checked = \"checked\"" )  ;  else if  ( is known open )  buf . append ( " disabled = \"disabled\"" )  ;  buf . append ( " > "  +  " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"1\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  ( is open )  buf . append ( " checked = \"checked\"" )  ;  else if  ( t . announceurl . equals ( "http: /  / diftracker . i2p / announce . php" )  || t . announceurl . equals ( "http: /  / tracker2 . postman . i2p / announce . php" )  )  buf . append ( " disabled = \"disabled\"" )  ;  buf . append ( " > "  +  " <  / td >  < td >  < input type = \"radio\" class = \"optbox\" value = \"2\" tabindex = \" - 1\" name = \"ttype   " )  . append ( announceurl )  . append ( "\"" )  ;  if  ( is private )   {  buf . append ( " checked = \"checked\"" )  ;   }  else if  ( is known open || t . announceurl . equals ( "http: /  / diftracker . i2p / announce . php" )  || t . announceurl . equals ( "http: /  / tracker2 . postman . i2p / announce . php" )  )   {  buf . append ( " disabled = \"disabled\"" )  ;   }  buf . append ( " > "  +  " <  / td >  < td > " )  . append ( urlify ( announceurl 35 )  )  . append ( " <  / td >  <  / tr > \n" )  ;   }  buf . append ( " < tr >  < td >  < b > " )  . append (    t ( " add" )  )  . append ( ": <  / b >  <  / td > "  +  " < td >  < input type = \"text\" class = \"trackername\" name = \"tname\" spellcheck = \"false\" >  <  / td > "  +  " < td >  < input type = \"text\" class = \"trackerhome\" name = \"thurl\" spellcheck = \"false\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"0\" name = \"add   tracker   type\" checked = \"checked\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"1\" name = \"add   tracker   type\" >  <  / td > " +  " < td >  < input type = \"radio\" class = \"optbox\" value = \"2\" name = \"add   tracker   type\" >  <  / td > " +  " < td >  < input type = \"text\" class = \"trackerannounce\" name = \"taurl\" spellcheck = \"false\" >  <  / td >  <  / tr > \n" +  " < tr class = \"spacer\" >  < td colspan = \"7\" > &nbsp ;  <  / td >  <  / tr > \n" +  " < tr >  < td colspan = \"7\" > \n" +  " < input type = \"submit\" name = \"taction\" class = \"default\" value = \"" )  . append (    t ( " add tracker" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"delete\" value = \"" )  . append (    t ( " delete selected" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"add\" value = \"" )  . append (    t ( " add tracker" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"accept\" value = \"" )  . append (    t ( " save tracker configuration" )  )  . append ( "\" > \n"  +  " < input type = \"submit\" name = \"taction\" class = \"reload\" value = \"" )  . append (    t ( " restore defaults" )  )  . append ( "\" > \n"  +  " <  / td >  <  / tr > "  +  " < tr class = \"spacer\" >  < td colspan = \"7\" > &nbsp ;  <  / td >  <  / tr > \n" +  " <  / table >  <  / div >  <  / div >  <  / form > \n" )  ;  out . write ( buf . to string (  )  )  ;   }  
public void   (  boolean value )  {  if  ( value  !  =  null )   jive globals . set property ( http   bind   cors   enabled  string . value of ( value )  )  ;   }  
@ non null public static  scheduler   (  )  {  return  rx java plugins . on computation scheduler ( computation )  ;   }  
@ override public  history strategy   (  )  {  return history strategy ;   }  
@ non null public static  scheduler   ( @ non null  thread factory thread factory )  {  return new  computation scheduler (  object helper . require non null ( thread factory "thread factory is null" )  )  ;   }  
@ test public void   (  )  throws io exception  {  final  file input file1 = new  file ( test   data   path "ceu trio - snps - scrambled . 1 . vcf" )  ;  final  file input file2 = new  file ( test   data   path "vcf format test . scrambled . vcf" )  ;  fi
@ override public void   ( boolean on )  {  if  ( on )  throw new  unsupported operation exception (  )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
@ test public void   (  )  {  int num msgs =    options . get inbound buffer size (  )   /     options . get max message size (  )  ;  byte orig[] = new byte[num msgs * 1024] ;     context . random (  )  . next bytes ( orig )  ;  for  ( int i = 0 ;  i  < 
@ test public void   (  )  throws io exception  {  final  file indel input file = new  file ( test   data   path "ceu trio - indels . vcf" )  ;  final  file snp input file = new  file ( test   data   path "ceu trio - snps - scrambled . 1 . vcf" )  ;  fina
public final static boolean   (  )  {  int addr cnt = getn host addresses (  )  ;  for  ( int n = 0 ;  n  <  addr cnt ;  n +  +  )   {   string addr = get host address ( n )  ;  if  ( isi pv4 address ( addr )   =  =  true )  return true ;   }  return false ;   }  
public  string   (  )  {  return    current graph name ;   }  
@ override public  sorting collection .  codec <  fastq records for cluster >    (  )  {  return new  fastq records for cluster codec ( num templates num sample barcodes num molecular barcodes )  ;   }  
public   (  inet address bind addr )  {  if  ( bind addr . get address (  )  . length  !  =  4 )   {  this . open (  (  inet6 address ) bind addr )  ;   }  else  {  this . open (  (  inet4 address ) bind addr )  ;   }   }  
public void   (  string whisper group id )  throws  parse exception  {   whisper group whisper group = wg manager . find whisper group ( whisper group id )  ;  if  ( whisper group  =  =  null )   {  throw new  parse exception ( " no such whisper group: "  +  whisper group id 0 )  ;   }  if  ( this . whisper group  !  =  whisper group )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " not in same wg  this "  +  this . whisper group  +  " other " +  whisper group )  ;   }  return ;   }  if  ( cp . get input treatment (  )   !  =  null && cp . is recorder (  )   =  =  false )   {  return ;   }  synchronized  ( mix manager )   {  if  ( whisper group . has common mix (  )  )   {  mix manager . add mix ( whisper group 1 )  ;  mix manager . add mix ( member receiver  - 1 )  ;   }  else  {  mix manager . remove mix ( whisper group )  ;  mix manager . remove mix ( member receiver )  ;   }   }  double[] spatial values = new double[4] ;  synchronized  ( conference manager )   {   array list <  conference member >  member list = conference manager . get member list (  )  ;  for  (   conference member member : member list )   {  if  ( member  =  =  this )   {  continue ;   }  set private mix ( member spatial values )  ;   }   }   }  
@ suppress warnings ( "unchecked" )    (  single observer <  ?  super r >  observer int n  function <  ?  super  object[]  ?  extends r >  zipper )  {  super ( n )  ;  this . actual = observer ;  this . zipper = zipper ;   zip single observer < t > [] o =
@ override public void   (  subscriber <  ?  super  integer >  s )  {  if  ( s instanceof  conditional subscriber )   {  s . on subscribe ( new  range conditional subscription (  (  conditional subscriber <  ?  super  integer >  ) s start end )  )  ;   } 
public void   (  )  throws  exception  {  final smpp session session = session pool . borrow object (  )  ;  try  {  final  string message id = session . submit short message ( service type source ton source npi source address destination ton destination npi destination address esm protocol id priority flag schedule delivery time validity period registered delivery replace if present flag data coding sm default msg id message )  ;   log . debug ( " message submitted  message   id is ' {  } ' . " message id )  ;   }  finally  {  session pool . return object ( session )  ;   }   }  
public  string   (  )  {  return    config . get property ( prop   intfc )  ;   }  
@ override protected void   (  thread t  runnable r )  {  super . before execute ( t r )  ;  t . set uncaught exception handler (  ( t1 e )   -  >   {  throw new  picard exception ( " uncaught exception in thread: "  +  t1 . get name (  )   +  " : " +  e 
public boolean   (  )  {  return subscribers . get (  )   =  =  terminated && value  !  =  null ;   }  
public boolean   (  data input in )  throws io exception  {  return  (  boolean ) read object ( in )  ;   }  
private   (  collection <  default cache .  cache object < v >  >  cached objects )  {  this . cached objects = new  array list <  >  ( cached objects )  ;   }  
@ test public void   (  )  {   string uri1 = "key$test" ;   string uri2 =  string uri utilities . encode uri ( uri1 )  ;  assert equals ( uri2 "key%24test" )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  count down latch exit = new  count down latch ( 1 )  ;  final  count down latch timeout setuped = new  count down latch ( 1 )  ;  final  subscriber <  string >  observer =  test helper . 
void   (  )  {  resources . dispose (  )  ;   disposable helper . dispose ( boundary )  ;   }  
void   (  )  {   switch map inner observer o = inner . get and set ( inner   disposed )  ;  if  ( o  !  =  null && o  !  =  inner   disposed )   {  o . dispose (  )  ;   }   }  
@ override public  string   (  )  {  return  string . format ( " { %d byte literal ( memory )  } " m data . length )  ;   }  
protected byte[]   (  )  {  return new byte[0] ;   }  
@ check return value @ backpressure support (  backpressure kind . special )  @ scheduler support (  scheduler support . none )  public static  < t >  flowable < t >    (  flowable on subscribe < t >  source  backpressure strategy mode )  {   object helpe
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer generated1 = new  atomic integer (  )  ;   flowable <  flowable <  integer >  >  o1 = create infinite flowable ( generated1 )  . map ( new  function <  integer  flowable < 
@ override public double   (  )  {  double average response size =  ( double ) data store . get accumulated response size (  )   /   ( double ) data store . get total responses (  )  ;  if  (  double . is nan ( average response size )  )   {  return doubl
@ override public  void   (  )  {  return null ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . sequence equal ( just1 just1 null )  ;   }  
public void   ( int id )  {  this . id = id ;   }  
public void   (  string username )  {  this . username = username ;   }  
private static float[]   (  float[] x values  float[] y values int sample count )  {  if  ( sample count  =  =  0 || sample count  >  x values . length )  sample count = x values . length ;  if  ( x values . length  <  =  1 || x values . length  !  =  y values . length )   {  throw new  picard exception ( " can not compute linear fit . " )  ;   }  float sumx = 0 ;  float sumy = 0 ;  float sumxx = 0 ;  float sumxy = 0 ;  float slope = 0f ;  float offset = 0f ;  for  ( int i = 0 ;  i  <  sample count ;  i +  +  )   {  sumx +  = x values[i] ;  sumy +  = y values[i] ;  sumxy +  = x values[i] * y values[i] ;  sumxx +  = x values[i] * x values[i] ;   }  float denominator = sample count * sumxx  -  sumx * sumx ;  if  ( denominator  >   math . ulp ( denominator )  )   {  slope =  ( sample count * sumxy  -  sumx * sumy )   /  denominator ;  offset =  ( sumy * sumxx  -  sumx * sumxy )   /  denominator ;   }  return new float[] { slope offset }  ;   }  
@ xml element ( name = "property" )  @ xml element wrapper ( name = "properties" )  public  list <  user property >    (  )  {  return properties ;   }  
public void   (  hash key )  {     keys . remove ( key )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  normal . completable . to single default ( null )  ;   }  
@ test public void   (  )  {   observable <  string >  skip =  observable . just ( "one" "two" "three" )  . skip ( 0 )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  skip . subscribe ( observer )  ;  verify ( observer times ( 
@ override public void   (  throwable t )  {  if  ( eager )   {  if  ( compare and set ( false true )  )   {  try  {  disposer . accept ( resource )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  t = new  composite exception 
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  debounce timed subscriber < t >  ( new  serialized subscriber < t >  ( s )  timeout unit scheduler . create worker (  )  )  )  ;   }  
@ override public final boolean   (  )  {  return s . get (  )   =  =   subscription helper . cancelled ;   }  
default  < c extends  jdbi config < c >  > c   (  class < c >  config class )  {  return get config (  )  . get ( config class )  ;   }  
private  string   (  string codes )  {  return codes . starts with ( " ! " )   ?  codes . substring ( 1 )  : codes ;   }  
public  array list   (  )  {  return private mixes for me ;   }  
private static  header   ( byte[] data )  {  byte[] type array = new byte[2] ;   system . arraycopy ( data 0 type array 0 2 )  ;  int type = unsigned short to int ( type array )  ;  byte[] length array = new byte[2] ;   system . arraycopy ( data 2 length array 0 2 )  ;  int length value = unsigned short to int ( length array )  ;  byte[] value array = new byte[length value] ;   system . arraycopy ( data 4 value array 0 length value )  ;  if  ( data . length  >  =  8 )   {  int family = unsigned byte to int ( value array[1] )  ;  if  ( family  =  =  1 )   {  byte[] port array = new byte[2] ;   system . arraycopy ( value array 2 port array 0 2 )  ;  int port = unsigned short to int ( port array )  ;  int first octet = unsigned byte to int ( value array[4] )  ;  int second octet = unsigned byte to int ( value array[5] )  ;  int third octet = unsigned byte to int ( value array[6] )  ;  int fourth octet = unsigned byte to int ( value array[7] )  ;  final  string builder ip = new  string builder (  )  . append ( first octet )  . append ( " . " )  . append ( second octet )  . append ( " . " )  . append ( third octet )  . append ( " . " )  . append ( fourth octet )  ;  return new  header ( new  inet socket address ( ip . to string (  )  port )  type length value  +  4 )  ;   }   }  return new  header ( null  - 1 length value  +  4 )  ;   }  
private final  properties   (  properties opts )  {   properties options = new  properties (  )  ;  options . put all ( filter ( opts )  )  ;  if  (  (  !    context . is router context (  )  )  &&    context . get boolean property ( "i2cp . auth" )  &&  (  (  ! opts . contains key ( prop   user )  )  ||  (  ! opts . contains key ( prop   pw )  )  )  )   {   string config user =    context . get property ( prop   user )  ;   string configpw =    context . get property ( prop   pw )  ;  if  ( config user  !  =  null && configpw  !  =  null )   {  options . set property ( prop   user config user )  ;  options . set property ( prop   pw configpw )  ;   }   }  if  ( options . get property ( i2p client . prop   fast   receive )   =  =  null )  options . set property ( i2p client . prop   fast   receive "true" )  ;  if  ( options . get property ( i2p client . prop   reliability )   =  =  null )  options . set property ( i2p client . prop   reliability "none" )  ;  return options ;   }  
@ test ( timeout = 5000 expected =  null pointer exception . class )  public void   (  )  {   completable c =  completable . unsafe create ( new  completable source (  )  {  @ override public void subscribe (   completable observer s )  {  throw new  null
public void   ( boolean blocking rebuild )  {  if  (    log . should log (  log . info )  )     log . info ( " rebuilding new router info" )  ;     router info lock . write lock (  )  . lock (  )  ;  try  {  locked   rebuild router info ( blocking rebuild )  ;   }  finally  {     router info lock . write lock (  )  . unlock (  )  ;   }   }  
public void   (  service service  string uuid long timeout )  {  set method (  subscription . subscribe   method )  ;  set service ( service )  ;  setsid ( uuid )  ;  set timeout ( timeout )  ;   }  
@ override public  string   (  )  {  return initiator ;   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   completable c = normal . completable . do on dispose ( new  action (  )  {  @ override public void run (  )  {  calls . get and increment (  )  ;
public static  string[]   (  string set )  {   array list <  string >  list = new  array list <  string >  (  )  ;  if  ( set  !  =  null )   {   string[] set items = set . split ( " " )  ;  for  (   string item : set items )   {  if  ( item . index of ( ':' )   =  =   - 1 )   {  try  {   integer . parse int ( item )  ;  list . add ( item )  ;   }  catch  (   number format exception e )   {   log utils . d (  logging . log   tag " invalid uid value" e )  ;   }   }  else  {  for  (   string range item : get imap range values ( item )  )   {  list . add ( range item )  ;   }   }   }   }   string[] string list = new  string[list . size (  ) ] ;  return list . to array ( string list )  ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . range ( 1 10 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )  . replay (  )  . auto connect (  )  ;   test observer <  integer >  to = new
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  maybe subject <  integer >  ms =  maybe subject . create (  ) 
@ override public int   (  )  {  return  objects . hash code ( m access token m refresh token m expiration )  ;   }  
@ test public void   (  )  {  final  directory resource resolver resolver = new  directory resource resolver ( " / etc / powerapi" )  ;  assert equals ( " should append file uri spec to configuration root" "file: /  /  / etc / powerapi" resolver . get con
public void   (  object input in )  throws io exception   class not found exception  {  conversationid =  externalizable util . get instance (  )  . read long ( in )  ;   }  
@ override public void   ( jid barejid )  {  owners . add ( barejid . as barejid (  )  )  ;   }  
public void   ( long x )  {     socket manager . get connection manager (  )  . set so timeout ( x )  ;   }  
public  privacy list   (  )  {   cache <  string  client session info >  cache =  session manager . get instance (  )  . get session info cache (  )  ;   client session info session info = cache . get ( get address (  )  . to string (  )  )  ;  if  ( session info  !  =  null && session info . get active list (  )   !  =  null )   {  return  privacy list manager . get instance (  )  . get privacy list ( address . get node (  )  session info . get active list (  )  )  ;   }  return null ;   }  
private  twod index[]   ( final  read structure read structure )  {  int total cycles = read structure . total cycles ;  final  twod index[] cycle to output index = new  twod index[total cycles  +  1] ;  final int[] output cycles = get output cycles (  )  ;  final int[] output lengths = get output read lengths (  )  ;  int output cycle index = 0 ;  int arr index = 0 ;  int element index = 0 ;  for  ( int i = 1 ;  i  <  =  total cycles && output cycle index  <  output cycles . length ;  i +  +  )   {  if  ( output cycles[output cycle index]  =  =  i )   {  if  ( element index  >  =  output lengths[arr index] )   {  element index = 0 ;   +  + arr index ;   }  cycle to output index[i] = new  twod index ( arr index element index )  ;   +  + element index ;   +  + output cycle index ;   }   }  if  ( output cycle index  !  =  output cycles . length )   {  throw new  picard exception ( " error in read structure output cycles  ( "  +   string util . int values to string ( output cycles )   +  " )  and total cycles  ( " +  total cycles +  " )   output cycle index ( " +  output cycle index +  " ) " )  ;   }  return cycle to output index ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  atomic reference <  throwable >  error = new  atomic reference <  throwable >  (  )  ;  final  test exception ex = new  test exception (
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . is empty (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  throws  exception  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  composite disposable composite = new  composite disposable (  )  ;  try  {  final  count down latch cdl = new  count 
public void   (  stat log log )  {     stat log = log ;  for  (   rate stat rs :    rate stats . values (  )  )   {  rs . set stat log ( log )  ;   }   }  
@ override public void   (  pooled object < smpp session >  pooled object )  throws  exception  {  final smpp session session = pooled object . get object (  )  ;   log . debug ( " destroying a pooled session with id ' {  } ' . " session . get session id 
@ test public void   (  )  throws io exception  sax exception  {  mock request . add header ( accept application   xml   value )  ;  mock request . set content ( content empty )  ;  http servlet request wrapper = new  http servlet request wrapper ( mock r
public   ( i2p snark util util  string torrent byte[] ih  string trackerurl  complete listener complistener  peer coordinator set peer coordinator set  connection acceptor connection acceptor boolean start  string root dir )  {  complete listener = complistener ;     util = util ;     log = util . get context (  )  . log manager (  )  . get log (  snark . class )  ;     peer coordinator set = peer coordinator set ;  acceptor = connection acceptor ;  this . torrent = torrent ;  this . info hash = ih ;  this . additional trackerurl = trackerurl ;  this . root data dir = root dir  !  =  null  ?  new  file ( root dir )  : null ;  saved uploaded = 0 ;  stopped = true ;  id = generateid (  )  ;  if  ( start )  start torrent (  )  ;   }  
public void   (  query listener query listener )  {   service state table state table = get service state table (  )  ;  int table size = state table . size (  )  ;  for  ( int n = 0 ;  n  <  table size ;  n +  +  )   {   state variable var = state table . get state variable ( n )  ;  var . set query listener ( query listener )  ;   }   }  
void   ( int size )  {  peer . uploaded ( size )  ;  listener . uploaded ( peer size )  ;   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  expect login ( mock )  ;   folder folder = m store . get folder ( "\u65e5\u672c\u8a9e" )  ;  assert true ( folder . can create (  folder type . holds   messages )  )  ;  mock . expect ( get next tag ( false )   +  " create \\\"& ze vnl iqe - \\\"" new  string[] { get next tag ( true )   +  " ok  success" }  )  ;  assert true ( folder . create (  folder type . holds   messages )  )  ;  expect noop ( mock true )  ;  mock . expect ( get next tag ( false )   +  " create \\\"& ze vnl iqe - \\\"" new  string[] { get next tag ( true )   +  " no  can't create folder" }  )  ;  assert false ( folder . create (  folder type . holds   messages )  )  ;   }  
void   (  inner observer inner  throwable e )  {  set . delete ( inner )  ;  if  ( errors . add throwable ( e )  )   {  if  (  ! delay errors )   {  d . dispose (  )  ;  set . dispose (  )  ;   }  active . decrement and get (  )  ;  drain (  )  ;   }  else  {   rx java plugins . on error ( e )  ;   }   }  
public   (  local session session )  {  this . session = session ;   }  
private void   (  )  {   simple timer2 .  timed event ev =    resend event ;  if  ( ev  !  =  null )  ev . cancel (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . empty (  )  . buffer ( 1  time unit . days )  . test (  )  . assert result (  collections . empty list (  )  )  ;   }  
@ override public void   (  disposable s )  {   disposable helper . set once ( this . s s )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . distinct (  functions . identity (  )  new  callable <  collection <  object >  >  (  )  {  @ override public  collection <  object >  call (  )  throws  exception  {  throw new  test exception (  ) 
private static  action   ( final  list <  string >  events )  {  return new  action (  )  {  @ override public void run (  )  {  events . add ( "unsub" )  ;   }   }   ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  list composite disposable cd = new  list composite disposable (  )  ;   runnable run = new  runnable (  )  {  @ override public void run
private void   (  reader in )  throws io exception  {  try  {  sax reader xml reader = new sax reader (  )  ;  xml reader . set encoding ( "utf - 8" )  ;  document = xml reader . read ( in )  ;   }  catch  (   exception e )   {   log . error ( " error reading xml properties" e )  ;  throw new io exception ( e . get message (  )  )  ;   }   }  
@ suppress warnings ( "unchecked" )  public static  < t >  subscriber < t >    (  )  {  return  (  subscriber < t >  ) instance ;   }  
@ override public  subscriber   (  subscriber observer )  throws  exception  {  return observer ;   }  
void   (  publisher <  ?  >  first timeout indicator )  {  if  ( first timeout indicator  !  =  null )   {   timeout consumer consumer = new  timeout consumer ( 0l this )  ;  if  ( task . replace ( consumer )  )   {  first timeout indicator . subscribe ( consumer )  ;   }   }   }  
@ test public void   (  )  throws  exception  {  final dns util .  weighted host address hosta = new dns util .  weighted host address ( "hosta" 5222 1 0 )  ;  final dns util .  weighted host address hostb = new dns util .  weighted host address ( "hostb"
@ override public  get admin console info task   (  )  {  return this ;   }  
public   (  byte key[]  byte salt[] )  throws  exception  {  if  (  array extensions . get length ( key )  . int value (  )   !  =  16 )  throw new  exception ( " invalid key length . " )  ;  if  (  array extensions . get length ( salt )  . int value (  )   !  =  14 )  throw new  exception ( " invalid salt length . " )  ;     key = key ;     salt = salt ;     offset = new  byte[16] ;  for  (  integer num =  integer . value of ( 0 )  ;  num . int value (  )   <   array extensions . get length (    offset )  . int value (  )  ;   )   {     offset[num . int value (  ) ] =  byte . value of (  ( byte ) 0 )  ;   integer integer = num ;   integer integer2 = num =  integer . value of ( num . int value (  )   +  1 )  ;   integer    tmp = integer ;   }  for  (  integer num =  integer . value of ( 0 )  ;  num . int value (  )   <   array extensions . get length (    salt )  . int value (  )  ;   )   {     offset[num . int value (  ) ] =    salt[num . int value (  ) ] ;   integer integer1 = num ;   integer integer3 = num =  integer . value of ( num . int value (  )   +  1 )  ;   integer    tmp1 = integer1 ;   }   }  
public boolean   ( int current )  throws sql exception  {  return stmt . get more results ( current )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test helper . check disposed ( pp . single element (  )  . is empty (  )  )  ;   }  
@ test public void   (  )  {  final  atomic integer emitted = new  atomic integer (  )  ;   flowable <  integer >  xs =  flowable . range ( 0  flowable . buffer size (  )  * 2 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void a
public   (  throwable t )  {  super ( "xml  parse  error" t )  ;   }  
public   ( final  handler handler final  context context final long account id )  {  super ( handler )  ;  m context = context ;  m account id = account id ;   }  
public   (  )  {  if  ( reader pool  =  =  null )   {  initialize pool (  )  ;   }   }  
public  map <  string  object >    (  )  {  return get config (  sql statements . class )  . get attributes (  )  ;   }  
public   (  )  {  this . map = new  concurrent hash map < k  atomic integer >  (  )  ;   }  
@ override public  resources   (  )  {  return m base context . get resources (  )  ;   }  
public void   ( int current substep )  {  this . current substep = current substep ;  last active date = new  date (  )  ;   }  
private static  < t >  list <  list < t >  >    (  flowable <  flowable < t >  >  observables )  {  final  list <  list < t >  >  lists = new  array list <  list < t >  >  (  )  ;   flowable . concat ( observables . map ( new  function <  flowable < t >   flowable <  list < t >  >  >  (  )  {  @ override public  flowable <  list < t >  >  apply (   flowable < t >  xs )  {  return xs . to list (  )  . to flowable (  )  ;   }   }   )  )  . blocking for each ( new  consumer <  list < t >  >  (  )  {  @ override public void accept (   list < t >  xs )  {  lists . add ( xs )  ;   }   }   )  ;  return lists ;   }  
public  node subscription   (  )  {  if  ( subscription  =  =  null )   {  subscription = new  node subscription ( get node (  )  owner sub jid state sub id )  ;   }  return subscription ;   }  
public  result set   (  string    sql )  throws sql exception  {  long t1 =  system . current time millis (  )  ;   result set result = cstmt . execute query (    sql )  ;  long t2 =  system . current time millis (  )  ;   string sqll =    sql . to lower case (  )  . trim (  )  ;  if  ( sqll . starts with ( "insert" )  )   {  add query (  type . insert    sql t2  -  t1 )  ;   }  else if  ( sqll . starts with ( "update" )  )   {  add query (  type . update    sql t2  -  t1 )  ;   }  else if  ( sqll . starts with ( "delete" )  )   {  add query (  type . delete    sql t2  -  t1 )  ;   }  else  {  add query (  type . select    sql t2  -  t1 )  ;   }  return result ;   }  
@ override public  string   (  )  {  return " response buffer commitment callback" ;   }  
@ override public void   (  throwable e )  {   system . out . println ( " >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  >  on error received: "  +  e )  ;  threads running . increment and get (  )  ;  try  {  on error = true ;   }  finally  {  
public void   (  data output out  map <  string  set <  string >  >  map )  throws io exception  {  strategy . write strings map ( out map )  ;   }  
public static  relay channel   ( final  string host final int min port final int max port )  throws io exception  {  int range = max port  -  min port ;  io exception be = null ;  for  ( int t = 0 ;  t  <  50 ;  t +  +  )   {  try  {  int a =  math . round (  ( int )  (  math . random (  )  * range )  )   +  min port ;  a = a % 2  =  =  0  ?  a : a  +  1 ;  return new  relay channel ( host a )  ;   }  catch  (   bind exception e )   {  be = e ;   }  catch  (  io exception e )   {  be = e ;   }   }  throw be ;   }  
@ override public  void   (  )  {  return null ;   }  
@ override public  string   (  )  {  return this . ref  +  " > "  +  this . call ;   }  
@ override public int   (  )  {  return  ( error correction level . ordinal (  )   <  <  3 )  | data mask ;   }  
public  string   (  )  {  if  ( parser  =  =  null )  initialize parser (  )  ;  return parser . get file name (  )  ;   }  
public boolean   (  )  {  return starting && stopped ;   }  
public   ( final  file pos file )  {  super ( pos file )  ;  this . parser = new  basic input parser ( true pos file )  ;   }  
@ override public void   (  throwable e )  {  parent . error ( this e )  ;   }  
private void   (  request request  request event request event )  throws  exception  {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( request . to string (  )  )  ;   }   response response = message factory . create response (  response . ok request )  ;   server transaction server transaction = request event . get server transaction (  )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " response "  +  response )  ;   }  if  ( server transaction  !  =  null )   {  server transaction . send response ( response )  ;   }  else  {  sip provider . send response ( response )  ;   }   }  
public  string   ( int tunnel )  {  return    helper . get inbound random key ( tunnel )  ;   }  
@ test public void   (  )  {  for  ( int i = 1 ;  i  <  =  1024 ;  i = i * 2 )   {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;   flowable . range ( 1 1000 * 1000 )  . observe on (  schedulers . computation (  )  false i )  . sub
public int   ( int port )  {  for  (  i2p tunneldcc client tun :    complete . values (  )  )   {  if  ( tun . get remote port (  )   =  =  port )  return new incoming ( tun . get dest (  )  port "accept" tun . get local port (  )  )  ;   }  for  (  i2p tunneldcc client tun :    active . values (  )  )   {  if  ( tun . get remote port (  )   =  =  port )  return new incoming ( tun . get dest (  )  port "accept" tun . get local port (  )  )  ;   }  for  (  i2p tunneldcc client tun :    incoming . values (  )  )   {  if  ( tun . get remote port (  )   =  =  port )   {  tun . stop (  )  ;  return new incoming ( tun . get dest (  )  port "accept" tun . get local port (  )  )  ;   }   }  return  - 1 ;   }  
private final static byte[]   ( int options )  {  if  (  ( options & url   safe )   =  =  url   safe )  return    url   safe   alphabet ;  else if  (  ( options & ordered )   =  =  ordered )  return    ordered   alphabet ;  else return    standard   alphabet ;   }  
public int   (  )  {   audio source audio source = this . audio source ;  if  ( audio source  =  =  null )   {  audio source = get audio source (  )  ;   }  if  ( audio source  =  =  null )   {  return 0 ;   }  return audio source . get sample rate (  )  ;   }  
@ test ( data provider = "shard data provider" )  public void   ( final  list <  file >  inputs )  throws io exception  {  final  file merged file prefix = new  file ( test   data   dir  +  "merge test" )  ;  final  file merged summary file = new  file ( 
@ override public  integer   (  )  {  return 5 ;   }  
@ benchmark public void   (  blackhole bh )  {  pipeline maybe . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
public static  language   ( final  string converse code )  {  for  (  final  language language : values (  )  )   {  if  ( language . get code (  )  . equals ignore case ( converse code )  )   {  return language ;   }   }  return null ;   }  
@ override public  object   (  mutable m )  throws  exception  {  return m . value ;   }  
@ after method private void   (  )  {  io util . delete directory tree ( intensity dir )  ;   }  
public  string   (  )  {  if  (    helper  =  =  null )  return "" ;  return    helper . get memory bar (  )  ;   }  
private static void   ( int indent levels  string text  string value )  {  if  ( value  =  =  null || value . length (  )   =  =  0 )   {  return ;   }  while  ( indent levels -  -   >  0 )   {   system . out . print ( "\t" )  ;   }  if  ( text  !  =  null && text . length (  )   >  0 )   {   system . out . print ( text )  ;   system . out . print ( " " )  ;   }   system . out . println ( value )  ;   }  
public  tunnel id   ( int hop )  {  return    config[hop] . get receive tunnel (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . from single ( null )  ;   }  
@ override public void   (  disposable d )  {  ds[0] = d ;   }  
public static void   (  string conference id  string treatment )  throws  parse exception  {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( "playing treatment "  +  treatment  +  " to " +  conference id )  ;   }  synchronized  ( conference list )   {   conference manager conference manager ;  conference manager = find conference manager ( conference id )  ;  try  {  conference manager . add treatment ( treatment )  ;   }  catch  (  io exception e )   {  throw new  parse exception ( "bad treatment "  +  " "  +  e . get message (  )  0 )  ;   }  return ;   }   }  
private  string   (  string uri )  {  return uri . create ( uri )  . get path (  )  ;   }  
@ override public void   (  observer <  ?  super t >  t )  {  source . subscribe ( new  skip last timed observer < t >  ( t time unit scheduler buffer size delay error )  )  ;   }  
public   (  publisher < t > [] sources )  {  this . sources = sources ;   }  
private static void   (  byte matrix matrix )  throws  writer exception  {  if  ( matrix . get ( 8 matrix . get height (  )   -  8 )   =  =  0 )   {  throw new  writer exception (  )  ;   }  matrix . set ( 8 matrix . get height (  )   -  8 1 )  ;   }  
@ override public void   (  )  {  queue . clear (  )  ;   }  
public  string   (  )  {  return " jetty "  +   arrays . to string (    args )  ;   }  
@ override public  collection <  user >    (  set <  string >  fields  string query int start index int num results )  throws  unsupported operation exception  {  if  ( fields . is empty (  )  )   {  return  collections . empty list (  )  ;   }  if  (  ! 
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  actual . on success ( false )  ;   }   }  
@ override public  string   (  )  {  return "obep "  +     config . get receive tunnel (  )  ;   }  
@ override protected void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 2 )  ;   }  
public synchronized  session key   (  )  {  return    session key ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   consumer <  integer >  source next = mock (  consumer . class )  ;   action source completed = mock (  action . class )  ;   action source unsubscribed = mock (  action
public boolean   (  )  {  return false ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . dispose (  )  ;  on error ( e )  ;  return ;   }  if  ( b
@ override public double   (  )  {  double msgcnt = 0 ;  for  (   multi user chat service service : get multi user chat services (  )  )   {  msgcnt +  = service . get outgoing message count ( true )  ;   }  return msgcnt ;   }  
private void   (  string treatment )  throws io exception  {  int[] linear data = null ;  try  {  linear data =  freetts client . text to speech ( treatment )  ;   }  catch  (  io exception e )   {   logger . println ( " can't convert text to speech '"  +  treatment  +  "' " +  e . get message (  )  )  ;  throw new io exception ( " can't convert text to speech '"  +  treatment  +  "'" )  ;   }  treatment = " freetts" ;  synchronized  ( treatments )   {  treatments . add ( new  linear data audio source ( linear data 16000 1 )  )  ;   }   }  
@ override public  collection <  integer >    (  )  throws  exception  {  return null ;   }  
@ override public v   ( k key v value )  {  if  ( value  =  =  null )   {  return remove ( key )  ;   }  else  {  return put ( key value true )  ;   }   }  
public void   (  bit matrix mask )  {  if  ( width  !  =  mask . get width (  )  || height  !  =  mask . get height (  )  || row size  !  =  mask . get row size (  )  )   {  throw new  illegal argument exception ( "input matrix dimensions do not match" )  ;   }   bit array row array = new  bit array ( width  /  32  +  1 )  ;  for  ( int y = 0 ;  y  <  height ;  y +  +  )   {  int offset = y * row size ;  int[] row = mask . get row ( y row array )  . get bit array (  )  ;  for  ( int x = 0 ;  x  <  row size ;  x +  +  )   {  bits[offset  +  x]^ = row[x] ;   }   }   }  
@ override public  set < k >    (  )  {  return new  persistence aware key set < k >  ( super . key set (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  i2p app context context = i2p app context . get global context (  )  ;     log = context . log manager (  )  . get log (  connectit . class )  ;     log . debug ( "creating server dest" )  ;     server dest
@ override public boolean   (  file f )  throws io exception  {  return true ;   }  
private long   (  )  {  return  jive globals . get int property ( "xmpp . live . request . overflow" 3 )  ;   }  
@ override public void   (  )  {  throw new  unsupported operation exception ( " read only iterator" )  ;   }  
public static  string   (  )  {  if  ( override ip  !  =  null && override ip . length (  )   >  =  7 )   {  return override ip ;   }   enumeration ifaces ;  try  {  ifaces =  network interface . get network interfaces (  )  ;  while  ( ifaces . has more elements (  )  )   {   network interface iface =  (  network interface ) ifaces . next element (  )  ;   enumeration iaddresses = iface . get inet addresses (  )  ;  while  ( iaddresses . has more elements (  )  )   {   inet address iaddress =  (  inet address ) iaddresses . next element (  )  ;  if  (  ! iaddress . is loopback address (  )  &&  ! iaddress . is link local address (  )  &&  ! iaddress . is site local address (  )  )   {  return iaddress . get host address (  )   !  =  null  ?  iaddress . get host address (  )  : iaddress . get host name (  )  ;   }   }   }  ifaces =  network interface . get network interfaces (  )  ;  while  ( ifaces . has more elements (  )  )   {   network interface iface =  (  network interface ) ifaces . next element (  )  ;   enumeration iaddresses = iface . get inet addresses (  )  ;  while  ( iaddresses . has more elements (  )  )   {   inet address iaddress =  (  inet address ) iaddresses . next element (  )  ;  if  (  ! iaddress . is loopback address (  )  &&  ! iaddress . is link local address (  )  )   {  return iaddress . get host address (  )   !  =  null  ?  iaddress . get host address (  )  : iaddress . get host name (  )  ;   }   }   }  return  inet address . get local host (  )  . get host address (  )   !  =  null  ?   inet address . get local host (  )  . get host address (  )  :  inet address . get local host (  )  . get host name (  )  ;   }  catch  (   socket exception e )   {  e . print stack trace (  )  ;   }  catch  (   unknown host exception e )   {  e . print stack trace (  )  ;   }  return "127 . 0 . 0 . 1" ;   }  
public  string   (  )  {   string str = format messages (    context . log manager (  )  . get buffer (  )  . get most recent messages (  )  )  ;  return " < p > "  +     t ( " file location" )   +  ":  < a href = \" / router . log\" target = \"   blank\" > " +     context . log manager (  )  . current file (  )  +  " <  / a >  <  / p > " +  str ;   }  
public   ( jid handlerjid )  {  this . handler = handlerjid ;  this . nodeid = xmpp server . get instance (  )  . get nodeid (  )  . to byte array (  )  ;   }  
public void   (  )  {  final  content resolver resolver = m mock context . get content resolver (  )  ;   account account1 =  provider test utils . setup account ( "orphaned body" true m mock context )  ;  long account1 id = account1 . m id ;   mailbox box1 =  provider test utils . setup mailbox ( "box1" account1 id true m mock context )  ;  long box1 id = box1 . m id ;   message message1 =  provider test utils . setup message ( "message1" account1 id box1 id false true m mock context )  ;  long message1 id = message1 . m id ;   message message2 =  provider test utils . setup message ( "message1" account1 id box1 id true true m mock context )  ;  long message2 id = message2 . m id ;  assert not null ( load body for message id ( message2 id )  )  ;  resolver . delete (  content uris . with appended id (  message . content   uri message1 id )  null null )  ;  assert not null ( load body for message id ( message2 id )  )  ;  resolver . delete (  content uris . with appended id (  message . content   uri message2 id )  null null )  ;  assert null ( load body for message id ( message2 id )  )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . retry until ( new  boolean supplier (  )  {  @ override public boolean get as boolean (  )  throws  exception  {  ret
@ benchmark public  big integer   (  inverse state s )  {  return s . k . mod inverse ( s . p )  ;   }  
public void   ( int size )  {  if  ( size  <  =  0 || size  >     original buffer size )  return ;     next buffer size = size ;   }  
public  data structure   (  )  {  return new  destroy session message (  )  ;   }  
public void   (  )  {  synchronized  (    selectors )   {     selectors . clear (  )  ;   }  synchronized  (    selector to message )   {     selector to message . clear (  )  ;   }     active messages . clear (  )  ;   }  
@ test ( data provider = " " )  public void test simple duplicate ( final  string test name final int num duplicates final int num read pairs examined )  throws io exception  {  final  file input = new  file ( test   data   dir test name )  ;  final  file
public   (  )  {  all mechanisms = new  hash set <  >  (  )  ;  all mechanisms . add ( new  mechanism ( "anonymous" true true )  )  ;  all mechanisms . add ( new  mechanism ( "plain" false true )  )  ;  all mechanisms . add ( new  mechanism ( "scram - sha - 1" false false )  )  ;  all mechanisms . add ( new  mechanism ( "jive - sharedsecret" true false )  )  ;  all mechanisms . add ( new  mechanism ( "external" false false )  )  ;   }  
public   (  handle handle  string sql )  {  super ( handle sql )  ;   }  
public   (  context mock context  context real context )  {  super ( mock context )  ;  m real context = real context ;   }  
protected   (  )  {     log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout (  flowable . never (  )  new  function <  integer  publisher <  object >  >  (  )  {  @ override public  publisher <  object >  apply (   integer v )  {  return
public void   (  string email subject )  {  this . email subject = email subject ;   }  
public static void   (  string args[] )  {  if  ( args . length  =  =  0 )   {   system . out . println ( "usage: java  phone prefix  < location >   < location >   .  .  . " )  ;   system . exit ( 1 )  ;   }  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )   {   string prefix = get prefix ( args[i] )  ;  if  ( prefix . equals ( "" )  )   {   system . out . println ( "no prefix needed for location "  +  args[i] )  ;   }  else  {   system . out . println ( "prefix "  +  prefix  +  " needed for location " +  args[i] )  ;   }   }   }  
protected  string[]   (  )  {  if  (  ( program   record   id  !  =  null || program   group   version  !  =  null || program   group   command   line  !  =  null )  &&  ( program   record   id  =  =  null || program   group   version  =  =  null || program   group   command   line  =  =  null )  )   {  return new  string[] { "program   record   id  program   group   version  and "  +  "program   group   command   line must all be supplied or none should "  +  "be included . " }  ;   }  final boolean r1s exist = read1   aligned   bam  !  =  null &&  ! read1   aligned   bam . is empty (  )  ;  final boolean r2s exist = read2   aligned   bam  !  =  null &&  ! read2   aligned   bam . is empty (  )  ;  if  (  ( r1s exist &&  ! r2s exist )  ||  ( r2s exist &&  ! r1s exist )  )   {  return new  string[] { "read1   aligned   bam and read2   aligned   bam "  +  "must both be supplied or neither should be included .   for "  +  "single - end read use aligned   bam . " }  ;   }  if  ( aligned   bam  =  =  null || aligned   bam . is empty (  )  &&  !  ( r1s exist && r2s exist )  )   {  return new  string[] { " either aligned   bam or the combination of "  +  "read1   aligned   bam and read2   aligned   bam must be supplied . " }  ;   }  return null ;   }  
@ override public  result   (  )  {  return get contact info ( m context m email address )  ;   }  
public void   (  )  {  streams . clear (  )  ;   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . scan ( new  bi function <  object  object  object >  (  )  {  @ override public  object apply (   object a   object b )  throws  exception  {  return a ;   }   }   )  . tes
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   flowable <  timed <  integer >  >  m = source . timestamp ( scheduler )  ;  m . subscrib
@put @ path ( " /  { group name } " )  public  response   ( @ path param ( "group name" )   string group name  group entity group entity )  throws  service exception  {  group controller . update group ( group name group entity )  ;  return  response . st
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber <  list <  integer >  >  ts = pp . to l
public  collection <  domain pair >    (  )  {  return routing table . get server routes (  )  ;   }  
public sam record   ( final int i )  {  if  ( i  >  =  first of pair or fragment . size (  )  )   {  return null ;   }  else  {  return first of pair or fragment . get ( i )  ;   }   }  
@ override public void   (  )  throws java . io . io exception  {  flush base64 (  )  ;  super . close (  )  ;  buffer = null ;  out = null ;   }  
public static void   (  session event listener listener )  {  if  ( listener  =  =  null )   {  throw new  null pointer exception (  )  ;   }  listeners . add ( listener )  ;   }  
public  string   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  if  ( tun  !  =  null )  return tun . get shared client (  )  ;  else return "" ;   }  
public void   (  string moo )  {     config . set reject inproxy ( true )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public void   ( boolean ishtml )  {  this . ishtml = ishtml ;   }  
public void   ( int i )  {  bits[i  /  32]^ = 1  <  <   ( i & 0x1f )  ;   }  
@ override public  publisher <  integer >    ( final long elements )  {  return  flowable . range ( 1 1000 )  . reduce ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  except
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer (  )  ;   maybe <  object >  completable =  maybe . from callable ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  ato
public void   ( int num msgs )  {     receive window = num msgs ;   }  
public int   (  )  {  return call answer timeout ;   }  
public   ( i2p app context ctx )  {  super ( ctx  dest reply message . message   type )  ;   }  
@ test public void   (  )  throws  exception  {  assert that ( h . create update ( u   insert )  . bind by type ( "u" new  array list <  >  (  arrays . as list ( test uuids )  )  uuid   list )  . execute (  )  )  . is equal to ( 1 )  ;  assert that ( h . 
public void   (  string agentjid )  {  this . agentjid = agentjid ;   }  
public static  string   (  string name )  {  name = name . trim (  )  ;   string builder buf = new  string builder ( name . length (  )  )  ;  buf . append ( "utf - 8''" )  ;  for  ( int i = 0 ;  i  <  name . length (  )  ;  i +  +  )   {  char c = name . char at ( i )  ;  if  ( c  <  32 ||  ( c  >  =  0x7f && c  <  =  0x9f )  || c  =  =  ' < ' || c  =  =  ' > ' || c  =  =  ':' || c  =  =  '"' || c  =  =  ' / ' || c  =  =  '\\' || c  =  =  '|' || c  =  =  ' ? ' || c  =  =  '*' || c  =  =  0x2028 || c  =  =  0x2029 )   {  buf . append ( '   ' )  ;   }  else if  ( c  =  =  ' ' || c  =  =  '\'' || c  =  =  '%' || c  =  =  ' ( ' || c  =  =  ' ) ' || c  =  =  '@' || c  =  =  ' ' || c  =  =  ' ; ' || c  =  =  '[' || c  =  =  ']' || c  =  =  ' = ' || c  =  =  ' { ' || c  =  =  ' } ' )   {  buf . append (  hex table . table[c] . replace ( ' = ' '%' )  )  ;   }  else if  ( c  <  0x7f )   {  buf . append ( c )  ;   }  else  {  byte[] utf =  data helper . getutf8 (  string . value of ( c )  )  ;  for  ( int j = 0 ;  j  <  utf . length ;  j +  +  )   {  int b = utf[j] & 0xff ;  buf . append (  hex table . table[b] . replace ( ' = ' '%' )  )  ;   }   }   }  return buf . to string (  )  ;   }  
private  function3 <  string  string  string  string >    (  )  {   function3 <  string  string  string  string >  combine latest function = new  function3 <  string  string  string  string >  (  )  {  @ override public  string apply (   string a1   string a2   string a3 )  {  if  ( a1  =  =  null )   {  a1 = "" ;   }  if  ( a2  =  =  null )   {  a2 = "" ;   }  if  ( a3  =  =  null )   {  a3 = "" ;   }  return a1  +  a2  +  a3 ;   }   }   ;  return combine latest function ;   }  
public  set < k >    (  )  {  return this . map . key set (  )  ;   }  
public boolean   (  )  {  return status . equals ( "open" )  ;   }  
public void   (  string value )  {  get state variable node (  )  . set node ( name value )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on lifecycle ( null new  long consumer (  )  {  @ override public void accept (  long v )  {   }   }   new  action (  )  {  @ override public void run (  )  {   }   }
public   ( boolean verify  file privkey  string privkeyname  logging l  event dispatcher notify this i2p tunnel tunnel )  {  super ( "udp server  <  -  "  +  privkeyname notify this tunnel )  ;     log = tunnel . get context (  )  . log manager (  )  . get log ( i2p tunneludp server base . class )  ;   file input stream fis = null ;  try  {  fis = new  file input stream ( privkey )  ;  init ( verify fis privkeyname l )  ;   }  catch  (  io exception ioe )   {     log . error ( " error starting server" ioe )  ;  notify event ( "open server result" "error" )  ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
@ before public void   (  )  throws  exception  {   configuration service configuration service = mock (  configuration service . class )  ;   string configuration root = "" ;  filter = new  translation filter ( configuration service configuration root ) 
@ test public void   (  )  {  boolean trace = true ;  boolean add header = true ;  long total millis = 0 ;  final  request tracer rt = new  request tracer ( trace add header )  ;  for  ( int i = 0 ;  i  <  100 ;   +  + i )   {  rt . trace enter (  )  ;  r
@ override public void   ( long n )  {   system . out . println ( "2 - requested: "  +  n )  ;  requested2 . set ( n )  ;   }  
public int   (  )  {  return max count ;   }  
@ override public boolean   (  integer v )  throws  exception  {  if  ( v  =  =  10 )   {  throw new  test exception (  )  ;   }  return v % 2  =  =  0 ;   }  
public  string   (  string s  string p int n )  {  return  messages . get string ( n s p    context )  ;   }  
@ test public void   (  )  {  for  ( int i =  - 100 ;  i  <  100 ;  i +  +  )   {   assert . assert equals (  read name parser . rapid parse int (  integer . to string ( i )  )  i )  ;   assert . assert equals (  read name parser . rapid parse int (  inte
@ override public void   (  bundle saved instance state )  {  super . on create ( saved instance state )  ;  set has options menu ( true )  ;  add preferences from resource ( r . xml . account   settings   preferences )  ;  if  (  ! get resources (  )  . 
public   ( final  string sample final  string library final  string read group )  {  this . sample = sample ;  this . library = library ;  this . read group = read group ;   string prefix = null ;  if  ( this . read group  !  =  null )   {  prefix = this . read group  +  " . " ;   }  else if  ( this . library  !  =  null )   {  prefix = this . library  +  " . " ;   }  else if  ( this . sample  !  =  null )   {  prefix = this . sample  +  " . " ;   }  else  {  prefix = " all    reads . " ;   }  histograms . put (  sam pair util .  pair orientation . fr new  histogram <  integer >  ( "insert   size" prefix  +  "fr   count" )  )  ;  histograms . put (  sam pair util .  pair orientation . tandem new  histogram <  integer >  ( "insert   size" prefix  +  "tandem   count" )  )  ;  histograms . put (  sam pair util .  pair orientation . rf new  histogram <  integer >  ( "insert   size" prefix  +  "rf   count" )  )  ;   }  
public   ( int i int j byte abyte0[] byte abyte1[]  peer p )  {  n = new b (  )  ;  g = new com . jcumulus . server . rtmfp . pipe . b (  )  ;  a = 0 ;  u = false ;  l = new  hash map (  )  ;  p = 1 ;  c = new  hash map (  )  ;  t = new  hash map (  )  ;  h = 0 ;  f = false ;  i = false ;  o = i ;  d = j ;  m = p ;  m . a ( new  client handler (  )  )  ;  s = new k ( abyte0 com . jcumulus . server . rtmfp . k .  encryption . decrypt )  ;  k = new k ( abyte1 com . jcumulus . server . rtmfp . k .  encryption . encrypt )  ;  n . e ( 11 )  ;  n . c ( com . jcumulus . server . rtmfp . n . g )  ;   }  
@ setup public void   (  )  {  data = new byte[len] ;  ctx . random (  )  . next bytes ( data )  ;   }  
public void   ( final long heartbeat )  throws  rrd exception  io exception  {  if  ( heartbeat  <  1l )   {  throw new  rrd exception ( " invalid heartbeat specified: "  +  heartbeat )  ;   }  this . heartbeat . set ( heartbeat )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic integer count = new  atomic integer (  )  ;  final  atomic reference <  throwable >  error = new  atomic reference <
public static long   (  atomic long requested long n )  {  for  (  ;   ;   )   {  long current = requested . get (  )  ;  if  ( current  =  =   long . max   value )   {  return  long . max   value ;   }  long update = current  -  n ;  if  ( update  <  0l )   {   rx java plugins . on error ( new  illegal state exception ( " more produced than requested: "  +  update )  )  ;  update = 0l ;   }  if  ( requested . compare and set ( current update )  )   {  return update ;   }   }   }  
private void   (  string builder buf )  {   list <  string >  list = new  array list <  string >  (    clients . size (  )  )  ;  for  (   map .  entry <  client app  string[] >  entry :    clients . entry set (  )  )   {   client app key = entry . get key (  )  ;   string[] val = entry . get value (  )  ;  list . add ( "[ < b > "  +  key . get name (  )   +  " <  / b > ]  =  [" +  key . get class (  )  . get name (  )  +  ' ' +   arrays . to string ( val )  +  "]  < i > " +  key . get state (  )  +  " <  / i >  < br > " )  ;   }   collections . sort ( list )  ;  for  (   string e : list )   {  buf . append ( e )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp =  publish process
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 5 )  . concat with (  completable . from action ( new  action (  )  {  @ override public void run (  )  throws  excepti
public static  array list <  string >    (  string policy string  array list <  string >  policy list )  {  if  ( policy string  !  =  null )   {  int start = 0 ;  int len = policy string . length (  )  ;  while  ( start  <  len )   {  int end = policy string . index of ( policy   string   delimiter start )  ;  if  ( end  >  start )   {  policy list . add ( policy string . substring ( start end )  )  ;  start = end  +  1 ;   }  else  {  break ;   }   }   }  return policy list ;   }  
@ override public void   (  object value )  {  bh . consume ( value )  ;  count down (  )  ;   }  
@ override protected int   (  )  {  return 1 ;   }  
public static void   (  context context  message message  email content .  message local message int load status )  {  try  {   email content .  body body = null ;  if  ( local message . m id  !  =   email content .  message . no   message )   {  body =  email content .  body . restore body with message id ( context local message . m id )  ;   }  if  ( body  =  =  null )   {  body = new  email content .  body (  )  ;   }  try  {   legacy conversions . update message fields ( local message message local message . m account key local message . m mailbox key )  ;   array list <  part >  viewables = new  array list <  part >  (  )  ;   array list <  part >  attachments = new  array list <  part >  (  )  ;   mime utility . collect parts ( message viewables attachments )  ;  final  conversion utilities .  body field data data =  conversion utilities . parse body fields ( viewables )  ;  local message . set flags ( data . is quoted reply data . is quoted forward )  ;  local message . m snippet = data . snippet ;  body . m text content = data . text content ;  body . m html content = data . html content ;  save or update ( local message context )  ;  body . m message key = local message . m id ;  save or update ( body context )  ;  if  ( load status  !  =   email content .  message . flag   loaded   partial && load status  !  =   email content .  message . flag   loaded   unknown )   {   legacy conversions . update attachments ( context local message attachments )  ;   legacy conversions . update inline attachments ( context local message viewables )  ;   }  else  {   email content .  attachment att = new  email content .  attachment (  )  ;  att . m file name = "" ;  att . m size = message . get size (  )  ;  att . m mime type = "text / plain" ;  att . m message key = local message . m id ;  att . m account key = local message . m account key ;  att . m flags =  attachment . flag   dummy   attachment ;  att . save ( context )  ;  local message . m flag attachment = true ;   }  local message . m flag loaded = load status ;   content values cv = new  content values (  )  ;  cv . put (  email content .  message columns . flag   attachment local message . m flag attachment )  ;  cv . put (  email content .  message columns . flag   loaded local message . m flag loaded )  ;   uri uri =  content uris . with appended id (  email content .  message . content   uri local message . m id )  ;  context . get content resolver (  )  . update ( uri cv null null )  ;   }  catch  (   messaging exception me )   {   log utils . e (  logging . log   tag " error while copying downloaded message . "  +  me )  ;   }   }  catch  (   runtime exception rte )   {   log utils . e (  logging . log   tag " error while storing downloaded message . "  +  rte . to string (  )  )  ;   }  catch  (  io exception ioe )   {   log utils . e (  logging . log   tag " error while storing attachment . "  +  ioe . to string (  )  )  ;   }   }  
public void   ( final  file output final  file ref file )  throws  file not found exception  {   reference sequence file ref = new  indexed fasta sequence file ( ref file )  ;  try  (  variant context writer writer = new  variant context writer builder (  )  . set output file ( output )  . set reference dictionary ( ref . get sequence dictionary (  )  )  . build (  )  )  {  final vcf header vcf header = new vcf header ( vcf utils . with updated contigs as lines (  collections . empty set (  )  ref file header . get sequence dictionary (  )  false )   collections . singleton ( het   genotype   for   phasing )  )  ;  vcf utils . with updated contigs as lines (  collections . empty set (  )  ref file header . get sequence dictionary (  )  false )  ;  vcf header . add meta data line ( new vcf header line ( vcf header version . vcf4   2 . get format string (  )  vcf header version . vcf4   2 . get version string (  )  )  )  ;  vcf header . add meta data line ( new vcf info header line ( vcf constants . allele   frequency   key vcf header line count . a vcf header line type .  float " allele  frequency  for each alt allele  in the same order as listed" )  )  ;  vcf header . add meta data line ( new vcf format header line ( vcf constants . genotype   key 1 vcf header line type .  string " genotype" )  )  ;  vcf header . add meta data line ( new vcf format header line ( vcf constants . phase   set   key 1 vcf header line type .  string " phase - set identifier for phased genotypes . " )  )  ;  vcf header . add meta data line ( new vcf header line ( vcf header . source   key " haplotype map::write as vcf" )  )  ;  vcf header . add meta data line ( new vcf header line ( "reference" " haplotype map::write as vcf" )  )  ;  writer . write header ( vcf header )  ;  final  linked list <  variant context >  variants = new  linked list <  >  ( this . as vcf ( ref )  )  ;  variants . sort ( vcf header . getvcf record comparator (  )  )  ;  variants . for each ( writer::add )  ;   }   }  
public   ( final  file clocs file )  {  super ( clocs file )  ;  byte iterator = m map backed iterator factory . get byte iterator ( header   size clocs file )  ;  final  byte buffer hbs = byte iterator . get header bytes (  )  ;  hbs . get (  )  ;  num bins =  unsigned type util . u int to long ( hbs . get int (  )  )  ;  x offset = 0 ;  y offset = 0 ;  current bin = 0 ;  start block (  )  ;  check and advance bin (  )  ;   }  
public void   (  tunnel id id )  {     tunnel id = id ;   }  
private void   (  string cmd )  throws io exception  {  if  (    log . should debug (  )  )     log . debug ( "smtp send cmd ( "  +  cmd  +  " ) " )  ;  if  ( socket  =  =  null )  throw new io exception ( "no socket" )  ;   output stream out = socket . get output stream (  )  ;  cmd +  = "\r\n" ;  out . write (  data helper . getascii ( cmd )  )  ;   }  
public  date   (  )  {  return date range max ;   }  
@ xml element ( name = "resource" )  public  string   (  )  {  return resource ;   }  
public void   ( javax . sip .  timeout event timeout event )  {  try  {   }  catch  (   exception e )   {   logger . exception ( "process timeout" e )  ;   }   }  
public sam file header   (  )  {  return this . header ;   }  
@ test public void   (  )  throws  exception  {   append only linked array list <  integer >  list = new  append only linked array list <  integer >  ( 3 )  ;  list . add ( 1 )  ;  list . add ( 2 )  ;  list . add ( 3 )  ;  final  list <  integer >  out = 
@ test public void   (  )  {  perform test using with observable factory error ( true )  ;   }  
@ override public void   (  )  throws  exception  {  d2 . dispose (  )  ;   }  
@ override public void   (  throwable e )  {  if  ( terminal event  =  =  null )   {  terminal event =  notification lite . error ( e )  ;  dispatch (  )  ;   }  else  {   rx java plugins . on error ( e )  ;   }   }  
@ override protected boolean   (  )  {  return false ;   }  
private static void   (  peer peer  peer listener listener byte[] bs  log log )  {  if  ( log . should log (  log . debug )  )  log . debug ( " got metadata msg from "  +  peer )  ;  try  {   input stream is = new  byte array input stream ( bs )  ;  b decoder dec = new b decoder ( is )  ;  be value bev = dec . bdecode map (  )  ;   map <  string be value >  map = bev . get map (  )  ;  int type = map . get ( "msg   type" )  . get int (  )  ;  int piece = map . get ( "piece" )  . get int (  )  ;   magnet state state = peer . get magnet state (  )  ;  if  ( type  =  =  type   request )   {  if  ( log . should log (  log . debug )  )  log . debug ( " got request for "  +  piece  +  " from: " +  peer )  ;  byte[] pc ;  int total size ;  synchronized  ( state )   {  pc = state . get chunk ( piece )  ;  total size = state . get size (  )  ;   }  send piece ( peer piece pc total size )  ;  peer . uploaded ( pc . length )  ;  listener . uploaded ( peer pc . length )  ;   }  else if  ( type  =  =  type   data )   {  boolean done ;  int chk =  - 1 ;  synchronized  ( state )   {  if  ( state . is complete (  )  )  return ;  int len = is . available (  )  ;  peer . downloaded ( len )  ;  listener . downloaded ( peer len )  ;  done = state . save chunk ( piece bs bs . length  -  len len )  ;  if  ( log . should log (  log . info )  )  log . info ( " got chunk "  +  piece  +  " from " +  peer )  ;  if  (  ! done )  chk = state . get next request (  )  ;   }  if  ( done )   {  if  ( log . should log (  log . warn )  )  log . warn ( " got last chunk from "  +  peer )  ;   }  else  {  if  ( log . should log (  log . info )  )  log . info ( " request chunk "  +  chk  +  " from " +  peer )  ;  send request ( peer chk )  ;   }   }  else if  ( type  =  =  type   reject )   {  if  ( log . should log (  log . warn )  )  log . warn ( " got reject msg from "  +  peer )  ;  peer . disconnect ( false )  ;   }  else  {  if  ( log . should log (  log . warn )  )  log . warn ( " got unknown metadata msg from "  +  peer )  ;  peer . disconnect ( false )  ;   }   }  catch  (   exception e )   {  if  ( log . should log (  log . info )  )  log . info ( " metadata ext .  msg .  exception from "  +  peer e )  ;  peer . disconnect ( false )  ;   }   }  
public static  string   (  string format  object arg0  object arg1  object arg2  object arg3 )  {  return  string . format ( reformat net format ( format 4 )  new  object[] { arg0 arg1 arg2 arg3 }  )  ;   }  
public long   (  data input in )  throws io exception  {  return  (  long ) read object ( in )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe <  integer >  error =  maybe . error ( new  runtime exception (  )  )  ;   maybe . amb array (  maybe . just ( 1 )  error )  . test (  )  . assert value ( 1 )  ;   }  
public boolean   (  )  {  return    isi pv6 ;   }  
  (  observer <  ?  super t >  actual )  {  this . actual = actual ;   }  
private void   ( byte b )  throws io exception  {  int c = b & 0xff ;  switch  (    state )   {  case mb1: if  ( c  !  =  0x1f )  throw new io exception ( " first magic byte was wrong ["  +  c  +  "]" )  ;     state =  header state . mb2 ;  break ;  case mb2: if  ( c  !  =  0x8b )  throw new io exception ( " second magic byte was wrong ["  +  c  +  "]" )  ;     state =  header state . cf ;  break ;  case cf: if  ( c  !  =  0x08 )  throw new io exception ( " compression format is invalid ["  +  c  +  "]" )  ;     state =  header state . flags ;  break ;  case flags:    flags = c ;     state =  header state . mt0 ;  break ;  case mt0:    state =  header state . mt1 ;  break ;  case mt1:    state =  header state . mt2 ;  break ;  case mt2:    state =  header state . mt3 ;  break ;  case mt3:    state =  header state . ef ;  break ;  case ef: if  (  ( c  !  =  0x00 )  &&  ( c  !  =  0x02 )  &&  ( c  !  =  0x04 )  )  throw new io exception ( " invalid extended flags ["  +  c  +  "]" )  ;     state =  header state . os ;  break ;  case os: if  ( 0  !  =   (    flags &  ( 1  <  <  5 )  )  )     state =  header state . eh1 ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  4 )  )  )     state =  header state . name ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  3 )  )  )     state =  header state . comment ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  6 )  )  )     state =  header state . crc1 ;  else    state =  header state . done ;  break ;  case eh1:    ext hdr to read = c ;     state =  header state . eh2 ;  break ;  case eh2:    ext hdr to read +  =  ( c  <  <  8 )  ;  if  (    ext hdr to read  >  0 )     state =  header state . ehdata ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  4 )  )  )     state =  header state . name ;  if  ( 0  !  =   (    flags &  ( 1  <  <  3 )  )  )     state =  header state . comment ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  6 )  )  )     state =  header state . crc1 ;  else    state =  header state . done ;  break ;  case ehdata: if  (  -  -    ext hdr to read  <  =  0 )   {  if  ( 0  !  =   (    flags &  ( 1  <  <  4 )  )  )     state =  header state . name ;  if  ( 0  !  =   (    flags &  ( 1  <  <  3 )  )  )     state =  header state . comment ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  6 )  )  )     state =  header state . crc1 ;  else    state =  header state . done ;   }  break ;  case name: if  ( c  =  =  0 )   {  if  ( 0  !  =   (    flags &  ( 1  <  <  3 )  )  )     state =  header state . comment ;  else if  ( 0  !  =   (    flags &  ( 1  <  <  6 )  )  )     state =  header state . crc1 ;  else    state =  header state . done ;   }  break ;  case comment: if  ( c  =  =  0 )   {  if  ( 0  !  =   (    flags &  ( 1  <  <  6 )  )  )     state =  header state . crc1 ;  else    state =  header state . done ;   }  break ;  case crc1:    state =  header state . crc2 ;  break ;  case crc2:    state =  header state . done ;  break ;  case done: default : break ;   }   }  
private boolean   (  )  {   string url =    context . get property (  config update handler . prop   zip   url )  ;  return url  !  =  null && url . length (  )   >  0 &&    context . get boolean property (  config update handler . prop   update   unsigned )  &&  !  news helper . dont install (    context )  ;   }  
public static int   (  )  {  return sender threads ;   }  
@ override public  data structure   (  )  {  return new  date and flags (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   subscriber wrapper <  integer >  wrapper = new  subscriber wrapper <  integer >  ( ts )  ;   flowable . range ( 1 5 )  . subscribe ( wrapper )  
@ override public  set <  string >    (  properties options )  {   string file = null ;  if  ( options  !  =  null )  file = options . get property ( "file" )  ;  if  ( file  =  =  null )  return super . get names ( options )  ;  for  (   naming service n
@ override public void   (  throwable e )  {  error count +  +  ;  error = e ;  completed . count down (  )  ;   }  
@ test public void   (  )  throws  exception  {  assert equals ( 0  observable internal helper .  map to int . instance . apply ( null )  )  ;   }  
public boolean   (  )  {  return m ;   }  
public  meta info   (  )  {  if  (  ! complete )  throw new  illegal argument exception ( "not complete" )  ;  return metainfo ;   }  
void   (  output stream os )  {     os = os ;   }  
public  string   (  )  {  return  jive globals . get property ( registraion   group )  ;   }  
@ override public void   (  )  {  executor . submit ( task )  ;   }  
public  string   (  )  {   calendar cal = get calendar (  )  ;  return to date string ( cal . get (  calendar . hour   of   day )  )   +   (  (  ( cal . get (  calendar . second )  % 2 )   =  =  0 )   ?  ":" : " " )   +  to date string ( cal . get (  calendar . minute )  )  ;   }  
@ override public final void   (  )  {  index = array . length ;   }  
private int   (  uri uri  content values ui values )  {  int result = 0 ;   integer state value = ui values . get as integer ( ui provider .  attachment columns . state )  ;  if  ( state value  !  =  null )   {  long attachment id =  long . parse long ( uri . get last path segment (  )  )  ;   context context = get context (  )  ;   attachment attachment =  attachment . restore attachment with id ( context attachment id )  ;  if  ( attachment  =  =  null )   {  return result ;   }  int state = state value ;   content values values = new  content values (  )  ;  if  ( state  =  =  ui provider .  attachment state . not   saved || state  =  =  ui provider .  attachment state . redownloading )   {  values . put (  attachment columns . ui   state ui provider .  attachment state . not   saved )  ;  values . put (  attachment columns . flags attachment . m flags& = ~ attachment . flag   download   user   request )  ;  attachment . update ( context values )  ;  result = 1 ;   }  if  ( state  =  =  ui provider .  attachment state . downloading || state  =  =  ui provider .  attachment state . redownloading )   {  values . put (  attachment columns . ui   state ui provider .  attachment state . downloading )  ;   integer destination value = ui values . get as integer ( ui provider .  attachment columns . destination )  ;  values . put (  attachment columns . ui   destination destination value  =  =  null  ?  0 : destination value )  ;  values . put (  attachment columns . flags attachment . m flags |  attachment . flag   download   user   request )  ;  if  ( values . contains key (  attachment columns . location )  &&  text utils . is empty ( values . get as string (  attachment columns . location )  )  )   {   log utils . w ( tag new  throwable (  )  "attachment with blank location" )  ;   }  attachment . update ( context values )  ;  result = 1 ;   }  if  ( state  =  =  ui provider .  attachment state . saved )   {  if  (  !  text utils . is empty ( attachment . m content id )  )   {  notifyui ( uiprovider   message   notifier attachment . m message key )  ;   }  result = 1 ;   }   }  return result ;   }  
@ override public void   (  session data session data  element command )  {   element note = command . add element ( "note" )  ;   map <  string  list <  string >  >  data = session data . get data (  )  ;   string groupname ;  try  {  groupname = get ( d
@ test public void   (  )  {  a <  string  integer >  a = new a <  string  integer >  (  )  {   }   ;   single . just ( a )  . compose (  transformer test .  <  string > test single transformer creator (  )  )  ;   }  
public  out net message   (  )  {  return    message ;   }  
public boolean   (  )  {  return deliver payloads ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c = normal . completable . do on complete ( new  action (  )  {  @ override public void run (  )  {  throw new  test exception (  )  ;   }   }   )  ;  c . bl
public static  workgroup   (  string workgroupjid )  {   workgroup workgroup = null ;  try  {  workgroup =  workgroup manager . get instance (  )  . get workgroup ( new jid ( workgroupjid )  )  ;   }  catch  (   user not found exception e )   {   log . error ( " error retrieving  workgroup" e )  ;   }  return workgroup ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . window ( null new  function <  object  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   object v )  {  return just1 ;   }   }   )
@ override public void   (  throwable e )  {  parent . inner error ( this e )  ;   }  
@ override public  string   (  )  {  return " subject  alternative  name  mapping" ;   }  
public  request queue   (  )  {  return queue ;   }  
@ override public  maybe <  boolean >    (  maybe <  object >  f )  throws  exception  {  return f . is empty (  )  . to maybe (  )  ;   }  
@ override public void   (  observer <  ?  super t >  s )  {   from array disposable < t >  d = new  from array disposable < t >  ( s array )  ;  s . on subscribe ( d )  ;  if  ( d . fusion mode )   {  return ;   }  d . run (  )  ;   }  
@ deprecated public void   ( boolean enabled )  {  enable (  connection type . connection   manager true enabled )  ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
@ test public void   (  )  {   subscriber <  integer >  observer =  test helper . mock subscriber (  )  ;   flowable . range ( 2 3 )  . subscribe ( observer )  ;  verify ( observer times ( 1 )  )  . on next ( 2 )  ;  verify ( observer times ( 1 )  )  . on
@ test public void   (  )  {   test subscriber <  notification <  integer >  >  ts = new  test subscriber <  notification <  integer >  >  ( 0l )  ;   flowable .  <  integer > empty (  )  . materialize (  )  . subscribe ( ts )  ;  ts . assert no values ( 
@ override public boolean   (  )  {  return false ;   }  
@ override public  transformer   (  )  {  try  {  return transformation templates . new transformer (  )  ;   }  catch  (   transformer configuration exception configuration exception )   {  throw new  xslt transformation exception ( " failed to generate 
@ override protected void   (  maybe observer <  ?  super t >  observer )  {   timeout main maybe observer < t u >  parent = new  timeout main maybe observer < t u >  ( observer fallback )  ;  observer . on subscribe ( parent )  ;  other . subscribe ( par
public  config registry   (  )  {  return config ;   }  
public final static  string   (  )  {  int addr cnt = getn host addresses (  )  ;  for  ( int n = 0 ;  n  <  addr cnt ;  n +  +  )   {   string addr = get host address ( n )  ;  if  ( isi pv6 address ( addr )   =  =  true )  return addr ;   }  return "" ;   }  
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 )  ;   single <  boolean >  observable = w . is empty (  )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  observable . subscribe (
private static void   (  string sam host int sam port  string con options )  {  test transient ( sam host sam port con options )  ;  test new dest ( sam host sam port con options )  ;  test old dest ( sam host sam port con options )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  child )  {   skip until main subscriber < t >  parent = new  skip until main subscriber < t >  ( child )  ;  child . on subscribe ( parent )  ;  other . subscribe ( parent . other )  ;  source . s
@ override public void   (  throwable e )  {  o . on error ( e )  ;   }  
private void   (  string response boolean notifications enabled )  throws  document exception  {  server update = null ;  sax reader xml reader = new sax reader (  )  ;  xml reader . set encoding ( "utf - 8" )  ;   element xml response = xml reader . read ( new  string reader ( response )  )  . get root element (  )  ;   element openfire = xml response . element ( "openfire" )  ;  if  ( openfire  !  =  null )   {   version latest version = new  version ( openfire . attribute value ( "latest" )  )  ;  if  ( latest version . is newer than ( xmpp server . get instance (  )  . get server info (  )  . get version (  )  )  )   {  url changelog = null ;  try  {  changelog = new url ( openfire . attribute value ( "changelog" )  )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to parse url from openfire changelog value ' {  } ' . " openfire . attribute value ( "changelog" )  e )  ;   }  url url = null ;  try  {  url = new url ( openfire . attribute value ( "url" )  )  ;   }  catch  (   malformedurl exception e )   {   log . warn ( " unable to parse url from openfire download url value ' {  } ' . " openfire . attribute value ( "url" )  e )  ;   }  server update = new  update ( " openfire" latest version . get version string (  )  changelog . to external form (  )  url . to external form (  )  )  ;   }   }  if  ( notifications enabled && is notification enabled (  )  && server update  !  =  null )   {   collection < jid >  admins = xmpp server . get instance (  )  . get admins (  )  ;   message notification = new  message (  )  ;  notification . set from ( server name )  ;  notification . set body ( get notification message (  )   +  " "  +  server update . get component name (  )  +  " " +  server update . get latest version (  )  )  ;  for  (  jid jid : admins )   {  notification . set to ( jid )  ;  router . route ( notification )  ;   }   }  save latest server info (  )  ;   }  
@ override protected void   ( final long new length )  throws io exception  {  m   write lock . lock (  )  ;  try  {  super . set length ( new length )  ;  m   ch = file . get channel (  )  ;  m   byte buffer =  byte buffer . allocate (  ( int ) new lengt
public   (  inet address ia int port )  throws  socket exception  {  int p = port ;  if  (  ( p & 1 )   !  =  0 )   {  p +  +  ;   logger . println ( " port number must be even  using "  +  p )  ;   }  while  ( true )   {  try  {  rtp datagram socket = new  datagram socket ( p ia )  ;  if  (  ( rtp datagram socket . get local port (  )  & 1 )   !  =  0 )   {  continue ;   }  try  {  rtcp datagram socket = new  datagram socket ( rtp datagram socket . get local port (  )   +  1 ia )  ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " rtp socket: listening for rtp data at local port "  +  rtp datagram socket . get local port (  )  )  ;   }  break ;   }  catch  (   socket exception e )   {  if  ( p  !  =  0 )   {  p +  = 2 ;   }   }  catch  (   exception e )   {  rtp datagram socket . close (  )  ;   logger . error ( " rtp socket:  unable to create control socket !  "  +  e . get message (  )  )  ;  throw e ;   }   }  catch  (   socket exception e )   {  if  ( p  !  =  0 )   {  p +  = 2 ;   }  continue ;   }  catch  (   exception e )   {   logger . error ( " rtp socket:  unable to create rtp / rtcp sockets !  "  +  e . get message (  )  )  ;  throw new  socket exception ( " rtp socket:  unable to create rtp / rtcp sockets ! " )  ;   }   }  if  ( p  !  =  port )   {   system . out . println ( " rtp socket:  desired port "  +  port  +  " is in use .   using " +  p +  " instead . " )  ;   }  try  {  rtp datagram socket . set receive buffer size ( max   receive   buffer )  ;   }  catch  (   socket exception e )   {   logger . error ( " rtp socket:  unable to set receive buffer size !  "  +  e . get message (  )  )  ;  throw e ;   }  try  {  rtp datagram socket . set send buffer size ( max   send   buffer )  ;   }  catch  (   socket exception e )   {   logger . error ( " rtp socket:  unable to set send buffer size !  "  +  e . get message (  )  )  ;  throw e ;   }  try  {  rtp datagram socket . set so timeout ( 0 )  ;   }  catch  (   socket exception e )   {   logger . error ( " rtp socket:  unable to set socket timeout !  "  +  e . get message (  )  )  ;  throw e ;   }   }  
public void   (  properties config  string prefix )  {   properties props = new  properties (  )  ;  for  (   map .  entry <  object  object >  e : config . entry set (  )  )   {   string key =  (  string ) e . get key (  )  ;  if  ( key . starts with ( prefix )  )   {  key = key . substring ( prefix . length (  )  )  ;   string val =  (  string ) e . get value (  )  ;  props . set property ( key val )  ;   }   }   properties old config =    config ;     config = props ;   string type = get type (  )  ;  if  ( type  !  =  null )   {  if  ( type . equals ( type   http   server )  )   {  if  (  !    config . contains key ( opt   limit   action )  )     config . set property ( opt   limit   action "http" )  ;   }  if  ( type . equals ( type   http   server )  || type . equals ( type   streamr   server )  )   {  if  (  !    config . contains key ( opt   bundle   reply )  )     config . set property ( opt   bundle   reply "false" )  ;   }  else if  (  ! is client ( type )  )   {     config . set property ( opt   bundle   reply "true" )  ;   }  if  ( type . contains ( "irc" )  || type . equals ( type   streamr   client )  )   {  if  (  !    config . contains key ( opt   tags   send )  )     config . set property ( opt   tags   send "20" )  ;  if  (  !    config . contains key ( opt   low   tags )  )     config . set property ( opt   low   tags "14" )  ;   }  if  (  ! is client ( type )  || type . equals ( type   irc   client )  || type . equals ( type   std   client ) || type . equals ( type   socks ) || type . equals ( type   socks   irc ) || type . equals ( type   streamr   client ) ||  ( type . equals ( type   http   client )  &&  boolean . value of ( get shared client (  )  )  )  )   {  if  (  !    config . contains key ( opt   sig   type )  )     config . set property ( opt   sig   type preferred   sigtype . name (  )  )  ;   }  if  (  ! is client ( type )  )   {   string p1 =    config . get property ( opt   max   conns   min "0" )  ;   string p2 =    config . get property ( opt   max   conns   hour "0" )  ;   string p3 =    config . get property ( opt   max   conns   day "0" )  ;   string p4 =    config . get property ( opt   max   total   conns   min "0" )  ;   string p5 =    config . get property ( opt   max   total   conns   hour "0" )  ;   string p6 =    config . get property ( opt   max   total   conns   day "0" )  ;   string p7 =    config . get property ( opt   max   streams "0" )  ;   string p8 =    config . get property ( opt   limits   set "false" )  ;  if  ( p1 . equals ( "0" )  && p2 . equals ( "0" )  && p3 . equals ( "0" ) && p4 . equals ( "0" ) && p5 . equals ( "0" ) && p6 . equals ( "0" ) && p7 . equals ( "0" ) &&  ! p8 . equals ( "true" )  )   {     config . set property ( opt   max   conns   min  integer . to string ( default   max   conns   min )  )  ;     config . set property ( opt   max   conns   hour  integer . to string ( default   max   conns   hour )  )  ;     config . set property ( opt   max   conns   day  integer . to string ( default   max   conns   day )  )  ;     config . set property ( opt   max   total   conns   min  integer . to string ( default   max   total   conns   min )  )  ;     config . set property ( opt   max   streams  integer . to string ( default   max   streams )  )  ;   }  if  ( type . equals ( type   http   server )  &&  ! p8 . equals ( "true" )  )   {   string p9 =    config . get property ( opt   post   max "0" )  ;   string p10 =    config . get property ( opt   post   total   max "0" )  ;  if  ( p9 . equals ( "0" )  && p10 . equals ( "0" )  )   {     config . set property ( opt   post   max  integer . to string ( i2p tunnelhttp server . default   post   max )  )  ;     config . set property ( opt   post   total   max  integer . to string ( i2p tunnelhttp server . default   post   total   max )  )  ;   }   }   }   }  set session options (  )  ;  synchronized  ( this )   {  if  (    state  !  =   tunnel state . running )   {  if  (    log . should log (  log . debug )  )   {     log . debug ( " not running  not updating sessions" )  ;   }  return ;   }   }  if  ( old config  !  =  null )   {  if  ( config changed (    config old config prop   file )  || config changed (    config old config opt   alt   pkf )  || config changed (    config old config opt   sig   type )  )   {  log ( " tunnel must be stopped and restarted for private key file changes to take effect" )  ;   }   }   collection < i2p session >  sessions = get all sessions (  )  ;  if  ( sessions . is empty (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " running but no sessions to update" )  ;   }  for  (  i2p session s : sessions )   {  if  (  ! s . is closed (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " session is open  updating: "  +  s )  ;  s . update options (    tunnel . get client options (  )  )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " session is closed  not updating: "  +  s )  ;   }   }   }  
@ override public void   (  presence type presence type  string verbose status )  {  connection = new irc connection (  )  ;  auto responder = new  auto responder ( connection )  ;  auto register = new  auto register ( connection get registration (  )  . 
public  string   (  )  {  return admin secret ;   }  
private void   (  input stream dest key stream )  throws  data format exception  io exception  {     my destination . read bytes ( dest key stream )  ;     private key . read bytes ( dest key stream )  ;     signing private key = new  signing private key (    my destination . get signing public key (  )  . get type (  )  )  ;     signing private key . read bytes ( dest key stream )  ;   }  
private void   ( boolean blocking rebuild )  {   router info ri ;  if  (    router info  !  =  null )  ri = new  router info (    router info )  ;  else ri = new  router info (  )  ;  try  {  ri . set published (    context . clock (  )  . now (  )  )  ;   properties stats =    context . stat publisher (  )  . publish statistics (  )  ;  ri . set options ( stats )  ;  ri . set addresses (    context . comm system (  )  . create addresses (  )  )  ;   signing private key key =    context . key manager (  )  . get signing private key (  )  ;  if  ( key  =  =  null )   {     log . log (  log . crit " internal error  -  signing private key not known ?   impossible ? " )  ;  return ;   }  ri . sign ( key )  ;  set router info ( ri )  ;  if  (  ! ri . is valid (  )  )  throw new  data format exception ( " our  router info has a bad signature" )  ;   republish r = new  republish (    context )  ;  if  ( blocking rebuild )  r . time reached (  )  ;  else    context . simple timer2 (  )  . add event ( r 0 )  ;   }  catch  (   data format exception dfe )   {     log . log (  log . crit " internal error  -  unable to sign our own address ?  ! " dfe )  ;   }   }  
public   (  )  {  analyzer = new  standard analyzer (  )  ;   }  
public static void   ( final  context context final  email content .  message local message final  array list <  part >  inline attachments )  throws  messaging exception  io exception  {  for  (  final  part inline part : inline attachments )   {  final  string disposition =  mime utility . get header parameter (  mime utility . unfold and decode ( inline part . get disposition (  )  )  null )  ;  if  (  !  text utils . is empty ( disposition )  )   {  add one attachment ( context local message inline part )  ;   }   }   }  
public void   ( byte data[] )  throws  data format exception  {  if  ( data  =  =  null )  throw new  data format exception ( " null data passed in" )  ;  try  {   byte array input stream bais = new  byte array input stream ( data )  ;  read bytes ( bais )  ;   }  catch  (  io exception ioe )   {  throw new  data format exception ( " error reading the byte array" ioe )  ;   }   }  
@ test public void   (  )  throws  interrupted exception  {  final  replay processor <  long >  replay =  replay processor . create unbounded (  )  ;   thread source = new  thread ( new  runnable (  )  {  @ override public void run (  )  {   flowable . un
public boolean   (  string key  string name )  {  if  (    log . should log (  log . debug )  )     log . debug ( " adding "  +  name  +  ": " +  key )  ;   signing public key signing public key = new  signing public key (  )  ;  try  {  signing public key . from base64 ( key )  ;   }  catch  (   data format exception dfe )   {     log . error ( " invalid signing key for "  +  name  +  " : " +  key dfe )  ;  return false ;   }   string old name =    trusted keys . get ( signing public key )  ;  if  ( name . equals ( old name )  )  return true ;  if  ( old name  !  =  null &&  ! old name . equals ( "" )  )   {     log . error ( " key for "  +  name  +  " already stored for different name " +  old name +  " : " +  key )  ;  return false ;   }  if  (  (  ! name . equals ( "" )  )  &&    trusted keys . contains value ( name )  )   {     log . error ( " key mismatch for "  +  name  +  "  spoof attempt ?  : " +  key )  ;  return false ;   }     trusted keys . put ( signing public key name )  ;  return true ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public static  < t > t   (  class < t >  clazz  object .  .  .  parameters )  {  try  {  return get constructor ( clazz to class array ( parameters )  )  . new instance ( parameters )  ;   }  catch  (   exception instanciation exception )   {  throw new  reflection exception ( " failed to create new instance of class: "  +  clazz . get canonical name (  )   +  " .   pump cause for more details . " instanciation exception )  ;   }   }  
public boolean   (  )  {  return  ( tls engine . is outbound done (  )  && tls engine . is inbound done (  )  )  ;   }  
public static boolean   (  )  {  return    one dot ten ;   }  
public final static void   ( int time )  {  int wait time =  ( int )  (  math . random (  )  *  ( double ) time )  ;  try  {   thread . sleep ( wait time )  ;   }  catch  (   exception e )   {   }   }  
public void   ( final  read ends for mate cigar end )  {  final  physical location for mate cigar location = new  physical location for mate cigar ( end )  ;  if  (  ! physical locations . contains ( location )  )   {  read ends . add ( end )  ;  physical locations . add ( new  physical location for mate cigar ( location )  )  ;   }   }  
public void   ( int num bytes )  {  set flag ( flag   max   packet   size   included num bytes  >  0 )  ;     option max size = num bytes ;   }  
public udp packet   (  inet address toip int to port  session key to cipher key  session key tomac key long nonce  session key alice intro key )  {  udp packet packet = build packet header ( peer   test   flag   byte )  ;   datagram packet pkt = packet . get packet (  )  ;  byte data[] = pkt . get data (  )  ;  int off = header   size ;  if  (    log . should log (  log . debug )  )     log . debug ( " sending peer test "  +  nonce  +  " to  bob" )  ;   data helper . to long ( data off 4 nonce )  ;  off +  = 4 ;   data helper . to long ( data off 1 0 )  ;  off +  +  ;   data helper . to long ( data off 2 0 )  ;  off +  = 2 ;   system . arraycopy ( alice intro key . get data (  )  0 data off  session key . keysize   bytes )  ;  off +  =  session key . keysize   bytes ;  off = pad1 ( data off )  ;  off = pad2 ( data off )  ;  pkt . set length ( off )  ;  authenticate ( packet to cipher key tomac key )  ;  set to ( packet toip to port )  ;  packet . set message type ( type   tfa )  ;  return packet ;   }  
public   (  routing table routing table )  {  this . routing table = routing table ;  this . server = xmpp server . get instance (  )  ;   }  
@ test @ ignore ( " observers can't throw" )  public void   (  )  {   subscriber <  string >  o = observer   onerror   fail (  )  ;  try  {  o . on subscribe ( throwing   disposable )  ;  new  safe subscriber <  string >  ( o )  . on error ( new  safe sub
@ override public  string   (  )  {  return    name ;   }  
protected void   (  )  {  request (  long . max   value )  ;   }  
@ benchmark public  object   (  blackhole bh )  {  return flowable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public int   (  )  {  return q . hash code (  )  ;   }  
public int   (  )  {  if  (    complete size  <  0 )   {  if  (    last fragment  <  0 )  throw new  illegal state exception ( "last fragment not set" )  ;  if  (    released )  throw new  illegal state exception ( "ssu ims 2  use after free" )  ;  int size = 0 ;  for  ( int i = 0 ;  i  <  =     last fragment ;  i +  +  )   {   byte array frag =    fragments[i] ;  if  ( frag  =  =  null )  throw new  illegal state exception ( "null fragment "  +  i  +  ' / ' +     last fragment )  ;  size +  = frag . get valid (  )  ;   }     complete size = size ;   }  return    complete size ;   }  
  (  string name  plottable plottable )  {  super ( name )  ;  this . plottable = plottable ;   }  
private static void   (  print writer out  folder <  string >  folder )  {  int sz ;  if  ( folder  !  =  null )  sz = folder . get page size (  )  ;  else sz =  config . get property (  folder . pagesize  folder . default   pagesize )  ;  out . println ( " < div class = \"topbuttons\" >  < b > " )  ;  out . println (    t ( " folder  page  size" )   +  ": <  / b > &nbsp ;  < input type = \"text\" style = \"text - align: right ; \" name = \""  +  pagesize +  "\" size = \"4\" value = \"" +  sz +  "\" > " +  "&nbsp ; " +  button ( setpagesize    t ( " set" )  )  )  ;  out . println ( " <  / div > " )  ;  out . println ( " < h3 id = \"config\" > " )  ;  out . print (    t ( " advanced  configuration" )  )  ;   properties config =  config . get properties (  )  ;  out . print ( " <  / h3 >  < textarea cols = \"80\" rows = \""  +   math . max ( 8 config . size (  )   +  2 )   +  "\" spellcheck = \"false\" name = \"" +  config   text +  "\" > " )  ;  for  (   map .  entry <  object  object >  e : config . entry set (  )  )   {  out . print ( quotehtml ( e . get key (  )  . to string (  )  )  )  ;  out . print ( ' = ' )  ;  out . println ( quotehtml ( e . get value (  )  . to string (  )  )  )  ;   }  out . println ( " <  / textarea > " )  ;  out . println ( " < div id = \"prefsave\" > " )  ;  out . println ( button ( save    t ( " save  configuration" )  )  )  ;  out . println ( button ( cancel    t ( " cancel" )  )  )  ;  if  ( folder  !  =  null )  out . println ( spacer  +  button ( logout    t ( " logout" )  )  )  ;  out . println ( " <  / div > " )  ;   }  
@ override public  publisher <  object >    (  flowable <  object >  f )  throws  exception  {  return f . do finally (  flowable do finally test . this )  . filter (  functions . always true (  )  )  ;   }  
@ test public void   (  )  {   list <  string >  values =  collection util . make list ( "foo" "bar" "abc123" " - foo" "f00" " - f00" )  ;  for  (   string s : values )   {  try  {   read name parser . rapid parse int ( s )  ;   assert . fail ( " should h
@ override public void   (  string property  map <  string  object >  params )  {  if  ( property . equals ( "xmpp . pubsub . enabled" )  )   {  enable service ( true )  ;   }   }  
@ override public boolean   (  )  {  return false ;   }  
@ test public void   (  )  throws  exception  {  final  constructor properties bean cpi = db rule . get shared handle (  )  . create query ( "select * from bean" )  . map to (  constructor properties bean . class )  . find only (  )  ;  assert that ( cpi 
public static  set <  string >    ( int num of mappings )  {   map <  string  service version mapping >  mappings = create configured mappings ( num of mappings )  ;  return mappings . key set (  )  ;   }  
public  query parameters   (  )  {  if  ( query parameters  =  =  null )   {  query parameters = object   factory . create query parameters (  )  ;  if  ( request  !  =  null )   {   list <  name value pair >  parameters = query parameters . get parameter (  )  ;   set <  entry <  string  string[] >  >  params = request . get parameter map (  )  . entry set (  )  ;  for  (   entry <  string  string[] >  entry : params )   {  for  (   string value : entry . get value (  )  )   {   name value pair param = new  name value pair (  )  ;  param . set name ( entry . get key (  )  )  ;  param . set value ( value )  ;  parameters . add ( param )  ;   }   }   }   }  return query parameters ;   }  
@ test public void   (  )  {   observable . interval range ( 1 5 1 1  time unit . milliseconds  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1l 2l 3l 4l 5l )  ;   }  
public void   (  string domain )  {  validated domains . remove ( domain )  ;   session manager . get instance (  )  . unregister incoming server session ( domain this )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  normal . completable . subscribe (  (  completable observer ) null )  ;   }  
public void   (  string format )  {     log date format = format ;   }  
protected   (  string path )  {  super ( path )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 2 )  . flat map iterable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer t )  throws  exception  {  return  arrays . as list ( t 
@ test public void   (  )  {  final  group element base point = ed25519 . getb (  )  ;  final  group element g = base point . scalar multiply ( curve . get field (  )  . zero . to byte array (  )  )  ;   assert . assert that ( curve . get zero (  group el
public void   ( final  simple timer .  timed event event final long delay final long timeout ms )  {  new  periodic timed event ( this delay timeout ms )  {  @ override public void time reached (  )  {  event . time reached (  )  ;   }  @ override public  string to string (  )  {  return event . to string (  )  ;   }   }   ;   }  
public void   (  )  {   log . debug ( " gadu gadu:  contact list exported" )  ;   }  
public void   (  )  {  if  (    tunnel status . equals (    x ( " rejecting tunnels:  starting up" )  )  )  cancel shutdown status (  )  ;   }  
private static  string   (  collection <  string >  strings )  {   string builder sb = new  string builder ( 90 )  ;  for  (   string group : strings )   {  sb . append ( group )  . append ( ' ' )  ;   }  if  (  ! strings . is empty (  )  )   {  sb . set length ( sb . length (  )   -  1 )  ;   }  else  {  sb . append ( ' ' )  ;   }  return sb . to string (  )  ;   }  
@ override public  string   (  )  {  return "http: /  / jabber . org / protocol / admin#add - group" ;   }  
@ check return value @ scheduler support (  scheduler support . custom )  public final  completable   ( final  scheduler scheduler )  {   object helper . require non null ( scheduler "scheduler is null" )  ;  return  rx java plugins . on assembly ( new  c
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  o 
private void   ( jid jid  element storage element )  {  final  collection <  bookmark >  bookmarks =  bookmark manager . get bookmarks (  )  ;  for  (   bookmark bookmark : bookmarks )   {  boolean add bookmark for user = bookmark . is global bookmark (  )  || is bookmark forjid ( jid bookmark )  ;  if  ( add bookmark for user )   {  add bookmark element ( jid bookmark storage element )  ;   }   }   }  
@ test public void   (  )  {   flowable . range ( 1 100 )  . concat map eager ( to range )  . subscribe ( ts )  ;  ts . assert no errors (  )  ;  ts . assert value count ( 200 )  ;  ts . assert complete (  )  ;   }  
public boolean   (  subscriber sub  string var name  string value )  {   string callback = sub . get deliveryurl (  )  ;   string sid = sub . getsid (  )  ;  long notify cnt = sub . get notify count (  )  ;   string host = sub . get delivery host (  )  ;   string path = sub . get delivery path (  )  ;  int port = sub . get delivery port (  )  ;  set method ( http . notify )  ;  seturi ( path )  ;  set host ( host port )  ;  setnt ( nt . event )  ;  setnts ( nts . propchange )  ;  setsid ( sid )  ;  setseq ( notify cnt )  ;  set content type ( xml . default   content   type )  ;   node prop set node = create property set node ( var name value )  ;  set content ( prop set node )  ;  return true ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   flowable . range ( 1 5 )  . publish ( new  function <  flowable <  integer >   flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   flowable <  integer >  v )  throws  ex
@ override public void   (  )  {  s . dispose (  )  ;   }  
@ before public void   (  )  {  tenant id = "tenant id" ;  token = "token" ;  user id = "user id" ;  repose local cache mock = mock (  repose local cache . class )  ;  reset ( metrics service )  ;  reset ( metric registry )  ;  reset ( timer )  ;  reset (
  (  completable observer actual  action on finally )  {  this . actual = actual ;  this . on finally = on finally ;   }  
public  string   (  )  {  return token ;   }  
@ override default void   (  consumer <  ?  super t >  action )  {  try  (  result iterator < t >  iterator = iterator (  )  )  {  iterator . for each remaining ( action )  ;   }   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  setup open folder ( mock )  ;  m folder . open (  open mode . read   write )  ;   imap message message = prepare for append test ( mock "no  no space left on the server . " )  ;  assert equals ( "initial uid" message . get uid (  )  )  ;  mock . expect literally ( get next tag ( false )   +  " uid search header message - id  < message . id@test . com > " new  string[] { "* search" get next tag ( true )   +  " ok  search completed . " }  )  ;  mock . expect literally ( get next tag ( false )   +  " uid search  ( header message - id  < message . id@test . com >  ) " new  string[] { "* search" get next tag ( true )   +  " ok  search completed . " }  )  ;  m folder . append message ( get instrumentation (  )  . get target context (  )  message false )  ;  assert equals ( "initial uid" message . get uid (  )  )  ;   }  
@ override public int   (  )  {  return  data helper . hash code (    encrypted data  !  =  null  ?     encrypted data :    unencrypted data )  ;   }  
@ override public void   (  string property  map params )  {  if  ( "ldap . override . avatar" . equals ( property )  )   {  db storage enabled =  boolean . parse boolean (  (  string ) params . get ( "value" )  )  ;   }  else if  ( "ldap . vcard - mappin
@ test public void   (  )  {   maybe . concat (  flowable . just (  maybe . just ( 1 )  )  )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   comparator <  media >  sort function = new  comparator <  media >  (  )  {  @ override public int compare (   media t1   media t2 )  {  return 1 ;   }   }   ;   flowable <  media >  o =  flowable . just ( new  movie (  )  ne
@ override public void   (  integer t )  {  super . on next ( t )  ;  cancel (  )  ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  setup open folder ( mock transport new  string[] { "* id  ( \"name\" \" cyrus\" \"version\" \"1 . 5\""  +  " \"os\" \"sunos\" \"os - version\" \"5 . 5\""  +  " \"support - url\" \"mailto:cyrus - bugs + @andrew . cmu . edu\" ) " "ok" }  "read - write" )  ;  m folder . open (  open mode . read   write )  ;   }  
@ test public void   (  )  {  final  atomic boolean unsub = new  atomic boolean (  )  ;   observable . range ( 1 10 )  . concat with (  observable .  <  integer > never (  )  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  {  un
@ override public  iterator <  string >    (  )  {  return  collections . singleton ( "jabber:iq:register" )  . iterator (  )  ;   }  
public static int   ( int flags )  {  int exp =  ( flags & tags   send   mask )  ;  return code to val ( exp tags   send )  ;   }  
public  string   (  )  {  return this . name ;   }  
@ override public void   (  subscriber <  ?  super t > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )   subscriber <  ?  super t > [] parents = new  subscrib
protected static void   (  string authentication realm )  {  sip config . authentication realm = authentication realm ;   }  
private boolean   (  string addr )  {  if  ( addr  =  =  null || addr . length (  )   <  =  0 )  return false ;  byte[] iab =  addresses . getip ( addr )  ;  if  ( iab  =  =  null )   {  add form error (    t ( " invalid address" )   +  ": "  +  addr )  ;  return false ;   }  boolean rv =  transport util . is publicly routable ( iab true )  ;  if  (  ! rv )  add form error (    t ( " the hostname or ip  { 0 }  is not publicly routable" addr )  )  ;  return rv ;   }  
public void   ( boolean processed )  {  this . processed = processed ;   }  
public synchronized void   (  )  {  synchronized  (    state lock )   {  if  ( graceful shutdown in progress (  )  ||  ! is alive (  )  )  return ;  change state (  state . restarting )  ;   }   (  (  router clock )    context . clock (  )  )  . remove shift listener ( this )  ;   thread t = new i2p thread ( new  restarter (    context )  " router  restart" )  ;  t . set priority (  thread . norm   priority  +  1 )  ;  t . start (  )  ;   }  
public static boolean   (  )  {  return  jive globals . get boolean property (  connection settings .  server . tls   accept   selfsigned   certs false )  ;   }  
public  string   (  )  {  return get state variable node (  )  . get node value ( default   value )  ;   }  
@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple5 <  ?   ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 5 )  )  ;   }  
static void   (  scheduler scheduler )  throws  interrupted exception  {   thread .  uncaught exception handler original handler =  thread . get default uncaught exception handler (  )  ;  try  {   capturing uncaught exception handler handler = new  capturing uncaught exception handler (  )  ;   thread . set default uncaught exception handler ( handler )  ;   illegal state exception error = new  illegal state exception ( " should be delivered to handler" )  ;   flowable . error ( error )  . subscribe on ( scheduler )  . subscribe (  )  ;  if  (  ! handler . completed . await ( 3  time unit . seconds )  )   {  fail ( "timed out" )  ;   }  assert equals ( " should have received exactly 1 exception" 1 handler . count )  ;   throwable cause = handler . caught ;  while  ( cause  !  =  null )   {  if  ( error . equals ( cause )  )   {  break ;   }  if  ( cause  =  =  cause . get cause (  )  )   {  break ;   }  cause = cause . get cause (  )  ;   }  assert equals ( " our error should have been delivered to the handler" error cause )  ;   }  finally  {   thread . set default uncaught exception handler ( original handler )  ;   }   }  
public   ( int required validation passes  inet socket address member address int dropped member rest time )  {  this . member address = member address ;  this . dropped member rest time = dropped member rest time ;  this . required validation passes = required validation passes ;  online = true ;  validation pass = 0 ;   }  
public int   (  )  {  return  ( consol fun . hash code (  )   +  steps )  * 53 ;   }  
public   (  )  {   log . info ( " created  gojara admin processor" )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
void   (  inner subscriber < t u >  inner  throwable t )  {  if  ( errs . add throwable ( t )  )   {  inner . done = true ;  if  (  ! delay errors )   {  upstream . cancel (  )  ;  for  (   inner subscriber <  ?   ?  >  a : subscribers . get and set ( cancelled )  )   {  a . dispose (  )  ;   }   }  drain (  )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   }  
public long   (  )  {  long range[] = get content range (  )  ;  return range[0] ;   }  
public void   (  string domains )  {  domain ban map = get map ( domains )  ;   }  
@ test public void   (  )  {   flowable <  integer >  ids =  flowable . just ( 1 2 )  ;   flowable <  string >  m = ids . flat map ( new  function <  integer  flowable <  string >  >  (  )  {  @ override public  flowable <  string >  apply (   integer id 
public   (  router context context  string stat group )  {     context = context ;     log = context . log manager (  )  . get log ( db history . class )  ;     stat group = stat group ;  create rates ( stat group )  ;   }  
@ override public void   (  )  {  if  ( this . d  =  =   disposable helper . disposed )   {  return ;   }  try  {  parent . on complete call . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  on error inner ( ex )  ;
public float   (  )  {  int h = get height (  )  ;  int ph = get physical height dpi (  )  ;  if  ( h  >  0 && ph  >  0 )   {  return  (  ( float ) h )   /   (  ( float ) ph )  ;   }  else  {  return  - 1 . 0f ;   }   }  
private   (  class <  ?  >  type  integer sql type )  {  this . type = type ;  this . sql type = sql type ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  parent . inner error ( t )  ;   }  
public void   ( final int num clusters in tile )  {  reader . record limit = num clusters in tile ;  reader . num records read = 0 ;   }  
public final void   (  disposable resource )  {   object helper . require non null ( resource "resource is null" )  ;  resources . add ( resource )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  future subscriber <  integer >  fo = new  future subscriber <  integer >  (  )  ;  if  ( i % 3  =  =  0 )   {  fo . on subscribe ( new  
@ test public void   (  )  throws  interrupted exception  {   flowable <  string >  os = async   observable   of   infinite   integers ( new  count down latch ( 1 )  )  . on backpressure buffer (  )  . zip with ( async   observable   of   infinite   integ
@ test public void   (  )  throws  interrupted exception  {  try  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   scheduler pool factory . shutdown (  )  ;   runnable r1 = new  runnable (  )  {  @ override public void
sam bridge   (  )  {  return bridge ;   }  
@ override public void   (  throwable t )  {  boolean b ;  try  {  b = predicate . test (  +  + retries t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  actual . on error ( new  composite exception ( t e )  )  ;  return ;  
@ override public  string   (  )  {  return " long value { "  +  "value = "  +  value  +  ' } ' ;   }  
private void   (  uri uri  content provider operation op )  {   string sequence string = uri . get query parameter ( ui provider . sequence   query   parameter )  ;  if  ( sequence string  !  =  null )   {  int sequence =  integer . parse int ( sequence string )  ;  if  ( sequence  >  m last sequence )   {  m last sequence ops . clear (  )  ;  m last sequence = sequence ;   }  m last sequence ops . add ( op )  ;   }   }  
public static  set <  string >    (  )  {  return allowed anonymi ps ;   }  
@ test public void   (  )  {   multicast processor <  integer >  mp = new  multicast processor <  integer >  ( 128 true )  ;   multicast subscription <  integer >  ms1 = new  multicast subscription <  integer >  ( null mp )  ;  assert true ( mp . add ( ms
@ override protected void   (  )  {  super . succeed (  )  ;  if  (    facade . is verify in progress (    state . get target (  )  )  )   {  if  (    log . should log (  log . info )  )     log . info ( " skipping verify  one already in progress for: "  
public boolean   (  )  {  return this . non duplicate read ends set . is empty (  )  ;   }  
boolean   (  maybe disposable < t >  inner )  {  for  (  ;   ;   )   {   maybe disposable < t > [] a = observers . get (  )  ;  if  ( a  =  =  terminated )   {  return false ;   }  int n = a . length ;  @ suppress warnings ( "unchecked" )   maybe disposable < t > [] b = new  maybe disposable[n  +  1] ;   system . arraycopy ( a 0 b 0 n )  ;  b[n] = inner ;  if  ( observers . compare and set ( a b )  )   {  return true ;   }   }   }  
@ override protected  per unit metric collector <  rrbs metrics  comparable <  ?  >  sam record and reference >    ( final  string sample final  string library final  string read group )  {  return new  per unit rrbs metrics collector ( sample library rea
public boolean   (  )  {  return is bobcat compatible ;   }  
@ override public boolean   (  object obj )  {  if  ( this  =  =  obj )   {  return true ;   }  if  (  !  ( obj instanceof  pair )  )   {  return false ;   }   pair key =  (  pair ) obj ;  return  ( m obj1  =  =  null  ?  key . m obj1  =  =  null : m obj1
public static void   (  string cache name long lifetime )  {  cache name = cache name . replace all ( " " "" )  ;  if  (  !  long . to string ( lifetime )  . equals (  jive globals . get property ( "cache . "  +  cache name  +  " . max lifetime" )  )  )   {   jive globals . set property (  ( "cache . "  +  cache name  +  " . max lifetime" )   long . to string ( lifetime )  )  ;   }   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . on error complete (  )  . test (  )  . assert result (  )  ;   }  
public void   (  plugin manager manager  file plugin directory )  {  component manager =  component manager factory . get component manager (  )  ;   jingle nodes component component = new  jingle nodes component ( this )  ;  try  {  component manager . add component ( service name component )  ;   }  catch  (   component exception e )   {   log . error ( " could not load "  +  component . get name (  )  )  ;   }  setup (  )  ;   }  
@ deprecated @ override public  inet address   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ test ( expected =  malformed header value exception . class )  public void   (  )  {  final  map <  string  string >  parameters = new  hash map <  >  (  )  ;  parameters . put ( "q" "nan" )  ;  final  header value impl header value = new  header value 
@ before public void   (  )  throws  exception  {  baos = new  byte array output stream (  )  ;  callback = new  mock stats callback (  )  ;  stats out = new  stats output stream ( baos callback )  ;   }  
protected static void   (  string public address )  {  sip config . public address = public address ;   }  
@ test public void   (  )  {  try  (  handle handle = jdbi . open (  )  )  {  handle . execute ( "insert into contacts  ( id  name )  values  (  ?    ?  ) " 3 " chuck" )  ;   }   }  
public  handle   (  )  {  return handle ;   }  
@ data provider public  iterator <  object[] >    (  )  {  return  stream . of (  transition . values (  )  )  . map ( t  -  >  new  object[] { t }  )  . iterator (  )  ;   }  
@ override public  string   (  )  {  return " loginicq flap cmd: "  +  "version = "  +  version  +  "  cookie = " +  cookie +  "  uin = '" +  uin +  "'" +  "  version = '" +  version +  "'" +  "  locale = " +  locale ;   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . on exception resume next (  maybe . just ( 1 )  )  . test (  )  . assert result ( 1 )  ;   }  
public   (  packet local packet long delay )  {  super (    timer )  ;     packet = packet ;     next send = delay  +     context . clock (  )  . now (  )  ;  packet . set resend packet event (  resend packet event . this )  ;  schedule ( delay )  ;   }  
@ override public void   ( t t )  {  long now = scheduler . now ( unit )  ;  queue . offer ( now t )  ;  drain (  )  ;   }  
public void   ( int priority )  {  this . priority = priority ;   }  
public   (  calendar gc1  calendar gc2 )  throws  rrd exception  {  this (  util . get timestamp ( gc1 )  gc2  !  =  null  ?   util . get timestamp ( gc2 )  : 0 )  ;   }  
public void   (  string s )  throws io exception  {  delegate . write bytes ( s )  ;   }  
public void   (  string home phone )  {  this . home phone = home phone ;   }  
@ override public void   (  gadu gadu buddy contact )  {   string gg contact = get transport (  )  . convertjid toid ( contact . getjid (  )  )  ;  if  ( pseudo roster . has item ( gg contact )  )   {   pseudo roster item roster item = pseudo roster . get
public void   (  string val )  {  if  ( val  !  =  null )   {  try  {     hash cash value =  integer . parse int ( val . trim (  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
private void   ( i2np message message body )  {  if  (    log . should log (  log . debug )  )     log . debug ( " shortcut dispatch tunnel gateway message "  +  message body )  ;     context . tunnel dispatcher (  )  . dispatch (  (  tunnel gateway message ) message body )  ;   }  
void   (  pooled tunnel creator config cfg )  {  synchronized  (    in progress )   {     in progress . remove ( cfg )  ;   }  cfg . set tunnel pool ( this )  ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   ( t value )  {  this . value = value ;  for  (   cache disposable < t >  inner : observers . get and set ( terminated )  )   {  if  (  ! inner . is disposed (  )  )   {  inner . actual . on suc
@ override public boolean   (  collection <  ?  >  coll )  {  throw new  unsupported operation exception (  )  ;   }  
@ override void   (  element revoke )  {  if  ( is anonymous user (  )  )   {   element element = revoke . add element ( "user" "http: /  / jivesoftware . com / protocol / workgroup" )  ;  element . add attribute ( "id" get userid (  )  )  ;   }   }  
@ override public boolean   (  )  {  return get (  )   =  =   subscription helper . cancelled ;   }  
public static  < t r > void   (  function <  flowable < t >   ?  extends  maybe source < r >  >  transform )  {   list <  throwable >  errors = track plugin errors (  )  ;  try  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   flowable < t >  source = new  flowable < t >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super t >  observer )  {  try  {   boolean subscription d1 = new  boolean subscription (  )  ;  observer . on subscribe ( d1 )  ;   boolean subscription d2 = new  boolean subscription (  )  ;  observer . on subscribe ( d2 )  ;  b[0] = d1 . is cancelled (  )  ;  b[1] = d2 . is cancelled (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }   }   ;   maybe source < r >  out = transform . apply ( source )  ;  out . subscribe (  no op consumer . instance )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " first cancelled ? " false b[0] )  ;  assert equals ( " second not cancelled ? " true b[1] )  ;  assert error ( errors 0  illegal state exception . class " subscription already set ! " )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  finally  {   rx java plugins . reset (  )  ;   }   }  
public void   ( int limit )  {  conflict limit = limit ;   jive globals . set property ( "xmpp . session . conflict - limit"  integer . to string ( conflict limit )  )  ;   }  
private void   (  )  {  boolean no java7 =  !  system version . is java7 (  )  ;  boolean no pack200 =  (  plugin starter . plugins enabled (    context )  ||  !  news helper . is update disabled (    context )  )  &&  !  file util . is pack200 supported (  )  ;  boolean openarm =  system version . isarm (  )  &&  system version . is openjdk (  )  ;  boolean is java10 =  system version . is java10 (  )  ;  if  ( no java7 || no pack200 || openarm|| is java10 )   {   string s = " java version: "  +   system . get property ( "java . version" )   +  " os: " +   system . get property ( "os . name" )  +  ' ' +   system . get property ( "os . arch" )  +  ' ' +   system . get property ( "os . version" )  ;  net . i2p . util .  log log =    context . log manager (  )  . get log (  router console runner . class )  ;  log . log always ( net . i2p . util .  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;  if  ( no java7 )   {  s = " java 7 is now required  please upgrade" ;  log . log always ( net . i2p . util .  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }  if  ( no pack200 )   {  s = " pack200 is required for plugins and automatic updates  please upgrade  java" ;  log . log always ( net . i2p . util .  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }  if  ( openarm )   {  s = " openjdk is not recommended for arm .   use  oracle  java 8" ;  log . log always ( net . i2p . util .  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }  if  ( is java10 )   {  s = " java 10 support is beta  and not recommended for general use" ;  log . log always ( net . i2p . util .  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }   }   }  
@ test public void   (  )  throws  exception  {  final  file metrics file =  file . create temp file ( "dual . " " . metrics" )  ;  metrics file . delete on exit (  )  ;  final  string[] args = new  string[] { "basecalls   dir = "  +  dual . get absolute 
 string   ( jid roomjid )  {  return roomjid . to string (  )  ;   }  
@ override public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public static  byte[]   (  double value )  {  byte bytes[] = new byte[8] ;   byte buffer . wrap ( bytes )  . put double ( value . double value (  )  )  ;  return bytes to array ( bytes )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   maybe subject <  integer >  ms =  maybe subject . create (  )  ;   test observer <  integer >  to = ps . concat map maybe delay error (  functions . just
@ before public void   (  )  {  instance = new  over limit exception ( message user date limit configured limit )  ;   }  
 sync manager   (  )  {  return s   sync manager ;   }  
public void   ( long fetch request resolution )  {  this . fetch request resolution = fetch request resolution ;   }  
  (  subscriber <  ?  super  long >  actual )  {  this . actual = actual ;   }  
public  long   (  )  {  return    synchronization source ;   }  
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public void   (  conversation listener listener )  {  conversation listeners . add ( listener )  ;   }  
private void   (  )  {     reorganize lock . write lock (  )  . unlock (  )  ;   }  
public long   (  )  {  return start time ;   }  
public   ( i2p app context ctx  string base name i2p session session )  {     context = ctx ;     session = session ;     log = ctx . log manager (  )  . get log ( krpc . class )  ;     tracker = new dht tracker ( ctx )  ;     sent queries = new  concurrent hash map <  msgid  reply waiter >  (  )  ;     outgoing tokens = new  concurrent hash map <  token  node info >  (  )  ;     incoming tokens = new  concurrent hash map < nid  token >  (  )  ;     blacklist = new  concurrent hash set < nid >  (  )  ;     q port =  tracker client . port  +  10  +  ctx . random (  )  . next int ( 65535  -  20  -   tracker client . port )  ;     r port =    q port  +  1 ;  if  ( secure   nid )   {     mynid =  node info . generatenid ( session . get my destination (  )  . calculate hash (  )     q port    context . random (  )  )  ;     myid =    mynid . get data (  )  ;   }  else  {     myid = new byte[nid . hash   length] ;  ctx . random (  )  . next bytes (    myid )  ;     mynid = new nid (    myid )  ;   }     my node info = new  node info (    mynid session . get my destination (  )     q port )  ;   file conf = new  file ( ctx . get config dir (  )  base name  +  " . config"  +   snark manager . config   dir   suffix )  ;     dht file = new  file ( conf "i2psnark"  +  dht   file   suffix )  ;  if  ( base name . equals ( "i2psnark" )  )   {     backup dht file = null ;   }  else  {   file bconf = new  file ( ctx . get config dir (  )  "i2psnark . config"  +   snark manager . config   dir   suffix )  ;     backup dht file = new  file ( bconf "i2psnark"  +  dht   file   suffix )  ;   }     known nodes = new dht nodes ( ctx    mynid )  ;  start (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . empty (  )  ;   observable <  list <  string >  >  buffered = source . buffer ( 3 3 )  ;  buffered . subscribe ( observer )  ;   mockito . verify ( observer  mockito . never (  
private void   (  data input stream in  data output stream out )  throws io exception  socks exception  {  int command = in . read byte (  )  & 0xff ;  switch  ( command )   {  case  command . connect: break ;  case  command . bind:    log . debug ( "bind command is not supported ! " )  ;  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;  throw new socks exception ( "bind command not supported" )  ;  default :    log . debug ( "unknown command in request  ( "  +   integer . to hex string ( command )   +  " ) " )  ;  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;  throw new socks exception ( " invalid command in request" )  ;   }  conn port = in . read unsigned short (  )  ;  if  ( conn port  =  =  0 )   {     log . debug ( "trying to connect to tcp port 0 ?   dropping ! " )  ;  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;  throw new socks exception ( " invalid port number in request" )  ;   }   string builder builder = new  string builder (  )  ;  boolean already warned = false ;  for  ( int i = 0 ;  i  <  4 ;   +  + i )   {  int octet = in . read byte (  )  & 0xff ;  builder . append (  integer . to string ( octet )  )  ;  if  ( i  !  =  3 )   {  builder . append ( " . " )  ;  if  ( octet  !  =  0 &&  ! already warned )   {     log . warn ( "ipv4 address type in request: "  +  conn host name  +  " .   is your client secure ? " )  ;  already warned = true ;   }   }   }  conn host name = builder . to string (  )  ;   string mapped domain name = get mapped domain name forip ( conn host name )  ;  if  ( mapped domain name  !  =  null )   {     log . debug ( "ipv4 address "  +  conn host name  +  " was mapped to domain name " +  mapped domain name )  ;  conn host name = mapped domain name ;   }  read string ( in )  ;  if  ( conn host name . starts with ( "0 . 0 . 0 . " )  &&  ! conn host name . equals ( "0 . 0 . 0 . 0" )  )  conn host name = read string ( in )  ;   }  
public void   (  )  {  add random ( 1000 )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp1 =  publish processor . create (  )  ;  final  publish processor <  integer >  pp2 =  publish process
@ override synchronized void   (  )  {  if  (    log . should log (  log . info )  )     log . info ( to string (  )   +  ":  startup (  )  called  was already alive ?  "  +     alive new  exception (  )  )  ;     alive = true ;  super . refresh lease set
@ override public byte[]   ( int capacity )  {  if  ( capacity  <  =  0 )   {  throw new  illegal argument exception ( " byte array capacity must be greater than zero  -  got "  +  capacity )  ;   }  return new byte[capacity] ;   }  
void   ( int init   bits  output stream outs )  throws io exception  {  int fcode ;  int i ;  int c ;  int ent ;  int disp ;  int hsize   reg ;  int hshift ;  g   init   bits = init   bits ;  clear   flg = false ;  n   bits = g   init   bits ;  maxcode = maxcode ( n   bits )  ;   clear code = 1  <  <   ( init   bits  -  1 )  ;  eof code =  clear code  +  1 ;  free   ent =  clear code  +  2 ;  char   init (  )  ;  ent = next pixel (  )  ;  hshift = 0 ;  for  ( fcode = hsize ;  fcode  <  65536 ;  fcode* = 2 )   {   +  + hshift ;   }  hshift = 8  -  hshift ;  hsize   reg = hsize ;  cl   hash ( hsize   reg )  ;  output (  clear code outs )  ;  outer   loop: while  (  ( c = next pixel (  )  )   !  =  eof )   {  fcode =  ( c  <  <  maxbits )   +  ent ;  i =  ( c  <  <  hshift )  ^ ent ;  if  ( htab[i]  =  =  fcode )   {  ent = codetab[i] ;  continue ;   }  else if  ( htab[i]  >  =  0 )   {  disp = hsize   reg  -  i ;  if  ( i  =  =  0 )   {  disp = 1 ;   }  do  {  if  (  ( i -  = disp )   <  0 )   {  i +  = hsize   reg ;   }  if  ( htab[i]  =  =  fcode )   {  ent = codetab[i] ;  continue outer   loop ;   }   }  while  ( htab[i]  >  =  0 )  ;   }  output ( ent outs )  ;  ent = c ;  if  ( free   ent  <  maxmaxcode )   {  codetab[i] = free   ent +  +  ;  htab[i] = fcode ;   }  else  {  cl   block ( outs )  ;   }   }  output ( ent outs )  ;  output ( eof code outs )  ;   }  
private static void   (  )  {   system . out . println ( " checking for  android  bit set bug" )  ;   bit set the bit set = new  bit set ( 864 )  ;  for  ( int exp = 0 ;  exp  <  864 ;  exp +  +  )   {  int act = the bit set . next clear bit ( 0 )  ;  if  ( exp  !  =  act )   {   system . err . println (  string . format ( " test failed for: exp = %d  act = %d" exp act )  )  ;   system . err . println ( " android  bit set bug detected  workaround implemented ! " )  ;  return ;   }  the bit set . set ( exp )  ;   }   system . err . println ( " android  bit set bug not detected  no workaround needed ! " )  ;   }  
public  hash   (  )  {  return    peer hash ;   }  
private void   (  msgid msgid  info hash ih byte[] tok boolean is seed )  throws  invalidb encoding exception  {   token token = new  token ( tok )  ;   node info n info =    outgoing tokens . get ( token )  ;  if  ( n info  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unknown token in announce   peer: "  +  token )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " rcvd announce from: "  +  n info  +  " for: " +  ih +  " seed ?  " +  is seed )  ;     tracker . announce ( ih n info . get hash (  )  is seed )  ;  send pong ( n info msgid )  ;   }  
public  job timing   (  )  {  return null ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . set once ( upstream d )  )   {  inner next (  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  )  {  d =  disposable helper . disposed ;  if  ( eager )   {   object resource = get and set ( this )  ;  if  ( resource  !  =  this )   {  try  {  disposer . accept (  ( d ) resource )  ;  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( upstream d )  )   {  upstream = d ;  downstream . on subscribe ( this )  ;  queue . offer ( next   window )  ;  drain (  )  ;   }   }  
public  string   (  )  {  return  collect multiple metrics . class . get simple name (  )  ;   }  
@ override public void   (  message payload message msg )  {   long mid =  long . value of ( msg . get message id (  )  )  ;     available messages . put ( mid msg )  ;  long id = msg . get message id (  )  ;  byte data[] = msg . get payload (  )  . get u
@ test public void   (  )  throws  exception  {  final  metrics file <  extract illumina barcodes .  barcode metric  integer >  metrics file = run it ( 1 "4m21t8b21t4m" )  ;   assert . assert equals ( metrics file . get metrics (  )  . get ( 0 )  . perfec
public void   (  properties options )  {     options = options ;   }  
@ override public  collection <  string >    (  )  {  return null ;   }  
public  properties   (  )  {  return    unknown options ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;   unicast processor <  integer >  up =  unicast processor . create (  )  ;  up . filter (  functions . always true (  )  )  . filt
private   (  config registry that )  {  that . cache . for each (  ( type config )   -  >   {   jdbi config <  ?  >  copy = config . create copy (  )  ;  copy . set registry (  config registry . this )  ;  cache . put ( type copy )  ;   }   )  ;   }  
@ override public void   (  consumer <  ?  super  disposable >  connection )  {  co . connect ( connection )  ;   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . on backpressure buffer (  )  ;   }  
@ override public  iterator < t >    (  )  {  return enumeration iterator ;   }  
private void   (  writer out  string builder buf  list <  router info >  ris  map <  hash  points >  points )  throws io exception  {  buf . append ( " < h3 id = \"same24\" class = \"sybils\" >  floodfills in the  same  / 24  ( 2 minimum )  <  / h3 > " )  ;   object counter <  integer >  oc = new  object counter <  integer >  (  )  ;  for  (   router info info : ris )   {  byte[] ip = getip ( info )  ;  if  ( ip  =  =  null )  continue ;   integer x =  integer . value of (  ( int )  data helper . from long ( ip 0 3 )  )  ;  oc . increment ( x )  ;   }   list <  integer >  foo = new  array list <  integer >  (  )  ;  for  (   integer ii : oc . objects (  )  )   {  int count = oc . count ( ii )  ;  if  ( count  >  =  2 )  foo . add ( ii )  ;   }   collections . sort ( foo new  foo comparator ( oc )  )  ;  boolean found = false ;  for  (   integer ii : foo )   {  int count = oc . count ( ii )  ;  int i = ii . int value (  )  ;  int i0 = i  >  >  16 ;  int i1 =  ( i  >  >  8 )  & 0xff ;  int i2 = i & 0xff ;   string sip = i0  +  " . "  +  i1 +  ' . ' +  i2 +  " . 0 / 24" ;  buf . append ( " < p class = \"sybil   info\" >  < b > " )  . append ( count )  . append ( " floodfills with ip  < a href = \" / netdb ? ip = " )  . append ( sip )  . append ( "&amp ; sybil\" > " )  . append ( sip )  . append ( " <  / a > : <  / b >  <  / p > " )  ;  for  (   router info info : ris )   {  byte[] ip = getip ( info )  ;  if  ( ip  =  =  null )  continue ;  if  (  ( ip[0] & 0xff )   !  =  i0 )  continue ;  if  (  ( ip[1] & 0xff )   !  =  i1 )  continue ;  if  (  ( ip[2] & 0xff )   !  =  i2 )  continue ;  found = true ;  render router info ( buf info null false false )  ;  double point = points24 *  ( count  -  1 )  ;  add points ( points info . get hash (  )  point " same  / 24 ip with "  +   ( count  -  1 )   +  " other" +   (  ( count  >  2 )   ?  "s" : "" )  )  ;   }   }  if  (  ! found )  buf . append ( " < p class = \"notfound\" >  none <  / p > " )  ;  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;  buf . set length ( 0 )  ;   }  
private void   (  buddy item buddy item )  {  if  (  ! highest buddy id per group . contains key ( buddy item . get group id (  )  )  )   {  highest buddy id per group . put ( buddy item . get group id (  )  0 )  ;   }  if  ( buddy item . get id (  )   >  highest buddy id per group . get ( buddy item . get group id (  )  )  )   {  highest buddy id per group . put ( buddy item . get group id (  )  buddy item . get id (  )  )  ;   }   }  
@ override public  collection < jid >    (  )  {  return  collections . unmodifiable list ( admins )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable
@ test public void   (  )  {   observable . just ( 1 )  . switch map single (  functions . just function (  single . error ( new  test exception (  )  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
private synchronized void   (  )  {  if  ( is done (  )  )   {  return ;   }  cluster member = false ;  senior cluster member = false ;   list <  nodeid >  nodei ds = new  array list <  >  ( node sessions . key set (  )  )  ;   cluster manager . fire left cluster (  )  ;  if  (  ! xmpp server . get instance (  )  . is shutting down (  )  )   {  for  (   nodeid key : nodei ds )   {  cleanup directed presences ( key )  ;  cleanup presences ( key )  ;   }  xmpp server . get instance (  )  . get presence update handler (  )  . removed expired presences (  )  ;   }  logger . info ( " left cluster as node: "  +  cluster . get local member (  )  . get uuid (  )  )  ;  done = true ;   }  
public void   (  )  {  try  {     fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . skip ( 1 null  schedulers . single (  )  )  ;   }  
public   (  iterator < k >  delegate )  {  this . delegate = delegate ;   }  
private static  collection <  illumina tile metrics >    ( final  iterator <  illumina tile metrics >  tile metrics iterator )  {  final  map <  tile metrics out reader .  illumina lane tile code  illumina tile metrics >  filtered tile metrics = new  hash map <  >  (  )  ;  for  (  final  illumina tile metrics illumina tile metrics : new  iterable adapter <  >  ( tile metrics iterator )  )   {  filtered tile metrics . put ( illumina tile metrics . get lane tile code (  )  illumina tile metrics )  ;   }  return filtered tile metrics . values (  )  ;   }  
public   (  )  {  super (  key manager . this .    context )  ;   }  
@ override public boolean   (  naming service ns boolean head )  {  if  ( head )     services . add ( 0 ns )  ;  else    services . add ( ns )  ;  return true ;   }  
public  translation result   ( final  input stream in final  output stream out final  list <  xslt parameter >  inputs )  {   translation result rtn = new  translation result ( false )  ;   xml filter chain pooled object ;  try  {  pooled object = object pool . borrow object (  )  ;  try  {  inputs . add all ( params )  ;   list <  xslt parameter <  ?  extends  output stream >  >  outputs = get output parameters (  )  ;  pooled object . execute chain ( in out inputs outputs )  ;  rtn = new  translation result ( true outputs )  ;   }  catch  (   xslt exception e )   {  object pool . invalidate object ( pooled object )  ;  pooled object = null ;  log . warn ( " error processing transforms" e . get message (  )  e )  ;   }  catch  (   exception e )   {  object pool . invalidate object ( pooled object )  ;  pooled object = null ;  log . error ( " failed to utilize the  xml filter chain .   reason:  {  } " e . get localized message (  )  )  ;  log . trace ( "" e )  ;   }  finally  {  if  ( pooled object  !  =  null )   {  object pool . return object ( pooled object )  ;   }   }   }  catch  (   exception e )   {  log . error ( " failed to obtain an  xml filter chain .   reason:  {  } " e . get localized message (  )  )  ;  log . trace ( "" e )  ;   }  return rtn ;   }  
public static void   (  type type  string sql long time )  {  if  ( sql  =  =  null || sql . equals ( "" )  )   {  return ;   }  sql = reformat query ( sql )  ;  sql = remove query values ( sql )  ;   profiled connection entry entry ;  switch  ( type )   {  case select: select count +  +  ;  total select time +  = time ;  entry = select queries . get ( sql )  ;  if  ( entry  =  =  null )   {  entry = new  profiled connection entry ( sql )  ;  select queries . put ( sql entry )  ;   }  break ;  case update: update count +  +  ;  total update time +  = time ;  entry = update queries . get ( sql )  ;  if  ( entry  =  =  null )   {  entry = new  profiled connection entry ( sql )  ;  update queries . put ( sql entry )  ;   }  break ;  case insert: insert count +  +  ;  total insert time +  = time ;  entry = insert queries . get ( sql )  ;  if  ( entry  =  =  null )   {  entry = new  profiled connection entry ( sql )  ;  insert queries . put ( sql entry )  ;   }  break ;  case delete: delete count +  +  ;  total delete time +  = time ;  entry = delete queries . get ( sql )  ;  if  ( entry  =  =  null )   {  entry = new  profiled connection entry ( sql )  ;  delete queries . put ( sql entry )  ;   }  break ;  default : throw new  illegal argument exception ( " invalid type" )  ;   }  entry . count +  +  ;  entry . total time +  = time ;   }  
@ test public void   (  )  {   future task <  object >  f = new  future task <  object >  (  functions . empty   runnable null )  ;  f . run (  )  ;   test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . from future ( f )
public int   (  )  {  return this . piece . get id (  )  ;   }  
public  string   (  )  {  return props . get property ( application   password )  ;   }  
public void   (  status code constraint status code constraint )  {  this . status code constraint = status code constraint ;   }  
@ test public void   (  )  {   observable . just ( 1 2 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )  . take last ( 1  time unit . minutes true )  . test (  )  . assert failure (  test exception . class 1 2 )  ;   }
public  string   (  )  {  return regex ;   }  
public boolean   (  )  {  return current cluster  <  num clusters ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  notification <  object >  >  >  (  )  {  @ override public  flowable <  notification <  object >  >  apply (   flowable <
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . reduce with ( null new  bi function <  object  integer  object >  (  )  {  @ override public  object apply (   object a   integer b )  {  return 1 ;   }   }   )  ;   }  
public  file   (  )  {  return    tmp dir ;   }  
public boolean   (  string id )  {  return conf extensions . contains key ( id )  ;   }  
@ after test private void   (  )  {  io util . delete directory tree ( root test dir )  ;   }  
public void   (  )  {  if  ( is enabled (  )  )   {  if  ( session . is detached (  )  )   {   log . debug ( " session is detached  won't request an ack . " )  ;  return ;   }   string ack =  string . format ( " < a xmlns = '%s' h = '%s'  /  > " namespace server processed stanzas . get (  )  & mask )  ;  session . deliver raw text ( ack )  ;   }   }  
@ test public void   (  )  throws  exception  {  when ( request . get input stream (  )  )  . then return ( new  servlet input stream wrapper ( new  byte array input stream ( new byte[] {  }  )  )  )  ;  uri uri = processor . get uri ( "http: /  / foo . c
public void   ( float k bps )  {     peak throughput[0] = k bps * 60 * 1024 ;   }  
@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
private static  map <  string  ?  extends  collection <  illumina tile metrics >  >    ( final  collection <  illumina tile metrics >  tile metrics )  {  return tile metrics . stream (  )  . collect (  collectors . grouping by (  tile metrics util::render metric location key )  )  ;   }  
public int   (  )  {  return bytes encoded ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . window (  (  callable <  publisher <  integer >  >  ) null )  ;   }  
@ test public void   (  )  {  final  atomic integer counter = new  atomic integer (  )  ;   composite disposable s = new  composite disposable (  )  ;  s . add (  disposables . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  cou
@ override public  string   (  )  {  return get class (  )  . get simple name (  )  ;   }  
private void   (  session key key )  throws  data format exception  io exception  {  int size =    leases . size (  )  ;  if  ( size  <  1 || size  >  max   leases  -  1 )  throw new  illegal argument exception ( " bad number of leases for encryption" )  ;  int datalen =  (  ( data   len * size  /  16 )   +  1 )  * 16 ;   byte array output stream baos = new  byte array output stream ( datalen )  ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {     leases . get ( i )  . get gateway (  )  . write bytes ( baos )  ;     leases . get ( i )  . get tunnel id (  )  . write bytes ( baos )  ;   }  int padlen = datalen  -   ( data   len * size )  ;  byte[] pad = new byte[padlen] ;   random source . get instance (  )  . next bytes ( pad )  ;  baos . write ( pad )  ;  byte[] iv = new byte[iv   len] ;   system . arraycopy (    destination . get public key (  )  . get data (  )  0 iv 0 iv   len )  ;  byte[] enc = new byte[data   len *  ( size  +  1 ) ] ;  i2p app context . get global context (  )  . aes (  )  . encrypt ( baos . to byte array (  )  0 enc 0 key iv datalen )  ;  padlen = enc . length  -  datalen ;   random source . get instance (  )  . next bytes ( enc datalen padlen )  ;   lease pad lease = new  lease (  )  ;  pad lease . set end date (    leases . get ( 0 )  . get end date (  )  )  ;     leases . add ( pad lease )  ;   byte array input stream bais = new  byte array input stream ( enc )  ;  for  ( int i = 0 ;  i  <  size  +  1 ;  i +  +  )   {   hash h = new  hash (  )  ;  h . read bytes ( bais )  ;     leases . get ( i )  . set gateway ( h )  ;   tunnel id t = new  tunnel id (  )  ;  t . read bytes ( bais )  ;     leases . get ( i )  . set tunnel id ( t )  ;   }   }  
@ override public boolean   (  )  {  return s  =  =   subscription helper . cancelled ;   }  
private void   (  string data )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( "update "  +  table name  +  " set prop value =  ?  where ownerid =  ?  and name =  ? " )  ;  pstmt . set string ( 1 properties . get ( data )  )  ;  pstmt . set long ( 2 id )  ;   db connection manager . set large text field ( pstmt 3 data )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public void   ( int value )  {  set value (  integer . to string ( value )  )  ;   }  
private void   ( final  arc state state final  robin robin final  string consol fun string final long num steps final double xff value )  throws io exception  {  final long nan steps = state . get nan steps (  )  ;  double accum value = state . get accum value (  )  ;  if  ( nan steps  <  =  xff value * num steps &&  !  double . is nan ( accum value )  )   {  if  ( consol fun string . equals ( cf   average )  )   {  accum value /  =  ( num steps  -  nan steps )  ;   }  robin . store ( accum value )  ;   }  else  {  robin . store (  double .  nan )  ;   }  state . set accum value (  double .  nan )  ;  state . set nan steps ( 0 )  ;   }  
@ test public void   (  )  {  assert false (  request url tokenizer . has version info ( "version - 1" version ids )  )  ;   }  
public  iterator <  string >    (  )  {  if  ( properties  =  =  null )   {  load properties from db (  )  ;   }  return  collections . unmodifiable set ( properties . key set (  )  )  . iterator (  )  ;   }  
public   (  thread factory thread factory )  {  this . thread factory = thread factory ;   }  
@ override public synchronized  event dispatcher   (  )  throws  interrupted exception  {  final  event e = next event (  )  ;  return new  event dispatcher impl ( e  collections . unmodifiable set ( get or create listener set ( e . type (  )  . get class
 string   (  )  {  return    db dir ;   }  
public  text builder   (  uri content uri )  {  return add tag ( "img" "src" content uri . to string (  )  )  ;   }  
void   (  )  {  if  ( compare and set ( false true )  )   {  try  {  disposer . accept ( resource )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( e )  ;   }   }   }  
public  roster   (  string username )  throws  user not found exception  {   roster roster = roster cache . get ( username )  ;  if  ( roster  =  =  null )   {  synchronized  (  ( username  +  " ro" )  . intern (  )  )   {  roster = roster cache . get ( username )  ;  if  ( roster  =  =  null )   {  roster = new  roster ( username )  ;  roster cache . put ( username roster )  ;   }   }   }  return roster ;   }  
@ test @ suppress warnings ( "rawtypes" )  public void   (  )  throws  exception  {  try  {   consumer <  ?  super  throwable >  error handler = new  consumer <  throwable >  (  )  {  @ override public void accept (   throwable t )  {  throw new  test exc
@ override public void   (  )  {  try  {   system . out . println ( "running  test observable thread" )  ;  for  (   string s : values )   {   system . out . println ( " test observable on next: "  +  s )  ;  observer . on next ( s )  ;   }  throw new  ru
@ test public void   (  )  {   string key = "my element" ;   string value = "1  2  3" ;  datastore . patch ( key new  string value .  patch ( value )  5 days )  ;   string value element =  (  string value ) datastore . get ( key )  ;  assert not null ( el
@ override public void   (  )  {  s . cancel (  )  ;   }  
@ ignore ( "v2 components should not throw" )  @ test ( expected =  runtime exception . class )  public void   (  )  throws  exception  {   single . just ( 1 )  . do on success ( new  consumer <  integer >  (  )  {  @ override public void accept (   integ
public void   (  string val )  {     old config = val ;   }  
public static  < t >  flowable < t >    (  )  {  return new  flowable < t >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super t >  observer )  {  observer . on subscribe ( new  queue subscription < t >  (  )  {  @ override public int request fusion (  int mode )  {  return 0 ;   }  @ override public boolean offer (  t value )  {  throw new  illegal state exception (  )  ;   }  @ override public boolean offer (  t v1  t v2 )  {  throw new  illegal state exception (  )  ;   }  @ override public t poll (  )  throws  exception  {  return null ;   }  @ override public boolean is empty (  )  {  return true ;   }  @ override public void clear (  )  {   }  @ override public void cancel (  )  {   }  @ override public void request (  long n )  {   }   }   )  ;   }   }   ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . collect (  (  callable <  integer >  ) null new  bi consumer <  integer  integer >  (  )  {  @ override public void accept (   integer a   integer b )  {   }   }   )  ; 
private ssl context   (  )  {   key store ks =  key store util . load system key store (  )  ;  if  ( ks  =  =  null )   {     log . error ( " key  store init error" )  ;  return null ;   }  if  (    log . should log (  log . info )  )   {  int count =  key store util . count certs ( ks )  ;     log . info ( " loaded "  +  count  +  " default trusted certificates" )  ;   }   file dir = new  file (    context . get base dir (  )  cert   dir )  ;  int adds =  key store util . add certs ( dir ks )  ;  int total adds = adds ;  if  ( adds  >  0 &&    log . should log (  log . info )  )     log . info ( " loaded "  +  adds  +  " trusted certificates from " +  dir . get absolute path (  )  )  ;  if  (  !    context . get base dir (  )  . get absolute path (  )  . equals (    context . get config dir (  )  . get absolute path (  )  )  )   {  dir = new  file (    context . get config dir (  )  cert   dir )  ;  adds =  key store util . add certs ( dir ks )  ;  total adds +  = adds ;  if  ( adds  >  0 &&    log . should log (  log . info )  )     log . info ( " loaded "  +  adds  +  " trusted certificates from " +  dir . get absolute path (  )  )  ;   }  dir = new  file (  system . get property ( "user . dir" )  )  ;  if  (  !    context . get base dir (  )  . get absolute path (  )  . equals ( dir . get absolute path (  )  )  )   {  dir = new  file (    context . get config dir (  )  cert   dir )  ;  adds =  key store util . add certs ( dir ks )  ;  total adds +  = adds ;  if  ( adds  >  0 &&    log . should log (  log . info )  )     log . info ( " loaded "  +  adds  +  " trusted certificates from " +  dir . get absolute path (  )  )  ;   }  if  (    log . should log (  log . info )  )     log . info ( " loaded total of "  +  total adds  +  " new trusted certificates" )  ;  try  {  ssl context sslc = ssl context . get instance ( "tls" )  ;   trust manager factory tmf =  trust manager factory . get instance (  trust manager factory . get default algorithm (  )  )  ;  tmf . init ( ks )  ;  x509 trust manager default trust manager =  ( x509 trust manager ) tmf . get trust managers (  ) [0] ;     stm = new  saving trust manager ( default trust manager )  ;  sslc . init ( null new  trust manager[] {    stm }  null )  ;  return sslc ;   }  catch  (   general security exception gse )   {     log . error ( " key  store update error" gse )  ;   }  catch  (   exception in initializer error eiie )   {     log . error ( "ssl context error  -   java 9 bug ? " eiie )  ;   }  return null ;   }  
public void   (  string protocol )  {  this . protocol = protocol ;   }  
@ override public void   ( tls policy tls policy )  {  this . tls policy = tls policy ;   }  
public void   (  response event response received event )  {   response response = response received event . get response (  )  ;  if  ( response received event . get client transaction (  )   =  =  null )   {   logger . error ( " sip server process response: client transaction is null !  "  +  response received event . get response (  )  )  ;  return ;   }  try  {   sip listener sip listener = find sip listener ( response received event )  ;  if  ( sip listener  !  =  null )   {  sip listener . process response ( response received event )  ;   }  else  {  if  ( response . get status code (  )   !  =   response . ok && response . get status code (  )   !  =  201 )   {   call id header call id header =  (  call id header ) response . get header (  call id header . name )  ;   }   }   }  catch  (   exception e )   {   logger . exception ( "process response" e )  ;   }   }  
boolean   (  )  {  return get (  )   =  =  0l ;   }  
public  boolean   (  )  throws  exception  {  try  {   list <  string >  properties =  jive globals . get property names (  )  ;  for  (   string property name : properties )   {   string property value =  jive globals . get property ( property name )  ;  execute script ( property name property value )  ;   }   }  catch  (   exception e )   {   log . error ( " node js initialize pluginn" e )  ;   }  return true ;   }  
@ override public void   (  completable observer s )  {   empty disposable . complete ( s )  ;   }  
@ test public void   (  )  throws  exception  {   lease lease = new  lease (  )  ;  assert true ( lease . is expired (  )  )  ;  lease . set end date ( new  date ( 1000 * 60 * 2 )  )  ;  byte h[] = new byte[ hash . hash   length] ;  lease . set gateway ( 
public short[]   (  )  {  return c ;   }  
public void   (  )  {     cleaner . cancel (  )  ;     cache . clear (  )  ;   }  
public  list <  integer >    (  )  {  return    order ;   }  
void   ( jid roomjid )  {  reply rooms . add ( roomjid )  ;   }  
@ override public void   (  throwable t )  {  if  ( get (  )   !  =   disposable helper . disposed )   {  lazy set (  disposable helper . disposed )  ;  parent . boundary error ( this t )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   }  
public void   (  string room name  string service name muc room entity muc room entity )  throws muc service exception  {  try  {  if  (  ! room name . equals ( muc room entity . get room name (  )  )  )   {  throw new muc service exception ( " could not update the channel .   the room name is different to the entity room name . " room name " illegal argument exception" )  ;   }  create room ( muc room entity service name )  ;   }  catch  (   not allowed exception e )   {  throw new muc service exception ( " could not update the channel" room name " not allowed exception" )  ;   }  catch  (   forbidden exception e )   {  throw new muc service exception ( " could not update the channel" room name " forbidden exception" )  ;   }  catch  (   conflict exception e )   {  throw new muc service exception ( " could not update the channel" room name " conflict exception" )  ;   }   }  
private void   ( i2np message message body  hash from )  {  if  (    log . should log (  log . debug )  )     log . debug ( " shortcut dispatch tunnel data message "  +  message body )  ;     context . tunnel dispatcher (  )  . dispatch (  (  tunnel data message ) message body from )  ;   }  
@ override protected  string   (  )  throws io exception  {   string builder buf = new  string builder ( 2048 )  ;  uri url ;  try  {  url = new uri (    actualurl )  ;   }  catch  (  uri syntax exception use )   {  io exception ioe = new  malformedurl ex
@ override public  list <  integer >    (  )  throws  exception  {  if  (  +  + calls  =  =  2 )   {  ts . cancel (  )  ;   }  return new  array list <  integer >  (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . distinct ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return null ;   }   }   )  . blocking subscribe (  )  ;   }  
@ override public void   (  observer <  ?  super t >  t )  {  source . subscribe ( new  take last timed observer < t >  ( t count time unit scheduler buffer size delay error )  )  ;   }  
public   (  )  {  renew (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  for  ( int j = 1 ;  j  <  50 ;  j +  = 5 )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publi
public static void   ( final  string[] args )  {  final  gather bam files gatherer = new  gather bam files (  )  ;  gatherer . create   index = true ;  gatherer . instance main with exit ( args )  ;   }  
@ override public void   (  subscription s )  {  s . request (  long . max   value )  ;   }  
@ override public void   (  subscription s )  throws  exception  {  throw new  test exception (  )  ;   }  
public int   (  )  {  return port ;   }  
public static  string   (  string string int length )  {  if  ( string  =  =  null || string . length (  )   >  length )   {  return string ;   }   string builder buf = new  string builder ( length )  ;  buf . append ( zero array 0 length  -  string . length (  )  )  . append ( string )  ;  return buf . to string (  )  ;   }  
@ test public void   (  )  {  final  list <  string >  errors = new  array list <  string >  (  )  ;   revert sam .  validation util . validate output params by read group ( null bad header output map errors )  ;   assert . assert equals ( errors . size (
@ override public void   (  )  {  fs . on next ( 1 )  ;  fs . on complete (  )  ;   }  
@ override public void   (  string username  string password )  throws  unauthorized exception  {  if  ( username  =  =  null || password  =  =  null )   {  throw new  unauthorized exception (  )  ;   }  username = username . trim (  )  . to lower case ( 
@ override public void   (  )  {  cancel timer (  )  ;  s . dispose (  )  ;   }  
private  index writer   ( boolean create )  throws io exception  {   index writer writer = new  index writer ( search directory indexer analyzer create )  ;  return writer ;   }  
public void   ( final  rrd updater other )  throws io exception   rrd exception  {  if  (  !  ( other instanceof  header )  )   {  throw new  rrd exception ( " cannot copy  header object to "  +  other . get class (  )  . get name (  )  )  ;   }  final  header header =  (  header ) other ;  header . signature . set ( signature . get (  )  )  ;  header . last update time . set ( last update time . get (  )  )  ;   }  
@ override public synchronized void   (  )  {  clean up (  )  ;  session disconnected no reconnect ( null )  ;   }  
public void   (  session session )  {   log . debug ( " rayo plugin session destroyed "  +  session . get address (  )  . to string (  )   +  "\n" +   (  (  client session ) session )  . get presence (  )  . toxml (  )  )  ;   call handler . hangup owner ( session . get address (  )  . to string (  )  " user has ended session" )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  s = new  test subscriber <  integer >  (  )  ;   flowable . just ( 1 )  . take last ( 1 )  . subscribe ( s )  ;  s . assert value ( 1 )  ;  s . assert no errors (  )  ;  s . assert terminated ( 
@ test public void   (  )  throws  exception  {  final  atomic integer count = new  atomic integer (  )  ;   flowable <  integer >  o =  flowable . just ( 1 )  . do on subscribe ( new  consumer <  subscription >  (  )  {  @ override public void accept (  
public static  media info   ( int encoding int sample rate int channels )  throws  parse exception  {  for  ( int i = 0 ;  i  <  supported media . size (  )  ;  i +  +  )   {   media info media info =  (  media info ) supported media . element at ( i )  ;  if  ( media info . is telephone event payload (  )  )   {  continue ;   }  if  ( media info . get encoding (  )   =  =  encoding && media info . get sample rate (  )   =  =  sample rate && media info . get channels (  )   =  =  channels )   {  return media info ;   }   }  throw new  parse exception ( " unsupported media "  +  "encoding "  +  encoding  +  " sample rate " +  sample rate +  " channels " +  channels 0 )  ;   }  
public static void   (  string args[] )  {  int dropx1000 = 0  jitter = 0  latency = 0 ;  boolean error = false ;   getopt g = new  getopt ( "router" args "d:j:l:" )  ;  try  {  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 'd': dropx1000 =  ( int )  ( 1000 *  double . parse double ( g . get optarg (  )  )  )  ;  if  ( dropx1000  <  0 || dropx1000  >  =  100 * 1000 )  error = true ;  break ;  case 'j': jitter =  integer . parse int ( g . get optarg (  )  )  ;  if  ( jitter  <  0 )  error = true ;  break ;  case 'l': latency =  integer . parse int ( g . get optarg (  )  )  ;  if  ( latency  <  0 )  error = true ;  break ;  default : error = true ;   }   }   }  catch  (  runtime exception e )   {  e . print stack trace (  )  ;  error = true ;   }  if  ( error || args . length  -  g . get optind (  )   >  0 )   {  usage (  )  ;   system . exit ( 1 )  ;   }   router context ctx = new  router context ( null )  ;  int port =  client manager facade impl . default   port ;   local client manager mgr = new  local client manager ( ctx port )  ;  mgr . dropx1000 = dropx1000 ;  mgr . jitter = jitter ;  mgr . latency = latency ;  mgr . start (  )  ;   system . out . println ( " listening on port "  +  port )  ;  try  {   thread . sleep ( 60 * 60 * 1000 )  ;   }  catch  (  interrupted exception ie )   {   }   system . out . println ( " done listening on port "  +  port )  ;   }  
private void   (  )  {  m activity = get activity (  )  ;  m check frequency view =  (  spinner ) m activity . find view by id ( r . id . account   check   frequency )  ;  m background attachments view =  (  check box ) m activity . find view by id ( r . id . account   background   attachments )  ;   }  
public long   (  )  {  return    bitfield message id ;   }  
void   (  workgroup workgroup )  {   workgroup .  status new status = workgroup . get status (  )  ;   workgroup .  status old status = workgroup open status . put ( workgroup . getid (  )  new status )  ;  if  (  workgroup .  status . open  !  =  old status &&  workgroup .  status . open  =  =  new status )   {  workgroup . notify opened (  )  ;   }  else if  (  workgroup .  status . open  =  =  old status &&  workgroup .  status . open  !  =  new status )   {  workgroup . notify closed (  )  ;   }   }  
public void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "stop datagram receiving (  )  invoked" )  ;  if  ( datagram session  =  =  null )   {     log . error ( "bug !   got datagram receiving stop  but session is null ! " )  ;  return ;   }  try  {  close client socket (  )  ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error closing socket" e )  ;   }   }  
public void   ( int i )  {  e = i ;   }  
@ override public void   (  context context  intent intent )  {  if  ( intent . get action (  )  . equals (  connectivity manager . connectivity   action )  )   {   bundle extras = intent . get extras (  )  ;  if  ( extras  !  =  null )   {   network info
@ override public void   (  )  throws  exception  {  super . set up (  )  ;  m mock context = get mock context (  )  ;  m mock resolver = m mock context . get content resolver (  )  ;  m email provider = new  email provider (  )  ;  m email provider . att
@ override public void   (  )  throws  exception  {  observer . on complete (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "cc" "dd" "eee" "eee" )  ;   function <  integer  collection <  string >  >  collection factory = new  function <  integer  collection <  string >  >  (  )  {  @ override
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  object >  func = mock (  callable . class )  ;  when ( func . call (  )  )  . then return ( new  object (  )  )  ;   flowable <  object >  from callable flo
  (  observer <  ?  super  timed < t >  >  actual  time unit unit  scheduler scheduler )  {  this . actual = actual ;  this . scheduler = scheduler ;  this . unit = unit ;   }  
protected void   (  )  {  try  {  final  sam file validator validator = new  sam file validator ( new  print writer (  system . out )  8000 )  ;  validator . set ignore warnings ( true )  ;  validator . set verbose ( true 1000 )  ;  validator . set errors to ignore (  arrays . as list ( sam validation error .  type . missing   read   group )  )  ;   sam reader factory factory =  sam reader factory . make default (  )  . validation stringency (  validation stringency . lenient )  ;   sam reader sam reader = factory . open ( get output (  )  )  ;  final sam record iterator iterator = sam reader . iterator (  )  ;  while  ( iterator . has next (  )  )   {  final sam record rec = iterator . next (  )  ;   assert . assert equals ( rec . get cigar string (  )  expected cigar )  ;  if  ( sam utils . has mate cigar ( rec )  )   {   assert . assert equals ( sam utils . get mate cigar string ( rec )  expected cigar )  ;   }   }   closer util . close ( sam reader )  ;  sam reader = factory . open ( get output (  )  )  ;  final boolean validated = validator . validate sam file verbose ( sam reader null )  ;   closer util . close ( sam reader )  ;   assert . assert true ( validated " validate sam file failed" )  ;   }  finally  {   test util . recursive delete ( get output dir (  )  )  ;   }   }  
public int   (  version version )  {  int number = version . get version number (  )  ;  int offset ;  if  ( number  <  =  9 )   {  offset = 0 ;   }  else if  ( number  <  =  26 )   {  offset = 1 ;   }  else  {  offset = 2 ;   }  return character count bits for versions[offset] ;   }  
@ test public void   (  )  throws  exception  {  for  (  final  string reference : illegal numeric character references )   {  final boolean result = xml lightweight parser . has illegal character references ( reference )  ;  assert true ( " no illegal nu
@ test public void   (  )  {   single <  integer >  o =  observable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single ( 2 )  ;   single observe
public   (  )  {  super ( " jetty stopper" )  ;  change state ( stopping )  ;   }  
public void   (  string str )  {  try  {     width =  math . max ( min   x  math . min (  integer . parse int ( str )  max   x )  )  ;   }  catch  (   number format exception nfe )   {   }   }  
private  string   (  http servlet request request  string login page  string optional params )  {   string builder buf = new  string builder (  )  ;  try  {  buf . append ( request . get requesturi (  )  )  ;   string qs = request . get query string (  )  ;  if  ( qs  !  =  null )   {  buf . append ( ' ? ' )  . append ( qs )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  return login page  +  " ? url = "  +  url encoder . encode ( buf . to string (  )  "iso - 8859 - 1" )  +   ( optional params  !  =  null  ?  "&"  +  optional params : "" )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return null ;   }   }  
public synchronized  trust manager[]   (  )  throws  key store exception   no such algorithm exception  {  return new  trust manager[] { new  openfirex509 trust manager ( configuration . get trust store (  )  . get store (  )  configuration . is accept self signed certificates (  )  configuration . is verify certificate validity (  )  )  }  ;   }  
protected static void   (  list <  string >  classes )  {   system . err . println ( " available commands:" )  ;   list <  string >  cmds = new  array list <  string >  ( classes . size (  )  )  ;  for  (   string cls : classes )   {   string ccmd = cls . substring ( cls . last index of ( ' . ' )   +  1 )  . to lower case (  locale . us )  ;  cmds . add ( ccmd )  ;   }   collections . sort ( cmds )  ;  for  (   string cmd : cmds )   {   system . err . println ( " "  +  cmd )  ;   }   system . err . println ( " enter command for detailed help . " )  ;   }  
public void   ( int value )  {  set value (  integer . to string ( value )  )  ;   }  
public long   (  )  {  return  cache factory . get max cache lifetime ( get name (  )  )  ;   }  
@ test public void   (  )  {   observable <  integer >  w =  observable . empty (  )  ;   observable <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t )  {  return true ;   }   }   )  .
private void   (  )  {   file file = subs file (  )  ;  if  ( file . is file (  )  )   {   string builder buf = new  string builder (  )  ;   buffered reader br = null ;  try  {  br = new  buffered reader ( new  input stream reader ( new  file input stream ( file )  "utf - 8" )  )  ;   string line ;  while  (  ( line = br . read line (  )  )   !  =  null )   {  buf . append ( line )  ;  buf . append ( "\n" )  ;   }  content = buf . to string (  )  ;   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }  finally  {  if  ( br  !  =  null )  try  {  br . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  else  {  content = default   sub ;   }   }  
@ override public void   (  boolean a boolean )  {  assert null ( a boolean )  ;   }  
public  string   ( int tunnel )  {  return  data helper . escapehtml (    helper . get tunnel description ( tunnel )  )  ;   }  
public  thread   (  runnable r )  {   thread rv =  executors . default thread factory (  )  . new thread ( r )  ;  rv . set name (    name  +  ' '  +   (  +  +    count )  +  ' / ' +     threads )  ;  rv . set daemon ( true )  ;  return rv ;   }  
@ test public void   (  )  {   observable . zip (  observable . just ( 1 )   observable . just ( 2 )   observable . just ( 3 )   observable . just ( 4 )   observable . just ( 5 )   observable . just ( 6 )   observable . just ( 7 )   observable . just ( 8 
public  list <  allele >    (  )  {  if  ( all alleles . is empty (  )  || this . call allele1  =  =  null )   {  return  collections . empty list (  )  ;   }  else  {  final  allele call allele1 =  allele . create ( this . call allele1 this . all alleles . index of ( this . call allele1 )   =  =  0 )  ;  final  allele call allele2 =  allele . create ( this . call allele2 this . all alleles . index of ( this . call allele2 )   =  =  0 )  ;  return  arrays . as list ( call allele1 call allele2 )  ;   }   }  
@ test public void   (  )  {   flowable <  string >  o1 =  flowable . just ( "one" "two" )  ;   flowable <  string >  o2 =  flowable . just ( "three" "four" )  ;   list <  string >  values =  flowable . concat ( o1 o2 )  . to list (  )  . blocking get (  
public   (  router context context  floodfill network database facade facade )  {  super ( context )  ;     facade = facade ;     log = context . log manager (  )  . get log (  floodfill monitor job . class )  ;   }  
private final void   (  string expect )  {  final  string result = to hex ( hash . engine digest (  )  )  ;  expect = expect . to upper case (  )  ;  assert equals ( expect result )  ;   }  
public void   (  ad hoc command command )  {  commands . put ( command . get code (  )  command )  ;   }  
private static  string   (  string[] ui projection  list <  string >  content type query parameters )  {   content values values = new  content values ( 1 )  ;  values . put ( ui provider .  attachment columns . supports   download   again 1 )  ;   string builder sb = gen select ( get attachment map (  )  ui projection values )  ;  sb . append ( " from " )  . append (  attachment . table   name )  . append ( " where " )  . append (  attachment columns . message   key )  . append ( "  =  ?  " )  ;  if  ( content type query parameters  !  =  null &&  ! content type query parameters . is empty (  )  )   {  final int size = content type query parameters . size (  )  ;  sb . append ( "and  ( " )  ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  final  string content type = content type query parameters . get ( i )  ;  sb . append (  attachment columns . mime   type )  . append ( " like '" )  . append ( content type )  . append ( "%'" )  ;  if  ( i  !  =  size  -  1 )   {  sb . append ( " or " )  ;   }   }  sb . append ( " ) " )  ;   }  return sb . to string (  )  ;   }  
@ override public void   (  )  {  if  (    log . should log (  log . debug )  )     log . debug ( "shut down gracefully (  )  invoked on socket sender "  +     id )  ;     shutting down gracefully = true ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . error ( new 
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;   subscriber <  object >  sub = new  subscriber <  object >  (  )  {  @ override public void on subscribe (   subscription s )  {  s . request ( 5 )  ;  lis
@ test public void   (  )  {   maybe . just ( 1 )  . ignore element (  )  . test (  )  . assert result (  )  ;   }  
private void   (  )  {  int retries = 0 ;  while  ( sock mgr . get session (  )  . is closed (  )  )   {  try  {  sock mgr . get session (  )  . connect (  )  ;   list < i2p session >  subs = sock mgr . get subsessions (  )  ;  if  (  ! subs . is empty (  )  )   {  for  (  i2p session sub : subs )   {  try  {  sub . connect (  )  ;  if  (    log . should info (  )  )     log . info ( " connected subsession "  +  sub )  ;   }  catch  (  i2p session exception ise )   {   string msg = " unable to connect subsession "  +  sub ;  this . l . log ( msg )  ;     log . error ( msg ise )  ;   }   }   }   }  catch  (  i2p session exception ise )   {   string port num = get tunnel (  )  . port ;  if  ( port num  =  =  null )  port num = "7654" ;   string msg ;  if  ( get tunnel (  )  . get context (  )  . is router context (  )  )  msg = " unable to build tunnels for the server at "  +  remote host . get host address (  )   +  ':' +  remote port ;  else msg = " unable to connect to the router at "  +  get tunnel (  )  . host  +  ':' +  port num +  " and build tunnels for the server at " +  remote host . get host address (  )  +  ':' +  remote port ;  if  (  +  + retries  <  max   retries )   {  msg +  = "  retrying in "  +   ( retry   delay  /  1000 )   +  " seconds" ;  this . l . log ( msg )  ;     log . error ( msg )  ;   }  else  {  msg +  = "  giving up" ;  this . l . log ( msg )  ;     log . log (  log . crit msg ise )  ;  throw new  illegal argument exception ( msg ise )  ;   }  try  {   thread . sleep ( retry   delay )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  l . log ( " tunnels ready for server at "  +  remote host . get host address (  )   +  ':' +  remote port )  ;  notify event ( "open server result" "ok" )  ;  open = true ;   }  
public   (  )  {  super ( " message  archiving  list  handler" "list" namespace )  ;   }  
public void   (  string username )  {  if  ( username  =  =  null )   {  throw new  null pointer exception ( " arguments cannot be null . " )  ;   }   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( change   username )  ;  pstmt . set string ( 1 username )  ;  pstmt . set long ( 2 registrationid )  ;  pstmt . set string ( 3 this . username )  ;  pstmt . execute update (  )  ;  this . username = username ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public void   (  node subscription subscription )  {  subscriptions byid . put ( subscription . getid (  )  subscription )  ;  subscriptions byjid . put ( subscription . getjid (  )  . to string (  )  subscription )  ;   }  
@ override public void   (  object value )  {  parent . other complete (  )  ;   }  
public static  sessionsdb   (  )  {  return sa mv3 handler . s sessions hash ;   }  
public  update task   (  update type type  update method method  list < uri >  update sources  string id  string new version long max time )  {  boolean should proxy =    context . get property (  config update handler . prop   should   proxy  config update handler . default   should   proxy )  ;  if  (  ( type  !  =  router   signed && type  !  =  router   signed   su3 )  ||  ( should proxy && method  !  =  http )  ||  (  (  ! should proxy )  && method  !  =  http   clearnet && method  !  =  https   clearnet ) || update sources . is empty (  )  )  return null ;   update runner update = new  update runner (    context    mgr type method update sources )  ;     mgr . notify progress ( update " < b > "  +     mgr .    t ( " updating i2p" )   +  " <  / b > " )  ;  return update ;   }  
public boolean   (  )  {  return    received as reply ;   }  
protected void   (  )  throws  exception  {  super . do stop (  )  ;  try  {  if  (    writer  !  =  null )     writer . flush (  )  ;   }  catch  (  io exception e )   {   log . get logger (  (  string ) null )  . ignore ( e )  ;   }  if  (    out  !  =  null &&    close out )  try  {     out . close (  )  ;   }  catch  (  io exception e )   {   log . get logger (  (  string ) null )  . ignore ( e )  ;   }     out = null ;     file out = null ;     close out = false ;     log date cache = null ;     writer = null ;     buffers = null ;     copy = null ;   }  
public static  image   (  string image name  class cls )  {  try  {  final url url = cls . get resource ( image name )  ;  if  ( url  =  =  null )   {  return null ;   }   image image = image cache . get ( url . to string (  )  )  ;  if  ( image  =  =  null )   {  image =  toolkit . get default toolkit (  )  . create image ( url )  ;  image cache . put ( url . to string (  )  image )  ;   }  return image ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }  return null ;   }  
@ override public void   ( final  throwable e )  {  actual . on error ( e )  ;   }  
public static  statement customizer   ( final int fetch size )  {  return new  statement customizer (  )  {  @ override public void before execution (  final  prepared statement stmt  final  statement context ctx )  throws sql exception  {  stmt . set fetch size ( fetch size )  ;   }   }   ;   }  
static  column mapper factory   (  )  {  return  ( type config )   -  >   {   class <  ?  >  raw type = get erased type ( type )  ;  if  ( raw type  =  =   option . class )   {  final  type nested type =  generic types . find generic parameter ( type  option . class )  . or else throw (  (  )   -  >  new  no such mapper exception ( " no mapper for raw  option type" )  )  ;  return  optional . of ( new  vavr option mapper <  >  ( nested type )  )  ;   }  return  optional . empty (  )  ;   }   ;   }  
  (  method method )  {  try  {   class <  ?  >  declaring class = method . get declaring class (  )  ;  method handle = lookup for ( declaring class )  . unreflect special ( method declaring class )  ;   }  catch  (   reflective operation exception e )   {  throw new  runtime exception ( e )  ;   }   }  
public void   (  signature sig )  {     signature = sig ;   }  
public static  object   (  )  {  return complete ;   }  
public boolean   (  )  {  return  ! is not empty (  )  ;   }  
@ test public void   (  )  {   flowable <  string >  obs =  flowable . empty (  )  ;   subscriber <  boolean >  observer =  test helper . mock subscriber (  )  ;  obs . all ( new  predicate <  string >  (  )  {  @ override public boolean test (   string s
@ override public void   (  integer t )  {  throw new  runtime exception ( "failed" )  ;   }  
private int   ( final  file file final  string regex )  {  return grep ( file "[ ; \t]mv = "  +  regex  +  "[ ; \t]" )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  for  ( int i = 0 ;  i  <  5 ;  i +  +  )   {  reporting service . increment request count ( "id   7" )  ;   }  assert equals ( 5 reporting service . get destination info ( "id   7" )  . get tota
public long   (  )  {  return total requests ;   }  
private   (  )  {  timer = new  timer ( "timer - monitoring" true )  ;  final  thread factory thread factory = new  named thread factory ( "pool - monitoring" true  thread . norm   priority  thread . current thread (  )  . get thread group (  )  0l )  ;  executor =  executors . new cached thread pool ( thread factory )  ;   }  
private   (  string client alias x509 certificate[] certificate chain  private key private key )  {  m client alias = client alias ;  m certificate chain = certificate chain ;  m private key = private key ;   }  
public void   (  validator configuration validator configuration  string config root  string wadl uri )  {  log deprecation warnings ( validator configuration )  ;  default validator = null ;   list <  ?  extends  validator item >  validator items = validator configuration . get validator (  )  ;  validators = new  array list <  >  ( validator items . size (  )  )  ;   delegating type delegating type = validator configuration . get delegating (  )  ;  boolean is delegating = delegating type  !  =  null ;  double delegation quality = is delegating  ?  delegating type . get quality (  )  : 0 . 0 ;   string component name = is delegating  ?  delegating type . get component name (  )  : "api - validator" ;  for  (   validator item validator item : validator items )   {   config configuration = create configuration ( validator item is delegating delegation quality validator configuration . is multi role match (  )  config root component name )  ;  configuration . set preserve request body ( validator configuration . is multi role match (  )  )  ;   validator info validator = validator item . get any (  )   !  =  null  ?  new  validator info ( validator item . get role (  )  validator item . get any (  )  get wadl path ( wadl uri config root )  configuration validator item . get validator name (  )  )  : new  validator info ( validator item . get role (  )  get wadl path ( validator item . get wadl (  )  config root )  configuration validator item . get validator name (  )  )  ;  validators . add ( validator )  ;  if  ( validator item . is default (  )  && default validator  =  =  null )   {  default validator = validator ;   }   }   }  
@ override public void   (  filter config filter config )  throws  servlet exception  {  log . debug ( " start "  +  this . get class (  )  . get name (  )  )  ;   }  
public static  string   ( long diff )  {  final  string hours = "h" ;  final  string minutes = "min" ;  final  string seconds = "sec" ;  final long ms   in   a   day = 1000 * 60 * 60* 24 ;  final long ms   in   an   hour = 1000 * 60 * 60 ;  final long ms   in   a   minute = 1000 * 60 ;  final long ms   in   a   second = 1000 ;  diff = diff % ms   in   a   day ;  long num hours = diff  /  ms   in   an   hour ;  diff = diff % ms   in   an   hour ;  long num minutes = diff  /  ms   in   a   minute ;  diff = diff % ms   in   a   minute ;  long num seconds = diff  /  ms   in   a   second ;  diff = diff % ms   in   a   second ;   string builder buf = new  string builder (  )  ;  if  ( num hours  >  0 )   {  buf . append ( num hours  +  " "  +  hours +  "  " )  ;   }  if  ( num minutes  >  0 )   {  buf . append ( num minutes  +  " "  +  minutes +  "  " )  ;   }  buf . append ( num seconds  +  " "  +  seconds )  ;   string result = buf . to string (  )  ;  return result ;   }  
private  string[]   (  input stream in )  {   string[] header lines = null ;  error = "" ;  if  ( header  !  =  null )   {  boolean ok = true ;   encoding html =  encoding factory . get encoding ( "html" )  ;  if  ( html  =  =  null )   {  error +  = "html encoder not found . \n" ;  ok = false ;   }   encoding hl =  encoding factory . get encoding ( "headerline" )  ;  if  ( hl  =  =  null )   {  error +  = " header line encoder not found . \n" ;  ok = false ;   }  if  ( ok )   {  try  {  eof on match input stream eofin = new eof on match input stream ( in header   match )  ;   memory buffer decoded = new  memory buffer ( 4096 )  ;  hl . decode ( eofin decoded )  ;  if  (  ! eofin . was found (  )  )  if  (    log . should debug (  )  )     log . debug ( "eof hit before \\r\\n\\r\\n in  mail" )  ;  header lines =  data helper . split ( new  string ( decoded . get content (  )  decoded . get offset (  )  decoded . get length (  )  )  "\r\n" )  ;  for  ( int j = 0 ;  j  <  header lines . length ;  j +  +  )   {   string line = header lines[j] ;  if  ( line . length (  )   =  =  0 )  break ;   string hlc = line . to lower case (  locale . us )  ;  if  ( hlc . starts with ( "from:" )  )   {  sender = line . substring ( 5 )  . trim (  )  ;  short sender = sender . replace ( "\"" "" )  . trim (  )  ;  int lt = short sender . index of ( ' < ' )  ;  if  ( lt  >  0 )  short sender = short sender . substring ( 0 lt )  . trim (  )  ;  else if  ( lt  <  0 && short sender . contains ( "@" )  )  short sender = ' < '  +  short sender  +  ' > ' ;  boolean trim = short sender . length (  )   >  45 ;  if  ( trim )  short sender =  servlet util . truncate ( short sender 42 )  . trim (  )  ;  short sender = html . encode ( short sender )  ;  if  ( trim )  short sender +  = "&hellip ; " ;   }  else if  ( hlc . starts with ( "date:" )  )   {  date string = line . substring ( 5 )  . trim (  )  ;  long date long = rfc822 date . parse822 date ( date string )  ;  if  ( date long  >  0 )  set date ( date long )  ;   }  else if  ( hlc . starts with ( "subject:" )  )   {  subject = line . substring ( 8 )  . trim (  )  ;  short subject = subject ;  boolean trim = subject . length (  )   >  75 ;  if  ( trim )  short subject =  servlet util . truncate ( subject 72 )  . trim (  )  ;  short subject = html . encode ( short subject )  ;  if  ( trim )  short subject +  = "&hellip ; " ;   }  else if  ( hlc . starts with ( "reply - to:" )  )   {  reply = get address ( line . substring ( 9 )  . trim (  )  )  ;   }  else if  ( hlc . starts with ( "to:" )  )   {   array list <  string >  list = new  array list <  string >  (  )  ;  get recipients from list ( list line . substring ( 3 )  . trim (  )  true )  ;  if  ( list . is empty (  )  )   {   }  else if  ( to  =  =  null )   {  to = list . to array ( new  string[list . size (  ) ] )  ;   }  else if  ( cc  =  =  null )   {  cc = list . to array ( new  string[list . size (  ) ] )  ;   }  else  {  for  ( int i = 0 ;  i  <  to . length ;  i +  +  )   {  list . add ( i to[i] )  ;   }  to = list . to array ( new  string[list . size (  ) ] )  ;   }   }  else if  ( hlc . starts with ( "cc:" )  )   {   array list <  string >  list = new  array list <  string >  (  )  ;  get recipients from list ( list line . substring ( 3 )  . trim (  )  true )  ;  if  ( list . is empty (  )  )   {   }  else if  ( cc  =  =  null )   {  cc = list . to array ( new  string[list . size (  ) ] )  ;   }  else  {  for  ( int i = 0 ;  i  <  cc . length ;  i +  +  )   {  list . add ( i cc[i] )  ;   }  cc = list . to array ( new  string[list . size (  ) ] )  ;   }   }  else if  ( hlc . equals ( "x - spam - flag: yes" )  )   {  is spam = true ;   }  else if  ( hlc . starts with ( "content - type:" )  )   {  content type = line . substring ( 13 )  . trim (  )  ;   }  else if  ( hlc . starts with ( "message - id:" )  )   {  messageid = line . substring ( 11 )  . trim (  )  ;   }   }   }  catch  (   exception e )   {  error +  = " error parsing mail header: "  +  e . get class (  )  . get name (  )   +  '\n' ;     log . error ( " parse error" e )  ;   }   }   }  return header lines ;   }  
public void   (  )  {  final  imap string date = new  imap simple string ( "01 -  jan - 2009 11:34:56  - 0100" )  ;  assert true ( date . is date (  )  )  ;   date d = date . get date or null (  )  ;  assert not null ( d )  ;  assert equals ( "1  jan 2009 12:34:56 gmt" d . togmt string (  )  )  ;  final  imap string non date = new  imap simple string ( "1234" )  ;  assert false ( non date . is date (  )  )  ;  assert null ( non date . get date or null (  )  )  ;   }  
private boolean   (  )  {  return get max users (  )   !  =  0 ;   }  
@ override protected void   (  completable observer observer )  {  source . subscribe ( new  flat map completable main subscriber < t >  ( observer mapper delay errors max concurrency )  )  ;   }  
public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ test public void   (  )  {  final int[] count =  { 0 }  ;   single . never (  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  throws  exception  {  count[0] +  +  ;   }   }   )  . test ( true )  ;  assert equals ( 1 count[0] )
@ override public void   (  )  {  try  {  on dispose . run (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( e )  ;   }  s . dispose (  )  ;   }  
private sam record   (  string name )  {  sam record record = new sam record ( new sam file header (  )  )  ;  record . set read name ( name )  ;  record . set base qualities ( high qualities )  ;  record . set read bases ( ref bases )  ;  return record ;   }  
public void   (  inet address[] inets )  {  this . http binds = inets ;   }  
public void   ( ssdp packet packet )  {  ssdp packet = packet ;   }  
@ test public void   (  )  {   observable <  string >  o =  observable . just ( 1 "abc" false 2l )  . of type (  string . class )  ;   observer <  object >  observer =  test helper . mock observer (  )  ;  o . subscribe ( observer )  ;  verify ( observer 
@ check return value @ backpressure support (  backpressure kind . error )  @ scheduler support (  scheduler support . none )  public final  < t right t left end t right end r >  flowable < r >    (  publisher <  ?  extends t right >  other  function <  ?
@ test ( timeout = 5000 )  public void   (  )  {   publish processor <  object >  pp1 =  publish processor . create (  )  ;   publish processor <  object >  pp2 =  publish processor . create (  )  ;   completable c1 =  completable . from publisher ( pp1 )
@ override public  object   (  string name )  {  return local datastore . patch ( name patch ttl time unit )  ;   }  
public void   ( ssdp packet ssdp packet )  {  int listener size = device search listener list . size (  )  ;  for  ( int n = 0 ;  n  <  listener size ;  n +  +  )   {   search listener listener =  (  search listener ) device search listener list . get ( n )  ;  listener . device search received ( ssdp packet )  ;   }   }  
private void   (  )  {  final long deadline =  system . current time millis (  )   -  user   idle ;  for  (   localmuc user user : users . values (  )  )   {  try  {  if  (  ! user . is joined (  )  )   {  remove user ( user . get address (  )  )  ;  continue ;   }  if  ( user   idle  =  =   - 1 )   {  continue ;   }  if  ( user . get last packet time (  )   <  deadline )   {  muc room room ;   presence kicked presence ;  for  (   localmuc role role : user . get roles (  )  )   {  room = role . get chat room (  )  ;  try  {  kicked presence = room . kick occupant ( user . get address (  )  null null null )  ;  room . send ( kicked presence )  ;   }  catch  (   not allowed exception e )   {   }   }   }   }  catch  (   throwable e )   {   log . error (  locale utils . get localized string ( "admin . error" )  e )  ;   }   }   }  
@ override public  service client response   (  string hash key  string uri  map <  string  string >  headers  string payload  media type content media type boolean check cache )  throws  akka service client exception  {   auth post request auth post requ
public  sql array types   (  sql array type factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
@ override public  enumeration <  servlet >    (  )  {  return proxy . get servlets (  )  ;   }  
private void   ( final  mendelian violation detector .  result result )  {  if  ( vcf   dir  !  =  null )   {  log . info (  string . format ( " writing family violation vc fs to %s / " vcf   dir . get absolute path (  )  )  )  ;  final  variant context comparator vc comparator = new  variant context comparator ( input header . get (  )  . get contig lines (  )  )  ;  final  set < vcf header line >  header lines = new  linked hash set <  >  ( input header . get (  )  . get meta data in input order (  )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . mendelian   violation   key 1 vcf header line type .  string " type of mendelian violation . " )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   ac vcf header line count . a vcf header line type .  integer " original ac" )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   af vcf header line count . a vcf header line type .  float " original af" )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   an 1 vcf header line type .  integer " original an" )  )  ;  for  (  final  ped file .  ped trio trio : ped file . get (  )  . values (  )  )   {  final  file output file = new  file ( vcf   dir io util . make file name safe ( trio . get family id (  )   +  io util . vcf   file   extension )  )  ;  log . info (  string . format ( " writing %s violation vcf to %s" trio . get family id (  )  output file . get absolute path (  )  )  )  ;  final  variant context writer out = new  variant context writer builder (  )  . set output file ( output file )  . unset option ( index   on   the   fly )  . build (  )  ;  final vcf header new header = new vcf header ( header lines  collection util . make list ( trio . get maternal id (  )  trio . get paternal id (  )  trio . get individual id (  )  )  )  ;  final  tree set <  variant context >  ordered violations = new  tree set <  >  ( vc comparator )  ;  ordered violations . add all ( result . violations (  )  . get ( trio . get family id (  )  )  )  ;  out . write header ( new header )  ;  ordered violations . for each ( out::add )  ;  out . close (  )  ;   }   }   }  
@ override public void   (  cluster task task byte[] nodeid )  {  throw new  illegal state exception ( " cluster service is not available" )  ;   }  
public  hash   (  )  {  return    random key ;   }  
public void   (  sort field sort field )  {  this . sort field = sort field ;   }  
public   ( i2p socket s int id )  throws io exception  {  super ( s id )  ;     data = new  array list <  byte array >  ( 1 )  ;     cache =  byte cache . get instance ( 10 32 * 1024 )  ;     out = s . get output stream (  )  ;     still running = true ;   }  
public int   (  )  {  final  default connection provider default connection provider = get default connection provider (  )  ;  return default connection provider  =  =  null  ?  0 : default connection provider . get max connections (  )  ;   }  
public static void   (  string[] args )  {  try  {  boolean uni = true ;  boolean html = true ;  if  ( html )   system . out . println ( " < html >  < head >  < meta http - equiv = \" content -  type\" content = \"text / html ;  charset = utf - 8\" >  <  / head >  < body > " )  ;  byte[] b = new byte[16] ;  net . i2p . util .  random source . get instance (  )  . next bytes ( b )  ;   string art = gnutls   key   fingerprint   randomart ( b "sha" 128 null uni html )  ;   system . out . println ( art )  ;   system . out . println ( "" )  ;  b = new byte[32] ;  for  ( int i = 0 ;  i  <  5 ;  i +  +  )   {  net . i2p . util .  random source . get instance (  )  . next bytes ( b )  ;  art = gnutls   key   fingerprint   randomart ( b "xsha" 256 null uni html )  ;   system . out . println ( art )  ;   system . out . println ( "" )  ;   }  b = new byte[48] ;  net . i2p . util .  random source . get instance (  )  . next bytes ( b )  ;  art = gnutls   key   fingerprint   randomart ( b "xxsha" 384 null uni html )  ;   system . out . println ( art )  ;   system . out . println ( "" )  ;  b = new byte[64] ;  net . i2p . util .  random source . get instance (  )  . next bytes ( b )  ;  art = gnutls   key   fingerprint   randomart ( b "xxxsha" 512 null uni html )  ;   system . out . println ( art )  ;  if  ( html )   system . out . println ( " <  / body >  <  / html > " )  ;   }  catch  (   runtime exception e )   {  e . print stack trace (  )  ;   }   }  
public static  group element   ( final  curve curve final  field element ypx final  field element ymx final  field element xy2d )  {  return new  group element ( curve  representation . precomp ypx ymx xy2d null )  ;   }  
@ test public void   (  )  {   maybe <  integer >  last =  observable . just ( 1 2 3 )  . last element (  )  ;  assert equals ( 3 last . blocking get (  )  . int value (  )  )  ;  assert equals ( 3 last . blocking get (  )  . int value (  )  )  ;   }  
public  data structure   (  )  throws  data format exception  {   lease lease = new  lease (  )  ;  lease . set end date ( new  date ( 1000 * 60 * 2 )  )  ;  byte h[] = new byte[ hash . hash   length] ;  lease . set gateway ( new  hash ( h )  )  ;   structure test tst = new  tunnel id test (  )  ;  lease . set tunnel id (  (  tunnel id ) tst . create data structure (  )  )  ;  return lease ;   }  
private void   (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   queue   groups )  ;  pstmt . set long ( 1 id )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  groups . add ( rs . get string ( 1 )  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ override public short   (  )  {  return this . read group ;   }  
int   (  )  {  return    transports . size (  )  ;   }  
public   (  list < e >  list )  {  this . list = list ;  list   size = list . size (  )  ;  served = new  bit set ( list   size )  ;  upper = list   size  -  1 ;   }  
@ override public  serializable   (  string hashed key byte[] id final  serializable patch patch final int ttl final  time unit time unit  remote behavior remote behavior )  {  return  (  serializable ) perform action ( hashed key id new  datastore action
@ test public void   (  )  {  assert equals ( 3  backpressure overflow strategy . values (  )  . length )  ;  assert not null (  backpressure overflow strategy . value of ( "error" )  )  ;   }  
public   (  conversation manager conversation manager  archive indexer archive indexer )  {  this . conversation manager = conversation manager ;  this . archive indexer = archive indexer ;   }  
@ override boolean   (  )  {  return true ;   }  
@ override public boolean   ( t first t second )  {  final  atomic reference array <  object >  buffer = producer buffer ;  final long p = lv producer index (  )  ;  final int m = producer mask ;  int pi = calc wrapped offset ( p  +  2 m )  ;  if  ( null 
public   ( i2p app context context int duration ms int entry bytes  string name int m )  {     context = context ;     log = context . log manager (  )  . get log (  decaying bloom filter . class )  ;     entry bytes = entry bytes ;     name = name ;  int k = default   k ;  if  ( m  >  default   m )   {  k -  -  ;  if  ( m  >  26 )   {  k -  -  ;  if  ( m  >  29 )  throw new  illegal argument exception ( " max m is 29" )  ;   }   }     current = new  bloomsha1 ( m k )  ;     previous = new  bloomsha1 ( m k )  ;     duration ms = duration ms ;  int num extenders =  ( 32  +   ( entry bytes  -  1 )  )   /  entry bytes  -  1 ;  if  ( num extenders  <  0 )  num extenders = 0 ;     extenders = new byte[num extenders][entry bytes] ;  for  ( int i = 0 ;  i  <  num extenders ;  i +  +  )     context . random (  )  . next bytes (    extenders[i] )  ;  if  ( num extenders  >  0 )   {     extended = new byte[32] ;     long to entry = new byte[   entry bytes] ;     long to entry mask =  ( 1l  <  <   (    entry bytes * 8l )  )   -  1 ;   }  else  {     extended = null ;     long to entry = null ;     long to entry mask = 0 ;   }     keep decaying = true ;  if  (    duration ms  =  =  60 * 60 * 1000 )   {     decay event = new  decay hourly event (  )  ;   }  else  {     decay event = new  decay event (  )  ;     decay event . schedule (    duration ms )  ;   }  if  (    log . should log (  log . warn )  )     log . warn ( " new dbf "  +  name  +  " m  =  " +  m +  " k  =  " +  k +  " entry bytes  =  " +  entry bytes +  " num extenders  =  " +  num extenders +  " cycle  ( s )   =  " +   ( duration ms  /  1000 )  )  ;  context . stat manager (  )  . create rate stat ( "router . decaying bloom filter . "  +  name  +  " . size" " size" " router" new long[] { 10 *  math . max ( 60 * 1000 duration ms )  }  )  ;  context . stat manager (  )  . create rate stat ( "router . decaying bloom filter . "  +  name  +  " . dups" "1000000 *  duplicates /  size" " router" new long[] { 10 *  math . max ( 60 * 1000 duration ms )  }  )  ;  context . stat manager (  )  . create rate stat ( "router . decaying bloom filter . "  +  name  +  " . log10 ( false pos ) " "log10 of the false positive rate  ( must have net . i2p . util .  decaying bloom filter = debug ) " " router" new long[] { 10 *  math . max ( 60 * 1000 duration ms )  }  )  ;  context . add shutdown task ( new  shutdown (  )  )  ;   }  
@ override public boolean   (  )  {  return s  =  =   subscription helper . cancelled ;   }  
public int   (  )  {  return    priority ;   }  
public  file   (  string uidl )  {  return get file ( uidl full   suffix )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   flowable <  object >  o )  throws  exception  { 
public void   (  snark snark )  {  notify progress (  )  ;     smgr . got piece ( snark )  ;   }  
public int   (  )  {  return depth ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ test public void   (  )  {  when ( mock request . get requesturi (  )  )  . then return (  cache request . cache   uri   path  +  " / foobar" )  ;  assert true (  cache request . is cache request valid ( mock request )  )  ;   }  
@ override public boolean   (  folder type type )  {  return false ;   }  
@ override public void   (  integer t )  {  list . add ( t )  ;   }  
@delete @ path ( " /  { jid } " )  public  response   ( @ path param ( "jid" )   string jid @ default value ( "conference" )  @ query param ( "servicename" )   string service name @ path param ( "room name" )   string room name )  throws muc service excep
private void   (  user entity user entity )  throws  service exception  {   user user = get and check user ( user entity . get username (  )  )  ;  user . get properties (  )  . clear (  )  ;  if  ( user entity . get properties (  )   !  =  null )   {  for  (   user property property : user entity . get properties (  )  )   {  user . get properties (  )  . put ( property . get key (  )  property . get value (  )  )  ;   }   }   }  
public static  time zone   ( i2p app context ctx )  {   string system time zone = ctx . get property ( "i2p . system time zone" )  ;  if  ( system time zone  !  =  null )  return  time zone . get time zone ( system time zone )  ;  return  time zone . get default (  )  ;   }  
@ test public void   (  )  {  final byte[] first = new byte[] { 0x1 0x2 0x3 }   second = new byte[] { 0x1 0x2 }  ;  assert false ( " arrays that have different sizes should return false for asserting that they are equal" new  byte array comparator ( first
@ after public void   (  )  throws  exception  {  if  ( h  !  =  null )  h . close (  )  ;   }  
private  function3 <  string  integer int[]  string >    (  )  {  return new  function3 <  string  integer int[]  string >  (  )  {  @ override public  string apply (   string s   integer i  int[] i array )  {  return get string value ( s )   +  get string value ( i )   +  get string value ( i array )  ;   }   }   ;   }  
private void   (  )  {   file output stream fos = null ;  try  {  fos = new  secure file output stream (    ping file )  ;  fos . write (  data helper . getascii (  long . to string (  system . current time millis (  )  )  )  )  ;   }  catch  (  io exception ioe )   {  if  (  !    error logged )   {   log log =    router . get context (  )  . log manager (  )  . get log (  mark liveliness . class )  ;  log . log always (  log . warn " error writing to ping file "  +     ping file  +  ": " +  ioe )  ;     error logged = true ;   }   }  finally  {  if  ( fos  !  =  null )  try  {  fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath ( "script / insert - script - with - comments . sql" )  )  ;  script . execute (  )  ;  assert that 
public int   (  )  {  return count ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . range ( 1 10 )  . to list ( 4 )  . to flowable (  )  . test (  )  . assert result (  arrays . as list ( 1 2 3 4 5 6 7 8 9 10 )  )  ;   }  
public static void   (  string args[] )  {  if  ( args . length  <  1 )   {   system . err . println ( " usage:  test swarm my dest file [peer dest file ]*" )  ;  return ;   }  i2p app context ctx = new i2p app context (  )  ;   string files[] = new  string[args . length  -  1] ;   system . arraycopy ( args 1 files 0 files . length )  ;   test swarm swarm = new  test swarm ( ctx args[0] files )  ;  swarm . startup (  )  ;   }  
public   (  flowable < t >  source  function <  ?  super  flowable < t >   ?  extends  publisher <  ?  extends r >  >  selector int prefetch boolean delay error )  {  super ( source )  ;  this . selector = selector ;  this . prefetch = prefetch ;  this . delay error = delay error ;   }  
private byte[]   ( byte data[]  private key target private key  set <  session tag >  found tags  session key used key  session key found key )  throws  data format exception  {  if  ( data  =  =  null )   {  return null ;   }  else if  ( data . length  <  514 )   {  return null ;   }  byte elg encr[] = new byte[514] ;  if  ( data . length  >  514 )   {   system . arraycopy ( data 0 elg encr 0 514 )  ;   }  else  {   system . arraycopy ( data 0 elg encr 514  -  data . length data . length )  ;   }  byte elg decr[] =    context . el gamal engine (  )  . decrypt ( elg encr target private key )  ;  if  ( elg decr  =  =  null )   {  return null ;   }  int offset = 0 ;  byte key[] = new byte[ session key . keysize   bytes] ;   system . arraycopy ( elg decr offset key 0  session key . keysize   bytes )  ;  offset +  =  session key . keysize   bytes ;  used key . set data ( key )  ;  byte[] preiv =  simple byte cache . acquire ( 32 )  ;   system . arraycopy ( elg decr offset preiv 0 32 )  ;  offset +  = 32 ;  byte[] iv = half hash ( preiv )  ;   simple byte cache . release ( preiv )  ;     context . random (  )  . harvester (  )  . feed entropy ( " elg / aes" elg decr offset elg decr . length  -  offset )  ;  byte aes decr[] = decryptaes block ( data 514 data . length  -  514 used key iv null found tags found key )  ;   simple byte cache . release ( iv )  ;  return aes decr ;   }  
public   (  string name  string description int members )  {  this . name = name ;  this . description = description ;  this . members = members ;   }  
public   (  string name )  {     name = name ;   }  
public   (  cursor c )  {  m id = c . get long ( column   id )  ;  m flag loaded = c . get int ( column   flag   loaded )  ;  m server id = c . get string ( column   server   id )  ;   }  
int   (  )  {  return    total comments sent ;   }  
public static boolean   (  context context )  {  try  {  return new  policy service proxy ( context )  . can disable camera (  )  ;   }  catch  (   remote exception e )   {   }  return false ;   }  
private static void   (  store remote store  mailbox old mailbox  email content .  message old message )  throws  messaging exception  {  if  ( old mailbox . m type  !  =   mailbox . type   trash )   {  return ;   }   folder remote trash folder = remote store . get folder ( old mailbox . m server id )  ;  if  (  ! remote trash folder . exists (  )  )   {  return ;   }  remote trash folder . open (  open mode . read   write )  ;  if  ( remote trash folder . get mode (  )   !  =   open mode . read   write )   {  remote trash folder . close ( false )  ;  return ;   }   message remote message = remote trash folder . get message ( old message . m server id )  ;  if  ( remote message  =  =  null )   {  remote trash folder . close ( false )  ;  return ;   }  remote message . set flag (  flag . deleted true )  ;  remote trash folder . expunge (  )  ;  remote trash folder . close ( false )  ;   }  
private static void   (  context context  account account  store remote store boolean manual sync )  throws  messaging exception  {   traffic stats . set thread stats tag (  traffic flags . get sync flags ( context account )  )  ;   string[] account id args = new  string[] {  long . to string ( account . m id )  }  ;  process pending deletes synchronous ( context account remote store account id args )  ;  process pending uploads synchronous ( context account remote store account id args manual sync )  ;  process pending updates synchronous ( context account remote store account id args )  ;   }  
byte   ( final int sextet )  {  return  ( byte ) alphabet[sextet] ;   }  
@ test public void   (  )  {   test subscriber <  long >  ts = new  test subscriber <  long >  (  )  {  @ override public void on next (   long t )  {  super . on next ( t )  ;  if  ( t  =  =  5l )   {  cancel (  )  ;  on complete (  )  ;   }   }   }   ; 
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . distinct ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return null ;   }   }   )  . blocking subscribe (  )  ;   }  
private void   ( final  uri uri final  string message id final  content values values )  {  if  (  ! uri . get boolean query parameter ( is   uiprovider false )  )   {  notifyui conversation ( uri )  ;   }  notifyui message ( message id )  ;  if  ( values . contains key (  message columns . flag   read )  || values . contains key (  message columns . mailbox   key )  )   {  final  cursor c = query (  message . content   uri . build upon (  )  . append encoded path ( message id )  . build (  )  message   keys   projection null null null )  ;  if  ( c  !  =  null )   {  try  {  if  ( c . move to first (  )  )   {  notifyui folder ( c . get long ( message   keys   mailbox   key   column )  c . get long ( message   keys   account   key   column )  )  ;   }   }  finally  {  c . close (  )  ;   }   }   }   }  
@ override public boolean   (  )  {  return false ;   }  
protected   (  string id int in sample rate int in channels int out sample rate int out channels )  throws io exception  {  this . id = id ;  if  ( in channels  !  =  1 && in channels  !  =  2 )   {   logger . println ( "invalid in channels "  +  in channels )  ;  throw new io exception ( "invalid in channels "  +  in channels )  ;   }  if  ( out channels  !  =  1 && out channels  !  =  2 )   {   logger . println ( " sample rate converter: invalid out channels "  +  out channels )  ;  throw new io exception ( " sample rate converter: invalid in channels "  +  in channels )  ;   }  if  ( in sample rate  <  =  0 )   {   logger . println ( " sample rate converter: invalid input sample rate "  +  in sample rate )  ;  throw new io exception ( " sample rate converter: "  +  " invalid input sample rate "  +  in sample rate )  ;   }  if  ( out sample rate  <  =  0 )   {   logger . println ( " sample rate converter: invalid output sample rate "  +  out sample rate )  ;  throw new io exception ( " sample rate converter: "  +  " invalid output sample rate "  +  out sample rate )  ;   }  this . in sample rate = in sample rate ;  this . in channels = in channels ;  this . out sample rate = out sample rate ;  this . out channels = out channels ;  if  ( in sample rate  >  out sample rate )   {  low pass filter = new  low pass filter ( id in sample rate in channels )  ;   }  else  {  low pass filter = new  low pass filter ( id out sample rate out channels )  ;   }  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " new  sample  converter: from "  +  in sample rate  +  " / " +  in channels +  " to " +  out sample rate +  " / " +  out channels )  ;   }   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . set once ( this d )  )   {  actual . on subscribe ( this )  ;   }   }  
public static  list <  test result >    ( final int lane final int tile final float[] xy pos final int[] xy qseq )  {  final  array list <  test result >  results = new  array list <  test result >  (  )  ;  for  ( int i = 0 ;  i  <  xy pos . length ;  i +  = 2 )   {  results . add ( new  test result ( lane tile xy pos[i] xy pos[i  +  1] xy qseq[i] xy qseq[i  +  1] )  )  ;   }  return results ;   }  
@ test public void   (  )  throws  exception  {  h . execute ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  ;  h . execute ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  ;  try  (  result iterator <  something >  i
@ override public  string   (  )  {   string builder buf = new  string builder ( 1024 )  ;  buf . append ( " < div class = \"debug   container buckets\" > " )  ;  buf . append ( " < hr >  < b >  bucket set rooted on: <  / b >  " )  . append (    us . to s
private   (  object value )  {  this . value = value ;   }  
@ test ( expected =  runtime exception . class )  @ ignore ( " subscribers can't throw" )  public void   (  )  {   rx java plugins . set error handler ( new  consumer <  throwable >  (  )  {  int calls ;  @ override public void accept (   throwable e )  {
@ test public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic reference <  throwable >  caught error = new  atomic reference <  throwable >  (  )  ;   observable <  long >  o =  
public  string   (  )  {  return pub sub service . get serviceid (  )  ;   }  
@ test public void   (  )  {   connectable observable <  integer >  co =  observable . range ( 1 2 )  . replay (  )  ;  try  {  co . connect ( new  consumer <  disposable >  (  )  {  @ override public void accept (   disposable t )  throws  exception  {  
@ override public void   (  )  {  pp1 . on error ( ex )  ;   }  
public  list <  string >    (  )  {  return answers ;   }  
public  string   (  )  {  return "xep - 0327:  rayo" ;   }  
public void   (  observable o  object arg )  {  paint ( g )  ;   }  
public void   (  certificate store configuration configuration )  {  if  ( this . identity store configuration . equals ( configuration )  )   {   log . debug ( " ignoring identity store configuration change request  ( to ' {  } ' ) : listener already in this state . " configuration )  ;  return ;   }   log . debug ( " changing identity store configuration from ' {  } ' to ' {  } ' . " this . identity store configuration configuration )  ;  this . identity store configuration = configuration ;  restart (  )  ;   }  
public boolean   (  )  {  return count active peers (  )   <  get max connections (  )  ;   }  
private static  projection map   (  )  {  if  ( s folder list map  =  =  null )   {  s folder list map =  projection map . builder (  )  . add (  base columns .    id  mailbox columns .    id )  . add ( ui provider .  folder columns . persistent   id  mailbox columns . server   id )  . add ( ui provider .  folder columns . uri uri with id ( "uifolder" )  )  . add ( ui provider .  folder columns . name "display name" )  . add ( ui provider .  folder columns . has   children  mailbox columns . flags  +  "&"  +   mailbox . flag   has   children )  . add ( ui provider .  folder columns . capabilities folder   capabilities )  . add ( ui provider .  folder columns . sync   window "3" )  . add ( ui provider .  folder columns . conversation   list   uri uri with id ( "uimessages" )  )  . add ( ui provider .  folder columns . child   folders   list   uri uri with id ( "uisubfolders" )  )  . add ( ui provider .  folder columns . unread   count  mailbox columns . unread   count )  . add ( ui provider .  folder columns . total   count total   count )  . add ( ui provider .  folder columns . refresh   uri uri with id ( query   uirefresh )  )  . add ( ui provider .  folder columns . sync   status  mailbox columns . ui   sync   status )  . add ( ui provider .  folder columns . last   sync   result  mailbox columns . ui   last   sync   result )  . add ( ui provider .  folder columns . type folder   type )  . add ( ui provider .  folder columns . icon   res   id folder   icon )  . add ( ui provider .  folder columns . load   more   uri uri with id ( "uiloadmore" )  )  . add ( ui provider .  folder columns . hierarchical   desc  mailbox columns . hierarchical   name )  . add ( ui provider .  folder columns . parent   uri "case when "  +   mailbox columns . parent   key  +  " = " +   mailbox . no   mailbox +  " then null else " +  uri with column ( "uifolder"  mailbox columns . parent   key )  +  " end" )  . add ( ui provider .  folder columns . unread   senders " ( select group   concat ( "  +   message columns . from   list  +  " )  from " +  " ( select " +   message columns . from   list +  " from " +   message . table   name +  " where " +   message columns . mailbox   key +  " = " +   mailbox . table   name +  " . " +   mailbox columns .    id +  " and " +   message columns . flag   read +  " = 0" +  " group by " +   message columns . from   list +  " order by " +   message columns . timestamp +  " desc )  ) " )  . build (  )  ;   }  return s folder list map ;   }  
private void   (  )  {   string url =    context . port mapper (  )  . get consoleurl (  )  ;  try  {  i2p desktop . browse ( url )  ;   }  catch  (   browse exception e1 )   {  log . log (  log . warn " failed to open browser ! " e1 )  ;   }   }  
private synchronized int   (  inet address addr )  {  byte[] v6vec = addr . get address (  )  ;  if  ( v6vec . length  =  =  4 )   {  byte[] t = new byte[16] ;   system . arraycopy ( v6vec 0 t 12 4 )  ;  v6vec = t ;   }  byte[] buf = new byte[2 * max   record   length] ;  int[] x = new int[2] ;  int offset = 0 ;     check   mtime (  )  ;  for  ( int depth = 127 ;  depth  >  =  0 ;  depth -  -  )   {  read node ( buf x offset )  ;  int bnum = 127  -  depth ;  int idx = bnum  >  >  3 ;  int b   mask = 1  <  <   ( bnum & 7 ^ 7 )  ;  if  (  ( v6vec[idx] & b   mask )   >  0 )   {  if  ( x[1]  >  =  database segments[0] )   {  last   netmask = 128  -  depth ;  return x[1] ;   }  offset = x[1] ;   }  else  {  if  ( x[0]  >  =  database segments[0] )   {  last   netmask = 128  -  depth ;  return x[0] ;   }  offset = x[0] ;   }   }  throw new  invalid database exception ( " error seeking country while searching for "  +  addr . get host address (  )  )  ;   }  
 string   (  )  {  return id ;   }  
@ override public boolean   (  )  {  if  ( iterator notification  !  =  null && iterator notification . is on error (  )  )   {  throw  exception helper . wrap or throw ( iterator notification . get error (  )  )  ;   }  if  ( iterator notification  =  = 
public   (  boolean authenticated )  {  this . authenticated = authenticated ;   }  
@ override public  unmarshaller   (  )  {  try  {   unmarshaller unmarshaller = jaxb   context . create unmarshaller (  )  ;  unmarshaller . set schema ( schema )  ;  return unmarshaller ;   }  catch  (  jaxb exception ex )   {  throw new  httpx exception
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts = pp . timeout (  functions . jus
@ override protected void   (  subscriber <  ?  super u >  s )  {   buffer boundary subscriber < t u  open  close >  parent = new  buffer boundary subscriber < t u  open  close >  ( s buffer open buffer close buffer supplier )  ;  s . on subscribe ( paren
@ test @ ignore ( " publishers should not throw" )  public void   (  )  {   flowable <  string >  test observable =  flowable . unsafe create ( new  publisher <  string >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  string >  t1 
@ override protected void   (  subscriber <  ?  super  timed < t >  >  s )  {  source . subscribe ( new  time interval subscriber < t >  ( s unit scheduler )  )  ;   }  
private boolean   (  signature signature  simple data structure hash  signing public key verifying key )  {  if  ( signature . get type (  )   !  =   sig type . dsa   sha1 )  throw new  illegal argument exception ( " bad sig type "  +  signature . get type (  )  )  ;  if  ( verifying key . get type (  )   !  =   sig type . dsa   sha1 )  throw new  illegal argument exception ( " bad key type "  +  verifying key . get type (  )  )  ;  long start =    context . clock (  )  . now (  )  ;  try  {  byte[] sigbytes = signature . get data (  )  ;  byte rbytes[] = new byte[20] ;  byte sbytes[] = new byte[20] ;  for  ( int x = 0 ;  x  <  40 ;  x +  +  )   {  if  ( x  <  20 )   {  rbytes[x] = sigbytes[x] ;   }  else  {  sbytes[x  -  20] = sigbytes[x] ;   }   }   big integer s = new  native big integer ( 1 sbytes )  ;   big integer r = new  native big integer ( 1 rbytes )  ;   big integer y = new  native big integer ( 1 verifying key . get data (  )  )  ;   big integer w ;  try  {  w = s . mod inverse (  crypto constants . dsaq )  ;   }  catch  (   arithmetic exception ae )   {     log . warn ( "mod inverse (  )  error" ae )  ;  return false ;   }  byte data[] = hash . get data (  )  ;   native big integer bi = new  native big integer ( 1 data )  ;   big integer u1 = bi . multiply ( w )  . mod (  crypto constants . dsaq )  ;   big integer u2 = r . multiply ( w )  . mod (  crypto constants . dsaq )  ;   big integer modval =  crypto constants . dsag . mod pow ( u1  crypto constants . dsap )  ;   big integer modmulval = modval . multiply ( y . mod pow ( u2  crypto constants . dsap )  )  ;   big integer v =  ( modmulval )  . mod (  crypto constants . dsap )  . mod (  crypto constants . dsaq )  ;  boolean ok = v . compare to ( r )   =  =  0 ;  long diff =    context . clock (  )  . now (  )   -  start ;  if  ( diff  >  1000 )   {  if  (    log . should log (  log . warn )  )     log . warn ( " took too long to verify the signature  ( "  +  diff  +  "ms ) " )  ;   }  return ok ;   }  catch  (   runtime exception e )   {     log . log (  log . crit " error verifying the signature" e )  ;  return false ;   }   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ override public void   ( t t )  {  if  ( s  =  =   subscription helper . cancelled )   {  return ;   }  t v = value ;  if  ( v  =  =  null )   {  value = t ;   }  else  {  try  {  value =  object helper . require non null ( reducer . apply ( v t )  " th
  ( int capacity hint )  {  this . buffer = new  array list < t >  (  object helper . verify positive ( capacity hint "capacity hint" )  )  ;   }  
@ deprecated public void   (  )  {   system . out . println ( " list size "  +  size )  ;   system . out . println ( first . print (  )  )  ;   }  
public void   (  )  {   mailbox original = build test mailbox ( "server id" "display name for mailbox" )  ;   parcel p =  parcel . obtain (  )  ;  original . write to parcel ( p 0 )  ;  p . set data position ( 0 )  ;   mailbox unparcelled =  mailbox . creator . create from parcel ( p )  ;   more asserts . assert equals ( original . get hashes (  )  unparcelled . get hashes (  )  )  ;   mailbox phony = build test mailbox ( "different id" "display name for mailbox" )  ;  assert false (  arrays . equals ( phony . get hashes (  )  unparcelled . get hashes (  )  )  )  ;  p . recycle (  )  ;   }  
  (  merge with observer < t >  parent )  {  this . parent = parent ;   }  
@ override protected void   ( final  single observer <  ?  super t >  s )  {  source . subscribe ( new  resume main single observer < t >  ( s next function )  )  ;   }  
@ before test void   (  )  throws io exception  {   file output   data   path = io util . create temp dir ( " fix vcf header test" null )  ;  output   data   path . delete on exit (  )  ;  final  file test data path = new  file ( "testdata / picard / vcf 
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . just ( 1 2 3 4 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single element ( 
private void   (  skip levels < k v >  l  set <  skip levels < k v >  >  lvl set )  {  if  ( bf . log . should log (  log . debug )  )  bf . log . debug ( "gal "  +  l . print (  )  )  ;   skip levels < k v >  cur = l ;  while  ( cur  !  =  null && lvl set . add ( cur )  )   {  if  ( bf . log . should log (  log . debug )  )  bf . log . debug ( " adding "  +  cur . print (  )  )  ;  if  (  ! cur . equals ( this )  && cur . key (  )   =  =  null && bf . log . should log (  log . warn )  )  bf . log . debug ( " null key !  !  !  "  +  cur . print (  )  )  ;  cur = cur . levels[0] ;   }  for  ( int i = 1 ;  i  <  l . levels . length ;  i +  +  )   {   skip levels < k v >  lv = l . levels[i] ;  if  ( lv  !  =  null &&  ! lvl set . contains ( lv )  )  get all levels ( lv lvl set )  ;   }   }  
public int   (  )  {  return    current . size (  )   +     previous . size (  )  ;   }  
public static void   (  string[] args )  {   duplication metrics m = new  duplication metrics (  )  ;  m . read   pairs   examined =  integer . parse int ( args[0] )  ;  m . read   pair   duplicates =  integer . parse int ( args[1] )  ;  m . calculate derived fields (  )  ;   system . out . println ( " percent  duplication: "  +  m . percent   duplication )  ;   system . out . println ( " est .   library  size : "  +  m . estimated   library   size )  ;   system . out . println (  )  ;   system . out . println ( "x  seq\tx  unique" )  ;  for  (   histogram .  bin <  double >  bin : m . calculate roi histogram (  )  . values (  )  )   {   system . out . println ( bin . get id (  )   +  "\t"  +  bin . get value (  )  )  ;   }   }  
public   ( int pipe size )  {  super ( pipe size )  ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    ( final  action on terminate )  {  return do on each (  functions . empty consumer (  )
private void   (  )  {  if  ( savede tag  !  =  null )   {  if  ( compressing )   {  http response . set header ( etag   header savede tag  +  ' - '  +  compressed content encoding )  ;   }  else  {  http response . set header ( etag   header savede tag )  ;   }   }   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
  (  string src name  string consol fun  string text boolean included in graph )  {  super ( text )  ;  this . src name = src name ;  this . consol fun = consol fun ;  this . included in graph = included in graph ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . start with array (  )  . test (  )  . assert result ( 1 )  ;   }  
public synchronized boolean   (  )  {  return is new ;   }  
@ test ( data provider = "  sets data provider" )  public void test umi (  list <  string >  umis  list <  string >  assigned umi final  list <  boolean >  is duplicate final int edit distance to join )  {   umi aware mark duplicates with mate cigar teste
@ override public  single <  ?  extends  integer >    (  integer v )  throws  exception  {  return  single . just ( v )  ;   }  
public void   ( final int offset final int depth )  {  if  ( offset  >  =  0 && offset  <  this . depths . length && this . depths[offset]  <   integer . max   value  -  depth )   {  this . depths[offset] +  = depth ;   }   }  
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;   consumer <  object >  cons = new  consumer <  object >  (  )  {  @ override public void accept (   object v )  throws  exception  {  list . add ( v )  ;  
protected  string[]   (  )  {  return null ;   }  
@ non null @ override public  worker   (  )  {  final  worker w =  schedulers . computation (  )  . create worker (  )  ;  return new  worker (  )  {  @ override public void dispose (  )  {  w . dispose (  )  ;   }  @ override public boolean is disposed (
private int   (  )  {   service service ;  synchronized  ( lock )   {  if  (  ! isnat present (  )  || thinks we are double natted )  return  - 1 ;  service =    service ;   }   action getip = service . get action ( " get link layer max bit rates" )  ;  if  ( getip  =  =  null ||  ! getip . post control action (  )  )  return  - 1 ;   argument a = getip . get output argument list (  )  . get argument ( " new downstream max bit rate" )  ;  if  ( a  =  =  null )  return  - 1 ;  try  {  return  integer . parse int ( a . get value (  )  )  ;   }  catch  (   number format exception nfe )   {  return  - 1 ;   }   }  
@ override public  message[]   (  )  throws  messaging exception  {  check open (  )  ;  try  {  handle untagged responses ( m connection . execute simple command (  imap constants . expunge )  )  ;   }  catch  (  io exception ioe )   {  throw io exceptio
private static  observer <  string >    (  )  {  return new  default observer <  string >  (  )  {  @ override public void on complete (  )  {   }  @ override public void on error (   throwable e )  {  throw new  safe observer test exception ( "on error fail" )  ;   }  @ override public void on next (   string args )  {   }   }   ;   }  
@ override public boolean   (  )  {  return cache . is empty (  )  ;   }  
private static void   (  session object session object  request wrapper request )  {   string str = request . get parameter ( sort )  ;  if  ( str  =  =  null )  str = request . get parameter ( current   sort )  ;  if  ( str  !  =  null && valid   sorts . contains ( str )  )   {   sort order order ;  if  ( str . starts with ( " - " )  )   {  order =  sort order . up ;  str = str . substring ( 1 )  ;   }  else  {  order =  sort order . down ;   }   folder <  string >  folder = get current folder ( session object request )  ;  if  ( folder  !  =  null )  folder . set sort by ( str order )  ;   }   }  
@ override public void   (  string column label  string x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public  headers   (  )  {   byte array output stream headers output = get headers stream (  )  ;  if  ( headers output  =  =  null )   {  return null ;   }  byte[] out = headers output . to byte array (  )  ;   byte array input stream input = new  byte array input stream ( out )  ;  if  ( input . available (  )   =  =  0 )   {  return null ;   }  if  ( log . is debug enabled (  )  )   {  log . debug ( " new headers: "  +  new  string ( out  standard charsets . utf   8 )  )  ;   }  return marshaller . unmarshall headers ( input )  ;   }  
public void   ( boolean is transient )  {  this . is transient = is transient ;   }  
@ test public void   (  )  throws io exception  {  merged with null . close (  )  ;  verify ( stream1 )  . close (  )  ;  verify ( stream2 )  . close (  )  ;  verify ( stream3 )  . close (  )  ;   }  
@ override public  string   (  )  {  return " deleting a  user" ;   }  
public   (  json format json format )  {  try  {  final jaxb context context = jaxb context . new instance ( org . openrepose . filters . versioning . schema .  object factory . class org . openrepose . filters . versioning . config .  object factory . class )  ;   string json xslt = xslt   dir  +   (  (  json format . compute  =  =  json format )   ?  json   xslt   compute : json   xslt   identity )  ;  final  templates json xslt templates =  content transformer . parse xslt ( new  stream source ( get class (  )  . get resource as stream ( json xslt )  )  )  ;  xml stream transform = new  jaxb to stream transform <  >  ( context )  ;  json stream transform = new  xslt to stream transform <  >  ( json xslt templates context )  ;   }  catch  (   exception ex )   {  throw new  power api context exception ( " failed to build transformation processors for response marshalling .   reason: "  +  ex . get message (  )  ex )  ;   }   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . first ( 2 )  . to observable
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 1 )  ;   disposable d =  disposables . empty (  )  ;   queue drain subscriber <  integer  integer  integer >  qd = create ordered ( ts d )  ;  ts . on s
public void   (  )  throws sql exception  {  cstmt . cancel (  )  ;   }  
@ override @ visible for testing public  message[]   (  string[] uids  message retrieval listener listener )  throws  messaging exception  {  if  ( uids  =  =  null )   {  uids = search for uids ( "1:* not deleted" )  ;   }  return get messages internal (
private static byte[]   ( int cmd  string digest )  {  byte addr[] = digest . get bytes (  )  ;  byte[] data = new byte[7  +  addr . length] ;  data[0] =  ( byte ) 5 ;  data[1] =  ( byte ) cmd ;  data[2] =  ( byte ) 0 ;  data[3] =  ( byte ) 0x3 ;  data[4] =  ( byte ) addr . length ;   system . arraycopy ( addr 0 data 5 addr . length )  ;  data[data . length  -  2] =  ( byte ) 0 ;  data[data . length  -  1] =  ( byte ) 0 ;  return data ;   }  
public  collection <  domain pair >    (  )  {   cluster task task = get remote session task (  remote session task .  operation . get outgoing domain pairs )  ;  return  (  collection <  domain pair >  ) do synchronous cluster task ( task )  ;   }  
@ test public void   (  )  throws io exception  {   assert . assert equals ( missing mate test helper ( true )  0 )  ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   observable . just ( 1 )  . buffer ( 1  time unit . seconds  schedulers . single (  )  10 new  callable <  collection <  integer >  >  (  )  {  @ override public  collection <  integer >  
private static void   (  string args[] )  {   random source . get instance (  )  . next boolean (  )  ;  try  {   thread . sleep ( 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  int runs = 200 ;   collection <  sig type >  to test ;  if  ( args . length  >  0 )   {  to test = new  array list <  sig type >  (  )  ;  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )   {   sig type type =  sig type . parse sig type ( args[i] )  ;  if  ( type  !  =  null )  to test . add ( type )  ;  else  system . out . println ( " unknown type: "  +  args[i] )  ;   }  if  ( to test . is empty (  )  )   {   system . out . println ( " no types to test" )  ;  return ;   }   }  else  {  to test =  arrays . as list (  sig type . values (  )  )  ;   }  for  ( int j = 0 ;  j  <  2 ;  j +  +  )   {  for  (   sig type type : to test )   {  if  (  ! type . is available (  )  )   {   system . out . println ( " skipping unavailable: "  +  type )  ;  continue ;   }  try  {   system . out . println ( " testing "  +  type )  ;  test sig ( type runs )  ;   }  catch  (   general security exception e )   {   system . out . println ( "error testing "  +  type )  ;  e . print stack trace (  )  ;   }   }  runs = 1000 ;   }   }  
public static void   (  bit matrix matrix  string format  output stream stream  matrix to image config config )  throws io exception  {   buffered image image = to buffered image ( matrix config )  ;  if  (  !  imageio . write ( image format stream )  )   {  throw new io exception ( " could not write an image of format "  +  format )  ;   }   }  
@ override public boolean   ( t t )  {  if  ( done )   {  return false ;   }  long retries = 0 ;  for  (  ;   ;   )   {  r v ;  try  {  v =  object helper . require non null ( mapper . apply ( t )  " the mapper returned a null value" )  ;   }  catch  (   
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  list composite disposable cd = new  list composite disposable (  )  ;  final  disposable d1 =  disposables . empty (  )  ;  cd . add ( d
public void   (  )  {  just1 . group by ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return null ;   }   }   )  . blocking subscribe (  )  ;   }  
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  actual . on next ( false )  ;  actual . on complete (  )  ;   }   }  
@ override public void   (  servlet config cfg )  throws  servlet exception  {  super . init ( cfg )  ;  if  ( cfg . get init parameter ( init   param   version )   !  =  null )  this . version =  integer . parse int ( cfg . get init parameter ( init   pa
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . sample ( 1  time unit . seconds )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public  string   ( final  variant context ctx )  {  final double fs = ctx . get attribute as double ( "fs" 0 )  ;  return  ( fs  >  max phred scalep value )   ?  " strand bias" : null ;   }  
public   (  observable source < t >  source  predicate <  ?  super t >  predicate )  {  this . source = source ;  this . predicate = predicate ;   }  
public   (  router context ctx )  {  super ( ctx )  ;   }  
private void   (  element elem  string sessionid )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   session   agents )  ;  pstmt . set string ( 1 sessionid )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   string agentjid = rs . get string ( 2 )  ;   string join time = rs . get string ( 3 )  ;   string left time = rs . get string ( 4 )  ;  final  element agent element = elem . add element ( "agent" )  ;  agent element . add element ( "agentjid" )  . set text ( agentjid )  ;  if  (  model util . has length ( join time )  )   {  agent element . add element ( "join time" )  . set text ( utc   format . format ( new  date (  long . parse long ( join time )  )  )  )  ;   }  if  (  model util . has length ( left time )  )   {  agent element . add element ( "left time" )  . set text ( utc   format . format ( new  date (  long . parse long ( left time )  )  )  )  ;   }   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
private boolean   (  big integer ip )  {  synchronized  (    singlei pv6 blocklist )   {  return    singlei pv6 blocklist . get ( ip )   !  =  null ;   }   }  
public void   ( i2np message message )  {     success time = get context (  )  . clock (  )  . now (  )   -   (  (  delivery status message ) message )  . get arrival (  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ test public void   (  )  {   function3 <  string  integer int[]  string >  zipr = get concat string integer int array zipr (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;   observable <  string >  w =  observable . zip ( 
@ test public void   (  )  {   flowable . range ( 1 5 )  . observe on (  schedulers . single (  )  )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return v % 2  =  =  0 ;   }   }   
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . just ( 1 1 )  . reduce ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  {  return null ;  
public void   ( int bonus )  {     capacity bonus = bonus ;   }  
public   ( boolean rev  string lang i2p snark servlet servlet )  {  super ( rev lang )  ;  this . servlet = servlet ;   }  
@ override public void   (  throwable t )  {  r p ;  try  {  p =  object helper . require non null ( on error mapper . apply ( t )  " the on error publisher returned is null" )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  a
public int   (  )  {  final  default connection provider default connection provider = get default connection provider (  )  ;  return default connection provider  =  =  null  ?  0 : default connection provider . get min connections (  )  ;   }  
public final static boolean   (  string name )  {  if  (  string util . has data ( name )   =  =  false )  return false ;   string lower name = name . to lower case (  locale . us )  ;  return lower name . ends with ( "xml" )  ;   }  
@ override public void   (  )  {  transactional   handles . remove ( handle )  ;   transaction synchronization manager . unbind resource ( db )  ;   }  
public   (  tunnel creator config config )  {     config = config ;     handler = new  fragment handler (    context  test receiver . this )  ;     received = new  array list < i2np message >  ( 1000 )  ;   }  
@ test ( data provider = "  data provider" )  public void test adapter in all read positions ( final int read length )  {  final int min adapter length = 6 ;  for  (  final  illumina adapter pair adapter pair :  illumina adapter pair . values (  )  )   { 
public   (  string message  throwable throwable )  {  super ( message throwable )  ;   }  
public void   (  http session binding event event )  {  if  ( log . should debug (  )  )  log . debug ( " session unbound: "  +  event . get session (  )  . get id (  )  )  ;  pop3 mail box mbox = mailbox ;  if  ( mbox  !  =  null )   {  mbox . destroy (  )  ;  mailbox = null ;   }   }  
public   (  localmuc room room muc role role )  {  super ( room )  ;  this . role = role ;  this . nickname = role . get nickname (  )  ;   }  
public void   ( boolean allow to discover locked rooms )  {  this . allow to discover locked rooms = allow to discover locked rooms ;  muc persistence manager . set property ( chat service name "discover . locked"  boolean . to string ( allow to discover locked rooms )  )  ;   }  
@ test public void   (  )  {  assert false (  observable . error ( new  test exception (  )  )  . test (  )  . assert failure (  test exception . class )  . is disposed (  )  )  ;   }  
private static  packet error   (  iterable <  string >  groups )  {   set <  string >  set = new  hash set <  >  (  )  ;  for  (   string group : groups )   {  if  (  ! set . add ( group )  )   {  return new  packet error (  packet error .  condition . bad   request  packet error .  type . modify " item contains duplicate groups" )  ;   }  if  ( group . is empty (  )  )   {  return new  packet error (  packet error .  condition . not   acceptable  packet error .  type . modify " group is of zero length" )  ;   }   }  return null ;   }  
@ test public void   (  )  throws  interrupted exception  {  final int num   loops = 1 ;  for  ( int j = 0 ;  j  <  num   loops ;  j +  +  )   {  final int num retries =  flowable . buffer size (  )  * 2 ;  for  ( int i = 0 ;  i  <  400 ;  i +  +  )   {  
public   (  router context ctx  kademlia network database facade facade )  {  super ( ctx )  ;     log = ctx . log manager (  )  . get log (  expire leases job . class )  ;     facade = facade ;   }  
@ override public boolean   ( long time  time unit unit )  {  return cache . lock ( key unit . to millis ( time )  )  ;   }  
public   ( x509 encoded key spec spec )  throws  invalid key spec exception  {  this ( new  eddsa public key spec ( decode ( spec . get encoded (  )  )   eddsa named curve table . get by name (  eddsa named curve table . curve   ed25519   sha512 )  )  )  ;   }  
private final static boolean   (  inet address addr )  {  if  ( use   loopback   addr  =  =  false )   {  if  ( addr . is loopback address (  )   =  =  true )  return false ;   }  if  ( use   only   ipv4   addr  =  =  true )   {  if  ( addr instanceof  inet6 address )  return false ;   }  if  ( use   only   ipv6   addr  =  =  true )   {  if  ( addr instanceof  inet4 address )  return false ;   }  return true ;   }  
public int   (  )  {  return channels ;   }  
public void   ( i2p session session  string message  throwable error )  {     l . error occurred ( session message error )  ;   }  
public  string   (  )  {  return    filename ;   }  
public void   (  string key )  {  if  ( key  !  =  null )     key = key . trim (  )  ;   }  
private   ( int i  string msg )  {  id = i ;  message = msg ;   }  
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
public boolean   (  )  {  return downloaded ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . replay ( null 1  time unit . seconds  schedulers . single (  )  )  ;   }  
public void   (  object element )  {  list . add ( element )  ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts =  flowable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  flowable <  object >  >  (  )
public synchronized double   (  )  {  if  (  (    last total value  !  =  0 )  &&  (    extreme total value  !  =  0 )  )  return    last total value  /     extreme total value ;  return 0 . 0d ;   }  
@ test public void   (  )  {   flowable .  <  integer > empty (  )  . parallel (  )  . sorted (  functions .  <  integer > natural comparator (  )  )  . test (  )  . assert result (  )  ;   }  
public void   ( long ms to wait )  {  schedule (    connection event ms to wait )  ;   }  
public   (  )  {  super ( 1 )  ;   }  
@ override public void   (  )  {   subscription helper . cancel ( this )  ;   }  
public static  string   ( x509 certificate cert  string type )  {  x500 principal p = cert . get subjectx500 principal (  )  ;  return get value ( p type )  ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  userjid =  ( jid )  externalizable util . get instance (  )  . read serializable ( in )  ;  name =  externalizable util . get instance (  )  . read safeutf 
void   ( int count )  {  loop count = count ;   }  
@ override public void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;  s . cancel (  )  ;  if  ( get and increment (  )   =  =  0 )   {  queue . clear (  )  ;   }   }   }  
@ override public void   ( t t )  {  long now = scheduler . now ( unit )  ;  long last = last time ;  last time = now ;  long delta = now  -  last ;  actual . on next ( new  timed < t >  ( t delta unit )  )  ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   string value = h . in transaction ( handle  -  >   {  handle . execute ( "insert into something  ( id  name )  values  ( 1  ' brian' ) " )  ;  return handle . cre
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  final x509 certificate valida =  keystore test utils . generate valid certificate (  )  ;  final x509 certificate validb =  keystore test utils . generate valid certificate (  )  ;  final x509 certificate i
public int   (  )  {  return    comm system facades . size (  )   -  1 ;   }  
@ test public void   (  )  {   properties props1 = new  properties (  )  ;  props1 . set property (  scheduler pool factory . purge   enabled   key "true" )  ;  props1 . set property (  scheduler pool factory . purge   period   seconds   key "abc" )  ;   
synchronized  string   (  )  {  return "locks = "  +  locks  +  "  " +  "unlocks = " +  unlocks +  "  " +  "delayed   locks = " +   ( locks  -  quick locks )  +  "  " +  "locked = " +  locked +  "  " +  "errors = " +  errors ;   }  
public static  list <  string >    (  collection < jid >  jids )  {   list <  string >  result = new  array list <  string >  (  )  ;  for  (  jid jid : jids )   {  if  ( jid . get resource (  )   =  =  null )  result . add ( jid . to barejid (  )  )  ;   }  return result ;   }  
public  perf async consumer   ( int count )  {  if  ( count  <  =  1000 )   {  while  ( get count (  )   !  =  0 )   {   }   }  else  {  try  {  await (  )  ;   }  catch  (   interrupted exception ex )   {  throw new  runtime exception ( ex )  ;   }   }  return this ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . empty (  )  . subscribe ( to )  ;  thrown . expect (  assertion error . class )  ;  thrown . expect message ( " no values" )  ;  to . ass
public void   (  string conference display name )  {  this . conference display name = conference display name ;   }  
@ override public  tuple mappers   (  string key column )  {  return set column ( key   column   tuple   index key column )  ;   }  
public static boolean   ( final  file basecall dir final int lane )  {  final  file lane dir = new  file ( basecall dir  illumina file util . long lane str ( lane )  )  ;  final  file[] cycle dirs = io util . get files matching regexp ( lane dir  illumina file util . cycle   subdirectory   pattern )  ;  if  ( cycle dirs  =  =  null )   {  return false ;   }  final  list <  file >  cbcls = new  array list <  >  (  )  ;   arrays . as list ( cycle dirs )  . for each ( cycle dir  -  >  cbcls . add all (  arrays . as list ( io util . get files matching regexp ( cycle dir "^"  +   illumina file util . long lane str ( lane )   +  "    ( \\d { 1 5 }  )  . cbcl$" )  )  )  )  ;  return cbcls . size (  )   >  0 ;   }  
private  tracker info   ( tc tracker tr  string info hash  string peerid long uploaded long downloaded long left  string event )  throws io exception  {   string builder buf = new  string builder ( 512 )  ;  buf . append ( tr . announce )  ;  if  ( tr . announce . contains ( " ? " )  )  buf . append ( '&' )  ;  else buf . append ( ' ? ' )  ;  buf . append ( "info   hash = " )  . append ( info hash )  . append ( "&peer   id = " )  . append ( peerid )  . append ( "&port = " )  . append ( port )  . append ( "&ip = " )  . append (    util . get ourip string (  )  )  . append ( " . i2p" )  . append ( "&uploaded = " )  . append ( uploaded )  . append ( "&downloaded = " )  . append ( downloaded )  . append ( "&left = " )  ;  if  ( left  >  =  0 )  buf . append ( left )  ;  else buf . append ( '1' )  ;  buf . append ( "&compact = 1" )  ;  if  (  ! event . equals ( no   event )  )  buf . append ( "&event = " )  . append ( event )  ;  buf . append ( "&numwant = " )  ;  boolean small = left  =  =  0 || event . equals ( stopped   event )  ||  ! coordinator . need outbound peers (  )  ;  if  ( small )  buf . append ( '0' )  ;  else buf . append (    util . get max connections (  )  )  ;   string s = buf . to string (  )  ;  if  (    log . should log (  log . info )  )     log . info ( " sending  tracker client request: "  +  s )  ;  tr . last request time =  system . current time millis (  )  ;  boolean fast =    fast unannounce && event . equals ( stopped   event )  ;  byte[] fetched =    util . get ( s true fast  ?   - 1 : 0 small  ?  128 : 1024 small  ?  1024 : 32 * 1024 )  ;  if  ( fetched  =  =  null )  throw new io exception ( " no response from "  +  tr . host )  ;  if  ( fetched . length  =  =  0 )  throw new io exception ( " no data from "  +  tr . host )  ;  if  ( fetched[0]  =  =  ' < ' )  throw new io exception ( error   got   html  +  " from "  +  tr . host )  ;   input stream in = new  byte array input stream ( fetched )  ;   tracker info info = new  tracker info ( in snark . getid (  )  snark . get info hash (  )  snark . get meta info (  )     util )  ;  if  (    log . should log (  log . info )  )     log . info ( " tracker client "  +  tr . host  +  " response: " +  info )  ;   string failure = info . get failure reason (  )  ;  if  ( failure  !  =  null )  throw new io exception ( " tracker "  +  tr . host  +  " responded with: " +  failure )  ;  tr . interval =  math . max ( min   tracker   announce   interval info . get interval (  )  * 1000l )  ;  return info ;   }  
@ test public void   (  )  {   flowable <  string >  skip =  flowable . just ( "one" "two" "three" )  . skip ( 2 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  skip . subscribe ( observer )  ;  verify ( observer never ( 
public void   (  string s )  {     console nonce = s  =  =  null  ?  null :  data helper . striphtml ( s )  ;   }  
public void   (  conference member member double[] spatial values )  {  if  ( cp . get input treatment (  )   !  =  null && cp . is recorder (  )   =  =  false )   {  return ;   }  synchronized  ( mix map )   {   hash map <  conference member double[] >  mixes to apply = mix map . get ( this )  ;  if  ( mixes to apply  =  =  null )   {  mixes to apply = new  hash map <  conference member double[] >  (  )  ;  mix map . put ( this mixes to apply )  ;   }  if  (  logger . log level  >  =   logger . log   info )   {  if  ( mixes to apply . get ( member )   !  =  null )   {   logger . println ( this  +  "  replacing mix for "  +  member )  ;   }   }  if  ( mixes to apply . put ( member spatial values )   !  =  null )   {  replaced +  +  ;   }   }   }  
public double   (  )  {  return lod genotype ;   }  
@ override public void   (  )  {  s . cancel (  )  ;   }  
public void   (  string contact )  {  if  (  ! email contacts . contains ( contact . trim (  )  )  )   {  email contacts . add ( contact . trim (  )  )  ;   jive globals . set property ( email   contacts prop prep ( email contacts )  )  ;   }   }  
@ test public void   (  )  {   optional <  argument >  arg = unit . build ( new  generic type <  validation <  string  integer >  >  (  )  {   }   . get type (  )   validation . invalid ( "error" )  null )  ;  assert that ( arg )  . is not empty (  )  ;  
@ override public  maybe <  object >    (  maybe <  object >  f )  throws  exception  {  return f . delay ( 100  time unit . milliseconds )  ;   }  
public  void   (  )  {  return null ;   }  
public void   (  )  {  receive encrypted (    encrypted true )  ;   }  
private boolean   (  )  {  if  ( bitfield  !  =  null )   {   partial piece pp = listener . get partial piece ( peer bitfield )  ;  if  ( pp  !  =  null )   {  if  (  ! get requested pieces (  )  . contains (  integer . value of ( pp . get piece (  )  )  )  )   {   request r = pp . get request (  )  ;  outstanding requests . add ( r )  ;  if  (  ! choked )  out . send request ( r )  ;  last request = r ;  return true ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " got dup from coord: "  +  pp )  ;  pp . release (  )  ;   }   }   }  if  ( outstanding requests . is empty (  )  )  last request = null ;  if  ( interesting && last request  =  =  null )   {  interesting = false ;  out . send interest ( false )  ;  if  (    log . should log (  log . debug )  )     log . debug ( peer  +  " nothing more to request  now uninteresting" )  ;   }  return false ;   }  
public static void   (  )  {  synchronized  (    ec pubkey cache )   {     ec pubkey cache . clear (  )  ;   }  synchronized  (    ec privkey cache )   {     ec privkey cache . clear (  )  ;   }  synchronized  (     ed pubkey cache )   {      ed pubkey cache . clear (  )  ;   }  synchronized  (     ed privkey cache )   {      ed privkey cache . clear (  )  ;   }   }  
@ before public void   (  )  throws  exception  {  mock request proxy service = mock (  request proxy service . class )  ;  executor = new  remote command executor ( mock request proxy service )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . replay ( new  function <  observable <  integer >   observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   observable <  integer >  v
private  interval list   (  interval list tools .  action action boolean invert )  throws io exception  {  final  file il out =  file . create temp file ( " interval list tools" "interval   list" )  ;  il out . delete on exit (  )  ;  final  list <  string >  args = new  array list <  >  (  )  ;  args . add ( "action = "  +  action . to string (  )  )  ;  args . add ( "input = "  +  scatterable )  ;  if  ( action . takes second input )   {  args . add ( "second   input = "  +  second input )  ;   }  else  {  args . add ( "input = "  +  second input )  ;   }  if  ( invert )   {  args . add ( "invert = true" )  ;   }  args . add ( "output = "  +  il out )  ;   assert . assert equals ( run picard command line ( args )  0 )  ;  return  interval list . from file ( il out )  ;   }  
public   (  string conference id  media info media info )  {  this . media info = media info ;  int channels = media info . get channels (  )  ;  conference whisper group = create whisper group ( conference id  whisper group . get default attenuation (  )  )  ;   }  
@ test public void   (  )  throws  unknown host exception  {  assert true ( range2 . address in range ( address )  )  ;  assert false ( range2 . address in range ( "192 . 168 . 1 . 2" )  )  ;   }  
public boolean   (  string transport  string user )  {  if  ( transport sessions . get ( transport )   !  =  null && transport sessions . get ( transport )  . get ( user )   =  =  null )   {  long millis =  system . current time millis (  )  ;  transport sessions . get ( transport )  . put ( user millis )  ;  db . insert or update session ( transport user millis )  ;  return true ;   }  return false ;   }  
@ override public int   (  )  throws io exception  {  if  ( have current stream (  )  )   {  return get current stream (  )  . available (  )  ;   }  return 0 ;   }  
@ override public void   (  throwable t )  {  parent . inner error ( this t )  ;   }  
private static byte[]   ( byte[] source int src offset int num sig bytes byte[] destination int dest offset int options )  {  byte[] alphabet = get alphabet ( options )  ;  int in buff =  ( num sig bytes  >  0  ?   (  ( source[src offset]  <  <  24 )   >  >  >  8 )  : 0 )  |  ( num sig bytes  >  1  ?   (  ( source[src offset  +  1]  <  <  24 )   >  >  >  16 )  : 0 )  |  ( num sig bytes  >  2  ?   (  ( source[src offset  +  2]  <  <  24 )   >  >  >  24 )  : 0 )  ;  switch  ( num sig bytes )   {  case 3: destination[dest offset] = alphabet[ ( in buff  >  >  >  18 ) ] ;  destination[dest offset  +  1] = alphabet[ ( in buff  >  >  >  12 )  & 0x3f] ;  destination[dest offset  +  2] = alphabet[ ( in buff  >  >  >  6 )  & 0x3f] ;  destination[dest offset  +  3] = alphabet[ ( in buff )  & 0x3f] ;  return destination ;  case 2: destination[dest offset] = alphabet[ ( in buff  >  >  >  18 ) ] ;  destination[dest offset  +  1] = alphabet[ ( in buff  >  >  >  12 )  & 0x3f] ;  destination[dest offset  +  2] = alphabet[ ( in buff  >  >  >  6 )  & 0x3f] ;  destination[dest offset  +  3] = equals   sign ;  return destination ;  case 1: destination[dest offset] = alphabet[ ( in buff  >  >  >  18 ) ] ;  destination[dest offset  +  1] = alphabet[ ( in buff  >  >  >  12 )  & 0x3f] ;  destination[dest offset  +  2] = equals   sign ;  destination[dest offset  +  3] = equals   sign ;  return destination ;  default : return destination ;   }   }  
@ override public  list <  string >    ( final  list <  integer >  expected tiles final int[] expected cycles )  {  if  ( tile index  =  =  null )   {  return  collections . singleton list ( " tile index ( "  +  bci . get absolute path (  )   +  " )  does
@ benchmark public void   (  )  {  ctx . aes (  )  . encrypt ( origpt 0 encrypted 0 key iv len )  ;   }  
protected  string   (  )  {  return auth   realm ;   }  
@ test public void   (  )  throws  exception  {   signing public key public key = new  signing public key (  )  ;  public key . to string (  )  ;  exception . expect (  data format exception . class )  ;  exception . expect message ( " no data to write ou
public pep service   ( jid owner )  {  if  (  ! xmpp server . get instance (  )  . is local ( owner )  ||  !  user manager . get instance (  )  . is registered user ( owner . get node (  )  )  )   {  throw new  illegal argument exception ( " request must be initiated by a local  registered user  but is not: "  +  owner )  ;   }  pep service pep service = null ;  final  string barejid = owner . to barejid (  )  ;  final  lock lock =  cache factory . get lock ( owner pep services )  ;  try  {  lock . lock (  )  ;  pep service = pep services . get ( barejid )  ;  if  ( pep service  =  =  null )   {  pep service = new pep service ( xmpp server . get instance (  )  barejid )  ;  pep services . put ( barejid pep service )  ;  if  (  log . is debug enabled (  )  )   {   log . debug ( "pep service created for : "  +  barejid )  ;   }   }   }  finally  {  lock . unlock (  )  ;   }  return pep service ;   }  
public static  list <  string >    (  file file  list <  string >  list )  {   list <  string >  result ;  try  {  result = parse subscriptions ( file )  ;  if  ( result . remove (  daemon . old   default   sub )  )   {  for  (   string sub : list )   {  if  (  ! result . contains ( sub )  )  result . add ( sub )  ;   }  try  {  write subscriptions ( result file )  ;   }  catch  (  io exception ioe )   {   }   }   }  catch  (  io exception exp )   {  result = list ;  try  {  write subscriptions ( result file )  ;   }  catch  (  io exception exp2 )   {   }   }  return result ;   }  
private void   (  friend change status packet p )  {   log . debug ( "qq:  processing friend status change event" )  ;  try  {  if  ( get session (  )  . get buddy manager (  )  . is activated (  )  )   {  try  {  qq buddy qq buddy = get session (  )  . get buddy manager (  )  . get buddy ( get session (  )  . get transport (  )  . convertid tojid (  string . value of ( p . friendqq )  )  )  ;  qq buddy . set presence and status (  (  ( qq transport ) get session (  )  . get transport (  )  )  . convertqq status toxmpp ( p . status )  null )  ;   }  catch  (   not found exception ee )   {   log . debug ( "qq:  received presense notification for contact we don't care about: "  +   string . value of ( p . friendqq )  )  ;   }   }  else  {  get session (  )  . get buddy manager (  )  . store pending status ( get session (  )  . get transport (  )  . convertid tojid (  string . value of ( p . friendqq )  )   (  ( qq transport ) get session (  )  . get transport (  )  )  . convertqq status toxmpp ( p . status )  null )  ;   }   }  catch  (   exception ex )   {   log . error ( " failed to handle friend status change event: " ex )  ;   }   }  
@ test public void   (  )  {  handle . register row mapper (  user . class new  user mapper (  )  )  ;  handle . create query ( "select id  name from user order by id asc" )  . map to (  user . class )  . use stream ( stream  -  >   {   optional <  string
public jid   (  )  {  return new jid ( workgroup name  +  "@workgroup . "  +   component manager factory . get component manager (  )  . get server name (  )  )  ;   }  
@ override public t   (  )  {  if  (  ! enumeration . has more elements (  )  )   {  throw new  no such element exception (  )  ;   }  return enumeration . next element (  )  ;   }  
private void   (  )  {  if  ( threshold output stream  =  =  null )   {  threshold output stream = new  threshold output stream ( raw stream compressing stream factory context new  response buffer commitment callback ( compressing response )  logger )  ;   }   }  
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   runnable r = new  runnable (  )  {  @ override public void run (  )  {  calls[0] +  +  ;   }   }   ;   scheduler s = new  computation scheduler (  )  ;  s . shutdown (  )  ;  s . shutdown (  ) 
public static rtcp source description chunk   (  byte chunk bytes[] )  {  return null ;   }  
@ override public  object   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
default void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {  throw new  unsupported operation exception ( " not supported for type" )  ;   }  
public synchronized int   (  )  {  return    messages processed ;   }  
public void   (  disposable d )  {   disposable helper . try set ( this d )  ;   }  
void   ( long idx t t  debounce emitter < t >  emitter )  {  if  ( idx  =  =  index )   {  actual . on next ( t )  ;  emitter . dispose (  )  ;   }   }  
@ override public  observable <  integer >    (  integer v )  {  return  observable . range ( v 2 )  ;   }  
@ test public void   (  )  {   offset date time dt =  offset date time . now (  )  . with offset same instant (  zone offset . of hours (  - 7 )  )  ;  h . execute ( "insert into stuff ( ts )  values  (  ?  ) " dt )  ;  assert that ( h . create query ( "s
public void   (  string property key )  throws  service exception  {  if  (  jive globals . get property ( property key )   !  =  null )   {   jive globals . delete property ( property key )  ;   }  else  {  throw new  service exception ( " could not find property" property key  exception type . property   not   found  response .  status . not   found )  ;   }   }  
private  object   (  element element )  {   element reason element =  (  element ) element . elements (  )  . get ( 0 )  ;   string reason value = reason element . get name (  )  . to upper case (  )  ;   reason reason =  reason . value of ( reason value )  ;   say complete event complete = new  say complete event (  )  ;  complete . set reason ( reason )  ;  return complete ;   }  
@ test ( timeout = 10000 )  public void   (  )  {  for  ( int i = 0 ;  i  <  50 ;  i +  +  )   {  final  replay processor <  string >  processor =  replay processor . create unbounded (  )  ;  final  atomic reference <  string >  value1 = new  atomic refe
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  mergen async streams ofn ( 1000 1000 )  . subscribe ( ts )  ;  ts . await terminal event (  )  ;  ts . assert no errors (  )  ;  assert equals ( 
public void   ( i2p session session  string message  throwable error )  {     log . debug ( " error occurred: "  +  message error )  ;   }  
@ test public void   (  )  throws io exception  {  stream . flush stream (  )  ;  verify ( digest )  . reset (  )  ;   }  
@ override public void   (  )  {  if  ( jmdns  !  =  null )   {  jmdns = null ;   }   }  
public synchronized void   (  )  {     alive = false ;   }  
public void   (  )  {  observer . on complete (  )  ;   }  
public void   ( long queueid )  {  this . queueid = queueid ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  connectable observable <  integer >  co = ps . publish (  )
public void   (  buffered writer out )  throws io exception  {  write remove ( out )  ;  out . new line (  )  ;   }  
public int   (  )  {  int offset = read body offset (  )  ;  return    message[offset] & 0xff ;   }  
@ test public void   (  )  {  assert null (  observable . empty (  )  . count (  )  . filter ( new  predicate <  long >  (  )  {  @ override public boolean test (   long v )  {  return false ;   }   }   )  . blocking get (  )  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  open =  publish subject . create (  )  ;  final  publish subject <  integer >  close =  publish subject . create (  )  
private  string   (  )  throws  unknown host exception  io exception  {   socket s = null ;  try  {  if  ( get property ( "http . proxy host" )   !  =  null )   {  s = new  socket ( get property ( "http . proxy host" )  parse int ( get property ( "http . proxy port" "80" )  )  )  ;   }  else  {  int port = 80 ;  if  ( push url . get port (  )   !  =   - 1 )   {  port = push url . get port (  )  ;   }  s = new  socket ( push url . get host (  )  port )  ;   }  s . set so timeout ( two   minutes )  ;  return s . get local address (  )  . get host address (  )  ;   }  finally  {  if  ( s  !  =  null )   {  try  {  s . close (  )  ;   }  catch  (  io exception e )   {   }   }   }   }  
@ test public void   (  )  {   unicast subject <  integer >  us =  unicast subject . create ( false )  ;   test observer <  integer >  to = us . to (  observer fusion .  <  integer > test (  queue fuseable . any false )  )  ;  us . done = true ;  us . dra
@ override public void   ( final  observer <  ?  super  long >  observer )  {  observer . on subscribe ( d )  ;  observer . on complete (  )  ;   }  
public boolean   (  list <  pending gateway message >  pending  tunnel gateway .  sender sender  tunnel gateway .  receiver rec )  {  throw new  unsupported operation exception ( "unused  right ? " )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . error ( new  test exception (  )  )  . window ( 1 2 )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public  object   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test public void   (  )  {  int num =  ( int )  (  flowable . buffer size (  )  * 2 . 1 )  ;   atomic integer c1 = new  atomic integer (  )  ;   atomic integer c2 = new  atomic integer (  )  ;   test subscriber <  integer >  ts = new  test subscriber < 
public void   (  data output out  list <  string >  string list )  throws io exception  {  strategy . write string list ( out string list )  ;   }  
@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
private void   (  file f  file app dir  string url )  {   trusted update up = new  trusted update (    context )  ;   file to = new  file (    context . get temp dir (  )  "tmp"  +     context . random (  )  . next int (  )   +  zip )  ;   string err = up . migrate file ( f to )  ;  if  ( err  !  =  null )   {  status done ( " < b > "  +  err  +  ' ' +     t ( "from  { 0 } " url )  +  "  <  / b > " )  ;  f . delete (  )  ;  to . delete (  )  ;  return ;   }   properties props = get plugin config ( f to url )  ;  if  ( props  =  =  null )  return ;   string pubkey = props . get property ( "key" )  ;   string signer =  data helper . striphtml ( props . get property ( "signer" )  )  ;  if  ( pubkey  =  =  null || signer  =  =  null || pubkey . length (  )   !  =  172 || signer . length (  )   <  =  0 )   {  f . delete (  )  ;  to . delete (  )  ;  status done ( " < b > "  +     t ( " plugin from  { 0 }  contains an invalid key" url )   +  " <  / b > " )  ;  return ;   }   signing public key spk ;  try  {  spk = new  signing public key ( pubkey )  ;   }  catch  (   data format exception dfe )   {  f . delete (  )  ;  to . delete (  )  ;  status done ( " < b > "  +     t ( " plugin from  { 0 }  contains an invalid key" url )   +  " <  / b > " )  ;  return ;   }   map <  string  string >  existing keys =  plugin starter . get plugin keys (    context )  ;  for  (   map .  entry <  string  string >  e : existing keys . entry set (  )  )   {  up . add key ( e . get key (  )  e . get value (  )  )  ;   }   map <  string  string >  trusted keys =  trusted plugin keys . get keys (  )  ;  for  (   map .  entry <  string  string >  e : trusted keys . entry set (  )  )   {  up . add key ( e . get key (  )  e . get value (  )  )  ;   }  if  ( up . have key ( pubkey )  )   {  boolean ok = up . verify ( f spk )  ;   string signing key name = up . get keys (  )  . get ( spk )  ;  if  (  (  ! ok )  ||  !  ( signer . equals ( signing key name )  || "" . equals ( signing key name )  )  )   {  f . delete (  )  ;  to . delete (  )  ;  if  ( signing key name  =  =  null )     log . error ( " failed to verify plugin signature  corrupt plugin or bad signature  signed by: "  +  signer )  ;  else    log . error ( " plugin signer \""  +  signer  +  "\" does not match existing signer in plugin . config file \"" +  signing key name +  "\"" )  ;  status done ( " < b > "  +     t ( " plugin signature verification of  { 0 }  failed" url )   +  " <  / b > " )  ;  return ;   }   }  else if  (    context . get boolean property ( prop   allow   new   keys )  )   {  if  (  ! up . add key ( pubkey signer )  )   {  f . delete (  )  ;  to . delete (  )  ;     log . error ( " bad key or key mismatch  -   failed to add plugin key \""  +  pubkey  +  "\" for plugin signer \"" +  signer +  "\"" )  ;  status done ( " < b > "  +     t ( " plugin signature verification of  { 0 }  failed" url )   +  " <  / b > " )  ;  return ;   }   string signing key name = up . verify and get signer ( f )  ;  if  (  ! signer . equals ( signing key name )  )   {  f . delete (  )  ;  to . delete (  )  ;  if  ( signing key name  =  =  null )     log . error ( " failed to verify plugin signature  corrupt plugin or bad signature  signed by: "  +  signer )  ;  else    log . error ( " plugin signer \""  +  signer  +  "\" does not match new signer in plugin . config file \"" +  signing key name +  "\"" )  ;  status done ( " < b > "  +     t ( " plugin signature verification of  { 0 }  failed" url )   +  " <  / b > " )  ;  return ;   }   }  else  {  f . delete (  )  ;  to . delete (  )  ;     log . error ( " untrusted plugin key \""  +  pubkey  +  "\" for plugin signer \"" +  signer +  "\"" )  ;  status done ( " < b > "  +     t ( " plugin not installed  -  signer is untrusted" )   +  " <  / b > " )  ;  return ;   }   string sud version =  trusted update . get version string ( f )  ;  f . delete (  )  ;  process final ( to app dir url props sud version pubkey signer )  ;   }  
protected static  node[]   (  node parent node )  {  return  util .  xml . get child nodes ( parent node null )  ;   }  
public   (  string message )  {  super ( message )  ;   }  
public int   (  )  {  return    type ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  new i2p socket address ( stats   host  +  ":90000" )  ;   }  
private synchronized void   ( final  string barcode final cluster   output   record record )  {   sorting collection < cluster   output   record >  record collection = this . barcode to record collection . get ( barcode )  ;  if  ( record collection  =  =  null )   {  if  (  ! barcode record writer map . contains key ( barcode )  )   {  if  ( ignore unexpected barcodes )   {  return ;   }  throw new  picard exception (  string . format ( " read records with barcode %s  but this barcode was not expected .   (  is it referenced in the parameters file ?  ) " barcode )  )  ;   }  record collection = new sorting collection (  )  ;  this . barcode to record collection . put ( barcode record collection )  ;   }  record collection . add ( record )  ;   }  
@ test public void   (  )  {   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   single . just ( "a" )  . map ( new  function <  string  string >  (  )  {  @ override public  string apply (   string s )  {  return s  +  "b" ;  
public  collection <  string >    (  string username )  throws  user not found exception  {   user user = get user ( username )  ;   collection <  group >  groups =  group manager . get instance (  )  . get groups ( user )  ;   collection <  string >  group names = new  array list <  string >  (  )  ;  for  (   group group : groups )   {  group names . add ( group . get name (  )  )  ;   }  return group names ;   }  
public   ( final  chat state event listener listener )  {  this . listener = listener ;   }  
  (  handle handle  string sql )  {  super ( handle )  ;  this . handle = handle ;  this . sql = sql ;  get context (  )  . set connection ( handle . get connection (  )  )  . set raw sql ( sql )  ;   }  
public void   ( boolean last response empty )  {  this . last response empty = last response empty ;   }  
@ override public boolean   (  )  {  return get (  )   =  =   subscription helper . cancelled ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . window ( 2 1  time unit . seconds scheduler )  . flat map 
public   ( int ms int wdw int rtt dev )  {     rtt = ms ;     wdw = wdw ;     rtt dev = rtt dev ;     updated =    context . clock (  )  . now (  )  ;   }  
@ override public  integer   (  )  throws  number format exception  {  return  integer . value of ( s )  ;   }  
public void   (  )  {  try  {   properties opts = new  properties (  )  ;  i2p socket manager mgr = new i2p socket manager full (    context    session opts "client" )  ;     log . debug ( "manager created" )  ;  i2p socket socket = mgr . connect (    server . get my destination (  )  )  ;     log . debug ( "socket created" )  ;   input stream in = socket . get input stream (  )  ;   output stream out = socket . get output stream (  )  ;  for  ( int i = 0 ;  i  <  3 ;  i +  +  )   {  byte buf[] = new byte[128 * 1024] ;     context . random (  )  . next bytes ( buf )  ;  byte orig[] = new byte[buf . length] ;   system . arraycopy ( buf 0 orig 0 buf . length )  ;  out . write ( buf )  ;     log . debug ( "client wrote a buffer" )  ;  out . flush (  )  ;     log . debug ( "client flushed" )  ;  byte rbuf[] = new byte[buf . length] ;  for  ( int j = 0 ;  j  <  buf . length ;  j +  +  )   {  int c = in . read (  )  ;  if  ( c  =  =   - 1 )   {  buf = null ;  break ;   }  else  {  if  ( c  <  0 )  c +  = 256 ;  rbuf[j] =  ( byte )  ( c & 0xff )  ;   }   }  if  ( buf  !  =  null )   {     log . debug ( "* client read a full buffer" )  ;  int first off =  - 1 ;  for  ( int k = 0 ;  k  <  orig . length ;  k +  +  )   {  if  ( orig[k]  !  =  rbuf[k] )   {  first off = k ;  break ;   }   }  assert true ( first off  <  0 )  ;   }   }  if  (    log . should log (  log . debug )  )     log . debug ( " closing the client socket" )  ;  socket . close (  )  ;     log . debug ( "socket closed" )  ;   thread . sleep ( 5 * 1000 )  ;   }  catch  (   exception e )   {     log . error ( "error running" e )  ;   }   }  
public   ( int in int out )  {  this (  )  ;  data[0] = in ;  data[1] = out ;   }  
int   (  )  {  int peers = 0 ;  for  (   transport t :    transports . values (  )  )   {  peers +  = t . count active send peers (  )  ;   }  return peers ;   }  
public  map <  class <  ?  >   field >    (  )  {  return  ( attachment or byte buffer field map )  ;   }  
@ test public void   (  )  throws sql exception  {  assert that thrown by (  (  )   -  >  db rule . get shared handle (  )  . register row mapper (  constructor mapper . factory (  something with option . class )  )  . create query ( "select name from som
public  hash   (  )  {  if  (       calculated hash  !  =  null )  return       calculated hash ;  byte ident bytes[] ;  try  {   byte array output stream baos = new  byte array output stream ( 400 )  ;  write bytes ( baos )  ;  ident bytes = baos . to byte array (  )  ;   }  catch  (  io exception ioe )   {  throw new  illegal state exception ( "kac hash error" ioe )  ;   }  catch  (   data format exception dfe )   {  throw new  illegal state exception ( "kac hash error" dfe )  ;   }        calculated hash = sha256 generator . get instance (  )  . calculate hash ( ident bytes )  ;  return       calculated hash ;   }  
public static  inet socket address   (  )  {  return sip address ;   }  
public boolean   (  date date )  {  if  ( date  =  =  null )   {  throw new  illegal argument exception ( " argument 'date' cannot be null . " )  ;   }  final  archive candidate c = conversation queue . peek (  )  ;  final  archive candidate m = message queue . peek (  )  ;  final  archive candidate p = participant queue . peek (  )  ;  return  ( c  =  =  null || c . creation . after ( date )  )  &&  ( m  =  =  null || m . creation . after ( date )  )  &&  ( p  =  =  null || p . creation . after ( date )  )  ;   }  
@ override public void   (  )  {  if  ( data source name  =  =  null || data source name . equals ( "" )  )   {   log . error ( " no name specified for  data source .  jndi lookup will fail" new  throwable (  )  )  ;  return ;   }  try  {   properties con
public static double   (  type type )  {  long count  start  end ;  switch  ( type )   {  case select: count = select count ;  start = start select time ;  end = end select time ;  break ;  case update: count = update count ;  start = start update time ;  end = end update time ;  break ;  case insert: count = insert count ;  start = start insert time ;  end = end insert time ;  break ;  case delete: count = delete count ;  start = start delete time ;  end = end delete time ;  break ;  default : throw new  illegal argument exception ( " invalid type" )  ;   }  if  ( count  =  =  0 )   {  return 0 ;   }  if  ( end  =  =  0 )   {  end =  system . current time millis (  )  ;   }  double time =  ( end  -  start )   /  1000 . 0 ;  return count  /  time ;   }  
public void   (  )  {   rule manager rule manager = new  rule manager proxy (  )  ;  rule manager . rules updated (  )  ;   }  
public  base transport < b >    (  )  {  return transport ;   }  
@ override public void   (  subscriber <  ?  super  integer >  t )  {  t . on subscribe ( new  boolean subscription (  )  )  ;  for  ( int i = 0 ;  i  <  m ;  i +  +  )   {  t . on next ( i )  ;   }  t . on complete (  )  ;   }  
@ override public void   ( t value )  {  d =  disposable helper . disposed ;  try  {  on event . accept ( value null )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  actual . on error ( ex )  ;  return ;   }  actual . on su
@ benchmark public void   (  blackhole bh )  {  observable . subscribe ( new  perf consumer ( bh )  )  ;   }  
public  string   (  )  {  return    host ;   }  
@ override public void   ( t t )  {  if  ( value  !  =  null )   {  s . get (  )  . cancel (  )  ;  on error ( new  index out of bounds exception ( " more than one element received" )  )  ;  return ;   }  value = t ;   }  
@ override public void   (  )  {  cancelled = true ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ override public boolean   ( jid requester )  {  return super . has permission ( requester )  ||  internal component manager . get instance (  )  . has component ( requester )  ;   }  
@ xml element ( name = "groupname" )  public  list <  string >    (  )  {  return group names ;   }  
@ test public void   (  )  {   test helper . check double on subscribe completable ( new  function <  completable  completable >  (  )  {  @ override public  completable apply (   completable f )  throws  exception  {  return f . do finally (  completable
static public int   (  context context  uri uri )  {  return count ( context uri null null )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private void   (  hash peer byte[] ip )  {   string reason =    x ( "ip banned by blocklist . txt entry  { 0 } " )  ;     context . banlist (  )  . banlist router forever ( peer reason  addresses . to string ( ip )  )  ;  if  (  !    context . get boolean property default true ( prop   blocklist   detail )  )  return ;  boolean should run job ;  int number ;  synchronized  (    in process )   {  number =    in process . size (  )  ;  should run job =    in process . add ( peer )  ;   }  if  (  ! should run job )  return ;   job job = new  banlist job ( peer get addresses ( peer )  )  ;  if  ( number  >  0 )  job . get timing (  )  . set start after (    context . clock (  )  . now (  )   +   ( 30 * 1000l * number )  )  ;     context . job queue (  )  . add job ( job )  ;   }  
@ override public iq   ( iq packet )  throws  unauthorized exception  {  iq reply = iq . create resultiq ( packet )  ;   element offline request = packet . get child element (  )  ;  jid from = packet . get from (  )  ;  if  ( offline request . element ( 
static void   (  byte matrix matrix )  {  matrix . clear (  ( byte )  - 1 )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   safe subscriber <  integer >  so = new  safe subscriber <  integer >  ( ts )  ;   boolean subscription d = new  boolean subscription (  )  ;  so
@ test public void   (  )  {   test helper . check utility class (  rx java plugins . class )  ;   }  
public  element   (  )  {   element vcard =  document helper . create element ( q name . get ( "v card"  name space . vcard   temp )  )  ;  vcard . add element ( "version" )  . addcdata ( "2 . 0" )  ;  vcard . add element ( "jabberid" )  . addcdata ( getjid (  )  . to string (  )  )  ;  vcard . add element ( "nickname" )  . addcdata ( get nickname (  )   =  =  null  ?  get name (  )  : get nickname (  )  )  ;  if  (  jive globals . get boolean property ( "plugin . gateway . "  +  get manager (  )  . get session (  )  . get transport (  )  . get type (  )   +  " . avatars" true )  )   {  addv card photo ( vcard )  ;   }  return vcard ;   }  
public void   ( long delay )  {  media proxy . set idle time ( delay )  ;   }  
@ test public void   (  )  {   flowable .  <  integer > just ( 1 )  . hide (  )  . concat map eager ( new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   integer v )  throws  exception  {  retur
@ override public boolean   (  object key )  {  check not null ( key null   key   is   not   allowed )  ;  delete expired entries (  )  ;  return map . contains key ( key )  ;   }  
public void   (  )  {     cache . release (    buf )  ;   }  
@ override public boolean   (  )  {  return audit presence ;   }  
@ override public boolean   (  )  {  return w . is disposed (  )  ;   }  
@ test public void   (  )  {   flowable processor <  string >  obs =  publish processor . create (  )  ;   iterator <  string >  it = obs . blocking next (  )  . iterator (  )  ;  fire on next in new thread ( obs "one" )  ;  assert true ( it . has next ( 
public   ( http socket socket )  {  set socket ( socket . get socket (  )  )  ;  set input stream ( socket . get input stream (  )  )  ;  set output stream ( socket . get output stream (  )  )  ;   }  
@ test public void   (  )  {  assert equals ( instance . get name (  )  instance . get name from roles ( instance . get roles (  )  )  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {  final  scheduled action sa = new  scheduled action (  )  {  private static final long serial versionuid =  - 672980251643733156l ;  @ override pro
private static  object[]   (  public key jpub  private key jpriv  signing private key priv  sig type type  string cname  set <  string >  alt names  string ou  string o  string l  string st  string c int valid days )  throws  general security exception  {   string oid ;  switch  ( type )   {  case dsa   sha1: case ecdsa   sha256   p256: case ecdsa   sha384   p384: case ecdsa   sha512   p521: case rsa   sha256   2048: case rsa   sha384   3072: case rsa   sha512   4096: case  eddsa   sha512    ed25519: case  eddsa   sha512    ed25519ph: oid = type . getoid (  )  ;  break ;  default : throw new  general security exception ( " unsupported: "  +  type )  ;   }  byte[] sigoid = get encodedoid seq ( oid )  ;  byte[] tbs = gentbs ( cname alt names ou o l st c valid days sigoid jpub )  ;  int tbslen = tbs . length ;   signature sig = dsa engine . get instance (  )  . sign ( tbs priv )  ;  if  ( sig  =  =  null )  throw new  general security exception ( "sig failed" )  ;  byte[] sigbytes =  sig util . to java sig ( sig )  ;  int seqlen = tbslen  +  sigoid . length  +  space for ( sigbytes . length  +  1 )  ;  int totlen = space for ( seqlen )  ;  byte[] cb = new byte[totlen] ;  int idx = 0 ;  cb[idx +  + ] = 0x30 ;  idx = int toasn1 ( cb idx seqlen )  ;   system . arraycopy ( tbs 0 cb idx tbs . length )  ;  idx +  = tbs . length ;   system . arraycopy ( sigoid 0 cb idx sigoid . length )  ;  idx +  = sigoid . length ;  cb[idx +  + ] = 0x03 ;  idx = int toasn1 ( cb idx sigbytes . length  +  1 )  ;  cb[idx +  + ] = 0 ;   system . arraycopy ( sigbytes 0 cb idx sigbytes . length )  ;  if  ( debug )   {   system . out . println ( " sig oid" )  ;   system . out . println (  hex dump . dump ( sigoid )  )  ;   system . out . println ( " signature" )  ;   system . out . println (  hex dump . dump ( sigbytes )  )  ;   system . out . println ( " whole cert" )  ;   system . out . println (  hex dump . dump ( cb )  )  ;   }   byte array input stream bais = new  byte array input stream ( cb )  ;  x509 certificate cert ;  try  {   certificate factory cf =  certificate factory . get instance ( "x . 509" )  ;  cert =  ( x509 certificate ) cf . generate certificate ( bais )  ;  cert . check validity (  )  ;   }  catch  (  illegal argument exception iae )   {  throw new  general security exception ( "cert error" iae )  ;   }  x509crl crl = generatecrl ( cert valid days 1 sigoid jpriv )  ;   public key cpub = cert . get public key (  )  ;  cert . verify ( cpub )  ;  if  (  ! cpub . equals ( jpub )  )  throw new  general security exception ( "pubkey mismatch" )  ;   object[] rv =  { jpub jpriv cert crl }  ;  return rv ;   }  
@ override protected boolean   (  )  {  return false ;   }  
@ test public void   (  )  {   observable . range ( 1 10 )  . window ( 1  time unit . minutes 20 true )  . flat map (  functions .  <  observable <  integer >  > identity (  )  true )  . test (  )  . await done ( 5  time unit . seconds )  . assert result 
private  list <  integer >    ( int port )  {   list <  integer >  ports = new  array list <  >  (  )  ;  ports . add ( port )  ;  return ports ;   }  
@ deprecated public  input stream   (  )  {  return    input stream ;   }  
  (  observer <  ?  super  integer >  actual )  {  super ( actual )  ;   }  
public boolean   (  )  {  return is ivy compatible ;   }  
@ override public void   ( long n )  {  if  ( crash request )   {  throw new  test exception ( "request (  ) " )  ;   }   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer sub unsub count = new  atomic integer (  )  ;   observable <  long >  o = synchronous interval (  )  . do on dispose ( new  action (  )  {  @ override public void run (  ) 
public  input stream   (  )  {  return m in ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . just ( 0 )  . switch map single ( null )  ;   }  
protected int   (  )  {  return redundancy ;   }  
@ test public void   (  )  {   observable <  string >  items =  observable . just ( "one" "two" "three" )  ;  assert equals (  (  long ) 3l items . count (  )  . blocking get (  )  )  ;  assert equals ( "two" items . skip ( 1 )  . take ( 1 )  . blocking s
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  test observer <  boolean >  to =  observable . sequence equ
public synchronized void   (  request event request received event )  {   request request = request received event . get request (  )  ;   server transaction st = request received event . get server transaction (  )  ;  if  ( request . get method (  )  . equals (  request . bye )  )   {  handle bye ( request st )  ;   }  else if  ( request . get method (  )  . equals (  request . invite )  )   {  handle re invite ( request st )  ;   }  else if  ( request . get method (  )  . equals (  request . ack )  )   {   logger . println ( " call "  +  cp  +  " got ack" )  ;   }  else  {   logger . write file ( " call "  +  cp  +  " ignoring request " +  request . get method (  )  )  ;   }   }  
public void   (  string value )  {  get device node (  )  . set node ( model   description value )  ;   }  
@ nullable @ override public r   (  )  throws  exception  {   iterator <  ?  extends r >  iterator = it ;  if  ( iterator  !  =  null )   {  r v =  object helper . require non null ( iterator . next (  )  " the iterator returned a null value" )  ;  if  ( 
public void   (  )  {  try  {  if  ( is registered (  )  )   {  register (  )  ;   }   }  catch  (  io exception e )   {   logger . println ( " failed to re register "  +  e . get message (  )  )  ;   }   }  
@ test public void   (  )  throws  unknown host exception  {  assert true ( range3 . address in range ( "2001:db8::1" )  )  ;  assert false ( range3 . address in range ( "2001:db9::1" )  )  ;  assert false ( range3 . address in range ( "127 . 0 . 0 . 1" )
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . just ( null )  ;   }  
public void   (  byte buffer buf )  {     bytes sent +  = buf . capacity (  )  ;   out net message msg = null ;  boolean clear message = false ;  if  (    sending meta &&  ( buf . capacity (  )   =  =     meta . length )  )   {     sending meta = false ;   }  else  {  clear message = true ;   }     write bufs . remove ( buf )  ;  if  ( clear message )   {  synchronized  (    outbound )   {  if  (    current outbound  !  =  null )   {  msg =    current outbound ;     current outbound = null ;   }   }  if  ( msg  !  =  null )   {     last send time =    context . clock (  )  . now (  )  ;     context . stat manager (  )  . add rate data ( "ntcp . send time" msg . get send time (  )  )  ;  if  (    log . should log (  log . debug )  )   {     log . debug ( "i2np message "  +     messages written  +  " / " +  msg . get message id (  )  +  " sent after " +  msg . get send time (  )  +  " / " +  msg . get lifetime (  )  +  " with " +  buf . capacity (  )  +  " bytes  ( uid = " +   system . identity hash code ( msg )  +  " on " +  to string (  )  +  " ) " )  ;   }     messages written . increment and get (  )  ;     transport . send complete ( msg )  ;   }   }  else  {  if  (    log . should log (  log . info )  )     log . info ( "i2np meta message sent completely" )  ;   }  if  ( get outbound queue size (  )   >  0 )     transport . get writer (  )  . wants write ( this "write completed" )  ;  update stats (  )  ;   }  
@ override public void   (  )  {  router . route ( message )  ;   }  
private static final int   (  object val )  {  if  ( val  =  =  null )  return 0 ;   string str = null ;  if  ( val instanceof  string )  str =  (  string ) val ;  else str =  (  (  string[] ) val ) [0] ;  if  ( str . trim (  )  . length (  )   <  =  0 )  return 0 ;  try  {  return  integer . parse int ( str )  ;   }  catch  (   number format exception nfe )   {  return 0 ;   }   }  
@ override protected void   (  )  throws  throwable  {  stop schedule (  )  ;  super . finalize (  )  ;   }  
public static void   ( final  list <  string >  package list final  bi consumer <  class <  command line program >   command line program properties >  clp class processor )  {  final  class finder class finder = new  class finder (  )  ;  package list . for each ( pkg  -  >  class finder . find ( pkg  command line program . class )  )  ;  for  (  final  class clazz : class finder . get classes (  )  )   {  if  (  ! clazz . is interface (  )  &&  ! clazz . is synthetic (  )  &&  ! clazz . is primitive (  ) &&  ! clazz . is local class (  ) &&  !  modifier . is abstract ( clazz . get modifiers (  )  )  )   {  clp class processor . accept ( clazz  picard command line . get program property ( clazz )  )  ;   }   }   }  
public void   (  multi user chat service service )  {   log . debug ( " multi user chat manager:  registering muc service "  +  service . get service name (  )  )  ;  try  {   component manager factory . get component manager (  )  . add component ( service . get service name (  )  service )  ;  muc services . put ( service . get service name (  )  service )  ;   }  catch  (   component exception e )   {   log . error ( " multi user chat manager:  unable to add "  +  service . get service name (  )   +  " as component . " e )  ;   }   }  
@ override public void   (  )  {  if  ( won )   {  actual . on complete (  )  ;   }  else  {  if  ( parent . win ( index )  )   {  won = true ;  actual . on complete (  )  ;   }  else  {  get (  )  . cancel (  )  ;   }   }   }  
public   (  string application name  map <  string  filter type >  registered filters )  {  this . application name = application name ;  this . registered filters = registered filters ;   }  
@ test public void   (  )  {  final int[] call =  { 0 }  ;   flowable . generate (  functions . just callable ( 1 )  new  bi consumer <  integer  emitter <  object >  >  (  )  {  @ override public void accept (   integer s   emitter <  object >  e )  thro
public static void   (  string message  condition condition int timeout seconds )  {   log utils . d (  logging . log   tag message  +  ":  waiting .  .  . " )  ;  final long timeout =  system . current time millis (  )   +  timeout seconds * 1000 ;  while  (  system . current time millis (  )   <  timeout )   {  if  ( condition . is met (  )  )   {  return ;   }  try  {   thread . sleep ( 500 )  ;   }  catch  (   interrupted exception ignore )   {   }   }  fail ( message  +  ":  timeout" )  ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . to flowable (  backpressure strategy . drop )  . test ( 1 )  . assert result ( 1 )  ;   }  
private int   (  )  {   service service ;  synchronized  ( lock )   {  if  (  ! isnat present (  )  || thinks we are double natted )  return  - 1 ;  service =    service ;   }   action getip = service . get action ( " get link layer max bit rates" )  ;  if  ( getip  =  =  null ||  ! getip . post control action (  )  )  return  - 1 ;   argument a = getip . get output argument list (  )  . get argument ( " new upstream max bit rate" )  ;  if  ( a  =  =  null )  return  - 1 ;  try  {  return  integer . parse int ( a . get value (  )  )  ;   }  catch  (   number format exception nfe )   {  return  - 1 ;   }   }  
@ override public void   (  )  {  cd . dispose (  )  ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {  try  {  new  bad observable (  )  . test (  )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   null pointer exception ex )   {  if  (  !
public void   (  list <  string >  outcasts )  {  this . outcasts = outcasts ;   }  
public   ( final  string read name regex final int optical duplicate pixel distance final long max duplicate set size final  log log )  {  super ( read name regex log )  ;  this . optical duplicate pixel distance = optical duplicate pixel distance ;  this . max duplicate set size = max duplicate set size ;   }  
@ test public void   (  )  {   flowable . from iterable (  arrays . as list ( 1 2 3 4 5 )  )  . filter (  functions . always true (  )  )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
int   (  )  {  return subscribers . get (  )  . length ;   }  
@ override public  < e > e   (  class < e >  extension type  handle supplier handle )  {   map <  method  handler >  handlers = method handlers for ( extension type handle . get config (  handlers . class )  handle . get config (  handler decorators . cla
private static  string   (  string name )  {  return  string . format ( " hello %s ! " name )  ;   }  
public byte[]   (  )  {  return bitfield ;   }  
  (  subscriber <  ?  super t > [] subscribers int prefetch )  {  this . subscribers = subscribers ;  this . prefetch = prefetch ;  this . limit = prefetch  -   ( prefetch  >  >  2 )  ;  int m = subscribers . length ;  this . requests = new  atomic long array ( m  +  m  +  1 )  ;  this . requests . lazy set ( m  +  m m )  ;  this . emissions = new long[m] ;   }  
@ check return value @ non null public final  parallel flowable < t >    ( @ non null  action on after terminate )  {   object helper . require non null ( on after terminate "on after terminate is null" )  ;  return  rx java plugins . on assembly ( new  p
@ override public void   (  )  throws  exception  {  throw new  test exception ( " inner" )  ;   }  
void   (  )  {  write started =  system . current time millis (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  final  list <  throwable >  errors = new  array list <  throwable >  (  )  ;  ps . subscribe ( new  consumer <  integer >  (  )  {  @ override public void
@ override public boolean   (  object obj )  {  if  ( obj instanceof  type variable key )   {   type variable key that =  (  type variable key ) obj ;  return equals type variable ( that . var )  ;   }  else  {  return false ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on lifecycle ( null  functions . empty   action )  ;   }  
public void   (  string treatment )  {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " setting conference answer treatment to "  +  treatment )  ;   }  conference answer treatment = treatment ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;   unicast processor <  integer >  up =  unicast processor . create (  )  ;  up . filter (  functions . always false (  )  )  . fil
public  string   (  )  {  return presence message ;   }  
public static byte[]   (  big integer r  big integer s )  {  int extra = 4 ;  byte[] rb = r . to byte array (  )  ;  if  ( rb . length  >  127 )   {  extra +  +  ;  if  ( rb . length  >  255 )  extra +  +  ;   }  byte[] sb = s . to byte array (  )  ;  if  ( sb . length  >  127 )   {  extra +  +  ;  if  ( sb . length  >  255 )  extra +  +  ;   }  int seqlen = rb . length  +  sb . length  +  extra ;  int totlen = seqlen  +  2 ;  if  ( seqlen  >  127 )   {  totlen +  +  ;  if  ( seqlen  >  255 )  totlen +  +  ;   }  byte[] rv = new byte[totlen] ;  int idx = 0 ;  rv[idx +  + ] = 0x30 ;  idx = int toasn1 ( rv idx seqlen )  ;  rv[idx +  + ] = 0x02 ;  idx = int toasn1 ( rv idx rb . length )  ;   system . arraycopy ( rb 0 rv idx rb . length )  ;  idx +  = rb . length ;  rv[idx +  + ] = 0x02 ;  idx = int toasn1 ( rv idx sb . length )  ;   system . arraycopy ( sb 0 rv idx sb . length )  ;  return rv ;   }  
@ data provider ( name = " " )  public  object[][] allow twice data (  )  {  return new  object[][] {  { true }   { false }  }  ;   }  
@ override public void   (  )  {  trim ( scheduler . now ( unit )  queue )  ;  done = true ;  drain (  )  ;   }  
@ override public final int   ( int mode )  {  return mode & sync ;   }  
@ test public void   (  )  throws  exception  {  h . create update ( "insert into values values ( 'baz' ) " )  . execute (  )  ;  assert that ( h . create query ( "select * from values" )  . map to (  enumt . class )  . find only (  )  )  . is equal to ( 
@ test public void   (  )  {   test subscriber <  list <  integer >  >  ts = new  test subscriber <  list <  integer >  >  (  )  ;   buffer boundary supplier subscriber <  integer  list <  integer >   integer >  sub = new  buffer boundary supplier subscri
public  iterator <  object[] >    (  )  {  return transfer list . iterator (  )  ;   }  
public static void   ( jid roomjid jid user  string new subject )  {  for  (  muc event listener listener : listeners )   {  listener . room subject changed ( roomjid user new subject )  ;   }   }  
@ override public void   ( boolean forward )  throws  cert path validator exception  {  if  (  ! forward )   {  cert index = certs . length  -  1 ;   }  else  {  throw new  cert path validator exception ( " forward checking not supported" )  ;   }   }  
  ( int value )  {  this . value = value ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . zip (  arrays . as list ( just1 just1 )  new  function <  object[]  object >  (  )  {  @ override public  object apply (   obj
@ test public void   (  )  {  assert equals ( " should add a root reference to a uri" " / a / resource"  string uri utilities . format uri ( "a / resource" )  )  ;   }  
@delete @ path ( " /  { roster jid } " )  public  response   ( @ path param ( "username" )   string username @ path param ( "roster jid" )   string roster jid )  throws  service exception  {  try  {  plugin . delete roster item ( username roster jid )  ; 
@ test public void   (  )  {   flowable . range ( 1 4 )  . hide (  )  . parallel ( 2 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )  throws  exception  {  if  ( v  =  =  1 )   {  throw new  test e
@ deprecated @ override public void   ( boolean on )  {  throw new  unsupported operation exception (  )  ;   }  
private void   (  )  {  on app upgrade (  )  ;   account reconciler . reconcile accounts ( this )  ;   email service utils . start remote services ( this )  ;   }  
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
public void   ( h h )  {  b = h ;   }  
@ benchmark public void   (  blackhole bh )  {  flow flat map maybe as flow0 . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  result =  flowable . concat (  flowable . just ( 1 2 3 4 5 )   flowable .  <  integer > error ( new  test exception (  )  )  )  . reduce ( 0 sum )  . to flowable (  )  . map ( new  function <  integer 
@ test public void   (  )  {  final  boolean subscription bs = new  boolean subscription (  )  ;   flowable . unsafe create ( new  publisher <  long >  (  )  {  @ override public void subscribe (  final  subscriber <  ?  super  long >  subscriber )  {  su
public synchronized void   (  )  {  if  (  !    is running )  return ;     is running = false ;     session . remove listener ( i2p session . proto   datagram    q port )  ;     session . remove listener ( i2p session . proto   datagram   raw    r port )  ;     tracker . stop (  )  ;  boolean save all =    context . clock (  )  . now (  )   -     started  <  20 * 60 * 1000 ;   persistdht . savedht (    known nodes save all    dht file )  ;     known nodes . stop (  )  ;  for  (  iterator <  reply waiter >  iter =    sent queries . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   reply waiter waiter = iter . next (  )  ;  iter . remove (  )  ;  waiter . network fail (  )  ;   }     outgoing tokens . clear (  )  ;     incoming tokens . clear (  )  ;     blacklist . clear (  )  ;   }  
public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  throwable t )  {  if  ( once )   {   rx java plugins . on error ( t )  ;  return ;   }  once = true ;  parent . on error ( t )  ;   }  
@ override public void   (  client app app  client app state state  string message  exception e )  {  switch  ( state )   {  case uninitialized: case initialized: if  (    log . should log (  log . warn )  )     log . warn ( " client "  +  app . get displ
@ test public void   (  )  throws  exception  {  mock columns (  )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean )  . is not null (  )  ;   }  
public static  date   (  long ntp )  {   byte long bytes network[] =  bit assistant . get long bytes network ( ntp )  ;   long num =  bit assistant . to long from integer network ( long bytes network  integer . value of ( 0 )  )  ;   long num3 =  long . value of (  (  bit assistant . to long from integer network ( long bytes network  integer . value of ( 4 )  )  . long value (  )  * 1000l )   /  0x100000000l )  ;  return  date extensions . add milliseconds (  date extensions . add seconds (    base time new  double (  ( new  long ( num . long value (  )  )  )  . double value (  )  )  )  new  double (  ( new  long ( num3 . long value (  )  )  )  . double value (  )  )  )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   composite exception cex = new  composite exception ( ex1 get new composite exception with ex123 (  )  )  ;   system . err . println ( " -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 
public   (  string protocol int number )  {  this . protocol = protocol ;  this . number = number ;   }  
@ override public final boolean   (  )  {  return cancelled ;   }  
@ override public boolean   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test public void   (  )  {  final  list <  string >  expected values = get file names ( default   tiles )  ;  final  per tile cycle parser <  mock cycled illumina data >  parser = make parser (  )  ;  int index = 0 ;  while  ( parser . has next (  )  ) 
@ override public boolean   ( jid requester )  {  return  ( super . has permission ( requester )  ||  internal component manager . get instance (  )  . has component ( requester )  )  &&  !  user manager . get user provider (  )  . is read only (  )  ;   
@ override public void   (  presence type presence type  string verbose status )  {   log . debug ( " simple session ( "  +  getjid (  )  . get node (  )   +  " )  . update status:  method commenced ! " )  ;   }  
protected  string   (  string value )  {  if  ( converter  !  =  null )   {  return converter . convert ( value input format output format )  ;   }  return value ;   }  
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   observable . just ( 1 )  . hide (  )  . flat map ( new  function <  integer  observable source <  ?  extends  object >  >  (  )  {  @ override public  observable source <  ?  extends  object > 
public   (  throwable cause )  {  super ( cause )  ;   }  
@ test public void   (  )  throws  exception  {  final  metrics file <  illumina basecalling metrics  integer >  metrics file = run it ( 1 "151t8b8b151t" new  file ( "testdata / picard / illumina / 151t8b8b151t   cbcl /  data /  intensities /  base calls"
@ override public void   ( jid jid )  {  final  string userid = get transport (  )  . convertjid toid ( jid )  ;   log . debug ( " my space: accept - adding is currently not implemented . "  +  "  cannot accept - add: "  +  userid )  ;   }  
public  date   (  )  {  return lastg mail thread date ;   }  
public void   (  session friend rejected event event )  {   log . debug ( event . to string (  )  )  ;   presence p = new  presence (  presence .  type . unsubscribed )  ;  p . set to ( get session (  )  . getjid (  )  )  ;  p . set from ( get session (  )  . get transport (  )  . convertid tojid ( event . get from (  )  )  )  ;  get session (  )  . get transport (  )  . send packet ( p )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   single . zip (  arrays . as list ( just1 just1 )  null )  . blocking get (  )  ;   }  
@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( "~* #boo '#nope'    %&^& *@ #id" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( "~*  ?  '#nope'    %&^& *@  ? " )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  test observer <  void >  to =  completable . using ( new  c
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;  barejid =  ( jid )  externalizable util . get instance (  )  . read serializable ( in )  ;  affiliation =  ( muc role .  af
private static void   (  string builder buf long period  string name )  {  buf . append ( " < b > " )  ;  buf . append (  data helper . format duration2 ( period )  )  ;  buf . append ( " " )  ;  buf . append ( name )  ;  buf . append ( ": <  / b >  " )  ;   }  
public  policy   (  )  {  return policy ;   }  
public long   (  )  {  return    establish begin ;   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . never (  )  . publish (  )  )  ;   test helper . check disposed (  flowable . never (  )  . publish (  functions .  <  flowable <  object >  > identity (  )  )  )  ;   }  
@ override public int   (  )  {  return users . size (  )  ;   }  
public  string   (  string s cipher text )  {  int n len =  ( s cipher text . length (  )   >  >  1 )  & ~7 ;  if  ( n len  <   blowfishecb . blocksize )  return null ;  byte[] cbciv = new byte[ blowfishcbc . blocksize] ;  int n num of bytes = bin hex to bytes ( s cipher text cbciv 0 0  blowfishcbc . blocksize )  ;  if  ( n num of bytes  <   blowfishcbc . blocksize )  return null ;  n len -  =  blowfishcbc . blocksize ;  if  ( n len  =  =  0 )   {  return "" ;   }  byte[] buf = new byte[n len] ;  n num of bytes = bin hex to bytes ( s cipher text buf  blowfishcbc . blocksize * 2 0 n len )  ;  if  ( n num of bytes  <  n len )   {  return null ;   }  synchronized  ( m   bfish )   {  m   bfish . setcbciv ( cbciv )  ;  m   bfish . decrypt ( buf )  ;   }  int n pad byte =  ( int ) buf[buf . length  -  1] & 0x0ff ;  if  (  ( n pad byte  >  8 )  ||  ( n pad byte  <  0 )  )   {  n pad byte = 0 ;   }  n num of bytes -  = n pad byte ;  if  ( n num of bytes  <  0 )   {  return "" ;   }  return byte array tounc string ( buf 0 n num of bytes )  ;   }  
public  collection <  conversation participation >    ( jid user )  {   user participations user participations = participants . get ( user . to string (  )  )  ;  if  ( user participations  =  =  null )   {  return  collections . empty list (  )  ;   }  return user participations . get participations (  )  ;   }  
  ( int emit delay int count next )  {  this . emit delay = emit delay ;  this . next before failure = new  atomic integer ( count next )  ;   }  
private static int   ( int index )  {  return index ;   }  
public synchronized static  workgroup manager   (  )  {  if  ( instance  =  =  null )   {  instance = new  workgroup manager (  )  ;   }  return instance ;   }  
public  string   (  )  {  synchronized  ( mix manager )   {  return mix manager . to abbreviated string (  )  ;   }   }  
public static long   (  string workgroup name  date start date  date end time )  {  int total requests = get number of requests for workgroup ( workgroup name start date end time )  ;  long wait time = get total wait time for workgroup ( workgroup name start date end time )  ;  if  ( total requests  =  =  0 )   {  return 0 ;   }  return wait time  /  total requests ;   }  
public void   (  string label )  {  long now = get current time (  )  ;  long elapse = now  -  m last split ;   log utils . w (  logging . log   tag " stop watch ( "  +  m name  +  " )  split ( " +  label +  " )  " +  elapse )  ;  m last split = now ;   }  
@ override public void   (  )  {  if  (    initialized &&    is running &&  (  !    disabled ) &&    timestamper thread  !  =  null )     timestamper thread . interrupt (  )  ;   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper boolean delay errors int max concurrency )  {  this . actual = actual ;  this . mapper = mapper ;  this . delay errors = delay errors ;  this . max concurrency = max concurrency ;  this . requested = new  atomic long (  )  ;  this . set = new  composite disposable (  )  ;  this . errors = new  atomic throwable (  )  ;  this . active = new  atomic integer ( 1 )  ;  this . queue = new  atomic reference <  spsc linked array queue < r >  >  (  )  ;   }  
public boolean   (  snark snark )  {  boolean rv = true ;   properties config = get config ( snark )  ;  if  ( config  !  =  null )   {   string s = config . get property ( prop   meta   comments )  ;  if  ( s  !  =  null )  rv =  boolean . parse boolean ( s )  ;   }  return rv ;   }  
@ small test public void   (  )  {   account account1 =  provider test utils . setup account ( "account - default - 1" false m mock context )  ;  account1 . save ( m mock context )  ;  long default account id =  account . get default account id ( m mock c
@ test public void   (  )  {  final int[] call =  { 0 }  ;   maybe . just ( 1 )  . do on success ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  call[0] +  +  ;   }   }   )  . do after terminate 
private void   ( final  subject <  string >  o final  string value )  {  new  thread (  )  {  @ override public void run (  )  {  try  {   thread . sleep ( 500 )  ;   }  catch  (   interrupted exception e )   {   }  o . on next ( value )  ;   }   }   . start (  )  ;   }  
public int   (  agent history model m1  agent history model m2 )  {   string str1 = m1 . get join time (  )  ;   string str2 = m2 . get join time (  )  ;  long i1 =  long . value of ( str1 )  ;  long i2 =  long . value of ( str2 )  ;  if  ( i1  =  =  i2 )   {  return 0 ;   }  if  ( i1  >  i2 )   {  return  - 1 ;   }  else if  ( i1  <  i2 )   {  return 1 ;   }  else  {  return 0 ;   }   }  
private void   (  )  {   string server list =    context . get property ( prop   server   list )  ;  if  (  ( server list  =  =  null )  ||  ( server list . trim (  )  . length (  )   <  =  0 )  )   {  server list = default   server   list ;   string country =    context . get property ( prop   ip   country )  ;  if  ( country  =  =  null )   {  country =  locale . get default (  )  . get country (  )  ;  if  ( country  !  =  null )  country = country . to lower case (  locale . us )  ;   }  if  ( country  !  =  null && country . length (  )   >  0 &&  ! country . equals ( "a1" )  &&  ! country . equals ( "a2" )  )   {     priority servers = new  array list <  list <  string >  >  ( 2 )  ;   list <  string >  p1 = new  array list <  string >  ( 3 )  ;  for  ( int i = 0 ;  i  <  3 ;  i +  +  )   {  p1 . add ( i  +  " . "  +  country +  " . pool . ntp . org" )  ;   }     priority servers . add ( p1 )  ;   string zone =    zones . get zone ( country )  ;  if  ( zone  !  =  null )   {   list <  string >  p2 = new  array list <  string >  ( 3 )  ;  for  ( int i = 0 ;  i  <  3 ;  i +  +  )   {  p2 . add ( i  +  " . "  +  zone +  " . pool . ntp . org" )  ;   }     priority servers . add ( p2 )  ;   }   }  else  {     priority servers = null ;   }   }  else  {     priority servers = null ;   }     servers . clear (  )  ;   string tokenizer tok = new  string tokenizer ( server list "  " )  ;  while  ( tok . has more tokens (  )  )   {   string val = tok . next token (  )  ;  val = val . trim (  )  ;  if  ( val . length (  )   >  0 )     servers . add ( val )  ;   }     query frequency =  math . max ( min   query   frequency    context . get property ( prop   query   frequency default   query   frequency )  )  ;     disabled =    context . get property ( prop   disabled default   disabled )  ;     concurring servers =  math . min ( 4  math . max ( 1    context . get property ( prop   concurring   servers default   concurring   servers )  )  )  ;   }  
protected final sam message sess   (  )  {  return raw session ;   }  
public void   (  hash key )  {  if  (    key  !  =  null )  throw new  illegal state exception (  )  ;     key = key ;   }  
public   (  timeout piped input stream snk )  throws io exception  {  super ( snk )  ;  sink = snk ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test subscriber <  long >  ts1 = new  test subscriber <  long >  (  )  ;   test subscriber <  long >  ts2 = new  test subscriber <  long >  (  )  ;   flowable <  long >  amb =  flowable . timer ( 100  tim
@ before public void   (  )  throws  exception  {  h = db rule . open handle (  )  ;   }  
@ override public void   (  throwable e )  {   rx java plugins . on error ( e )  ;   }  
@ override public  < v > v   (  extension method extension method  config registry config  callable < v >  task )  throws  exception  {  return  jdbi thread locals . invoke in context ( this . extension method extension method  (  )   -  >   jdbi thread l
protected  abstract mark duplicates command line program tester   (  )  {  return new  simple mark duplicates with mate cigar tester (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 0 100000 )  . on error return ( new  function <  throwable  integer >  (  )  {  @ override public  integer apply (   throwabl
public void   (  output stream out )  throws io exception   data format exception  {  if  ( x +  +   =  =  0 )  throw new  data format exception ( "let it enfold you" new  exception (  )  )  ;  else throw new io exception (  )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private void   (  string name  file file )  throws io exception  {     out . write ( " < p >  < h4 > " )  ;     out . write ( name )  ;     out . write ( " <  / h4 > " )  ;  if  ( file  !  =  null && file . exists (  )  )   {   string cert =  file util . read text file ( file . to string (  )   - 1 true )  ;  if  ( cert  !  =  null )   {     out . write ( "\n < textarea readonly = \"readonly\" > \n" )  ;     out . write ( cert )  ;     out . write ( " <  / textarea > \n" )  ;   }  else  {     out . write ( ": read failure" )  ;   }   }  else  {     out . write ( " < p > " )  ;     out . write (    t ( "none" )  )  ;     out . write ( " <  / p > \n" )  ;   }   }  
public   ( tc tracker tr )  {  this . tr = tr ;   }  
@ override public  string   (  )  {  return "tc "  +  get type (  )   +  ' ' +  get name (  )  +  " for " +     tunnel +  ' ' +     state ;   }  
public  sort order   (  )  {  return this . sort order ;   }  
@ test public void   (  )  {   connectable flowable <  integer >  cf =  flowable . just ( 1 )  . compose ( new  flowable transformer <  integer  integer >  (  )  {  @ override public  publisher <  integer >  apply (   flowable <  integer >  v )  {  return
public boolean   ( int tunnel )  {  return get boolean property ( tunnel "should bundle reply info" )  ;   }  
@ after public void   (  )  {  handle . close (  )  ;   }  
public void   (  workgroup workgroup long queueid int position  string query )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( add   routing   rule )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  pstmt . set long ( 2 queueid )  ;  pstmt . set int ( 3 position )  ;  pstmt . set string ( 4 query )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public static long   (  object o )  {   jiveid id = o . get class (  )  . get annotation (  jiveid . class )  ;  if  ( id  =  =  null )   {   log . error ( " annotation  jiveid must be defined in the class "  +  o . get class (  )  )  ;  throw new  illegal argument exception ( " annotation  jiveid must be defined in the class "  +  o . get class (  )  )  ;   }  return nextid ( id . value (  )  )  ;   }  
public static  uri   ( long account id long id )  {  if  ( s uri  =  =  null )   {  s uri =  uri . parse (  attachment . attachment   provider   uri   prefix )  ;   }  return s uri . build upon (  )  . append path (  long . to string ( account id )  )  . append path (  long . to string ( id )  )  . append path ( format   raw )  . build (  )  ;   }  
@ test public void   (  )  {   subscriber <  object >  o =  test helper . mock subscriber (  )  ;  final  list <  integer >  list =  arrays . as list ( 1 2 3 )  ;   function <  integer  list <  integer >  >  func = new  function <  integer  list <  intege
void   (  packet packet )  {  receive packet direct ( packet true )  ;   }  
public  session key   (  )  {  return    currentmac key ;   }  
protected void   (  node node )  throws io exception  {   string text = node . get text (  )  ;  if  ( text  !  =  null && text . length (  )   >  0 )   {  if  ( escape text )   {  text = escape element entities ( text )  ;   }  last output node type =  node . text   node ;  writer . write ( text )  ;   }   }  
public static void   ( final  string[] args )  {  new  make sites only vcf (  )  . instance main with exit ( args )  ;   }  
private static void   (  )  {  while  ( true )   {  int alive = 0 ;  for  ( int i = 0 ;  i  <     routers . size (  )  ;  i +  +  )   {   router r =    routers . get ( i )  ;  if  (  ! r . is alive (  )  )   {     out . println ( " router "  +  i  +  " is dead" )  ;   }  else  {  alive +  +  ;   }   }  if  ( alive  >  0 )   {  try  {   thread . sleep ( 30 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  else  {  break ;   }   }     out . println ( " all routers shut down" )  ;   }  
private  set <  string >    (  )  {   set <  string >  result = known group names from keys ;  if  ( result  =  =  null )   {  synchronized  ( this )   {  result = known group names from keys ;  if  ( result  =  =  null )   {  result = new  hash set <  >  (  )  ;   iterator < k >  iterator = key set (  )  . iterator (  )  ;  while  ( iterator . has next (  )  )   {  k key = iterator . next (  )  ;   group group =  group . resolve from ( key )  ;  if  ( group  !  =  null )   {  result . add ( group . get name (  )  )  ;   }   ;   }  known group names from keys = result . is empty (  )   ?  null : result ;   }   }   }  return result ;   }  
public void   ( long nonce )  {     nonce = nonce ;   }  
@ test public void   (  )  throws  exception  {   signature sgr = new  eddsa engine (  message digest . get instance ( "sha - 512" )  )  ;   eddsa parameter spec spec =  eddsa named curve table . get by name ( "ed25519 - sha - 512" )  ;   eddsa private ke
private static  object   (  string host int port  string user  string pass )  {   object lock = new  object (  )  ;   object old =    locks . put if absent ( user  +  host  +  port lock )  ;  return  ( old  !  =  null )   ?  old : lock ;   }  
private static int   ( byte b )  {  return  ( int ) b & 0xff ;   }  
int   (  )  {  return    mtu ;   }  
@ test public void   (  )  {   jdbi jdbi =  jdbi . create ( "jdbc:h2:mem:test" )  ;   list <  user >  users = jdbi . with handle ( handle  -  >   {  handle . execute ( "create table user  ( id integer primary key  name varchar ) " )  ;  handle . execute (
public   (  date date )  {  this . input = date ;   }  
@ override public boolean   (  )  {  return cancelled ;   }  
@ test public void   (  )  {  assert equals ( 1  observable .  <  integer > empty (  )  . subscribe on (  schedulers . computation (  )  )  . blocking first ( 1 )  . int value (  )  )  ;   }  
public void   (  output stream out )  throws  data format exception  io exception  {  if  (    data  =  =  null )  throw new  data format exception ( " no data to write out" )  ;  if  (    data . length  <  =  keysize   bytes )  out . write (    data )  ;  else out . write (    data 0 keysize   bytes )  ;   }  
@ test public void   (  )  {   scheduler s = new  scheduler (  )  {  @ non null @ override public  worker create worker (  )  {  return new  worker (  )  {  @ non null @ override public  disposable schedule (  @ non null  runnable run  long delay  @ non n
@ override protected void   (  http servlet request srq  http servlet response srs )  throws  servlet exception  io exception  {  byte[] data ;   string name = srq . get parameter ( "plugin" )  ;  data =  nav helper . get binary ( name )  ;  srs . set con
public void   (  )  {  check and rethrow (  )  ;  assert open (  )  ;  this . is closed . set ( true )  ;  try  {  this . reader . join (  )  ;   }  catch  (   interrupted exception ie )   {  throw new  runtime exception ( " interrupted waiting on reader thread . " ie )  ;   }  underlying iterator . close (  )  ;  check and rethrow (  )  ;  this . queue . clear (  )  ;   }  
public   (  )  {   jive globals . migrate property ( property   adminprovider   classname )  ;   jive globals . migrate property ( property   userprovider   classname )  ;  admin provider =  user multi provider . instantiate ( property   adminprovider   classname )  ;  if  ( admin provider  =  =  null )   {  throw new  illegal state exception ( "a class name for the admin provider must be specified via openfire . xml or the system properties using property: "  +  property   adminprovider   classname )  ;   }  user provider =  user multi provider . instantiate ( property   userprovider   classname )  ;  if  ( user provider  =  =  null )   {  throw new  illegal state exception ( "a class name for the user provider must be specified via openfire . xml or the system properties using property: "  +  property   userprovider   classname )  ;   }   }  
public void   (  string value )  {  set header ( http . usn value )  ;   }  
@ override public void   (  string property  map params )  {  if  ( "provider . vcard . class name" . equals ( property )  )   {  initialize ( xmpp server . get instance (  )  )  ;   }   }  
private static int   (  byte buffer buffer )  {  if  ( buffer . remaining (  )   <  3 )   {  throw new  invalid database exception ( " unexpected end of data record when reading metro area" )  ;   }  int metroarea combo = 0 ;  for  ( int j = 0 ;  j  <  3 ;  j +  +  )   {  metroarea combo +  = unsigned byte to int ( buffer . get (  )  )   <  <   ( j * 8 )  ;   }  return metroarea combo ;   }  
@ before public void   (  )  {  template engine =  message format template engine . instance ;  attributes = new  hash map <  >  (  )  ;  ctx = mock (  statement context . class )  ;  when ( ctx . get attributes (  )  )  . then return ( attributes )  ;   
@ suppress warnings ( "rawtypes" )  @ test public void   (  )  {  try  {   rx java plugins . set on flowable assembly ( new  function <  flowable  flowable >  (  )  {  @ override public  flowable apply (   flowable f )  throws  exception  {  throw new  il
 genericgf poly   ( int degree int coefficient )  {  if  ( degree  <  0 )   {  throw new  illegal argument exception (  )  ;   }  if  ( coefficient  =  =  0 )   {  return zero ;   }  int[] coefficients = new int[degree  +  1] ;  coefficients[0] = coefficient ;  return new  genericgf poly ( this coefficients )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  final  single subject <  integer >  ms1 =  single subject . create (  )  ;  final  single subject <  integer >  ms2 =  single subject . create (  )  ;   t
public boolean   (  )  {  return    fast receive &&    router supports fast receive ;   }  
@ test public void   (  )  {   publish processor <  integer >  main =  publish processor . create (  )  ;  final  publish processor <  integer >  inner =  publish processor . create (  )  ;   test subscriber <  integer >  ts = main . concat map eager ( ne
public static  genotype concordance counts   ( final  file truthvcf final  file callvcf final  string call sample final boolean missing sites flag  list <  file >  interval files )  {  final  file output base file name = new  file ( output   data   path "actual gt conc" )  ;  final  file output summary file = new  file ( output base file name . get absolute path (  )   +   genotype concordance . summary   metrics   file   extension )  ;  final  file output details file = new  file ( output base file name . get absolute path (  )   +   genotype concordance . detailed   metrics   file   extension )  ;  output summary file . delete on exit (  )  ;  output details file . delete on exit (  )  ;  final  genotype concordance genotype concordance = new  genotype concordance (  )  ;  genotype concordance . truth   vcf = truthvcf ;  genotype concordance . truth   sample = "na12878" ;  genotype concordance . call   vcf = callvcf ;  genotype concordance . call   sample = call sample ;  genotype concordance . missing   sites   hom   ref = missing sites flag ;  genotype concordance . intervals = interval files ;  genotype concordance . output = output base file name ;   assert . assert equals ( genotype concordance . instance main ( new  string[0] )  0 )  ;  return genotype concordance . get snp counter (  )  ;   }  
public void   (  string msg  throwable t )  {  log ( debug msg t )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
private  composite exception   (  )  {   list <  throwable >  throwables = new  array list <  throwable >  (  )  ;  throwables . add ( ex1 )  ;  throwables . add ( ex2 )  ;  throwables . add ( ex3 )  ;  return new  composite exception ( throwables )  ;   }  
public boolean   (  )  {  return  ( cpuid . getecxcpu flags (  )  &  ( 1  <  <  25 )  )   !  =  0 ;   }  
public   ( final  file file final  string message final  throwable throwable )  {  super ( message throwable )  ;  this . file = file ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {   functions . to function ( new  function4 <  integer  integer  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer t1   int
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    (  bi predicate <  ?  super t  ?  super t >  comparer )  {   object helper . require non null ( comparer "comparer is null" )  ;  return  rx java plu
private void   (  string s )  {  log . error ( s )  ;   system . out . println ( "[error] "  +  s )  ;   }  
@ override protected void   (  map <  string  object >  result )  {  final  account account =  (  account ) result . get ( result   key   account )  ;  if  ( account  !  =  null )   {  if  ( account . m policy  !  =  null )   {  account . m policy . close
protected synchronized boolean   (  string id )  {  return backends . contains key ( id )  ;   }  
@ before public void   (  )  {  b = mock (  byte buffer . class )  ;  buffer = new  synchronized byte buffer ( b )  ;   }  
@ override public  condition   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public static boolean   (  )  {  return  cache factory . is senior cluster member (  )  ;   }  
@ override public boolean   (  string fragment name )  {  return true ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c = error . completable . on error complete (  )  ;  c . blocking await (  )  ;   }  
@ xml element ( name = "property" )  public  list <  system property >    (  )  {  return properties ;   }  
@ override public int   ( int mode )  {  return 0 ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;  nickname =  externalizable util . get instance (  )  . read safeutf ( in )  ;  role =  externalizable util . get instance (
@ override public boolean   (  object object )  {  if  ( this  =  =  object )   {  return true ;   }  if  ( object  !  =  null && object instanceof  group )   {  return name . equals (  (  (  group ) object )  . get name (  )  )  ;   }  else  {  return fa
public synchronized int   (  string message )  {     messages . offer ( new  message (    count +  +  message )  )  ;  while  (    messages . size (  )   >     max size )   {     messages . poll (  )  ;   }  return    count ;   }  
void   ( int index )  {  boolean cancel others = false ;  synchronized  ( this )   {   object[] latest = this . latest ;  if  ( latest  =  =  null )   {  return ;   }  cancel others = latest[index]  =  =  null ;  if  ( cancel others ||  +  + complete  =  =  latest . length )   {  done = true ;   }   }  if  ( cancel others )   {  cancel sources (  )  ;   }  drain (  )  ;   }  
public void   (  string url )  {  event suburi = url ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer subscribe counter = new  atomic integer (  )  ;  final  atomic integer sent event counter = new  atomic integer (  )  ;  do test unsubscribe on nested take and async infini
public void   ( int size )  {  m size = size ;   }  
@ override public void   ( long request size )  {  data store . process request size ( request size )  ;   }  
public void   (  msn messenger messenger  msn group group )  {   log . debug ( "msn:  group add completed: "  +  group )  ;  get session (  )  . store group ( group )  ;  get session (  )  . completed pending group add ( group )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  {  return just1 ;   }   }   ne
@ override public  observable source < t >    (  )  {  return source ;   }  
private static  resource bundle   (  string bun  string lang  string country )  {   string key = bun  +  ' - '  +  lang +  ' - ' +  country ;   resource bundle rv =    bundles . get ( key )  ;  if  ( rv  =  =  null &&  !    missing . contains ( key )  )   {  if  ( "" . equals ( lang )  )   {     missing . add ( key )  ;  return null ;   }  try  {   locale loc ;  if  ( "" . equals ( country )  )  loc = new  locale ( lang )  ;  else loc = new  locale ( lang country )  ;  rv =  resource bundle . get bundle ( bun loc  thread . current thread (  )  . get context class loader (  )  )  ;  if  ( rv  !  =  null )     bundles . put ( key rv )  ;   }  catch  (   missing resource exception e )   {     missing . add ( key )  ;   }   }  return rv ;   }  
@ override public boolean   ( final  object o )  {  if  ( o instanceof  illumina lane tile code )   {  final  illumina lane tile code that =  (  illumina lane tile code ) o ;  return lane number  =  =  that . lane number && tile number  =  =  that . tile 
public static void   (  workgroup workgroup )  {  for  (   workgroup event listener listener : listeners )   {  try  {  listener . workgroup deleting ( workgroup )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
@ override public void   (  )  {  disposed = true ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;   }  
public  map <  string x509 certificate >    (  )  throws  key store exception  {  final  map <  string x509 certificate >  results = new  hash map <  >  (  )  ;  for  (  final  string alias :  collections . list ( store . aliases (  )  )  )   {  final  certificate certificate = store . get certificate ( alias )  ;  if  (  !  ( certificate instanceof x509 certificate )  )   {  continue ;   }  results . put ( alias  ( x509 certificate ) certificate )  ;   }  return results ;   }  
@ override public void   (  throwable e )  {  parent . inner error ( e )  ;   }  
public void   (  )  {   account account1 =  provider test utils . setup account ( "account - hostauth" false m mock context )  ;  account1 . m host auth recv =  provider test utils . setup host auth ( "eas" "account - hostauth - recv" false m mock context )  ;  account1 . m host auth send =  provider test utils . setup host auth ( "foo" "account - hostauth - send" false m mock context )  ;  account1 . save ( m mock context )  ;  assert equals ( "eas"  account . get protocol ( m mock context account1 . m id )  )  ;  assert equals ( "eas" account1 . get protocol ( m mock context )  )  ;   account account2 =  provider test utils . setup account ( "account - nohostauth" false m mock context )  ;  account2 . save ( m mock context )  ;  assert null (  account . get protocol ( m mock context account2 . m id )  )  ;  assert null ( account2 . get protocol ( m mock context )  )  ;  assert null (  account . get protocol ( m mock context 0 )  )  ;   }  
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
public url   (  )  {  return icon ;   }  
private static int   ( int max )  {  long x =  system . nano time (  )  ;  x^ =  ( x  <  <  21 )  ;  x^ =  ( x  >  >  >  35 )  ;  x^ =  ( x  <  <  4 )  ;  return  math . abs (  ( int ) x % max )  ;   }  
@ override public void   (  subscription s )  {  arbiter . set subscription ( s )  ;   }  
public   (  maybe source <  ?  extends t > [] sources )  {  this . sources = sources ;   }  
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   subject <  integer >  ps =  publish subject .  <  integer > create (  )  ;   test observer <  observable <  integer >  >  to = ps . window ( 5  time unit . millisecond
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any )  ;   maybe . merge array (  maybe .  <  integer > error ( new  test exception (  )  )   maybe . 
private void   (  string config  string param )  {  boolean val = get jetty string ( param )   !  =  null ;  changes . put ( config  boolean . to string ( val )  )  ;   }  
public  string   (  )  {  return super . to string (  )   +  " operation: "  +  operation +  " address: " +  address ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public vo
public  robin   ( final int ds index )  {  return robins[ds index] ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . time interval ( null  schedulers . single (  )  )  ;   }  
@ test public void   (  )  {   flowable . create ( source  backpressure strategy . missing )  . subscribe ( ts )  ;  source . on next ( 1 )  ;  source . on next ( 2 )  ;  source . on error ( new  test exception (  )  )  ;  ts . request ( 1 )  ;  ts . asse
public  string   (  )  {  return sid ;   }  
@ sql query ( "select id  name from something where  ( id  name )  in  (  < keys >  ) " )   list <  something >    ( @ bind bean list ( property names =  { "id" "name" }  )   iterator <  something key >  keys )  ;  
@ override protected  per unit metric collector <  insert size metrics  integer  insert size collector args >    ( final  string sample final  string library final  string read group )  {  return new  per unit insert size metrics collector ( sample librar
@ test public void   (  )  {   observable . from callable ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   )  . take ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
public   (  stats engine engine )  {  this . engine = engine ;   }  
public char   (  )  {  int bw lim =  math . min (    context . bandwidth limiter (  )  . get inboundk bytes per second (  )     context . bandwidth limiter (  )  . get outboundk bytes per second (  )  )  ;  bw lim =  ( int )  ( bw lim * get share percentage (  )  )  ;   string force =    context . get property ( prop   force   bwclass )  ;  if  ( force  !  =  null && force . length (  )   >  0 )   {  return force . char at ( 0 )  ;   }  else if  ( bw lim  <  min   bw   l )   {  return capability   bw12 ;   }  else if  ( bw lim  <  =  min   bw   m )   {  return capability   bw32 ;   }  else if  ( bw lim  <  =  min   bw   n )   {  return capability   bw64 ;   }  else if  ( bw lim  <  =  min   bw   o )   {  return capability   bw128 ;   }  else if  ( bw lim  <  =  min   bw   p )   {  return capability   bw256 ;   }  else if  ( bw lim  <  =  min   bw   x )   {  return capability   bw512 ;   }  else  {  return capability   bw   unlimited ;   }   }  
@ test ( timeout = 60000 )  public void   (  )  throws  interrupted exception  {   worker w =  schedulers . io (  )  . create worker (  )  ;  try  {   executor scheduler test . test cancelled retention ( w false )  ;   }  finally  {  w . dispose (  )  ;  
public int   (  )  {   local map stats stats = map . get local map stats (  )  ;  return  ( int )  ( stats . get owned entry memory cost (  )   +  stats . get backup entry memory cost (  )  )  ;   }  
  (  single observer <  ?  super t >  actual  single source < t >  source )  {  this . actual = actual ;  this . source = source ;   }  
void   (  throwable t )  {  if  ( is disposed (  )  )   {   rx java plugins . on error ( t )  ;   }  else  {  actual . on error ( t )  ;   }   }  
private void   (  )  {   account setup incoming fragment f =  (  account setup incoming fragment ) get content fragment (  )  ;  f . collect user input (  )  ;   }  
@ test public void   (  )  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  observer . on complete (  )
public  string   (  )  {  return null ;   }  
public void   (  msn messenger messenger  msn contact friend )  {   log . debug ( "msn:  contact removed me: "  +  friend . get friendly name (  )  )  ;   presence p = new  presence (  )  ;  p . set type (  presence .  type . unsubscribe )  ;  p . set to ( get session (  )  . getjid (  )  )  ;  p . set from ( get session (  )  . get transport (  )  . convertid tojid ( friend . get email (  )  . to string (  )  )  )  ;  get session (  )  . get transport (  )  . send packet ( p )  ;   }  
public void   ( final sam record rec )  {  if  ( restore   original   qualities )   {  final byte[] oq = rec . get original base qualities (  )  ;  if  ( oq  !  =  null )   {  rec . set base qualities ( oq )  ;  rec . set original base qualities ( null )  ;   }   }  if  ( remove   duplicate   information )   {  rec . set duplicate read flag ( false )  ;   }  if  ( remove   alignment   information )   {  if  ( rec . get read negative strand flag (  )  )   {  rec . reverse complement ( true )  ;  rec . set read negative strand flag ( false )  ;   }  rec . set reference index ( sam record . no   alignment   reference   index )  ;  rec . set alignment start ( sam record . no   alignment   start )  ;  rec . set cigar string ( sam record . no   alignment   cigar )  ;  rec . set mapping quality ( sam record . no   mapping   quality )  ;  rec . set inferred insert size ( 0 )  ;  rec . set not primary alignment flag ( false )  ;  rec . set proper pair flag ( false )  ;  rec . set read unmapped flag ( true )  ;  rec . set mate alignment start ( sam record . no   alignment   start )  ;  rec . set mate negative strand flag ( false )  ;  rec . set mate reference index ( sam record . no   alignment   reference   index )  ;  rec . set mate unmapped flag ( rec . get read paired flag (  )  )  ;  attribute   to   clear . for each ( tag  -  >  rec . set attribute ( tag null )  )  ;   }   }  
@ override public void   (  print writer pw )  {  super . print stack trace ( pw )  ;  if  ( nested throwable  !  =  null )   {  nested throwable . print stack trace ( pw )  ;   }   }  
@ test public void   (  )  {  int n = 10000 ;   list <  flowable <  integer >  >  source list = new  array list <  flowable <  integer >  >  ( n )  ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {  source list . add (  flowable . just ( i )  )  ;   }   ite
private static int   ( final byte[][] barcode bytes final byte[][] read subsequence final byte[][] qualities final int minimum base quality )  {  int num mismatches = 0 ;  for  ( int j = 0 ;  j  <  barcode bytes . length ;  j +  +  )   {  for  ( int i = 0 ;   ( i  <  barcode bytes[j] . length && read subsequence[j] . length  >  i )  ;   +  + i )   {  if  (  sequence util . is no call ( read subsequence[j][i] )  )   {  continue ;   }  if  (  !  sequence util . bases equal ( barcode bytes[j][i] read subsequence[j][i] )  )   {   +  + num mismatches ;  continue ;   }  if  ( qualities  !  =  null && qualities[j][i]  <  minimum base quality )   {   +  + num mismatches ;   }   }   }  return num mismatches ;   }  
@ override public  list <  string >    ( final  list <  integer >  expected tiles final int[] expected cycles )  {  final  list <  string >  failures = new  linked list <  string >  (  )  ;  final  map <  integer  long >  tile to file length map = new  ha
@ test @ ignore ( " subscribe should not throw" )  public void   (  )  {   test observer <  string >  to = new  test observer <  string >  (  )  ;   observable <  string >  o1 =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ 
@ override public void   (  )  throws  exception  {  super . set up (  )  ;  m mock context = new  mock context2 ( get mock context (  )  get context (  )  )  ;  m provider = get provider (  )  ;  m provider . inject attachment service ( mock   attachment
@ override public void   (  user new user  map <  string  object >  params )  {  jid new userjid = server . createjid ( new user . get username (  )  null )  ;  for  (   group group : get public shared groups (  )  )   {   collection < jid >  users = new 
@ test public void   (  )  throws  exception  {  try  (  handle h = db . open handle (  )  )  {  assert that ( h . is read only (  )  )  . is false (  )  ;  assert that ( h . get connection (  )  . is read only (  )  )  . is false (  )  ;  h . set read on
public   (  maybe source < t >  source  action on finally )  {  super ( source )  ;  this . on finally = on finally ;   }  
int   ( int arc index int ds index )  throws  rrd exception  {   node cdp node =  util .  xml . get first child node ( arc nodes[arc index] "cdp   prep" )  ;   node[] ds nodes =  util .  xml . get child nodes ( cdp node "ds" )  ;  return  util .  xml . get child value as int ( ds nodes[ds index] "unknown   datapoints" )  ;   }  
public void   ( jid jid )  throws  user not found exception  {   collection <  registration >  registrations =  registration manager . get instance (  )  . get registrations ( jid parent . transport type )  ;  if  ( registrations . is empty (  )  )   {  throw new  user not found exception ( " user was not registered . " )  ;   }  try  {   transport session session = parent . session manager . get session ( jid )  ;  if  ( session . is logged in (  )  )   {  parent . registration logged out ( session )  ;   }  parent . session manager . remove session ( jid )  ;   }  catch  (   not found exception e )   {   }  for  (  final  registration reg : registrations )   {   registration manager . get instance (  )  . delete registration ( reg )  ;   }  try  {  parent . clean up roster ( jid false true )  ;   }  catch  (   user not found exception e )   {  throw new  user not found exception ( " unable to find roster . " )  ;   }   }  
@ test public void   (  )  {   completable . error ( new  test exception (  )  )  . hide (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
public void   (  )  {   host auth ha = new  host auth (  )  ;  ha . set connection ( "imap" "server" 123 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "imap" "server"  - 1 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "pop3" "server" 123 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "pop3" "server"  - 1 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "eas" "server" 123 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "eas" "server"  - 1 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "smtp" "server" 123 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "smtp" "server"  - 1 0 )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown  host auth . flag   ssl )  ;  assert equals (  host auth . flag   ssl ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown  host auth . flag   ssl |  host auth . flag   trust   all )  ;  assert equals (  host auth . flag   ssl |  host auth . flag   trust   all ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown  host auth . flag   tls )  ;  assert equals (  host auth . flag   tls ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown  host auth . flag   tls |  host auth . flag   trust   all )  ;  assert equals (  host auth . flag   tls |  host auth . flag   trust   all ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown  host auth . flag   authenticate )  ;  assert equals ( 0 ha . m flags )  ;  ha . set connection ( "imap" "server"  host auth . port   unknown 0xfffffff4 )  ;  assert equals ( 0x10 ha . m flags )  ;   }  
public void   (  client connection runner runner )  {  synchronized  (    pending runners )   {     pending runners . remove ( runner )  ;   }   list <  session id >  ids = runner . get session ids (  )  ;   list <  destination >  dests = runner . get destinations (  )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " unregistering  ( dropping )  a client connection with ids: "  +  ids )  ;  synchronized  (    runners )   {  for  (   session id id : ids )   {     runner session ids . remove ( id )  ;   }  for  (   destination dest : dests )   {     runners . remove ( dest )  ;     runners by hash . remove ( dest . calculate hash (  )  )  ;   }  for  (  iterator <  client connection runner >  iter =    runners . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   client connection runner r = iter . next (  )  ;  if  ( r . equals ( runner )  )  iter . remove (  )  ;   }  for  (  iterator <  client connection runner >  iter =    runners by hash . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   client connection runner r = iter . next (  )  ;  if  ( r . equals ( runner )  )  iter . remove (  )  ;   }   }   }  
@ override public void   (  throwable e )  {  child . on error ( e )  ;   }  
@ override protected void   (  observer <  ?  super  integer >  s )  {  assert false (  (  (  disposable ) s )  . is disposed (  )  )  ;  s . on subscribe (  disposables . empty (  )  )  ;  sub[count +  + ] = s ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   script script = h . create script ( get resource on classpath ( "script / insert - with - string - semicolons . sql" )  )  ;  script . execute (  )  ;  assert tha
public void   ( boolean accept )  {  final boolean old value = verify certificate validity (  )  ;   jive globals . set property ( type . get prefix (  )   +  "certificate . accept - selfsigned"  boolean . to string ( accept )  )  ;  if  ( old value  =  =  accept )   {   log . debug ( " ignoring self - signed certificate acceptance policy change request  ( to ' {  } ' ) : listener already in this state . " accept )  ;  return ;   }   log . debug ( " changing self - signed certificate acceptance policy from ' {  } ' to ' {  } ' . " old value accept )  ;  restart (  )  ;   }  
@ test public void   (  )  throws io exception  {  byte byte val = 1 ;  buffer . put ( byte val )  ;  verify ( b )  . put ( eq ( byte val )  )  ;   }  
public static void   ( muc room room )  {  if  (  ! room . is persistent (  )  ||  ! room . was saved todb (  )  )   {  return ;   }   connection con = null ;   prepared statement pstmt = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;  pstmt = con . prepare statement ( delete   affiliations )  ;  pstmt . set long ( 1 room . getid (  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   members )  ;  pstmt . set long ( 1 room . getid (  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   room )  ;  pstmt . set long ( 1 room . getid (  )  )  ;  pstmt . execute update (  )  ;  room . set saved todb ( false )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;  abort transaction = true ;   }  finally  {   db connection manager . close statement ( pstmt )  ;   db connection manager . close transaction connection ( con abort transaction )  ;   }   }  
@ override public long   (  )  {  return max lifetime ;   }  
public  string   (  )  {  return  jive globals . get property ( jn   public   ip   property  localip resolver . get localip (  )  )  ;   }  
@ override protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  final  reference sequence file ref =  reference sequence file factory . get reference sequence file ( input )  ;  final  r
@ test public void   (  )  {   scalar ops sc = new  big integer scalar ops ( ed25519 field new  big integer ( "5" )  )  ;  assert that ( sc . multiply and add ( new byte[] { 7 }  new byte[] { 2 }  new byte[] { 5 }  )  is ( equal to (  utils . hex to bytes
@ override public boolean   ( boolean may interrupt if running )  {  for  (  ;   ;   )   {   disposable a = s . get (  )  ;  if  ( a  =  =  this || a  =  =   disposable helper . disposed )   {  return false ;   }  if  ( s . compare and set ( a  disposable
@ override public boolean   (  )  {  return cancelled ;   }  
@ test public void   (  )  {   test helper . check double on subscribe completable to flowable ( new  function <  completable  publisher <  ?  >  >  (  )  {  @ override public  publisher <  ?  >  apply (   completable c )  throws  exception  {  return c .
@ override public boolean   (  )  {  return true ;   }  
private void   ( boolean is verified )  {  if  (    prev encrypted  !  =  null &&    prev encrypted . length  =  =  aes   size )   simple byte cache . release (    prev encrypted )  ;  if  (  ! is verified )   simple byte cache . release (    cur encrypted )  ;   simple byte cache . release (    cur decrypted )  ;   simple byte cache . release (    hx   xor   bob ident hash )  ;  if  (    dh . get peer public value (  )   =  =  null )     transport . return unused (    dh )  ;  if  (    con . is inbound (  )  )   simple byte cache . release (    x )  ;  else  simple byte cache . release (    y )  ;   }  
public  string   (  )  {  load config (  )  ;   string url = base   theme   path ;   string theme =    context . get property ( rc   prop   theme   name default   theme )  ;  theme = properties . get property ( prop   theme   name theme )  ;   string[] themes = get themes (  )  ;  boolean theme exists = false ;  for  ( int i = 0 ;  i  <  themes . length ;  i +  +  )   {  if  ( themes[i] . equals ( theme )  )  theme exists = true ;   }  if  (  ! theme exists )  theme = default   theme ;  url +  = theme  +  " / " ;  return url ;   }  
@ test public void   (  )  {   future task <  object >  ft = new  future task <  object >  (  functions . empty   runnable null )  ;   disposable d =  disposables . from future ( ft true )  ;  assert false ( d . is disposed (  )  )  ;  d . dispose (  )  ;
  (  string name  string path  string ds name  string consol func  string backend )  {  super ( name )  ;  this . path = path ;  this . ds name = ds name ;  this . consol fun = consol func ;  this . backend = backend ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  start =  publish processor . create (  )  ;  final  publish processor <  integer >  end =  publish processor . cr
public static void   (  node node )  {   connection con = null ;   prepared statement pstmt = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;  pstmt = con . prepare statement ( update   node )  ;  pstmt . set string ( 1  string utils . date to millis ( node . get modification date (  )  )  )  ;  pstmt . set string ( 2 node . get parent (  )   !  =  null  ?  encode nodeid ( node . get parent (  )  . get nodeid (  )  )  : null )  ;  pstmt . set int ( 3  ( node . is payload delivered (  )   ?  1 : 0 )  )  ;  if  (  ! node . is collection node (  )  )   {  pstmt . set int ( 4  (  (  leaf node ) node )  . get max payload size (  )  )  ;  pstmt . set int ( 5  (  (  (  leaf node ) node )  . is persist published items (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 6  (  (  leaf node ) node )  . get max published items (  )  )  ;   }  else  {  pstmt . set int ( 4 0 )  ;  pstmt . set int ( 5 0 )  ;  pstmt . set int ( 6 0 )  ;   }  pstmt . set int ( 7  ( node . is notified of config changes (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 8  ( node . is notified of delete (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 9  ( node . is notified of retract (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 10  ( node . is presence based delivery (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 11  ( node . is send item subscribe (  )   ?  1 : 0 )  )  ;  pstmt . set string ( 12 node . get publisher model (  )  . get name (  )  )  ;  pstmt . set int ( 13  ( node . is subscription enabled (  )   ?  1 : 0 )  )  ;  pstmt . set int ( 14  ( node . is subscription configuration required (  )   ?  1 : 0 )  )  ;  pstmt . set string ( 15 node . get access model (  )  . get name (  )  )  ;  pstmt . set string ( 16 node . get payload type (  )  )  ;  pstmt . set string ( 17 node . get bodyxslt (  )  )  ;  pstmt . set string ( 18 node . get dataformxslt (  )  )  ;  pstmt . set string ( 19 node . get description (  )  )  ;  pstmt . set string ( 20 node . get language (  )  )  ;  pstmt . set string ( 21 node . get name (  )  )  ;  if  ( node . get reply policy (  )   !  =  null )   {  pstmt . set string ( 22 node . get reply policy (  )  . name (  )  )  ;   }  else  {  pstmt . set string ( 22 null )  ;   }  if  ( node . is collection node (  )  )   {  pstmt . set string ( 23  (  (  collection node ) node )  . get association policy (  )  . name (  )  )  ;  pstmt . set int ( 24  (  (  collection node ) node )  . get max leaf nodes (  )  )  ;   }  else  {  pstmt . set string ( 23 null )  ;  pstmt . set int ( 24 0 )  ;   }  pstmt . set string ( 25 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 26 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   node   jids )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   node   groups )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;  save associated elements ( con node )  ;   }  catch  (  sql exception sqle )   {  log . error ( sqle . get message (  )  sqle )  ;  abort transaction = true ;   }  finally  {   db connection manager . close statement ( pstmt )  ;   db connection manager . close transaction connection ( con abort transaction )  ;   }   }  
public static boolean   (  node node )  {   connection con = null ;   prepared statement pstmt = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;  pstmt = con . prepare statement ( delete   node )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   node   jids )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   node   groups )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  if  ( node instanceof  leaf node )   {  purge node (  (  leaf node ) node con )  ;   }  pstmt = con . prepare statement ( delete   affiliations )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   db connection manager . fastclose stmt ( pstmt )  ;  pstmt = con . prepare statement ( delete   subscriptions )  ;  pstmt . set string ( 1 node . get service (  )  . get serviceid (  )  )  ;  pstmt . set string ( 2 encode nodeid ( node . get nodeid (  )  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {  log . error ( sqle . get message (  )  sqle )  ;  abort transaction = true ;   }  finally  {   db connection manager . close statement ( pstmt )  ;   db connection manager . close transaction connection ( con abort transaction )  ;   }  return  ! abort transaction ;   }  
public void   ( int dlsr )  {  rtcp data[48] =  ( byte )  (  ( dlsr  >  >  24 )  & 0xff )  ;  rtcp data[49] =  ( byte )  (  ( dlsr  >  >  16 )  & 0xff )  ;  rtcp data[50] =  ( byte )  (  ( dlsr  >  >  8 )  & 0xff )  ;  rtcp data[51] =  ( byte )  ( dlsr & 0xff )  ;   }  
@ override public  datastore   (  )  {  return new eh cache datastore ( cache )  ;   }  
private boolean   (  connection con  string schema key int required version  resource loader resource loader )  throws  exception  {  int current version =  - 1 ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  pstmt = con . prepare statement ( check   version )  ;  pstmt . set string ( 1 schema key )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  current version = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqle )   {   log . debug ( " schema manager:  error verifying "  +  schema key  +  " version  probably ignorable . " sqle )  ;   db connection manager . close statement ( rs pstmt )  ;  if  ( schema key . equals ( "openfire" )  )   {  try  {  pstmt = con . prepare statement ( check   version   jive )  ;  pstmt . set string ( 1 schema key )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  current version = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqlea )   {   log . debug ( " schema manager:  error verifying "  +  schema key  +  " version  probably ignorable . " sqlea )  ;   db connection manager . close statement ( rs pstmt )  ;  try  {  pstmt = con . prepare statement ( check   version   old )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  current version = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqle2 )   {   log . debug ( " schema manager:  error verifying "  +  schema key  +  " version  probably ignorable" sqle2 )  ;   }   }   }   }  finally  {   db connection manager . close statement ( rs pstmt )  ;   }  if  ( current version  >  =  required version )   {  return true ;   }  else if  ( current version  =  =   - 1 )   {   log . info (  locale utils . get localized string ( "upgrade . database . missing   schema"  arrays . as list ( schema key )  )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . missing   schema"  arrays . as list ( schema key )  )  )  ;   string resource name = schema key  +  "   "  +   db connection manager . get database type (  )  +  " . sql" ;  try  (  input stream resource = resource loader . load resource ( resource name )  )  {  if  ( resource  =  =  null )   {  return false ;   }  executesql script ( con resource  ! schema key . equals ( "openfire" )  &&  ! schema key . equals ( "wildfire" )  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return false ;   }   log . info (  locale utils . get localized string ( "upgrade . database . success" )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . success" )  )  ;  return true ;   }  else  {   log . info (  locale utils . get localized string ( "upgrade . database . old   schema"  arrays . as list ( current version schema key required version )  )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . old   schema"  arrays . as list ( current version schema key required version )  )  )  ;  if  (  db connection manager . get database type (  )   =  =   db connection manager .  database type . unknown )   {   log . info (  locale utils . get localized string ( "upgrade . database . unknown   db" )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . unknown   db" )  )  ;  return false ;   }  else if  (  db connection manager . get database type (  )   =  =   db connection manager .  database type . interbase )   {   log . info (  locale utils . get localized string ( "upgrade . database . interbase   db" )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . interbase   db" )  )  ;  return false ;   }  for  ( int i = current version  +  1 ;  i  <  =  required version ;  i +  +  )   {  try  (  input stream resource = get upgrade resource ( resource loader i schema key )  )  {  try  {  if  ( i  =  =  21 && schema key . equals ( "openfire" )  )   {  of33 . execute fix ( con )  ;   }  if  ( i  =  =  27 && schema key . equals ( "openfire" )  )   {  of1515 . execute fix (  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return false ;   }  if  ( resource  =  =  null )   {  continue ;   }  executesql script ( con resource  ! schema key . equals ( "openfire" )  &&  ! schema key . equals ( "wildfire" )  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return false ;   }   }   log . info (  locale utils . get localized string ( "upgrade . database . success" )  )  ;   system . out . println (  locale utils . get localized string ( "upgrade . database . success" )  )  ;  return true ;   }   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  serialized subscriber < t >  ( s )  )  ;   }  
@ nullable public t   (  )  {   object o = value . get (  )  ;  if  (  notification lite . is complete ( o )  ||  notification lite . is error ( o )  )   {  return null ;   }  return  notification lite . get value ( o )  ;   }  
@ override public void   (  )  {  total   mendelian   violations = num   diploid   denovo  +  num   homvar   homvar   het  +  num   homref   homvar   hom +  num   hom   het   hom +  num   haploid   denovo +  num   haploid   other +  num   other ;   }  
public  string   (  )  {  return forwarding call id ;   }  
public  inet socket address   (  )  {  return addressa    ;   }  
public static void   (  peer peer int num  comment set comments )  {  int to send =  math . min ( num comments . size (  )  )  ;  if  ( to send  <  =  0 )  return ;   map <  string  object >  map = new  hash map <  string  object >  (  )  ;  map . put ( "msg   type"  integer . value of ( 1 )  )  ;   list <  object >  lc = new  array list <  object >  ( to send )  ;  long now = i2p app context . get global context (  )  . clock (  )  . now (  )  ;  int i = 0 ;  for  (   comment c : comments )   {  if  ( i +  +   >  =  to send )  break ;   map <  string  object >  mc = new  hash map <  string  object >  (  )  ;   string s = c . get name (  )  ;  mc . put ( "owner" s  !  =  null  ?  s : "" )  ;  s = c . get text (  )  ;  mc . put ( "text" s  !  =  null  ?  s : "" )  ;  mc . put ( "like"  integer . value of ( c . get rating (  )  )  )  ;  mc . put ( "timestamp"  long . value of (  ( now  -  c . get time (  )  )   /  1000l )  )  ;  lc . add ( mc )  ;   }  map . put ( "comments" lc )  ;  byte[] payload = b encoder . bencode ( map )  ;  try  {  int his msg code = peer . get handshake map (  )  . get ( "m" )  . get map (  )  . get ( type   comment )  . get int (  )  ;  peer . send extension ( his msg code payload )  ;   }  catch  (   exception e )   {   }   }  
@ test public void   (  )  {   flowable . range ( 1 1024 )  . concat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  if  ( v % 2  =  = 
private int   (  )  {  int iratek bps =    context . bandwidth limiter (  )  . get inboundk bytes per second (  )  ;  int oratek bps =    context . bandwidth limiter (  )  . get outboundk bytes per second (  )  ;  double pct =    context . router (  )  . get share percentage (  )  ;  if  ( iratek bps  <  0 || oratek bps  <  0 )  return  config net helper . default   share   kbps ;  return  ( int )  ( pct *  math . min ( iratek bps oratek bps )  )  ;   }  
@ override public void   (  session data data  element command )  {   element note = command . add element ( "note" )  ;  if  (  group manager . get instance (  )  . is read only (  )  )   {  note . add attribute ( "type" "error" )  ;  note . set text ( "
public static  < t u > void   (  function <  maybe < t >   ?  extends  single source < u >  >  composer )  {   publish processor < t >  pp =  publish processor . create (  )  ;   test subscriber < u >  ts = new  test subscriber < u >  (  )  ;  try  {  new  single to flowable < u >  ( composer . apply ( pp . single element (  )  )  )  . subscribe ( ts )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert true ( pp . has subscribers (  )  )  ;  ts . cancel (  )  ;  assert false ( pp . has subscribers (  )  )  ;   }  
private int   ( int range )  {  if  ( b   value  <  =  3 )   {  for  ( int i =    buckets . size (  )   -  1 ;  i  >  =  0 ;  i -  -  )   {  k bucket < t >  b =    buckets . get ( i )  ;  if  ( range  >  =  b . get range begin (  )  && range  <  =  b . get range end (  )  )  return i ;   }  return  - 1 ;   }  else  {  k bucket < t >  dummy = new  dummy bucket < t >  ( range )  ;  return  collections . binary search (    buckets dummy new  bucket comparator < t >  (  )  )  ;   }   }  
@ test ( expected =  thread death . class )  public void   (  )  {   observable . just ( 1 )  . subscribe ( new  observer <  integer >  (  )  {  @ override public void on subscribe (   disposable d )  {   }  @ override public void on complete (  )  {   } 
@ override protected  object   (  element element )  throws  exception  {  if  ( onhook   qname . equals ( element . getq name (  )  )  )   {  return build on hook command ( element )  ;   }  else if  ( offhook   qname . equals ( element . getq name (  ) 
public int   (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( count   log   entries )  ;  rs = pstmt . execute query (  )  ;  rs . next (  )  ;  return rs . get int ( 1 )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return  - 1 ;   }  
public static  string   (  )  {  return inet salt ;   }  
@ override public boolean   (  string username  string principal )  {  return get authorized ( username )  . contains ( principal )  ;   }  
public double   (  )  {  return last ;   }  
private void   ( jid unsubscriber jid service owner )  {  pep service pep service = pep service manager . getpep service ( service owner . to barejid (  )  )  ;  if  ( pep service  =  =  null )   {  return ;   }   collection node root node = pep service . get root collection node (  )  ;   node subscription node subscription = root node . get subscription ( unsubscriber )  ;  if  ( node subscription  !  =  null )   {  root node . cancel subscription ( node subscription )  ;   }   }  
public  string   (  )  throws  exception  {  if  ( actual server  =  =  null )   {  return " java vm" ;   }  return actual server . get name (  )  ;   }  
@ test public void   (  )  throws  exception  {   something result = handle . create query ( select   by   name )  . bind ( "name"  optional . of ( "brian" )  )  . map to bean (  something . class )  . find only (  )  ;  assert that ( result )  . is equal
@ override public void   (  object t )  {  bh . consume ( t )  ;   blackhole . consumecpu ( cycles )  ;   }  
@ deprecated public void   (  set <  session tag >  tags )  {  if  ( tags  !  =  null &&  ! tags . is empty (  )  )     log . error ( " who is sending tags thru the streaming lib ?  "  +  tags . size (  )  )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . map ( new  function <  integer  string >  (  )  {  @ override public  string apply (   integer v )  throws  exception  {  return v . to string (  )  ;   }   }   )  . test (  )  . assert result ( "1" )  
@ override public void   (  )  {   disposable helper . replace ( this scheduler . schedule direct ( this )  )  ;   }  
@ test public void   (  )  {  second test counter manager . check out of bounds ( 11 )  ;   assert . assert equals ( 11 second test counter manager . get offset (  )  " after rebase offset must be new int" )  ;   }  
@ override public void   (  string username  string name )  throws  user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 100 2 100 )  )  . test (  )  . assert failure and message (  test exception . class "has next (  ) " 0 )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  maybe < t >    (  single source < t >  single source )  {   object helper . require non null ( single source "single source is null" )  ;  return  rx java plugin
private void   (  )  {  final long now =  system . current time millis (  )  ;  if  ( now  >  timestamp  +  unit )   {  count = 0 ;  timestamp = now ;   }   }  
@ test public void   (  )  {   test helper . check utility class (  half serializer . class )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . observe on (  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result (  )  ;   }  
public   (  matcher m )  {  life cycle modifier = get group value ( m lifecycle   group   index )  ;  status codes = get group value ( m status   code   index )  ;  variable = get group value ( m variable   index )  ;  variable argument separator = get group value ( m var   arg   separator   index )  ;  arguments = parse arguments ( get group value ( m arguments   index )  )  ;  entity = get group value ( m entity   index )  ;   }  
@ test public void   (  )  throws  exception  {  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  h . create update ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  . execute (  )  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   subscriber wrapper <  integer >  wrapper = new  subscriber wrapper <  integer >  ( ts )  ;  new  flowable <  integer >  (  )  {  @ override prot
@ test public void   (  )  {   behavior processor <  integer >  async =  behavior processor . create (  )  ;  async . on next ( 1 )  ;  async . on complete (  )  ;   flowable processor <  integer >  serial = async . to serialized (  )  ;  assert false ( s
private  tatic  string[] s (  string .  .  .  strings )  {  return strings ;   }  
public  string   (  )  {  return " outbound client message send timeout" ;   }  
public boolean   (  )  {  return successfull ;   }  
public void   (  )  {  room cache . clear (  )  ;   }  
public  illumina file map   ( final  list <  integer >  tiles to keep )  {  final  illumina file map file map = new  illumina file map (  )  ;  for  (  final  integer tile : tiles to keep )   {  final  file file = this . get ( tile )  ;  if  ( file  !  =  null )   {  file map . put ( tile file )  ;   }   }  return file map ;   }  
@ override public void   ( byte val[] )  {   map <  string byte[] >  props =  collections . singleton map ( seed val )  ;  init ( props )  ;   }  
void   (  string payloadxml )  {  this . payloadxml = payloadxml ;  this . payload = null ;   }  
public  string   ( final  string column label )  {  final  integer key = column label indices . get ( column label )  ;  if  ( key  =  =  null )  throw new  no such element exception (  string . format ( "column %s in %s" column label parser . get file name (  )  )  )  ;  return fields[key] ;   }  
public void   ( iq packet  workgroup workgroup )  {  iq reply = iq . create resultiq ( packet )  ;   form manager form manager =  form manager . get instance (  )  ;   data form data form = form manager . get data form ( workgroup )  ;  if  ( data form  =  =  null )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  workgroup . send ( reply )  ;  return ;   }   element iq = packet . get child element (  )  ;  if  ( iq . elements (  )  . is empty (  )  )   {  reply . set child element ( iq . create copy (  )  )  ;  reply . add extension ( data form . create copy (  )  )  ;  workgroup . send ( reply )  ;   }   }  
public static  < t > void   (  subject < t >  p t .  .  .  values )  {  for  (  t v : values )   {  p . on next ( v )  ;   }  p . on complete (  )  ;   }  
@ benchmark public void   (  blackhole bh )  {  source . subscribe ( new  external consumer ( bh cpu )  )  ;   }  
protected   ( i2p app context ctx i2p session session )  {     context = ctx ;     session = session ;     log = ctx . log manager (  )  . get log ( this . get class (  )  )  ;   }  
@ override public void   (  throwable t )  {  error = t ;  drain (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable observable <  integer >  co =  observable . range ( 1 1000 )  . replay (  )  ;  final  test observer <  integer >  to1 = new
void   (  )  {  if  (  ! compare and set ( false true )  )   {  return ;   }  final  observer <  ?  super t >  a = actual ;  final  spsc linked array queue <  object >  q = queue ;  final boolean delay error = this . delay error ;  for  (  ;   ;   )   {  if  ( cancelled )   {  q . clear (  )  ;  return ;   }  if  (  ! delay error )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  q . clear (  )  ;  a . on error ( ex )  ;  return ;   }   }   object ts = q . poll (  )  ;  boolean empty = ts  =  =  null ;  if  ( empty )   {   throwable ex = error ;  if  ( ex  !  =  null )   {  a . on error ( ex )  ;   }  else  {  a . on complete (  )  ;   }  return ;   }  @ suppress warnings ( "unchecked" )  t o =  ( t ) q . poll (  )  ;  if  (  (  long ) ts  <  scheduler . now ( unit )   -  time )   {  continue ;   }  a . on next ( o )  ;   }   }  
public void   (  string uid  string parameter  string value )  {  loginfo ( " voice bridge manage participant" )  ;  if  ( call partipants . contains key ( uid )   =  =  false )   {  call partipants . put ( uid new  call participant (  )  )  ;  report info ( " call  participant "  +  uid  +  " created" )  ;   }   call participant cp = call partipants . get ( uid )  ;  try  {  parse call parameters ( parameter value cp uid )  ;  report info ( "manage call participant processing "  +  parameter  +  " value: " +  value )  ;   }  catch  (   exception e )   {  report error ( e . to string (  )  )  ;   }   }  
private void   (  )  {  synchronized  ( join confirmation listeners )   {  for  ( int i = 0 ;  i  <  join confirmation listeners . size (  )  ;  i +  +  )   {   join confirmation listener listener =  (  join confirmation listener ) join confirmation listeners . get ( i )  ;  listener . join confirmation (  )  ;  remove join confirmation listener ( listener )  ;   }   }   }  
@ override public int   (  session data data )  {  return 1 ;   }  
static boolean   (  throwable error )  {  if  ( error instanceof  on error not implemented exception )   {  return true ;   }  if  ( error instanceof  missing backpressure exception )   {  return true ;   }  if  ( error instanceof  illegal state exception )   {  return true ;   }  if  ( error instanceof  null pointer exception )   {  return true ;   }  if  ( error instanceof  illegal argument exception )   {  return true ;   }  if  ( error instanceof  composite exception )   {  return true ;   }  return false ;   }  
public static boolean   (  string domain )  {  if  (  !  jive globals . get boolean property (  connection settings .  server . socket   active true )  )   {  return false ;   }   permission permission = null ;   remote server configuration config = get configuration ( domain )  ;  if  ( config  !  =  null )   {  permission = config . get permission (  )  ;   }  if  (  permission policy . blacklist  =  =  get permission policy (  )  )   {  return  permission . blocked  !  =  permission ;   }  else  {  return  permission . allowed  =  =  permission ;   }   }  
public int   (  )  {  return    offset ;   }  
public boolean   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  if  ( tun  !  =  null )   {  if  (  tunnel controller . type   http   client . equals ( tun . get type (  )  )  )   {   properties opts = tun . get client option props (  )  ;  if  (  boolean . parse boolean ( opts . get property ( i2p tunnelhttp client base . prop   use   outproxy   plugin "true" )  )  )   {   client app manager mgr =    context . client app manager (  )  ;  if  ( mgr  !  =  null )  return mgr . get registered app (  outproxy . name )   !  =  null ;   }   }   }  return false ;   }  
@ override public void   ( t t )  {  parent . other success ( t )  ;   }  
public void   (  outgoing server session session )  {  this . session = session ;   }  
@ override public void   ( jid to  string reason jid sender )  {  if  (  (  (  multi user chat service impl ) muc service )  . getmuc delegate (  )   !  =  null )   {  switch  (  (  (  multi user chat service impl ) muc service )  . getmuc delegate (  )  
private void   (  ssi command command )  {  parent . request ( command )  ;   }  
public   (  )  {  super ( i2p app context . get global context (  )  . simple timer2 (  )  get check time (  )  )  ;   }  
public   (  iterable <  ?  extends  maybe source <  ?  extends t >  >  sources )  {  this . sources = sources ;   }  
@ override void   (  object o )  {  print writer . println ( o )  ;   }  
public int   (  )  {  return this . sock . get local port (  )  ;   }  
private  sorting collection <  string >    (  )  {  final  string name = get class (  )  . get simple name (  )  ;  final  file tmp dir = io util . create temp dir ( name null )  ;  tmp dir . delete on exit (  )  ;  long max names in ram =  runtime . get runtime (  )  . max memory (  )   /  256  /  10 ;  return  sorting collection . new instance (  string . class new  string codec (  )   string::compare to  ( int )  math . min ( max names in ram  integer . max   value )  tmp dir )  ;   }  
void   ( int size )  {  float low peak =    peak tunnel1m throughput[throughput   count  -  1] ;  if  ( size  >  low peak )   {  synchronized  (    peak tunnel1m throughput )   {  for  ( int i = 0 ;  i  <  throughput   count ;  i +  +  )   {  if  ( size  >     peak tunnel1m throughput[i] )   {  for  ( int j = throughput   count  -  1 ;  j  >  i ;  j -  -  )     peak tunnel1m throughput[j] =    peak tunnel1m throughput[j  -  1] ;     peak tunnel1m throughput[i] = size ;  break ;   }   }   }  if  (    log . should log (  log . debug )  )   {   string builder buf = new  string builder ( 128 )  ;  buf . append ( " updating 1m throughput after " )  . append ( size )  . append ( " to " )  ;  for  ( int i = 0 ;  i  <  throughput   count ;  i +  +  )  buf . append (    peak tunnel1m throughput[i] )  . append ( ' ' )  ;  buf . append ( " for " )  . append (    peer . to base64 (  )  )  ;     log . debug ( buf . to string (  )  )  ;   }   }   }  
public  node info   ( nid nid )  {  return    node map . get ( nid )  ;   }  
public   (  string login  properties props sa mv3 handler handler i2p socket manager mgr int listen port )  throws io exception   data format exception  sam exception  {  super ( mgr props handler listen port )  ;  this . nick = login ;     accept queue = new  linked blocking queue < i2p socket >  ( max   accept   queue )  ;   }  
static void   (  parsed parameters parameters  binding binding  prepared statement statement  statement context context )  {  if  ( parameters . is positional (  )  )   {  bind positional ( parameters . get parameter count (  )  binding statement context )  ;   }  else  {  bind named ( parameters . get parameter names (  )  binding statement context )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . throttle first ( 1  time unit . days )  )  ;   }  
@ test public void   (  )  throws  exception  {  set password types ( "bcrypt md5 plain" )  ;  assert true ( "should ignore everything beyond bcrypt" jdbc auth provider . compare passwords ( password bcrypted   password )  )  ;   }  
@ test public void   (  )  {   single <  number >  source =  single . just ( 1d )  . cast (  number . class )  ;  source . test (  )  . assert result (  (  number ) 1d )  ;   }  
@ override protected  interval list   (  )  {  return  interval list . from file ( amplicon   intervals )  ;   }  
public boolean   (  client session session jid fulljid boolean anonymous boolean force unavailable )  {  if  ( server name  =  =  null )   {  return false ;   }  if  ( session  =  =  null )   {  session = get session ( fulljid )  ;   }  boolean removed = routing table . remove client route ( fulljid )  ;  if  ( removed )   {  if  ( anonymous )   {   session event dispatcher . dispatch event ( session  session event dispatcher .  event type . anonymous   session   destroyed )  ;   }  else  {   session event dispatcher . dispatch event ( session  session event dispatcher .  event type . session   destroyed )  ;   }   }  boolean preauth   removed = local session manager . get pre authenticated sessions (  )  . remove ( fulljid . get resource (  )  )   !  =  null ;  if  ( force unavailable || session . get presence (  )  . is available (  )  )   {   presence offline = new  presence (  )  ;  offline . set from ( fulljid )  ;  offline . set to ( new jid ( null server name null true )  )  ;  offline . set type (  presence .  type . unavailable )  ;  router . route ( offline )  ;   }  session info cache . remove ( fulljid . to string (  )  )  ;  if  ( removed || preauth   removed )   {  connections counter . decrement and get (  )  ;  return true ;   }  return false ;   }  
private static final  list <  integer >    (  )  {   list <  integer >  rv = new  array list <  integer >  ( 8 )  ;  rv . add ( new  integer ( 2 )  )  ;  rv . add ( new  integer ( 4 )  )  ;  rv . add ( new  integer ( 6 )  )  ;  rv . add ( new  integer ( 0 )  )  ;  rv . add ( new  integer ( 1 )  )  ;  rv . add ( new  integer ( 3 )  )  ;  rv . add ( new  integer ( 5 )  )  ;  rv . add ( new  integer ( 7 )  )  ;  return rv ;   }  
public  request queue   (  workgroup workgroup  user request request )  {   word match router router = new  word match router (  )  ;  for  (   routing rule rule : get routing rules ( workgroup )  )   {   string query = rule . get query (  )  ;  boolean handled = router . check for hits ( request . get meta data (  )  query )  ;  if  ( handled )   {  try  {  return workgroup . get request queue ( rule . get queueid (  )  )  ;   }  catch  (   not found exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }   list <  request queue >  available request queues = new  array list <  request queue >  (  )  ;  for  (   request queue request queue : workgroup . get request queues (  )  )   {  if  ( request queue  !  =  null && request queue . is opened (  )  )   {  available request queues . add ( request queue )  ;   }   }   collections . sort ( available request queues queue comparator )  ;  return available request queues . get ( 0 )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
private void   (  observer <  string >  observer )  {  verify ( observer times ( 1 )  )  . on next ( "one" )  ;  verify ( observer times ( 1 )  )  . on next ( "two" )  ;  verify ( observer times ( 1 )  )  . on next ( "three" )  ;  verify ( observer times ( 1 )  )  . on error ( test exception )  ;  verify ( observer  mockito . never (  )  )  . on complete (  )  ;   }  
private static boolean   (  class <  ?  >  cls  class <  ?  >  intfc )  {  try  {   class <  ?  > [] intfcs = cls . get interfaces (  )  ;  for  ( int i = 0 ;  i  <  intfcs . length ;  i +  +  )   {  if  ( intfcs[i]  =  =  intfc )  return true ;   }   }  catch  (   throwable t )   {   }  return false ;   }  
@ test public void   (  )  throws io exception  {   input stream input stream = byte array configuration resource . new input stream (  )  ;  assert not null ( input stream )  ;   }  
public  string   (  )  {  return "i2psnark" ;   }  
@ override public boolean   (  )  {  return false ;   }  
public static boolean   (  string app name )  {   properties props = plugin properties (  )  ;   string prop = prefix  +  app name  +  enabled ;  return  boolean . parse boolean ( props . get property ( prop "true" )  )  ;   }  
@ override public boolean   (  object obj )  {  if  (  ( obj  =  =  null )  ||  !  ( obj instanceof  garlic clove )  )  return false ;   garlic clove clove =  (  garlic clove ) obj ;  return  data helper . eq (    certificate clove .    certificate )  && 
public   ( final  string sequence final int start final int end final boolean negative final  string name )  {  super ( sequence start end negative name )  ;   }  
public boolean   (  )  {  return    should processdsrm ;   }  
public boolean   (  )  {  return m sync calendar view . is checked (  )  ;   }  
@ test ( timeout = 2000 )  public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integer >  
@ test public void   (  )  {  byte[] array = "array" . get bytes (  )  ;  assert that (  array utilities . null safe copy ( array )  equal to ( array )  )  ;   }  
public  string   (  )  {  return local addr ;   }  
public void   (  status status )  {  this . status = status ;   }  
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  integer >   object >  (  )  {  @ override public  object apply (   flowable <  integer >  o )  throws  exception  {  return o . flat map completable ( ne
@ override public jid   (  )  {  return new jid ( get name (  )  getmuc service (  )  . get service domain (  )  null )  ;   }  
public  date   (  )  {  return last activity ;   }  
@ override public void   ( boolean self change )  {   account account =  account . restore account with id ( m context m account id )  ;  if  (  ( account . m flags &  account . flags   initial   folder   list   loaded )   !  =  0 &&  ( m account observer
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . zip (  arrays . as list ( just1 just1 )  null )  ;   }  
protected void   (  audio packet a )  {  f . error (  ( new  string builder (  )  )  . append ( " audio packet untreated for flow " )  . append ( a )  . to string (  )  )  ;   }  
public int   (  )  {  return physical width dpi ;   }  
public void   ( boolean is mute whisper group )  {  this . is mute whisper group = is mute whisper group ;   }  
public void   (  )  throws  exception  {   byte array output stream out = new  byte array output stream (  )  ;     client . create destination ( out )  ;     client . create session ( new  byte array input stream ( out . to byte array (  )  )  null )  ;   }  
@ override public long   (  )  {  return 1 ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . on backpressure buffer ( false )  . test ( 0l )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {  check backpressure support (  single . class )  ;   }  
private void   (  )  {  database . get read lock (  )  ;  info . get read lock (  )  ;   }  
public static  < t >  builder < t >    ( t .  .  .  items )  {  return new  builder < t >  (  arrays . as list ( items )  )  ;   }  
public boolean   (  )  {  return halted ;   }  
public void   (  )  {  release (  )  ;   }  
public int   (  )  {  if  (  !    last received )  throw new  illegal state exception ( "don't get the completed size when we're not complete ! " )  ;  if  (    released after  >  0 )   {   runtime exception e = new  runtime exception ( "use after free in  fragmented message" )  ;     log . error ( "fm complete size (  ) " e )  ;  throw e ;   }  int size = 0 ;  for  ( int i = 0 ;  i  <  =     high fragment num ;  i +  +  )   {   byte array ba =    fragments[i] ;  if  ( ba  =  =  null )  throw new  illegal state exception ( "don't get the completed size when we're not complete !   -  null fragment i = "  +  i  +  " of " +     high fragment num )  ;  size +  = ba . get valid (  )  ;   }  return size ;   }  
@ test public void   (  )  throws  exception  {  run standard test ( 1 "multiplexed barcode . " "mp   barcode . params" 1 "25t8b25t" basecalls   dir test   data   dir )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . flat map single ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (   integer v )  throws  exception  {  return  single . ju
@ test public void   (  )  {   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  final int num   msg = 1034 ;  final  atomic integer count = new  atomic integer (  )  ;   flowable <  string >  origin =  flowable . unsafe create ( 
private void   (  map <  hash  peer profile >  peers int how many  set <  hash >  to exclude  set <  hash >  matches  hash random key  slice sub tier mode )  {   list <  hash >  all = new  array list <  hash >  ( peers . key set (  )  )  ;  for  (  iterator <  hash >  iter = new  random iterator <  hash >  ( all )  ;   ( matches . size (  )   <  how many )  && iter . has next (  )  ;   )   {   hash peer = iter . next (  )  ;  if  ( to exclude  !  =  null && to exclude . contains ( peer )  )  continue ;  if  ( matches . contains ( peer )  )  continue ;  if  (    us . equals ( peer )  )  continue ;  int sub tier = get sub tier ( peer random key )  ;  if  (  ( sub tier & sub tier mode . mask )   !  =  sub tier mode . val )  continue ;  boolean ok = is selectable ( peer )  ;  if  ( ok )  matches . add ( peer )  ;  else matches . remove ( peer )  ;   }   }  
private  list <  string >    (  string .  .  .  args )  {   list <  string >  list = new  array list <  string >  (  )  ;  for  (   string arg : args )   {  list . add ( arg )  ;   }  return list ;   }  
@ override public void   (  object t )  {  to2 . cancel (  )  ;  super . on next ( t )  ;   }  
@ override public void   ( long n )  {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }  
@ test public void   (  )  {  uuid u = uuid . randomuuid (  )  ;  handle . register argument ( new uuid argument factory (  )  )  ;  assert that ( handle . create query ( "select cast ( :uuid as varchar ) " )  . bind ( "uuid" u )  . map to (  string . cla
@ test ( timeout = 1000 )  public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic integer event counter = new  atomic integer (  )  ;   flowable . range ( 0 100 )  . group by ( n
public   ( i2p app context ctx  connection manager mgr )  {     manager = mgr ;     context = ctx ;     listeners = new  copy on write array set <  disconnect listener >  (  )  ;     log = ctx . log manager (  )  . get log (  message handler . class )  ;     context . stat manager (  )  . create rate stat ( "stream . packet receive failure" " when do we fail to decrypt or otherwise receive a packet sent to us ? " " stream" new long[] { 60 * 60 * 1000 24 * 60 * 60* 1000 }  )  ;   }  
private void   (  session session )  {   streamid streamid = session . get streamid (  )  ;   string connection manager domain = streami ds . remove ( streamid )  ;  if  ( connection manager domain  !  =  null )   {   map <  streamid  local client session >  sessions = sessions by manager . get ( connection manager domain )  ;  if  ( sessions  !  =  null )   {  sessions . remove ( streamid )  ;   }   }   }  
boolean   ( boolean d boolean empty  subscriber <  ?  super t >  a boolean delay error )  {  if  ( cancelled )   {  queue . clear (  )  ;  return true ;   }  if  ( d )   {  if  ( delay error )   {  if  ( empty )   {   throwable e = error ;  if  ( e  !  =  null )   {  a . on error ( e )  ;   }  else  {  a . on complete (  )  ;   }  return true ;   }   }  else  {   throwable e = error ;  if  ( e  !  =  null )   {  queue . clear (  )  ;  a . on error ( e )  ;  return true ;   }  else if  ( empty )   {  a . on complete (  )  ;  return true ;   }   }   }  return false ;   }  
private void   (  string msg )  {  if  ( msg  =  =  null )     buffer . append ( "null" )  ;  else    buffer . append ( msg )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . hide (  )  . flat map ( new  function <  integer  flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   integer v )  throws  exception  {  return  flowable . range ( 1 
public synchronized void   (  properties props  string prefix boolean treat as current )  throws  illegal argument exception  {     period =  persistence helper . get int ( props prefix " . period" )  ;     creation date =  persistence helper . get long ( props prefix " . creation date" )  ;     last coalesce date =  persistence helper . get long ( props prefix " . last coalesce date" )  ;     current total value =  ( float )  persistence helper . get double ( props prefix " . current total value" )  ;     current event count =  persistence helper . get int ( props prefix " . current event count" )  ;     current total event time =  ( int )  persistence helper . get long ( props prefix " . current total event time" )  ;     last total value =  ( float )  persistence helper . get double ( props prefix " . last total value" )  ;     last event count =  persistence helper . get int ( props prefix " . last event count" )  ;     last total event time =  ( int )  persistence helper . get long ( props prefix " . last total event time" )  ;     extreme total value =  ( float )  persistence helper . get double ( props prefix " . extreme total value" )  ;     extreme event count =  persistence helper . get int ( props prefix " . extreme event count" )  ;     extreme total event time =  ( int )  persistence helper . get long ( props prefix " . extreme total event time" )  ;     lifetime total value =  ( float )  persistence helper . get double ( props prefix " . lifetime total value" )  ;     lifetime event count =  persistence helper . get long ( props prefix " . lifetime event count" )  ;     lifetime total event time =  persistence helper . get long ( props prefix " . lifetime total event time" )  ;  if  ( treat as current )     last coalesce date = now (  )  ;  if  (    period  <  =  0 )  throw new  illegal argument exception ( " period for "  +  prefix  +  " is invalid" )  ;  coalesce (  )  ;   }  
@ benchmark public void   (  blackhole bh )  {  observe on observable . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
public void   (  )  {  m input open = false ;   }  
public  list <  router address >    (  string transport style )  {   list <  router address >  ret = new  array list <  router address >  (    addresses . size (  )  )  ;  for  (   router address addr :    addresses )   {  if  ( addr . get transport style (  )  . equals ( transport style )  )  ret . add ( addr )  ;   }  return ret ;   }  
void   (  dialog dialog )  {  if  ( dialog  !  =  null )   {   string buffer log = new  string buffer ( 1024 )  ;  log . append ( " printing dialog: \n" )  ;  log . append ( " call id  =  " )  ;  log . append ( dialog . get call id (  )  . get call id (  )  )  ;  log . append ( "\n" )  ;  log . append ( " dialog id  =  " )  ;  log . append ( dialog . get dialog id (  )  )  ;  log . append ( "\n" )  ;  log . append ( " local party  =  " )  ;  log . append ( dialog . get local party (  )  )  ;  log . append ( "\n" )  ;  log . append ( " remote party  =  " )  ;  log . append ( dialog . get remote party (  )  )  ;  log . append ( "\n" )  ;  log . append ( " remote targ  =  " )  ;  log . append ( dialog . get remote target (  )  )  ;  log . append ( "\n" )  ;  log . append ( " local seq  =  " )  ;  log . append ( dialog . get local seq number (  )  )  ;  log . append ( "\n" )  ;  log . append ( " remote seq  =  " )  ;  log . append ( dialog . get remote seq number (  )  )  ;  log . append ( "\n" )  ;  log . append ( " local tag  =  " )  ;  log . append ( dialog . get local tag (  )  )  ;  log . append ( "\n" )  ;  log . append ( " remote tag  =  " )  ;  log . append ( dialog . get remote tag (  )  )  ;  log . append ( "\n" )  ;  log . append ( " dialog state  =  " )  ;  log . append ( dialog . get state (  )  )  ;   log . debug ( new  string ( log )  )  ;   }   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
private static void   (  string s )  {  i2p app context . get global context (  )  . log manager (  )  . get log ( ssl util . class )  . error ( s )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public void   ( final  file sam file )  {  final int validate exit status = run picard command line ( new  string[] { "i = "  +  sam file . get absolute path (  )  }  )  ;   assert . assert equals ( validate exit status 0 )  ;   }  
private boolean   (  string server list[] int per server timeout boolean preferi pv6 )  throws  illegal argument exception  {  long found[] = new long[   concurring servers] ;  long now =  - 1 ;  int stratum =  - 1 ;  long expected delta = 0 ;     well synced = false ;  for  ( int i = 0 ;  i  <     concurring servers ;  i +  +  )   {  long[] time and stratum =  ntp client . current time and stratum ( server list per server timeout preferi pv6    log )  ;  now = time and stratum[0] ;  stratum =  ( int ) time and stratum[1] ;  long delta = now  -     context . clock (  )  . now (  )  ;  found[i] = delta ;  if  ( i  =  =  0 )   {  if  (  math . abs ( delta )   <  max   variance )   {  if  (    log  !  =  null &&    log . should info (  )  )     log . info ( "a single sntp query was within the tolerance  ( "  +  delta  +  "ms ) " )  ;     well synced =  math . abs ( delta )   <  500 ;  break ;   }  else  {  expected delta = delta ;   }   }  else  {  if  (  math . abs ( delta  -  expected delta )   >  max   variance )   {  if  (    log  !  =  null &&    log . should error (  )  )   {   string builder err = new  string builder ( 96 )  ;  err . append ( "sntp client variance exceeded at query " )  . append ( i )  ;  err . append ( " .  expected  =  " )  ;  err . append ( expected delta )  ;  err . append ( "  found  =  " )  ;  err . append ( delta )  ;  err . append ( " all deltas: " )  ;  for  ( int j = 0 ;  j  <  found . length ;  j +  +  )  err . append ( found[j] )  . append ( ' ' )  ;     log . error ( err . to string (  )  )  ;   }  return false ;   }   }   }  stamp time ( now stratum )  ;  if  (    log  !  =  null &&    log . should debug (  )  )   {   string builder buf = new  string builder ( 64 )  ;  buf . append ( " deltas: " )  ;  for  ( int i = 0 ;  i  <  found . length ;  i +  +  )  buf . append ( found[i] )  . append ( ' ' )  ;     log . debug ( buf . to string (  )  )  ;   }  return true ;   }  
@ override public  list <  object >    (  object o )  throws  exception  {  return new  array list <  object >  (  )  ;   }  
public  request information   (  )  {   byte array output stream request output = get request info stream (  )  ;  if  ( request output  =  =  null )   {  return null ;   }  byte[] request bytes = request output . to byte array (  )  ;   byte array input stream input = new  byte array input stream ( request bytes )  ;  if  ( input . available (  )   =  =  0 )   {  return null ;   }  if  ( log . is debug enabled (  )  )   {  log . debug ( " new request info: "  +  new  string ( request bytes  standard charsets . utf   8 )  )  ;   }  return marshaller . unmarshall request information ( input )  ;   }  
@ test ( data provider = "  data provider" )  public void test from sex map ( final  collection <  string >  females final  collection <  string >  males )  throws  exception  {  final  map <  string  sex >  data = new  hash map <  string  sex >  (  )  ; 
@ test public void   (  )  throws  exception  {  assert that ( handle . select ( "select id from something where name  =  'arthur'" )  . collect into (  optional int . class )  )  . is empty (  )  ;  assert that ( handle . select ( "select null from somet
@ test ( timeout = 10000 )  public void   (  )  {  for  ( int i = 0 ;  i  <  200 ;  i +  +  )   {  test simple one less async (  )  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  ts . on error ( new  test exception (  )  )  ;  ts . on error ( new  test exception (  )  )  ;  try  {  ts . assert terminated (  )  ;   }  catch
public   (  context context  host auth host auth )  {  super ( context log   tag host auth )  ;   }  
@ override public int   (  )  {  return 0 ;   }  
public void   (  )  {  executor service . shutdown now (  )  ;  cleanup task . cancel (  )  ;  cleanup task = null ;   statistics manager . get instance (  )  . remove statistic ( conversations   key )  ;   property event dispatcher . remove listener ( property listener )  ;  property listener = null ;  conversation listeners . clear (  )  ;  conversation listeners = null ;  server info = null ;   internal component manager . get instance (  )  . remove listener ( this )  ;   }  
private static boolean   (  string lhs  string rhs )  {  return  ( lhs  =  =  null && rhs  =  =  null )  ||  ( lhs  !  =  null && lhs . equals ( rhs )  )  ;   }  
public   (  string a boolean p )  {  announce = a ;   string s = a . substring ( 7 )  ;  host = s . substring ( 0 s . index of ( ' / ' )  )  ;  is primary = p ;  interval = initial   sleep ;   }  
@ override public int   (  )  throws  cannot calculate size exception  {  int size = jid . to barejid (  )  . length (  )  ;  size +  =  cache sizes . size of string ( nickname )  ;  size +  =  cache sizes . size of collection ( groups )  ;  size +  =  ca
@ override public void   (  )  {  parent . complete (  )  ;   }  
@ override public void   (  throwable t )  {  if  (  ! done &&  exception helper . add throwable ( error t )  )   {  done = true ;  drain (  )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   }  
@ override public  string   (  )  {  return " user modified" ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   unicast subject . create ( 0 )  ;   }  
public int   (  )  throws io exception  {  return steps . get (  )  ;   }  
@ override public boolean   (  object obj )  {  if  (  !  ( obj instanceof  ed25519 field element )  )  return false ;   ed25519 field element fe =  (  ed25519 field element ) obj ;  return 1  =  =   utils . equal ( to byte array (  )  fe . to byte array 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable flowable <  integer >  cf =  flowable . range ( 1 1000 )  . replay (  )  ;  final  test subscriber <  integer >  ts1 = new  
public void   (  )  {  synchronized  (    data lock )   {     data lock . notify all (  )  ;   }   }  
  (  observer <  ?  super t >  actual  consumer <  ?  super t >  on after next )  {  super ( actual )  ;  this . on after next = on after next ;   }  
public synchronized void   (  hash destination )  {  if  ( destination  =  =  null )  return ;  if  (    log . should log (  log . debug )  )     log . debug ( " removing tunnels for the client "  +  destination . to base32 (  )  )  ;  if  (    context . client manager (  )  . is local ( destination )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not removing pool still registered with client manager: "  +  destination . to base32 (  )  new  exception ( "i did it" )  )  ;  return ;   }   tunnel pool inbound =    client inbound pools . remove ( destination )  ;   tunnel pool outbound =    client outbound pools . remove ( destination )  ;  if  ( inbound  !  =  null )  inbound . shutdown (  )  ;  if  ( outbound  !  =  null )  outbound . shutdown (  )  ;   }  
public int   (  )  {  return id ;   }  
@ override public void   (  throwable e )  {  throw new  test exception (  )  ;   }  
public void   (  snark snark )  {   meta info metainfo = snark . get meta info (  )  ;   storage storage = snark . get storage (  )  ;  if  ( metainfo  =  =  null || storage  =  =  null )  return ;  if  ( metainfo . get files (  )   =  =  null )  return ;   properties config = get config ( snark )  ;   string pri = config . get property ( prop   meta   priority )  ;  if  ( pri  =  =  null )  return ;  int filecount = metainfo . get files (  )  . size (  )  ;  int[] rv = new int[filecount] ;   string[] arr =  data helper . split ( pri " " )  ;  for  ( int i = 0 ;  i  <  filecount && i  <  arr . length ;  i +  +  )   {  if  ( arr[i] . length (  )   >  0 )   {  try  {  rv[i] =  integer . parse int ( arr[i] )  ;   }  catch  (   throwable t )   {   }   }   }  storage . set file priorities ( rv )  ;   }  
@ override public void   (  )  {  index = array . length ;   }  
public static void   (  router context ctx )  {  if  (  system version . is android (  )  )  return ;  boolean unavail = false ;   log log = null ;  for  (   sig type t :  sig type . values (  )  )   {  if  (  ! t . is available (  )  )   {  if  (  ! unavail )   {  unavail = true ;  if  ( ctx  !  =  null )  log = ctx . log manager (  )  . get log (  crypto checker . class )  ;   }   string s = " crypto "  +  t  +  " is not available" ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }   }  if  ( unavail )   {   string s = " java version: "  +   system . get property ( "java . version" )   +  " os: " +   system . get property ( "os . name" )  +  ' ' +   system . get property ( "os . arch" )  +  ' ' +   system . get property ( "os . version" )  ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;  if  (  !  system version . is java7 (  )  )   {  s = " please consider upgrading to  java 7" ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( s )  ;   }  else if  (  system version . is java9 (  )  )   {  s = " java 9 support is beta  check for  java updates" ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }  if  (  !  crypto check . is unlimited (  )  &&  !  system version . is java9 (  )  )   {  s = " please consider installing the  java  cryptography  unlimited  strength  jurisdiction  policy  files from " ;  s +  = jre6 ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( s )  ;   }  s = " this crypto will be required in a future release" ;  if  ( log  !  =  null )  log . log always (  log . warn s )  ;   system . out . println ( " warning: "  +  s )  ;   }  else if  ( ctx  =  =  null )   {   system . out . println ( " all crypto available" )  ;   }   }  
public void   ( byte target[] int target offset )  {  int offset = read body offset (  )   +  4 ;  offset +  =    message[offset] & 0xff ;  offset +  = 1  +  2 ;  int sz =    message[offset] & 0xff ;  offset +  +  ;  offset +  = sz ;   system . arraycopy (    message offset target target offset  session key . keysize   bytes )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "read alice intro key: "  +   base64 . encode ( target target offset  session key . keysize   bytes )   +  " packet size: " +     payload length +  " off: " +  offset +  " data: " +   base64 . encode (    message )  )  ;   }  
@ benchmark public void   (  blackhole bh )  {  flow flat map completable as flow0 . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ test public void   (  )  {   test observable func f = new  test observable func ( "one" "two" "three" )  ;   observable <  string >  w =  observable . unsafe create ( f )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;   obser
public   (  router context ctx )  {  super ( ctx )  ;     to unbanlist = new  array list <  hash >  ( 4 )  ;  get timing (  )  . set start after ( ctx . clock (  )  . now (  )   +  banlist   cleaner   start   delay )  ;   }  
public  service version mapping   (  )  {  return mapping ;   }  
public void   (  string descriptionuri )  {  this . descriptionuri = descriptionuri ;   }  
public   (  mail cache mail cache )  {  super ( mail cache )  ;   }  
@ override public  string   (  )  {  if  (    settings . is exploratory (  )  )   {  if  (    settings . is inbound (  )  )  return " inbound exploratory pool" ;  else return " outbound exploratory pool" ;   }  else  {   string builder rv = new  string bu
private  member receiver   (  inet socket address isa )  {  synchronized  ( members )   {  return members . get ( isa )  ;   }   }  
public void   (  )  {  observed umi with ns +  +  ;   }  
@ override public muc room   (  )  {  return room ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  once = true ;  actual . on complete (  )  ;   }  
public char   (  )  throws io exception  {  return delegate . read char (  )  ;   }  
@ override public  data form   (  string name  string node jid senderjid )  {  return null ;   }  
@ override public void   (  )  {  if  ( m state  =  =  state   checking   preconfigured )   {  m pre configured failed = true ;  proceed (  )  ;   }  else  {  reset state from current fragment (  )  ;   }  final  account setup incoming fragment f =  (  ac
public void   (  string business department )  {  this . business department = business department ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   iterator <  object >  it =  observable . never (  )  . blocking latest (  )  . iterator (  )  ;   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   (  (  
public static  permission policy   (  )  {  try  {  return  permission policy . value of (  jive globals . get property ( "xmpp . component . permission"  permission policy . blacklist . to string (  )  )  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  return  permission policy . blacklist ;   }   }  
public   (  flowable < t >  source  predicate <  ?  super t >  predicate )  {  super ( source )  ;  this . predicate = predicate ;   }  
@ test public void   (  )  {  final  atomic boolean unsub = new  atomic boolean (  )  ;   observable . range ( 1 10 )  . concat with (  observable .  <  integer > never (  )  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  {  un
public  builder   (  string name )  {  named = true ;  parameter names . add ( name )  ;  return append ( " ? " )  ;   }  
@ override public void   (  throwable t )  {  if  ( get (  )   !  =   subscription helper . cancelled )   {  lazy set (  subscription helper . cancelled )  ;  parent . on timeout error ( idx t )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ delivery status message: " )  ;  buf . append ( "\n\t message id: " )  . append ( get message id (  )  )  ;  buf . append ( "\n\t arrival: " )  . app
public void   (  string addr )  {  local addr = addr ;   }  
@ test public void   (  )  {   test scheduler ts = new  test scheduler (  )  ;   replay processor <  object >  rs =  replay processor . create with time ( 1  time unit . seconds ts )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has valu
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  future subscriber <  integer >  fs = new  future subscriber <  integer >  (  )  ;   runnable r = new  runnable (  )  {  @ override publi
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  int n = 1000 * 1000 ;   flowable . range ( 1 n )  . concat map iterable ( mapper )  . concat map ( new  function <  integer  flowable <  integer 
@ test public void   (  )  throws  exception  {   future <  object >  future = new  future <  object >  (  )  {  private  atomic boolean is cancelled = new  atomic boolean ( false )  ;  private  atomic boolean is done = new  atomic boolean ( false )  ;  @
@ override @ suppress warnings ( "squid:s106" )  protected void   (  )  {  try  {   system . out . println ( " stopping  tomcat  server" )  ;  tomcat . stop (  )  ;  tomcat . get server (  )  . stop (  )  ;   }  catch  (   lifecycle exception e )   {  log
@ test public final void   (  )  {   test scheduler s = new  test scheduler (  )  ;  final  scheduler .  worker inner = s . create worker (  )  ;  try  {  final  atomic integer counter = new  atomic integer ( 0 )  ;  final  disposable subscription = inner
@ override protected  password authentication   (  )  {  return new  password authentication ( proxy user proxy pass . to char array (  )  )  ;   }  
private   (  )  {  timer = new  timer ( "timer - fastpath" true )  ;  final  thread factory thread factory = new  named thread factory ( "pool - fastpath" true  thread . norm   priority  thread . current thread (  )  . get thread group (  )  0l )  ;  executor =  executors . new cached thread pool ( thread factory )  ;   }  
@ override public void   ( int one byte )  throws io exception  {  super . write ( one byte )  ;  m count +  +  ;  if  (  logging . logd )   {  if  ( m count % 1024  =  =  0 )   {   log utils . v (  logging . log   tag "# "  +  m count )  ;   }   }   }  
public   (  packet error .  condition creation status  element pubsub error  node new node )  {  this . creation status = creation status ;  this . new node = new node ;  this . pubsub error = pubsub error ;   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   completable c =  completable . from callable ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  ret
@ override public boolean   (  )  {  return properties . is empty (  )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   publish processor <  object >  pp1 =  publish processor . create (  )  ;   publish processor <  object >  pp2 =  publish processor . create (  )  ;   completable c1 =  completable . from publisher ( pp1 )
  (  observer <  ?  super t >  actual )  {  super ( actual )  ;   }  
@ test public void   (  )  {  final int offset = 10 ;  for  (   integer i : expected )   {  db rule . get shared handle (  )  . execute ( "insert into something ( name  int value )  values  (  ?    ?  ) "  integer . to string ( i  +  offset )   +  "as str
@ override public int   (  string header )  {  return is filtered header ( header )   ?   - 1 : super . get int header ( header )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  completable subject cs =  completable subject . create (  
@ override public  certificate[]   (  )  {  ssl session ssl session =  ( ssl session ) io session . get attribute (  ssl filter . ssl   session )  ;  if  ( ssl session  !  =  null )   {  return ssl session . get local certificates (  )  ;   }  return new 
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 5 )  . concat with (  single .  <  integer > error ( new  test exception (  )  )  )  . subscribe ( to )  ;  to . assert
@ test public void   (  )  {   maybe . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  maybe source <  integer >  >  (  )  {  @ override public  maybe sou
public void   ( byte target[] int target offset )  {  int offset = read body offset (  )  ;  int size =    message[offset] & 0xff ;  offset +  +  ;   system . arraycopy (    message offset target target offset size )  ;   }  
@ override public void   ( boolean enabled boolean persistent )  {  if  ( is service enabled (  )   =  =  enabled )   {  return ;   }  if  (  ! enabled )   {  stop (  )  ;   }  if  ( persistent )   {  muc persistence manager . set property ( chat service 
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  single < t >    ( final  callable <  ?  extends  single source <  ?  extends t >  >  single supplier )  {   object helper . require non null ( single supplier "s
@ override public void   (  throwable ex )  {  if  (  exception helper . add throwable ( error ex )  )   {  active . decrement and get (  )  ;  drain (  )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
private void   (  mock transport mock transport )  throws  messaging exception  {  setup open folder ( mock transport 1 null )  ;  m folder . open (  open mode . read   only )  ;  assert equals ( 1 m folder . get message count (  )  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish processor .  <  integer > create (  )  . join (  flowable . just ( 1 )   functions . just function (  flowable . never (  )  )   functions . just function (  flowable . never (  )  )  
public   (  parallel flowable <  list < t >  >  source  comparator <  ?  super t >  comparator )  {  this . source = source ;  this . comparator = comparator ;   }  
@ test @ ignore ( " unhandled errors are no longer thrown" )  public final void   (  )  throws  interrupted exception  {   scheduler test helper . test unhandled error is delivered to thread handler ( get scheduler (  )  )  ;   }  
@ override public void   (  )  {  d =  disposable helper . disposed ;  actual . on success ( false )  ;   }  
@ override public int   ( final  class a class final  class b class )  {  return a class . get simple name (  )  . compare to ( b class . get simple name (  )  )  ;   }  
@ override public void   (  subscriber <  ?  super t > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )   subscriber <  ?  super t > [] parents = new  subscrib
@ test public void   (  )  throws  exception  {  final  string name = "deeper . xmpp . example . org" ;  final  string pattern = "* . example . org" ;  final boolean result = dns util . is name covered by pattern ( name pattern )  ;   assert . assert true
@ before public void   (  )  {  observer =  test helper . mock observer (  )  ;  test scheduler = new  test scheduler (  )  ;  subject =  publish subject . create (  )  ;  observable = subject . time interval ( test scheduler )  ;   }  
@ test ( data provider = "  data provider" )  public void test has cbcls ( final int lane final boolean create cbcl dir final boolean create cbcl final boolean expected result )  throws io exception  {  final  file basecalls dir = io util . create temp di
public static  string   (  string s )  {  if  ( s  =  =  null )   {  return "" ;   }   string builder out = new  string builder (  )  ;  int code point ;  int i = 0 ;  while  ( i  <  s . length (  )  )   {  code point = s . code point at ( i )  ;  if  (  ( code point  =  =  0x9 )  ||  ( code point  =  =  0xa )  ||  ( code point  =  =  0xd ) ||  (  ( code point  >  =  0x20 )  &&  ( code point  <  =  0xd7ff )  ) ||  (  ( code point  >  =  0xe000 )  &&  ( code point  <  =  0xfffd )  ) ||  (  ( code point  >  =  0x10000 )  &&  ( code point  <  =  0x10ffff )  )  )   {  out . append (  character . to chars ( code point )  )  ;   }  i +  =  character . char count ( code point )  ;   }  return out . to string (  )  ;   }  
@ test public void   (  )  throws  exception  {  fs . cancel ( true )  ;  fs . on error ( new  test exception ( " one" )  )  ;  try  {  fs . get ( 5  time unit . milliseconds )  ;  fail ( " should have thrown" )  ;   }  catch  (   cancellation exception e
private void   (  )  {  int header id = r . string . trash   folder   selection   title ;   uri uri =  uri . parse ( "content: /  / "  +   email content . authority  +  " / uifullfolders / " +  m account id )  ;  start picker ( uri header id )  ;   }  
public static void   (  )  {  for  (   simple byte cache bc :    caches . values (  )  )  bc . clear (  )  ;   }  
@ override protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is readable ( dbsnp )  ;  if  ( target   intervals  !  =  null )  io util . assert file is readable ( target   intervals )  ;  if  ( sequence   dicti
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
boolean   (  )  {  return aborted ;   }  
@ override public  string   (  string username )  throws  user not found exception   unsupported operation exception  {  throw new  unsupported operation exception (  )  ;   }  
protected static int   (  pending gateway message msg int offset int instructions size )  {  int payload length = msg . get data (  )  . length  -  msg . get offset (  )  ;  if  ( offset  +  payload length  +  instructions size +  iv   size +  1 +  4  >  preprocessed   size )   {  return 4 ;   }  return 0 ;   }  
public static  string   (  string s )  {  byte[] b = decode ( s )  ;  if  ( b  =  =  null )  return null ;  return  data helper . getutf8 ( b )  ;   }  
@ override public  single source <  long >    (  flowable <  object >  o )  throws  exception  {  return o . count (  )  ;   }  
@ test public void   (  )  {   iterable <  integer >  it =  flowable . range ( 1 300 )  . blocking iterable (  )  ;  for  ( int i = 0 ;  i  <  5 ;  i +  +  )   {   flowable <  integer >  f =  flowable . just ( it it )  . flat map iterable (  functions .  
private  string   ( asn1 primitive primitive )  throws io exception  {  if  ( primitive  =  =  null || primitive instanceof asn1 null )   {  return "" ;   }  else if  ( primitive instanceof asn1 sequence )   {  return do collection (  (  ( asn1 sequence ) primitive )  . to array (  )  )  ;   }  else if  ( primitive instanceof asn1 set )   {  return do collection (  (  ( asn1 set ) primitive )  . to array (  )  )  ;   }  else if  ( primitive instanceof der tagged object )   {  final der tagged object tagged =  (  ( der tagged object ) primitive )  ;  return " < table >  < tr >  < td > "  +  " <  / td >  < td > "  +  do primitive ( tagged . get object (  )  )   +  " <  / td >  <  / tr >  <  / table > " ;   }  else  {  return " < table >  < tr >  < td colspan = '2' > "  +  as string ( primitive )   +  " <  / td >  <  / tr >  <  / table > " ;   }   }  
public static  string   (  string s  string buffer expected pong dcc helper helper )  {   string field[] =  data helper . split ( s " " 3 )  ;  if  ( field[0] . length (  )   =  =  0 )  return null ;  if  ( field[0] . char at ( 0 )   =  =  ':' )  return null ;   string command = field[0] . to upper case (  locale . us )  ;  if  ( "ping" . equals ( command )  )   {   string rv = null ;  expected pong . set length ( 0 )  ;  if  ( field . length  =  =  1 )   {  rv = "ping" ;   }  else if  ( field . length  =  =  2 )   {  rv = "ping "  +  field[1] ;   }  else if  ( field . length  =  =  3 )   {  rv = "ping "  +  field[1] ;  expected pong . append ( "pong " )  . append ( field[2] )  . append ( " :" )  . append ( field[1] )  ;   }  else  {  rv = null ;   }  return rv ;   }  if  (    allowed outbound . contains ( command )  )  return s ;  if  ( "notice" . equals ( command )  )   {  if  ( field . length  <  3 )  return s ;   string msg = field[2] ;  if  ( msg . starts with ( ":dcc " )  )  return filterdcc out ( field[0]  +  ' '  +  field[1] +  " :dcc " msg . substring ( 5 )  helper )  ;   }  if  ( "privmsg" . equals ( command )  || "notice" . equals ( command )  )   {  if  ( field . length  <  3 )  return s ;   string msg = field[2] ;  if  ( msg . index of ( 0x01 )   >  =  0 )   {  int count = 0 ;  for  ( int i = 0 ;  i  <  msg . length (  )  ;  i +  +  )   {  if  ( msg . char at ( i )   =  =  0x01 )  count +  +  ;   }  if  ( count  !  =  2 )  return null ;  msg = msg . substring ( 2 )  ;  if  ( msg . starts with ( "action " )  )   {  return s ;   }  if  ( msg . starts with ( "dcc " )  )  return filterdcc out ( field[0]  +  ' '  +  field[1] +  " :\001dcc " msg . substring ( 4 )  helper )  ;  if  ( msg . to upper case (  locale . us )  . starts with ( "xdcc " )  && helper  !  =  null && helper . is enabled (  )  )  return s ;  if  ( allow   all   ctcp   out )  return s ;  return null ;   }  return s ;   }  if  ( "user" . equals ( command )  )   {  if  ( field . length  <  3 )  return s ;  int idx = field[2] . last index of ( ':' )  ;  if  ( idx  <  0 )  return "user user hostname localhost :realname" ;   string realname = field[2] . substring ( idx  +  1 )  ;   string ret = "user "  +  field[1]  +  " hostname localhost :" +  realname ;  return ret ;   }  if  ( "part" . equals ( command )  )   {  return "part "  +  field[1]  +  " :leaving" ;   }  if  ( "quit" . equals ( command )  )   {  return "quit :leaving" ;   }  return null ;   }  
public  string   (  )  {  return " rayo  plugin" ;   }  
public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
public static  string   ( final  object .  .  .  objects )  {   string out = objects[0] . to string (  )  ;  for  ( int i = 1 ;  i  <  objects . length ;  i +  +  )   {  out +  = "   "  +  objects[i] ;   }  return out ;   }  
void   (  )  throws  interrupted exception  {  thread has started . await (  )  ;  t . join (  )  ;   }  
@ test public void   (  )  {  final  list <  worker >  list = new  array list <  worker >  (  )  ;   scheduler multi worker support mws =  (  scheduler multi worker support )  schedulers . computation (  )  ;  mws . create workers ( max * 2 new  worker ca
private void   (  peer profile profile )  {   hash peer = profile . get peer (  )  ;  if  ( profile . get is failing (  )  )   {  if  (  ! should drop ( profile )  )     failing peers . put ( peer profile )  ;     fast peers . remove ( peer )  ;     high capacity peers . remove ( peer )  ;     well integrated peers . remove ( peer )  ;     not failing peers . remove ( peer )  ;     not failing peers list . remove ( peer )  ;   }  else  {     failing peers . remove ( peer )  ;     fast peers . remove ( peer )  ;     high capacity peers . remove ( peer )  ;     well integrated peers . remove ( peer )  ;     not failing peers . put ( peer profile )  ;     not failing peers list . add ( peer )  ;  if  (    threshold capacity value  <  =  profile . get capacity value (  )  && is selectable ( peer )  &&  !    context . comm system (  )  . is in bad country ( peer )  )   {     high capacity peers . put ( peer profile )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " high capacity: \t"  +  peer )  ;  if  (    threshold speed value  <  =  profile . get speed value (  )  )   {  if  (  ! profile . get is active (  )  )   {  if  (    log . should log (  log . info )  )     log . info ( " skipping fast mark [ ! active] for "  +  peer )  ;   }  else  {     fast peers . put ( peer profile )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " fast: \t"  +  peer )  ;   }   }   }  else  {   }  if  (    threshold integration value  <  =  profile . get integration value (  )  )   {     well integrated peers . put ( peer profile )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " integrated: \t"  +  peer )  ;   }   }   }  
public static void   (  output stream out  string method  string target request  string query  string proxy nonce )  throws io exception  {  if  ( target request . equals ( " / " )  )   {  out . write ( ok . get bytes ( "utf - 8" )  )  ;  out . flush (  )  ;  return ;   }  if  (  ( method . equals ( "get" )  || method . equals ( "head" )  )  && target request . starts with ( " / themes / " )  &&  ! target request . contains ( " .  . " )  )   {   string filename = null ;  try  {  filename = target request . substring ( 8 )  ;   }  catch  (   index out of bounds exception ioobe )   {  return ;   }  if  ( filename . starts with ( "console / default / " )  )  filename = filename . replace first ( "default" i2p app context . get global context (  )  . get property ( "routerconsole . theme" "light" )  )  ;   file themes dir = new  file ( i2p app context . get global context (  )  . get base dir (  )  "docs / themes" )  ;   file file = new  file ( themes dir filename )  ;  if  ( file . exists (  )  &&  ! file . is directory (  )  )   {   string type ;  if  ( filename . ends with ( " . css" )  )  type = "text / css" ;  else if  ( filename . ends with ( " . ico" )  )  type = "image / x - icon" ;  else if  ( filename . ends with ( " . png" )  )  type = "image / png" ;  else if  ( filename . ends with ( " . jpg" )  )  type = "image / jpeg" ;  else type = "text / html" ;  out . write ( "http / 1 . 1 200 ok\r\n content -  type: " . get bytes ( "utf - 8" )  )  ;  out . write ( type . get bytes ( "utf - 8" )  )  ;  out . write ( "\r\n cache -  control: max - age = 86400\r\n connection: close\r\n proxy -  connection: close\r\n\r\n" . get bytes ( "utf - 8" )  )  ;   file util . read file ( filename themes dir . get absolute path (  )  out )  ;  return ;   }   }  if  ( target request . equals ( " / add" )  )   {  if  ( query  =  =  null )   {  out . write ( err   add . get bytes ( "utf - 8" )  )  ;  return ;   }   map <  string  string >  opts = new  hash map <  string  string >  ( 8 )  ;   string tokenizer tok = new  string tokenizer ( query " = & ; " )  ;  while  ( tok . has more tokens (  )  )   {   string k = tok . next token (  )  ;  if  (  ! tok . has more tokens (  )  )  break ;   string v = tok . next token (  )  ;  opts . put ( decode ( k )  decode ( v )  )  ;   }   string url = opts . get ( "url" )  ;   string host = opts . get ( "host" )  ;   string b64 dest = opts . get ( "dest" )  ;   string nonce = opts . get ( "nonce" )  ;   string referer = opts . get ( "referer" )  ;   string book = "privatehosts . txt" ;  if  ( opts . get ( "master" )   !  =  null )  book = "userhosts . txt" ;  else if  ( opts . get ( "router" )   !  =  null )  book = "hosts . txt" ;   destination dest = null ;  if  ( b64 dest  !  =  null )   {  try  {  dest = new  destination ( b64 dest )  ;   }  catch  (   data format exception dfe )   {   system . err . println ( " bad dest to save ? "  +  b64 dest )  ;   }   }  if  ( proxy nonce . equals ( nonce )  && url  !  =  null && host  !  =  null && dest  !  =  null )   {   naming service ns = i2p app context . get global context (  )  . naming service (  )  ;   properties ns options = new  properties (  )  ;  ns options . set property ( "list" book )  ;  if  ( referer  !  =  null && referer . starts with ( "http" )  )   {   string ref =  data helper . escapehtml ( referer )  ;   string from = " < a href = \""  +  ref  +  "\" > " +  ref +  " <  / a > " ;  ns options . set property ( "s"    t ( " added via address helper from  { 0 } " from )  )  ;   }  else  {  ns options . set property ( "s"    t ( " added via address helper" )  )  ;   }  boolean success = ns . put ( host dest ns options )  ;  write redirect page ( out success host book url )  ;  return ;   }  out . write ( err   add . get bytes ( "utf - 8" )  )  ;   }  else  {  out . write ( err   404 . get bytes ( "utf - 8" )  )  ;   }  out . flush (  )  ;   }  
public static  simple timer2   (  )  {  return i2p app context . get global context (  )  . simple timer2 (  )  ;   }  
@ test public void   (  )  {   map <  string  string >  m1 = get map ( " one" )  ;   map <  string  string >  m2 = get map ( " two" )  ;   flowable <  map <  string  string >  >  observable1 =  flowable . just ( m1 m2 )  ;   map <  string  string >  m3 = 
public  streamid   (  )  {  return streamid factory . create streamid (  )  ;   }  
public static void   ( final  string[] args )  {  new  collect wgs metrics (  )  . instance main with exit ( args )  ;   }  
@ test ( timeout = 10000 )  @ ignore ( " request pattern changed and i can't decide if this is okay or not" )  public void   (  )  throws  interrupted exception  {  final  list <  long >  requests = new  copy on write array list <  long >  (  )  ;   test 
public  string   (  )  {  return    connection id ;   }  
@ override public void   (  throwable t )  {  collection = null ;  actual . on error ( t )  ;   }  
public void   (  )  {   imap list list = build list (  imap list . empty string   1 list   1  imap string . empty )  ;  assert element (  imap list . empty list . get list or empty ( 0 )  )  ;  assert element (  imap list . empty list . get list or empty ( 1 )  )  ;  assert element ( list   1 list . get list or empty ( 2 )  )  ;  assert element (  imap list . empty list . get list or empty ( 3 )  )  ;  assert element (  imap list . empty list . get list or empty ( 4 )  )  ;  assert element (  imap list . empty  imap list . empty . get list or empty ( 0 )  )  ;   }  
@ test public void   (  )  {  assert equals ( " / resource / info" tokenizer . get resource (  )  )  ;   }  
@ non null public  list <  throwable >    (  )  {  return exceptions ;   }  
  (  subscriber <  ?  super t >  actual  publisher <  ?  >  other )  {  this . actual = actual ;  this . sampler = other ;   }  
public void   (  roster item item boolean optimize )  {  if  ( optimize && item . is only shared (  )  && item . get sub status (  )   =  =   roster item . sub   from )   {  return ;   }   list <  string >  groups = new  array list <  >  ( item . get groups (  )  )  ;  for  (   group shared group : item . get shared groups (  )  )   {   string display name = shared group . get properties (  )  . get ( "shared roster . display name" )  ;  if  ( display name  !  =  null )   {  groups . add ( display name )  ;   }   }  org . xmpp . packet .  roster roster = new org . xmpp . packet .  roster (  )  ;  roster . set type ( iq .  type . set )  ;  roster . add item ( item . get jid (  )  item . get nickname (  )  get ask status ( item . get ask status (  )  )  org . xmpp . packet .  roster .  subscription . value of ( item . get sub status (  )  . get name (  )  )  groups )  ;  broadcast ( roster )  ;   }  
public  rate stat   (  )  {  return    db response time ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   flowable . merge (  flowable . range ( 1 10000 )  . do on next ( new  consumer <  int
@ test public void   (  )  {   worker w =  schedulers . computation (  )  . create worker (  )  ;  try  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final  test subscriber <  integer >  ts =  test subscriber . create ( 0l )  ;   testing deferred s
public void   (  string username )  {  for  (   string list name : provider . get privacy lists ( username )  . key set (  )  )   {  lists cache . remove ( get cache key ( username list name )  )  ;  for  (   privacy list event listener listener : listeners )   {  listener . privacy list deleting ( list name )  ;   }   }  provider . delete privacy lists ( username )  ;   }  
@ override public  set <  entry < k v >  >    (  )  {  return new  persistence aware entry set <  entry < k v >  >  ( super . entry set (  )  )  ;   }  
public  node   (  )  {  if  ( root node  !  =  null )  return root node ;  if  ( device node  =  =  null )  return null ;  return device node . get root node (  )  ;   }  
void   (  string name  plugin plugin )  {  for  (  final  plugin listener listener : plugin listeners )   {  try  {  listener . plugin created ( name plugin )  ;   }  catch  (   exception ex )   {   log . warn ( " an exception was thrown when one of the plugin manager listeners was notified of a 'created' event for plugin ' {  } ' ! " name ex )  ;   }   }   }  
public   (  string value string value  long value long value )  {  this . string value = string value ;  this . long value = long value ;   }  
public  udio packet a (  )  {  if  ( c  !  =  null )   {  d . error ( " packet already released" )  ;  return c ;   }  else  {  c = new  audio packet ( b b . length )  ;  c . g ( a )  ;  return c ;   }   }  
@ override public int   ( byte[] b int off int len )  throws io exception  {  if  ( b  =  =  null )   {  throw new  null pointer exception (  )  ;   }  else if  ( off  <  0 || len  <  0 || len  >  b . length  -  off )   {  throw new  index out of bounds e
protected  eddsa named curve spec   (  string curve name )  throws  invalid algorithm parameter exception  {   eddsa named curve spec spec =  eddsa named curve table . get by name ( curve name )  ;  if  ( spec  =  =  null )   {  throw new  invalid algorithm parameter exception ( "unknown curve name: "  +  curve name )  ;   }  return spec ;   }  
@ override public void   (  )  {     extra sent = false ;   }  
@ override protected void   (  )  throws  exception  {  super . set up (  )  ;  m mock context = new  mock context2 ( get mock context (  )  m context )  ;   content cache . invalidate all caches (  )  ;   }  
public static boolean   (  context context )  {   email content . init ( context )  ;   cursor c = null ;  try  {  c = context . get content resolver (  )  . query (  account . content   uri  account . id   projection null null null )  ;  boolean enable = c  !  =  null && c . get count (  )   >  0 ;  set services enabled ( context enable )  ;  return enable ;   }  finally  {  if  ( c  !  =  null )   {  c . close (  )  ;   }   }   }  
public long   (  )  {  return    highest acked through ;   }  
@ override public void   ( byte[] data )  {  super . set data ( data )  ;     cached hash code =  sip hash . hash code ( data )  ;   }  
private int   ( boolean ipv6 )  {  int rv = get listen port ( ipv6 )  ;  if  ( rv  >  0 )  return rv ;  rv =    context . get property ( prop   internal   port  - 1 )  ;  if  ( rv  >  0 )  return rv ;  return    context . get property ( prop   external   port  - 1 )  ;   }  
public static  < t o >  collector < t  ?  o >    (  supplier < o >  empty  function < t o >  factory )  {  return  collector . of (  (  )   -  >  new  optional builder <  >  ( empty factory )   optional builder::set  optional builder::combine  optional builder::build )  ;   }  
public synchronized int   (  )  {  return rrd map . size (  )  ;   }  
public boolean   ( iq packet )  {   element iq = packet . get child element (  )  ;   string name = iq . get name (  )  ;  return "macros" . equals ( name )  ;   }  
@ test public void   (  )  {  final  list <  string >  errors = new  array list <  string >  (  )  ;   revert sam .  validation util . validate output params by read group ( null null errors )  ;   assert . assert equals ( errors . size (  )  1 )  ;   ass
public  string   (  )  {  return get representative read (  )  . get read name (  )  ;   }  
public   (  output stream o )  {  super ( o )  ;     data expected =  - 1 ;   }  
@ test public void   (  )  {  mocked request . set requesturi ( " / v1 . 0 / limits" )  ;   http servlet request wrapper wrapped request = new  http servlet request wrapper ( mocked request )  ;   rate limiting configuration rate limiting configuration = 
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   maybe <  integer >  source =  maybe . create ( new  maybe on subscribe <  integer >  (  )  {  @ override public void subscribe (   maybe emitter <  integer 
@ test public void   (  )  {  assert that (  utils . equal ( 0 0 )  is ( 1 )  )  ;  assert that (  utils . equal ( 1 1 )  is ( 1 )  )  ;  assert that (  utils . equal ( 1 0 )  is ( 0 )  )  ;  assert that (  utils . equal ( 1 127 )  is ( 0 )  )  ;  assert 
@ override public void   (  )  {  sasl authentication . remove supported mechanism (  tiki token sasl server . mechanism   name )  ;   security . remove provider (  tiki token sasl provider . name )  ;   }  
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  actual . on complete (  )  ;   }   }  
public void   ( int status code )  throws  http exception  io exception  {  set response headers (  )  ;  response . set status ( status code )  ;  set response body (  )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 1024 )  ;  buf . append ( " mail part:"  +  "\n\tuidl:\t"  +  uidl  +  "\n\tbuffer:\t" +  buffer +  "\n\tbuffer offset:\t" +  buffer . get offset (  )  +  "\n\tbegin:\t" +  b
@ override public int   ( byte buf[] int off int len )  throws io exception  {  int rv = in . read ( buf off len )  ;  if  ( rv  >  0 )  count +  = rv ;  return rv ;   }  
public long   (  )  {  return    session id ;   }  
@ override public  iterator <  string >    (  )  {  return new  iterator <  string >  (  )  {  @ override public boolean has next (  )  {  return true ;   }  @ override public  string next (  )  {  throw new  test exception (  )  ;   }  @ override public 
public int   (  )  {  return height ;   }  
public void   (  call event listener listener )  {  synchronized  ( listeners )   {  listeners . remove ( listener )  ;   }   }  
@ override public void   (  )  {  inner complete ( this )  ;   }  
public void   ( boolean enable )  throws sql exception  {  cstmt . set escape processing ( enable )  ;   }  
private  destination   (  string name )  {  i2p app context ctx = i2p app context . get global context (  )  ;  boolean b32 = name . length (  )   =  =  60 && name . to lower case (  locale . us )  . ends with ( " . b32 . i2p" )  ;  if  ( ctx . is router context (  )  &&  ! b32 )   {   destination dest = ctx . naming service (  )  . lookup ( name )  ;  if  ( dest  !  =  null || ctx . is router context (  )  || name . length (  )   >  =  516 )  return dest ;   }  try  {  i2p session sess = sock mgr . get session (  )  ;  return sess . lookup dest ( name )  ;   }  catch  (  i2p session exception ise )   {     log . error ( " error looking up "  +  name ise )  ;  return null ;   }   }  
void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ test public void   (  )  {  fetch from ( "https: /  / "  +  stats   host false )  ;   }  
public void   (  schedule schedule )  {  if  ( schedule  =  =  null || schedule . getid (  )   !  =  id )   {  throw new  illegal argument exception (  )  ;   }  follow schedule = true ;  if  ( update workgroup (  )  )   {  broadcast presence (  )  ;   }   }  
@ override public void   (  member attribute event event )  {   cluster node info prior node info = cluster nodes info . get ( event . get member (  )  . get uuid (  )  )  ;  cluster nodes info . put ( event . get member (  )  . get uuid (  )  new  hazelc
public void   (  string rejection message )  {  this . rejection message = rejection message ;   }  
public int   (  )  {  return    on screen limit ;   }  
public void   (  string filter )  {  this . filter =  ( filter  =  =  null )   ?  null :  ( new  string[] { filter }  )  ;   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
protected  file transfer   (  string key )  {  return file transfer map . get ( key )  ;   }  
public boolean   (  )  {  return  ( cpuid . get extendedebx feature flags (  )  &  ( 1  <  <  5 )  )   !  =  0 ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . merge with (  single . just ( 100 )  )  . take ( 3 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
public static  java spec version   (  path plugin dir )  {  final  string value = get element value ( plugin dir " / plugin / min java version" )  ;  if  ( value  =  =  null || value . trim (  )  . is empty (  )  )   {  return null ;   }  return new  java spec version ( value )  ;   }  
public static  < t >  row mapper < t >    (  constructor < t >  constructor  string prefix )  {  return new  constructor mapper <  >  ( constructor prefix )  ;   }  
@get @ produces (  {  media type . application   xml  media type . application   json }  )  public  security audit logs   ( @ query param ( "username" )   string username @ query param ( "offset" )  int offset @ default value ( "100" )  @ query param ( "l
public synchronized void   (  buddy item buddy item boolean auto populate )  {  buddy items . put ( buddy item . get group id (  )  buddy item )  ;  if  ( auto populate )   {  populate group list (  )  ;   }   }  
@ override public boolean   (  )  {  return true ;   }  
@ test public void   (  )  {  assert null (  observable . empty (  )  . ignore elements (  )  . blocking get (  )  )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . group join (  flowable . just ( 2 )  new  function <  integer  flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   integer left )  throws  exception  {  return  flowa
protected   (  domain pair address  string text )  {  super ( address null )  ;  this . text = text ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ request variable lease set message: " )  ;  buf . append ( "\n\t session id: " )  . append ( get session id (  )  )  ;  buf . append ( "\n\t tunnels:
public  rrd db   (  )  {  return parent db ;   }  
public long   (  public key target  session key key )  {  return 0 ;   }  
@ override public  iterator <  element >    (  string name  string node jid senderjid )  {   element identity =  document helper . create element ( "identity" )  ;  identity . add attribute ( "category" "automation" )  ;  identity . add attribute ( "type"
public void   (  )  {  sampling task . cancel (  )  ;   }  
  (  atomic boolean live  atomic boolean lock  socket server  properties props  nameddb database  logger    log )  {  this . lock = lock ;  this . live = live ;  this . server = server ;  this . props = new  properties (  )  ;  this . database = database ;  this .    log =    log ;   lifted . copy properties ( props this . props )  ;   }  
public   (  )  {  m base uri = content   uri ;   }  
public boolean   ( int tunnel )  {  return    helper . get close on idle ( tunnel false )  ;   }  
public boolean   (  )  {  return  ( high quality depth histogram . is empty (  )  || high quality depth histogram non zero . is empty (  )  )  ;   }  
public static final void   (  string message  imap element expected  imap element actual )  {  if  ( expected  =  =  null && actual  =  =  null )   {  return ;   }  if  ( expected  !  =  null && expected . equals for test ( actual )  )   {  return ;   }   assert . fail (  string . format ( "%s expected = %s\nactual = %s" message expected actual )  )  ;   }  
@ override public void   (  servlet config servlet config  configuration configuration )  throws  servlet exception  {  try  {   document builder factory dbf =  document builder factory . new instance (  )  ;   document builder builder = dbf . new documen
@ before public void   (  )  {  scheduler = new  test scheduler (  )  ;  inner scheduler = scheduler . create worker (  )  ;   }  
public void   (  snark snark  comment set comments )  {     smgr . locked   save comments ( snark comments )  ;   }  
@ override public  string   (  string file )  {  return context . get mime type ( file )  ;   }  
public static  result producer <  result bearing >    (  )  {  return  ( supplier ctx )   -  >   result bearing . of ( get return result set ( supplier ctx )  ctx )  ;   }  
private void   (  print writer out  http servlet request req int start int page size int total boolean no thinsp )  {  if  ( start  >  0 )   {  out . write ( " < a href = \""  +     context path )  ;  out . write ( get query string ( req null "" null )  )  ;  out . write ( "\" > " )  ;  out . write ( to theme img ( "first"    t ( " first" )     t ( " first page" )  )  )  ;  out . write ( " <  / a > &nbsp ; " )  ;  int prev =  math . max ( 0 start  -  page size )  ;  if  ( true )   {  out . write ( "&nbsp ;  < a href = \""  +     context path )  ;   string sprev =  ( prev  >  0 )   ?   integer . to string ( prev )  : "" ;  out . write ( get query string ( req null sprev null )  )  ;  out . write ( "\" > " )  ;  out . write ( to theme img ( "previous"    t ( " prev" )     t ( " previous page" )  )  )  ;  out . write ( " <  / a > &nbsp ; " )  ;   }   }  else  {  out . write ( " < img alt = \"\" border = \"0\" class = \"disable\" src = \""  +     img path  +  "first . png\" > " +  "&nbsp ; " +  " < img alt = \"\" border = \"0\" class = \"disable\" src = \"" +     img path +  "previous . png\" > " +  "&nbsp ; " )  ;   }  int pages = 1  +   (  ( total  -  1 )   /  page size )  ;  if  ( pages  =  =  1 && start  >  0 )  pages = 2 ;  if  ( pages  >  1 )   {  int page ;  if  ( start  +  page size  >  =  total )  page = pages ;  else page = 1  +   ( start  /  page size )  ;  out . write ( "&nbsp ; &nbsp ; "  +  page  +  thinsp ( no thinsp )  +  pages +  "&nbsp ; &nbsp ; " )  ;   }  if  ( start  +  page size  <  total )   {  int next = start  +  page size ;  if  ( true )   {  out . write ( "&nbsp ;  < a href = \""  +     context path )  ;  out . write ( get query string ( req null  integer . to string ( next )  null )  )  ;  out . write ( "\" > " )  ;  out . write ( to theme img ( "next"    t ( " next" )     t ( " next page" )  )  )  ;  out . write ( " <  / a > &nbsp ; " )  ;   }  int last =  (  ( total  -  1 )   /  page size )  * page size ;  out . write ( "&nbsp ;  < a href = \""  +     context path )  ;  out . write ( get query string ( req null  integer . to string ( last )  null )  )  ;  out . write ( "\" > " )  ;  out . write ( to theme img ( "last"    t ( " last" )     t ( " last page" )  )  )  ;  out . write ( " <  / a > &nbsp ; " )  ;   }  else  {  out . write ( "&nbsp ; "  +  " < img alt = \"\" border = \"0\" class = \"disable\" src = \""  +     img path  +  "next . png\" > " +  "&nbsp ; " +  " < img alt = \"\" border = \"0\" class = \"disable\" src = \"" +     img path +  "last . png\" > " )  ;   }   }  
private void   (  )  throws  exception  {  if  (  !  jive globals . get boolean property ( "flash . crossdomain . enabled" true )  )   {   log . debug ( " flash cross domain listener is disabled" )  ;  return ;   }  int port =  jive globals . get int property ( "flash . crossdomain . port" 5229 )  ;  try  {   string interface name =  jive globals . getxml property ( "network . interface" )  ;   inet address bind interface = null ;  if  ( interface name  !  =  null )   {  if  ( interface name . trim (  )  . length (  )   >  0 )   {  bind interface =  inet address . get by name ( interface name )  ;   }   }  server socket = new  server socket ( port  - 1 bind interface )  ;   log . debug ( " flash cross domain is listening on "  +  interface name  +  " on port " +  port )  ;   }  catch  (  io exception e )   {   log . error ( " could not listen on port: "  +  port e )  ;  return ;   }  while  ( true )   {   socket client socket = null ;   print writer out = null ;   buffered reader in = null ;  try  {  client socket = server socket . accept (  )  ;  client socket . set so timeout ( 10000 )  ;  out = new  print writer ( client socket . get output stream (  )  true )  ;  in = new  buffered reader ( new  input stream reader ( client socket . get input stream (  )  )  )  ;   string request = "" ;  request = read ( in )  ;  if  ( request . contains ( " < policy - file - request /  > " )  || request . contains ( "get  / crossdomain . xml" )  )   {  out . write ( cross   domain   text  +  xmpp server . get instance (  )  . get connection manager (  )  . get client listener port (  )   +  cross   domain   end   text +  "\u0000" )  ;   }   }  catch  (  io exception e )   {  if  ( xmpp server . get instance (  )  . is shutting down (  )  )   {  break ;   }   log . error ( e . get message (  )  e )  ;   }  finally  {  if  ( out  !  =  null )   {  out . flush (  )  ;  out . close (  )  ;   }  if  ( in  !  =  null )   {  in . close (  )  ;   }  if  ( client socket  !  =  null )   {  client socket . close (  )  ;   }   }   }   }  
@ deprecated public final void   (  key cache entry key )  {     available keys . offer ( key )  ;   }  
private void   ( final boolean use barcodes final boolean index optical duplicates )  {  final int entry overhead ;  if  ( tag   duplicate   set   members )   {  entry overhead = 16 ;   }  else  {  entry overhead =  sorting long collection . sizeof ;   }  int max in memory =  ( int )  math . min (  (  runtime . get runtime (  )  . max memory (  )  * 0 . 25 )   /  entry overhead  ( double )  (  integer . max   value  -  5 )  )  ;  if  ( index optical duplicates )   {  max in memory /  =  (  ( entry overhead  +   sorting long collection . sizeof )   /  entry overhead )  ;  this . optical duplicate indexes = new  sorting long collection ( max in memory tmp   dir . to array ( new  file[tmp   dir . size (  ) ] )  )  ;   }  log . info ( " will retain up to "  +  max in memory  +  " duplicate indices before spilling to disk . " )  ;  this . duplicate indexes = new  sorting long collection ( max in memory tmp   dir . to array ( new  file[tmp   dir . size (  ) ] )  )  ;  if  ( tag   duplicate   set   members )   {  final  representative read indexer codec representative index codec = new  representative read indexer codec (  )  ;  this . representative read indices for duplicates =  sorting collection . new instance (  representative read indexer . class representative index codec  comparator . comparing ( read  -  >  read . read index in file )  max in memory tmp   dir )  ;   }   read ends for mark duplicates first of next chunk = null ;  final  list <  read ends for mark duplicates >  next chunk = new  array list <  >  ( 200 )  ;  log . info ( " traversing read pair information and detecting duplicates . " )  ;  for  (  final  read ends for mark duplicates next : this . pair sort )   {  if  ( first of next chunk  !  =  null && are comparable for duplicates ( first of next chunk next true use barcodes )  )   {  next chunk . add ( next )  ;   }  else  {  if  ( next chunk . size (  )   >  1 )   {  mark duplicate pairs ( next chunk )  ;  if  ( tag   duplicate   set   members )   {  add representative read index ( next chunk )  ;   }   }  next chunk . clear (  )  ;  next chunk . add ( next )  ;  first of next chunk = next ;   }   }  if  ( next chunk . size (  )   >  1 )   {  mark duplicate pairs ( next chunk )  ;  if  ( tag   duplicate   set   members )   {  add representative read index ( next chunk )  ;   }   }  this . pair sort . cleanup (  )  ;  this . pair sort = null ;  log . info ( " traversing fragment information and detecting duplicates . " )  ;  boolean contains pairs = false ;  boolean contains frags = false ;  first of next chunk = null ;  for  (  final  read ends for mark duplicates next : this . frag sort )   {  if  ( first of next chunk  !  =  null && are comparable for duplicates ( first of next chunk next false use barcodes )  )   {  next chunk . add ( next )  ;  contains pairs = contains pairs || next . is paired (  )  ;  contains frags = contains frags ||  ! next . is paired (  )  ;   }  else  {  if  ( next chunk . size (  )   >  1 && contains frags )   {  mark duplicate fragments ( next chunk contains pairs )  ;   }  next chunk . clear (  )  ;  next chunk . add ( next )  ;  first of next chunk = next ;  contains pairs = next . is paired (  )  ;  contains frags =  ! next . is paired (  )  ;   }   }  mark duplicate fragments ( next chunk contains pairs )  ;  this . frag sort . cleanup (  )  ;  this . frag sort = null ;  log . info ( " sorting list of duplicate records . " )  ;  this . duplicate indexes . done adding start iteration (  )  ;  if  ( this . optical duplicate indexes  !  =  null )   {  this . optical duplicate indexes . done adding start iteration (  )  ;   }  if  ( tag   duplicate   set   members )   {  this . representative read indices for duplicates . done adding (  )  ;   }   }  
public void   ( jid sender jid receiver )  {  final  chat state session session = new  chat state session ( sender receiver )  ;  synchronized  ( mutex )   {  final  chat state type previous state = current states . remove ( session )  ;  if  ( previous state  !  =  null )   {  send is gone ( sender receiver )  ;   }  final  scheduled future <  ?  >  old future = pending state changes . remove ( session )  ;  if  ( old future  !  =  null )   {  old future . cancel ( false )  ;   }   }   }  
public boolean   (  )  {  if  ( acceptor  =  =  null )  return false ;  acceptor . restart (  )  ;  return true ;   }  
public  string   (  )  {  final  string builder sb = new  string builder (  )  ;  sb . append ( " < h3 id = \"upnp\" > " )  . append (    t ( "u pnp  status" )  )  . append ( " <  / h3 >  < div id = \"upnpscan\" > " )  ;  synchronized  (    otherud ns )   {  if  (  !    otherud ns . is empty (  )  )   {  sb . append (    t ( " disabled u pnp  devices" )  )  ;  sb . append ( " < ul > " )  ;  for  (   map .  entry <  string  string >  e :    otherud ns . entry set (  )  )   {   string udn = e . get key (  )  ;   string name = e . get value (  )  ;  sb . append ( " < li > " )  . append (  data helper . escapehtml ( name )  )  ;  sb . append ( " < br > udn: " )  . append (  data helper . escapehtml ( udn )  )  . append ( " <  / li > " )  ;   }  sb . append ( " <  / ul > " )  ;   }   }  if  ( is disabled )   {  sb . append ( " < p > " )  ;  sb . append (    t ( "u pnp has been disabled ;   do you have more than one u pnp  internet  gateway  device on your lan  ? " )  )  ;  return sb . to string (  )  ;   }  else if  (  ! isnat present (  )  )   {  sb . append ( " < p > " )  ;  sb . append (    t ( "u pnp has not found any u pnp - aware  compatible device on your lan . " )  )  ;  return sb . to string (  )  ;   }   device router ;  synchronized  ( lock )   {  router =    router ;   }  if  ( router  !  =  null )  list sub dev ( null router sb )  ;   string addr = getnat address (  )  ;  sb . append ( " < p > " )  ;  if  ( addr  !  =  null )  sb . append (    t ( " the current external ip address reported by u pnp is  { 0 } "  data helper . escapehtml ( addr )  )  )  ;  else sb . append (    t ( " the current external ip address is not available . " )  )  ;  int downstream max bit rate = get downstream max bit rate (  )  ;  int upstream max bit rate = get upstream max bit rate (  )  ;  if  ( downstream max bit rate  >  0 )  sb . append ( " < br > " )  . append (    t ( "u pnp reports the maximum downstream bit rate is  { 0 } bits / sec"  data helper . format size2 decimal ( downstream max bit rate )  )  )  ;  if  ( upstream max bit rate  >  0 )  sb . append ( " < br > " )  . append (    t ( "u pnp reports the maximum upstream bit rate is  { 0 } bits / sec"  data helper . format size2 decimal ( upstream max bit rate )  )  )  ;  synchronized  ( lock )   {  for  (   forward port port : ports to forward )   {  sb . append ( " < br > " )  ;  if  ( ports forwarded . contains ( port )  )  sb . append (    t ( " { 0 }  port  { 1 number ##### }  was successfully forwarded by u pnp . " proto to string ( port . protocol )  port . port number )  )  ;  else sb . append (    t ( " { 0 }  port  { 1 number ##### }  was not forwarded by u pnp . " proto to string ( port . protocol )  port . port number )  )  ;   }   }  sb . append ( " <  / p >  <  / div > " )  ;  return sb . to string (  )  ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 100 10 * 1000 * 1000 10 * 1000 * 1000 )  )  . filter (  functions . always true (  )  )  . take ( 1000 * 1000 )  . test (  )  . assert subscribed (  )  . assert value count
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to multimap ( null )  ;   }  
public boolean   (  )  {  return is locked ;   }  
@post public  response   (  system property system property )  throws  service exception  {  plugin . create system property ( system property )  ;  return  response . status (  response .  status . created )  . build (  )  ;   }  
public  list <  string >    (  )  {  return values ;   }  
@ test public void   (  )  {   test helper . check double on subscribe completable to observable ( new  function <  completable  observable <  ?  >  >  (  )  {  @ override public  observable <  ?  >  apply (   completable c )  throws  exception  {  return
@ override public void   (  )  {  m security type view . set on item selected listener ( new  adapter view .  on item selected listener (  )  {  @ override public void on item selected (   adapter view <  ?  >  arg0   view arg1  int arg2  long arg3 )  {  
public  string   (  )  {  return custom auth filter class name ;   }  
public static long   ( final  content resolver cr final long message id )  {  final  string[] selection args =  {  string . value of ( message id )  }  ;  final  cursor move cursor = cr . query ( content   uri  projection last synced mailbox query . projection selection   last   synced   mailbox selection args id  +  " asc" )  ;  if  ( move cursor  !  =  null )   {  try  {  if  ( move cursor . move to first (  )  )   {  return move cursor . get long (  projection last synced mailbox query . column   src   folder   key )  ;   }   }  finally  {  move cursor . close (  )  ;   }   }  final  cursor message cursor = cr . query (  content uris . with appended id (  email content .  message . content   uri message id )   email content .  message . mailbox   key   projection null null null )  ;  if  ( message cursor  !  =  null )   {  try  {  if  ( message cursor . move to first (  )  )   {  return message cursor . get long ( 0 )  ;   }   }  finally  {  message cursor . close (  )  ;   }   }  return  mailbox . no   mailbox ;   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  int missed = 1 ;  for  (  ;   ;   )   {  if  ( sa . is disposed (  )  )   {  return ;   }  source . subscribe ( this )  ;  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }   }  
@ data provider ( name = "multi file parsing data" )  private  object[][]   (  )  {  return new  object[][] {  { new  file ( test file1 )  new  file ( test file1 )  }   { io util . open file for reading ( new  file ( test file1 )  )  io util . open file f
public byte[]   (  )  {  return a ;   }  
@ override public  boolean   (  )  {  return true ;   }  
private static  string[]   (  file geo file  long[] search  map <  string  string >  code cache  log log )  {   string[] rv = new  string[search . length] ;  int idx = 0 ;  long start =  system . current time millis (  )  ;   input stream in = null ;  try  {  in = new gzip input stream ( new  buffered input stream ( new  file input stream ( geo file )  )  )  ;  byte[] magic = new byte[magic . length (  ) ] ;   data helper . read ( in magic )  ;  if  (  !  data helper . eq ( magic  data helper . getascii ( magic )  )  )  throw new io exception ( " not a i pv6 geoip data file" )  ;   data helper . skip ( in header   len  -  magic . length (  )  )  ;  byte[] buf = new byte[18] ;  while  (  data helper . read ( in buf )   =  =  18 && idx  <  search . length )   {  long ip1 = read long ( buf 0 )  ;  long ip2 = read long ( buf 8 )  ;  while  ( idx  <  search . length && search[idx] . long value (  )   <  ip1 )   {  idx +  +  ;   }  while  ( idx  <  search . length && search[idx] . long value (  )   >  =  ip1 && search[idx] . long value (  )   <  =  ip2 )   {   string lc = new  string ( buf 16 2 "iso - 8859 - 1" )  ;   string cached = code cache . get ( lc )  ;  if  ( cached  =  =  null )  cached = lc ;  rv[idx +  + ] = cached ;   }   }   }  catch  (  io exception ioe )   {  if  ( log . should log (  log . error )  )  log . error ( " error reading the geo file" ioe )  ;   }  finally  {  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  if  ( log . should log (  log . info )  )  log . info ( " geoi pv6 processing finished  time: "  +   (  system . current time millis (  )   -  start )  )  ;  return rv ;   }  
public void   (  session session )  {  try  {  new  registration handler ( this )  . delete registration ( xmpp server . get instance (  )  . createjid ( session . get address (  )  . get node (  )  null )  )  ;   }  catch  (   user not found exception e )   {   }   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer
private static final  string   (  string s )  {  return s ;   }  
boolean   (  inner disposable < t >  producer )  {  for  (  ;   ;   )   {   inner disposable < t > [] c = observers . get (  )  ;  if  ( c  =  =  terminated )   {  return false ;   }  int len = c . length ;  @ suppress warnings ( "unchecked" )   inner disposable < t > [] u = new  inner disposable[len  +  1] ;   system . arraycopy ( c 0 u 0 len )  ;  u[len] = producer ;  if  ( observers . compare and set ( c u )  )   {  return true ;   }   }   }  
public static  key store   (  )  {   key store ks ;  try  {  ks =  key store . get instance (  key store . get default type (  )  )  ;   }  catch  (   general security exception gse )   {  error ( " key  store init error" gse )  ;  return null ;   }  boolean success = false ;   string override =  system . get property ( "javax . net . ssl . key store" )  ;  if  ( override  !  =  null )  success = load certs ( new  file ( override )  ks )  ;  if  (  ! success )   {  if  (  system version . is android (  )  )   {  if  (  system version . get android version (  )   >  =  14 )   {  try  {  ks . load ( null default   keystore   password . to char array (  )  )  ;  success = add certs ( new  file (  system . get property ( "java . home" )  "etc / security / cacerts" )  ks )   >  0 ;   }  catch  (  io exception e )   {   }  catch  (   general security exception e )   {   }   }  else  {  success = load certs ( new  file (  system . get property ( "java . home" )  "etc / security / cacerts . bks" )  ks )  ;   }   }  else  {  success = load certs ( new  file (  system . get property ( "java . home" )  "lib / security / jssecacerts" )  ks )  ;  if  (  ! success )  success = load certs ( new  file (  system . get property ( "java . home" )  "lib / security / cacerts" )  ks )  ;   }   }  if  ( success )   {  remove blacklisted certs ( ks )  ;   }  else  {  try  {  ks . load ( null default   keystore   password . to char array (  )  )  ;   }  catch  (  io exception e )   {   }  catch  (   general security exception e )   {   }  error ( " all key store loads failed  will only load local certificates" null )  ;   }  return ks ;   }  
void   (  remote host id alice udp packet reader reader )  {  if  (    context . router (  )  . is hidden (  )  )  return ;  udp packet reader .  relay request reader rr reader = reader . get relay request reader (  )  ;  long tag = rr reader . read tag (  )  ;  int ip size = rr reader . readip size (  )  ;  int port = rr reader . read port (  )  ;  byte[] aliceip = alice . getip (  )  ;  int alice port = alice . get port (  )  ;  if  (  ! is valid ( alice . getip (  )  alice . get port (  )  )  )   {  if  (    log . should warn (  )  )     log . warn ( " bad relay req from "  +  alice  +  " for " +   addresses . to string ( aliceip alice port )  )  ;     context . stat manager (  )  . add rate data ( "udp . relay badip" 1 )  ;  return ;   }  if  ( ip size  !  =  0 )   {  byte ip[] = new byte[ip size] ;  rr reader . readip ( ip 0 )  ;  if  (  !  arrays . equals ( aliceip ip )  )   {  if  (    log . should warn (  )  )     log . warn ( " bad relay req from "  +  alice  +  " for " +   addresses . to string ( ip port )  )  ;     context . stat manager (  )  . add rate data ( "udp . relay badip" 1 )  ;  return ;   }   }  if  ( port  !  =  0 && port  !  =  alice port )   {  if  (    log . should warn (  )  )     log . warn ( " bad relay req from "  +  alice  +  " for " +   addresses . to string ( aliceip port )  )  ;     context . stat manager (  )  . add rate data ( "udp . relay badip" 1 )  ;  return ;   }   peer state charlie = get ( tag )  ;  if  ( charlie  =  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( " receive relay request from "  +  alice  +  " with unknown tag" )  ;     context . stat manager (  )  . add rate data ( "udp . receive relay request bad tag" 1 )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " receive relay request from "  +  alice  +  " for tag " +  tag +  " and relaying with " +  charlie )  ;     context . stat manager (  )  . add rate data ( "udp . receive relay request" 1 )  ;     transport . send (    builder . build relay intro ( alice charlie reader . get relay request reader (  )  )  )  ;   session key cipher key = null ;   session key mac key = null ;   peer state alice state =    transport . get peer state ( alice )  ;  if  ( alice state  !  =  null )   {  cipher key = alice state . get current cipher key (  )  ;  mac key = alice state . get currentmac key (  )  ;   }  if  ( cipher key  =  =  null || mac key  =  =  null )   {  byte key[] = new byte[ session key . keysize   bytes] ;  reader . get relay request reader (  )  . read alice intro key ( key 0 )  ;  cipher key = new  session key ( key )  ;  mac key = cipher key ;  if  (    log . should log (  log . info )  )     log . info ( " sending relay response  ( w /  intro key )  to "  +  alice )  ;   }  else  {  if  (    log . should log (  log . info )  )     log . info ( " sending relay response  ( in - session )  to "  +  alice )  ;   }     transport . send (    builder . build relay response ( alice charlie reader . get relay request reader (  )  . read nonce (  )  cipher key mac key )  )  ;   }  
@ suppress warnings ( "squid:s1848" )  public   ( final  string date format )  {  this . date format =  string utils . is empty ( date format )   ?  default   date   format : date format ;  new  simple date format ( date format )  ;   }  
@ override public boolean   (  )  {  for  (  ;   ;   )   {  boolean d = done ;  boolean empty = queue . is empty (  )  ;  if  ( d )   {   throwable e = error ;  if  ( e  !  =  null )   {  throw  exception helper . wrap or throw ( e )  ;   }  else if  ( em
public  map <  string  string >    (  )  {  return    opts ;   }  
@ benchmark public void   (  blackhole bh )  {  flow flat map iterable1 . subscribe ( new  perf consumer ( bh )  )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public  < t > t   ( int pos  class < t >  type )  {  return type . cast ( get object ( pos )  )  ;   }  
public int   (  )  {  int result = 0 ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   session   count )  ;   result set rs = pstmt . execute query (  )  ;  rs . next (  )  ;  result = rs . get int ( 1 )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return result ;   }  
public void   (  string key  string value )  {     properties . set property ( key value )  ;  write config file (  )  ;   }  
@ test public void   (  )  throws io exception  {  final  file outfile =  file . create temp file ( "test" " . gc   bias . summary   metrics" )  ;  final  file details outfile =  file . create temp file ( "test" " . gc   bias . detail   metrics" )  ;  out
public   (  router context ctx  console update manager mgr )  {     context = ctx ;     mgr = mgr ;   }  
@ override public void   (  throwable e )  {  inner error ( this e )  ;   }  
  (  single observer <  ?  super  boolean >  actual )  {  this . actual = actual ;   }  
public void   ( int ms )  {  long count = 0 ;  long bw = 0 ;  long tcount = 0 ;  long too young =    context . clock (  )  . now (  )   -  60 * 1000 ;  long too old = too young  -  9 * 60 * 1000 ;  for  (   hop config cfg :    participating config . values (  )  )   {  long c = cfg . get and reset recent messages count (  )  ;  bw +  = c ;  long created = cfg . get creation (  )  ;  if  ( created  >  too young || created  <  too old )  continue ;  tcount +  +  ;  count +  = c ;   }  if  ( tcount  >  0 )  count = count *  ( 10 * 60 * 1000  /  ms )   /  tcount ;     context . stat manager (  )  . add rate data ( "tunnel . participating message count avg per tunnel" count ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating message count" bw ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating bandwidth" bw * 1024  /   ( ms  /  1000 )  ms )  ;     context . stat manager (  )  . add rate data ( "tunnel . participating tunnels" tcount )  ;   }  
private  string   (  )  {   string rtpmaps = "" ;  for  ( int i = 0 ;  i  <  supported media . size (  )  ;  i +  +  )   {   media info media info =  (  media info ) supported media . element at ( i )  ;  if  ( media info . get sample rate (  )   >  max sample rate || media info . get channels (  )   >  max channels )   {  continue ;   }  rtpmaps +  = generate rtpmap ( media info )   +  "\r\n" ;   }  return rtpmaps ;   }  
@ override public void   (  string username )  {  get user provider ( username )  . delete user ( username )  ;   }  
public static void   (  string username )  {   string message = get mark message ( username )  ;  warn ( message )  ;   }  
public static void   (  string treatment )  throws  parse exception  {  synchronized  ( conference list )   {  for  ( int i = 0 ;  i  <  conference list . size (  )  ;  i +  +  )   {   conference manager conference manager =  (  conference manager ) conference list . get ( i )  ;  play treatment ( conference manager . get id (  )  treatment )  ;   }   }   }  
public   ( final  string extension final  file base final  file faker faker final int lane final boolean skip empty files )  {  super ( true extension base faker lane skip empty files )  ;  this . file map = get tiled files ( base match pattern )  ;  if  (  ! file map . is empty (  )  )   {  this . tiles = new  array list <  >  ( this . file map . key set (  )  )  ;   }  else  {  this . tiles =  collections . empty list (  )  ;   }   }  
public void   ( byte target[] int target offset )  {  int offset = read body offset (  )  ;  offset +  =    message[offset] & 0xff ;  offset +  = 1  +  2 ;  int sz =    message[offset] & 0xff ;  offset +  +  ;   system . arraycopy (    message offset target target offset sz )  ;   }  
public   (  string registration address  type type )  {  super ( registration address )  ;  this . type = type ;   }  
public  string   (  )  {  return " load up any client applications" ;   }  
public void   (  disposable resource )  {   disposable helper . set ( this resource )  ;   }  
public int   (  )  {  return hash   length ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register object argument factory register object argument factory =  (  register object argument factory ) annotation ;   arguments argument
public boolean   (  )  {  return filter status enabled ;   }  
public void   (  )  {  set login status (  transport login status . logged   in )  ;  set presence (  presence type . available )  ;  try  {  get transport (  )  . sync legacy roster ( getjid (  )  get buddy manager (  )  . get buddies (  )  )  ;  get buddy manager (  )  . activate (  )  ;   }  catch  (   user not found exception e )   {   log . debug ( "simple:  unable to find user whose roster we're trying to sync: "  +  getjid (  )  )  ;   }   }  
private o   ( int i )  {  o result = null ;  if  ( elements  !  =  null )   {  result = elements[i] ;   }  return result ;   }  
public void   ( double volume )  {  member sender . set output volume ( volume )  ;   }  
private static  method   (  )  {  try  {  return  method handles . class . get method ( "private lookup in"  class . class  method handles .  lookup . class )  ;   }  catch  (   no such method exception e )   {  return null ;   }   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   flowable <  object >  f )  throws  exception  { 
private static  string   (  string s )  {  return i2p snark servlet . urlify ( s )  ;   }  
private void   (  message message )  throws  exception  {   string builder sb = new  string builder (  )  ;  sb . append ( " new email has been received\n" )  ;  sb . append ( " from: " )  ;  for  (   address address : message . get from (  )  )   {  sb . append ( address . to string (  )  )  . append ( " " )  ;   }  sb . append ( "\n" )  ;   date date = message . get sent date (  )  ;  sb . append ( " received: " )  . append ( date  !  =  null  ?  date . to string (  )  : "unknown" )  . append ( "\n" )  ;  sb . append ( " subject: " )  . append ( message . get subject (  )  )  . append ( "\n" )  ;  append message part ( message sb )  ;  for  (   string user : get users (  )  )   {  org . xmpp . packet .  message notification = new org . xmpp . packet .  message (  )  ;  notification . set from ( xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  )  ;  notification . set to ( user )  ;  notification . set subject ( " new email has been received" )  ;  notification . set body ( sb . to string (  )  )  ;  xmpp server . get instance (  )  . get message router (  )  . route ( notification )  ;   }   }  
public long   (  )  {  return accumulated request size ;   }  
@ override public void   (  )  {  finish (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe . just ( 1 )  . delay subscription (  flowable . never (  )  )  )  ;   }  
@ override protected void   (  session data data  element command )  {   data form form = new  data form (  data form .  type . form )  ;  form . set title ( " requesting  list of  active  users" )  ;  form . add instruction ( " fill out this form to requ
public static long   ( final  node parent node final  string child name )  throws  rrd exception  {  final  string value str = get child value ( parent node child name )  ;  return  long . parse long ( value str )  ;   }  
  (  maybe observer <  ?  super r >  actual  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper )  {  this . actual = actual ;  this . mapper = mapper ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  500 ;  i +  +  )   {   test observer <  object >  to =  observable . merge (  observable . just ( 1 )  . observe on (  schedulers . single (  )  )  . map ( new  function <  integer  object >  (  )  {
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  long consumer on request )  {  return do on lifecycle (  functions . empty consumer 
@ suppress warnings (  { "rawtypes" "unchecked" }  )  public void   (  map settings )  {     settings = new  hash map ( settings )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
@ override public int   (  )  {  try  {  pool lock . lock (  )  ;  return checkout counter  +  pool . size (  )  ;   }  finally  {  pool lock . unlock (  )  ;   }   }  
@ override public void   (  description description )  {  description . append text ( " response with success: "  +  has requests  +  " reset time greater than: " +  reset time +  "and less than: " +   ( reset time  +  120000 )  +  " current limit amount:
@ override public void   (  throwable t )  {  d =  disposable helper . disposed ;  actual . on error ( t )  ;   }  
 string   ( jid jid1 jid jid2 )  {   string builder builder = new  string builder (  )  ;  if  ( jid1 . compare to ( jid2 )   <  0 )   {  builder . append ( jid1 . to barejid (  )  )  . append ( "   " )  . append ( jid2 . to barejid (  )  )  ;   }  else  {  builder . append ( jid2 . to barejid (  )  )  . append ( "   " )  . append ( jid1 . to barejid (  )  )  ;   }  return builder . to string (  )  ;   }  
protected void   ( long mailbox id boolean user request int delta message count )  {  final  mailbox mailbox =  mailbox . restore mailbox with id ( m context mailbox id )  ;  if  ( mailbox  =  =  null )  return ;  final  account account =  account . restore account with id ( m context mailbox . m account key )  ;  if  ( account  =  =  null )  return ;  final  email service info info =  email service utils . get service info for account ( m context account . m id )  ;  final android . accounts .  account acct = new android . accounts .  account ( account . m email address info . account type )  ;  final  bundle extras =  mailbox . create sync bundle ( mailbox id )  ;  if  ( user request )   {  extras . put boolean (  content resolver . sync   extras   manual true )  ;  extras . put boolean (  content resolver . sync   extras   do   not   retry true )  ;  extras . put boolean (  content resolver . sync   extras   expedited true )  ;   }  if  ( delta message count  !  =  0 )   {  extras . put int (  mailbox . sync   extra   delta   message   count delta message count )  ;   }   content resolver . request sync ( acct  email content . authority extras )  ;   log utils . i (  logging . log   tag "request sync  email service stub start sync %s  %s" account . to string (  )  extras . to string (  )  )  ;   }  
public  connection options   (  )  {  return    options ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set single scheduler handler ( replace with immediate )  ;  assert same (  immediate thin scheduler . instance  schedulers . single (  )  )  ;   }  finally  {   rx java plugins . reset (  )  ;   }  
@ override public boolean   (  )  {  return  log . is warn enabled (  )  ;   }  
@ override public void   (  )  {  inner complete ( this )  ;   }  
@ override public void   (  )  {  super . on destroy (  )  ;  if  ( m account observer  !  =  null )   {  get content resolver (  )  . unregister content observer ( m account observer )  ;  m account observer = null ;   }  if  ( m waiting for folders dial
public static void   ( final  string[] args )  {  new  illumina basecalls to fastq (  )  . instance main with exit ( args )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   spsc array queue <  object >  q = new  spsc array queue <  object >  ( 16 )  ;  q . offer ( null )  ;   }  
@ test public void   (  )  {   async processor <  object >  p =  async processor . create (  )  ;  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test subscriber <  object >  ts1 = p . test (  )  ;  final  test su
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  if  ( 1  /  v  <  0 )   {   system . out . println ( " shou
public   ( i2p app context context boolean locally created )  {  super ( context )  ;     type =  type . any ;   }  
@ override public final void   ( @ non null  disposable s )  {  if  (  end consumer helper . set once ( this . s s get class (  )  )  )   {  on start (  )  ;   }   }  
@ override public void   (  subscriber <  ?  super  boolean >  s )  {   equal coordinator < t >  parent = new  equal coordinator < t >  ( s prefetch comparer )  ;  s . on subscribe ( parent )  ;  parent . subscribe ( first second )  ;   }  
@ override public  iterable <  integer >    (  integer v )  throws  exception  {  return list ;   }  
public int   (  )  {  return ttl in seconds ;   }  
public void   (  )  {  lock . write lock (  )  . lock (  )  ;   }  
  (  conditional subscriber <  ?  super t >  actual t[] array )  {  super ( array )  ;  this . actual = actual ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 1 100 100 )  )  . test (  )  . assert failure and message (  test exception . class "iterator (  ) " )  ;   }  
@ override public  string   (  )  {  return " add members or admins to a group" ;   }  
public   (  localmuc room room  message message int occupants )  {  super ( room )  ;  this . message = message ;  this . occupants = occupants ;   }  
private  list <  header name >    (  )  {   list <  header name >  result = new  linked list <  >  (  )  ;  if  ( request  !  =  null )   {   enumeration <  string >  names = request . get header names (  )  ;  if  ( names  !  =  null )   {  while  ( names . has more elements (  )  )   {  result . add (  header name . wrap ( names . next element (  )  )  )  ;   }   }   }  return result ;   }  
@ test public void   (  )  {   flowable <  string >  w =  flowable . just ( "one" "two" "three" )  ;   flowable <  string >  take = w . take last ( 2 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   in order in order = in
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ database search reply message: " )  ;  buf . append ( "\n\t search  key: " )  . append (    key )  ;  buf . append ( "\n\t replies: #  =  " )  . appe
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  object >  func = mock (  callable . class )  ;   throwable throwable = new  illegal state exception ( " test exception" )  ;  when ( func . call (  )  )  . 
@ override public  pooled object < smpp session >    ( smpp session smpp session )  {  return new  default pooled object <  >  ( smpp session )  ;   }  
private static void   (  throwable ex )  {   byte array output stream baos = new  byte array output stream (  )  ;   print stream print stream = new  print stream ( baos )  ;  ex . print stack trace ( print stream )  ;  assert false ( baos . to string (  )  . contains ( "circular reference" )  )  ;   }  
public void   ( final  string type final byte[] data )  {  this . pending avatar = data ;  try  {  final  message digest digest =  message digest . get instance ( "md5" )  ;  digest . update ( data )  ;  final  extra info data eid = new  extra info data (  extra info data . flag   hash   present  byte block . wrap ( digest . digest (  )  )  )  ;  final  ssi command request ;  final  icon item new icon item ;  if  ( icon  !  =  null )   {  new icon item = new  icon item ( icon )  ;  new icon item . set icon info ( eid )  ;  request = new  modify items cmd ( new icon item . to ssi item (  )  )  ;   }  else  {  new icon item = new  icon item (  icon item . name   default this . get next buddy id (  ssi item . group   root )  eid )  ;  request = new  create items cmd ( new icon item . to ssi item (  )  )  ;   }  request ( new  pre mod cmd (  )  )  ;  request ( request )  ;  request ( new  post mod cmd (  )  )  ;  this . icon = new icon item ;   }  catch  (   no such algorithm exception e )   {   log . error ( " no algorithm found for md5 checksum ?  ? " )  ;   }   }  
public synchronized o   ( o element )  {  o result = null ;  int i = get index of ( element )  ;  if  ( i  !  =   - 1 && elements  !  =  null )   {  i -  -  ;  if  ( i  >  =  0 && i  <  elements . length )  result = elements[i] ;   }  return result ;   }  
private  node   (  )  {  return get service node (  )  . get root node (  )  ;   }  
public  raw print filter   (  )  {  return old port filter ;   }  
@ override public  transport   (  )  {  return ntcp transport . this ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . observe on ( new  test scheduler (  )  )  )  ;   }  
public void   (  string value )  {  get device node (  )  . set node ( model   name value )  ;   }  
public  packet type   (  )  {  return packet type ;   }  
@ test public void   (  )  {   message message = new  message (  )  ;  message . set type (  message .  type . chat )  ;   packet extension chat state = new  packet extension ( "composing" "http: /  / jabber . org / protocol / chatstates" )  ;  message . 
@ test public void   (  )  {   single subject <  integer >  ss =  single subject . create (  )  ;   test observer <  integer >  to = ss . test (  )  ;  ss . on success ( 1 )  ;  ss . on success ( 2 )  ;   list <  throwable >  errors =  test helper . track
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to multimap ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   new  function <  integer  object >  (
public  string   (  )  {  return from email ;   }  
@ override public  sql statement parameter customizer   (  annotation annotation  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return  ( stmt arg )   -  >   {  final  type type arg ;  if  ( arg instanceof  gene
public  collection <  workgroup >    (  )  {  return workgroups ;   }  
@ override protected void   (  )  {  multi collector . finish (  )  ;  final  metrics file <  insert size metrics  integer >  file = get metrics file (  )  ;  multi collector . add all levels to file ( file )  ;  if  ( file . get num histograms (  )   =  
public  rrd graph def   (  )  throws  rrd exception  {  if  (  ! root . get tag name (  )  . equals ( "rrd   graph   def" )  )   {  throw new  rrd exception ( "xml definition must start with  < rrd   graph   def > " )  ;   }  validate tags only once ( root new  string[] { "filename" "span" "options" "datasources" "graph" }  )  ;  rrd graph def = new  rrd graph def (  )  ;   node[] child nodes = get child nodes ( root )  ;  for  (   node child node : child nodes )   {   string node name = child node . get node name (  )  ;  if  ( node name . equals ( "filename" )  )   {  resolve filename ( child node )  ;   }  else if  ( node name . equals ( "span" )  )   {  resolve span ( child node )  ;   }  else if  ( node name . equals ( "options" )  )   {  resolve options ( child node )  ;   }  else if  ( node name . equals ( "datasources" )  )   {  resolve datasources ( child node )  ;   }  else if  ( node name . equals ( "graph" )  )   {  resolve graph elements ( child node )  ;   }   }  return rrd graph def ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout ( null )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  final  deferred scalar subscription <  integer >  ds = new  defe
public int   (  )  {  return  ( int )  math . ceil (  ( double ) get workgroup manager (  )  . get workgroup count (  )   /   ( double ) range )  ;   }  
public long   (  )  {  return connection pool . get time between eviction runs millis (  )  ;   }  
public  string   (  )  {  return " publish lease set failed" ;   }  
private void   ( final  metrics file <  collect variant calling metrics .  variant calling detail metrics  comparable <  ?  >  >  detail final  metrics file <  collect variant calling metrics .  variant calling summary metrics  comparable <  ?  >  >  summary )  {  int parsed detail = 0 ;  for  (  final  collect variant calling metrics .  variant calling detail metrics metrics : detail . get metrics (  )  )   {  if  ( metrics . sample   alias . equals ( "foo1" )  )   {   assert . assert equals ( metrics . het   homvar   ratio 2 . 0 )  ;   assert . assert equals ( metrics . total   het   depth 30 )  ;   assert . assert equals ( metrics . total   snps 15 )  ;   assert . assert equals ( metrics . num   in   db   snp 10 )  ;   assert . assert equals ( metrics . novel   snps 5 )  ;   assert . assert equals ( metrics . filtered   snps 7 )  ;   assert . assert equals ( metrics . pct   dbsnp 0 . 666667 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   titv 2 . 333333 0 . 01 )  ;   assert . assert equals ( metrics . novel   titv 1 . 5 0 . 01 )  ;   assert . assert equals ( metrics . total   indels 9 )  ;   assert . assert equals ( metrics . novel   indels 3 )  ;   assert . assert equals ( metrics . filtered   indels 12 )  ;   assert . assert equals ( metrics . num   in   db   snp   indels 6 )  ;   assert . assert equals ( metrics . pct   dbsnp   indels 0 . 666667 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   ins   del   ratio 1 . 0 0 . 01 )  ;   assert . assert equals ( metrics . novel   ins   del   ratio 0 . 0 0 . 01 )  ;   assert . assert equals ( metrics . snp   reference   bias 0 . 466667 0 . 01 )  ;   assert . assert equals ( metrics . num   singletons 10 )  ;   }  else if  ( metrics . sample   alias . equals ( "foo2" )  )   {   assert . assert equals ( metrics . het   homvar   ratio 1 . 571429 )  ;   assert . assert equals ( metrics . total   het   depth 33 )  ;   assert . assert equals ( metrics . total   snps 18 )  ;   assert . assert equals ( metrics . num   in   db   snp 13 )  ;   assert . assert equals ( metrics . novel   snps 5 )  ;   assert . assert equals ( metrics . filtered   snps 5 )  ;   assert . assert equals ( metrics . pct   dbsnp 0 . 722222 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   titv 2 . 25 0 . 01 )  ;   assert . assert equals ( metrics . novel   titv 0 . 666667 0 . 01 )  ;   assert . assert equals ( metrics . total   indels 6 )  ;   assert . assert equals ( metrics . novel   indels 3 )  ;   assert . assert equals ( metrics . filtered   indels 6 )  ;   assert . assert equals ( metrics . num   in   db   snp   indels 3 )  ;   assert . assert equals ( metrics . pct   dbsnp   indels 0 . 5 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   ins   del   ratio 0 . 5 0 . 01 )  ;   assert . assert equals ( metrics . novel   ins   del   ratio 0 . 5 0 . 01 )  ;   assert . assert equals ( metrics . snp   reference   bias 0 . 696969 0 . 01 )  ;   assert . assert equals ( metrics . num   singletons 9 )  ;   }  else  {   assert . assert true ( false " unexpected sample name in detailed metrics: "  +  metrics . sample   alias )  ;   }  parsed detail +  +  ;   }   assert . assert equals ( parsed detail 2 " did not parse enough detail metrics . " )  ;  boolean parsed summary = false ;  for  (  final  collect variant calling metrics .  variant calling summary metrics metrics : summary . get metrics (  )  )   {   assert . assert equals ( metrics . total   snps 33 )  ;   assert . assert equals ( metrics . novel   snps 10 )  ;   assert . assert equals ( metrics . num   in   db   snp 23 )  ;   assert . assert equals ( metrics . filtered   snps 12 )  ;   assert . assert equals ( metrics . pct   dbsnp 0 . 696969 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   titv 2 . 285714 0 . 01 )  ;   assert . assert equals ( metrics . novel   titv 1 . 0 0 . 01 )  ;   assert . assert equals ( metrics . total   indels 15 )  ;   assert . assert equals ( metrics . novel   indels 6 )  ;   assert . assert equals ( metrics . num   in   db   snp   indels 9 )  ;   assert . assert equals ( metrics . filtered   indels 18 )  ;   assert . assert equals ( metrics . pct   dbsnp   indels 0 . 6 0 . 01 )  ;   assert . assert equals ( metrics . dbsnp   ins   del   ratio 0 . 8 0 . 01 )  ;   assert . assert equals ( metrics . novel   ins   del   ratio 0 . 2 0 . 01 )  ;   assert . assert equals ( metrics . snp   reference   bias 0 . 587302 0 . 01 )  ;   assert . assert equals ( metrics . num   singletons 19 )  ;  parsed summary = true ;   }   assert . assert true ( parsed summary " did not parse summary metrics . " )  ;   }  
private final  string builder   (  string builder sb )  {  sb . append ( '[' )  ;  for  ( int i = 0 ;  i  <  m list . size (  )  ;  i +  +  )   {  if  ( i  >  0 )   {  sb . append ( ' ' )  ;   }  final  imap element e = get element or none ( i )  ;  if  ( e . is list (  )  )   {  get list or empty ( i )  . flatten ( sb )  ;   }  else if  ( e . is string (  )  )   {  sb . append ( get string or empty ( i )  . get string (  )  )  ;   }   }  sb . append ( ']' )  ;  return sb ;   }  
public static boolean   ( jid jid boolean group must exist )  throws  group not found exception  {  boolean is group = false ;   string group name = null  node = jid . get node (  )  ;  if  ( node  !  =  null )   {  is group =  ( jid instanceof  groupjid )   ?  true : jid . get resource (  )   !  =  null &&  string utils . is base32 ( node )  &&  string utils . hash ( group name = decode node ( node )  )  . equals ( jid . get resource (  )  )  ;  if  ( is group && group must exist )   {   log . debug ( " validating group: "  +  jid )  ;  if  ( xmpp server . get instance (  )  . is local ( jid )  )   {   group manager . get instance (  )  . get group ( group name )  ;   }  else  {  is group = false ;   }   }   }  return is group ;   }  
public  relay intro reader   (  )  {  return    relay intro reader ;   }  
private static  row mapper <  ?  >    (  type key type  config registry config )  {   string column = config . get (  map entry mappers . class )  . get key column (  )  ;  if  ( column  =  =  null )   {  return config . get (  row mappers . class )  . find for ( key type )  . or else throw (  (  )   -  >  new  no such mapper exception ( " no row mapper registered for map key "  +  key type )  )  ;   }  else  {  return config . get (  column mappers . class )  . find for ( key type )  . map ( mapper  -  >  new  single column mapper <  >  ( mapper column )  )  . or else throw (  (  )   -  >  new  no such mapper exception ( " no column mapper registered for map key "  +  key type  +  " in column " +  column )  )  ;   }   }  
public boolean   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  return tun  !  =  null  ?  tun . get start on load (  )  : false ;   }  
@ test public void   (  )  {   observable <  string >  src =  observable . empty (  )  ;  src . first ( "default" )  . to observable (  )  . subscribe ( w )  ;  verify ( w times ( 1 )  )  . on next ( any string (  )  )  ;  verify ( w times ( 1 )  )  . on 
@ override public void   (  disposable s )  {  wlf . set other ( s )  ;   }  
private  mailbox   (  string server id  string name )  {   mailbox test mailbox = new  mailbox (  )  ;  test mailbox . m server id = server id ;  test mailbox . m display name =  ( name  =  =  null )   ?  test   display   name : name ;  test mailbox . m parent server id = test   parent   server   id ;  test mailbox . m sync key = test   sync   key ;  test mailbox . m sync status = test   sync   status ;  test mailbox . m account key = 1l ;  test mailbox . m delimiter = ' / ' ;  test mailbox . m flags = 2 ;  test mailbox . m flag visible = true ;  test mailbox . m parent key = 3l ;  test mailbox . m sync interval = 4 ;  test mailbox . m sync lookback = 5 ;  test mailbox . m sync time = 6l ;  test mailbox . m type = 7 ;  test mailbox . m last touched time = 10l ;  return test mailbox ;   }  
public   ( int id  string name )  {  this . id = id ;  this . name = name ;   }  
private void   (  boolean start speaking  string call id  string conference id jid from )  {   log . info ( " rayo component broadcast speaking "  +  start speaking  +  " " +  call id +  " " +  conference id +  " " +  from )  ;  try  {   conference manager conference manager =  conference manager . find conference manager ( conference id )  ;   array list member list = conference manager . get member list (  )  ;  synchronized  ( member list )   {  for  ( int i = 0 ;  i  <  member list . size (  )  ;  i +  +  )   {   conference member member =  (  conference member ) member list . get ( i )  ;   call handler call handler = member . get call handler (  )  ;  if  ( call handler  !  =  null )   {   call participant cp = call handler . get call participant (  )  ;   string target = cp . get call owner (  )  ;   log . info ( " rayo component broadcast speaking checking "  +  target )  ;  if  ( target  !  =  null && target . equals ( from . to string (  )  )   =  =  false )   {   presence presence = new  presence (  )  ;  presence . set from ( conference id  +  "@"  +  get domain (  )  )  ;  presence . set to ( target )  ;  if  ( start speaking )   {   started speaking event speaker = new  started speaking event (  )  ;  speaker . set speaker id ( jid . escape node ( from . to string (  )  )  )  ;  presence . get element (  )  . add ( rayo provider . toxml ( speaker )  )  ;   }  else  {   stopped speaking event speaker = new  stopped speaking event (  )  ;  speaker . set speaker id ( jid . escape node ( from . to string (  )  )  )  ;  presence . get element (  )  . add ( rayo provider . toxml ( speaker )  )  ;   }  send packet ( presence )  ;   }   }   }   }   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  
public void   (  peer peer boolean choke )  {  if  (    log . should log (  log . info )  )     log . info ( " got choke ( "  +  choke  +  " ) : " +  peer )  ;   }  
boolean   (  )  {  return  text utils . is empty ( m path separator )  &&  !  text utils . is empty ( m path prefix )  ;   }  
public  string   (  )  {  return    reason ;   }  
public int   (  )  {  sample threads (  )  ;  return states . get (  thread .  state . blocked )  ;   }  
public void   (  string moo )  {     start at beginning =  boolean . parse boolean ( moo )  ;   }  
public   (  router context ctx  hash key  database entry data  set <  hash >  to skip )  {     context = ctx ;     key = key ;     data = data ;     pending peers = new  hash set <  hash >  ( 4 )  ;     pending peer times = new  hash map <  hash  long >  ( 4 )  ;     pending messages = new  concurrent hash map <  hash  wrapped message >  ( 4 )  ;     attempted peers = new  hash set <  hash >  ( 8 )  ;  if  ( to skip  !  =  null )   {     attempted peers . add all ( to skip )  ;     complete count = to skip . size (  )  ;   }     failed peers = new  hash set <  hash >  ( 8 )  ;     successful peers = new  hash set <  hash >  ( 4 )  ;     completed =  - 1 ;     started =    context . clock (  )  . now (  )  ;   }  
boolean   ( char ch )  {  return directly encoded . index of ( ch )   >  =  0 ;   }  
@ override public void   ( boolean value )  {  this . rewrite host header = value ;   }  
  (  string name )  {  this . name = name ;   }  
public final  string   (  )  {  return m server id ;   }  
public synchronized void   (  object key )  throws  interrupted exception  {  final  lock request qlr = new  lock request (  thread . current thread (  )  key )  ;  if  ( wait depth  >  0 ||  ( locked &&  ! current key . equals ( key )  )  )   {  do  {  wait depth +  +  ;  wait (  )  ;  wait depth -  -  ;   }  while  ( locked && current key  !  =  qlr . get lock key (  )  )  ;   }  register thread ( qlr )  ;   }  
public boolean   (  node other node )  {  if  ( other node  =  =  null )  return false ;  set name ( other node . get name (  )  )  ;  set value ( other node . get value (  )  )  ;  remove all attributes (  )  ;  int n other attributes = other node . getn attributes (  )  ;  for  ( int n = 0 ;  n  <  n other attributes ;  n +  +  )   {   attribute other attr = other node . get attribute ( n )  ;   attribute this attr = new  attribute ( other attr )  ;  add attribute ( this attr )  ;   }  remove all nodes (  )  ;  int n other child nodes = other node . getn nodes (  )  ;  for  ( int n = 0 ;  n  <  n other child nodes ;  n +  +  )   {   node other child node = other node . get node ( n )  ;   node this child node = new  node (  )  ;  this child node . set ( other child node )  ;  add node ( this child node )  ;   }  return true ;   }  
public  optional <  row mapper <  ?  >  >    (  type type )  {  return find first present (  (  )   -  >  row mappers . find for ( type )   (  )   -  >  column mappers . find for ( type )  . map (  single column mapper::new )  )  ;   }  
@ override public  join row   (  result set r  statement context ctx )  throws sql exception  {  return specialize ( r ctx )  . map ( r ctx )  ;   }  
protected  string   (  )  {  return cache object key ;   }  
public void   (  )  {  final  attachment service .  download queue dq = new  attachment service .  download queue (  )  ;  final  attachment service .  download request dr = new  attachment service .  download request (  attachment service . priority   foreground 1 )  ;  final boolean result = dq . add request ( dr )  ;  assert true ( result )  ;  final  attachment service .  download request dr result = dq . find request by id ( 1 )  ;  assert not null ( dr result )  ;  assert equals ( dr dr result )  ;   }  
@ override public  config registry   (  )  {  return config . get (  )  ;   }  
  (  subscriber <  ?  super t >  actual  boolean supplier until  subscription arbiter sa  publisher <  ?  extends t >  source )  {  this . actual = actual ;  this . sa = sa ;  this . source = source ;  this . stop = until ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . last ( null )  ;   }  
public void   (  ad hoc command command )  {  manager . add command ( command )  ;  start command ( command )  ;   }  
public  header[]   (  )  {  return headers ;   }  
@ override public byte[]   (  )  throws  unknown host exception  {  return address . get address (  )  ;   }  
@ override public boolean   (  collection <  ?  >  c )  {   iterator it = c . iterator (  )  ;  while  ( it . has next (  )  )   {  if  (  ! contains ( it . next (  )  )  )   {  return false ;   }   }  return true ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  maybe subject <  integer >  cs =  maybe subject . create (  )  ;   test observer <  integer
private void   ( final  collection <  gc bias detail metrics >  details final  gc bias summary metrics summary )  {  double total reads = 0 ;  double total windows = 0 ;  for  (  final  gc bias detail metrics detail : details )   {  total reads +  = detail . read   starts ;  total windows +  = detail . windows ;   }  double at dropout = 0 ;  double gc dropout = 0 ;  for  (  final  gc bias detail metrics detail : details )   {  final double relative reads = detail . read   starts  /  total reads ;  final double relative windows = detail . windows  /  total windows ;  final double dropout =  ( relative windows  -  relative reads )  * 100 ;  if  ( dropout  >  0 )   {  if  ( detail . gc  <  =  50 )  at dropout +  = dropout ;  else  {  gc dropout +  = dropout ;   }   }   }  summary . at   dropout = at dropout ;  summary . gc   dropout = gc dropout ;   }  
public long   (  )  {  return    last send fully time ;   }  
void   (  subscriber <  ?  > [] subscribers  throwable ex )  {  for  (   subscriber <  ?  >  s : subscribers )   {   empty subscription . error ( ex s )  ;   }   }  
private boolean   (  )  {  return    inbound fragments . is alive (  )  ;   }  
protected void   (  async context context  string content )  throws io exception  {  final  string remote address = get remote address ( context )  ;   document document ;  try  {  document = get packet reader (  )  . read ( new  string reader ( content )  "utf - 8" )  ;   }  catch  (   exception ex )   {   log . warn ( " error parsing request data from ["  +  remote address  +  "]" ex )  ;  send legacy error ( context  bosh binding error . bad request )  ;  return ;   }  if  ( document  =  =  null )   {   log . info ( " the result of parsing request data from ["  +  remote address  +  "] was a null - object . " )  ;  send legacy error ( context  bosh binding error . bad request )  ;  return ;   }  final  element node = document . get root element (  )  ;  if  ( node  =  =  null ||  ! "body" . equals ( node . get name (  )  )  )   {   log . info ( " root element 'body' is missing from parsed request data from ["  +  remote address  +  "]" )  ;  send legacy error ( context  bosh binding error . bad request )  ;  return ;   }  final long rid = get long attribute ( node . attribute value ( "rid" )   - 1 )  ;  if  ( rid  <  =  0 )   {   log . info ( " root element 'body' does not contain a valid rid attribute value in parsed request data from ["  +  remote address  +  "]" )  ;  send legacy error ( context  bosh binding error . bad request " body - element is missing a rid  (  request id )  value  or the provided value is a non - positive integer . " )  ;  return ;   }  final  string sid = node . attribute value ( "sid" )  ;  if  ( sid  =  =  null )   {  if  ( node . elements (  )  . size (  )   >  0 )   {   log . info ( " root element 'body' does not contain a sid attribute value in parsed request data from ["  +  remote address  +  "]" )  ;  send legacy error ( context  bosh binding error . bad request )  ;  return ;   }  create new session ( context node )  ;   }  else  {  handle session request ( sid context node )  ;   }   }  
static void   (  connection type type  string key store type )  {   jive globals . set property ( type . get prefix (  )   +  "store type" key store type )  ;  final  string old key store type = get key store type ( type )  ;  if  ( old key store type . equals ( key store type )  )   {   log . debug ( " ignoring  key store type change request  ( to ' {  } ' ) : listener already in this state . " key store type )  ;  return ;   }   log . debug ( " changing  key store type from ' {  } ' to ' {  } ' . " old key store type key store type )  ;   }  
public boolean   ( long entry )  {  if  ( always   miss )  return false ;  if  (    entry bytes  <  =  7 )  entry =  (  ( entry ^    long to entry mask )  &  (  ( 1  <  <  31 )   -  1 )  )  |  ( entry ^    long to entry mask )  ;  if  ( entry  <  0 )   {   data helper . to long (    long to entry 0    entry bytes 0  -  entry )  ;     long to entry[0]| =  ( 1  <  <  7 )  ;   }  else  {   data helper . to long (    long to entry 0    entry bytes entry )  ;   }  get read lock (  )  ;  try  {  return locked   add (    long to entry 0    long to entry . length false )  ;   }  finally  {  release read lock (  )  ;   }   }  
public  node .  item reply policy   (  )  {  return reply policy ;   }  
@ test public void   (  )  {   observable . sequence equal (  observable . just ( 1 )   observable . just ( 2 )  )  . test (  )  . assert result ( false )  ;   }  
@ xml element ( name = "roster item" )  public  list <  roster item entity >    (  )  {  return roster ;   }  
@ override public void   ( t t )  {  produced +  +  ;  actual . on next ( t )  ;   }  
void   (  fetch data fetch data )  {  this . fetch data = fetch data ;   }  
public  string   (  )  {  return    context . router (  )  . get config filename (  )  ;   }  
@ test public void   (  )  {  assert that (  iterable like . is empty ( new int[] { 1 2 3 }  )  )  . is false (  )  ;   }  
@ override public void   (  maybe observer <  ?  super  integer >  s )  {   disposable d1 =  disposables . empty (  )  ;  s . on subscribe ( d1 )  ;   disposable d2 =  disposables . empty (  )  ;  s . on subscribe ( d2 )  ;  assert false ( d1 . is dispose
@ override public int   (  session data data )  {  return 1 ;   }  
private static  string   (  string plugin name )  {  return plugin name . replace ( ' . ' '   ' )   +  "   i18n" ;   }  
@ override public  enumeration <  string >    (  )  {  return proxy . get attribute names (  )  ;   }  
@ override public void   ( t value )  {  if  ( done )   {  return ;   }  if  ( source mode  =  =  none )   {  k key ;  boolean b ;  try  {  key =  object helper . require non null ( key selector . apply ( value )  " the key selector returned a null key" )
boolean   (  )  {  return    dead ;   }  
@ override public  single source <  integer >    (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
public  agent chat session   (  )  {  long start time =  - 1 ;   agent chat session return session = null ;   iterator <  agent chat session >  iter = get agents (  )  ;  while  ( iter . has next (  )  )   {   agent chat session agent = iter . next (  )  ;  if  ( agent . get start time (  )   <  =  start time || start time  =  =   - 1 )   {  start time = agent . get start time (  )  ;  return session = agent ;   }   }  return return session ;   }  
@ override  optional <  typed value >    (  string name  statement context ctx )  {   property descriptor descriptor = property descriptors . get ( name )  ;  if  ( descriptor  =  =  null )   {  return  optional . empty (  )  ;   }   method getter = get g
static void   (  router context ctx  string prop  collection <  app >  apps boolean full )  {   string builder buf = new  string builder ( 1024 )  ;  for  (   app app : apps )   {  buf . append ( app . name )  . append ( s )  ;  if  ( full )  buf . append ( app . desc )  . append ( s )  ;  buf . append ( app . url )  . append ( s )  ;  if  ( full )  buf . append ( app . icon )  . append ( s )  ;   }  ctx . router (  )  . save config ( prop buf . to string (  )  )  ;   }  
  ( final boolean reset mapping information final boolean populatepa tag )  {  this . reset mapping information = reset mapping information ;  this . populatepa tag = populatepa tag ;   }  
public   (  rrd graph def gdef )  throws io exception   rrd exception  {  this . gdef = gdef ;  signature = gdef . get signature (  )  ;  worker = new  image worker ( 100 100 )  ;  try  {  create graph (  )  ;   }  finally  {  worker . dispose (  )  ;  worker = null ;  dproc = null ;   }   }  
@ override public boolean   (  )  {  return  ! db storage enabled ;   }  
  (  maybe observer <  ?  super t >  actual )  {  this . actual = actual ;   }  
@ override public int   (  )  {  int hash = hash   base ;  hash = hash   prime * hash  +   ( this . parameters  !  =  null  ?  this . parameters . hash code (  )  : 0 )  ;  hash = hash   prime * hash  +   ( this . value  !  =  null  ?  this . value . hash
public   (  )  {  new  drop target ( this this )  ;  drag source . create default drag gesture recognizer ( this  dnd constants . action   copy   or   move this )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
@ override public void   (  integer e )  throws  exception  {  throw new  test exception (  )  ;   }  
public   ( int hour int minute boolean on )  {  set hour ( hour )  ;  set minute ( minute )  ;  set on ( on )  ;   }  
@ override public  integer   (  )  {  return generated . get and increment (  )  ;   }  
public void   ( boolean val )  {  if  ( val )     boolean options . add ( i2p tunnelhttp server . opt   reject   inproxy )  ;  else    boolean options . remove ( i2p tunnelhttp server . opt   reject   inproxy )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 100 )  . scan ( 0 new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer t1  
@ override public int   ( final long account id final  bundle sync extras )  {  return  email service status . success ;   }  
private  string   (  )  {     executor . purge (  )  ;  return "  pool: "  +     name  +  "  active: " +     executor . get active count (  )  +  ' / ' +     executor . get pool size (  )  +  "  completed: " +     executor . get completed task count (  )  +  "  queued: " +     executor . get queue (  )  . size (  )  ;   }  
public void   (  snark snark )  {  process complete ( snark )  ;     smgr . torrent complete ( snark )  ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
@ test public void   (  )  throws io exception  {  processor . process (  )  ;  verify ( servlet response )  . set status ( eq ( 200 )  )  ;   }  
public   (  byte buffer shared buffer )  {  this . shared buffer = shared buffer ;   }  
public  presence manager   (  )  {  return getxmpp server (  )  . get presence manager (  )  ;   }  
public void   (  string email field )  {  this . email field = email field ;  if  ( email field  =  =  null )   {  properties . remove ( "ldap . email field" )  ;   }  else  {  properties . put ( "ldap . email field" email field )  ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . sync )  ;   observable . range ( 1 5 )  . do finally ( this )  . filter (  functions . always true (  )  )  . subscribe ( to )  ;   observer fu
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . from completable ( null )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   observable . just ( 1 )  . for each while ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exc
boolean   (  string feature )  {  return features . add ( feature )  ;   }  
public void   (  string proxy )  {  this . proxy = proxy ;   }  
private boolean   ( int capability )  {  return  ( m capabilities & capability )   !  =  0 ;   }  
public void   (  )  throws uri syntax exception  {   intent i = get test intent ( "imap: /  / user@server . com:999" )  ;  set activity intent ( i )  ;  get activity and fields (  )  ;  assert false ( is next button enabled (  )  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  i2p socket address . create unresolved ( stats   host 90000 )  ;   }  
public long   (  )  {  return file size ;   }  
@ override public void   (  )  {  if  ( yahoo session  !  =  null )   {  if  ( yahoo listener  !  =  null )   {  yahoo session . remove session listener ( yahoo listener )  ;  yahoo listener = null ;   }  try  {  yahoo session . logout (  )  ;   }  catch 
 timer   (  )  {  return m   timer ;   }  
@ test public void   (  )  {   behavior subject <  string >  subject =  behavior subject . create default ( "default" )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "o
@ override public int   (  )  {  return  - 1 ;   }  
public void   (  list <  string >  groups )  {  this . groups = groups ;   }  
void   (  )  {   task scheduler sched =    chooser . get scheduler ( this )  ;  long before =  system . current time millis (  )  ;  sched . event occurred ( this )  ;  long elapsed =  system . current time millis (  )   -  before ;  if  (  ( elapsed  >  250 )  &&  (    log . should log (  log . warn )  )  )     log . warn ( " took "  +  elapsed  +  "ms to pump through " +  sched +  " on " +  to string (  )  )  ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . observe on (  schedulers . trampoline (  )  )  . test (  )  . assert result ( 1 )  ;   }  
public void   ( long account id )  {  m shared preferences . edit (  )  . put long ( last   account   used account id )  . apply (  )  ;   }  
@ test ( data provider = "failing files forsam exception" expected exceptions = sam exception . class )  public void   ( final  string failing file )  {  final  filter file reader reader = new  filter file reader ( new  file ( test   data   dir failing fi
public void   (  )  throws  exception  {   byte array output stream out = new  byte array output stream (  )  ;   destination d = i2p client factory . create client (  )  . create destination ( out )  ;  i2p session session = new i2p session impl2 ( i2p app context . get global context (  )  new  byte array input stream ( out . to byte array (  )  )  null )  ;  session . connect (  )  ;  session . set session listener ( this )  ;     s = new  hash set <  string >  (  )  ;     s . add ( "a" )  ;     s . add ( "b" )  ;     s . add ( "c" )  ;     s . add ( "d" )  ;  session . send message ( d  data helper . getascii ( "a" )  )  ;  session . send message ( d  data helper . getascii ( "b" )  )  ;  session . send message ( d  data helper . getascii ( "c" )  )  ;  session . send message ( d  data helper . getascii ( "d" )  )  ;  for  ( int i = 0 ;   ( i  <  20 )  &&  (  !    s . is empty (  )  )  ;  i +  +  )   {   thread . sleep ( 1000 )  ;   }  assert true (    s . is empty (  )  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  boundary =  publish processor . create (  )  ;  final  subscriber <  object >  o =  test helper . mock subscriber
public  list < uri >    (  update type type  string id  update method method )  {   version available va =    available . get ( new  update item ( type id )  )  ;  if  ( va  !  =  null )   {   list < uri >  rv = va . source map . get ( method )  ;  if  ( rv  !  =  null )  return rv ;   }  switch  ( type )   {  case news: case news   su3: break ;  case router   signed:  {   string ur ls =    context . get property (  config update handler . prop   update   url  config update handler . default   update   url )  ;   string tokenizer tok = new  string tokenizer ( ur ls "  \r\n" )  ;   list < uri >  rv = new  array list < uri >  (  )  ;  while  ( tok . has more tokens (  )  )   {  try  {  rv . add ( new uri ( tok . next token (  )  . trim (  )  )  )  ;   }  catch  (  uri syntax exception use )   {   }   }   collections . shuffle ( rv    context . random (  )  )  ;  return rv ;   }  case router   signed   su3:  {   string ur ls =  config update handler . su3   update   urls ;   string tokenizer tok = new  string tokenizer ( ur ls "  \r\n" )  ;   list < uri >  rv = new  array list < uri >  (  )  ;  while  ( tok . has more tokens (  )  )   {  try  {  rv . add ( new uri ( tok . next token (  )  . trim (  )  )  )  ;   }  catch  (  uri syntax exception use )   {   }   }   collections . shuffle ( rv    context . random (  )  )  ;  return rv ;   }  case router   unsigned:  string url =    context . get property (  config update handler . prop   zip   url )  ;  if  ( url  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( url )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  case router   dev   su3:  string url3 =    context . get property (  config update handler . prop   dev   su3   url )  ;  if  ( url3  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( url3 )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  case plugin:  properties props =  plugin starter . plugin properties (    context id )  ;   string xpi2purl = props . get property ( "updateurl" )  ;  if  ( xpi2purl  !  =  null )   {  try  {  return  collections . singleton list ( new uri ( xpi2purl )  )  ;   }  catch  ( uri syntax exception use )   {   }   }  break ;  default : break ;   }  return  collections . empty list (  )  ;   }  
public  field element   (  )  {  return this . z ;   }  
@ test public void   (  )  {  s1 . on next ( "a" )  ;  s1 . on next ( "b" )  ;  s1 . on complete (  )  ;  s2 . on next ( "1" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s2 . on next ( "2" )  ;  in order . verify ( observer
public  string   (  )  {  return failure   reason ;   }  
@ override public boolean   (  object o )  {  if  (  !  ( o instanceof  query parameter )  )   {  return false ;   }  return compare to (  (  query parameter ) o )   =  =  0 ;   }  
@ override public void   (  string source byte[] data int offset int len )  {  try  {  synchronized  (    fortuna )   {     fortuna . add random bytes ( data offset len )  ;   }   }  catch  (   runtime exception e )   {   log log =    context . log manage
@ test public void   (  )  {  for  (   map .  entry <  integer  string >  entry : status map . entry set (  )  )   {  int status = entry . get key (  )  ;   string msg = entry . get value (  )  ;  i2p socket exception e = new i2p socket exception ( status
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  sampler =  publish processor . create (  )  ;   flowable <  integer >  m = source . sample ( sampler )  ;  m . su
public static  bundle   ( final long account id )  {  final  bundle b = new  bundle ( 1 )  ;  b . put long ( arg   account   id account id )  ;  return b ;   }  
public   ( final  haplotype block haplotype block )  {  super ( haplotype block )  ;   }  
private void   (  object output stream out )  throws io exception  {  byte[] seed = new byte[seed   file   size] ;  generator . next bytes ( seed )  ;  out . write ( seed )  ;   }  
@ override public  integer   (  integer a  integer b )  throws  exception  {  return a  +  b ;   }  
public synchronized void   (  )  throws io exception  {  long remaining = length ;  final int zeroblocksize =  ( int )  math . min ( remaining 32 * 1024 )  ;  byte[] zeros = new byte[zeroblocksize] ;  raf . seek ( 0 )  ;  if  ( remaining  >  20 * 1024 * 1024 )     allocate count . increment and get (  )  ;  try  {  while  ( remaining  >  0 )   {  int size =  ( int )  math . min ( remaining zeroblocksize )  ;  raf . write ( zeros 0 size )  ;  remaining -  = size ;   }   }  finally  {  remaining = length ;  if  ( remaining  >  20 * 1024 * 1024 )     allocate count . decrement and get (  )  ;   }  is sparse = false ;   }  
@ override public  datastore   (  )  {  return datastore ;   }  
public void   (  )  {  try  {  remove from db (  )  ;   }  catch  (  sql exception e )   {   log . error ( "sql error while removing pseudo roster item "  +  this . get registrationid (  )  )  ;   }   }  
@ suppress warnings ( "unused" )  public  big decimal   (  )  {  return null ;   }  
public void   (  )  throws json exception  {  final json object json = new json object (  )  ;  json . put (  email content .  account columns . display   name " david  hasselhoff" )  ;  json . put (  email content .  account columns . email   address "dhoff@example . com" )  ;  json . put (  email content .  account columns . sync   lookback 42 )  ;  json . put (  email content .  account columns . sync   interval 99 )  ;  json . put (  account . json   tag   host   auth   recv get host authjson ( "receiver" "recpass" )  . to json (  )  )  ;  json . put (  account . json   tag   host   auth   send get host authjson ( "send" "sendpass" )  . to json (  )  )  ;  json . put (  email content .  account columns . flags 22 )  ;  json . put (  email content .  account columns . sender   name " friend of  kitt" )  ;  json . put (  email content .  account columns . protocol   version "protocol version 3 . 14" )  ;  json . put (  email content .  account columns . signature " david with a heart over the i" )  ;  json . put (  email content .  account columns . ping   duration 77 )  ;  final  account a =  account . from json ( json )  ;  assert equals ( " david  hasselhoff" a . get display name (  )  )  ;  assert equals ( "dhoff@example . com" a . get email address (  )  )  ;  assert equals ( 42 a . get sync lookback (  )  )  ;  assert equals ( 99 a . get sync interval (  )  )  ;  assert equals ( "receiver" a . m host auth recv . m login )  ;  assert equals ( "recpass" a . m host auth recv . m password )  ;  assert equals ( "send" a . m host auth send . m login )  ;  assert equals ( "sendpass" a . m host auth send . m password )  ;  assert equals ( 22 a . get flags (  )  )  ;  assert equals ( " friend of  kitt" a . get sender name (  )  )  ;  assert equals ( "protocol version 3 . 14" a . m protocol version )  ;  assert equals ( " david with a heart over the i" a . get signature (  )  )  ;  assert equals ( 77 a . m ping duration )  ;   }  
public  control point   (  )  {  return ctrl point ;   }  
@ test public void   (  )  {   flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  integer >  ts = s . test (  )  ;   flowable . range ( 1 10 )  . subscribe ( s )  ;  ts . asser
@ test public void   (  )  {   single . from observable (  observable . error ( new  runtime exception ( "some error" )  )  )  . test (  )  . assert failure (  runtime exception . class )  . assert error message ( "some error" )  ;   }  
@ test public void   (  )  {   publish processor <  string >  r1 =  publish processor . create (  )  ;   subscriber <  string >  o =  test helper . mock subscriber (  )  ;   in order io = in order ( o )  ;   iterable <  string >  r2 =  arrays . as list ( 
public   ( final  plugin manager plugin manager )  {  this . plugin manager = plugin manager ;   }  
@ override public  collection <  domain pair >    (  )  {  return servers cache . key set (  )  ;   }  
public  basic flap connection   ( int family code )  {   list <  basic flap connection >  handlers = conns . get ( family code )  ;  if  ( handlers  =  =  null || handlers . size (  )   =  =  0 )   {  return null ;   }  return handlers . get ( 0 )  ;   }  
public void   (  macro macro )  {  macros . add ( macro )  ;   }  
public int   (  )  {  return data codewords ;   }  
private void   (  )  {  int arg count =    args . size (  )  ;  if  ( arg count  <  =  0 || arg count  >  max   args )   {  flushit (  )  ;  return ;   }     state = s . start ;     in buf . set length ( 0 )  ;  if  (    hook  !  =  null )   {     hook . tag (    args )  ;  return ;   }   string tx = null ;  if  ( arg count  =  =  1 )  tx =  translate . get string (    args . get ( 0 )     ctx    bundle )  ;  else tx =  translate . get string (    args . get ( 0 )     ctx    bundle    args . sub list ( 1    args . size (  )  )  . to array (  )  )  ;     out buf . append ( tx )  ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . empty (  )  ;   flowable <  integer >  dematerialize = observable . dematerialize (  )  ;   subscriber <  integer >  observer =  test helper . mock subscriber (  )  ;   test su
@ test ( data provider = "override test data" expected exceptions =  {  picard exception . class }  )  public void   ( final  string sample final  string library )  throws  exception  {  final  file output =  file . create temp file ( "bad" " . sam" )  ; 
public   (  workgroup workgroup  date from  date upto jid agentjid  string query string )  {  this . after date = from ;  this . before date = upto ;  this . workgroup = workgroup ;  this . agentjid = agentjid ;  this . query string = wildcard ignored  ?  strip wildcards ( query string )  : query string ;  if  (  ! wildcard ignored && contains wildcards ( query string )  )   {  this . query string = lower case query string ( this . query string )  ;   }   }  
@ override public synchronized  output stream   (  )  throws io exception  {  if  (    offset  >  0 )  throw new  illegal state exception (  )  ;  if  (    cos  !  =  null )  throw new  illegal state exception (  )  ;     cos = new  counting output stream
 database entry   (  hash key )  {  if  (  !    initialized )  return null ;  return    ds . get ( key )  ;   }  
@ override public void   ( t v )  {  target . on next ( v )  ;   }  
@ override public void   ( long n )  {  requested . set ( n )  ;   }  
public int   (  )  {  return port ;   }  
void   ( final sam record record )  {  if  (  ! record . get read paired flag (  )  )  throw new  picard exception ( " record "  +  record . get read name (  )   +  " is not paired" )  ;  if  ( record . get first of pair flag (  )  )   {  if  ( mate1  !  =  null )  throw new  picard exception ( " mate 1 already set for record: "  +  record . get read name (  )  )  ;  mate1 = record ;   }  else if  ( record . get second of pair flag (  )  )   {  if  ( mate2  !  =  null )  throw new  picard exception ( " mate 2 already set for record: "  +  record . get read name (  )  )  ;  mate2 = record ;   }  else throw new  picard exception ( " neither  first of pair flag or  second of pair flag is set for a paired record" )  ;   }  
@ test public void   (  )  {   test multi threaded observable on subscribe = new  test multi threaded observable ( "one" "two" "three" null )  ;   observable <  string >  w =  observable . unsafe create ( on subscribe )  ;   busy observer busyobserver = n
public void   (  blackhole bh )  throws  exception  {   perf subscriber lo = new  perf subscriber ( bh )  ;  range async pipeline . subscribe ( lo )  ;  if  ( times  =  =  1 )   {  while  ( lo . latch . get count (  )   !  =  0 )   {   }   }  else  {  lo . latch . await (  )  ;   }   }  
protected   (  string module name  string element name  string namespace )  {  super ( module name )  ;  this . info = new iq handler info ( element name namespace )  ;   }  
private  class <  ?  extends  stats viewer >    (  )  {  if  (  jive globals . get boolean property ( "stats . mock . viewer" false )  )   {  return  mock stats viewer . class ;   }  else  {  return  default stats viewer . class ;   }   }  
public void   (  )  {  get context (  )  . client manager (  )  . startup (  )  ;   }  
public  element   (  string username  element data )  {  if  ( enabled )   {  final pep service manager service mgr = xmpp server . get instance (  )  . getiqpep handler (  )  . get service manager (  )  ;  final pep service pep service = service mgr . getpep service ( xmpp server . get instance (  )  . createjid ( username null )  )  ;  if  ( pep service  !  =  null )   {  final  node node = pep service . get node ( data . get namespaceuri (  )  )  ;  if  ( node  !  =  null )   {  final  published item item = node . get published item ( "current" )  ;  if  ( item  !  =  null )   {  data . clear content (  )  ;  data = item . get payload (  )  ;   }   }   }   }  return data ;   }  
@ override public  observable source <  object >    (  observable <  object >  f )  throws  exception  {  return f . take last ( 1 )  ;   }  
@ test public void   (  )  {  for  (   backpressure strategy m :  backpressure strategy . values (  )  )   {   flowable . create ( new  flowable on subscribe <  object >  (  )  {  @ override public void subscribe (   flowable emitter <  object >  e )  thr
@ test public void   (  )  throws  exception  {  run standard test ( 1 "cbcl convert . " "barcode   double . params" 2 "151t8b8b151t" test   data   dir   with   cbcls dual   cbcl   test   data   dir )  ;   }  
public udp packet   (  outbound establish state state )  {  int off = header   size ;  byte[] options ;  boolean ext = state . is extended options allowed (  )  ;  if  ( ext )   {  options = new byte[udp packet . sess   req   min   ext   options   length] ;  boolean intro = state . need introduction (  )  ;  if  ( intro )  options[1] =  ( byte ) udp packet . sess   req   ext   flag   request   relay   tag ;  if  (    log . should info (  )  )     log . info ( "send sess req .  w /  ext .  options  need intro ?  "  +  intro  +  ' ' +  state )  ;  off +  = udp packet . sess   req   min   ext   options   length  +  1 ;   }  else  {  options = null ;   }  udp packet packet = build packet header ( session   request   flag   byte options )  ;   datagram packet pkt = packet . get packet (  )  ;  byte data[] = pkt . get data (  )  ;  byte toip[] = state . get sentip (  )  ;  if  (  !    transport . is valid ( toip )  )   {  packet . release (  )  ;  return null ;   }   inet address to = null ;  try  {  to =  inet address . get by address ( toip )  ;   }  catch  (   unknown host exception uhe )   {  if  (    log . should log (  log . error )  )     log . error ( " how did we think this was a valid ip ?  "  +  state . get remote host id (  )  . to string (  )  )  ;  packet . release (  )  ;  return null ;   }  if  (    log . should log (  log . debug )  )     log . debug ( " sending request to "  +   addresses . to string ( toip )  )  ;  byte[] x = state . get sentx (  )  ;   system . arraycopy ( x 0 data off x . length )  ;  off +  = x . length ;   data helper . to long ( data off 1 toip . length )  ;  off +  = 1 ;   system . arraycopy ( toip 0 data off toip . length )  ;  off +  = toip . length ;  int port = state . get sent port (  )  ;   data helper . to long ( data off 2 port )  ;  off +  = 2 ;  off = pad1 ( data off )  ;  off = pad2 ( data off )  ;  pkt . set length ( off )  ;  authenticate ( packet state . get intro key (  )  state . get intro key (  )  )  ;  set to ( packet to port )  ;  packet . set message type ( type   sreq )  ;  return packet ;   }  
public  list <  fingerprint results >    ( final  list <  path >  sam files final  list <  path >  genotype files final  string specific sample final boolean ignore read groups )  {  final  list <  fingerprint >  expected fingerprints = new  linked list <  >  (  )  ;  for  (  final  path p : genotype files )   {  expected fingerprints . add all ( load fingerprints ( p specific sample )  . values (  )  )  ;   }  if  ( expected fingerprints . is empty (  )  )   {  throw new  illegal state exception ( " could not find any fingerprints in: "  +  genotype files )  ;   }  final  list <  fingerprint results >  results list = new  array list <  >  (  )  ;  final  interval list intervals = get loci to genotype ( expected fingerprints )  ;  for  (  final  path p : sam files )   {  final  map <  fingerprint id details  fingerprint >  fingerprints by read group = fingerprint sam file ( p intervals )  ;  if  ( ignore read groups )   {  final  fingerprint combined fp = new  fingerprint ( specific sample p null )  ;  fingerprints by read group . values (  )  . for each ( combined fp::merge )  ;  final  fingerprint results results = new  fingerprint results ( p null specific sample )  ;  for  (  final  fingerprint expected fp : expected fingerprints )   {  final  match results result = calculate match results ( combined fp expected fp 0 p lossof het )  ;  results . add results ( result )  ;   }  results list . add ( results )  ;   }  else  {  for  (  final  fingerprint id details rg : fingerprints by read group . key set (  )  )   {  final  fingerprint results results = new  fingerprint results ( p rg . platform unit rg . sample )  ;  for  (  final  fingerprint expected fp : expected fingerprints )   {  final  match results result = calculate match results ( fingerprints by read group . get ( rg )  expected fp 0 p lossof het )  ;  results . add results ( result )  ;   }  results list . add ( results )  ;   }   }   }  return results list ;   }  
public void   (  string sql )  {  this . sql = sql ;   }  
@ override public void   ( final int one based tile number )  {  for  (  final  illumina parser parser : parsers )   {  parser . seek to tile ( one based tile number )  ;   }   }  
@ override public void   ( boolean ok  string version )  {  synchronized  (    hello lock )   {  if  ( ok )     hello ok =  boolean . true ;  else    hello ok =  boolean . false ;     version = version ;     hello lock . notify all (  )  ;   }   }  
public void   ( final sam record rec final  reference sequence ref )  {  if  (  ! this . include secondary alignments && rec . get not primary alignment flag (  )  )  return ;  if  (  ! this . include supplemental alignments && rec . get supplementary alignment flag (  )  )  return ;  final int length = rec . get read length (  )  ;  metrics . total   reads +  +  ;  metrics . total   bases +  = length ;  final boolean is pf read =  ! rec . get read fails vendor quality check flag (  )  ;  if  ( is pf read )   {  metrics . pf   reads +  +  ;  metrics . pf   bases +  = length ;   }  final byte[] quals ;  if  ( this . use original qualities )   {  byte[] tmp = rec . get original base qualities (  )  ;  if  ( tmp  =  =  null )  tmp = rec . get base qualities (  )  ;  quals = tmp ;   }  else  {  quals = rec . get base qualities (  )  ;   }  for  (  final int qual : quals )   {  metrics . q20   equivalent   yield +  = qual ;  if  ( qual  >  =  30 )   {  metrics . q20   bases +  +  ;  metrics . q30   bases +  +  ;   }  else if  ( qual  >  =  20 )   {  metrics . q20   bases +  +  ;   }  if  ( is pf read )   {  metrics . pf   q20   equivalent   yield +  = qual ;  if  ( qual  >  =  30 )   {  metrics . pf   q20   bases +  +  ;  metrics . pf   q30   bases +  +  ;   }  else if  ( qual  >  =  20 )   {  metrics . pf   q20   bases +  +  ;   }   }   }   }  
public  object   (  string name )  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . replace ( this d )  ;   }  
public boolean   (  )  {  return return response ( http status . bad   request )  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  cancel (  )  ;  on complete (  )  ;   }   }  
  (  subscriber <  ?  super t >  actual int n int prefetch )  {  super ( actual n prefetch )  ;   }  
@ before public void   (  )  throws sql exception  {  when ( result set . get meta data (  )  )  . then return ( result set meta data )  ;   }  
public  inet address[]   (  )  {  return this . get device data (  )  . gethttp bind address (  )  ;   }  
public static  string   (  )  {  try  {  final  inet address addr =  inet address . get local host (  )  ;  return addr . get host name (  )  ;   }  catch  (   unknown host exception e )   {  throw new  net utilities exception ( " failed to get hostname .   something weird is going on . " e )  ;   }   }  
public void   (  string home city )  {  this . home city = home city ;   }  
@ test public void   (  )  {  final  disposable underlying = mock (  disposable . class )  ;  serial disposable . update ( underlying )  ;  assert same ( underlying serial disposable . get (  )  )  ;  final  disposable another = mock (  disposable . class
public static  < t > boolean   (  set < t >  one  set < t >  two )  {  return one  =  =  null  ?  two  =  =  null :  ( two  !  =  null && one . equals ( two )  )  ;   }  
@ override public void   (  integer v )  throws  exception  {  if  (  +  + c  =  =  5 )   {  flag . set ( true )  ;   }   }  
public static  < t > void   (  function <  maybe < t >   ?  extends  completable source >  transform )  {   list <  throwable >  errors = track plugin errors (  )  ;  try  {  final  boolean[] b =  { null null }  ;  final  count down latch cdl = new  count down latch ( 1 )  ;   maybe < t >  source = new  maybe < t >  (  )  {  @ override protected void subscribe actual (   maybe observer <  ?  super t >  observer )  {  try  {   disposable d1 =  disposables . empty (  )  ;  observer . on subscribe ( d1 )  ;   disposable d2 =  disposables . empty (  )  ;  observer . on subscribe ( d2 )  ;  b[0] = d1 . is disposed (  )  ;  b[1] = d2 . is disposed (  )  ;   }  finally  {  cdl . count down (  )  ;   }   }   }   ;   completable source out = transform . apply ( source )  ;  out . subscribe (  no op consumer . instance )  ;  try  {  assert true ( " timed out" cdl . await ( 5  time unit . seconds )  )  ;   }  catch  (   interrupted exception ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert equals ( " first disposed ? " false b[0] )  ;  assert equals ( " second not disposed ? " true b[1] )  ;  assert error ( errors 0  illegal state exception . class " disposable already set ! " )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  finally  {   rx java plugins . reset (  )  ;   }   }  
public  meta info   (  string announce )  throws  invalidb encoding exception  {   map <  string be value >  m = new  hash map <  string be value >  (  )  ;  if  ( announce  !  =  null )  m . put ( "announce" new be value (  data helper . getutf8 ( announce )  )  )  ;   map <  string be value >  info = create info map (  )  ;  m . put ( "info" new be value ( info )  )  ;  return new  meta info ( m )  ;   }  
  (  subscriber <  ?  super  flowable < t >  >  actual long size long skip int buffer size )  {  super ( 1 )  ;  this . actual = actual ;  this . size = size ;  this . skip = skip ;  this . queue = new  spsc linked array queue <  unicast processor < t >  >  ( buffer size )  ;  this . windows = new  array deque <  unicast processor < t >  >  (  )  ;  this . once = new  atomic boolean (  )  ;  this . first request = new  atomic boolean (  )  ;  this . requested = new  atomic long (  )  ;  this . wip = new  atomic integer (  )  ;  this . buffer size = buffer size ;   }  
@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   value type that =  (  value type ) o ;  return this . value . equals ( that . value )
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  completable subject cs =  completable subject . create (  )  ;  final  test observer <  void >  to = ps . concat map completable (  functions
public  sql objects   (  sql locator sql locator )  {  this . sql locator =  objects . require non null ( sql locator )  ;  return this ;   }  
@ test public void   (  )  {  final  atomic integer subscribe count = new  atomic integer (  )  ;  final  atomic integer unsubscribe count = new  atomic integer (  )  ;   observable <  long >  r =  observable . interval ( 0 1  time unit . milliseconds )  
public final boolean   (  )  {  return true ;   }  
public int   (  available plugin o1  available plugin o2 )  {  return o1 . get name (  )  . compare to ignore case ( o2 . get name (  )  )  ;   }  
@ override public boolean   (  char sequence text )  {  return  address . parse ( text . to string (  )  )  . length  =  =  1 ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;   }  
private void   (  node info n info byte[] nid )  {  if  ( n info . getnid (  )  . equals ( fake   nid )  )   {   node info new info = new  node info ( new nid ( nid )  n info . get hash (  )  n info . get port (  )  )  ;   destination dest = n info . get destination (  )  ;  if  ( dest  !  =  null )  new info . set destination ( dest )  ;  heard from ( new info )  ;   }  if  (    log . should log (  log . info )  )     log . info ( " rcvd pong from: "  +  n info )  ;   }  
public  string   (  )  {  return top level type name ;   }  
@ test public void   (  )  {   completable error =  completable . error ( new  runtime exception (  )  )  ;   completable . amb array (  completable . complete (  )  error )  . test (  )  . assert complete (  )  ;   }  
public boolean   (  string url )  {  return isurl ( get controlurl (  )  url )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  observable source <  object > 
@ override public  string   ( final  variant context ctx )  {  return  ( super . accept ( ctx )   ?  null : this . filter name )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . repeat until ( new  boolean supplier (  )  {  @ override public boolean get as boolean (  )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test (  )  . assert failure (  test
@ test public void   (  )  {   behavior subject <  string >  subject =  behavior subject . create default ( "default" )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "o
@ override public void   (  )  {  this . initialized = true ;   }  
public void   (  string sdp )  {  try  {   sip util . send ack withsdp ( ct sdp )  ;  set state ( invite   ack )  ;   }  catch  (   sip exception ex )   {  ex . print stack trace (  )  ;   }  catch  (   parse exception ex )   {  ex . print stack trace (  )  ;   }   }  
public void   ( byte[] b int offset int length int[] word offset )  {  int stride = m  -  5 ;  int cur bit =  ( k * 5 )   +   ( offset * 8 )  ;  int cur byte ;  for  ( int j = 0 ;  j  <  k ;  j +  +  )   {  cur byte = cur bit  /  8 ;  int bits unused =  (  ( cur byte  +  1 )  * 8 )   -  cur bit ;  if  ( bits unused  >  stride )   {  word offset[j] =  (  ( 0xff & b[cur byte] )   >  >   ( bits unused  -  stride )  )  & unmask[stride] ;   }  else if  ( bits unused  =  =  stride )   {  word offset[j] = b[cur byte] & unmask[stride] ;   }  else  {  word offset[j] = b[cur byte] & unmask[bits unused] ;  int bits to get = stride  -  bits unused ;  if  ( bits to get  >  =  8 )   {  word offset[j]| =  ( 0xff & b[cur byte  +  1] )   <  <  bits unused ;  bits to get -  = 8 ;  if  ( bits to get  >  0 )   {  word offset[j]| =  (  ( 0xff & b[cur byte  +  2] )   >  >   ( 8  -  bits to get )  )   <  <   ( stride  -  bits to get )  ;   }   }  else  {  word offset[j]| =  (  ( b[cur byte  +  1]  >  >   ( 8  -  bits to get )  )  & unmask[bits to get] )   <  <  bits unused ;   }   }  cur bit +  = stride ;   }   }  
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 3 )  ;   flowable <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1  <  2 ;   }   }   )
public boolean   (  )  {  return matched ;   }  
@ override public void   (  observer <  ?  super  observable < t >  >  t )  {   serialized observer <  observable < t >  >  actual = new  serialized observer <  observable < t >  >  ( t )  ;  if  ( timespan  =  =  timeskip )   {  if  ( max size  =  =   lo
public void   (  tunnel id tunnel )  {  if  (  !    do log )  return ;  if  ( tunnel  =  =  null )  return ;   string builder buf = new  string builder ( 128 )  ;  buf . append ( get prefix (  )  )  ;  buf . append ( "failing tunnel [" )  . append ( tunnel . get tunnel id (  )  )  . append ( "]" )  ;  add entry ( buf . to string (  )  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    (  iterable <  ?  extends  observable source <  ?  extends t >  >  sources )  {   object helper . require non null ( sources "sources is null
public void   (  publisher <  integer >  p )  {  p . subscribe ( this )  ;   }  
public  string   (  )  {  return  locale utils . get localized string ( "update . notification - message" )  ;   }  
@ test public void   (  )  {  thread safe cluster view = new  thread safe cluster view ( cluster members service ports )  ;  assert not null ( thread safe cluster view )  ;   }  
public void   (  )  {     context = new i2p app context (  )  ;   }  
@ override public void   (  handle handle  string name )  {  final  connection conn = handle . get connection (  )  ;  try  {  final  savepoint savepoint = local stuff . get ( handle )  . get savepoints (  )  . remove ( name )  ;  if  ( savepoint  =  =  n
@ override public void   (  )  {  log . debug ( "[task]  cancel  subscription :  {  } " to string (  )  )  ;   node node = get node (  )  ;  if  ( node  =  =  null )  return ;  node . cancel subscription ( get subscription (  )  false )  ;   }  
@ test ( data provider = "ok grouped files" )  public void   ( final  string sam filename final  string[] group files )  throws io exception  {  final  file sam file = new  file ( test   data   dir sam filename )  ;  final  map <  string  set <  string > 
@ override public void   (  )  {  count = 0 ;  for  (   multi user chat service muc service : xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat services (  )  )   {  count +  = muc service . get number connected us
public  string   (  )  {  return " net db flood search match" ;   }  
private boolean   (  string host )  {  if  ( host  =  =  null )  return true ;  if  ( host . equals ( "127 . 0 . 0 . 1:7657" )  || host . equals ( "localhost:7657" )  || host . equals ( "[::1]:7657" ) || host . equals ( "127 . 0 . 0 . 1:7667" ) || host . equals ( "localhost:7667" ) || host . equals ( "[::1]:7667" )  )  return true ;  if  (    listen hosts . is empty (  )  )  return true ;  host = get host ( host )  ;  if  (    listen hosts . contains ( host )  )  return true ;  if  (  addresses . isip address ( host )  )  return true ;  return false ;   }  
@ test public void   (  )  {   flowable . create ( source  backpressure strategy . error )  . subscribe ( ts )  ;  ts . cancel (  )  ;  source . on next ( 1 )  ;  source . on next ( 2 )  ;  source . on error ( new  test exception (  )  )  ;  ts . request 
@ test public void   (  )  throws  exception  {   string key1 = "a key" ;   string key2 = "a different key" ;   string value = "some value" ;  datastore . put ( key1 value )  ;  datastore . put ( key2 value )  ;   serializable element = datastore . get ( 
public void   (  string log dir )  {  this . log dir = log dir ;  base folder = new  file ( log dir )  ;  if  (  ! base folder . exists (  )  )   {  if  (  ! base folder . mkdir (  )  )   {   log . error ( " unable to create log directory:  {  } " base folder )  ;   }   }   }  
@ test public void   (  )  {  assert that ( p2   zero . is on curve ( curve )  is ( true )  )  ;  assert that (  group element . p2 ( curve zero zero one )  . is on curve ( curve )  is ( false )  )  ;  assert that (  group element . p2 ( curve one one one
public  string   (  update type type  string id )  {   version v =    available . get ( new  update item ( type id )  )  ;  if  ( v  =  =  null )  return null ;  return v . version ;   }  
private static byte[]   ( final int value )  {  final byte[] b = new byte[4] ;  b[0] =  ( byte )  (  ( value  >  >  >  24 )  & 0xff )  ;  b[1] =  ( byte )  (  ( value  >  >  >  16 )  & 0xff )  ;  b[2] =  ( byte )  (  ( value  >  >  >  8 )  & 0xff )  ;  b[3] =  ( byte )  (  ( value )  & 0xff )  ;  return b ;   }  
@ test public void   (  )  {   flowable <  string >  source =  flowable . just ( "a" "bb" "ccc" "dddd" )  ;   callable <  map <  integer  string >  >  map factory = new  callable <  map <  integer  string >  >  (  )  {  @ override public  map <  integer  
@ override public void   (  throwable e )  {  this . error = e ;   disposable helper . replace ( this scheduler . schedule direct ( this )  )  ;   }  
@ test public void   (  )  {   observer <  long >  observer =  test helper . mock observer (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   observable . range long ( 1 1000 )  . do on next ( new  consumer <  long >  (  )  {  @ override
@ test public void   (  )  {   flowable . zip (  flowable . just ( 1 )   flowable . just ( 2 )   flowable . just ( 3 )   flowable . just ( 4 )   flowable . just ( 5 )   flowable . just ( 6 )   flowable . just ( 7 )  new  function7 <  integer  integer  int
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  if  ( value  !  =  null )   {  done = true ;  s . cancel (  )  ;  actual . on error ( new  illegal argument exception ( " sequence contains more than one element ! " )  )  ;  return ;   
private void   (  packet packet )  {  boolean ok = packet . verify signature (    context packet . get optional from (  )  null )  ;  if  (  ! ok )   {  if  (    log . should log (  log . warn )  )     log . warn ( " received a spoofed syn packet: they said they were "  +  packet . get optional from (  )  )  ;  return ;   }   packet local reply = new  packet local (    context packet . get optional from (  )  packet . get session (  )  )  ;  reply . set flag (  packet . flag   reset )  ;  reply . set flag (  packet . flag   signature   included )  ;  reply . set ack through ( packet . get sequence num (  )  )  ;  reply . set send stream id ( packet . get receive stream id (  )  )  ;  reply . set receive stream id ( 0 )  ;  reply . set optional from (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " sending rst: "  +  reply  +  " because of " +  packet )  ;     manager . get packet queue (  )  . enqueue ( reply )  ;   }  
@ deprecated public static void   (  map <  string  string >  allowed )  {  set whitelistedi ps ( allowed . key set (  )  )  ;   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . scan ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  e
public   (  string cluster id  string node id )  {  this . cluster id = cluster id ;  this . node id = node id ;   }  
@ test public void   (  )  {   flowable <  integer >  error1 =  flowable . error ( new  test exception ( " one" )  )  ;   flowable <  integer >  source1 =  flowable . range ( 1 3 )  . concat with ( error1 )  ;   flowable <  integer >  error2 =  flowable .
@ override public boolean   (  )  {  return offline flood stopped ;   }  
public boolean   (  )  {  return is telephone event payload ;   }  
@ test public void   (  )  throws  exception  {  check internal operator naming ( " flowable" "producers" )  ;   }  
private static long   ( int[] buffer int n start index )  {  return  (  (  ( long ) buffer[n start index] )   <  <  32 )  |  (  (  ( long ) buffer[n start index  +  1] )  & 0x0ffffffffl )  ;   }  
public   ( byte[] nodeid jid address )  {  super ( nodeid address )  ;   }  
public static double[]   ( final double[] p posterior )  {  final double[] tmp = new double[p posterior . length] ;  final double total = sum ( p posterior )  ;  final double maxp = max   prob   below   one ;  final double minp =  ( 1  -  max   prob   below   one )   /   ( tmp . length  -  1 )  ;  for  ( int i = 0 ;  i  <  p posterior . length ;   +  + i )   {  tmp[i] = p posterior[i]  /  total ;  if  ( tmp[i]  >  maxp )  tmp[i] = maxp ;  else if  ( tmp[i]  <  minp )  tmp[i] = minp ;   }  return tmp ;   }  
@ override void   (  )  throws  exception  {  connection . starttls ( false )  ;   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . timeout (  functions . just function (  observable . never (  )  )   observable . never (  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public int   ( int mode )  {  if  (  ( mode & async )   !  =  0 )   {  output fused = true ;  return async ;   }  return none ;   }  
public float   (  )  {  return density ;   }  
private static void   ( long l value int[] buffer int n start index )  {  buffer[n start index] =  ( int )  ( l value  >  >  >  32 )  ;  buffer[n start index  +  1] =  ( int ) l value ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . concat map eager delay error ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   integer t )  {  return  observab
@ test public void   (  )  {   single . error ( new  test exception (  )  )  . subscribe (  )  ;   }  
@ override public void   (  print writer pw )  {  super . print stack trace ( pw )  ;  if  ( nested throwable  !  =  null )   {  nested throwable . print stack trace ( pw )  ;   }   }  
@ override public  string   (  )  {  return "flb with "  +  len  +  "  /  " +  max   size +  " page " +  page +  " next page " +  next page ;   }  
public rtp packet   (  byte encrypted bytes[] )  throws  exception  {  if  (  array extensions . get length ( encrypted bytes )  . int value (  )   <  12 )   {   log . info ( "decryptrtp packet less than 12 bytes" )  ;  return null ;   }   integer num = new  integer ( encrypted bytes[1] . byte value (  )  & 0x7f )  ;  if  ( num . int value (  )   >  =  72 && num . int value (  )   <  =  76 )   {   log . info ( "decryptrtp packet first bye no good "  +  encrypted bytes[1] )  ;  return null ;   }   encryption mode    var0 = get encryption mode (  )  ;  if  (    var0  !  =  null  ?     var0 . equals (  encryption mode .  null )  :    var0  =  =   encryption mode .  null )   {   log . info ( "decryptrtp no encryption found" )  ;  return rtp packet . parse bytes ( encrypted bytes )  ;   }  if  (  array extensions . get length ( encrypted bytes )  . int value (  )   <  12  +     rtp integrity size . int value (  )  )   {   log . info ( "decryptrtp packet too small" )  ;  return null ;   }   byte collection[] =  bit assistant . sub array ( encrypted bytes  integer . value of ( 0 )   integer . value of (  array extensions . get length ( encrypted bytes )  . int value (  )   -     rtp integrity size . int value (  )  )  )  ;   byte buffer2[] =  bit assistant . sub array ( encrypted bytes  integer . value of (  array extensions . get length ( encrypted bytes )  . int value (  )   -     rtp integrity size . int value (  )  )     rtp integrity size )  ;   array list list =  array list extensions . create array ( collection )  ;   array list extensions . add range ( list  bit assistant . get integer bytes from long network (    rtp decryptionroc )  )  ;   byte buffer4[] =  bit assistant . sub array (  crypto . get hmac sha1 (    rtp decryption auth  (  byte[] ) list . to array ( new  byte[0] )  )   integer . value of ( 0 )     rtp integrity size )  ;  if  (  !  bit assistant . sequences are equal ( buffer2 buffer4 )  . boolean value (  )  )   {   }  rtp packet packet = rtp packet . parse bytes ( collection )  ;  if  ( packet  =  =  null )   {   log . info ( "decryptrtp collection is bad" )  ;  return null ;   }  if  (    rtp decryption  !  =  null )  packet . set payload (    rtp decryption . decrypt ( packet . get payload (  )  packet . get synchronization source (  )  getrtp decryption packet index ( packet . get sequence number (  )  )  )  )  ;  return packet ;   }  
@ override protected void   (  )  throws  exception  {  super . set up (  )  ;   intent i = get test intent ( "imap: /  / user:password@server . com:999" )  ;  set activity intent ( i )  ;   }  
public  client transaction   (  response challenge  client transaction challenged transaction )  throws  sip security exception   sip exception   invalid argument exception   parse exception  {  try  {   string branchid = challenged transaction . get branch id (  )  ;   request challenged request = challenged transaction . get request (  )  ;   request reoriginated request =  (  request ) challenged request . clone (  )  ;   list iterator auth headers = null ;  if  ( challenge  =  =  null || reoriginated request  =  =  null )  throw new  null pointer exception ( "a null argument was passed to handle challenge . " )  ;  if  ( challenge . get status code (  )   =  =   response . unauthorized )  auth headers = challenge . get headers ( www authenticate header . name )  ;  else if  ( challenge . get status code (  )   =  =   response . proxy   authentication   required )  auth headers = challenge . get headers (  proxy authenticate header . name )  ;  if  ( auth headers  =  =  null )  throw new  security exception ( " could not find www authenticate or  proxy authenticate headers" )  ;  reoriginated request . remove header (  authorization header . name )  ;  reoriginated request . remove header (  proxy authorization header . name )  ;  c seq header c seq =  ( c seq header ) reoriginated request . get header (  ( c seq header . name )  )  ;  c seq . set sequence number ( c seq . get sequence number (  )   +  1 )  ;   client transaction retry tran = transaction creator . get new client transaction ( reoriginated request )  ;  www authenticate header auth header = null ;   credentials cache entry cc entry = null ;  while  ( auth headers . has next (  )  )   {  auth header =  ( www authenticate header ) auth headers . next (  )  ;   string realm = auth header . get realm (  )  ;  cc entry = cached credentials . remove ( realm )  ;   user credentials default credentials = new  user credentials (  )  ;   from header from =  (  from header ) reoriginated request . get header (  from header . name )  ;  uri uri = from . get address (  )  . geturi (  )  ;  if  ( uri . is sipuri (  )  )   {   log . debug ( "handle challenge" sip config . get auth user name (  )  )  ;   string user = sip config . get auth user name (  )   !  =  null  ?  sip config . get auth user name (  )  :  (  (  sipuri ) uri )  . get user (  )  ;  default credentials . set auth user name ( user  =  =  null  ?  sip config . get user name (  )  : user )  ;   }  boolean cc entry has seen tran = false ;  if  ( cc entry  !  =  null )  cc entry has seen tran = cc entry . process response ( branchid )  ;  if  ( cc entry  =  =  null ||  (  (  ! auth header . is stale (  )  && cc entry has seen tran )  )  )   {  if  ( cc entry  =  =  null )   {  cc entry = new  credentials cache entry (  )  ;  cc entry . user credentials = default credentials ;   }  sip config . set user name ( cc entry . user credentials . get user name (  )  )  ;   }  else if  ( cc entry  !  =  null &&  (  ! cc entry has seen tran || auth header . is stale (  )  )  )   {   }  if  ( cc entry . user credentials  =  =  null )  throw new  security exception ( " unable to authenticate with realm "  +  realm )  ;   authorization header authorization = this . get authorization ( reoriginated request . get method (  )  reoriginated request . get requesturi (  )  . to string (  )  reoriginated request . get content (  )   =  =  null  ?  "" : reoriginated request . get content (  )  . to string (  )  auth header cc entry . user credentials )  ;  cc entry . process request ( retry tran . get branch id (  )  )  ;  cached credentials . cache entry ( realm cc entry )  ;  reoriginated request . add header ( authorization )  ;  if  ( uri . is sipuri (  )  )   {   (  (  sipuri ) uri )  . set user ( cc entry . user credentials . get user name (  )  )  ;   address add = from . get address (  )  ;  add . seturi ( uri )  ;  from . set address ( add )  ;  reoriginated request . set header ( from )  ;  if  ( challenged request . get method (  )  . equals (  request . register )  )   {   to header to =  (  to header ) reoriginated request . get header (  to header . name )  ;  add . seturi ( uri )  ;  to . set address ( add )  ;  reoriginated request . set header ( to )  ;   }  sip man callback . set currently useduri ( uri . to string (  )  )  ;   log . debug ( "uri: "  +  uri . to string (  )  )  ;   }   }  return retry tran ;   }  catch  (   exception e )   {   log . debug ( "erro reg: "  +  e . to string (  )  )  ;  return null ;   }   }  
public static  string   (  )  {  return sip config . ip address ;   }  
boolean   ( final byte[] bases final byte[] quals final int seed length final int min quality )  {  if  ( bases . length  <  seed length )  return false ;  for  ( int i = 0 ;  i  <  seed length ;   +  + i )   {  if  (  sequence util . is no call ( bases[i] )  )  return false ;   }  final int max read length =  ( max   read   length  <  =  0 )   ?   integer . max   value : max   read   length ;  final int read length =  math . min ( bases . length max read length )  ;  int total = 0 ;  for  ( int i = 0 ;  i  <  read length ;  i +  +  )  total +  = quals[i] ;  return total  /  read length  >  =  min quality ;   }  
@ test public void   (  )  {   single . from callable ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   )  . to observable (  )  . take ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {  final  test scheduler scheduler = new  test scheduler (  )  ;   rx java plugins . set computation scheduler handler ( new  function <  scheduler  scheduler >  (  )  {  @ override public  scheduler apply (   scheduler v )  thr
@ test public void   (  )  throws  exception  {   multimap <  user  article >  joined =  hash multimap . create (  )  ;  h . create query ( "select * from user natural join author natural join article" )  . map (  join row mapper . for types (  user . cla
@ override public void   ( final long account id )  throws  remote exception  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m service . push modify ( account id )  ;   }   }   "push modify" )  ;   }  
public static  calendar[]   (  time spec spec1  time spec spec2 )  throws  rrd exception  {  if  ( spec1 . type  =  =  type   start || spec2 . type  =  =  type   end )   {  throw new  rrd exception ( " recursive time specifications not allowed" )  ;   }  spec1 . context = spec2 ;  spec2 . context = spec1 ;  return new  calendar[] { spec1 . get time (  )  spec2 . get time (  )  }  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  pp . on complete (  )  ;  dispose (  )  ;   }   }  
void   ( long total event count )  {  this . total event count = total event count ;   }  
@ test public void   (  )  {   behavior processor <  integer >  source =  behavior processor . create default ( 1 )  ;  final  subscriber <  object >  o =  test helper . mock subscriber (  )  ;  source . take ( 1 )  . subscribe ( o )  ;  verify ( o )  . o
public void   (  network state state  string msg )  {  this . state = state ;  this . msg = msg ;   }  
public  string   (  )  {  return get datagram packet (  )  . get address (  )  . get host address (  )  ;   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends  iterable <  ?  extends r >  >  mapper )  {  this . actual = actual ;  this . mapper = mapper ;  this . requested = new  atomic long (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . distinct until changed (  (  function <  integer  integer >  ) null )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  backpressure buffer subscriber < t >  ( s buffer size unbounded delay error on overflow )  )  ;   }  
@ override public void   (  string group name jid user boolean administrator )  {  throw new  unsupported operation exception ( " cannot add members to read - only groups" )  ;   }  
@ override public  enumeration <  string >    (  )  {  return  collections . enumeration ( init params . key set (  )  )  ;   }  
protected   ( i2p session sess int listen protocol int listen port )  throws io exception   data format exception  i2p session exception  {     log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " initializing sam message - based session" )  ;  this . listen protocol = listen protocol ;  this . listen port = listen port ;     is own session = false ;  session = sess ;  handler = new sam message session handler ( session )  ;   }  
@ override public boolean   (  object obj )  {  if  (  ( obj  =  =  null )  ||  !  ( obj instanceof  delivery instructions )  )  return false ;   delivery instructions instr =  (  delivery instructions ) obj ;  return  ( get delay requested (  )   =  =  i
public int   (  )  throws io exception  {  return delegate . read unsigned short (  )  ;   }  
@ xml element public boolean   (  )  {  return can change nickname ;   }  
@ test public void   (  )  {  int s =  scheduler pool factory . pools . size (  )  ;   scheduler pool factory . try put into pool ( true null )  ;  assert equals ( s  scheduler pool factory . pools . size (  )  )  ;   }  
private void   (  )  throws  rrd exception  {  im . xsize = gdef . width ;  im . ysize = gdef . height ;  im . unitslength = gdef . units length ;  if  ( gdef . only graph )   {  if  ( im . ysize  >  64 )   {  throw new  rrd exception ( " cannot create graph only  height too big" )  ;   }  im . xorigin = 0 ;   }  else  {  im . xorigin =  ( int )  ( padding   left  +  im . unitslength * get small font char width (  )  )  ;   }  if  ( gdef . vertical label  !  =  null )   {  im . xorigin +  = get font height ( fonttag   unit )  ;   }  if  ( gdef . only graph )   {  im . yorigin = im . ysize ;   }  else  {  im . yorigin = padding   top  +  im . ysize ;   }  mapper = new  mapper ( this )  ;  if  ( gdef . title  !  =  null )   {  im . yorigin +  = get font height ( fonttag   title )   +  padding   title ;   }  if  ( gdef . only graph )   {  im . xgif = im . xsize ;  im . ygif = im . yorigin ;   }  else  {  im . xgif = padding   right  +  im . xsize  +  im . xorigin ;  im . ygif = im . yorigin  +   ( int )  ( padding   plot * get font height ( fonttag   default )  )  ;   }   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 1  ( int ) elements )  . concat with (  completable . complete (  )  )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . window ( 1 1  time unit . seconds scheduler )  . flat map 
@ test public void   (  )  {   observable <  string >  src =  observable . empty (  )  ;  src . distinct until changed (  )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any string (  )  )  ;  verify ( w never (  )  )  . on error ( any (  t
@ override public void   (  disposable d )  {  if  ( observers . get (  )   =  =  terminated )   {  d . dispose (  )  ;   }   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  object >  >  (  )  {  @ override public  flowable <  object >  apply (   flowable <  object >  o )  throws  exception  { 
public void   ( boolean yes )  {     answer pings = yes ;   }  
  (  )  {  this . counter = new  object counter <  hash >  (  )  ;   simple timer2 . get instance (  )  . add periodic event ( new  cleaner (  )  clean   time )  ;   }  
public   (  string server name  connection connection  streamid streamid  locale language )  {  if  ( connection  =  =  null )   {  throw new  illegal argument exception ( "connection must not be null" )  ;   }  conn = connection ;  this . streamid = streamid ;  this . server name = server name ;   string id = streamid . getid (  )  ;  this . address = new jid ( null server name id true )  ;  this . session manager =  session manager . get instance (  )  ;  this . stream manager = new  stream manager ( this )  ;  this . language = language ;   }  
public long   (  )  {  return    connect timeout ;   }  
@ test ( data provider = "quality barcode data" )  public void   ( final int quality final int max mismatches final int perfect matches final int one mismatch final  string test name )  throws  exception  {  final  file metrics file =  file . create temp 
public void   (  string node )  {  server node providers . remove ( node )  ;   }  
final void   ( final  prepared statement stmt )  {  for  (   statement customizer customizer : customizers )   {  try  {  customizer . before binding ( stmt ctx )  ;   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( " exception thrown in statement customization" e ctx )  ;   }   }   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   test observer <  integer >  to = source . single (  - 99 )  . take unt
private void   (  )  {  health check service proxy . report issue ( remote   datastore   service   config   issue " remote  datastore  service  configuration  error"  severity . broken )  ;  url xsdurl = get class (  )  . get resource ( default   config   schema )  ;  configuration service . subscribe to ( default   config   name xsdurl configuration listener  remote datastore configuration . class )  ;   }  
@ override public void   (  )  {   disposable d = get and set (  disposable helper . disposed )  ;  if  ( d  !  =   disposable helper . disposed )   {  this . ds = d ;  scheduler . schedule direct ( this )  ;   }   }  
void   (  throwable t )  {  s . cancel (  )  ;  resources . dispose (  )  ;   disposable helper . dispose ( boundary )  ;  actual . on error ( t )  ;   }  
public  session entities   (  )  throws  service exception  {   collection <  client session >  client sessions =  session manager . get instance (  )  . get sessions (  )  ;   session entities session entities = convert to session entities ( client sessions )  ;  return session entities ;   }  
@ before public void   (  )  {  version ids = create version ids ( 2 )  ;   }  
public   (  iterable <  ?  extends  maybe source <  ?  extends t >  >  sources  function <  ?  super  object[]  ?  extends r >  zipper )  {  this . sources = sources ;  this . zipper = zipper ;   }  
@ test public void   (  )  {  final  list <  object >  received = new  array list <  object >  (  )  ;   lambda subscriber <  object >  o = new  lambda subscriber <  object >  ( new  consumer <  object >  (  )  {  @ override public void accept (   object 
@ override protected  ad hoc command .  action   (  session data data )  {  return  ad hoc command .  action . complete ;   }  
@ override public void   (  subscription s )  {   subscription helper . set once ( this s  long . max   value )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   observable <  integer >  source =  observable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override publi
@ test public void   (  )  {   completable subject . create (  )  . subscribe ( new  completable observer (  )  {  @ override public void on subscribe (   disposable d )  {  assert false ( d . is disposed (  )  )  ;  d . dispose (  )  ;  d . dispose (  ) 
@ test public void   (  )  {   string value =  flowable . just ( 1 2 3 )  . collect ( new  callable <  string builder >  (  )  {  @ override public  string builder call (  )  {  return new  string builder (  )  ;   }   }   new  bi consumer <  string build
public   (  )  {  super (  email provider . class  email content . authority )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final int[] t = new int[10] ;  for  ( int j = 0 ;  j  <  10 ;  j +  +  )   {  t[j] = random . next int ( 1  <  <  28 )   -   ( 1  <  <  27 )  ;   }  final boolean is negative 
@ test public void   (  )  throws  interrupted exception  {   observable <  integer >  source =  observable .  <  integer > never (  )  ;  final  publish subject <  integer >  timeout =  publish subject . create (  )  ;   function <  integer  observable <
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  actual . on next ( t )  ;  if  (  ! once )   {  arbiter . produced ( 1l )  ;   }   }  
public static int   (  )  {  return rtp timeout ;   }  
public boolean   (  )  {  return socket . is closed (  )  ;   }  
public boolean   (  )  {  return flag set ( udp packet . data   flag   want   acks )  ;   }  
@ test public void   (  )  {   runnable noop = mock (  runnable . class )  ;   unicast subject <  integer >  ap =  unicast subject . create ( 16 noop true )  ;  ap . on next ( 1 )  ;  ap . on error ( new  runtime exception (  )  )  ;   test observer <  in
@ override public boolean   (  )  {  logger . finest ( "is email required" )  ;  return false ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public static  < t >  single < t >    ( final  iterable <  ?  extends  single source <  ?  extends t >  >  sources )  {   object helper . require non null ( sources "sources is null" 
@ test public void   (  )  {   flowable . range ( 1 100000 )  . publish ( new  function <  flowable <  integer >   publisher <  integer >  >  (  )  {  @ suppress warnings ( "unchecked" )  @ override public  publisher <  integer >  apply (   flowable <  in
@ test public void   (  )  {  final  overlap detector <  interval >  one tiny interval detector = new  overlap detector <  interval >  ( 0 0 )  ;  final  interval the interval = new  interval ( "1" 5 10 )  ;  one tiny interval detector . add lhs ( the int
@ override public void   ( t t )  {  produced +  +  ;  actual . on next ( t )  ;   }  
@ override public void   (  disposable d )  {  observer . on subscribe ( d )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ override public void   (  )  {  final  array deque <  unicast subject < t >  >  ws = windows ;  while  (  ! ws . is empty (  )  )   {  ws . poll (  )  . on complete (  )  ;   }  actual . on complete (  )  ;   }  
@ data provider ( name = " " )  public  object[][] multi bin passing clocs files (  )  {  return new  object[][] {  { multi   bin   passing   clocs   file 0 2102 }   { mbcf   w   empty   bins   at   start 2 2103 }   { mbcf   w   empty   bins   at   end 0 
public static  string   (  )  {  return default record directory ;   }  
@ override public void   (  )  {  latch . count down (  )  ;   }  
public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write int ( out type . ordinal (  )  )  ;   externalizable util . get instance (  )  . write long ( out date . get time (  )  )  ;   externalizable util . get instance (  )  . write boolean ( out sender  !  =  null )  ;  if  ( sender  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out sender )  ;   }   externalizable util . get instance (  )  . write boolean ( out receiver  !  =  null )  ;  if  ( receiver  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out receiver )  ;   }   externalizable util . get instance (  )  . write boolean ( out body  !  =  null )  ;  if  ( body  !  =  null )   {   externalizable util . get instance (  )  . write safeutf ( out body )  ;   }   externalizable util . get instance (  )  . write boolean ( out roomjid  !  =  null )  ;  if  ( roomjid  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out roomjid )  ;   }   externalizable util . get instance (  )  . write boolean ( out user  !  =  null )  ;  if  ( user  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out user )  ;   }   externalizable util . get instance (  )  . write boolean ( out nickname  !  =  null )  ;  if  ( nickname  !  =  null )   {   externalizable util . get instance (  )  . write safeutf ( out nickname )  ;   }   }  
@ test public void   (  )  {   replay processor <  object >  rs =  replay processor . create (  )  ;  rs . on complete (  )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has value (  )  )  ;   }  
@ test public void   (  )  {   observable . range long ( 1l 0l )  ;   }  
protected   (  string name )  {  this . name = name ;  buffer = new byte[0] ;   }  
@ override public void   (  )  {   observer <  ?  super t >  a = actual ;  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  t v = poll (  )  ;  if  ( v  =  =  null )   {  if  (  ! cancelled )   {  a . on complete (  )  ;   }  return ;   }  a . 
public static  string   (  resource bundle catalog  string msgid )  {   string result = gettextnull ( catalog msgid )  ;  if  ( result  !  =  null )  return result ;  return msgid ;   }  
public static void   (  string[] args )  {  if  ( args . length  =  =  0 )   {  help (  )  ;  return ;   }  run app ( args )  ;   }  
@ override public  set < i2p socket >    (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ benchmark public void   (  blackhole bh )  {  nbp range map range . subscribe ( new  perf observer ( bh )  )  ;   }  
private void   ( int type  string name )  throws sql exception  {   connection con = null ;  boolean abort transaction = false ;  try  {  con =  db connection manager . get transaction connection (  )  ;   prepared statement pstmt = con . prepare statement ( insert   bookmark   permissions )  ;  pstmt . set long ( 1 bookmarkid )  ;  pstmt . set int ( 2 type )  ;  pstmt . set string ( 3 name )  ;  pstmt . execute update (  )  ;  pstmt . close (  )  ;   }  catch  (  sql exception sqle )   {  abort transaction = true ;  throw sqle ;   }  finally  {   db connection manager . close transaction connection ( con abort transaction )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   iterator <  object >  it =  flowable . never (  )  . blocking latest (  )  . iterator (  )  ;   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   (  (  su
public void   (  string file )  {     priv key file =  ( file  !  =  null  ?  file . trim (  )  : null )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ override public int   ( int mode )  {  if  (  ( mode & sync )   !  =  0 )   {  fusion mode = true ;  return sync ;   }  return none ;   }  
public void   ( boolean is muted )  {  if  ( trace call ||  logger . log level  >  =   logger . log   info )   {   logger . println ( " call "  +  cp  +  " mute is now " +  is muted )  ;   }  cp . set muted ( is muted )  ;  if  ( speech detector  =  =  null )   {  return ;   }  if  ( is muted )   {  if  ( speech detector . is speaking (  )  )   {  call handler . speaking changed ( false )  ;   }   }  speech detector . reset (  )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . ignore element (  )  . test (  )  . assert result (  )  ;   single . error ( new  test exception (  )  )  . ignore element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ before public void   (  )  {  stream =  input stream merger . merge (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  document web xml =  web xml utils . as document ( new  file (  web xml utils test . class . get resource ( " / org / jivesoftware / util / test - web . xml" )  . touri (  )  )  )  ;  final  string fi
private static void   (  string args[] int start args  properties props )  throws  help requested exception  {  for  ( int i = start args ;  i  <  args . length ;  i +  +  )   {  int eq = args[i] . index of ( ' = ' )  ;  if  ( eq  <  =  0 )  throw new  help requested exception (  )  ;  if  ( eq  >  =  args[i] . length (  )   -  1 )  throw new  help requested exception (  )  ;   string key = args[i] . substring ( 0 eq )  ;   string val = args[i] . substring ( eq  +  1 )  ;  key = key . trim (  )  ;  val = val . trim (  )  ;  if  (  ( key . length (  )   >  0 )  &&  ( val . length (  )   >  0 )  )  props . set property ( key val )  ;  else throw new  help requested exception (  )  ;   }   }  
@ test public void   (  )  {   flowable . range ( 0 100000 )  . take last ( 100000 )  . subscribe ( new  default subscriber <  integer >  (  )  {  @ override public void on start (  )  {  request ( 1 )  ;   }  @ override public void on complete (  )  {   
@ test public void   (  )  throws io exception  {  final  file snp input file = new  file ( test   data   path "ceu trio - snps . vcf" )  ;  final  file output =  file . create temp file ( "sort - presorted - test - output . " " . vcf" )  ;  final  list <
@ test public void   (  )  {   completable . create ( new  completable on subscribe (  )  {  @ override public void subscribe (   completable emitter e )  throws  exception  {  e . on error ( null )  ;   }   }   )  . test (  )  . assert failure (  null po
@ override public void   (  completable observer s )  {  sources . subscribe ( new  completable concat subscriber ( s prefetch )  )  ;   }  
private static  function <  consumer <  object >   map <  integer  object >  >    ( final int max size )  {   function <  consumer <  object >   map <  integer  object >  >  evicting map factory = new  function <  consumer <  object >   map <  integer  object >  >  (  )  {  @ override public  map <  integer  object >  apply (  final  consumer <  object >  notify )  throws  exception  {  return new  single thread evicting hash map <  integer  object >  ( max size new  consumer <  object >  (  )  {  @ override public void accept (   object object )  {  try  {  notify . accept ( object )  ;   }  catch  (   exception e )   {  throw new  runtime exception ( e )  ;   }   }   }   )  ;   }   }   ;  return evicting map factory ;   }  
public boolean   (  )  {  return are equal ;   }  
@ test @ ignore ( " publishers should not throw" )  public void   (  )  {   flowable <  string >  test observable =  flowable . unsafe create ( new  publisher <  string >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  string >  t1 
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . skip while (  functions . always false (  )  )  )  ;   }  
public final int   (  )  {  if  ( m old flag read  =  =  m new flag read )   {  return value   unchanged ;   }  return m new flag read ;   }  
public static  string   (  )  {  return "null   hmac   sha1   32" ;   }  
public  string   (  )  {  return name ;   }  
  (  observer <  ?  super t >  actual long period  time unit unit  scheduler scheduler )  {  super ( actual period unit scheduler )  ;   }  
private final  string   (  )  {  if  (    settings . is exploratory (  )  )  return "tunnel . build ratio . exploratory . "  +   (    settings . is inbound (  )   ?  "in" : "out" )  ;  else return "tunnel . build ratio . l"  +     settings . get length (  )   +  "v" +     settings . get length variance (  )  +   (    settings . is inbound (  )   ?  " . in" : " . out" )  ;   }  
public boolean   (  )  {  return is fatal ;   }  
public void   ( int call answer timeout )  {  this . call answer timeout = call answer timeout ;   }  
@ override synchronized protected iq   ( iq iq )  throws  exception  {   log . info ( " rayo component handleiq get \n"  +  iq . to string (  )  )  ;  final  element element = iq . get child element (  )  ;  final  string namespace = element . get namespa
@ override public  string   (  )  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m return = m service . get device id (  )  ;   }   }   "get device id" )  ;  wait for completion (  )  ;  if  ( m return
private static boolean   (  session object session object  string showuidl  request wrapper request  http servlet response response )  {   string str = request . get parameter ( save   as )  ;  if  ( str  =  =  null )  return false ;   mail cache mc = get current mail cache ( session object request )  ;   mail mail =  ( mc  !  =  null )   ?  mc . get mail ( showuidl  mail cache .  fetch mode . all )  : null ;  if  ( mail  !  =  null )   {  if  ( send mail save as ( session object mail response )  )  return true ;   }  session object . error +  =    t ( " message not found . " )  ;  try  {  response . send error ( 404    t ( " message not found . " )  )  ;   }  catch  (  io exception ioe )   {   }  return true ;   }  
public static  resource bundle   (  string base name  locale locale )  {  return  resource bundle . get bundle ( base name locale )  ;   }  
@ override public boolean   (  object obj )  {  if  (  ( obj  =  =  null )  ||  !  ( obj instanceof  rate stat )  )  return false ;  if  ( obj  =  =  this )  return true ;   rate stat rs =  (  rate stat ) obj ;  if  ( name group desc equals ( rs )  )  ret
@ override public void   (  )  {  m open = false ;  m input open = false ;  if  ( m pairs . size (  )   >  0 )   {   transaction expect = m pairs . remove ( 0 )  ;  if  ( expect . m action  =  =   transaction . action   client   close )   {  return ;   } 
public   (  )  {  super ( 100 )  ;   }  
@ override protected  void   (  stream <  ?  >  stream  statement context ctx )  {  @ suppress warnings ( "unchecked" )   consumer <  object >  consumer =  (  consumer <  object >  ) ctx . get config (  sql object statement configuration . class )  . get 
@ override public void   (  maybe emitter <  integer >  s )  throws  exception  {  calls[0] +  +  ;  s . on success ( 1 )  ;   }  
public   (  string jid  string nickname int subscription type )  {  this . jid = jid ;  this . nickname = nickname ;  this . subscription type = subscription type ;   }  
@ override public void   (  )  {  ready . decrement and get (  )  ;  while  ( ready . get (  )   !  =  0 )   {   }  ts . request ( 1 )  ;   }  
@ override public  string   (  )  {  return " kademlia  net db  explore" ;   }  
public   (  predicate <  ?  super t >  on next  consumer <  ?  super  throwable >  on error  action on complete )  {  this . on next = on next ;  this . on error = on error ;  this . on complete = on complete ;   }  
@ override public void   ( jid userjid )  {  remove users allowed to create (  collections . singleton ( userjid )  )  ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   flowable .  <  integer > never (  )  . buffer ( 1  time unit . milliseconds  schedulers . single (  )  10 new  callable <  collection <  integer >  >  (  )  {  int count ;  @ override pub
public void   (  node left  node right )  {  final int left index = add node ( left )  ;  if  ( left  =  =  right )  return ;  final int right index = add node ( right )  ;  add neighbor ( left index right index )  ;  add neighbor ( right index left index )  ;   }  
@ override public  ref   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  illegal argument exception . class )  public void   (  )  {   parallel flowable . from array ( new  publisher[0] )  ;   }  
@ override boolean   (  )  {  return true ;   }  
public  db properties   (  )  {  if  ( properties  =  =  null )   {  properties = new  jive live properties ( "fp agent prop" id )  ;   }  return properties ;   }  
@ test public void   (  )  throws  exception  {   single . just ( 1 )  . delay subscription (  observable . timer ( 100  time unit . milliseconds )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  observer )  {  observer
public void   (  string patt )  {  patterns = patt ;   jive globals . set property ( patterns   property patt )  ;  change content filter patterns (  )  ;   }  
@ test public void   (  )  {   publish processor <  string >  r1 =  publish processor . create (  )  ;   subscriber <  string >  o =  test helper . mock subscriber (  )  ;   in order io = in order ( o )  ;   iterable <  string >  r2 =  arrays . as list ( 
public static  class <  ?  >    (  type type )  {  return  type token . of ( type )  . get raw type (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . just ( 1 )  . do after terminate ( null )  ;   }  
private void   (  )  {  is running = false ;  datastore service . destroy datastore ( remote   datastore   name )  ;  configuration service . unsubscribe from ( default   config   name configuration listener )  ;  health check service proxy . resolve issue ( remote   datastore   service   config   issue )  ;   }  
@ override public void   (  )  {  if  (  ! cancelled )   {  cancelled = true ;  resources . dispose (  )  ;  if  ( get and increment (  )   =  =  0 )   {   equal observer < t > [] as = observers ;  as[0] . queue . clear (  )  ;  as[1] . queue . clear (  )
@ override public void   ( t t )  {  produced +  +  ;  actual . on next ( t )  ;   }  
public void   (  string ff )  {     ff = ff ;   }  
@ override public  string   (  )  throws  unknowncpu exception  {  throw new  unknowncpu exception ( " class cpuidcpu info cannot indentify cp us" )  ;   }  
public   (  string result k key )  {  this . result = result ;  this . key = key ;   }  
public uri   (  )  {  return uri ;   }  
public static  string   (  )  {  return    system nonce ;   }  
@ test public void   (  )  {   completable . complete (  )  . on terminate detach (  )  . test (  )  . assert result (  )  ;   }  
@ override public void   (  )  {  try  {  cb . await (  )  ;   }  catch  (   interrupted exception e )   {  return ;   }  catch  (   broken barrier exception e )   {  return ;   }  for  ( int i = 0 ;  i  <  1000000 ;  i +  +  )   {  rs . on next ( i )  ; 
public  string   (  )  {  return config ;   }  
@ test @ ignore ( " null values not allowed" )  public void   (  )  {   flowable <  string >  observable =  flowable . from iterable (  arrays . as list ( "one" null "two" )  )  . skip last ( 1 )  ;   subscriber <  string >  observer =  test helper . mock
@ test public void   (  )  {   async subject <  object >  p =  async subject . create (  )  ;  final  test observer <  object >  to2 = new  test observer <  object >  (  )  ;   test observer <  object >  to1 = new  test observer <  object >  (  )  {  @ ov
@ override public void   (  )  {  done = true ;   half serializer . on complete ( actual this error )  ;   }  
public long   (  )  {  return    last rejected critical ;   }  
protected static synchronized i2p session   ( i2p tunnel tunnel )  {  i2p session sess = socket manager . get session (  )  ;  if  ( sess . get my destination (  )  . get sig type (  )   =  =   sig type . dsa   sha1 )  return null ;   properties props = new  properties (  )  ;  props . put all ( tunnel . get client options (  )  )  ;   string name = props . get property ( "inbound . nickname" )  ;  if  ( name  !  =  null )  props . set property ( "inbound . nickname" name  +  "  ( dsa ) " )  ;  name = props . get property ( "outbound . nickname" )  ;  if  ( name  !  =  null )  props . set property ( "outbound . nickname" name  +  "  ( dsa ) " )  ;  props . set property ( i2p client . prop   sigtype "dsa   sha1" )  ;  try  {  return socket manager . add subsession ( null props )  ;   }  catch  (  i2p session exception ise )   {   log log = tunnel . get context (  )  . log manager (  )  . get log ( i2p tunnel client base . class )  ;  if  ( log . should log (  log . warn )  )  log . warn ( " failed to add subssession" ise )  ;  return null ;   }   }  
@ test public void   (  )  {   list <  throwable >  error =  test helper . track plugin errors (  )  ;  try  {   test completable tc = new  test completable (  )  ;  tc . on subscribe (  disposables . empty (  )  )  ;   disposable d =  disposables . empty
public long   (  )  {  return    lifetime failed . get (  )  ;   }  
@ override public void   (  )  {  acquire lock ( key )  ;   }  
public synchronized void   ( boolean header only )  {  this . header only = header only ;   }  
@ override @ suppress warnings ( "unchecked" )  public void   (  replay subscription < t >  rs )  {  if  ( rs . get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;  final  subscriber <  ?  super t >  a = rs . actual ;   timed node < t >
 string   (  )  {  return consol fun ;   }  
public long   (  )  {  return heartbeat ;   }  
public synchronized boolean   (  )  {  return success ;   }  
public  group element   (  )  {  return  aneg ;   }  
@ override public  enumeration <  string >    (  )  {  return proxy . get init parameter names (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  single <  boolean >    (  )  {  return  rx java plugins . on assembly ( new  maybe is empty single < t >  ( this )  )  ;   }  
public static  < t >  simple queue < t >    ( int capacity hint )  {  if  ( capacity hint  <  0 )   {  return new  spsc linked array queue < t >  (  - capacity hint )  ;   }  return new  spsc array queue < t >  ( capacity hint )  ;   }  
private static void   (  string sam host int sam port  string con options )  {  int n tests = 20 ;  start alice ( sam host sam port con options )  ;  for  ( int i = 0 ;  i  <  n tests ;  i +  +  )   {  test bob ( "bob"  +  i sam host sam port con options )  ;  if  ( i % 2  =  =  1 )  try  {   thread . sleep ( 10 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  while  ( true )   {  synchronized  (    counter lock )   {  if  (    recv counter  =  =  n tests * 2 &&    close counter  =  =  n tests )   {  break ;   }   }  try  {   thread . sleep ( 1000 )  ;   }  catch  (   interrupted exception ie )   {   }     log . info ( " receive counter is: "  +     recv counter  +  "  close counter is: " +     close counter )  ;   }     log . info ( " unit test passed . " )  ;   }  
public   (  router context ctx  console update manager mgr )  {     context = ctx ;     mgr = mgr ;   }  
public static boolean   (  router context ctx )  {  return ctx . get boolean property default true ( prop   enable   ntcp )  ;   }  
  (  runnable run  long exec time int count )  {  this . run = run ;  this . exec time = exec time ;  this . count = count ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  domain =  externalizable util . get instance (  )  . read safeutf ( in )  ;  if  (  externalizable util . get instance (  )  . read boolean ( in )  )   {  p
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . combine latest ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] v )  {  return nul
@ test public void   (  )  {   basic fuseable subscriber <  integer  integer >  fcs = new  basic fuseable subscriber <  integer  integer >  ( new  test subscriber <  integer >  ( 0l )  )  {  @ override public void on next (   integer t )  {   }  @ overrid
byte[]   (  hash peer )  {  return  transport impl . getip ( peer )  ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 2 3 4 )  ;  o . reduce ( 50 new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer t1   integer t2 )  {  return t1  +  t2 ; 
private void   ( final sam record rec )  {  final boolean is negative strand = rec . get read negative strand flag (  )  ;  final boolean is read two = rec . get read paired flag (  )  && rec . get second of pair flag (  )  ;  if  ( is read two )   {  if  ( is negative strand )  this . r2   neg +  +  ;  else this . r2   pos +  +  ;   }  else  {  if  ( is negative strand )  this . r1   neg +  +  ;  else this . r1   pos +  +  ;   }   }  
@ override public void   (  )  {  throw new  test exception (  )  ;   }  
public void   ( int port )  {  this . get device data (  )  . setssdp port ( port )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable <  integer >  source =  flowable . create ( new  flowable on subscribe <  integer >  (  )  {  @ override public void subscribe (   flowable emitter
private static  string[]   (  string[] enabled cipher suites  string[] supported cipher suites )  {  return select ( enabled cipher suites supported cipher suites include   ciphers exclude   ciphers )  ;   }  
@ override public  string   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {   test resource single observer <  integer >  rso = new  test resource single observer <  integer >  (  )  ;  rso . dispose (  )  ;   disposable d =  disposables . empty (  )  ;  rso . on subscribe ( d )  ;  assert true ( d . 
@ test public void   (  )  {   maybe . never (  )  . timeout ( 1  time unit . milliseconds  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert failure (  timeout exception . class )  ;   }  
protected int   (  input stream in byte target[] )  throws io exception  {  return  data helper . read ( in target )  ;   }  
public void   (  session key key )  {     currentmac key = key ;   }  
@ test ( timeout = 2000 )  public void   (  )  {  final  atomic long count = new  atomic long (  )  ;  infinite   observable . take ( 10 )  . subscribe ( new  consumer <  long >  (  )  {  @ override public void accept (   long l )  {  count . set ( l )  ;
static void   (  output stream cm dout  string s )  throws io exception  {  cm dout . write (  data helper . getutf8 ( s )  )  ;  cm dout . write ( '\n' )  ;  cm dout . flush (  )  ;   }  
public boolean   (  )  {  return only not processed enabled ;   }  
@ test public void   (  )  {   observable . zip (  observable . just ( 1 )   observable . just ( 2 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  throws  exception  {  return ""  + 
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements * 2 )  . skip ( elements )  ;   }  
public  date   (  )  {  return start date ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write serializable ( out jid )  ;   externalizable util . get instance (  )  . write boolean ( out nickname  !  =  null )  ;  if  ( nickna
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . subscription s )  )   {  subscription = s ;  if  ( remaining  =  =  0 )   {  done = true ;  s . dispose (  )  ;   empty disposable . complete ( actual )  ;   }  el
public static void   (  context context long account id  policy policy  string security key )  {  set account policy2 ( context account id policy security key true )  ;   }  
@ test public void   (  )  {  final  test scheduler scheduler = new  test scheduler (  )  ;   rx java plugins . set computation scheduler handler ( new  function <  scheduler  scheduler >  (  )  {  @ override public  scheduler apply (   scheduler v )  thr
public   (  )  {  super ( " multicast  packet  router" )  ;   string cache name = " multicast  service" ;  cache =  cache factory . create cache ( cache name )  ;   }  
@ override public void   ( final long account id )  throws  remote exception  {  final  account account =  account . restore account with id ( m context account id )  ;  if  ( account  =  =  null )   {   log utils . e (  log utils . tag " account %d not f
  (  unicast subject < t >  w )  {  this . w = w ;   }  
public void   ( long pos )  throws io exception  {  delegate . seek ( pos )  ;   }  
public void   ( final  string read name final int reference sequence index1 final int reference sequence index2 final int alignment start1 final int alignment start2 final boolean record1 unmapped final boolean record2 unmapped final boolean is duplicate1 final boolean is duplicate2 final  string cigar1 final  string cigar2 final boolean strand1 final boolean strand2 final boolean first only final boolean record1 non primary final boolean record2 non primary final int default quality final  string umi final  string assignedumi )  {  final  list < sam record >  sam record list = sam record set builder . add pair ( read name reference sequence index1 reference sequence index2 alignment start1 alignment start2 record1 unmapped record2 unmapped cigar1 cigar2 strand1 strand2 record1 non primary record2 non primary default quality )  ;  final sam record record1 = sam record list . get ( 0 )  ;  final sam record record2 = sam record list . get ( 1 )  ;  if  ( this . no mate cigars )   {  record1 . set attribute ( "mc" null )  ;  record2 . set attribute ( "mc" null )  ;   }  if  ( first only )   {  sam record set builder . get records (  )  . remove ( record2 )  ;   }  final  string key1 = sam record to duplicates flags key ( record1 )  ;   assert . assert false ( this . duplicate flags . contains key ( key1 )  )  ;  this . duplicate flags . put ( key1 is duplicate1 )  ;  final  string key2 = sam record to duplicates flags key ( record2 )  ;   assert . assert false ( this . duplicate flags . contains key ( key2 )  )  ;  this . duplicate flags . put ( key2 is duplicate2 )  ;  if  ( umi  !  =  null )   {  record1 . set attribute ( "rx" umi )  ;  record2 . set attribute ( "rx" umi )  ;   }  if  ( assignedumi  !  =  null )   {  record1 . set attribute ( expected umi tag assignedumi )  ;  record2 . set attribute ( expected umi tag assignedumi )  ;   }   }  
public   (  router context context )  {     context = context ;     start = context . clock (  )  . now (  )  ;   }  
@ override public boolean   (  )  {  return disposed ;   }  
public  string   (  )  {  return "http: /  / www . jivesoftware . com / spark" ;   }  
@ override public void   (  )  {  get room (  )  . occupant updated (  update occupant . this )  ;   }  
private void   ( final  arc state state final double value  string consol fun string )  throws io exception  {  if  (  double . is nan ( value )  )   {  state . set nan steps ( state . get nan steps (  )   +  1 )  ;   }  else  {  final double accum value = state . get accum value (  )  ;  if  ( consol fun string . equals ( cf   min )  )   {  final double min value =  util . min ( accum value value )  ;  if  ( min value  !  =  accum value )   {  state . set accum value ( min value )  ;   }   }  else if  ( consol fun string . equals ( cf   max )  )   {  final double max value =  util . max ( accum value value )  ;  if  ( max value  !  =  accum value )   {  state . set accum value ( max value )  ;   }   }  else if  ( consol fun string . equals ( cf   last )  )   {  state . set accum value ( value )  ;   }  else if  ( consol fun string . equals ( cf   average )  )   {  state . set accum value (  util . sum ( accum value value )  )  ;   }   }   }  
public   (  completable source source )  {  this . source = source ;   }  
public static void   ( muc room room )  {  if  (  ! room . is persistent (  )  ||  ! room . was saved todb (  )  )   {  return ;   }   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( update   emptydate )  ;   date empty date = room . get empty date (  )  ;  if  ( empty date  =  =  null )   {  pstmt . set string ( 1 null )  ;   }  else  {  pstmt . set string ( 1  string utils . date to millis ( empty date )  )  ;   }  pstmt . set long ( 2 room . getid (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
@ override public void   (  movie pv )  {   system . out . println ( pv )  ;   }  
@ override public void   ( long n )  {  upstream . request ( n )  ;   }  
public  control point   (  )  {  return control point ;   }  
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  {  @ override public void on next (   integer t )  {  if  ( t  =  =
void   ( final  string consol fun final int steps )  throws  rrd exception  {  final  arc def arc def = find archive ( consol fun steps )  ;  if  (  ! arc defs . remove ( arc def )  )   {  throw new  rrd exception ( " could not remove archive "  +  consol fun  +  " / " +  steps )  ;   }   }  
public  session key   (  )  {  return    current key ;   }  
void   (  node child )  {   message message = new  message (  )  ;   element event = message . add child element ( "event" "http: /  / jabber . org / protocol / pubsub#event" )  ;  event . add element ( "delete" )  . add attribute ( "node" child . get nodeid (  )  )  ;  broadcast collection node event ( child message )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 3 )  . parallel ( 1 )  . sequential delay error ( 1 )  . take ( 2 )  . rebatch requests ( 1 )  . test (  )  . assert result ( 1 2 )  ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;  run finally (  )  ;   }  
public  long   (  )  {  return    synchronization source ;   }  
  ( final  subject < t >  actual )  {  this . actual = actual ;   }  
@ override public  string   (  )  {  return name ;   }  
public  string   (  )  {  return    config . get property ( prop   dest )  ;   }  
@ override public void   ( int position  prepared statement statement  statement context ctx )  throws sql exception  {   (  (  callable statement ) statement )  . register out parameter ( position sql type )  ;  this . position = position ;   }  
public  string   (  )  {  if  (    context  =  =  null )  return "[no router]" ;   router router =    context . router (  )  ;  if  ( router  =  =  null )  return "[not up]" ;  else return  data helper . format duration2 ( router . get uptime (  )  )  ;   }  
public  string   ( int tunnel )  {  if  ( get outproxy username ( tunnel )  . length (  )   <  =  0 )  return "" ;  return get property ( tunnel i2p tunnelhttp client base . prop   outproxy   pw "" )  ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;   observer resource wrapper <  object >  orw = new  observer resource wrapper <  object >  ( to )  ;   disposable d =  disposables . empty (  )  ;   dis
public void   ( int minutes )  {  m sync interval = minutes ;   }  
public static void   (  output stream out  string string )  throws  data format exception  io exception  {  if  ( string  =  =  null )   {  out . write (  ( byte ) 0 )  ;   }  else  {  int len = string . length (  )  ;  if  ( len  >  255 )  throw new  data format exception ( " the i2p data spec limits strings to 255 bytes or less  but this is "  +  len  +  " [" +  string +  "]" )  ;  out . write (  ( byte ) len )  ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )  out . write (  ( byte )  ( string . char at ( i )  & 0xff )  )  ;   }   }  
public long   (  )  {  return id ;   }  
public void   (  document factory factory )  {  this . factory = factory ;   }  
public static  group element[]   (  string file name )  {   eddsa named curve spec ed25519 =  eddsa named curve table . get by name ( "ed25519 - sha - 512" )  ;   curve curve = ed25519 . get curve (  )  ;   field field = curve . get field (  )  ;   group element[] dbl precmp = new  group element[8] ;   buffered reader file = null ;  int row = 0 ;  try  {   input stream is =  precomputation test vectors . class . get resource as stream ( file name )  ;  if  ( is  =  =  null )  throw new io exception ( " resource not found: "  +  file name )  ;  file = new  buffered reader ( new  input stream reader ( is )  )  ;   string line ;  while  (  ( line = file . read line (  )  )   !  =  null )   {  if  ( line . equals ( "  }  " )  )   {  row +  = 1 ;   }  else if  ( line . starts with ( "  {  " )  )   {   string ypx str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element ypx = field . from byte array (  utils . hex to bytes ( ypx str )  )  ;  line = file . read line (  )  ;   string ymx str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element ymx = field . from byte array (  utils . hex to bytes ( ymx str )  )  ;  line = file . read line (  )  ;   string xy2d str = line . substring ( 4 line . last index of ( ' ' )  )  ;   field element xy2d = field . from byte array (  utils . hex to bytes ( xy2d str )  )  ;  dbl precmp[row] =  group element . precomp ( curve ypx ymx xy2d )  ;   }   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }  finally  {  if  ( file  !  =  null )  try  {  file . close (  )  ;   }  catch  (  io exception e )   {   }   }  return dbl precmp ;   }  
public static  integer   (  integer u  integer v )  {  return u  +  v ;   }  
@ override public  string   (  )  {  return resource url . to string (  )  ;   }  
protected  string   (  )  {  return sql ;   }  
public void   (  msn messenger messenger )  {   log . debug ( "msn:  login completed for "  +  messenger . get owner (  )  . get email (  )  )  ;  get session (  )  . set login status (  transport login status . logged   in )  ;   }  
@ test public void   (  )  {   single . error ( new  test exception ( " main" )  )  . on error resume next (  single . error ( new  test exception ( " resume" )  )  )  . test (  )  . assert failure and message (  test exception . class " resume" )  ;   } 
public  string   (  )  {  return info ;   }  
private void   (  )  {  synchronized  (    lock13 )   {  if  (    key generator  =  =  null )     key generator = new  key generator ( this )  ;     key generator initialized = true ;   }   }  
public   (  charset charset )  {  encoder = charset . new decoder (  )  . on malformed input (  coding error action . replace )  . on unmappable character (  coding error action . replace )  ;   }  
@ test public void   (  )  {   observable <  string >  w =  observable . from iterable (  arrays . as list ( "one" "two" "three" )  )  ;   single <  list <  string >  >  observable = w . to list (  )  ;   single observer <  list <  string >  >  observer =
@ check return value @ scheduler support (  scheduler support . none )  @ suppress warnings ( "unchecked" )  public static  < t >  observable < t >    (  )  {  return  rx java plugins . on assembly (  (  observable < t >  )  observable never . instance ) 
public  collection <  agent session >    (  )  {  return  collections . unmodifiable collection ( session list . key set (  )  )  ;   }  
public int   (  )  {  return stage ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  throwable e )  {  d =  disposable helper . disposed ;  if  ( eager )   {   object resource = get and set ( this )  ;  if  ( resource  !  =  this )   {  try  {  disposer . accept (  ( r ) res
public void   (  )  {  mina . stop (  )  ;   }  
public int   (  )  {  return  ( longind )  ;   }  
@ test ( expected =  certificate exception . class )  public void   (  )  throws  exception  {  system under test . check client trusted ( expired int chain "rsa" )  ;   }  
public   (  )  {  super (  persistent data store . this .    context )  ;   }  
private void   (  )  {  try  {  final  class loader parent = find parent class loader (  )  ;   string lib dir string =  system . get property ( "openfire . lib . dir" )  ;   file lib dir ;  if  ( lib dir string  !  =  null )   {  lib dir = new  file ( lib dir string )  ;  if  (  ! lib dir . exists (  )  )   {   log . warn ( " lib directory "  +  lib dir string  +  " does not exist .   using default " +  default   lib   dir )  ;  lib dir = new  file ( default   lib   dir )  ;   }   }  else  {  lib dir = new  file ( default   lib   dir )  ;   }   string admin lib dir string =  system . get property ( "openfire home" )  ;  if  ( admin lib dir string  =  =  null )   {  admin lib dir string = default   admin   lib   dir ;   }  else  {  admin lib dir string = admin lib dir string  +  " / plugins / admin / webapp / web - inf / lib" ;   }   file admin lib dir = new  file ( admin lib dir string )  ;  if  (  ! admin lib dir . exists (  )  )   {   log . warn ( " admin  lib  directory "  +  admin lib dir string  +  " does not exist .   web admin console may not work . " )  ;   }   class loader loader = new  jive class loader ( parent lib dir )  ;   thread . current thread (  )  . set context class loader ( loader )  ;   class container class = loader . load class ( "org . jivesoftware . openfire . xmpp server" )  ;  container class . new instance (  )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  
@ test ( data provider = " vcf to interval list data" )  public void   ( final  file input file final boolean include filtered final int expected intervals size )  throws io exception  {  final  file output file =  file . create temp file ( "vcftointerval
public static void   (  spinner spinner  object value )  {  for  ( int i = 0  count = spinner . get count (  )  ;  i  <  count ;  i +  +  )   {   spinner option so =  (  spinner option ) spinner . get item at position ( i )  ;  if  ( so . value . equals ( value )  )   {  spinner . set selection ( i true )  ;  return ;   }   }   }  
@ override protected void   (  single observer <  ?  super  boolean >  observer )  {  source . subscribe ( new  is empty maybe observer < t >  ( observer )  )  ;   }  
@ override public boolean   (  )  {  return is initialized ;   }  
@ override public void   ( final short library id )  {  this . library id = library id ;   }  
public void   (  )  {   pop3 store .  pop3 folder .  uidl parser parser = m folder . new  uidl parser (  )  ;  boolean result ;  result = parser . parse single line ( null )  ;  assert false ( result )  ;  result = parser . parse single line ( "" )  ;  assert false ( result )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on error ( t )  ;   }  
public void   (  string rate )  {     inbound rate =  ( rate  !  =  null  ?  rate . trim (  )  : null )  ;   }  
public void   (  long blong field )  {  this . blong field = blong field ;   }  
public void   (  request request  server transaction server transaction )  throws  transaction does not exist exception   parse exception   sip exception  {   response response = message factory . create response (  response . busy   here request )  ;  try  {  server transaction . send response ( response )  ;   }  catch  (   invalid argument exception e )   {   logger . println ( " send busy: "  +  e . get message (  )  )  ;  throw new  sip exception ( " failed to send response: "  +  e . get message (  )  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . zip (  arrays . as list (  maybe . just ( 1 )   maybe .  <  integer > error ( new  test exception (  )  )  )  add string )  . test (  )  . assert failure (  test exception . class
private static void   (  profiled connection entry[] entries boolean sort by time int first int last )  {  if  ( first  >  =  last || entries . length  <  2 )   {  return ;   }  swap ( entries first  ( first  +  last )   /  2 )  ;  int index = first ;  for  ( int i = first  +  1 ;  i  <  =  last ;  i +  +  )   {  if  ( sort by time &&  (  ( entries[first] . total time  /  entries[first] . count )   <   ( entries[i] . total time  /  entries[i] . count )  )  )   {  swap ( entries  +  + index i )  ;   }  else if  (  ! sort by time && entries[first] . count  <  entries[i] . count )   {  swap ( entries  +  + index i )  ;   }   }  swap ( entries first index )  ;  quick sort ( entries sort by time first index  -  1 )  ;  quick sort ( entries sort by time index  +  1 last )  ;   }  
public static long   (  string subdomain  string name long default value )  {   string value = get property ( subdomain name )  ;  if  ( value  !  =  null )   {  try  {  return  long . parse long ( value )  ;   }  catch  (   number format exception nfe )   {   }   }  return default value ;   }  
public static void   (  context context long account id )  {  context . get content resolver (  )  . delete (  content uris . with appended id (  account . content   uri account id )  null null )  ;   }  
private double   (  )  {  return get font char width ( fonttag   legend )  ;   }  
public static void   (  account expect  account actual )  {  assert equals ( " m display name" expect . m display name actual . m display name )  ;  assert equals ( " m email address" expect . m email address actual . m email address )  ;  assert equals ( " m sync lookback" expect . m sync lookback actual . m sync lookback )  ;  assert equals ( " m sync interval" expect . m sync interval actual . m sync interval )  ;  assert equals ( " m flags" expect . m flags actual . m flags )  ;  assert equals ( " m sender name" expect . m sender name actual . m sender name )  ;  assert equals ( " m protocol version" expect . m protocol version actual . m protocol version )  ;  assert equals ( " m signature" expect . m signature actual . m signature )  ;  assert equals ( 0 actual . m policy key )  ;  assert null ( actual . m sync key )  ;  assert null ( actual . m security sync key )  ;   }  
@ override public synchronized boolean   (  )  throws io exception  {  final  byte buffer fresh buffer = new  cyclic byte buffer (  )  ;  final byte[] new digest = read ( fresh buffer )  ;  if  ( digest  =  =  null ||  ! new  byte array comparator ( diges
public void   (  )  {  workgroup manager start (  )  ;   }  
public static void   (  atomic reference <  subscription >  field  atomic long requested long n )  {   subscription s = field . get (  )  ;  if  ( s  !  =  null )   {  s . request ( n )  ;   }  else  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  s = field . get (  )  ;  if  ( s  !  =  null )   {  long r = requested . get and set ( 0l )  ;  if  ( r  !  =  0l )   {  s . request ( r )  ;   }   }   }   }   }  
@ test public void   (  )  {   function <  consumer <  object >   map <  integer  object >  >  evicting map factory = create evicting map factory synchronous only ( 1 )  ;   publish subject <  integer >  subject =  publish subject . create (  )  ;   test 
@ test public void   (  )  {   flowable <  string >  obs =  flowable . just ( "one" "two" "six" )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  obs . all ( new  predicate <  string >  (  )  {  @ override public
@ test public void   (  )  {   maybe . just ( 1 )  . flat map single element ( new  function <  integer  single source <  string >  >  (  )  {  @ override public  single source <  string >  apply (  final  integer integer )  throws  exception  {  if  ( in
public  media type   (  header value header value )  {   string media type with parameters stripped = header value . get value (  )  . split ( " ; " ) [0] ;   mime type media type =  mime type . get matching mime type ( media type with parameters stripped )  ;  if  (  mime type . unknown . equals ( media type )  )   {  media type =  mime type . guess media type from string ( media type with parameters stripped )  ;   }  return new  media type ( media type with parameters stripped media type header value . get parameters (  )  )  ;   }  
private  sip listener   (  event object event )  {   string sip call id = null ;  try  {   call id header call id header ;  if  ( event instanceof  request event )   {   request request =  (  (  request event ) event )  . get request (  )  ;  call id header =  (  call id header ) request . get header (  call id header . name )  ;   }  else if  ( event instanceof  response event )   {   response response =  (  (  response event ) event )  . get response (  )  ;  call id header =  (  call id header ) response . get header (  call id header . name )  ;   }  else  {   logger . error ( " invalid event object "  +  event )  ;  return null ;   }  sip call id = call id header . get call id (  )  ;  synchronized  ( sip listeners table )   {  return  (  sip listener ) sip listeners table . get ( sip call id )  ;   }   }  catch  (   null pointer exception e )   {  if  ( sip call id  =  =  null || "" . equals ( sip call id )  )   {   logger . exception ( "could not get sip  call id from incoming"  +  " message .   dropping message" e )  ;   }  throw e ;   }   }  
public  string   (  )  {  return  jive globals . get property ( header " web  sign -  in" )  ;   }  
public   (  string message  throwable cause )  {  super ( message cause )  ;   }  
public void   (  input stream in  output stream out )  {  json transform . transform ( in out )  ;   }  
static void   (  version version  bit array bits )  throws  writer exception  {  bits . append bits ( version . get version number (  )  6 )  ;  int bch code = calculatebch code ( version . get version number (  )  version   info   poly )  ;  bits . append bits ( bch code 12 )  ;  if  ( bits . get size (  )   !  =  18 )   {  throw new  writer exception ( "should not happen but we got: "  +  bits . get size (  )  )  ;   }   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
@ test public void   (  )  {  final int[] call =  { 0 }  ;   flowable . just ( 1 )  . do after terminate ( new  action (  )  {  @ override public void run (  )  throws  exception  {  call[0] +  +  ;   }   }   )  . test (  )  . assert result ( 1 )  ;  asse
void   (  merge inner observer inner  throwable t )  {  set . delete ( inner )  ;  if  (  ! delay errors )   {  s . cancel (  )  ;  set . dispose (  )  ;  if  ( error . add throwable ( t )  )   {  if  ( get and set ( 0 )   >  0 )   {  actual . on error ( error . terminate (  )  )  ;   }   }  else  {   rx java plugins . on error ( t )  ;   }   }  else  {  if  ( error . add throwable ( t )  )   {  if  ( decrement and get (  )   =  =  0 )   {  actual . on error ( error . terminate (  )  )  ;   }  else  {  if  ( max concurrency  !  =   integer . max   value )   {  s . request ( 1 )  ;   }   }   }  else  {   rx java plugins . on error ( t )  ;   }   }   }  
public  tile template read   (  )  {  return tile template read ;   }  
@ override public  user   (  string username  string password  string name  string email )  throws  user already exists exception  {  for  (  final  user provider provider : get user providers (  )  )   {  if  ( provider . is read only (  )  )   {  contin
public void   (  )  {   string builder buf = new  string builder ( 2048 )  ;  boolean comma = false ;  for  (   map .  entry <  string  tracker >  e :    tracker map . entry set (  )  )   {  if  ( comma )  buf . append ( ' ' )  ;  else comma = true ;   tracker t = e . get value (  )  ;  buf . append ( e . get key (  )  . replace ( " " "&#44 ; " )  )  . append ( ' ' )  . append ( t . announceurl . replace ( " " "&#44 ; " )  )  ;  if  ( t . baseurl  !  =  null )  buf . append ( ' = ' )  . append ( t . baseurl )  ;   }     config . set property ( prop   trackers buf . to string (  )  )  ;  save config (  )  ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
public int   (  string transport  string user )  {  int result = 0 ;   log . info ( " removing registration for: "  +  user  +  " from gateway: " +  transport )  ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( delete   session   entry )  ;  pstmt . set string ( 1 user )  ;  pstmt . set string ( 2 transport )  ;  result = pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return result ;   }  
@ override public void   (  )  throws io exception  {  super . close (  )  ;  if  (  ! read only )   {  sync (  )  ;   }   }  
public void   (  peer peer boolean interest )  {  if  ( interest )   {  if  ( uploaders . get (  )   <  allowed uploaders (  )  )   {  if  ( peer . is choking (  )  )   {  uploaders . increment and get (  )  ;  interested uploaders . increment and get (  )  ;  peer . set choking ( false )  ;  if  (    log . should log (  log . info )  )     log . info ( " unchoke: "  +  peer )  ;   }   }   }   }  
@ test public void   (  )  {  handle . register row mapper ( new  contact mapper (  )  )  ;  handle . create update ( "insert into contacts  ( id  name )  values  (  ?    ?  ) " )  . bind ( 0 3 )  . bind ( 1 " chuck" )  . execute (  )  ;   string name = h
  ( int index )  {  this . index = index ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;  final  publish processor <  integer >  boundary =  publish processor . create (  )  ;   callable <  flowable <  integer >  >  boundary func = new 
public static boolean   (  )  {  return  auth check filter . is servlet request authenticator instance of (  site minder servlet request authenticator . class )  ;   }  
public boolean   (  query request query req )  {   query listener listener = get query listener (  )  ;  if  ( listener  =  =  null )  return false ;   query response query res = new  query response (  )  ;   state variable ret var = new  state variable (  )  ;  ret var . set ( this )  ;  ret var . set value ( "" )  ;  ret var . set status ( u pnp status . invalid   var )  ;  if  ( listener . query control received ( ret var )   =  =  true )   {  query res . set response ( ret var )  ;   }  else  {  u pnp status upnp status = ret var . get status (  )  ;  query res . set fault response ( upnp status . get code (  )  upnp status . get description (  )  )  ;   }  query req . post ( query res )  ;  return true ;   }  
@ override public void   (  )  {  u c = collection ;  collection = null ;  actual . on next ( c )  ;  actual . on complete (  )  ;   }  
@ test public void   (  )  {   flowable <  ?  >  source =  flowable . just ( 1 2 )  ;   flowable <  boolean >  observable = source . cast (  boolean . class )  ;   subscriber <  boolean >  observer =  test helper . mock subscriber (  )  ;  observable . su
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . delay ( 1  time unit . seconds )  )  ;   test helper . check disposed (  publish processor . create (  )  . delay (  functions . just function (  flowable . 
public int   (  )  {  return    packets relayed . increment and get (  )  ;   }  
@ override public int   ( byte[] b int off int len )  throws io exception  {  return is . read ( b off len )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public void   ( i2cp message msg )  throws i2cp message exception  {  boolean success =    messages to write . offer ( msg )  ;  if  (  ! success )  throw new i2cp message exception ( "i2cp write to queue failed" )  ;   }  
public void   ( jid roomjid )  {  if  (  cluster manager . is senior cluster member (  )  )   {  conversation manager . room conversation ended ( roomjid new  date (  )  )  ;   }  else  {   conversation events queue events queue = conversation manager . get conversation events queue (  )  ;  events queue . add group chat event ( conversation manager . get room conversation key ( roomjid )   conversation event . room destroyed ( roomjid new  date (  )  )  )  ;   }   }  
public   (  flowable < t >  source  callable < u >  collection supplier )  {  super ( source )  ;  this . collection supplier = collection supplier ;   }  
public int   (  )  {  int bits = rng . next int (  )  ;  int max = max levels (  )  ;  for  ( int res = 0 ;  res  <  max ;  res +  +  )   {  if  ( bits % p  =  =  0 )  return res ;  bits /  = p ;   }  return max ;   }  
@ test ( data provider = "check samples crosscheck all data" )  public void   ( final  list <  file >  files1 final  list <  file >  files2 final int expected ret val final int number of samples1 final int number of samples2 boolean  expect all match )  t
public  string   (  )  {  return " < input type = \"checkbox\" class = \"optbox\" value = \"true\" name = \"update devsu3\" id = \"update devsu3\" "  +  get checked (  config update handler . prop   update   dev   su3 )   +  ' > ' ;   }  
public   (  )  {  super ( xmpp server . get instance (  )  . get pub sub module (  )  )  ;   }  
boolean   (  multicast subscription < t >  s )  {  for  (  ;   ;   )   {   multicast subscription < t > [] current = subscribers . get (  )  ;  if  ( current  =  =  terminated )   {  return false ;   }  int n = current . length ;  @ suppress warnings ( "unchecked" )   multicast subscription < t > [] next = new  multicast subscription[n  +  1] ;   system . arraycopy ( current 0 next 0 n )  ;  next[n] = s ;  if  ( subscribers . compare and set ( current next )  )   {  return true ;   }   }   }  
@ test public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   test observer <  integer >  to = pp1 . single element (  )  . take until
public  inet socket address   ( byte[] hash bytes )  {  final  inet socket address[] ring members = cluster view . members (  )  ;  if  ( ring members . length  <  =  0 )   {  if  (  ! cluster member warning )   {  log . info ( " no members to route to in datastore cluster .  .  .  unable to route this datastore request . " )  ;  cluster member warning = true ;   }  return null ;   }  cluster member warning = false ;  final int member address = new  big integer ( hash bytes )  . mod (  big integer . value of ( ring members . length )  )  . abs (  )  . int value (  )  ;  return ring members[member address] ;   }  
public static  account check settings fragment   ( int mode )  {  final  account check settings fragment f = new  account check settings fragment (  )  ;  final  bundle b = new  bundle ( 1 )  ;  b . put int ( args   mode mode )  ;  f . set arguments ( b )  ;  return f ;   }  
public  db properties   (  )  {  if  ( properties  =  =  null )   {  properties = new  jive live properties ( "jla queue prop" id )  ;   }  return properties ;   }  
public int   (  string transport )  {  int result = 0 ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   session   count   for   transport )  ;  pstmt . set string ( 1 transport )  ;   result set rs = pstmt . execute query (  )  ;  rs . next (  )  ;  result = rs . get int ( 1 )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return result ;   }  
public static final  string   (  string baseurl str  string relu rl str )  {  try  {  url baseurl = new url ( baseurl str )  ;   string url = baseurl . get protocol (  )   +  ": /  / "  +  baseurl . get host (  )  +  ":" +  baseurl . get port (  )  +  to relativeurl ( relu rl str )  ;  return url ;   }  catch  (   exception e )   {  return "" ;   }   }  
public void   (  out net message msg )  {  if  ( is dummy (  )  )   {   get bids job . fail (    context msg )  ;  return ;   }   get bids job . get bids (    context    manager msg )  ;   }  
@ override public void   (  )  {  ts1 . cancel (  )  ;   }  
@ test public void   (  )  {   observable <  string >  o =  observable . just ( "a" "b" "c" "d" )  ;  o . count (  )  . subscribe ( wo )  ;  verify ( wo times ( 1 )  )  . on success ( any long (  )  )  ;  verify ( wo )  . on success ( 4l )  ;  verify ( wo
@ test ( expected =  unsupported operation exception . class )  public void   (  )  {   observable . never (  )  . blocking latest (  )  . iterator (  )  . remove (  )  ;   }  
public byte[]   (  string transport type  string jid )  {  if  (  ! session locations . contains key ( jid  +  "@"  +  transport type )  )   {  return null ;   }  return session locations . get ( jid  +  "@"  +  transport type )  ;   }  
public void   (  message message )  throws  messaging exception  {  m one message[0] = message ;  set flags ( m one message permanent   flags true )  ;   }  
private  string   (  string key )  {   string d = get prop ( key )  ;  if  ( d . length (  )   >  0 )   {  try  {  d =  format date . format (  long . parse long ( d )  )  ;   }  catch  (   number format exception nfe )   {   }   }  return d ;   }  
private static  string   (  object o )  {  if  ( o  =  =  null )   {  return "" ;   }  else  {  if  ( o instanceof int[] )   {  return  arrays . to string (  ( int[] ) o )  ;   }  else  {  return  string . value of ( o )  ;   }   }   }  
public   ( i2p app context context )  {     context = context ;   }  
private static  state   (  session object session object boolean offline  state state  string host int pop3 port no  string user  string pass )  {  pop3 mail box mailbox = new pop3 mail box ( host pop3 port no user pass )  ;  i2p app context ctx = i2p app context . get global context (  )  ;   log log = session object . log ;   mail cache mc ;  try  {  mc = new  mail cache ( ctx mailbox dir   folder host pop3 port no user pass )  ;  session object . caches . put ( dir   folder mc )  ;   mail cache mc2 = new  mail cache ( ctx null dir   drafts host pop3 port no user pass )  ;  session object . caches . put ( dir   drafts mc2 )  ;  mc2 = new  mail cache ( ctx null dir   sent host pop3 port no user pass )  ;  session object . caches . put ( dir   sent mc2 )  ;  mc2 = new  mail cache ( ctx null dir   trash host pop3 port no user pass )  ;  session object . caches . put ( dir   trash mc2 )  ;  mc2 = new  mail cache ( ctx null dir   spam host pop3 port no user pass )  ;  session object . caches . put ( dir   spam mc2 )  ;   }  catch  (  io exception ioe )   {  log . error ( " error creating disk cache" ioe )  ;  session object . error +  = ioe . to string (  )   +  '\n' ;  return  state . auth ;   }  session object . mailbox = mailbox ;  session object . user = user ;  session object . pass = pass ;  session object . host = host ;  session object . really delete = false ;  boolean ok = mc . load from disk ( new  load waiter ( session object mc )  )  ;  if  ( offline )   {  if  ( log . should debug (  )  )  log . debug ( "offline mode" )  ;   }  else  {  session object . is fetching = true ;  if  (  ! mailbox . connect to server ( new  connect waiter ( session object )  )  )   {  session object . error +  =    t ( " cannot connect" )   +  '\n' ;  session object . is fetching = false ;   }   }  if  ( ok && mc . is loading (  )  )   {  try  {  session object . wait ( 5000 )  ;   }  catch  (   interrupted exception ie )   {  if  ( log . should debug (  )  )  log . debug ( " interrupted waiting for load" ie )  ;   }   }  state = mc . is loading (  )   ?   state . loading :  state . list ;  return state ;   }  
public  status   (  )  {  return status ;   }  
  (  switch map subscriber < t r >  parent long index int buffer size )  {  this . parent = parent ;  this . index = index ;  this . buffer size = buffer size ;   }  
public  sel datagram channel   (  )  {  return channelb ;   }  
@ after public void   (  )  {  handle . execute ( "drop table something" )  ;  handle . close (  )  ;   }  
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
@ override public synchronized  set <  group >    (  )  {   set <  group >  result = new  hash set <  >  (  )  ;  for  (   string group name : get known group names from keys (  )  )   {   group resolved =  group . resolve from ( group name )  ;  if  ( re
public int   (  )  {  return type ;   }  
private void   ( long ip )  {   long li =  long . value of ( ip )  ;  if  (  !  (    ip to country . contains key ( li )  ||    not found . contains ( li )  )  )   {  if  ( ip  >  =  0 && ip  <   ( 1l  <  <  32 )  )     pending search . add ( li )  ;  else    pendingi pv6 search . add ( li )  ;   }   }  
@ test public void   (  )  {  final byte[] first = new byte[] { 0x1 0x2 0x3 }   second = new byte[] { 0x1 0x2 0x3 }  ;  assert true ( " arrays that are identical should return true for asserting that they are equal" new  byte array comparator ( first seco
@ override public void   (  string text )  {   streamid streamid = session . get streamid (  )  ;   connection multiplexer session multiplexer session = multiplexer manager . get multiplexer session ( connection manager name streamid )  ;  if  ( multiplex
public void   (  )  {  parent . register ( this )  ;  try  {  sam handler handler = sam handler factory . createsam handler ( s i2cp props parent )  ;  if  ( handler  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( "sam handler has not been instantiated" )  ;  try  {  s . close (  )  ;   }  catch  (  io exception e )   {   }  return ;   }  handler . start handling (  )  ;   }  catch  (  sam exception e )   {  if  (    log . should log (  log . error )  )     log . error ( "sam error: "  +  e . get message (  )  e )  ;   string reply = "hello reply result = i2p   error message = \""  +  e . get message (  )   +  "\"\n" ;  sam handler . write string ( reply s )  ;  try  {  s . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  catch  (   exception ee )   {  try  {  s . close (  )  ;   }  catch  (  io exception ioe )   {   }     log . log (  log . crit " unexpected error handling sam connection" ee )  ;   }  finally  {  parent . unregister ( this )  ;   }   }  
public int   (  )  {  return message   type ;   }  
public  packet   (  )  {  return f ;   }  
public  data structure   (  )  {  return new  signing private key (  )  ;   }  
@ test public void   (  )  {  try  {  final  list <  throwable >  list = new  copy on write array list <  throwable >  (  )  ;   rx java plugins . set error handler ( add to list ( list )  )  ;  final  runtime exception e1 = new  runtime exception (  )  ;
@ override public  destination   (  string hostname  properties lookup options  properties stored options )  {   destination d = super . lookup ( hostname null null )  ;  if  ( d  !  =  null )  return d ;  if  ( hostname . length (  )   =  =  base32   has
@ test public void   (  )  {  final  atomic boolean r = new  atomic boolean (  )  ;   flowable .  <  string > error ( new  test exception (  )  )  . do on terminate ( new  action (  )  {  @ override public void run (  )  {  r . set ( true )  ;   }   }   )
@ test public void   (  )  throws  exception  {  final  atomic boolean subscribed = new  atomic boolean ( false )  ;  final  flowable <  integer >  observable =  flowable . just ( 4 )  . switch if empty (  flowable . just ( 2 )  . do on subscribe ( new  c
private   (  )  {  throw new  assertion error (  )  ;   }  
public int   (  )  {  return num responses compressed ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . range ( 1 5 )  . parallel (  )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  throws  exception  {  return new  a
@ suppress warnings ( "squid:s1244" )  private static  string   (  string accept encoding header )  {   collection <  string >  best encodings = new  hash set <  >  ( 3 )  ;  double bestq = 0 . 0 ;   collection <  string >  unacceptable encodings = new  h
private void   (  string name  string value )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( update   property )  ;  pstmt . set string ( 1 value )  ;  pstmt . set long ( 2 serviceid )  ;  pstmt . set string ( 3 name )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
protected static  < x extends  comparable <  ?  super x >  y > void   ( b skip span < x y >  bss  block file bf b skip list < x y >  bsl int span page  serializer < x >  key  serializer < y >  val )  throws io exception  {  if  ( bss . is killed )  throw new io exception ( " already killed !  !  "  +  bss )  ;  bss . page = span page ;  bss . key ser = key ;  bss . val ser = val ;  bsl . span hash . put (  integer . value of ( span page )  bss )  ;   block file . page seek ( bf . file span page )  ;  int magic = bf . file . read int (  )  ;  if  ( magic  !  =  magic )  throw new io exception ( " bad  skip span magic number 0x"  +   integer . to hex string ( magic )   +  " on page " +  span page )  ;  bss . overflow page = bf . file . read unsigned int (  )  ;  bss . prev page = bf . file . read unsigned int (  )  ;  bss . next page = bf . file . read unsigned int (  )  ;  bss . span size = bf . file . read unsigned short (  )  ;  bss . n keys = bf . file . read unsigned short (  )  ;  if  ( bss . span size  <  1 || bss . span size  >   skip span . max   size || bss . n keys  >  bss . span size )   {  bf . log . error ( " invalid span size "  +  bss . n keys  +  "  /  " +  bss . span size )  ;  bss . n keys = 0 ;  bss . span size = bf . span size ;   }   }  
@ test public void   (  )  {   async subscription as = new  async subscription (  )  ;   disposable r = mock (  disposable . class )  ;  assert true ( as . replace resource ( r )  )  ;   disposable r2 = mock (  disposable . class )  ;  as . replace resour
@ override public void   (  )  {  final  string protocol = m setup data . get account (  )  . get or create host auth recv ( m app context )  . m protocol ;  final  intent intent =  account credentials . get account credentials intent ( get activity (  ) 
public static  eddsa named curve spec   (  string name )  {  return curves . get ( name )  ;   }  
@ override public  hash   (  )  {  return get hash (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( 1 1 new  callable <  collection <  integer >  >  (  )  {  @ override public  collection <  integer >  call (  )  {  return null ;   }   }   )  . blocking subscr
public void   (  string bean )  {  this . bean = bean ;   }  
@ override public void   (  )  {  if  ( windows . decrement and get (  )   =  =  0 )   {   disposable helper . dispose ( upstream )  ;   }   }  
public static  signature   ( byte[] asn  sig type type )  throws  signature exception  {  if  ( type . get base algorithm (  )   =  =   sig algo . rsa || type . get base algorithm (  )   =  =   sig algo .  eddsa )  return new  signature ( type asn )  ;  return new  signature ( type asn1 to sig bytes ( asn type . get sig len (  )  )  )  ;   }  
@ test public void   (  )  {  convert file ( unmapped bam unmapped cram " . cram" )  ;   }  
private jid   (  string jid )  {  if  ( jid  !  =  null )   {  jid = jid . unescape node ( jid )  ;  if  ( jid . index of ( "@" )   =  =   - 1 || jid . index of ( " / " )   =  =   - 1 )  return null ;  try  {  return new jid ( jid )  ;   }  catch  (   exception e )   {  return null ;   }   }  else return null ;   }  
@ override public  string   (  )  {  return "0x"  +   long . to hex string ( from )   +  "  -  >  0x" +   long . to hex string ( to )  +  " : " +  cc ;   }  
@ test public void   (  )  {   deferred scalar subscription <  integer >  ds = new  deferred scalar subscription <  integer >  ( new  test subscriber <  integer >  (  )  )  ;  ds . value = 1 ;  ds . clear (  )  ;  assert equals (  deferred scalar subscrip
public   (  hash router  tunnel id id )  {     router = router ;     tunnel id = id ;   }  
@ test public void   (  )  {   blocking flowable iterator <  integer >  it = new  blocking flowable iterator <  integer >  ( 128 )  ;  assert false ( it . is disposed (  )  )  ;  it . dispose (  )  ;  assert true ( it . is disposed (  )  )  ;   }  
private static void   (  user new user  roster item other item  string current user )  throws  service exception  {  other item . get jid (  )  ;   user manager user manager =  user manager . get instance (  )  ;   string username = other item . get jid (  )  . get node (  )  ;  if  ( username  !  =  null && username . length (  )   >  0 && user manager . is registered user ( username )  && xmpp server . get instance (  )  . is local ( xmpp server . get instance (  )  . createjid ( current user null )  )  )   {  try  {   user other user = user manager . get user ( username )  ;   roster other roster = other user . get roster (  )  ;   roster item old user on others roster = other roster . get roster item ( xmpp server . get instance (  )  . createjid ( current user null )  )  ;  try  {  if  (  ! old user on others roster . is only shared (  )  )   {   roster item just created = other roster . create roster item ( xmpp server . get instance (  )  . createjid ( new user . get username (  )  null )  old user on others roster . get nickname (  )  old user on others roster . get groups (  )  true true )  ;  just created . set ask status ( old user on others roster . get ask status (  )  )  ;  just created . set recv status ( old user on others roster . get recv status (  )  )  ;  just created . set sub status ( old user on others roster . get sub status (  )  )  ;  other roster . update roster item ( just created )  ;   }   }  catch  (   user already exists exception e )   {  throw new  service exception ( " could not create roster item for user " new user . get username (  )   exception type . user   already   exists   exception  response .  status . conflict e )  ;   }  catch  (   shared group exception e )   {  throw new  service exception ( " could not create roster item  because it is a contact from a shared group" new user . get username (  )   exception type . user   already   exists   exception  response .  status . bad   request e )  ;   }   }  catch  (   user not found exception e )   {  throw new  service exception ( " could not create roster item for user "  +  new user . get username (  )   +  " because it is a contact from a shared group . " new user . get username (  )   exception type . user   not   found   exception  response .  status . not   found e )  ;   }   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  100 ;  i +  +  )   {  final  group element base point = ed25519 . getb (  )  ;  final  field element f =  math utils . get random field element (  )  ;  final  group element g = base point . scalar m
void   (  )  {   switch map inner observer o = inner . get and set ( inner   disposed )  ;  if  ( o  !  =  null && o  !  =  inner   disposed )   {  o . dispose (  )  ;   }   }  
  (  observer <  ?  super  observable < t >  >  actual  observable source < b >  open  function <  ?  super b  ?  extends  observable source < v >  >  close int buffer size )  {  super ( actual new  mpsc linked queue <  object >  (  )  )  ;  this . open = open ;  this . close = close ;  this . buffer size = buffer size ;  this . resources = new  composite disposable (  )  ;  this . ws = new  array list <  unicast subject < t >  >  (  )  ;  windows . lazy set ( 1 )  ;   }  
public void   (  string jid )  {  if  ( server items  =  =  null )   {  return ;   }   lock lock =  cache factory . get lock ( jid server items )  ;  try  {  lock . lock (  )  ;   clustered server item item = server items . get ( jid )  ;  if  ( item  !  =  null && item . nodes . remove ( xmpp server . get instance (  )  . get nodeid (  )  )  )   {  if  ( item . nodes . is empty (  )  )   {  server items . remove ( jid )  ;   }  else  {  server items . put ( jid item )  ;   }   }   }  finally  {  lock . unlock (  )  ;   }  local server items . remove ( jid )  ;   }  
@ test public void   (  )  {  final  field element f = new  ed25519 field element (  math utils . get field (  )  new int[10] )  ;   assert . assert that ( f . is non zero (  )   is equal . equal to ( false )  )  ;   }  
public void   (  string file )  {     config . set priv key file ( file )  ;   }  
@ test public void   (  )  {   runtime exception e = new  runtime exception ( " oops" )  ;   test subscriber <  object >  subscriber = new  test subscriber <  object >  (  )  ;   flowable . error ( e )  . subscribe ( subscriber )  ;  subscriber . assert e
@ override public void   (  )  {  s . dispose (  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  int database id =  - 1 ;   string name = "description" ;   string host = null ;   integer port = 123 ;   boolean restricted = false ;   string transport = "udp" ;   string t
public  string   ( int n indent level  string space )  {   string buffer indent string = new  string buffer ( n indent level * space . length (  )  )  ;  for  ( int n = 0 ;  n  <  n indent level ;  n +  +  )   {  indent string . append ( space )  ;   }  return indent string . to string (  )  ;   }  
public void   (  control point ctrlp )  {  this . control point = ctrlp ;   }  
public static long   (  type type )  {  switch  ( type )   {  case select: return total select time ;  case update: return total update time ;  case insert: return total insert time ;  case delete: return total delete time ;  default : throw new  illegal argument exception ( " invalid type" )  ;   }   }  
public  string   (  conference member member )  {  synchronized  ( whisper groups )   {   string s = "" ;  for  ( int i = 0 ;  i  <  whisper groups . size (  )  ;  i +  +  )   {   whisper group whisper group =  (  whisper group ) whisper groups . get ( i )  ;  if  ( whisper group . is member ( member )  )   {  s +  = " "  +  whisper group ;   }   }  return s ;   }   }  
@ override public void   (  )  {   subscription helper . cancel ( this )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  source =  replay subject . create with size ( 1 )  ;   observer <  integer >  o =  test helper . mock observer (  )  ;  source . on next ( 1 )  ;  source . on next ( 2 )  ;  source . subscribe ( 
private   ( i2p app context ctx  string output file  output stream output stream  string url ssl state state )  {  super ( ctx false null  - 1 0  - 1  - 1 output file output stream url true null null )  ;     proxy type =  proxy type . none ;  if  ( state  !  =  null && state . context  !  =  null )     ssl context = state . context ;  else    ssl context = initssl context (  )  ;  if  (    ssl context  =  =  null )     log . error ( " failed to initialize custom ssl context  using default context" )  ;   }  
public   (  )  {   jive globals . migrate property ( property   mapper   classname )  ;  final  string mapper class =  jive globals . get property ( property   mapper   classname )  ;  if  ( mapper class  =  =  null )   {  throw new  illegal state exception ( "a mapper must be specified via openfire . xml or the system properties . " )  ;   }  try  {  final  class c =  class utils . for name ( mapper class )  ;  mapper =  (  user property provider mapper ) c . new instance (  )  ;   }  catch  (   exception e )   {  throw new  illegal state exception ( " unable to create new instance of  user property provider mapper class: "  +  mapper class e )  ;   }   }  
public  hash   ( int hop )  {  return    peers[hop] ;   }  
@ override public void   (  presence type presence type  string verbose status )  {  final org . jivesoftware . smack . packet .  presence presence = new org . jivesoftware . smack . packet .  presence ( org . jivesoftware . smack . packet .  presence .  
public double   (  )  {  return output volume ;   }  
public void   (  form element form element )  {  hidden vars . add ( form element )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  flowable . empty (  )   flowable . combine latest ( new  flowable[0]  functions .  <  object[] > identity (  )  16 )  )  ;   }  
public void   (  )  {  this . fwd   error   rate = min   error ;  final long fwd bases = this . fwd   cxt   ref   bases  +  this . fwd   cxt   alt   bases ;  if  ( fwd bases  >  0 )   {  final double fwd err = this . fwd   cxt   alt   bases  /   ( double ) fwd bases ;  this . fwd   error   rate =  math . max ( min   error fwd err )  ;   }  this . rev   error   rate = min   error ;  final long rev bases = this . rev   cxt   ref   bases  +  this . rev   cxt   alt   bases ;  if  ( rev bases  >  0 )   {  final double rev err = this . rev   cxt   alt   bases  /   ( double ) rev bases ;  this . rev   error   rate =  math . max ( min   error rev err )  ;   }  this . error   rate =  math . max ( min   error this . fwd   error   rate  -  this . rev   error   rate )  ;  this . qscore =  quality util . get phred score from error probability ( this . error   rate )  ;   }  
@ override public  maybe <  ?  extends  integer >    (  integer v )  throws  exception  {  return  maybe . empty (  )  ;   }  
public static void   ( final  test result tr final  positional data pd final int index )  {   assert . assert equals ( tr . xq seq coord pd . getx coordinate (  )  "  at index "  +  index )  ;   assert . assert equals ( tr . yq seq coord pd . gety coordinate (  )  "  at index "  +  index )  ;   }  
@ override public  read ends for mark duplicates with barcodes   (  )  {  return new  read ends for mark duplicates with barcodes ( this )  ;   }  
public  conference   (  string phone no )  {   conference conf = null ;  if  ( conferences . contains key ( phone no )  )   {  conf = conferences . get ( phone no )  ;   }  else if  ( conf extensions . contains key ( phone no )  )   {  conf = conf extensions . get ( phone no )  ;   }  return conf ;   }  
public  nodeid   (  )  {  return nodeid ;   }  
synchronized long   (  )  {  return  (    received time  >  0  ?     context . clock (  )  . now (  )   -     received time : 0 )  ;   }  
@ override public  maybe <  ?  extends  integer >    (  integer v )  throws  exception  {  return  maybe . just ( v )  ;   }  
@ test public void   (  )  {   test subscriber <  grouped flowable <  integer  integer >  >  ts = new  test subscriber <  grouped flowable <  integer  integer >  >  ( 0l )  ;   flowable . from array ( 1 2 )  . group by ( new  function <  integer  integer 
@ test ( expected =  index out of bounds exception . class )  public void   (  )  {   flowable . from array ( 1 2 )  . element at (  - 1 0 )  ;   }  
  (  list iterator < e >  i )  {     i = i ;  while  (    i . has next (  )  )     i . next (  )  ;   }  
public boolean   (  )  {  return flash client ;   }  
@ override protected void   (  form field field )  throws  not acceptable exception  {  if  ( "pubsub#persist   items" . equals ( field . get variable (  )  )  )   {  persist published items = parse first value as boolean ( field true )  ;   }  else if  (
@ test public void   (  )  {   flowable . range ( 1 5 )  . merge with (  maybe .  <  integer > empty (  )  )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
public void   ( int port )  {   jive globals . set property ( "update . proxy . port"  integer . to string ( port )  )  ;   }  
@ test public void   (  )  throws io exception  jaxb exception   parser configuration exception  {   configuration resource cfg resource = mock (  configuration resource . class )  ;   byte array input stream cfg stream = new  byte array input stream ( cf
public  string   (  call participant cp  inet socket address isa )  {   string sdp = sdp manager . generate sdp ( cp " meeting central" isa )  ;   string s = "a = conference id:"  +  cp . get conference id (  )  ;  if  ( cp . get media preference (  )   !  =  null )   {  s +  = ":"  +  cp . get media preference (  )  ;  if  ( cp . get conference display name (  )   !  =  null )   {  s +  = ":"  +  cp . get conference display name (  )  ;   }   }  sdp +  = s  +  "\r\n" ;  if  ( cp . get remote call id (  )   !  =  null )   {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " setting call id in sdp to "  +  cp . get remote call id (  )  )  ;   }  sdp +  = "a = call id:"  +  cp . get remote call id (  )   +  "\r\n" ;   }  if  ( cp . is distributed bridge (  )  )   {  sdp +  = "a = user name: distributed bridge\r\n" ;  sdp +  = "a = distributed bridge\r\n" ;   }  sdp +  = "a = transmit media info ok\r\n" ;  return sdp ;   }  
@ override public boolean   (  data input in )  {  return false ;   }  
void   (  linked queue node < t >  node )  {  consumer node . lazy set ( node )  ;   }  
@ test public void   (  )  {   flowable <  string >  src =  flowable . empty (  )  ;  src . first ( "default" )  . to flowable (  )  . subscribe ( w )  ;  verify ( w times ( 1 )  )  . on next ( any string (  )  )  ;  verify ( w times ( 1 )  )  . on next (
@ test public void   (  )  {   test helper . assert bad request reported (  flowable . range long ( 1l 5l )  )  ;   test helper . assert bad request reported (  flowable . range long ( 1l 5l )  . filter (  functions . always true (  )  )  )  ;   }  
public  data structure   (  )  {  return new  message id (  )  ;   }  
default  this   (  template engine template engine )  {  return configure (  sql statements . class c  -  >  c . set template engine ( template engine )  )  ;   }  
public long   (  byte buffer[] srcs int offset int length )  {  throw new  unsupported operation exception (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . skip until ( null )  ;   }  
private void   ( long tunnel  hash peer )  {  if  (    log . should log (  log . info )  )     log . info ( tunnel  +  ":  peer "  +  peer . to base64 (  )  +  " did not reply to the tunnel join request" )  ;   }  
public void   ( final  plugin manager plugin manager final  file plugin directory )  {  if  ( plugin manager . is executed (  )  )   {  add interceptors (  )  ;   }  else  {  plugin manager . add plugin manager listener ( new  plugin manager listener (  )  {  public void plugins monitored (  )  {  plugin manager . remove plugin manager listener ( this )  ;  add interceptors (  )  ;   }   }   )  ;   }   }  
private void   (  result result )  {  if  (  ! result . equals ( this . result )  )  fire result changed ( this . result result )  ;  this . result = result ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   observable <  long >  source =  observable . interval ( 1  time unit . seconds scheduler )  . take ( 10 )  ;   iterable <  long >  iter = source . 
public   (  set < k >  delegate )  {  this . delegate = delegate ;   }  
private static final boolean   (  string signed file )  {  boolean is update = new  trusted update (  )  . is updated version (  core version . version new  file ( signed file )  )  ;  if  ( is update )   system . out . println ( " file version is newer than current version . " )  ;  else  system . out . println ( " file version is older than or equal to current version . " )  ;  return is update ;   }  
@ test public void   (  )  {   lease set subj = new  lease set (  )  ;  exception . expect (  index out of bounds exception . class )  ;  subj . get lease (  - 1 )  ;   }  
public   (  http servlet request request )  {  this . request = request ;   }  
public   ( final  file file )  {  bb iterator = m map backed iterator factory . get byte iterator ( header   size file )  ;  final  byte buffer header buf = bb iterator . get header bytes (  )  ;  for  ( int i = 0 ;  i  <  4 ;  i +  +  )   {  final byte b = header buf . get (  )  ;  if  ( b  !  =  0 )   {  throw new  picard exception ( " the first four bytes of a  filter  file should be 0 but byte "  +  i  +  " was " +  b +  " in file " +  file . get absolute path (  )  )  ;   }   }  version = header buf . get int (  )  ;  if  ( version  !  =  expected   version )   {  throw new  picard exception ( " expected version is "  +  expected   version  +  " but version found was " +  version +  " in file " +  file . get absolute path (  )  )  ;   }  num clusters =  unsigned type util . u int to long ( header buf . get int (  )  )  ;  bb iterator . assert total elements equal ( num clusters )  ;  current cluster = 0 ;   }  
@ override public void   (  )  {  u next ;  try  {  next =  object helper . require non null ( buffer supplier . call (  )  " the buffer supplier returned a null buffer" )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  dispos
public  string   (  )  {  return protocol ;   }  
@ override public  observable source <  integer >    (  observable <  integer >  v )  throws  exception  {  return v ;   }  
public  jpa member   (  string column label )  {   string column = column label . to lower case (  locale . root )  ;  return members . stream (  )  . filter ( member  -  >  column . equals ( member . get column name (  )  . to lower case (  locale . root )  )  )  . find first (  )  . or else ( null )  ;   }  
public  map <  string  string >    (  )  {  return logging context map ;   }  
@ override public void   ( long n )  {  if  (  ! requested . compare and set ( 0 n )  )   {  child . on error ( new  runtime exception ( " expected to receive request before on next but didn't" )  )  ;   }   }  
public void   (  )  {     alive = true ;  i2p thread t = new i2p thread ( this "udp outbound refiller" true )  ;  t . start (  )  ;   }  
@ test public void   (  )  {   flowable <  string >  w =  flowable . from iterable (  arrays . as list ( "one" "two" "three" )  )  ;   single <  list <  string >  >  observable = w . to list (  )  ;   single observer <  list <  string >  >  observer =  te
@ override public  single source <  integer >    (  integer v )  throws  exception  {  if  ( v  =  =  1 )   {  return ms ;   }  return  single . never (  )  ;   }  
public  string   (  )  {  return query string ;   }  
@ override public int   (  )  {  return this . start ;   }  
public void   (  string exception )  {  this . exception = exception ;   }  
private int   (  tunnel build reply message reply  tunnel creator config cfg int record num int hop )  {  if  (  build message generator . is blank ( cfg hop )  )   {  if  ( log . should log (  log . debug )  )  log . debug ( reply . get unique id (  )   +  ":  record "  +  record num +  " / " +  hop +  " is fake  so consider it valid .  .  . " )  ;  return 0 ;   }   encrypted build record rec = reply . get record ( record num )  ;  byte[] data = rec . get data (  )  ;  int start = cfg . get length (  )   -  1 ;  if  ( cfg . is inbound (  )  )  start -  -  ;  for  ( int j = start ;  j  >  =  hop ;  j -  -  )   {   hop config hop config = cfg . get config ( j )  ;   session key reply key = hop config . get reply key (  )  ;  byte replyiv[] = hop config . get replyiv (  )  ;  if  ( log . should log (  log . debug )  )   {  log . debug ( reply . get unique id (  )   +  ":  decrypting record "  +  record num +  " / " +  hop +  " / " +  j +  " with reply key " +  reply key . to base64 (  )  +  " / " +   base64 . encode ( replyiv )  +  ": " +  cfg )  ;  log . debug ( reply . get unique id (  )   +  ": before decrypt: "  +   base64 . encode ( data )  )  ;  log . debug ( reply . get unique id (  )   +  ":  full reply rec: sz = "  +  data . length +  " data = " +   base64 . encode ( data 0  tunnel build reply message . record   size )  )  ;   }  ctx . aes (  )  . decrypt ( data 0 data 0 reply key replyiv 0  tunnel build reply message . record   size )  ;  if  ( log . should log (  log . debug )  )  log . debug ( reply . get unique id (  )   +  ": after decrypt: "  +   base64 . encode ( data )  )  ;   }  byte[] h =  simple byte cache . acquire (  hash . hash   length )  ;  ctx . sha (  )  . calculate hash ( data  hash . hash   length  tunnel build reply message . record   size  -   hash . hash   length h 0 )  ;  boolean ok =  data helper . eq ( h 0 data 0  hash . hash   length )  ;  if  (  ! ok )   {  if  ( log . should log (  log . debug )  )  log . debug ( reply . get unique id (  )   +  ":  failed verification on "  +  record num +  " / " +  hop +  ": " +   base64 . encode ( h )  +  " calculated  " +   base64 . encode ( data 0  hash . hash   length )  +  " expected\n" +  " record: " +   base64 . encode ( data  hash . hash   length  tunnel build reply message . record   size  -   hash . hash   length )  )  ;   simple byte cache . release ( h )  ;  return  - 1 ;   }  else  {   simple byte cache . release ( h )  ;  int rv = data[ tunnel build reply message . record   size  -  1] & 0xff ;  if  ( log . should log (  log . debug )  )  log . debug ( reply . get unique id (  )   +  ":  verified: "  +  rv +  " for record " +  record num +  " / " +  hop )  ;  return rv ;   }   }  
@ override protected  per unit metric collector <  rna seq metrics  integer sam record >    ( final  string sample final  string library final  string read group )  {  return new  per unit rna seq metrics collector ( sample library read group ribosomal in
@ test public void   (  )  {   observable .  <  integer > just ( 1 )  . hide (  )  . concat map delay error ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   integer v )  t
  ( final  string library final  string context )  {  this . library = library ;  this . context = context ;   }  
private int   ( final  file file final  string regex )  {  int results = 0 ;  final  pattern pattern =  pattern . compile ( " . *"  +  regex  +  " . *" )  ;  try  ( final  line iterator impl li = new  line iterator impl ( new  ascii line reader ( io util . open file for reading ( file )  )  )  )  {  while  ( li . has next (  )  )   {  final  string line = li . next (  )  ;  if  ( pattern . matcher ( line )  . matches (  )  )   {  results +  +  ;   }   }   }  catch  (  final io exception e )   {  e . print stack trace (  )  ;   }  return results ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just (  notification . create on complete (  )  )  . dematerialize (  )  )  ;   }  
public  savepoint   (  string name )  throws sql exception  {  return connection . set savepoint ( name )  ;   }  
public void   (  input stream compressed stream )  throws io exception  {  len = 0 ;  inf . reset (  )  ;     complete = false ;     crc32 . reset (  )  ;     buf1[0] = 0x0 ;     extra byte input stream . reset (  )  ;     lookahead stream . initialize ( compressed stream )  ;  verify header (  )  ;   }  
@ test public void   (  )  {  check check return value support (  single . class )  ;   }  
@ override public byte[]   ( byte[] outgoing int offset int len )  throws  sasl exception  {  if  (  ! is complete (  )  )   {  throw new  illegal state exception ( " authentication exchange not completed . " )  ;   }  throw new  illegal state exception (
@ override public void   (  integer t )  {  try  {   thread . sleep ( 100 )  ;   }  catch  (   interrupted exception e )   {   }   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  void   (  )  {   switch map single observer < r >  current = inner . get and set (  (  switch map single observer ) inner   disposed )  ;  if  ( current  !  =  null && current  !  =  inner   disposed )
@ test public void   (  )  {   observable <  string >  source =  observable . empty (  )  ;   observable <  grouped observable <  integer  string >  >  grouped = source . group by ( length )  ;   map <  integer  collection <  string >  >  map = to map ( g
@ ignore ( "null value is not allowed" )  @ test public void   (  )  throws  exception  {   flowable <  string >  obs =  flowable . just (  (  string ) null )  ;   future <  string >  f = obs . to future (  )  ;  assert equals ( null f . get (  )  )  ;   
public long   (  )  {  return    context . clock (  )  . now (  )   -     created ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer
public  string   (  )  {  return delivery host ;   }  
@ xml element public boolean   (  )  {  return moderated ;   }  
public synchronized void   (  string nick  session record session )  throws  existing id exception  {  if  ( map . contains key ( nick )  )   {  throw new  existing id exception (  )  ;   }  session . create thread group ( "sam session "  +  nick )  ;  map . put ( nick session )  ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;  to . dispose (  )  ;   observable . just ( 1 )  . blocking subscribe ( to )  ;  to . assert empty (  )  ;   }  
public void   ( boolean use stun )  {  this . use stun = use stun ;   }  
public void   (  graphics g )  {  byte[] image data = get rrd graph info (  )  . get bytes (  )  ;   image icon image = new  image icon ( image data )  ;  image . paint icon ( null g 0 0 )  ;   }  
public  string   (  )  {   string builder rv = new  string builder ( 4 )  ;  char bw = get bandwidth class (  )  ;  rv . append ( bw )  ;  if  ( bw  =  =  capability   bw512 || bw  =  =  capability   bw   unlimited )  rv . append ( capability   bw256 )  ;  if  (    context . net db (  )  . floodfill enabled (  )  &&  !    context . get boolean property ( "router . hide floodfill participant" )  )  rv . append (  floodfill network database facade . capability   floodfill )  ;  if  (    context . get boolean property ( prop   hidden )  )  rv . append (  router info . capability   hidden )  ;  if  (    context . get boolean property ( prop   force   unreachable )  )   {  rv . append ( capability   unreachable )  ;  return rv . to string (  )  ;   }  switch  (    context . comm system (  )  . get status (  )  )   {  case ok: case ipv4   ok   ipv6   unknown: case ipv4   ok   ipv6   firewalled: case ipv4   firewalled   ipv6   ok: case ipv4   disabled   ipv6   ok: case ipv4   unknown   ipv6   ok: case ipv4   snat   ipv6   ok: rv . append ( capability   reachable )  ;  break ;  case different: case reject   unsolicited: case ipv4   disabled   ipv6   firewalled: rv . append ( capability   unreachable )  ;  break ;  case disconnected: case hosed: case unknown: case ipv4   unknown   ipv6   firewalled: case ipv4   disabled   ipv6   unknown: case ipv4   firewalled   ipv6   unknown: case ipv4   snat   ipv6   unknown: default : break ;   }  return rv . to string (  )  ;   }  
synchronized boolean   ( final  download request req )  {  final  email service proxy service =  email service utils . get service for account (  attachment service . this req . m account id )  ;  boolean already in progress = m downloads in progress . get ( req . m attachment id )   !  =  null ;  if  ( already in progress )   {  debug trace ( " this attachment #%d is already in progress" req . m attachment id )  ;  return false ;   }  try  {  start download ( service req )  ;   }  catch  (   remote exception e )   {  cancel download ( req )  ;   }  return true ;   }  
@ test public void   (  )  {   flowable . timer ( 100  time unit . milliseconds scheduler )  . subscribe ( observer )  ;  scheduler . advance time by ( 100  time unit . milliseconds )  ;  verify ( observer times ( 1 )  )  . on next ( 0l )  ;  verify ( obs
@ override public void   (  )  {  throw new  test exception ( "dispose" )  ;   }  
public long   (  )  {  return    current duplicates ;   }  
@ test public void   (  )  {   flowable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . just
public static void   (  string method  throwable e )  {   system . out . println (  ( method  !  =  null  ?  method : "" )   +  "  -  "  +   ( e  !  =  null  ?  e . to string (  )  : "" )  )  ;   }  
@ override public  completable source   (  maybe <  object >  m )  throws  exception  {  return m . ignore element (  )  ;   }  
public  editor   (  string key long value )  {  m temp values . put ( key value )  ;  return this ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   observable <  object >  f )  throws  exc
@ override public int   (  )  {  return source . parallelism (  )  ;   }  
@ override public  void   (  )  throws  exception  {  runner =  thread . current thread (  )  ;  try  {  task . run (  )  ;  set rest ( executor . submit ( this )  )  ;  runner = null ;   }  catch  (   throwable ex )   {  runner = null ;   rx java plugins
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . ignore elements (  )  )  ;   test helper . check disposed (  flowable . just ( 1 )  . ignore elements (  )  . to flowable (  )  )  ;   }  
@ override public void   (  )  {  clean up (  )  ;  session disconnected no reconnect ( null )  ;   }  
@ visible for testing protected static boolean   (  string str )  {  int len = str . length (  )  ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  char c = str . char at ( i )  ;  if  ( c  >  =  128 )  return false ;   }  return true ;   }  
@ test ( timeout = 5000 )  public void   (  )  throws  interrupted exception  {   completable c = normal . completable . delay ( 250  time unit . milliseconds )  ;  final  atomic boolean done = new  atomic boolean (  )  ;  final  atomic reference <  throw
@ test public void   (  )  throws  interrupted exception  {   test subscriber <  notification <  integer >  >  ts = new  test subscriber <  notification <  integer >  >  ( 0l )  ;   flowable . just ( 1 2 3 )  . materialize (  )  . subscribe on (  schedule
public void   (  writer out boolean debug )  throws io exception  {   string builder buf = new  string builder ( 4 * 1024 )  ;  if  ( debug )  buf . append ( " < p id = \"debugmode\" >  debug mode  -   sorted by hash distance  closest first <  / p > \n" )  ;   hash ourr key ;   set <  lease set >  leases ;   decimal format fmt ;  if  ( debug )   {  ourr key =    context . router hash (  )  ;  leases = new  tree set <  lease set >  ( new  lease set routing key comparator ( ourr key )  )  ;  fmt = new  decimal format ( "#0 . 00" )  ;   }  else  {  ourr key = null ;  leases = new  tree set <  lease set >  ( new  lease set comparator (  )  )  ;  fmt = null ;   }  leases . add all (    context . net db (  )  . get leases (  )  )  ;  int median count = 0 ;  int rap count = 0 ;   big integer median = null ;  int c = 0 ;   floodfill network database facade netdb =  (  floodfill network database facade )    context . net db (  )  ;  if  ( debug )   {  buf . append ( " < table id = \"leasesetdebug\" > \n" )  ;   }  else  {  buf . append ( " < table id = \"leasesetsummary\" > \n" )  ;   }  buf . append ( " < tr >  < th colspan = \"3\" >  leaseset  summary <  / th > " )  . append ( " < th >  < a href = \" / configadvanced\" title = \"" )  . append (    t ( " manually  configure  floodfill  participation" )  )  . append ( "\" > [" )  . append (    t ( " configure  floodfill  participation" )  )  . append ( "] <  / a >  <  / th >  <  / tr > \n" )  . append ( " < tr >  < td >  < b >  total  leasesets: <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( leases . size (  )  )  . append ( " <  / td >  <  / tr > \n" )  ;  if  ( debug )   {  buf . append ( " < tr >  < td >  < b >  published  ( rap )   leasesets: <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( netdb . get known lease sets (  )  )  . append ( " <  / td >  <  / tr > \n" )  . append ( " < tr >  < td >  < b >  mod  data: <  / b >  <  / td >  < td > " )  . append (  data helper . getutf8 (    context . router key generator (  )  . get mod data (  )  )  )  . append ( " <  / td > " )  . append ( " < td >  < b >  last  changed: <  / b >  <  / td >  < td > " )  . append ( new  date (    context . router key generator (  )  . get last changed (  )  )  )  . append ( " <  / td >  <  / tr > \n" )  . append ( " < tr >  < td >  < b >  next  mod  data: <  / b >  <  / td >  < td > " )  . append (  data helper . getutf8 (    context . router key generator (  )  . get next mod data (  )  )  )  . append ( " <  / td > " )  . append ( " < td >  < b >  change in: <  / b >  <  / td >  < td > " )  . append (  data helper . format duration (    context . router key generator (  )  . get time till midnight (  )  )  )  . append ( " <  / td >  <  / tr > \n" )  ;   }  int ff =    context . peer manager (  )  . get peers by capability (  floodfill network database facade . capability   floodfill )  . size (  )  ;  buf . append ( " < tr >  < td >  < b >  known  floodfills: <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( ff )  . append ( " <  / td >  <  / tr > \n" )  . append ( " < tr >  < td >  < b >  currently  floodfill ?  <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( netdb . floodfill enabled (  )   ?  "yes" : "no" )  . append ( " <  / td >  <  / tr > \n" )  ;  buf . append ( " <  / table > \n" )  ;  if  ( leases . is empty (  )  )   {   }  else  {  if  ( debug )   {  for  (   lease set ls : leases )   {  if  ( ls . get received as published (  )  )  rap count +  +  ;   }  median count = rap count  /  2 ;   }  boolean link susi =  web app starter . is web app running ( "susidns" )  ;  long now =    context . clock (  )  . now (  )  ;  buf . append ( " < div class = \"leasesets   container\" > " )  ;  for  (   lease set ls : leases )   {   destination dest = ls . get destination (  )  ;   hash key = dest . calculate hash (  )  ;  buf . append ( " < table class = \"leaseset\" > \n" )  . append ( " < tr >  < th >  < b > " )  . append (    t ( " lease set" )  )  . append ( ": <  / b > &nbsp ;  < code > " )  . append ( key . to base64 (  )  )  . append ( " <  / code > " )  ;  if  (    context . key ring (  )  . get ( key )   !  =  null )  buf . append ( "  ( " )  . append (    t ( " encrypted" )  )  . append ( ' ) ' )  ;  buf . append ( " <  / th > " )  ;  if  (    context . client manager (  )  . is local ( dest )  )   {  buf . append ( " < th >  < a href = \"tunnels#"  +  key . to base64 (  )  . substring ( 0 4 )   +  "\" > " +     t ( " local" )  +  " <  / a >  " )  ;  boolean unpublished =  !    context . client manager (  )  . should publish lease set ( key )  ;  if  ( unpublished )  buf . append ( " < b > " )  . append (    t ( " unpublished" )  )  . append ( " <  / b >  " )  ;  buf . append ( " < b > " )  . append (    t ( " destination" )  )  . append ( ": <  / b >  " )  ;   tunnel pool settings in =    context . tunnel manager (  )  . get inbound settings ( key )  ;  if  ( in  !  =  null && in . get destination nickname (  )   !  =  null )  buf . append ( in . get destination nickname (  )  )  ;  else buf . append ( dest . to base64 (  )  . substring ( 0 6 )  )  ;  buf . append ( " <  / th >  <  / tr > \n < tr >  < td" )  ;   string host = null ;  if  (  ! unpublished )   {  host =    context . naming service (  )  . reverse lookup ( dest )  ;   }  if  ( unpublished || host  !  =  null ||  ! link susi )   {  buf . append ( " colspan = \"2\"" )  ;   }  buf . append ( " > " )  ;   string b32 = dest . to base32 (  )  ;  buf . append ( " < a href = \"http: /  / " )  . append ( b32 )  . append ( "\" > " )  . append ( b32 )  . append ( " <  / a >  <  / td > " )  ;  if  ( link susi &&  ! unpublished )   {  if  ( host  =  =  null )   {  buf . append ( " < td class = \"addtobook\" colspan = \"2\" > " )  . append ( " < a title = \"" )  . append (    t ( " add to addressbook" )  )  . append ( "\" href = \" / susidns / addressbook . jsp ? book = private&amp ; destination = " )  . append ( dest . to base64 (  )  )  . append ( "#add\" > " )  . append (    t ( " add to local addressbook" )  )  . append ( " <  / a >  <  / td > " )  ;   }   }   }  else  {  buf . append ( " < th >  < b > " )  . append (    t ( " destination" )  )  . append ( ": <  / b >  " )  ;   string host =    context . naming service (  )  . reverse lookup ( dest )  ;  if  ( host  !  =  null )   {  buf . append ( " < a href = \"http: /  / " )  . append ( host )  . append ( " / \" > " )  . append ( host )  . append ( " <  / a >  <  / th > " )  ;   }  else  {   string b32 = dest . to base32 (  )  ;  buf . append ( " < code > " )  . append ( dest . to base64 (  )  . substring ( 0 6 )  )  . append ( " <  / code >  <  / th > " )  . append ( " <  / tr > \n < tr >  < td" )  ;  if  (  ! link susi )  buf . append ( " colspan = \"2\"" )  ;  buf . append ( " >  < a href = \"http: /  / " )  . append ( b32 )  . append ( "\" > " )  . append ( b32 )  . append ( " <  / a >  <  / td > \n" )  ;  if  ( link susi )   {  buf . append ( " < td class = \"addtobook\" >  < a title = \"" )  . append (    t ( " add to addressbook" )  )  . append ( "\" href = \" / susidns / addressbook . jsp ? book = private&amp ; destination = " )  . append ( dest . to base64 (  )  )  . append ( "#add\" > " )  . append (    t ( " add to local addressbook" )  )  . append ( " <  / a >  <  / td > " )  ;   }   }   }  buf . append ( " <  / tr > \n < tr >  < td colspan = \"2\" > \n" )  ;  long exp = ls . get latest lease date (  )   -  now ;  if  ( exp  >  0 )  buf . append ( " < b > " )  . append (    t ( " expires in  { 0 } "  data helper . format duration2 ( exp )  )  )  . append ( " <  / b > " )  ;  else buf . append ( " < b > " )  . append (    t ( " expired  { 0 }  ago"  data helper . format duration2 ( 0  -  exp )  )  )  . append ( " <  / b > " )  ;  buf . append ( " <  / td >  <  / tr > \n" )  ;  if  ( debug )   {  buf . append ( " < tr >  < td colspan = \"2\" > " )  ;  buf . append ( " < b > rap ?  <  / b >  " )  . append ( ls . get received as published (  )  )  ;  buf . append ( "&nbsp ; &nbsp ;  < b > rar ?  <  / b >  " )  . append ( ls . get received as reply (  )  )  ;   big integer dist =  hash distance . get distance ( ourr key ls . get routing key (  )  )  ;  if  ( ls . get received as published (  )  )   {  if  ( c +  +   =  =  median count )  median = dist ;   }  buf . append ( "&nbsp ; &nbsp ;  < b >  distance:  <  / b > " )  . append ( fmt . format ( bi log2 ( dist )  )  )  ;  buf . append ( " <  / td >  <  / tr > \n < tr >  < td colspan = \"2\" > " )  ;  buf . append ( " < b >  signature type: <  / b >  " )  . append ( dest . get signing public key (  )  . get type (  )  )  ;  buf . append ( "&nbsp ; &nbsp ;  < b >  encryption  key: <  / b >  " )  . append ( ls . get encryption key (  )  . to base64 (  )  . substring ( 0 20 )  )  . append ( "&hellip ; " )  ;  buf . append ( " <  / td >  <  / tr > \n < tr >  < td colspan = \"2\" > " )  ;  buf . append ( " < b >  routing  key: <  / b >  " )  . append ( ls . get routing key (  )  . to base64 (  )  )  ;  buf . append ( " <  / td >  <  / tr > " )  ;   }  buf . append ( " < tr >  < td colspan = \"2\" >  < ul class = \"netdb   leases\" > " )  ;  for  ( int i = 0 ;  i  <  ls . get lease count (  )  ;  i +  +  )   {   lease lease = ls . get lease ( i )  ;  buf . append ( " < li >  < b > " )  . append (    t ( " lease" )  )  . append ( ' ' )  . append ( i  +  1 )  . append ( ": <  / b >   < span class = \"netdb   gateway\" title = \"" )  . append (    t ( " gateway" )  )  . append ( "\" >  < img src = \"themes / console / images / info / gateway . png\" alt = \"" )  . append (    t ( " gateway" )  )  . append ( "\" >  <  / span >   < span class = \"tunnel   peer\" > " )  ;  buf . append (    context . comm system (  )  . render peerhtml ( lease . get gateway (  )  )  )  ;  buf . append ( " <  / span >   < span class = \"netdb   tunnel\" > " )  . append (    t ( " tunnel" )  )  . append ( "  < span class = \"tunnel   id\" > " )  . append ( lease . get tunnel id (  )  . get tunnel id (  )  )  . append ( " <  / span >  <  / span >  " )  ;  if  ( debug )   {  long exl = lease . get end date (  )  . get time (  )   -  now ;  if  ( exl  >  0 )  buf . append ( " < b class = \"netdb   expiry\" > " )  . append (    t ( " expires in  { 0 } "  data helper . format duration2 ( exl )  )  )  . append ( " <  / b > " )  ;  else buf . append ( " < b class = \"netdb   expiry\" > " )  . append (    t ( " expired  { 0 }  ago"  data helper . format duration2 ( 0  -  exl )  )  )  . append ( " <  / b > " )  ;   }  buf . append ( " <  / li > " )  ;   }  buf . append ( " <  / ul >  <  / td >  <  / tr > \n" )  ;  buf . append ( " <  / table > \n" )  ;  out . write ( buf . to string (  )  )  ;  buf . set length ( 0 )  ;   }  if  ( debug )   {  buf . append ( " < table id = \"leasesetdebug\" >  < tr >  < td >  < b >  network data  ( only valid if floodfill ) : <  / b >  <  / td >  < td colspan = \"3\" > " )  ;  if  ( median  !  =  null )   {  double log2 = bi log2 ( median )  ;  buf . append ( " <  / td >  <  / tr > " )  . append ( " < tr >  < td >  < b >  median distance  ( bits ) : <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( fmt . format ( log2 )  )  . append ( " <  / td >  <  / tr > \n" )  ;  int total =  ( int )  math . round (  math . pow ( 2 2  +  256  -  1  -  log2 )  )  ;  buf . append ( " < tr >  < td >  < b >  estimated total floodfills: <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( total )  . append ( " <  / td >  <  / tr > \n" )  ;  buf . append ( " < tr >  < td >  < b >  estimated total leasesets: <  / b >  <  / td >  < td colspan = \"3\" > " )  . append ( total * rap count  /  4 )  ;   }  else  {  buf . append ( " < i >  not floodfill or no data .  <  / i > " )  ;   }  buf . append ( " <  / td >  <  / tr >  <  / table > \n" )  ;   }  buf . append ( " <  / div > " )  ;   }  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;   }  
@ override public  string   (  destination dest  properties options )  {   string destkey = dest . to base64 (  )  ;   buffered reader in = null ;  get read lock (  )  ;  try  {  in = new  buffered reader ( new  input stream reader ( new  file input strea
@ override public void   (  )  {  collection . clear (  )  ;  super . clear (  )  ;   }  
public long[]   (  )  {  long[] times = new long[pixel count] ;  long span = t end  -  t start ;  for  ( int i = 0 ;  i  <  pixel count ;  i +  +  )   {  times[i] =  math . round ( t start  +   ( double )  ( span * i )   /   ( double )  ( pixel count  -  1 )  )  ;   }  return times ;   }  
private void   (  )  {  if  (  news helper . is any update in progress (  )  )   {  add form error (    t ( " plugin or update download already in progress . " )  )  ;  return ;   }  if  (  ! verify proxy (  )  )  return ;  add form notice (    t ( " updating all plugins" )  )  ;   plugin starter . update all (    context )  ;  try  {   thread . sleep ( 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  
private void   (  )  throws io exception  {  worker . fill rect ( 0 0 im . xgif im . ygif gdef . colors[color   back] )  ;  if  ( gdef . background image  !  =  null )   {  worker . load image ( gdef . background image )  ;   }  worker . fill rect ( im . xorigin im . yorigin  -  im . ysize im . xsize im . ysize gdef . colors[color   canvas] )  ;   }  
private void   (  )  throws io exception  sam exception  {   string line =    reader . read line (  )  ;     log . debug ( " read: "  +  line )  ;   properties props = sam utils . parse params ( line )  ;   string maj = props . get property ( sam utils . command )  ;   string min = props . get property ( sam utils . opcode )  ;  if  (  ( "stream" . equals ( maj )  )  &&  ( "connected" . equals ( min )  )  )   {   string dest = props . get property ( "destination" )  ;   string id = props . get property ( "id" )  ;  if  (  ( dest  =  =  null )  ||  ( id  =  =  null )  )   {     log . error ( " invalid stream connected line: ["  +  line  +  "]" )  ;  return ;   }  dest = dest . trim (  )  ;  id = id . trim (  )  ;     streams . put ( id dest )  ;   }  else if  (  ( "stream" . equals ( maj )  )  &&  ( "closed" . equals ( min )  )  )   {   string id = props . get property ( "id" )  ;  if  ( id  =  =  null )   {     log . error ( " invalid stream closed line: ["  +  line  +  "]" )  ;  return ;   }     streams . remove ( id )  ;   }  else if  (  ( "stream" . equals ( maj )  )  &&  ( "received" . equals ( min )  )  )   {   string id = props . get property ( "id" )  ;   string size = props . get property ( "size" )  ;  if  (  ( id  =  =  null )  ||  ( size  =  =  null )  )   {     log . error ( " invalid stream received line: ["  +  line  +  "]" )  ;  return ;   }  id = id . trim (  )  ;  size = size . trim (  )  ;  int payload size =  - 1 ;  try  {  payload size =  integer . parse int ( size )  ;   }  catch  (   number format exception nfe )   {     log . error ( " invalid size in message ["  +  size  +  "]" )  ;  return ;   }  char payload[] = new char[payload size] ;  int read =    reader . read ( payload )  ;  if  ( read  !  =  payload size )   {     log . error ( " incorrect size read  -  expected "  +  payload size  +  " got " +  read )  ;  return ;   }     log . info ( "\n =  =   received from the stream "  +  id  +  ": [" +  new  string ( payload )  +  "]" )  ;  synchronized  (    counter lock )   {     recv counter +  +  ;   }  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  else  {     log . error ( " received unsupported type ["  +  maj  +  " / " +  min +  "]" )  ;  return ;   }   }  
public  map <  string  list <  string >  >    (  )  {   map <  string  list <  string >  >  data = new  hash map <  >  (  )  ;  for  (   map <  string  list <  string >  >  stage data : stages data . values (  )  )   {  data . put all ( stage data )  ;   }  return data ;   }  
@ test public void   (  )  throws  user already exists exception  io exception  {   in exporter testobject = new  openfire exporter ( "server name" user manager roster item provider )  ;  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  user manager . creat
public synchronized long   (  )  {  return    last coalesce date ;   }  
public void   (  )  {  final  context c = m mock context ;   account a =  provider test utils . setup account ( "acct" true c )  ;   mailbox b1 =  provider test utils . setup mailbox ( "box1" a . m id true c  mailbox . type   mail )  ;   mailbox b2 =  provider test utils . setup mailbox ( "box2" a . m id true c  mailbox . type   mail )  ;   message m1 = create message ( c b1 false false )  ;   message m2 = create message ( c b2 false false )  ;  assert equals ( a . m id  message . get key column long ( c m1 . m id  message columns . account   key )  )  ;  assert equals ( a . m id  message . get key column long ( c m2 . m id  message columns . account   key )  )  ;  assert equals ( b1 . m id  message . get key column long ( c m1 . m id  message columns . mailbox   key )  )  ;  assert equals ( b2 . m id  message . get key column long ( c m2 . m id  message columns . mailbox   key )  )  ;   }  
@ override public boolean   (  object o )  {  return super . equals ( o )  &&  ( o instanceof  router identity )  ;   }  
public void   ( boolean secure )  {  this . secure = secure ;   }  
public  string   (  )  {  return from recording type ;   }  
private static  genotype concordance state codes   ( final  variant context ctx final  string sample final int min gq final int min dp )  {  if  ( ctx  =  =  null )  return missing   code ;  else if  ( ctx . is mixed (  )  )  return is   mixed   code ;  else if  ( ctx . is filtered (  )  )  return vc   filtered   code ;  else  {  final  genotype genotype = ctx . get genotype ( sample )  ;  if  ( genotype . is no call (  )  )  return no   call   code ;  else if  ( genotype . is filtered (  )  )  return gt   filtered   code ;  else if  (  ( genotype . getgq (  )   !  =   - 1 )  &&  ( genotype . getgq (  )   <  min gq )  )  return low   gq   code ;  else if  (  ( genotype . getdp (  )   !  =   - 1 )  &&  ( genotype . getdp (  )   <  min dp )  )  return low   dp   code ;  else if  (  ( genotype . is mixed (  )  )  )  return no   call   code ;   }  return null ;   }  
public static void   ( final  string[] args )  {  new  fix vcf header (  )  . instance main with exit ( args )  ;   }  
@ override public boolean   (  object obj )  {  if  ( obj instanceof  batching row )   {   batching row other =  (  batching row ) obj ;  return id  =  =  other . id &&  arrays . equals ( values other . values )  ;   }  return false ;   }  
public void   (  )  {  http socket http sock = new http socket ( sock )  ;  if  ( http sock . open (  )   =  =  false )  return ;  http request http req = new http request (  )  ;  http req . set socket ( http sock )  ;  while  ( http req . read (  )   =  =  true )   {  http server . perform request listener ( http req )  ;  if  ( http req . is keep alive (  )   =  =  false )  break ;   }  http sock . close (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . just ( 1 )  . safe subscribe ( new  safe subscriber <  integer >  ( ts )  )  ;  ts . assert result ( 1 )  ;   }  
public  list <  file >    ( final int starting tile )  {  return new  array list <  file >  ( this . tail map ( starting tile )  . values (  )  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  source1 =  publish processor . create (  )  ;   publish processor <  integer >  source2 =  publish processor . create (  )  ;   flowable <  integer >  m = source1 . join ( source2 just (  flow
private static int   ( long flags )  {  long v = flags & flag   mode ;  v >  >  >  = 5 ;  return  ( int ) v ;   }  
public  private key   (  )  {  return    decryption key ;   }  
public   (  class <  ?  >  sql object type  method method )  {  super ( sql object type method )  ;   }  
@ override public void   (  )  {  dr . direct . replace ( schedule direct ( dr )  )  ;   }  
public boolean   (  )  {  return patterns enabled ;   }  
@ override public void   (  )  {  try  {  start . await (  )  ;  serial disposable . update ( subscription )  ;   }  catch  (   interrupted exception e )   {  fail ( e . get message (  )  )  ;   }  finally  {  end . count down (  )  ;   }   }  
public int   (  )  {  return min connections ;   }  
public void   ( final t packet )  {   runnable r = new  runnable (  )  {  @ override public void run (  )  {  try  {  channel handler . process ( packet )  ;   }  catch  (   exception e )   {   log . error (  locale utils . get localized string ( "admin . error" )  e )  ;  try  {   session session =  session manager . get instance (  )  . get session ( packet . get from (  )  )  ;  if  ( session  !  =  null )   {   log . debug ( " closing session of ' {  } ':  {  } " packet . get from (  )  session )  ;  session . close (  )  ;   }   }  catch  (   exception e1 )   {   log . error ( " unexpected exception while trying to close session of ' {  } ' . " packet . get from (  )  e1 )  ;   }   }   }   }   ;  executor . execute ( r )  ;   }  
@ test public void   (  )  {   single . error ( new  test exception (  )  )  . subscribe (  functions . empty consumer (  )  )  ;   }  
public void   (  string rejection message )  {  this . rejection message = rejection message ;   }  
@ override public void   (  )  {  ts . on complete (  )  ;   }  
public  session config   (  )  {  return    session config ;   }  
public void   (  )  throws  messaging exception  {  final  mime message message = new  mime message (  )  ;  message . set message id ( " test -  message - id" )  ;  message . remove header ( " message - id" )  ;  final  email content .  message local message = new  email content .  message (  )  ;  local message . m message id = " test -  message - id -  second" ;  final boolean result =  legacy conversions . update message fields ( local message message 1 1 )  ;  assert true ( result )  ;  assert equals ( " test -  message - id -  second" local message . m message id )  ;   }  
@ override public void   (  )  {  s . dispose (  )  ;   }  
public void   (  string query string )  {  this . query string = query string ;   }  
public boolean   (  file pathname )  {   string file name = pathname . get name (  )  . to lower case (  )  ;  return  ( file name . equals ignore case ( "enterprise . jar" )  )  ;   }  
public void   (  string password )  {  this . password = password ;   }  
private   ( long flags )  {  m min password length =  ( int )  (  ( flags &  legacy policy set . password   length   mask )   >  >   legacy policy set . password   length   shift )  ;  m password mode =  ( int )  ( flags &  legacy policy set . password   mode   mask )  ;  m max password fails =  ( int )  (  ( flags &  legacy policy set . password   max   fails   mask )   >  >   legacy policy set . password   max   fails   shift )  ;  m max screen lock time =  ( int )  (  ( flags &  legacy policy set . screen   lock   time   mask )   >  >   legacy policy set . screen   lock   time   shift )  ;  m require remote wipe = 0  !  =   ( flags &  legacy policy set . require   remote   wipe )  ;  m password expiration days =  ( int )  (  ( flags &  legacy policy set . password   expiration   mask )   >  >   legacy policy set . password   expiration   shift )  ;  m password history =  ( int )  (  ( flags &  legacy policy set . password   history   mask )   >  >   legacy policy set . password   history   shift )  ;  m password complex chars =  ( int )  (  ( flags &  legacy policy set . password   complex   chars   mask )   >  >   legacy policy set . password   complex   chars   shift )  ;  m require encryption = 0  !  =   ( flags &  legacy policy set . require   encryption )  ;  m require encryption external = 0  !  =   ( flags &  legacy policy set . require   encryption   external )  ;   }  
@ override protected void   (  )  {     context . in net message pool (  )  . register handler job builder (  database lookup message . message   type new  floodfill database lookup message handler (    context this )  )  ;     context . in net message po
private void   ( final  file input final  file output final  file reference )  throws io exception  {  final  string[] args =  { "input = "  +  input "output = "  +  output "reference   sequence = "  +  reference "set   only   uq = true" }  ;   set nm md and uq tags set nm md and uq tags = new  set nm md and uq tags (  )  ;   assert . assert equals ( set nm md and uq tags . instance main ( args )  0 " fix did not succeed" )  ;   }  
@ override public void   (  )  {   system . out . println ( "on complete" )  ;  latch . count down (  )  ;   }  
private void   ( final  string test name final int[] first map qs final int[] second map qs final boolean include secondary final int expected first mapq final int expected second mapq )  throws  exception  {  final  file unmapped sam =  file . create temp file ( "unmapped . " " . sam" )  ;  unmapped sam . delete on exit (  )  ;  final sam file writer factory factory = new sam file writer factory (  )  ;  final sam file header header = new sam file header (  )  ;  header . set sort order ( sam file header .  sort order . queryname )  ;  final  string read name = "the read" ;  final sam record first unmapped read = new sam record ( header )  ;  first unmapped read . set read name ( read name )  ;  first unmapped read . set read string ( "acgtacgtacgtacgt" )  ;  first unmapped read . set base quality string ( "5555555555555555" )  ;  first unmapped read . set read unmapped flag ( true )  ;  first unmapped read . set mate unmapped flag ( true )  ;  first unmapped read . set read paired flag ( true )  ;  first unmapped read . set first of pair flag ( true )  ;  final sam record second unmapped read = new sam record ( header )  ;  second unmapped read . set read name ( read name )  ;  second unmapped read . set read string ( "tcgaacgttcgaactg" )  ;  second unmapped read . set base quality string ( "6666666666666666" )  ;  second unmapped read . set read unmapped flag ( true )  ;  second unmapped read . set mate unmapped flag ( true )  ;  second unmapped read . set read paired flag ( true )  ;  second unmapped read . set second of pair flag ( true )  ;  final sam file writer unmapped writer = factory . makesam writer ( header false unmapped sam )  ;  unmapped writer . add alignment ( first unmapped read )  ;  unmapped writer . add alignment ( second unmapped read )  ;  unmapped writer . close (  )  ;  final  file aligned sam =  file . create temp file ( "aligned . " " . sam" )  ;  aligned sam . delete on exit (  )  ;  final  string sequence = "chr1" ;  header . set sequence dictionary ( sam sequence dictionary extractor . extract dictionary ( sequence dict2 . to path (  )  )  )  ;  final sam file writer aligned writer = factory . makesam writer ( header false aligned sam )  ;  add alignments for best fragment mapq strategy ( aligned writer first unmapped read sequence first map qs )  ;  add alignments for best fragment mapq strategy ( aligned writer second unmapped read sequence second map qs )  ;  aligned writer . close (  )  ;  final  file output =  file . create temp file ( "test best fragment mapq strategy . "  +  test name " . sam" )  ;  output . delete on exit (  )  ;  do merge alignment ( unmapped sam  collections . singleton list ( aligned sam )  null null null null false true false 1 "0" "1 . 0" "align ! " "my aligner" true fasta output  sam pair util .  pair orientation . fr  merge bam alignment .  primary alignment strategy .  best end mapq null include secondary null null )  ;  final  sam reader reader =  sam reader factory . make default (  )  . open ( output )  ;  int num first records = 0 ;  int num second records = 0 ;  int first primary mapq =  - 1 ;  int second primary mapq =  - 1 ;  for  (  final sam record rec : reader )   {   assert . assert true ( rec . get read paired flag (  )  )  ;  if  ( rec . get first of pair flag (  )  )   +  + num first records ;  else if  ( rec . get second of pair flag (  )  )   +  + num second records ;  else  assert . fail ( "unpossible ! " )  ;  if  (  ! rec . get read unmapped flag (  )  &&  ! rec . get not primary alignment flag (  )  )   {  if  ( rec . get first of pair flag (  )  )   {   assert . assert equals ( first primary mapq  - 1 )  ;  first primary mapq = rec . get mapping quality (  )  ;   }  else  {   assert . assert equals ( second primary mapq  - 1 )  ;  second primary mapq = rec . get mapping quality (  )  ;   }   }  else if  ( rec . get not primary alignment flag (  )  )   {   assert . assert true ( rec . get mate unmapped flag (  )  )  ;   }   }  reader . close (  )  ;   assert . assert equals ( first primary mapq expected first mapq )  ;   assert . assert equals ( second primary mapq expected second mapq )  ;  if  (  ! include secondary )   {   assert . assert equals ( num first records 1 )  ;   assert . assert equals ( num second records 1 )  ;   }  else  {   assert . assert equals ( num first records  math . max ( 1 first map qs . length )  )  ;   assert . assert equals ( num second records  math . max ( 1 second map qs . length )  )  ;   }   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
public void   (  )  {  for  (   life cycle lc :    jettys )   {  if  ( lc . is running (  )  )   {  try  {  lc . stop (  )  ;   }  catch  (   exception e )   {  change state ( stopping e )  ;   }   }   }  if  (    context  !  =  null )   {   port mapper pm =    context . port mapper (  )  ;  if  (    port  >  0 && pm . get port (  port mapper . svc   eepsite )   =  =     port )   {     port = 0 ;  pm . unregister (  port mapper . svc   eepsite )  ;   }  if  (    ssl port  >  0 && pm . get port (  port mapper . svc   https   eepsite )   =  =     ssl port )   {     ssl port = 0 ;  pm . unregister (  port mapper . svc   https   eepsite )  ;   }   }  change state ( stopped )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  future <  ?  >  f = ps . single (  - 99 )  . to future (  )
@ test public void   (  )  {  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 1 )  ;  obs
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  )  {  return  rx java plugins . on assembly ( new  completable from single < t >  ( this )  )  ;   }  
@ override public void   (  observer <  ?  super  integer >  s )  {  s . on subscribe (  disposables . empty (  )  )  ;  s . on next ( 1 )  ;  s . on complete (  )  ;  s . on next ( 2 )  ;  s . on error ( new  test exception (  )  )  ;  s . on complete ( 
@ before public void   (  )  {  parent = mock (  input stream uri parameter resolver . class )  ;  resolver = new  input stream uri parameter resolver ( parent )  ;  input = mock (  input stream . class )  ;   }  
public boolean   (  )  {  if  ( initialized  =  =   - 1 )   {   presence presence = get presence (  )  ;  if  ( presence  !  =  null && presence . is available (  )  )   {  initialized = 1 ;   }  else  {   cluster task task = get remote session task (  remote session task .  operation . is initialized )  ;   object result = do synchronous cluster task ( task )  ;  initialized = result  !  =  null &&  (  boolean ) result  ?  1 : 0 ;   }   }  return initialized  =  =  1 ;   }  
void   ( double minval double maxval boolean force legend )  {  legend . enabled& =  ( force legend ||  ( value  >  =  minval && value  <  =  maxval )  )  ;   }  
@ override public void   (  object t )  {  throw ex ;   }  
@ test public void   (  )  throws  exception  {  mock columns ( " lo ngfield" )  ;  mock all nulls result (  )  ;   sample bean sample bean = mapper . map ( result set ctx )  ;  assert that ( sample bean . get long field (  )  )  . is null (  )  ;   }  
private void   ( final  file unmapped bam final  list <  file >  aligned bams final  list <  file >  read1 aligned bams final  list <  file >  read2 aligned bams final  integer read1 trim final  integer read2 trim final boolean align reads only final boolean clip adapters final boolean is bisulfite sequence final int max ins or dels final  string prog record id final  string prog group version final  string prog group command line final  string prog group name final boolean paired run final  file ref seq final  file output final  sam pair util .  pair orientation expected orientation final  merge bam alignment .  primary alignment strategy primary alignment strategy final  string attributes to retain final  boolean include secondary final  boolean unmap contaminant reads final sam file header .  sort order sort order final  abstract alignment merger .  unmapping read strategy unmapping read strategy )  {  final  list <  string >  tags to rc = new  array list <  >  ( sam record . tags   to   reverse   complement )  ;  final  list <  string >  tags to rev = new  array list <  >  ( sam record . tags   to   reverse )  ;  tags to rc . add ( "ab" )  ;  tags to rev . add all (  arrays . as list ( "aa" "ac" "as" "ai" "af" )  )  ;  final  list <  string >  args = new  array list <  >  (  arrays . as list ( "unmapped   bam = "  +  unmapped bam . get absolute path (  )  "aligned   reads   only = "  +  align reads only "clip   adapters = "  +  clip adapters "is   bisulfite   sequence = "  +  is bisulfite sequence "max   insertions   or   deletions = "  +  max ins or dels "add   pg   tag   to   reads = true" )  )  ;  if  ( aligned bams  !  =  null )   {  for  (  final  file aligned bam : aligned bams )   {  args . add ( "aligned   bam = "  +  aligned bam . get absolute path (  )  )  ;   }   }  if  ( read1 aligned bams  !  =  null )   {  for  (  final  file aligned bam : read1 aligned bams )   {  args . add ( "read1   aligned   bam = "  +  aligned bam . get absolute path (  )  )  ;   }   }  if  ( read2 aligned bams  !  =  null )   {  for  (  final  file aligned bam : read2 aligned bams )   {  args . add ( "read2   aligned   bam = "  +  aligned bam . get absolute path (  )  )  ;   }   }  if  ( read1 trim  !  =  null )   {  args . add ( "read1   trim = "  +  read1 trim )  ;   }  if  ( read2 trim  !  =  null )   {  args . add ( "read2   trim = "  +  read2 trim )  ;   }  if  ( prog record id  !  =  null )   {  args . add ( "program   record   id = "  +  prog record id )  ;   }  if  ( prog group version  !  =  null )   {  args . add ( "program   group   version = "  +  prog group version )  ;   }  if  ( prog group command line  !  =  null )   {  args . add ( "program   group   command   line = "  +  prog group command line )  ;   }  if  ( prog group name  !  =  null )   {  args . add ( "program   group   name = "  +  prog group name )  ;   }  args . add ( "paired   run = "  +  paired run )  ;  args . add ( "reference   sequence = "  +  ref seq . get absolute path (  )  )  ;  args . add ( "output = "  +  output . get absolute path (  )  )  ;  if  ( expected orientation  !  =  null )   {  args . add ( "expected   orientations = "  +  expected orientation )  ;   }  if  ( primary alignment strategy  !  =  null )   {  args . add ( "primary   alignment   strategy = "  +  primary alignment strategy )  ;   }  if  ( attributes to retain  !  =  null )   {  args . add ( "attributes   to   retain = "  +  attributes to retain )  ;   }  for  (  final  string t : tags to rc )   {  args . add ( "attributes   to   reverse   complement = "  +  t )  ;   }  for  (  final  string t : tags to rev )   {  args . add ( "attributes   to   reverse = "  +  t )  ;   }  if  ( include secondary  !  =  null )   {  args . add ( "include   secondary   alignments = "  +  include secondary )  ;   }  if  ( unmap contaminant reads  !  =  null )   {  args . add ( "unmap   contaminant   reads = "  +  unmap contaminant reads )  ;   }  if  ( unmapping read strategy  !  =  null )   {  args . add ( "unmapped   read   strategy = "  +  unmapping read strategy )  ;   }  if  ( sort order  !  =  null )   {  args . add ( "sort   order = "  +  sort order . name (  )  )  ;   }   assert . assert equals ( run picard command line ( args )  0 " merge did not succeed" )  ;   }  
public  storage   (  )  {  return storage ;   }  
public static  session event   (  session session )  {  return new  session event ( session session   connect null )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   new  function <  object  publisher <  object >  >  (  )  {  
@ override public void   ( jid route  routable channel handler destination )  {   domain pair pair = new  domain pair ( "" route . get domain (  )  )  ;   string address = route . get domain (  )  ;  local routing table . add route ( pair destination )  ;
@ test public void   (  )  {   bi function <  string  integer  string >  combine latest function = get concat string integer combine latest function (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;   observable <  string >  
  (  subscriber <  ?  super t >  child  cache state < t >  state )  {  this . child = child ;  this . state = state ;  this . requested = new  atomic long (  )  ;   }  
public static  http bind manager   (  )  {  return instance ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . merge with (  completable . complete (  )  )  . take ( 3 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
@ override public  string   (  )  {  return  filter sam reads . class . get simple name (  )  ;   }  
public   ( @ non null  iterable <  ?  extends  throwable >  errors )  {   set <  throwable >  de duped exceptions = new  linked hash set <  throwable >  (  )  ;   list <  throwable >  local exceptions = new  array list <  throwable >  (  )  ;  if  ( errors  !  =  null )   {  for  (   throwable ex : errors )   {  if  ( ex instanceof  composite exception )   {  de duped exceptions . add all (  (  (  composite exception ) ex )  . get exceptions (  )  )  ;   }  else if  ( ex  !  =  null )   {  de duped exceptions . add ( ex )  ;   }  else  {  de duped exceptions . add ( new  null pointer exception ( " throwable was null ! " )  )  ;   }   }   }  else  {  de duped exceptions . add ( new  null pointer exception ( "errors was null" )  )  ;   }  if  ( de duped exceptions . is empty (  )  )   {  throw new  illegal argument exception ( "errors is empty" )  ;   }  local exceptions . add all ( de duped exceptions )  ;  this . exceptions =  collections . unmodifiable list ( local exceptions )  ;  this . message = exceptions . size (  )   +  " exceptions occurred .  " ;   }  
@ test public void   (  )  {   flowable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe .  <  
@ test public void   (  )  {   flowable . from array ( 4 3 2 1 )  . parallel ( 2 )  . sorted ( new  comparator <  integer >  (  )  {  @ override public int compare (   integer o1   integer o2 )  {  if  ( o1  =  =  4 && o2  =  =  3 )   {  throw new  test e
@ override public synchronized boolean   (  object obj )  {  if  (  ( obj  =  =  null )  ||  !  ( obj instanceof  rate )  )  return false ;  if  ( obj  =  =  this )  return true ;   rate r =  (  rate ) obj ;  if  (    period  !  =  r . get period (  )  ||
public  string   (  )  {  return long distance prefix ;   }  
@ override public final void   (  )  {   object o = enter transform (  notification lite . complete (  )  )  ;   node n = new  node ( o )  ;  add last ( n )  ;  truncate final (  )  ;   }  
@ test public void   (  )  throws  exception  {  h . execute ( "insert into something  ( id  name )  values  (  ?    ?  ) " 1 "hello" )  ;  h . execute ( "insert into something  ( id  name )  values  (  ?    ?  ) " 2 "world" )  ;   list <  something >  rs
private  flowable <  string >    ( final  string[] values final long interval final  throwable e )  {  return  flowable . unsafe create ( new  publisher <  string >  (  )  {  @ override public void subscribe (  final  subscriber <  ?  super  string >  subscriber )  {  final  composite disposable parent subscription = new  composite disposable (  )  ;  subscriber . on subscribe ( new  subscription (  )  {  @ override public void request (  long n )  {   }  @ override public void cancel (  )  {  parent subscription . dispose (  )  ;   }   }   )  ;  long delay = interval ;  for  (  final  string value : values )   {  parent subscription . add ( inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  subscriber . on next ( value )  ;   }   }   delay  time unit . milliseconds )  )  ;  delay +  = interval ;   }  parent subscription . add ( inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  if  ( e  =  =  null )   {  subscriber . on complete (  )  ;   }  else  {  subscriber . on error ( e )  ;   }   }   }   delay  time unit . milliseconds )  )  ;   }   }   )  ;   }  
void   ( t value int index )  {  values[index] = value ;  if  ( decrement and get (  )   =  =  0 )   {  r v ;  try  {  v =  object helper . require non null ( zipper . apply ( values )  " the zipper returned a null value" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  actual . on error ( ex )  ;  return ;   }  actual . on success ( v )  ;   }   }  
@ test public void   (  )  {   composite disposable cd = new  composite disposable (  )  ;  cd . dispose (  )  ;   disposable d1 =  disposables . empty (  )  ;  assert false ( cd . add ( d1 )  )  ;  assert true ( d1 . is disposed (  )  )  ;  d1 =  disposa
public int   (  )  {  return    config . length ;   }  
@ test public void   (  )  {  final  atomic boolean completed = new  atomic boolean ( false )  ;   flowable . from iterable (  collections . empty list (  )  )  . subscribe ( new  default subscriber <  object >  (  )  {  @ override public void on start ( 
public  file transfer proxy   (  )  {  return  (  file transfer proxy ) modules . get (  file transfer proxy . class )  ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
void   (  packet packet )  {  if  (  ! packet queue . offer ( packet )  )   {  return error to sender ( packet )  ;   log . debug ( " error sending packet to domain ' {  } '  ( outbound queue full ) :  {  } " domain packet )  ;   }   }  
@ override public boolean   (  node node jid owner jid subscriber )  {  return true ;   }  
public   ( i2p app context context ntcp transport transport )  {     context = context ;     log =    context . log manager (  )  . get log ( ntcp send finisher . class )  ;     transport = transport ;   }  
@ test public void   (  )  {   single . from callable ( new  callable <  integer >  (  )  {  @ override public  integer call (  )  throws  exception  {  return null ;   }   }   )  . test (  )  . assert failure and message (  null pointer exception . class
public void   ( i2p session impl session )  {   string max = session . get options (  )  . get property ( prop   max   bw )  ;  if  ( max  !  =  null )   {  try  {  int i max =  integer . parse int ( max )  ;  if  ( i max  >  0 )     max bytes per second = 256  +   math . max ( min   rate typ   size *  (  ( i max  +  typ   size  -  1 )   /  typ   size )  )  ;  else    max bytes per second = 0 ;   }  catch  (   number format exception nfe )   {   }   }  if  (    log . should log (  log . debug )  )     log . debug ( " setting "  +     max bytes per second  +  " bps max" )  ;   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  on error next maybe observer < t >  ( observer resume function allow fatal )  )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
public  list <  peer >    (  )  {   peer coordinator coord = coordinator ;  if  ( coord  !  =  null )  return coord . peer list (  )  ;  return  collections . empty list (  )  ;   }  
public void   (  string resource )  {  this . resource = resource ;   }  
@ suppress warnings ( "unchecked" )  @ override public  publisher <  long >    ( long elements )  {  return  flowable . combine latest delay error (  arrays . as list (  flowable . just ( 1l )   flowable . from iterable ( iterate ( elements )  )  )  new  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic reference <  string >  name = new  atomic reference <  string >  (  )  ;   completable c =  completable . unsafe create ( new  completable source (  )  {  @ override public void subscribe (  
public void   ( final  hits for insert hits for insert )  {  if  ( hits for insert . num hits (  )   =  =  0 )  throw new  illegal argument exception ( " no alignments to pick from" )  ;  final  list <  integer >  earliest alignments = new  array list <  integer >  (  )  ;  int earliest mapped base =  integer . max   value ;  int best mapq =  - 1 ;  for  ( int i = 0 ;  i  <  hits for insert . num hits (  )  ;   +  + i )   {  final sam record rec = hits for insert . get fragment ( i )  ;  if  ( rec . get read unmapped flag (  )  )  continue ;  final int this first mapped base = get index of first aligned base ( rec )  ;  final int this mapq = rec . get mapping quality (  )  ;  if  ( this first mapped base  <  earliest mapped base ||  ( this first mapped base  =  =  earliest mapped base && this mapq  >  best mapq )  )   {  earliest alignments . clear (  )  ;  earliest alignments . add ( i )  ;  earliest mapped base = this first mapped base ;  best mapq = this mapq ;   }  else if  ( this first mapped base  =  =  earliest mapped base && this mapq  =  =  best mapq )   {  earliest alignments . add ( i )  ;   }   }  if  ( earliest alignments . size (  )   =  =  1 )   {  hits for insert . set primary alignment ( earliest alignments . get ( 0 )  )  ;   }  else  {  hits for insert . set primary alignment ( earliest alignments . get ( random . next int ( earliest alignments . size (  )  )  )  )  ;   }   }  
public   (  publisher <  ?  extends t > [] sources  iterable <  ?  extends  publisher <  ?  extends t >  >  sources iterable  function <  ?  super  object[]  ?  extends r >  zipper int buffer size boolean delay error )  {  this . sources = sources ;  this . sources iterable = sources iterable ;  this . zipper = zipper ;  this . buffer size = buffer size ;  this . delay error = delay error ;   }  
private boolean   (  packet packet jid userjid )  {  if  ( filter everything )   {  return true ;   }   class packet class = packet . get class (  )  ;  if  (  message . class . equals ( packet class )  )   {  return filter message ;   }  else if  (  presence . class . equals ( packet class )  )   {   presence .  type presence type =  (  (  presence ) packet )  . get type (  )  ;  if  ( presence type  =  =  null || presence type  =  =   presence .  type . unavailable )   {  jid to = packet . get to (  )  ;  boolean incoming = to  !  =  null && to . to barejid (  )  . equals ( userjid . to barejid (  )  )  ;  if  ( incoming )   {  return filter presence   in ;   }  else  {  return filter presence   out ;   }   }   }  else if  ( iq . class . equals ( packet class )  )   {  return filteriq ;   }  return false ;   }  
void   ( int width int height byte ci   pixels[] )  throws io exception  {  add frame ( new  index gif89 frame ( width height ci   pixels )  )  ;   }  
public static  hash set <  integer >    ( final sam file header header final  set <  string >  ignored sequence )  {  final  hash set <  integer >  ignored sequence indices = new  hash set <  integer >  (  )  ;  for  (  final  string sequence name : ignored sequence )   {  final sam sequence record sequence record = header . get sequence ( sequence name )  ;  if  ( sequence record  =  =  null )   {  throw new  picard exception ( " unrecognized sequence "  +  sequence name  +  " passed as argument to ignore   sequence" )  ;   }  ignored sequence indices . add ( sequence record . get sequence index (  )  )  ;   }  return ignored sequence indices ;   }  
@ test public void   (  )  {  test type ( new  generic type <  array <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  vector <  integer >  >  (  )  {   }   )  ;  test type ( new  generic type <  list <  integer >  >  (  )  {   }   )  
public static  string   (  string input int width  locale locale )  {  if  ( input  =  =  null )   {  return "" ;   }  else if  ( width  <  5 )   {  return input ;   }  else if  ( width  >  =  input . length (  )  )   {  return input ;   }  if  ( locale  =  =  null )   {  locale =  jive globals . get locale (  )  ;   }   string builder buf = new  string builder ( input )  ;  boolean end of line = false ;  int line start = 0 ;  for  ( int i = 0 ;  i  <  buf . length (  )  ;  i +  +  )   {  if  ( buf . char at ( i )   =  =  '\n' )   {  line start = i  +  1 ;  end of line = true ;   }  if  ( i  >  line start  +  width  -  1 )   {  if  (  ! end of line )   {  int limit = i  -  line start  -  1 ;   break iterator breaks =  break iterator . get line instance ( locale )  ;  breaks . set text ( buf . substring ( line start i )  )  ;  int end = breaks . last (  )  ;  if  ( end  =  =  limit  +  1 )   {  if  (  !  character . is whitespace ( buf . char at ( line start  +  end )  )  )   {  end = breaks . preceding ( end  -  1 )  ;   }   }  if  ( end  !  =   break iterator . done && end  =  =  limit  +  1 )   {  buf . replace ( line start  +  end line start  +  end  +  1 "\n" )  ;  line start = line start  +  end ;   }  else if  ( end  !  =   break iterator . done && end  !  =  0 )   {  buf . insert ( line start  +  end '\n' )  ;  line start = line start  +  end  +  1 ;   }  else  {  buf . insert ( i '\n' )  ;  line start = i  +  1 ;   }   }  else  {  buf . insert ( i '\n' )  ;  line start = i  +  1 ;  end of line = false ;   }   }   }  return buf . to string (  )  ;   }  
void   ( int index  throwable t )  {  done = true ;   subscription helper . cancel ( s )  ;  cancel all but ( index )  ;   half serializer . on error ( actual t this error )  ;   }  
  (  single observer <  ?  super  long >  actual )  {  this . actual = actual ;   }  
private static void   ( int size  binding binding  prepared statement statement  statement context context )  {  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  try  {   argument argument = binding . find for position ( i )  . or else ( null )  ;  if  ( argument  !  =  null )   {  argument . apply ( i  +  1 statement context )  ;   }   }  catch  (  sql exception e )   {  throw new  unable to execute statement exception ( " exception while binding positional param at  ( 0 based )  position "  +  i e context )  ;   }   }   }  
public   (  context activity  class klass )  {  super ( activity klass )  ;  set flags (  intent . flag   activity   forward   result )  ;   }  
public void   (  rtcp packet p )  throws io exception  {  if  ( rtcp datagram socket  =  =  null )   {  throw new io exception ( " rtcp socket send failed  socket closed" )  ;   }  rtcp datagram socket . send ( p . get datagram packet (  )  )  ;   }  
public  string   (  )  {  return  string utils . get time from long ( duration )  ;   }  
public synchronized long   (  )  {  return    received relay tag ;   }  
public static  string   (  )  {  return join confirmation key ;   }  
@ override public int   (  )  throws sql exception  {  return fetch   forward ;   }  
private static void   (  file directory  string extension boolean recursive  list <  string >  list )  throws io exception  {   file[] files = directory . list files (  )  ;  for  (   file file : files )   {  if  ( file . is directory (  )  && recursive )   {  traverse directory ( file extension recursive list )  ;   }  else if  ( file . is file (  )  && file . get name (  )  . ends with ( extension )  )   {  list . add ( file . get canonical path (  )  )  ;   }   }   }  
@ override protected void   (  )  {  if  ( lock )   {  lock reference . lock ( key )  ;  passed = true ;   }  else  {  lock reference . unlock ( key )  ;   }  lock =  ! lock ;   }  
public static boolean   ( int flags )  {  return  ( flags & ls   mask )   =  =  0 ;   }  
@ override public boolean   (  )  {  return socket . is web socket secure (  )  ;   }  
@ test public void   (  )  {   flowable <  string >  w =  flowable . from iterable (  arrays . as list ( "one" "two" "three" )  )  ;   flowable <  list <  string >  >  observable = w . to list (  )  . to flowable (  )  ;   subscriber <  list <  string >  
@ override public final void   (  )  {  cancelled = true ;   }  
public   ( int buffer size )  {  m buffer size = buffer size ;  init buffer (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publish processor <  integer >  source1 =  publish processor . create (  )  ;   publish processor <  integer >  source2 =  publish processor . create (  )  ;   publish processor <  intege
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . start with ( new  iterable <  integer >  (  )  {  @ override public  iterator <  integer >  iterator (  )  {  return null ;   }   }   )  . blocking subscribe (  )  ;   }
@ suppress warnings ( "unchecked" )  @ test @ ignore ( " no 2 - 9 parameter merge delay error (  )  overloads" )  public void   (  )  throws  exception  {  for  ( int i = 2 ;  i  <  10 ;  i +  +  )   {   class <  ?  > [] clazz = new  class[i] ;   arrays .
 genericgf poly   ( int degree int coefficient )  {  if  ( degree  <  0 )   {  throw new  illegal argument exception (  )  ;   }  if  ( coefficient  =  =  0 )   {  return field . get zero (  )  ;   }  int size = coefficients . length ;  int[] product = new int[size  +  degree] ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  product[i] = field . multiply ( coefficients[i] coefficient )  ;   }  return new  genericgf poly ( field product )  ;   }  
@ override boolean   (  packet packet )  {  final  string sender domain = packet . get from (  )  . get domain (  )  ;  final  string recip domain = packet . get to (  )  . get domain (  )  ;  boolean processed = true ;  if  (  ! check outgoing domain pai
public void   ( boolean auto answer )  {  this . auto answer = auto answer ;   }  
@ test public void   (  )  {   flowable <  integer >  src =  flowable . just ( 5 3 1 )  ;  src . skip while ( less   than   five )  . subscribe ( w )  ;   in order in order = in order ( w )  ;  in order . verify ( w times ( 1 )  )  . on next ( 5 )  ;  in 
public  inet6 address   (  )  {  return addr ;   }  
@ test public void   (  )  {   observable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . ju
public  imap string   (  )  {  if  (  ! is status response (  )  )   {  return  imap string . empty ;   }  return get list or empty ( 1 )  . get string or empty ( 0 )  ;   }  
public void   (  session key key byte data[] int offset int length byte target[] int target offset )  {  if  (  ( key  =  =  null )  ||  ( key . get data (  )   =  =  null )  ||  ( data  =  =  null )  )  throw new  null pointer exception ( " null arguments for hmac" )  ;  i2ph mac mac = acquire (  )  ;  mac . init ( key . get data (  )  )  ;  mac . update ( data offset length )  ;  mac . do final ( target target offset )  ;  release ( mac )  ;   }  
public void   (  string secret )  {   jive globals . set property ( "plugin . userservice . secret" secret )  ;  this . secret = secret ;   }  
public  boolean   (  )  {  return    lost packet id plus7 ;   }  
public static  version   (  path plugin dir )  {  final  string value = get element value ( plugin dir " / plugin / prior to server version" )  ;  if  ( value  =  =  null || value . trim (  )  . is empty (  )  )   {  return null ;   }  return new  version ( value )  ;   }  
public synchronized void   (  )  {     current total = 0 ;     total throttle until = 0 ;     peers . clear (  )  ;   }  
@ test public void   (  )  {   flowable . merge delay error (  flowable . just (  flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )   flowable . just ( 2 )  )  1 )  . test (  )  . assert failure (  tes
public boolean   (  )  {  return  ( m host auth . m flags &  host auth . flag   ssl )   !  =  0 ;   }  
public void   ( boolean enabled )  {  enable service ( enabled )  ;   jive globals . set property ( "xmpp . pubsub . enabled"  boolean . to string ( enabled )  )  ;   }  
public static boolean   (  )  {  return  jmx helper . mbean exists ( objectname   openfire )  ;   }  
@ override public void   (  )  {  if  ( once . compare and set ( false true )  )   {  set . clear (  )  ;  if  ( other  =  =  null )   {  s . on error ( new  timeout exception (  )  )  ;   }  else  {  other . subscribe ( new  dispose observer (  )  )  ;  
public void   (  web app context context )  throws  exception  {  configure class path ( context )  ;  context . get servlet context (  )  . set attribute ( "org . apache . tomcat .  instance manager" new  simple instance manager (  )  )  ;   }  
public   (  router context ctx  hash client )  {     context = ctx ;     client = client ;     log = ctx . log manager (  )  . get log (  inbound message distributor . class )  ;     receiver = new  garlic message receiver ( ctx this client )  ;   }  
public void   (  collection <  string >  rooms archived )  {  this . rooms archived = rooms archived ;   jive globals . set property ( "conversation . rooms archived"  string utils . collection to string ( rooms archived )  )  ;   }  
void   (  xml writer writer )  throws io exception  {  writer . start tag ( "ds" )  ;  writer . write tag ( "value" accum value . get (  )  )  ;  writer . write tag ( "unknown   datapoints" nan steps . get (  )  )  ;  writer . close tag (  )  ;   }  
@ deprecated public static void   (  bit matrix matrix  string format  file file  matrix to image config config )  throws io exception  {  write to path ( matrix format file . to path (  )  config )  ;   }  
public static void   (  context context long account id long message id )  {  final  uri uri =  content uris . with appended id (  attachment . message   id   uri message id )  ;  final  cursor c = context . get content resolver (  )  . query ( uri attachment   cached   file   projection null null null )  ;  try  {  while  ( c . move to next (  )  )   {  final  string file name = c . get string ( 0 )  ;  if  (  !  text utils . is empty ( file name )  )   {  final  file cached file = new  file ( file name )  ;  cached file . delete (  )  ;   }   }   }  finally  {  c . close (  )  ;   }   }  
 array list <  archive >    (  consolidation function type type )  {   array list <  archive >  subset = new  array list <  archive >  (  )  ;  for  ( int i = 0 ;  i  <  archives . size (  )  ;  i +  +  )   {   archive archive = archives . get ( i )  ;  if  ( archive . get type (  )  . equals ( type )  )   {  subset . add ( archive )  ;   }   }  return subset ;   }  
@ override public  string   (  )  {   string path info = super . get path info (  )  ;  return path info . replace all ( " / kraken / dwr" "" )  ;   }  
@ test public void   (  )  {   maybe . merge delay error (  flowable . just (  maybe . just ( 1 )   maybe . just ( 2 )   maybe . just ( 3 )  )  1 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . single element (  )  . to flowable (  )  . test (  )  . assert result ( 1 )  ;   }  
@ override public  string   (  )  {  if  ( throw during to string )   {  throw new  illegal argument exception ( " error  making to string" )  ;   }  else  {  return " bad to string" ;   }   }  
@ override public void   (  )  {  if  ( context  !  =  null )   {   http bind manager . get instance (  )  . remove jetty handler ( context )  ;  context . destroy (  )  ;  context = null ;   }  for  (  final  string public resource : public resources )  
public void   ( int level )  {  def . set level ( level )  ;   }  
public void   (  macro group group )  {  macro groups . add ( group )  ;   }  
public static void   (  file f )  {  if  (  ! can set perms (  )  )  return ;  try  {  f . set readable ( false false )  ;  f . set readable ( true true )  ;  f . set writable ( false false )  ;  f . set writable ( true true )  ;   }  catch  (   throwable t )   {   }   }  
public void   ( int mode )  {  switch  ( mode )   {  case 1:    boolean options . add ( "i2cp . new dest on resume" )  ;     boolean options . remove ( "persistent client key" )  ;  break ;  case 2:    boolean options . remove ( "i2cp . new dest on resume" )  ;     boolean options . add ( "persistent client key" )  ;  break ;  default :    boolean options . remove ( "i2cp . new dest on resume" )  ;     boolean options . remove ( "persistent client key" )  ;   }   }  
@ override public  serializable   (  data input in )  throws io exception  {  return null ;   }  
@ override public  iterable <  closeable iterator <  variant context >  >    (  )  {  return  fluent iterable . from ( segments )  . transform ( this::iterator for segment )  ;   }  
@ test public void   (  )  throws  exception  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  count down latch cdl1 = new  count down latch ( 1 )  ;  final  count down latch cdl2 = new  count down latch ( 1 )  
@ override public long   (  )  {  return 1 ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   flowable <  timed <  integer >  >  m = source . timestamp ( scheduler )  ;  m . subscrib
public  example config   ( int number )  {  this . number = number ;  return this ;   }  
@ test public void   (  )  {   flowable <  integer >  source =  flowable . range ( 1 10 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . cache (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integ
private  list <  fastq writer >    ( final sam read group record read group final  fastq writer factory factory )  {   string base filename = null ;  if  ( read group  !  =  null )   {  if  ( rg   tag . equals ignore case ( "pu" )  )   {  base filename = read group . get platform unit (  )   +  "   " ;   }  else if  ( rg   tag . equals ignore case ( "id" )  )   {  base filename = read group . get read group id (  )   +  "   " ;   }  if  ( base filename  =  =  null )   {  throw new  picard exception ( " the selected rg   tag: "  +  rg   tag  +  " is not present in the bam header . " )  ;   }   }  else  {  base filename = "" ;   }   list <  file >  tag files = new  array list <  >  (  )  ;  for  (   string tag split : sequence   tag   group )   {   string file name = base filename  +  tag split . replace ( " " "   " )  ;  file name = io util . make file name safe ( file name )  ;  file name +  = compress   outputs   per   tag   group  ?  " . fastq . gz" : " . fastq" ;  final  file result =  ( output   dir  !  =  null )   ?  new  file ( output   dir file name )  : new  file ( fastq . get parent (  )  file name )  ;  io util . assert file is writable ( result )  ;  tag files . add ( result )  ;   }  return tag files . stream (  )  . map ( factory::new writer )  . collect (  collectors . to list (  )  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 3 )  ;   single <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1  <  2 ;   }   }   )  
public   (  xml filter chain chain )  {  this . chain = chain ;  format . put (  output keys . omit   xml   declaration "yes" )  ;  format . put (  output keys . encoding "utf - 8" )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flat map publisher ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  throws  exception  {  return  flowable . range ( v 5
public int   (  )  {  return whisperers . size (  )  ;   }  
  (  timeout main maybe observer < t u >  parent )  {  this . parent = parent ;   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . take ( 1  time unit . minutes )  . test (  )  . await done ( 5  time unit . seconds )  . assert result ( 1 2 3 4 5 )  ;   }  
public long   (  )  {  return    last used ;   }  
@ test public void   (  )  {  perform test using ( false )  ;   }  
@ test public void   (  )  throws  exception  {  boolean trace = false ;  boolean add header = true ;  long time ;   request tracer rt ;  rt = new  request tracer ( trace add header )  ;   thread . sleep ( 1000l )  ;  time = rt . trace enter (  )  ;  asse
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
public   (  router context context )  {     context = context ;     log =    context . log manager (  )  . get log (  out net message pool . class )  ;   }  
public void   (  string username  string itemjid  string item name  string subscription  string group names )  throws  user not found exception   shared group exception  {  get user ( username )  ;   roster r = roster manager . get roster ( username )  ;  jid j = new jid ( itemjid )  ;   roster item ri = r . get roster item ( j )  ;   list <  string >  groups = new  array list <  string >  (  )  ;  if  ( group names  !  =  null )   {   string tokenizer tkn = new  string tokenizer ( group names " " )  ;  while  ( tkn . has more tokens (  )  )   {  groups . add ( tkn . next token (  )  )  ;   }   }  ri . set groups ( groups )  ;  ri . set nickname ( item name )  ;  if  ( subscription  =  =  null )   {  subscription = "0" ;   }  ri . set sub status (  roster item .  sub type . get type from int (  integer . parse int ( subscription )  )  )  ;  r . update roster item ( ri )  ;   }  
public int   (  )  {  return hash   length ;   }  
private  string   (  )  {  int lastdot =    page . last index of ( ' . ' )  ;  if  ( lastdot  <  =  0 )  return    page ;   string lang =    lang ;  if  ( lang  =  =  null || lang . length (  )   <  =  0 )   {  if  (    context  !  =  null )  lang =    context . get property (  messages . prop   lang )  ;  if  ( lang  =  =  null || lang . length (  )   <  =  0 )   {  lang =  locale . get default (  )  . get language (  )  ;  if  ( lang  =  =  null || lang . length (  )   <  =  0 )  return    page ;   }   }  if  ( lang . equals ( "en" )  )  return    page ;   string newname =    page . substring ( 0 lastdot )   +  '   '  +  lang +     page . substring ( lastdot )  ;   file newfile = new  file ( newname )  ;  if  ( newfile . exists (  )  )  return newname ;  return    page ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay ( just1 new  function <  integer  publisher <  object >  >  (  )  {  @ override public  publisher <  object >  apply (   integer v )  {  return null ;   }   }   ) 
@ override public  publisher <  integer >    (  integer v )  throws  exception  {  return  flowable . just ( v )  ;   }  
private  string   ( int a  string b  string c )  {  return  translate . get string ( a b c    manager . get context (  )  bundle   name )  ;   }  
@ override public void   (  string property  map <  string  object >  params )  {  property set ( property  collections .  <  string  object > empty map (  )  )  ;   }  
public static void   ( final  fingerprint fingerprint final  file output file final  file reference sequence file name final  string sample final  string source )  throws io exception  {  try  ( final  reference sequence file ref =  reference sequence file factory . get reference sequence file ( reference sequence file name )  ; final  variant context writer variant context writer = get variant context writer ( output file reference sequence file name sample source ref )  )  {  createvc set from fingerprint ( fingerprint ref sample )  . for each ( variant context writer::add )  ;   }   }  
@ test public void   (  )  {  final  string[] key = new  string[] { "uninitialized" }  ;  final  list <  string >  values = new  array list <  string >  (  )  ;   observable . just ( "a" "b" "c" )  . group by ( new  function <  string  string >  (  )  {  
public  multi user chat manager   (  )  {  return getxmpp server (  )  . get multi user chat manager (  )  ;   }  
private  < t extends  output stream > t   (  string name )  {  if  ( outputs  =  =  null )   {  return null ;   }  for  (   xslt parameter <  ?  extends  output stream >  output : outputs )   {  if  ( name . equals ignore case ( output . get name (  )  )  )   {  return  ( t ) output . get value (  )  ;   }   }  return null ;   }  
public void   (  )  {  if  ( executor  !  =  null )   {  executor . shutdown (  )  ;   }   }  
public   (  string agentjid long start time long end time )  {  this . agentjid = agentjid ;  this . start time = start time ;  this . end time = end time ;   }  
public synchronized void   (  )  {     last send =    context . clock (  )  . now (  )  ;  long delay ;  if  (    request sent count  =  =  0 )   {  delay = retransmit   delay ;     request sent time =    last send ;   }  else  {  delay =  math . min ( retransmit   delay  <  <     request sent count    request sent time  +   establishment manager . ob   message   timeout  -     last send )  ;   }     request sent count +  +  ;     next send =    last send  +  delay ;  if  (    log . should log (  log . debug )  )     log . debug ( " send a request packet  next send in "  +  delay )  ;  if  (    current state  =  =   outbound state . ob   state   unknown ||    current state  =  =   outbound state . ob   state   introduced )     current state =  outbound state . ob   state   request   sent ;   }  
public  garlic message parser   (  )  {  return    garlic message parser ;   }  
@ override public void   (  packet packet  session session boolean incoming boolean processed )  throws  packet rejected exception  {  if  (  ! subscribers . is empty (  )  )   {  boolean queue = false ;   class packet class = packet . get class (  )  ;  
@ override public void   (  disposable s )  {  parent . set disposable ( s index )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable <  integer >  pp = new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer . on subscribe (
private void   (  single <  boolean >  observable )  {   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  observable . subscribe ( observer )  ;   in order in order = in order ( observer )  ;  in order . verify ( observer times ( 1 )  )  . on error ( isa (  test exception . class )  )  ;  in order . verify no more interactions (  )  ;   }  
boolean   (  )  {  return include path patterns ;   }  
public static void   (  list <  throwable >  list int index  class <  ?  extends  throwable >  clazz  string message )  {   throwable ex = list . get ( index )  ;  if  (  !  ( ex instanceof  undeliverable exception )  )   {   assertion error err = new  assertion error ( " outer exception  undeliverable exception expected but got "  +  list . get ( index )  )  ;  err . init cause ( list . get ( index )  )  ;  throw err ;   }  ex = ex . get cause (  )  ;  if  (  ! clazz . is instance ( ex )  )   {   assertion error err = new  assertion error ( " inner exception "  +  clazz  +  " expected but got " +  list . get ( index )  )  ;  err . init cause ( list . get ( index )  )  ;  throw err ;   }  if  (  !  object helper . equals ( message ex . get message (  )  )  )   {   assertion error err = new  assertion error ( " message "  +  message  +  " expected but got " +  ex . get message (  )  )  ;  err . init cause ( ex )  ;  throw err ;   }   }  
public float   (  )  throws io exception  {  return delegate . read float (  )  ;   }  
public   (  set <  entry < k v >  >  delegate )  {  this . delegate = delegate ;   }  
public static  list <  string >    (  document web xml )  {  return get names ( "filter" web xml )  ;   }  
public  string   (  )  {  return    context . get property ( prop   i2np   ntcp   hostname "" )  ;   }  
public void   (  string new name )  {  if  (  !  model util . has length ( new name )  )   {  return ;   }  presence available = false ;  try  {  active agents . broadcast queue status ( this )  ;   }  finally  {  presence available = true ;   }  this . name = new name ;  jid workgroupjid = workgroup . getjid (  )  ;  address = new jid ( workgroupjid . get node (  )  workgroupjid . get domain (  )  this . name )  ;  update queue (  )  ;  active agents . broadcast queue status ( this )  ;   }  
@ override public  file   (  )  {  return reference   sequence ;   }  
private jid   (  string username )  {   collection <  client session >  sessions =  session manager . get instance (  )  . get sessions (  )  ;  jid found user = null ;  for  (   client session session : sessions )   {  try  {   string user id = session . get address (  )  . get node (  )  ;  if  ( username . equals ( user id )  )   {   log . info ( " incoming sip  find user "  +  session . get address (  )  )  ;  found user = session . get address (  )  ;  break ;   }   }  catch  (   exception e )   {   }   }  return found user ;   }  
public  list <  occupant added event >    (  )  {  return occupants ;   }  
public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write long ( out conversationid )  ;   externalizable util . get instance (  )  . write externalizable map ( out participants )  ;   externalizable util . get instance (  )  . write boolean ( out external )  ;   externalizable util . get instance (  )  . write long ( out start date . get time (  )  )  ;   externalizable util . get instance (  )  . write long ( out last activity . get time (  )  )  ;   externalizable util . get instance (  )  . write int ( out message count )  ;   externalizable util . get instance (  )  . write boolean ( out room  !  =  null )  ;  if  ( room  !  =  null )   {   externalizable util . get instance (  )  . write serializable ( out room )  ;   }   }  
private  path   ( int num cycle metrics files boolean base metrics file )  throws io exception  {   path base dir =  files . create temp directory ( " tile metrics util test" )  ;   path base op dir =  files . create directory ( base dir . resolve (  tile metrics util . interop   subdirectory   name )  )  ;   int stream . range ( 1 num cycle metrics files  +  1 )  . for each ( i  -  >   {  try  {   path cycle dir =  files . create directory ( base op dir . resolve ( "c"  +  i  +  " . 1" )  )  ;  if  ( i  =  =  num cycle metrics files )   {   files . create file ( cycle dir . resolve (  tile metrics util . tile   metrics   out   file   name )  )  ;   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }   }   )  ;  if  ( base metrics file )   {   files . create file ( base op dir . resolve (  tile metrics util . tile   metrics   out   file   name )  )  ;   }  return base dir ;   }  
@ test ( data provider = "clipping tests" )  public void   ( final  string clipping action final  string bases1   1 final  string quals1   1 final  string bases1   2 final  string quals1   2 final  string bases2   1 final  string quals2   1 final  string 
public   (  flowable < t >  source t initial value )  {  this . source = source ;  this . initial value = initial value ;   }  
public void   (  )  {  for  (   object o :    settings . key set (  )  )   {  if  (  !  ( o instanceof  string )  )  continue ;   string k =  (  string ) o ;  if  ( k . starts with ( "move   " )  && k . ends with ( " . x" )  &&    settings . get ( k )   !  =  null )   {     action = k . substring ( 0 k . length (  )   -  2 )  ;  break ;   }   }   }  
@ test ( expected exceptions =  picard exception . class )  public void   (  )  {  final  read structure read structure = new  read structure ( "151t8b8b151t" )  ;  for  (  final boolean use read structure :  arrays . as list ( true false )  )   {  final 
@ override public t   (  )  {  if  ( error  !  =  null )   {  throw  exception helper . wrap or throw ( error )  ;   }  if  ( has next (  )  )   {  is next consumed = true ;  return next ;   }  else  {  throw new  no such element exception ( " no more ele
public   (  string jid int count )  {  this . jid = jid ;  this . count = count ;   }  
public byte[]   (  )  {  return bases ;   }  
public   (  string date string )  {  this . date string = date string ;   }  
@ test public void   (  )  throws  exception  {  final  document web xml =  web xml utils . as document ( new  file (  web xml utils test . class . get resource ( " / org / jivesoftware / util / test - web . xml" )  . touri (  )  )  )  ;  final  string fi
public static void   (  router context ctx  list <  client app config >  apps )  {   file cfg file = config file ( ctx )  ;   file output stream fos = null ;  try  {  fos = new  secure file output stream ( cfg file )  ;   string builder buf = new  string builder ( 2048 )  ;  for  ( int i = 0 ;  i  <  apps . size (  )  ;  i +  +  )   {   client app config app = apps . get ( i )  ;  buf . append ( prefix )  . append ( i )  . append ( " . main = " )  . append ( app . class name )  . append ( "\n" )  ;  buf . append ( prefix )  . append ( i )  . append ( " . name = " )  . append ( app . client name )  . append ( "\n" )  ;  if  ( app . args  !  =  null )  buf . append ( prefix )  . append ( i )  . append ( " . args = " )  . append ( app . args )  . append ( "\n" )  ;  buf . append ( prefix )  . append ( i )  . append ( " . delay = " )  . append ( app . delay  /  1000 )  . append ( "\n" )  ;  buf . append ( prefix )  . append ( i )  . append ( " . start on load = " )  . append (  ! app . disabled )  . append ( "\n" )  ;   }  fos . write ( buf . to string (  )  . get bytes ( "utf - 8" )  )  ;   }  catch  (  io exception ioe )   {   }  finally  {  if  ( fos  !  =  null )  try  {  fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
@ test public void   (  )  {   flowable <  integer >  oi =  flowable . from iterable (  arrays . as list ( 1 2 )  )  ;   test subscriber <  integer >  o = new  test subscriber <  integer >  (  )  ;  oi . subscribe ( o )  ;  o . assert values ( 1 2 )  ;  t
public void   (  )  {  assert equals ( "alert text" build response ( "tag" false new  imap simple string ( "ok" )  build list ( new  imap simple string ( "alert" )  )  new  imap simple string ( "alert text" )  )  . get alert text or empty (  )  . get string (  )  )  ;  assert equals ( "" build response ( "tag" false new  imap simple string ( "ok" )  build list ( new  imap simple string ( "x" )  )  new  imap simple string ( "alert text" )  )  . get alert text or empty (  )  . get string (  )  )  ;   }  
public boolean   (  )  {     failures +  +  ;  if  (    failures  >  max   consecutive   test   failures )   {     failed = true ;  return false ;   }  else  {  return true ;   }   }  
@ override public void   ( boolean required )  {  this . required = required ;   }  
public void   (  string filename )  {     location file = new  file ( filename )  ;  if  (  !    location file . is absolute (  )  )     location file = new  file (    context . get config dir (  )  filename )  ;  load config (  )  ;   }  
public   (  connection connection )  {  super ( connection )  ;   }  
public int   (  )  {  return size ;   }  
@ test ( expected =  cert path builder exception . class )  public void   (  )  throws  exception  {  final x509 cert selector selector = new x509 cert selector (  )  ;  selector . set subject ( valid chain[0] . get subjectx500 principal (  )  )  ;  final
@ override protected  action   (  session data data )  {  return  action . complete ;   }  
  (  router context ctx  job next )  {  super ( ctx )  ;     next = next ;     log = ctx . log manager (  )  . get log (  create router info job . class )  ;   }  
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  info handler = server . getiq disco info handler (  )  ;  items handler = server . getiq disco items handler (  )  ;  message store = server . get offline message store 
@ test public void   (  )  {  final  publish subject <  object >  ps1 =  publish subject . create (  )  ;  final  publish subject <  object >  ps2 =  publish subject . create (  )  ;   test observer <  object >  to = ps1 . group join ( ps2 new  function <
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay subscription ( 1  time unit . seconds null )  ;   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
private static  string   (  string username )  {  return get cache key ( username "      d   e   f   a   u   l   t      " )  ;   }  
public boolean   (  )  {  return    context . get boolean property ( prop   advanced )  ;   }  
public  list <  inet address >    (  )  {  return allowed hosts ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . just ( 1 1 )  . scan ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  {  return null ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . concat (  (  observable <  observable <  object >  >  ) null )  ;   }  
public void   (  string username  privacy list new default  privacy list old default )  {  if  ( old default  !  =  null )   {  old default . set default list ( false )  ;  provider . update privacy list ( username old default )  ;   }  new default . set default list ( true )  ;  lists cache . put ( get default cache key ( username )  new default )  ;  provider . update privacy list ( username new default )  ;   }  
public int   (  )  {  return message   type ;   }  
@ override public final boolean   (  )  {  return cancelled ;   }  
public  string   (  )  {  return get class (  )  . get name (  )   +  "@"  +   integer . to hex string ( hash code (  )  )  +  "[parent db = " +  parent db +  " ds name = " +  ds name +  " ds type = " +  ds type +  " heartbeat = " +  heartbeat +  " min value = " +  min value +  " max value = " +  max value +  "]" ;   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . ignore element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
public   ( int id  string name )  {  set id ( id )  ;  set name ( name )  ;   }  
public  download request   ( final long request id )  {  if  ( request id  <  0 )   {  return null ;   }  synchronized  ( m lock )   {  return m request map . get ( request id )  ;   }   }  
@ override void   (  element offer element )  {   element invite element = offer element . add element ( "transfer" "http: /  / jabber . org / protocol / workgroup" )  ;  invite element . add attribute ( "type" type . to string (  )  )  ;  invite element 
public  row mappers   (  row mapper factory factory )  {  factories . add ( 0 factory )  ;  cache . clear (  )  ;  return this ;   }  
public   ( v card template template )  {  this . template = template ;   }  
public boolean   (  group group )  {  return groups . contains ( group . get name (  )  )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . zip with (  flowable . just ( 2 )  new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  exception  {  return a  +  b ;   }  
public boolean   (  )  {  return send presence ;   }  
@ override public void   (  )  throws io exception  {  finish (  )  ;  super . close (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final t   ( t default item )  {   blocking last observer < t >  s = new  blocking last observer < t >  (  )  ;  subscribe ( s )  ;  t v = s . blocking get (  )  ;  return v  ! 
@ test public void   (  )  {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 5 )  . concat with (  completable . error ( new  test exception (  )  )  )  . subscribe ( to )  ;  to . assert failure 
private void   (  update type type  string id  string version )  {   update item ui = new  update item ( type id )  ;   version ver = new  version ( version )  ;  if  (    log . should log (  log . info )  )     log . info ( ui  +  " "  +  ver +  " downloaded" )  ;     downloaded . put ( ui ver )  ;  if  ( type  =  =  router   signed )   {     downloaded . remove ( new  update item ( router   unsigned "" )  )  ;     downloaded . remove ( new  update item ( router   signed   su3 "" )  )  ;     downloaded . remove ( new  update item ( router   dev   su3 "" )  )  ;   update item altui = new  update item ( router   signed   su3 id )  ;   version old =    available . get ( altui )  ;  if  ( old  !  =  null && old . compare to ( ver )   <  =  0 )     available . remove ( altui )  ;     downloaded . put ( altui ver )  ;   }  else if  ( type  =  =  router   signed   su3 )   {     downloaded . remove ( new  update item ( router   signed "" )  )  ;     downloaded . remove ( new  update item ( router   unsigned "" )  )  ;     downloaded . remove ( new  update item ( router   dev   su3 "" )  )  ;   update item altui = new  update item ( router   signed id )  ;   version old =    available . get ( altui )  ;  if  ( old  !  =  null && old . compare to ( ver )   <  =  0 )     available . remove ( altui )  ;     downloaded . put ( altui ver )  ;   }  else if  ( type  =  =  router   unsigned )   {     downloaded . remove ( new  update item ( router   signed "" )  )  ;     downloaded . remove ( new  update item ( router   signed   su3 "" )  )  ;     downloaded . remove ( new  update item ( router   dev   su3 "" )  )  ;   }  else if  ( type  =  =  router   dev   su3 )   {     downloaded . remove ( new  update item ( router   signed "" )  )  ;     downloaded . remove ( new  update item ( router   signed   su3 "" )  )  ;     downloaded . remove ( new  update item ( router   unsigned "" )  )  ;   }   version old =    available . get ( ui )  ;  if  ( old  !  =  null && old . compare to ( ver )   <  =  0 )     available . remove ( ui )  ;   }  
@ test public void   (  )  throws io exception  {  final  file input = new  file ( test   data   dir "insert   size   metrics   test . sam" )  ;  final  file outfile =  file . create temp file ( "test" " . insert   size   metrics" )  ;  final  file pdf = 
@ test public void   (  )  {   version test = new  version ( null )  ;  assert equals ( 0 test . get major (  )  )  ;  assert equals ( 0 test . get minor (  )  )  ;  assert equals ( 0 test . get micro (  )  )  ;  assert equals (  release status .  release
private   (  string jid  string namespace  string payload )  {  this . serviceid = jid ;  this . nodeid = namespace ;  this . parent = jid ;  this . creator = jid ;  this . payload = payload ;   }  
private  string   (  string jid )  {  for  (   string subdomain : watched subdomains )   {  if  ( jid . contains ( subdomain )  )  return subdomain ;   }  return "" ;   }  
public static  list <  string >    (  string property name  string property value )  throws  service exception  {   list <  string >  usernames = new  array list <  string >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  if  ( property value  !  =  null )   {  pstmt = con . prepare statement ( load   property )  ;  pstmt . set string ( 1 property name )  ;  pstmt . set string ( 2 property value )  ;   }  else  {  pstmt = con . prepare statement ( load   property   by   key )  ;  pstmt . set string ( 1 property name )  ;   }  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  usernames . add ( rs . get string ( 1 )  )  ;   }   }  catch  (  sql exception sqle )   {  throw new  service exception ( " could not get username by property" property name  exception type . property   not   found  response .  status . not   found sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return usernames ;   }  
public  pair <  configured ratelimit  cached rate limit >    (  )  {  return least remaining limit ;   }  
public boolean   (  )  {  return mysql use unicode ;   }  
@ test public void   (  )  throws  exception  {   ehcache cache = mock (  ehcache . class )  ;   element returned element = new  element ( "key" new  string value ( "" )  )  ;  when ( cache . put if absent ( any (  element . class )  )  )  . then return (
public static  room interceptor manager   (  )  {  return instance ;   }  
public static  string   ( final  http servlet request request )  {   string rtn = "" ;  final  string request protocol = request . get protocol (  )  ;  if  (  string utils . is not blank ( request protocol )  )   {  rtn = request protocol . contains ( "1 . 0" )   ?  "1 . 0" : "1 . 1" ;   }  return rtn ;   }  
@ nullable @ suppress warnings ( "rawtypes" )  public static  bi function <  ?  super  single  ?  super  single observer  ?  extends  single observer >    (  )  {  return on single subscribe ;   }  
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;   subscriber <  object >  sub = new  subscriber <  object >  (  )  {   subscription s ;  @ override public void on subscribe (   subscription s )  {  this .
@ override public  account[]   ( int size )  {  return new  account[size] ;   }  
private static  class loader[]   (  )  {   class loader[] class loaders = new  class loader[3] ;  class loaders[0] =  admin console . class . get class (  )  . get class loader (  )  ;  class loaders[1] =  thread . current thread (  )  . get context class loader (  )  ;  class loaders[2] =  class loader . get system class loader (  )  ;  return class loaders ;   }  
@ override public boolean   (  )  throws  exception  {  return false ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just ( 1 )  . hide (  )  . concat map single (  functions . just function (  single . never (  )  )  )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   single . amb (  arrays . as list ( null just1 )  )  . test (  )  . assert error (  null pointer exception . class )  ;   }  
public  boolean   (  )  {  return    lost packet id plus12 ;   }  
public void   (  string version boolean isssl int mode  string user  string password  string session opts )  {  if  (    log . should log (  log . debug )  )     log . debug ( " starting up" )  ;  try  {   socket sock = connect ( isssl )  ;  sam event handler event handler = new  send event handler (    context )  ;     reader = new sam reader (    context sock . get input stream (  )  event handler )  ;     reader . start reading (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " reader created" )  ;   output stream out = sock . get output stream (  )  ;   string our dest = handshake ( out version true event handler mode user password session opts )  ;  if  ( mode  >  =  master )  mode -  = master ;  if  ( our dest  =  =  null )  throw new io exception ( "handshake failed" )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " handshake complete .  we are "  +  our dest )  ;  if  (    isv3 && mode  =  =  stream )   {   socket sock2 = connect ( isssl )  ;  event handler = new  send event handler (    context )  ;     reader2 = new sam reader (    context sock2 . get input stream (  )  event handler )  ;     reader2 . start reading (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " reader2 created" )  ;  out = sock2 . get output stream (  )  ;   string ok = handshake ( out version false event handler mode user password "" )  ;  if  ( ok  =  =  null )  throw new io exception ( "2nd handshake failed" )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " handshake2 complete . " )  ;   }  if  ( mode  =  =  dg || mode  =  =  raw )  out = null ;  send ( out event handler mode )  ;   }  catch  (  io exception e )   {     log . error ( " unable to connect to sam at "  +     sam host  +  ":" +     sam port e )  ;  if  (    reader  !  =  null )     reader . stop reading (  )  ;  if  (    reader2  !  =  null )     reader2 . stop reading (  )  ;   }   }  
@ override public boolean   (  )  {  return true ;   }  
public  collection <  registration >    (  )  {   list <  long >  registrationi ds = new  array list <  long >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( all   registrations )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  registrationi ds . add ( rs . get long ( 1 )  )  ;   }   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  if  ( registrationi ds . is empty (  )  )   {  return  collections . empty list (  )  ;   }  else  {  return new  registration collection ( registrationi ds )  ;   }   }  
public void   (  data output out long[] array )  throws io exception  {  strategy . write long array ( out array )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  subscriber fusion . new test (  queue fuseable . any |  queue fuseable . boundary )  ;   flowable . range ( 1 5 )  . map (  functions .  <  integer > identity (  )  )  . subscribe ( ts )  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  create ( 1000 )  . subscribe ( ts )  ;  ts . assert no errors (  )  ;  ts . assert value count ( 1000 )  ;  ts . assert complete (  )  ;   }  
void   (  gif89 frame gf )  throws io exception  {  if  ( gf instanceof  direct gif89 frame )   {  filter pixels (  (  direct gif89 frame ) gf )  ;   }  else  {  track pixel usage (  (  index gif89 frame ) gf )  ;   }   }  
public  set <  hash >    (  )  {  return    our family ;   }  
public void   (  string image file )  throws io exception  {   buffered image wp image =  imageio . read ( new  file ( image file )  )  ;   texture paint paint = new  texture paint ( wp image new  rectangle ( 0 0 wp image . get width (  )  wp image . get height (  )  )  )  ;  gd . set paint ( paint )  ;  gd . fill rect ( 0 0 wp image . get width (  )  wp image . get height (  )  )  ;   }  
public  string   (  )  {  return transport ;   }  
@ test public void   (  )  {  stream . mark ( 1 )  ;   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . single element (  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public long   (  )  {  return 1024 * 1024 ;   }  
public  connection multiplexer session   ( jid address )  {   local connection multiplexer session session = local session manager . get connnection manager sessions (  )  . get ( address . to string (  )  )  ;  if  ( session  =  =  null && server . get remote session locator (  )   !  =  null )   {  byte[] nodeid = multiplexer sessions cache . get ( address . to string (  )  )  ;  if  ( nodeid  !  =  null )   {  return server . get remote session locator (  )  . get connection multiplexer session ( nodeid address )  ;   }   }  return null ;   }  
@ override public void   (  yahoo buddy contact )  {   string yahoo contact = get transport (  )  . convertjid toid ( contact . getjid (  )  )  ;  yahoo session . get roster (  )  . remove (  ( contact )  . yahoo user )  ;  pseudo roster . remove item ( y
public void   ( boolean enabled )  {  this . enabled = enabled ;   }  
@ test public void   (  )  {   single <  boolean >  o =  observable . just ( "a" "b" )  . contains ( "c" )  ;   single observer <  object >  observer =  test helper . mock single observer (  )  ;  o . subscribe ( observer )  ;  verify ( observer times ( 1
@ test public void   (  )  {   test observer <  integer >  to =  observable . range ( 1 10 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  ( 
@ override public  maybe source <  object >    (  single <  object >  v )  throws  exception  {  return  maybe . from single ( v )  ;   }  
private static  string   (  field field )  {  return  optional . of nullable ( field . get annotation (  column name . class )  )  . map (  column name::value )  . or else get ( field::get name )  ;   }  
private void   ( boolean isi pv6 )  {   peer state bob =    transport . pick test peer ( bob isi pv6 null )  ;  if  ( bob  !  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( " running periodic test with bob  =  "  +  bob )  ;     test manager . run test ( bob . get remoteip address (  )  bob . get remote port (  )  bob . get current cipher key (  )  bob . get currentmac key (  )  )  ;  set last tested ( isi pv6 )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to run peer test  no peers available  -  v6 ?  "  +  isi pv6 )  ;   }     force run = no   force ;   }  
@ override public synchronized void   (  )  {  store watcher . destroy (  )  ;  type to identity store . clear (  )  ;  type to trust store . clear (  )  ;  identity stores . clear (  )  ;  trust stores . clear (  )  ;  super . destroy (  )  ;   }  
@ test public void   (  )  throws  exception  {  assert that (  string utils . get full elapsed time (  jive constants . second )  is ( "1 second" )  )  ;  assert that (  string utils . get full elapsed time (  jive constants . second  +  1 )  is ( "1 sec
public   (  connection type type boolean enabled int max thread pool size int max buffer size  connection .  client auth client auth  inet address bind address int port  connection . tls policy tls policy  certificate store configuration identity store configuration  certificate store configuration trust store configuration boolean accept self signed certificates boolean verify certificate validity  set <  string >  encryption protocols  set <  string >  encryption cipher suites  connection .  compression policy compression policy )  {  if  ( max thread pool size  <  =  0 )   {  throw new  illegal argument exception ( " argument 'max thread pool size' must be equal to or greater than one . " )  ;   }  if  ( client auth  =  =  null )   {  throw new  illegal argument exception ( " argument 'client auth' cannot be null . " )  ;   }  this . enabled = enabled ;  this . tls policy = tls policy ;  this . type = type ;  this . max thread pool size = max thread pool size ;  this . max buffer size = max buffer size ;  this . client auth = client auth ;  this . bind address = bind address ;  this . port = port ;  this . identity store configuration = identity store configuration ;  this . trust store configuration = trust store configuration ;  this . accept self signed certificates = accept self signed certificates ;  this . verify certificate validity = verify certificate validity ;  this . encryption protocols =  collections . unmodifiable set ( encryption protocols )  ;  this . encryption cipher suites =  collections . unmodifiable set ( encryption cipher suites )  ;  this . compression policy = compression policy ;  final  certificate store manager certificate store manager = xmpp server . get instance (  )  . get certificate store manager (  )  ;  this . identity store = certificate store manager . get identity store ( type )  ;  this . trust store = certificate store manager . get trust store ( type )  ;   }  
public void   (  pub sub service service  message message )  {  if  ( message . get type (  )   =  =   message .  type . error )   {  if  ( message . get error (  )  . get type (  )   =  =   packet error .  type . cancel )   {  jid owner = message . get from (  )  . as barejid (  )  ;  cancel all subscriptions ( service owner )  ;   }  else if  ( message . get error (  )  . get type (  )   =  =   packet error .  type . auth )   {   }   }  else if  ( message . get type (  )   =  =   message .  type . normal )   {   data form auth form =  (  data form ) message . get extension ( "x" "jabber:x:data" )  ;  if  ( auth form  !  =  null && auth form . get type (  )   =  =   data form .  type . submit )   {   string form type = auth form . get field ( "form   type" )  . get values (  )  . get ( 0 )  ;  if  ( "http: /  / jabber . org / protocol / pubsub#subscribe   authorization" . equals ( form type )  )   {  process authorization answer ( service auth form message )  ;   }   }   }   }  
public void   (  destination from byte[] data )  {   sink s = this . cache . get ( from )  ;  if  ( s  =  =  null )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  multi sink . class )  ;  log . error ( " no where to go for "  +  from . calculate hash (  )  . to base64 (  )  . substring ( 0 6 )  )  ;  return ;   }  s . send ( from data )  ;   }  
public static  queued tasks manager   (  )  {  return instance ;   }  
public int   ( int fragment num )  throws  data format exception  {  int off = get fragment begin ( fragment num )  ;  off +  = 4 ;  return  (    message[off] & 0xff )   >  >  >  1 ;   }  
@ override public void   ( @ non null  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  try  {  actual . on subscribe ( this )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  done =
@ test public void   (  )  {   iterable <  integer >  it = new  iterable <  integer >  (  )  {  @ override public  iterator <  integer >  iterator (  )  {  return new  iterator <  integer >  (  )  {  int count ;  @ override public boolean has next (  )  {
@ test public void   (  )  {  final  atomic boolean did run on terminate = new  atomic boolean (  )  ;   unicast processor <  integer >  us =  unicast processor . create (  observable . buffer size (  )  new  runnable (  )  {  @ override public void run (
@ xml element public boolean   (  )  {  return public room ;   }  
private void   (  writer out  string builder buf  list <  router info >  ris  map <  hash  points >  points )  throws io exception  {  buf . append ( " < h3 id = \"samefamily\" class = \"sybils\" >  floodfills in the  same  declared  family <  / h3 >  < div class = \"sybil   container\" > " )  ;   object counter <  string >  oc = new  object counter <  string >  (  )  ;  for  (   router info info : ris )   {   string fam = info . get option ( "family" )  ;  if  ( fam  =  =  null )  continue ;  oc . increment ( fam )  ;   }   list <  string >  foo = new  array list <  string >  ( oc . objects (  )  )  ;   collections . sort ( foo new  foof comparator ( oc )  )  ;   family key crypto fkc =    context . router (  )  . get family key crypto (  )  ;   string our family = fkc  !  =  null  ?  fkc . get our family name (  )  : null ;  boolean found = false ;  for  (   string s : foo )   {  int count = oc . count ( s )  ;   string ss =  data helper . escapehtml ( s )  ;  if  ( count  >  1 )   {  buf . append ( " < p class = \"family\" >  < b > " )  . append ( count )  . append ( " floodfills in family: &nbsp ;  < a href = \" / netdb ? fam = " )  . append ( ss )  . append ( "&amp ; sybil\" > " )  . append ( ss )  . append ( " <  / a >  <  / b >  <  / p > " )  ;   }  for  (   router info info : ris )   {   string fam = info . get option ( "family" )  ;  if  ( fam  =  =  null )  continue ;  if  (  ! fam . equals ( s )  )  continue ;  found = true ;  double point = points   family ;  if  ( fkc  !  =  null && s . equals ( our family )  )   {  if  ( fkc . verify our family ( info )  )  add points ( points info . get hash (  )  points   our   family " our family \""  +   data helper . escapehtml ( s )   +  "\" with " +   ( count  -  1 )  +  " other" +   (  ( count  >  2 )   ?  "s" : "" )  )  ;  else add points ( points info . get hash (  )  points   bad   our   family " spoofed our family \""  +   data helper . escapehtml ( s )   +  "\" with " +   ( count  -  1 )  +  " other" +   (  ( count  >  2 )   ?  "s" : "" )  )  ;   }  else if  ( count  >  1 )   {  add points ( points info . get hash (  )  point " same declared family \""  +   data helper . escapehtml ( s )   +  "\" with " +   ( count  -  1 )  +  " other" +   (  ( count  >  2 )   ?  "s" : "" )  )  ;   }  else  {  add points ( points info . get hash (  )  point " declared family \""  +   data helper . escapehtml ( s )   +  '"' )  ;   }   }   }  if  (  ! found )  buf . append ( " < p class = \"notfound\" >  none <  / p > " )  ;  buf . append ( " <  / div > " )  ;  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;  buf . set length ( 0 )  ;   }  
public void   ( boolean permanent )  {  this . permanent = permanent ;   }  
public void   ( boolean only not processed enabled )  {  this . only not processed enabled = only not processed enabled ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . test (  )  ;  ps . subscribe ( new  observer <  integer >  (  )  {  @ override public void on subscribe (   disposa
public  service   (  string search url )  {   service list service list = get service list (  )  ;  int service cnt = service list . size (  )  ;  for  ( int n = 0 ;  n  <  service cnt ;  n +  +  )   {   service service = service list . get service ( n )  ;  if  ( service . is event suburl ( search url )   =  =  true )  return service ;   }   device list dev list = get device list (  )  ;  int dev cnt = dev list . size (  )  ;  for  ( int n = 0 ;  n  <  dev cnt ;  n +  +  )   {   device dev = dev list . get device ( n )  ;   service service = dev . get service by event suburl ( search url )  ;  if  ( service  !  =  null )  return service ;   }  return null ;   }  
@ test public void   (  )  {   function3 <  string  integer int[]  string >  combine latest function = get concat string integer int array combine latest function (  )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   flowab
@ after public void   (  )  throws  exception  {  handle . close (  )  ;   }  
private static  string   (  string[] ui projection )  {   string builder sb = gen select ( get message list map (  )  ui projection )  ;  sb . append ( " from "  +   message . table   name  +  " where " +   message columns .    id +  " =  ? " )  ;  return sb . to string (  )  ;   }  
  (  disposable s  string .  .  .  values )  {  this . s = s ;  this . values = values ;   }  
void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  int missed = 1 ;   observer <  ?  super c >  a = actual ;   spsc linked array queue < c >  q = queue ;  for  (  ;   ;   )   {  for  (  ;   ;   )   {  if  ( cancelled )   {  q . clear (  )  ;  return ;   }  boolean d = done ;  if  ( d && errors . get (  )   !  =  null )   {  q . clear (  )  ;   throwable ex = errors . terminate (  )  ;  a . on error ( ex )  ;  return ;   }  c v = q . poll (  )  ;  boolean empty = v  =  =  null ;  if  ( d && empty )   {  a . on complete (  )  ;  return ;   }  if  ( empty )   {  break ;   }  a . on next ( v )  ;   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
private static  news metadata   (  node feed )  throws i2p parser exception  {   news metadata rv = new  news metadata (  )  ;   node n = feed . get node ( "title" )  ;  if  ( n  !  =  null )   {  rv . feed title = n . get value (  )  ;  if  ( rv . feed title  !  =  null )  rv . feed title = rv . feed title . trim (  )  ;   }  n = feed . get node ( "subtitle" )  ;  if  ( n  !  =  null )   {  rv . feed subtitle = n . get value (  )  ;  if  ( rv . feed subtitle  !  =  null )  rv . feed subtitle = rv . feed title . trim (  )  ;   }  n = feed . get node ( "id" )  ;  if  ( n  !  =  null )   {  rv . feedid = n . get value (  )  ;  if  ( rv . feed title  !  =  null )  rv . feed title = rv . feed title . trim (  )  ;   }  n = feed . get node ( "updated" )  ;  if  ( n  !  =  null )   {   string v = n . get value (  )  ;  if  ( v  !  =  null )   {  long time = rfc3339 date . parse3339 date ( v . trim (  )  )  ;  if  ( time  >  0 )  rv . feed updated = time ;   }   }   list <  news metadata .  release >  releases = new  array list <  news metadata .  release >  (  )  ;   list <  node >  release nodes = get nodes ( feed "i2p:release" )  ;  if  ( release nodes . size (  )   =  =  0 )  throw new i2p parser exception ( "no release data in xml" )  ;  for  (   node r : release nodes )   {   news metadata .  release release = new  news metadata .  release (  )  ;   string a = r . get attribute value ( "date" )  ;  if  ( a . length (  )   >  0 )   {  long time = rfc3339 date . parse3339 date ( a . trim (  )  )  ;  if  ( time  >  0 )  release . date = time ;   }  a = r . get attribute value ( "min version" )  ;  if  ( a . length (  )   >  0 )  release . min version = a . trim (  )  ;  a = r . get attribute value ( "min java version" )  ;  if  ( a . length (  )   >  0 )  release . min java version = a . trim (  )  ;  n = r . get node ( "i2p:version" )  ;  if  ( n  !  =  null )   {  release . i2p version = n . get value (  )  ;  if  ( release . i2p version  !  =  null )  release . i2p version = release . i2p version . trim (  )  ;   }   list <  news metadata .  update >  updates = new  array list <  news metadata .  update >  (  )  ;   list <  node >  update nodes = get nodes ( r "i2p:update" )  ;  if  ( update nodes . size (  )   =  =  0 )  throw new i2p parser exception ( "no updates in release" )  ;   set <  string >  types = new  hash set <  string >  (  )  ;  for  (   node u : update nodes )   {   string type = u . get attribute value ( "type" )  ;  if  ( type . is empty (  )  )  throw new i2p parser exception ( "update with no type" )  ;  if  ( types . contains ( type )  )  throw new i2p parser exception ( "update with duplicate type" )  ;   news metadata .  update update = new  news metadata .  update (  )  ;  update . type = type . trim (  )  ;  types . add ( type )  ;  int total sources = 0 ;   node t = u . get node ( "i2p:torrent" )  ;  if  ( t  !  =  null )   {   string href = t . get attribute value ( "href" )  ;  if  ( href . length (  )   >  0 )   {  update . torrent = href . trim (  )  ;  total sources +  = 1 ;   }   }  if  ( total sources  =  =  0 )  throw new i2p parser exception ( "no sources for update type "  +  type )  ;  updates . add ( update )  ;   }   collections . sort ( updates )  ;  release . updates = updates ;  releases . add ( release )  ;   }   collections . sort ( releases )  ;  rv . releases = releases ;  return rv ;   }  
@ test public void   (  )  {   test helper . check double on subscribe maybe ( new  function <  maybe <  integer >   maybe <  integer >  >  (  )  {  @ override public  maybe <  integer >  apply (   maybe <  integer >  m )  throws  exception  {  return m .
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ suppress warnings ( "unchecked" )  private void   (  string hostname  element user element  string user name )  {   collection <  offline message >  offline messages = offline messages store . get messages ( user name false )  ;  if  (  ! offline messag
@ override public int   (  )  {   connection options opts =  (  connection options )    socket . get options (  )  ;  if  ( opts  =  =  null )  return 64 * 1024 ;  return opts . get inbound buffer size (  )  ;   }  
@ test public void   (  )  {   single <  boolean >  o =  observable . sequence equal (  observable . concat (  observable . just ( "one" )   observable .  <  string > error ( new  test exception (  )  )  )   observable . just ( "one" "two" "three" )  )  ;
@ override public void   ( u t )  {  s . dispose (  )  ;  sus . not skipping = true ;   }  
@ override public void   ( u t )  {  frc . dispose (  )  ;  serial . on complete (  )  ;   }  
@ override public boolean   (  )  {  while  (  ( current tile  =  =  null || next cluster in tile  >  =  current tile . num clusters in tile )  && requested tiles iterator . has next (  )  )   {  seek to tile ( requested tiles iterator . next (  )  )  ;  
public  integer   ( boolean include private )  {   integer services cnt = muc services . size (  )  ;  if  (  ! include private )   {  for  (   multi user chat service service : muc services . values (  )  )   {  if  ( service . is hidden (  )  )   {  services cnt -  -  ;   }   }   }  return services cnt ;   }  
void   (  throwable t )  {  s . dispose (  )  ;  resources . dispose (  )  ;  on error ( t )  ;   }  
public int   (  )  {  return use long el gamal exponent (  )   ?  pubkey   exponent   size   full : pubkey   exponent   size   short ;   }  
@ test public void   (  )  {   assert . assert equals ( "a  magical  string"  reflection tools . construct (  string . class "a  magical  string" )  )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return  collections .  <  int
static  provider   (  context context  string domain int resource id )  {  try  {   xml resource parser xml = context . get resources (  )  . get xml ( resource id )  ;  int xml event type ;   provider provider = null ;  while  (  ( xml event type = xml . next (  )  )   !  =   xml resource parser . end   document )   {  if  ( xml event type  =  =   xml resource parser . start   tag && "provider" . equals ( xml . get name (  )  )  )   {   string provider domain = get xml attribute ( context xml "domain" )  ;  try  {  if  ( match provider ( domain provider domain )  )   {  provider = new  provider (  )  ;  provider . id = get xml attribute ( context xml "id" )  ;  provider . label = get xml attribute ( context xml "label" )  ;  provider . domain = domain . to lower case (  )  ;  provider . note = get xml attribute ( context xml "note" )  ;  provider . oauth = get xml attribute ( context xml "oauth" )  ;   }   }  catch  (   illegal argument exception e )   {   log utils . w (  logging . log   tag "providers line: "  +  xml . get line number (  )   +  " ;   domain contains multiple globals" )  ;   }   }  else if  ( xml event type  =  =   xml resource parser . start   tag && "incoming" . equals ( xml . get name (  )  )  && provider  !  =  null )   {  provider . incoming uri template = get xml attribute ( context xml "uri" )  ;  provider . incoming username template = get xml attribute ( context xml "username" )  ;   }  else if  ( xml event type  =  =   xml resource parser . start   tag && "outgoing" . equals ( xml . get name (  )  )  && provider  !  =  null )   {  provider . outgoing uri template = get xml attribute ( context xml "uri" )  ;  provider . outgoing username template = get xml attribute ( context xml "username" )  ;   }  else if  ( xml event type  =  =   xml resource parser . start   tag && "incoming - fallback" . equals ( xml . get name (  )  )  && provider  !  =  null )   {  provider . alt incoming uri template = get xml attribute ( context xml "uri" )  ;  provider . alt incoming username template = get xml attribute ( context xml "username" )  ;   }  else if  ( xml event type  =  =   xml resource parser . start   tag && "outgoing - fallback" . equals ( xml . get name (  )  )  && provider  !  =  null )   {  provider . alt outgoing uri template = get xml attribute ( context xml "uri" )  ;  provider . alt outgoing username template = get xml attribute ( context xml "username" )  ;   }  else if  ( xml event type  =  =   xml resource parser . end   tag && "provider" . equals ( xml . get name (  )  )  && provider  !  =  null )   {  return provider ;   }   }   }  catch  (   exception e )   {   log utils . e (  logging . log   tag " error while trying to load provider settings . " e )  ;   }  return null ;   }  
@ test public void   (  )  {   observable .  <  integer > just ( 1 )  . hide (  )  . concat map eager ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   integer v )  throws 
@ override public void   (  context context int[] app widget ids )  {  super . on deleted ( context app widget ids )  ;  final  shared preferences prefs = context . get shared preferences ( legacy   prefs   name 0 )  ;  final  shared preferences .  editor
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  list <  integer >  >  ts = pp . buff
void   (  throwable e )  {  upstream . cancel (  )  ;  if  ( errors . add throwable ( e )  )   {  done = true ;  drain (  )  ;   }  else  {   rx java plugins . on error ( e )  ;   }   }  
public void   (  )  {  if  (    writer  !  =  null )   {  int i = 50 ;  while  (  (  !    records . is empty (  )  )  && i -  -   >  0 )   {  synchronized  (    writer )   {     writer . notify all (  )  ;   }  try  {   thread . sleep ( 5 )  ;   }  catch  (   interrupted exception ie )   {   }   }   }   }  
@ test public void   (  )  {   publish subject <  string >  r1 =  publish subject . create (  )  ;   publish subject <  string >  r2 =  publish subject . create (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;   observable .
@ override public void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 1 )  ;  s . on error ( new  test exception ( " source" )  )  ;  s . on complete (  )  ;   }
public  string   (  )  {  return  jive globals . get property ( message " big  brother is watching . " )  ;   }  
@ override public void   ( t t )  {  child . on next ( t )  ;   }  
public  roster item .  sub type   (  )  {  return new sub ;   }  
public boolean   (  )  {   argument list action arg list = get argument list (  )  ;   argument list action input arg list = get input argument list (  )  ;   action request ctrl req = new  action request (  )  ;  ctrl req . set request ( this action input arg list )  ;  if  (  debug . is on (  )   =  =  true )  ctrl req . print (  )  ;   action response ctrl res = ctrl req . post (  )  ;  if  (  debug . is on (  )   =  =  true )  ctrl res . print (  )  ;  set control response ( ctrl res )  ;  int stat code = ctrl res . get status code (  )  ;  set status ( stat code )  ;  if  ( ctrl res . is successful (  )   =  =  false )  return false ;   argument list out arg list = ctrl res . get response (  )  ;  try  {  action arg list . set res args ( out arg list )  ;   }  catch  (   illegal argument exception ex )   {  set status ( u pnp status . invalid   args " action succesfully delivered but invalid arguments returned . " )  ;  return false ;   }  return true ;   }  
@ setup public void   (  )  {   integer[] source array = new  integer[count] ;   arrays . fill ( source array 777 )  ;   observable <  integer >  source =  observable . from array ( source array )  ;  observable plain = source . switch map ( new  function
@ override public void   (  content handler handler )  throws sax exception  {  handler . start element ( jsonx   uri get local name (  )  get qname (  )  get attributes (  )  )  ;  handler . end element ( jsonx   uri get local name (  )  get qname (  )  
@ override public void   (  )  throws io exception  {  input stream . reset (  )  ;   }  
  (  subscriber <  ?  super c >  actual int size int skip  callable < c >  buffer supplier )  {  this . actual = actual ;  this . size = size ;  this . skip = skip ;  this . buffer supplier = buffer supplier ;   }  
@ test public void   (  )  {   observable . from publisher (  flowable . just ( 1 )  )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  throws  exception  {  find pattern ( " connectable observable <  . * > \\s + cf ( 0 - 9|\\b ) " )  ;   }  
public void   (  )  {   packed string ps = new  packed string ( packed   string   tagged )  ;  assert equals ( "val1" ps . get ( "tag1" )  )  ;  assert equals ( "val2" ps . get ( "tag2" )  )  ;  assert equals ( "val3" ps . get ( "tag3" )  )  ;  assert equals ( "val4" ps . get ( "tag4" )  )  ;  assert null ( ps . get ( "tag100" )  )  ;   }  
@ override public void   (  integer t )  {  upstream count . increment and get (  )  ;   }  
@ override public void   (  )  {  dispose after (  )  ;  s . cancel (  )  ;   }  
private   (  context context )  {  m context = context . get application context (  )  ;  mdpm = null ;  m admin name = new  component name ( context  policy admin . class )  ;  m aggregate policy = null ;   }  
public static void   (  logger log )  {  try  {  final  input stream banner input stream =  repose banner . class . get resource as stream ( " / repose . banner" )  ;   scanner s = new  scanner ( banner input stream )  . use delimiter ( "\\a" )  ;  if  ( s . has next (  )  )   {  log . info ( "\n"  +  s . next (  )  )  ;   }  else  {  log . warn ( " unable to find the beautiful narwhal banner .   this is a bad thing . " )  ;   }   }  catch  (   exception e )   {  log . warn ( "non - fatal  -   unable to log the beautiful narwhal banner .   sad day . " e )  ;   }   }  
public  session request reader   (  )  {  return    session request reader ;   }  
protected final void   ( long n )  {   subscription helper . deferred request ( s missed requested n )  ;   }  
private udp packet   ( byte flag byte byte[] extended options )  {  udp packet packet = udp packet . acquire (    context false )  ;  byte data[] = packet . get packet (  )  . get data (  )  ;   arrays . fill ( data 0 data . length  ( byte ) 0x0 )  ;  int off = udp packet . mac   size  +  udp packet . iv   size ;  if  ( extended options  !  =  null )  flag byte| = udp packet . header   flag   extended   options ;  data[off] = flag byte ;  off +  +  ;  long now =  (    context . clock (  )  . now (  )   +  500 )   /  1000 ;   data helper . to long ( data off 4 now )  ;  if  ( extended options  !  =  null )   {  off +  = 4 ;  int len = extended options . length ;  if  ( len  >  255 )  throw new  illegal argument exception (  )  ;  data[off +  + ] =  ( byte ) len ;   system . arraycopy ( extended options 0 data off len )  ;   }  return packet ;   }  
public  string[]   (  )  {  return all participants ;   }  
  (  observer <  ?  super t >  actual  subject <  throwable >  signaller  observable source < t >  source )  {  this . actual = actual ;  this . signaller = signaller ;  this . source = source ;  this . wip = new  atomic integer (  )  ;  this . error = new  atomic throwable (  )  ;  this . inner = new  inner repeat observer (  )  ;  this . d = new  atomic reference <  disposable >  (  )  ;   }  
@ override public  collection <  string >    ( jid user )  {   list <  string >  group names = new  array list <  >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get
@ test public void   (  )  throws  exception  {  filter chain = new  mock filter chain ( new  http servlet (  )  {  @ override public void do get (   http servlet request request   http servlet response response )  throws io exception  {  response . set h
public synchronized double   (  )  {  if  (  (    last total value  !  =  0 )  &&  (    lifetime total value  !  =  0 )  )   {  double lifetime period value =    period *  (    lifetime total value  /   ( now (  )   -     creation date )  )  ;  return    last total value  /  lifetime period value ;   }  return 0 . 0d ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 128 )  ;  buf . append ( super . to string (  )  )  ;  buf . append ( "\n\t verified  certificate ?  " )  . append ( verify cert ( true )  )  ;  return buf . to string (  )  
@ override protected byte[]   (  )  throws i2cp message exception  io exception  {  if  (  (    session id  <  0 )  ||  (    message id  <  0 )  )  throw new i2cp message exception ( " unable to write out the message as there is not enough data" )  ;  byt
private void   (  )  throws  rrd exception  io exception  {  dproc = new  data processor ( gdef . start time gdef . end time )  ;  dproc . set pool used ( gdef . pool used )  ;  if  ( gdef . step  >  0 )   {  dproc . set step ( gdef . step )  ;   }  for  (   source src : gdef . sources )   {  src . request data ( dproc )  ;   }  dproc . process data (  )  ;  im . start = gdef . start time ;  im . end = gdef . end time ;   }  
public void   (  )  {  final  context c = m mock context ;   account a =  provider test utils . setup account ( "acct1" true c )  ;   mailbox bi =  provider test utils . setup mailbox ( "b1" a . m id true c  mailbox . type   inbox )  ;   mailbox bm =  provider test utils . setup mailbox ( "b1" a . m id true c  mailbox . type   mail )  ;   mailbox bd =  provider test utils . setup mailbox ( "b1" a . m id true c  mailbox . type   drafts )  ;   mailbox bo =  provider test utils . setup mailbox ( "b1" a . m id true c  mailbox . type   outbox )  ;  assert true (  mailbox . is refreshable ( c bi . m id )  )  ;  assert true (  mailbox . is refreshable ( c bm . m id )  )  ;  assert false (  mailbox . is refreshable ( c bd . m id )  )  ;  assert false (  mailbox . is refreshable ( c bo . m id )  )  ;  assert false (  mailbox . is refreshable ( c 9999999 )  )  ;  assert false (  mailbox . is refreshable ( c  mailbox . query   all   drafts )  )  ;  assert false (  mailbox . is refreshable ( c  mailbox . query   all   inboxes )  )  ;   }  
public byte[]   (  )  {  return nodeid ;   }  
public static  string[]   (  string text )  {  if  ( text  =  =  null || text . length (  )   =  =  0 )   {  return new  string[0] ;   }   list <  string >  word list = new  array list <  >  (  )  ;   break iterator boundary =  break iterator . get word instance (  )  ;  boundary . set text ( text )  ;  int start = 0 ;  for  ( int end = boundary . next (  )  ;  end  !  =   break iterator . done ;  start = end  end = boundary . next (  )  )   {   string tmp = text . substring ( start end )  . trim (  )  ;  tmp = replace ( tmp " + " "" )  ;  tmp = replace ( tmp " / " "" )  ;  tmp = replace ( tmp "\\" "" )  ;  tmp = replace ( tmp "#" "" )  ;  tmp = replace ( tmp "*" "" )  ;  tmp = replace ( tmp " ) " "" )  ;  tmp = replace ( tmp " ( " "" )  ;  tmp = replace ( tmp "&" "" )  ;  if  ( tmp . length (  )   >  0 )   {  word list . add ( tmp )  ;   }   }  return word list . to array ( new  string[word list . size (  ) ] )  ;   }  
@ test public void   (  )  throws  interrupted exception  {   flowable <  integer >  o =  flowable . from iterable (  arrays . as list ( 1 2 3 4 )  )  ;  final int expected count = 4 ;  final  count down latch latch = new  count down latch ( expected coun
@ test public void   (  )  {  final  test exception ex0 = new  test exception (  )  ;  final  test exception ex = new  test exception (  )  ;  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {   list <  throwable >  errors =  t
public void   (  )  {     acked = true ;   }  
private void   (  )  {   build message state state = null ;  try  {  state =    inbound build messages . take (  )  ;   }  catch  (   interrupted exception ie )   {  return ;   }  if  ( state . msg  =  =  null )   {     is running = false ;  return ;   }  long now =    context . clock (  )  . now (  )  ;  long drop before = now  -   (  build requestor . request   timeout  /  4 )  ;  if  ( state . recv time  <  =  drop before )   {  if  (    log . should log (  log . warn )  )     log . warn ( " not even trying to handle / decrypt the request "  +  state . msg . get unique id (  )   +  "  since we received it a long time ago: " +   ( now  -  state . recv time )  )  ;     context . stat manager (  )  . add rate data ( "tunnel . drop load delay" now  -  state . recv time )  ;     context . throttle (  )  . set tunnel status (    x ( " dropping tunnel requests:  too slow" )  )  ;  return ;   }  long lag =    context . job queue (  )  . get max lag (  )  ;  if  ( lag  >  job   lag   limit   tunnel )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping tunnel request  as the job lag is "  +  lag )  ;     context . stat manager (  )  . add rate data ( "router . throttle tunnel cause" lag )  ;     context . throttle (  )  . set tunnel status (    x ( " dropping tunnel requests:  high job lag" )  )  ;  return ;   }  handle request ( state )  ;   }  
@ test public void   (  )  {   observable <  string >  w =  observable . from iterable (  arrays . as list ( "one" "two" "three" )  )  ;   observable <  list <  string >  >  observable = w . to list (  )  . to observable (  )  ;   observer <  list <  stri
@ test public void   (  )  {   flowable . create ( source no cancel  backpressure strategy . drop )  . subscribe ( ts )  ;  ts . cancel (  )  ;  source no cancel . on next ( 1 )  ;  source no cancel . on next ( 2 )  ;  source no cancel . on error ( new  t
public  string   (  )  {  return m   dest ;   }  
@ override public  element   (  string username  element v card element )  throws  already exists exception  {  if  ( log . is debug enabled (  )  )   {  log . debug ( "createvcard:"  +  v card element . asxml (  )  )  ;   }  return super . createv card (
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . unsafe create ( null )  ;   }  
@ override public int   (  )  {  return source . parallelism (  )  ;   }  
public long[]   (  snark snark )  {  long[] rv = new long[2] ;   properties config = get config ( snark )  ;  if  ( config  !  =  null )   {  try  {  rv[0] =  long . parse long ( config . get property ( prop   meta   added )  )  ;   }  catch  (   number format exception nfe )   {   }  try  {  rv[1] =  long . parse long ( config . get property ( prop   meta   completed )  )  ;   }  catch  (   number format exception nfe )   {   }   }  return rv ;   }  
private void   (  )  {  treatment done = false ;  if  ( conference treatments . size (  )   =  =  0 )   {  current treatment = null ;  return ;   }  current treatment =  (  treatment manager ) conference treatments . get ( 0 )  ;  current treatment . add treatment done listener ( this )  ;  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( "whisper group "  +  id  +  "  starting first treatment " +  current treatment . get id (  )  )  ;   }   }  
dh session key builder   (  )  {  return    dh factory . get builder (  )  ;   }  
@ override public void   (  disposable d )  {  this . d = d ;  if  ( cancelled )   {  d . dispose (  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . zip array ( new  function <  object[]  object >  (  )  {  @ override public  object apply (   object[] v )  {  return 1 ;   }   }  
  (  unicast subject < t >  w boolean open )  {  this . w = w ;  this . open = open ;   }  
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  drain loop (  )  ;   }   }  
public void   (  string url )  {  if  (    got date  <  max   date   sets )     attempt started =  system . current time millis (  )  ;   }  
public   (  callable <  ?  extends d >  resource supplier  function <  ?  super d  ?  extends  publisher <  ?  extends t >  >  source supplier  consumer <  ?  super d >  disposer boolean eager )  {  this . resource supplier = resource supplier ;  this . source supplier = source supplier ;  this . disposer = disposer ;  this . eager = eager ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe . just ( 1 )  . delay (  flowable . just ( 1 )  )  )  ;   }  
private boolean   ( int[] data )  {   string dtmf keys = dtmf decoder . process data ( data )  ;  if  (  call handler . dtmf suppression (  )   =  =  true && cp . dtmf suppression (  )   =  =  true )   {  if  ( dtmf decoder . dtmf detected (  )  )   {  if  ( is auto muted  =  =  false )   {  if  ( trace call ||  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  cp  +  " dtmf detected  setting automute " )  ;   }  is auto muted = true ;  flush contributions (  )  ;   }   }  else  {  if  ( is auto muted  =  =  true )   {  if  ( trace call ||  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  cp  +  " automute now false" )  ;   }   }  is auto muted = false ;   }   }  if  ( dtmf keys  !  =  null )   {  process dtmf keys ( dtmf keys )  ;  if  ( trace call ||  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  cp  +  " processed dtmf packet" +  " with key " +  dtmf keys +  " dtmf packets " +  dtmf packets )  ;   }  is auto muted = false ;  return true ;   }  if  ( is auto muted )   {  return true ;   }  return false ;   }  
@ test public void   (  )  {   flowable <  string >  skip =  flowable . just ( "one" "two" "three" )  . skip ( 1 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  skip . subscribe ( observer )  ;  verify ( observer never ( 
@ override public  user   (  string username )  throws  user not found exception  {  logger . finest ( "load user" )  ;  return user list . get ( username )  ;   }  
public  status   (  presence type xmpp status )  {  if  ( xmpp status  =  =   presence type . available )   {  return  status . available ;   }  else if  ( xmpp status  =  =   presence type . away )   {  return  status . brb ;   }  else if  ( xmpp status  =  =   presence type . xa )   {  return  status . steppedout ;   }  else if  ( xmpp status  =  =   presence type . dnd )   {  return  status . busy ;   }  else if  ( xmpp status  =  =   presence type . chat )   {  return  status . available ;   }  else if  ( xmpp status  =  =   presence type . unavailable )   {  return  status . offline ;   }  else  {  return  status . available ;   }   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  observer )  {  observer
public  string   (  )  {  return protocol ;   }  
public boolean   (  )  {  return false ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . error ( new  test exception (  )  )  . on error return ( new  function <  throwable  object >  (  )  {  @ override public  object apply (   throwable e )  {  retur
public void   (  string value )  {  set header ( http . transfer   encoding value )  ;   }  
@ override protected void   ( byte[] b int off int len )  throws  signature exception  {  if  ( one shot mode )   {  if  ( one shot bytes  !  =  null )  throw new  signature exception ( "update (  )  already called" )  ;  one shot bytes = b ;  one shot of
public  node   (  input stream in stream )  throws  parser exception  {  org . cybergarage . xml .  node root = null ;  try  {   document builder factory factory =  document builder factory . new instance (  )  ;  factory . set validating ( false )  ;  factory . set namespace aware ( true )  ;  factory . set expand entity references ( false )  ;  try  {  try  {  factory . set feature ( "http: /  / xml . org / sax / features / external - general - entities" false )  ;   }  catch  (   parser configuration exception pce )   {   }  try  {  factory . set feature ( "http: /  / xml . org / sax / features / external - parameter - entities" false )  ;   }  catch  (   parser configuration exception pce )   {   }  try  {  factory . set feature ( "http: /  / apache . org / xml / features / disallow - doctype - decl" true )  ;   }  catch  (   parser configuration exception pce )   {   }  try  {  factory . set feature ( "http: /  / apache . org / xml / features / nonvalidating / load - external - dtd" false )  ;   }  catch  (   parser configuration exception pce )   {   }   }  catch  (   abstract method error ame )   {   }   document builder builder = factory . new document builder (  )  ;  builder . set entity resolver ( new  blanking resolver (  )  )  ;   input source in src = new  input source ( new  null filter input stream ( in stream )  )  ;   document doc = builder . parse ( in src )  ;  org . w3c . dom .  element doc elem = doc . get document element (  )  ;  if  ( doc elem  !  =  null )  root = parse ( root doc elem )  ;   }  catch  (   exception e )   {  throw new  parser exception ( e )  ;   }  return root ;   }  
public boolean   (  )  {  final byte[] s = to byte array (  )  ;  return  utils . equal ( s zero )   =  =  0 ;   }  
private int   (  request queue queue  map <  string  list <  string >  >  meta data )  {  int current match = 0 ;  try  {   db properties queue props = queue . get properties (  )  ;  for  (   string name : meta data . key set (  )  )   {   list <  string >  values = meta data . get ( name )  ;   string queue prop = queue props . get property ( name )  ;  for  (   string value : values )   {  if  ( queue prop  !  =  null && queue prop . equals ignore case ( value )  )   {  current match +  +  ;  break ;   }   }   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  return current match ;   }  
public static  runtime exception   (  throwable error )  {  if  ( error instanceof  error )   {  throw  (  error ) error ;   }  if  ( error instanceof  runtime exception )   {  return  (  runtime exception ) error ;   }  return new  runtime exception ( error )  ;   }  
public void   ( boolean ssl enabled )  {  this . ssl enabled = ssl enabled ;  properties . put ( "ldap . ssl enabled"  boolean . to string ( ssl enabled )  )  ;   }  
public static  plc factory   (  )  {  if  ( plc factory  =  =  null )   {  plc factory = new  plc factory (  )  ;   }  return plc factory ;   }  
@ override public boolean   (  )  throws sql exception  {  return true ;   }  
public static  message   (  string name long account id long mailbox id boolean add body boolean save it  context context boolean starred boolean read )  {   message message = new  message (  )  ;  message . m display name = name ;  message . m time stamp = 100  +  name . length (  )  ;  message . m subject = "subject "  +  name ;  message . m flag read = read ;  message . m flag seen = read ;  message . m flag loaded =  message . flag   loaded   unloaded ;  message . m flag favorite = starred ;  message . m flag attachment = true ;  message . m flags = 0 ;  message . m server id = "serverid "  +  name ;  message . m server time stamp = 300  +  name . length (  )  ;  message . m message id = "messageid "  +  name ;  message . m mailbox key = mailbox id ;  message . m account key = account id ;  message . m from = "from "  +  name ;  message . m to = "to "  +  name ;  message . m cc = "cc "  +  name ;  message . m bcc = "bcc "  +  name ;  message . m reply to = "replyto "  +  name ;  message . m meeting info = "123"  +  account id  +  mailbox id +  name . length (  )  ;  if  ( add body )   {  message . m text = "body text "  +  name ;  message . m html = "body html "  +  name ;  message . m source key = 400  +  name . length (  )  ;   }  if  ( save it )   {  message . save ( context )  ;   }  return message ;   }  
public static void   (  output stream raw stream int num bytes long value )  throws  data format exception  io exception  {  if  ( num bytes  <  =  0 || num bytes  >  8 )  throw new  data format exception ( " bad byte count "  +  num bytes )  ;  if  ( value  <  0 )  throw new  data format exception ( " value is negative  ( "  +  value  +  " ) " )  ;  for  ( int i =  ( num bytes  -  1 )  * 8 ;  i  >  =  0 ;  i -  = 8 )   {  byte cur =  ( byte )  ( value  >  >  i )  ;  raw stream . write ( cur )  ;   }   }  
@ test public void   (  )  {  final  observer <  ?  > [] sub =  { null }  ;  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  s )  {  sub[0] = s ;   }   }   . publish (  )  . connect ( 
protected boolean   (  socket socket )  {  try  {   input stream is = socket . get input stream (  )  ;  socket . set so timeout ( connect   timeout )  ;  boolean rv = is . read (  )   =  =  i2p client . protocol   byte ;  socket . set so timeout ( 0 )  ;  return rv ;   }  catch  (  io exception ioe )   {   }  if  (    log . should log (  log . warn )  )     log . warn ( " peer did not authenticate themselves as i2cp quickly enough  dropping" )  ;  return false ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  functions . empty consumer (  )   functions . empty consumer (  )   functions . empty   action null )  ;   }  
public static  < t >  consumer < t >    (  consumer <  ?  super  notification < t >  >  on notification )  {  return new  notification on next < t >  ( on notification )  ;   }  
public void   ( i2cp message message i2p session impl session )  {  if  (    log . should log (  log . debug )  )     log . debug ( " handle message "  +  message )  ;   dest reply message msg =  (  dest reply message ) message ;   destination d = msg . get destination (  )  ;  if  ( d  !  =  null )   {  session . dest received ( d )  ;   }  else  {   hash h = msg . get hash (  )  ;  if  ( h  !  =  null )  session . dest lookup failed ( h )  ;   }   }  
@ test public void   (  )  {  assert equals ( 1  flowable . just ( 1 2 )  . blocking first ( 3 )  . int value (  )  )  ;   }  
public void   (  data output out long[] array )  throws io exception  {  write object ( out array )  ;   }  
@ test public void   (  )  {   test observer <  list <  integer >  >  to = new  test observer <  list <  integer >  >  (  )  ;   buffer exact observer <  integer  list <  integer >  >  sub = new  buffer exact observer <  integer  list <  integer >  >  ( t
@ override public void   (  subscriber <  ?  super t >  child )  {  source . subscribe ( child )  ;  if  ( clients . increment and get (  )   =  =  number of subscribers )   {  source . connect ( connection )  ;   }   }  
public void   ( final boolean apply eamss filtering )  {  this . apply eamss filtering = apply eamss filtering ;   }  
@ setup public void   (  )  {   integer[] source array = new  integer[count] ;   arrays . fill ( source array 777 )  ;   observable <  integer >  source =  observable . from array ( source array )  ;  observable plain = source . flat map ( new  function <
private boolean   (  )  {  return temp char  !  =  0 || bits read  >  =  6 ;   }  
@ override public void   ( t t )  {  long r = remaining ;  if  ( r  >  0l )   {  remaining =  -  - r ;  actual . on next ( t )  ;  if  ( r  =  =  0l )   {  upstream . cancel (  )  ;  actual . on complete (  )  ;   }   }   }  
public  collection <  client session >    (  string username )  {   list <  client session >  session list = new  array list <  >  (  )  ;  if  ( username  !  =  null && server name  !  =  null )   {   list < jid >  addresses = routing table . get routes ( new jid ( username server name null true )  null )  ;  for  (  jid address : addresses )   {  session list . add ( routing table . get client route ( address )  )  ;   }   }  return session list ;   }  
public  property   ( int n )  {  return  (  property ) get ( n )  ;   }  
public synchronized long   (  )  {  return    sent relay tag ;   }  
public void   ( int parameter index  row id x )  throws sql exception  {  pstmt . set row id ( parameter index x )  ;   }  
@ override public void   (  collection < jid >  userji ds )  {  for  (  jid userjid : userji ds )   {  add sysadmin ( userjid )  ;   }   }  
public static boolean   (  )  {  return clustering started ;   }  
public  socket channel   (  )  throws io exception  {     socket . get input stream (  )  . close (  )  ;  return this ;   }  
public void   (  )  throws io exception  {   string domain name = xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;  try  {   inet socket address isa local = call handler . get receive address (  )  ;  int localrtp port = isa local . get port (  )  ;  int localrtcp port = localrtp port  +  1 ;  int remotertp port = nextrtp port ;  int remotertcp port = remotertp port  +  1 ;  synchronized  ( nextrtp port )   {  nextrtp port +  +  ;  if  ( nextrtp port  >  stoprtp port )  nextrtp port = startrtp port ;   }  set state (  call state . invited )  ;  iq iq = new iq ( iq .  type . set )  ;  iq . set from ( cp . get call owner (  )  )  ;  iq . set to ( domain name )  ;   string id = "rayo - "  +   system . current time millis (  )  ;   element colibri = iq . set child element ( "colibri" "urn:xmpp:rayo:colibri:1" )  ;  colibri . add attribute ( "videobridge" cp . get conference id (  )  )  ;  colibri . add attribute ( "localrtpport"  string . value of ( remotertp port )  )  ;  colibri . add attribute ( "localrtcpport"  string . value of ( remotertcp port )  )  ;  colibri . add attribute ( "remotertpport"  string . value of ( localrtp port )  )  ;  colibri . add attribute ( "remotertcpport"  string . value of ( localrtcp port )  )  ;  colibri . add attribute ( "codec" cp . get media preference (  )  . equals ( "pcm / 48000 / 2" )   ?  "opus" : "pcmu" )  ;   rayo plugin . component . send packet ( iq )  ;  set state (  call state . answered )  ;   inet socket address isa remote = new  inet socket address ( "localhost" remotertp port )  ;  set endpoint address ( isa remote  ( byte )  ( cp . get media preference (  )  . equals ( "pcm / 48000 / 2" )   ?  111 : 0 )   ( byte ) 0  ( byte ) 0 )  ;  set state (  call state . established )  ;   }  catch  (   exception e )   {   logger . println ( " call "  +  cp  +  ":  videobridge call agent: initiate call exception " )  ;  e . print stack trace (  )  ;   }   }  
public void   (  string connection manager name )  {   map <  streamid  local client session >  sessions = sessions by manager . get ( connection manager name )  ;  if  ( sessions  =  =  null )   {  synchronized  ( connection manager name . intern (  )  )   {  sessions = sessions by manager . get ( connection manager name )  ;  if  ( sessions  =  =  null )   {  sessions = new  concurrent hash map <  >  (  )  ;  sessions by manager . put ( connection manager name sessions )  ;   }   }   }   }  
public void   ( final  truth and call states truth and call states final double count )  {  this . counter . increment ( truth and call states count )  ;   }  
@ override public  list <  string >    (  )  {  return    manager . get most recent error messages (  )  ;   }  
public static  uri .  builder   (  string path )  {  final  uri .  builder b = new  uri .  builder (  )  ;  b . scheme ( activity   intent   scheme )  ;  b . authority ( activity   intent   host )  ;  b . path ( path )  ;  return b ;   }  
private static int   (  mail prefs mail prefs )  {  return mail prefs . get show sender images (  )   ?  ui provider .  conversation list icon . sender   image : ui provider .  conversation list icon . none ;   }  
public synchronized  sdp info   (  string sdp data )  throws  parse exception  {   string t = "c = in ip4 " ;  int start = sdp data . index of ( t )  ;  int finish = sdp data . index of ( "\r" start )  ;  if  ( start  <  0 || finish  <  0 )   {  throw new  parse exception ( " invalid remote sdp" 0 )  ;   }   string remote host = sdp data . substring ( start  +  t . length (  )  finish )  . trim (  )  ;  t = "m = audio" ;  start = sdp data . index of ( t )  ;   string s = sdp data . substring ( start  +  t . length (  )  )  ;  t = "rtp / avp " ;  finish = s . index of ( t )  ;   string port = s . substring ( 0 finish )  . trim (  )  ;  if  ( start  <  0 || finish  <  0 )   {  throw new  parse exception ( " invalid remote sdp" 0 )  ;   }  int remote port ;  try  {  remote port =  integer . parse int ( port )  ;   }  catch  (   number format exception e )   {   logger . println ( " invalid remote port in sdp "  +  port  +  " sdp data " +  sdp data )  ;  throw new  parse exception ( " invalid remote port in sdp "  +  port  +  " sdp data " +  sdp data 0 )  ;   }  start = finish  +  t . length (  )  ;  finish = s . index of ( "\r\n" )  ;  s = s . substring ( start finish )  ;   string[] payloads = s . split ( "[\" \"]" )  ;   string[] sdp = sdp data . split ( "[\r\n]" )  ;   media info media info = new  media info (  rtp packet . pcmu   payload 0 8000 1 false )  ;  supported media . add ( media info )  ;  byte telephone event payload = 0 ;  for  ( int i = 0 ;  i  <  sdp . length ;  i +  +  )   {  s = sdp[i] ;  if  ( s . index of ( "a = rtpmap:" )   !  =  0 )   {  continue ;   }   rtpmap parser rtpmap parser = new  rtpmap parser ( s )  ;  media info = rtpmap parser . get media info (  )  ;  if  ( media info  =  =  null )   {  continue ;   }  if  ( media info . is telephone event payload (  )  )   {  telephone event payload = media info . get payload (  )  ;   }  supported media . add ( media info )  ;   }  media info = null ;  boolean preferred media specified = false ;  t = "a =  preferred payload:" ;  if  (  ( start = sdp data . index of ( t )  )   >  =  0 )   {  s = sdp data . substring ( start  +  t . length (  )  )  ;  finish = s . index of ( "\r\n" )  ;  if  ( finish  >  0 )   {  int payload ;  s = s . substring ( 0 finish )  ;  payload =  integer . parse int ( s )  ;  try  {  media info = get media info ( payload )  ;   }  catch  (   parse exception e )   {   }  preferred media specified = true ;   }   }  if  ( media info  =  =  null )   {  for  ( int i = 0 ;  i  <  payloads . length ;  i +  +  )   {  int payload = 0 ;  try  {  payload =  integer . parse int ( payloads[i] )  ;   }  catch  (   number format exception e )   {   logger . println ( " invalid payload in rtpmap: "  +  payloads[i] )  ;  throw new  parse exception ( " invalid payload int rtpmap: "  +  payloads[i] 0 )  ;   }  if  ( payload  !  =  0 &&  ( payload  <  96 || payload  >  127 )  )   {  continue ;   }   media info m = null ;  try  {  m = get media info ( payload )  ;   }  catch  (   parse exception e )   {   logger . println ( "ignoring undefined payload "  +  payload )  ;  continue ;   }  if  ( m . is telephone event payload (  )  )   {  continue ;   }  if  ( media info  =  =  null || media info . get sample rate (  )   <  m . get sample rate (  )  )   {  media info = m ;   }  else if  ( media info . get sample rate (  )   =  =  m . get sample rate (  )  )   {  if  ( media info . get channels (  )   <  m . get channels (  )  )   {  media info = m ;   }   }   }   }  if  ( media info  =  =  null )   {   logger . println ( " no suitable media payload in sdp data "  +  sdp data )  ;  throw new  parse exception ( " no suitable media payload in sdp data "  +  sdp data 0 )  ;   }  sdp info = new  sdp info ( remote host remote port telephone event payload supported media media info preferred media specified )  ;  t = "a = transmit payload:" ;  if  (  ( start = sdp data . index of ( t )  )   >  =  0 )   {  s = sdp data . substring ( start  +  t . length (  )  )  ;  finish = s . index of ( "\r\n" )  ;  if  ( finish  >  0 )   {  int payload ;  s = s . substring ( 0 finish )  ;  payload =  integer . parse int ( s )  ;  try  {  sdp info . set transmit media info ( get media info ( payload )  )  ;   logger . println ( " set xmit media info to "  +  sdp info . get transmit media info (  )  )  ;   }  catch  (   parse exception e )   {   }   }   }  int ix ;  t = "a = transmit media info ok" ;  if  (  ( ix = sdp data . index of ( t )  )   >  =  0 )   {  sdp info . set transmit media info ok ( true )  ;   }  t = "a = user name:" ;  if  (  ( ix = sdp data . index of ( t )  )   >  =  0 )   {   string user name = sdp data . substring ( ix  +  t . length (  )  )  ;  finish = user name . index of ( "\n" )  ;  if  ( finish  >  0 )   {  sdp info . set user name ( user name . substring ( 0 finish )  . trim (  )  )  ;   }  else  {  sdp info . set user name ( user name . substring ( 0 )  . trim (  )  )  ;   }   }  t = "a = call id:" ;  if  (  ( ix = sdp data . index of ( t )  )   >  =  0 )   {   string call id = sdp data . substring ( ix  +  t . length (  )  )  ;  finish = call id . index of ( "\n" )  ;  if  ( finish  >  0 )   {  sdp info . set call id ( call id . substring ( 0 finish )  . trim (  )  )  ;   }   }  t = "a = conference id:" ;  if  (  ( ix = sdp data . index of ( t )  )   >  =  0 )   {   string conference id = sdp data . substring ( ix  +  t . length (  )  )  ;  finish = conference id . index of ( "\n" )  ;  if  ( finish  >  0 )   {  sdp info . set conference id ( conference id . substring ( 0 finish )  . trim (  )  )  ;   }  else  {  sdp info . set conference id ( conference id . substring ( 0 )  . trim (  )  )  ;   }   }  if  ( sdp data . index of ( "a = distributed bridge" )   >  =  0 )   {  sdp info . set distributed bridge (  )  ;   }  t = "a = rtcp address:" ;  if  (  ( ix = sdp data . index of ( t )  )   >  =  0 )   {  s = sdp data . substring ( ix  +  t . length (  )  )  ;  finish = s . index of ( "\n" )  ;  if  ( finish  >  0 )   {  s = s . substring ( 0 finish )  . trim (  )  ;   }  else  {  s = s . substring ( 0 )  . trim (  )  ;   }   string[] tokens = s . split ( ":" )  ;  if  ( tokens . length  !  =  2 )   {  throw new  parse exception ( " invalid rtcp address in sdp "  +  " sdp data "  +  sdp data 0 )  ;   }  try  {  sdp info . set rtcp address ( new  inet socket address (  inet address . get by name ( tokens[0] )   integer . parse int ( tokens[1] )  )  )  ;   }  catch  (   unknown host exception e )   {  throw new  parse exception ( " invalid rtcp host address in sdp "  +  " sdp data "  +  sdp data 0 )  ;   }  catch  (   number format exception e )   {  throw new  parse exception ( " invalid rtcp port in sdp "  +  " sdp data "  +  sdp data 0 )  ;   }   }  return sdp info ;   }  
public  string   (  )  {  return this . current line ;   }  
  (  person person  flowable <  person fruit >  fruits )  {  this . person = person ;  this . fruits = fruits ;   }  
public  http session   ( long rid  inet address address  streamid id  http connection connection  locale language )  throws  unauthorized exception  {  if  ( server name  =  =  null )   {  throw new  unauthorized exception ( " server not initialized" )  ;   }   packet deliverer backup deliverer = server . get packet deliverer (  )  ;   http session session = new  http session ( backup deliverer server name address id rid connection language )  ;   connection conn = session . get connection (  )  ;  conn . init ( session )  ;  conn . register close listener ( client session listener session )  ;  local session manager . get pre authenticated sessions (  )  . put ( session . get address (  )  . get resource (  )  session )  ;  connections counter . increment and get (  )  ;  return session ;   }  
@ override public  iterator <  user >    (  )  {  return new  user iterator (  )  ;   }  
@ override public  iterable <  vcf file segment >    ( final  file vcf )  {  return  fluent iterable . from ( underlying strategy . for vcf ( vcf )  )  . transform and concat ( new  function <  vcf file segment  iterable <  ?  extends  vcf file segment > 
@ suppress warnings ( "unchecked" )  public  object[]   ( int start k key  skip list < k v >  sl )  {   object[] res = null ;   skip levels < k v >  slvls = null ;  for  ( int i =  math . min ( start levels . length  -  1 )  ;  i  >  =  0 ;  i -  -  )   {
public  string   (  )  {  return get header value ( http . location )  ;   }  
protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;  if  ( reader . get file header (  )  . get sort order (  )   !  =  sam file header .  sort order . coordinate )   {  throw new sam exception ( " input must be coordinate - sorted for this program to run .   found: "  +  reader . get file header (  )  . get sort order (  )  )  ;   }  final sam file writer writer = new sam file writer factory (  )  . makesam orbam writer ( reader . get file header (  )  true output )  ;  writer . set progress logger ( new  progress logger ( log  ( int ) 1e7 " wrote" "records" )  )  ;  final  reference sequence file walker ref seq walker = new  reference sequence file walker ( reference   sequence )  ;   stream support . stream ( reader . spliterator (  )  false )  . peek ( rec  -  >  fix record ( rec ref seq walker )  )  . for each ( writer::add alignment )  ;   closer util . close ( reader )  ;  writer . close (  )  ;  return 0 ;   }  
public static i pv6 config   (  string cfg )  {  if  ( cfg  =  =  null )  return default   ipv6   config ;  i pv6 config c = by   name . get ( cfg )  ;  if  ( c  !  =  null )  return c ;  return default   ipv6   config ;   }  
void   ( u value )  {  if  ( get (  )   =  =  0 && compare and set ( 0 1 )  )   {  long r = requested . get (  )  ;   simple queue < u >  q = queue ;  if  ( r  !  =  0l &&  ( q  =  =  null || q . is empty (  )  )  )   {  actual . on next ( value )  ;  if  ( r  !  =   long . max   value )   {  requested . decrement and get (  )  ;   }  if  ( max concurrency  !  =   integer . max   value &&  ! cancelled &&  +  + scalar emitted  =  =  scalar limit )   {  scalar emitted = 0 ;  upstream . request ( scalar limit )  ;   }   }  else  {  if  ( q  =  =  null )   {  q = get main queue (  )  ;   }  if  (  ! q . offer ( value )  )   {  on error ( new  illegal state exception ( " scalar queue full ?  ! " )  )  ;  return ;   }   }  if  ( decrement and get (  )   =  =  0 )   {  return ;   }   }  else  {   simple queue < u >  q = get main queue (  )  ;  if  (  ! q . offer ( value )  )   {  on error ( new  illegal state exception ( " scalar queue full ?  ! " )  )  ;  return ;   }  if  ( get and increment (  )   !  =  0 )   {  return ;   }   }  drain loop (  )  ;   }  
@ override public void   (  observer <  ?  super t >  t )  {  source . subscribe ( new  debounce observer < t u >  ( new  serialized observer < t >  ( t )  debounce selector )  )  ;   }  
public synchronized static int   (  string name int default value )  {  int result = default value ;   string str = get property ( name )  ;  if  ( str  !  =  null )   {  try  {  result =  integer . parse int ( str )  ;   }  catch  (   number format exception nfe )   {  result = default value ;   }   }  return result ;   }  
public static void   ( boolean expression @ nullable  string error message template @ nullable  object .  .  .  error message args )  {  if  (  ! expression )   {  throw new  illegal argument exception ( format ( error message template error message args )  )  ;   }   }  
public void   (  throwable ignored )  {  debug ( "ignored" ignored )  ;   }  
@ override public void   (  )  {  clean up (  )  ;  session disconnected no reconnect ( null )  ;   }  
public void   ( byte message[]  hash from peer )  {     context . job queue (  )  . add job ( new  receive job ( from peer message    context )  )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   maybe . just ( 1 )  . do after success ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  throws  exceptio
@ override public boolean   (  )  {  return index  <  size ;   }  
private void   (  writer out  string builder buf  hash us double avg min dist  list <  router info >  ris  map <  hash  points >  points )  throws io exception  {   collections . sort ( ris new  router info routing key comparator ( us )  )  ;  double min = 256 ;  double max = 0 ;  double tot = 0 ;  double median = 0 ;  int count =  math . min ( max ris . size (  )  )  ;  boolean is even =  ( count % 2 )   =  =  0 ;  int med idx = is even  ?   ( count  /  2 )   -  1 :  ( count  /  2 )  ;  for  ( int i = 0 ;  i  <  count ;  i +  +  )   {   router info ri = ris . get ( i )  ;  double dist = render router info ( buf ri us false false )  ;  if  ( dist  <  avg min dist )   {  if  ( i  =  =  0 )   {   }  else if  ( i  =  =  1 )   {  buf . append ( " < p class = \"sybil   info\" >  < b >  not to worry  but above routers are closer than average minimum distance "  +  fmt . format ( avg min dist )   +  " <  / b >  <  / p > " )  ;   }  else if  ( i  =  =  2 )   {  buf . append ( " < p class = \"sybil   info\" >  < b >  possible  sybil  warning  -  above routers are closer than average minimum distance "  +  fmt . format ( avg min dist )   +  " <  / b >  <  / p > " )  ;   }  else  {  buf . append ( " < p class = \"sybil   info\" >  < b >  major  sybil  warning  -  above router is closer than average minimum distance "  +  fmt . format ( avg min dist )   +  " <  / b >  <  / p > " )  ;   }   }  if  ( dist  <  min )  min = dist ;  if  ( dist  >  max )  max = dist ;  tot +  = dist ;  if  ( i  =  =  med idx )  median = dist ;  else if  ( i  =  =  med idx  +  1 && is even )  median =  ( median  +  dist )   /  2 ;  double point = min   close  -  dist ;  if  ( point  >  0 )   {  point* = our   key   factor ;  add points ( points ri . get hash (  )  point " very close  ( "  +  fmt . format ( dist )   +  " )  to our key " +  us . to base64 (  )  )  ;   }  if  ( i  >  =  max  -  1 )  break ;   }  double avg = tot  /  count ;  buf . append ( " < p id = \"sybil   totals\" >  < b >  totals for "  +  count  +  " floodfills: &nbsp ;  <  / b >  < span class = \"netdb   name\" > min: <  / span  >  " +  fmt . format ( min )  +  "&nbsp ;   < span class = \"netdb   name\" > avg: <  / span >  " +  fmt . format ( avg )  +  "&nbsp ;   < span class = \"netdb   name\" > median: <  / span >  " +  fmt . format ( median )  +  "&nbsp ;   < span class = \"netdb   name\" > max: <  / span >  " +  fmt . format ( max )  +  " <  / p > \n" )  ;  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;  buf . set length ( 0 )  ;   }  
@ test public void   (  )  {   jdbi jdbi with key col and val col = db rule . get jdbi (  )  . set map key column ( "key   c" )  . set map value column ( "val   c" )  ;   boolean executed = jdbi with key col and val col . with handle ( h  -  >   {   hash 
@ override public void   (  subscriber <  ?  super  flowable < t >  >  s )  {  if  ( skip  =  =  size )   {  source . subscribe ( new  window exact subscriber < t >  ( s size buffer size )  )  ;   }  else if  ( skip  >  size )   {  source . subscribe ( ne
@ override public  string   (  http servlet request request  http servlet response response )  {   object start time = request . get attribute ( start   time   attribute )  ;   string response time = "" ;  if  ( start time  !  =  null )   {  response time
public void   (  )  {  try  {   wrapper manager . signal stopped (    exit code )  ;   }  catch  (   throwable t )   {  t . print stack trace (  )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject .  <  integer > create (  )  . single element (  )  . do on event ( new  bi consumer <  integer  throwable >  (  )  {  @ override public void accept (   integer v   throwable e
public   (  timer task task )  {  this . task = task ;   }  
@ override public int   (  )  {  return delivery   mode   local ;   }  
  (  zip coordinator < t  ?  >  parent int index )  {  this . parent = parent ;  this . index = index ;   }  
public  safe subscriber <  object >    (  )  {  return new  safe subscriber <  object >  ( this )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  rp =  replay subject . create with size ( 2 )  ;  rp . on next ( 1 )  ;  rp . on next ( 2 )  ;  rp . on next ( 3 )  ;  rp . take ( 1 )  . test (  )  . assert result ( 2 )  ;   }  
public boolean   (  )  {  return    already changed ;   }  
@ override public int   (  )  {  return 1 ;   }  
@ override public void   (  subscriber <  ?  super  integer >  sub )  {  sub . on subscribe ( new  boolean subscription (  )  )  ;  counter . increment and get (  )  ;  sub . on next ( 1 )  ;  sub . on next ( 2 )  ;  sub . on complete (  )  ;   }  
@ test @ ignore ( " null values are no longer permitted" )  public void   (  )  {   system . out . println ( "merge with terminal event after unsubscribe" )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   flowable <  str
@ override public  list <  router address >    (  )  {  rebuild external address ( false )  ;  return get current addresses (  )  ;   }  
@ test public void   (  )  {   maybe .  <  integer > empty (  )  . delay subscription ( 100  time unit . milliseconds )  . test (  )  . await done ( 5  time unit . seconds )  . assert result (  )  ;   }  
public   (  output stream target )  throws io exception  {  super ( target )  ;   }  
public void   (  service service )  {  if  ( services . add ( service )  )   {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( "insert into of external services values  (  ?    ?    ?    ?    ?    ?    ?    ?    ?    ?  ) " )  ;  pstmt . set long ( 1 service . get database id (  )  )  ;  if  ( service . get name (  )   =  =  null || service . get name (  )  . is empty (  )  )   {  pstmt . set null ( 2  types . varchar )  ;   }  else  {  pstmt . set string ( 2 service . get name (  )  )  ;   }  if  ( service . get host (  )   =  =  null || service . get host (  )  . is empty (  )  )   {  pstmt . set null ( 3  types . varchar )  ;   }  else  {  pstmt . set string ( 3 service . get host (  )  )  ;   }  if  ( service . get port (  )   =  =  null )   {  pstmt . set null ( 4  types . integer )  ;   }  else  {  pstmt . set int ( 4 service . get port (  )  )  ;   }  if  ( service . get restricted (  )   =  =  null )   {  pstmt . set null ( 5  types . boolean )  ;   }  else  {  pstmt . set boolean ( 5 service . get restricted (  )  )  ;   }  if  ( service . get transport (  )   =  =  null || service . get transport (  )  . is empty (  )  )   {  pstmt . set null ( 6  types . char )  ;   }  else  {  pstmt . set string ( 6 service . get transport (  )  )  ;   }  if  ( service . get type (  )   =  =  null || service . get type (  )  . is empty (  )  )   {  pstmt . set null ( 7  types . char )  ;   }  else  {  pstmt . set string ( 7 service . get type (  )  )  ;   }  if  ( service . get raw username (  )   =  =  null || service . get raw username (  )  . is empty (  )  )   {  pstmt . set null ( 8  types . varchar )  ;   }  else  {  pstmt . set string ( 8 service . get raw username (  )  )  ;   }  if  ( service . get raw password (  )   =  =  null || service . get raw password (  )  . is empty (  )  )   {  pstmt . set null ( 9  types . varchar )  ;   }  else  {  pstmt . set string ( 9 service . get raw password (  )  )  ;   }  if  ( service . get shared secret (  )   =  =  null || service . get shared secret (  )  . is empty (  )  )   {  pstmt . set null ( 10  types . varchar )  ;   }  else  {  pstmt . set string ( 10 service . get shared secret (  )  )  ;   }  pstmt . execute update (  )  ;   log . info ( " added  {  }  service at  {  }  . " service . get type (  )  service . get host (  )  )  ;   }  catch  (   exception e )   {   log . error ( " unable to persists service  (  {  }  at  {  }  )  in database ! " service . get type (  )  service . get host (  )  e )  ;  services . remove ( service )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }   }  
@ test public void   (  )  {   executor service exec =  executors . new fixed thread pool ( 3 )  ;   scheduler s =  schedulers . from ( exec )  ;  try  {   callable <  list <  integer >  >  as = new  callable <  list <  integer >  >  (  )  {  @ override p
public static void   (  string args[] )  {   list <  string >  classes = new  array list <  string >  ( rclasses . size (  )   +  classes . size (  )  )  ;  classes . add all ( rclasses )  ;  classes . add all ( classes )  ;  if  ( args . length  >  0 )   {  exec ( args classes )  ;   }  usage ( classes )  ;   system . exit ( 1 )  ;   }  
@ override public  arguments   (  )  {  return new  arguments ( this )  ;   }  
@ override public  observable source <  integer >    (  observable <  integer >  w )  throws  exception  {  return w . take ( 1 )  ;   }  
public  optional <  argument >    (  type type  object value )  {  return get config (  arguments . class )  . find for ( type value )  ;   }  
public static  character seteci   ( int value )  throws  format exception  {  if  ( value  <  0 || value  >  =  900 )   {  throw  format exception . get format instance (  )  ;   }  return value   to   eci . get ( value )  ;   }  
public  string   (  )  {  if  ( config  !  =  null )  return config ;  reload (  )  ;  return config ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  replay subject <  long >  replay =  replay subject . create unbounded (  )  ;   thread source = new  thread ( new  runnable (  )  {  @ override public void run (  )  {   observable . unsa
@ test public void   (  )  {  assert same (  maybe . empty (  )   maybe . empty (  )  )  ;   }  
@ override public jid   (  )  {  return realjid ;   }  
public  rate stat   (  )  {  return    db introduction ;   }  
@ override public void   (  )  {  subscriber . on complete (  )  ;   }  
public   (  string username  string password  date expires )  {  this . username = username ;  this . password = password ;  this . expires = expires ;   }  
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
int   (  )  {     update lock . read lock (  )  . lock (  )  ;  try  {  return locked   get current participating bandwidth (  )  ;   }  finally  {     update lock . read lock (  )  . unlock (  )  ;   }   }  
@ test public void   (  )  {   replay processor <  integer >  async =  replay processor . create with size ( 1 )  ;   test exception te = new  test exception (  )  ;  async . on error ( te )  ;   flowable processor <  integer >  serial = async . to serial
public byte[]   ( byte data[]  private key target private key  session key manager key manager )  throws  data format exception  {  if  ( data  =  =  null )   {  if  (    log . should log (  log . error )  )     log . error ( " null data being decrypted ? " )  ;  return null ;   }  else if  ( data . length  <  min   encrypted   size )   {  if  (    log . should log (  log . error )  )     log . error ( " data is less than the minimum size  ( "  +  data . length  +  "  <  " +  min   encrypted   size +  " ) " )  ;  return null ;   }  byte tag[] = new byte[32] ;   system . arraycopy ( data 0 tag 0 32 )  ;   session tag st = new  session tag ( tag )  ;   session key key = key manager . consume tag ( st )  ;   session key found key = new  session key (  )  ;   session key used key = new  session key (  )  ;   set <  session tag >  found tags = new  hash set <  session tag >  (  )  ;  byte decrypted[] = null ;  boolean was existing = false ;  if  ( key  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " decrypting existing session encrypted with tag: "  +  st . to string (  )   +  ": key: " +  key . to base64 (  )  +  ": " +  data . length +  " bytes " )  ;  decrypted = decrypt existing session ( data key target private key found tags used key found key )  ;  if  ( decrypted  !  =  null )   {     context . stat manager (  )  . update frequency ( "crypto . el gamalaes . decrypt existing session" )  ;  if  (  (  ! found tags . is empty (  )  )  &&  (    log . should log (  log . debug )  )  )     log . debug ( " elg / aes decrypt success with "  +  st  +  ": found tags: " +  found tags )  ;  was existing = true ;   }  else  {     context . stat manager (  )  . update frequency ( "crypto . el gamalaes . decrypt failed" )  ;  if  (    log . should log (  log . warn )  )   {     log . warn ( " elg decrypt fail: known tag ["  +  st  +  "]  failed decrypt" )  ;   }   }   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " key is not known for tag "  +  st )  ;  decrypted = decrypt new session ( data target private key found tags used key found key )  ;  if  ( decrypted  !  =  null )   {     context . stat manager (  )  . update frequency ( "crypto . el gamalaes . decrypt new session" )  ;  if  (  (  ! found tags . is empty (  )  )  &&  (    log . should log (  log . debug )  )  )     log . debug ( " elg decrypt success: found tags: "  +  found tags )  ;   }  else  {     context . stat manager (  )  . update frequency ( "crypto . el gamalaes . decrypt failed" )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " elg decrypt fail: unknown tag: "  +  st )  ;   }   }  if  (  ( key  =  =  null )  &&  ( decrypted  =  =  null )  )   {   }  if  (  ! found tags . is empty (  )  )   {  if  ( found key . get data (  )   !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " found key: "  +  found key . to base64 (  )   +  " tags: " +  found tags +  " was existing ?  " +  was existing )  ;  key manager . tags received ( found key found tags )  ;   }  else if  ( used key . get data (  )   !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " used key: "  +  used key . to base64 (  )   +  " tags: " +  found tags +  " was existing ?  " +  was existing )  ;  key manager . tags received ( used key found tags )  ;   }   }  return decrypted ;   }  
public void   (  file file )  throws io exception  {   print writer out = null ;  try  {  out = new  print writer ( new  output stream writer ( new gzip output stream ( new  secure file output stream ( file )  )  "utf - 8" )  )  ;  for  (   list <  comment >  l : map . values (  )  )   {  for  (   comment c : l )   {  out . println ( c . to persistent string (  )  )  ;   }   }  if  ( out . check error (  )  )  throw new io exception ( " failed write to "  +  file )  ;  modified = false ;   }  finally  {  if  ( out  !  =  null )  out . close (  )  ;   }   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as flowable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return  collections .  <  intege
@ override public  flowable <  integer >    (  flowable <  integer >  c )  throws  exception  {  return c . take until (  flowable . never (  )  )  ;   }  
public void   (  )  throws sql exception  {  cstmt . add batch (  )  ;   }  
@ test public void   (  )  {   single . merge (  single . just ( 1 )   single . just ( 2 )  )  . test (  )  . assert result ( 1 2 )  ;   }  
@ data provider ( name = "data test missing contig in reference" )  public  object[][]   (  )  {  return new  object[][] {  { false  liftover vcf . exit   code   when   contig   not   in   reference }   { true 0 }  }  ;   }  
public int   (  )  {  return encoding ;   }  
public  tunnel id   (  )  {  if  (    receive tunnel  =  =  null )     receive tunnel = get tunnel (    receive tunnel id )  ;  return    receive tunnel ;   }  
@ test public void   (  )  {   flowable . empty (  )  . first or error (  )  . test (  )  . assert no values (  )  . assert error (  no such element exception . class )  ;   }  
@ test public void   (  )  throws  exception  {  final  message message = new  message (  )  ;  message . set to ( "unittest@example . org / test" )  ;  message . add child element ( "unittest" "unit:test:namespace" )  ;  final  list <  packet >  packets 
public static void   (  string[] args )  throws  parse exception   servlet exception  {   repose container props props =  repose container util . parse args ( args )  ;   repose tomcat container container = new  repose tomcat container ( props )  ;  container . start repose (  )  ;   }  
public  element   (  )  {   element option =  document helper . create element ( q name . get ( "option" "jabber:x:data" )  )  ;  if  ( get label (  )   !  =  null )   {  option . add attribute ( "label" get label (  )  )  ;   }  if  ( get value (  )   !  =  null )   {  option . add element ( "value" )  . add text ( get value (  )  )  ;   }  return option ;   }  
public  string   (  )  {  if  (    refresh delay seconds  <  =  8 ||  config restart bean . get restart time remaining (  )   <   ( 1000 *  (    refresh delay seconds  +  30 )  )  )  return "" ;  return " < meta http - equiv = \"refresh\" content = \""  +   (    refresh delay seconds  -  3 )   +  "\" > " ;   }  
public boolean   (  imap element that )  {  if  ( that  =  =  null )   {  return false ;   }  return this . get class (  )   =  =  that . get class (  )  ;   }  
public void   ( boolean yes )  {     auto stoppable = yes ;   }  
public boolean   (  )  {  return  !  ( get presence manager (  )   =  =  null || getxmpp server (  )   =  =  null )  ;   }  
@ test public void   (  )  throws  interrupted exception  {   test observer <  string >  to = new  test observer <  string >  (  )  ;   observable . range ( 1 4000 )  . group by ( is   even2 )  . flat map ( new  function <  grouped observable <  boolean  
public int   (  )  {  return    entries . size (  )  ;   }  
@ override public void   (  subscriber <  ?  super  object >  t )  {  subscriber . set ( t )  ;   }  
public   (  )  {     delivery mode =  - 1 ;   }  
@ test @ ignore ( " fusion not supported yet" )  public void   (  )  {   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . any )  ;  final int[] call =  { 0 0 }  ;   observable . range ( 1 5 )  . do on next ( new  consumer <
static void   (  error correction level ec level int mask pattern  byte matrix matrix )  throws  writer exception  {   bit array type info bits = new  bit array (  )  ;  make type info bits ( ec level mask pattern type info bits )  ;  for  ( int i = 0 ;  i  <  type info bits . get size (  )  ;   +  + i )   {  boolean bit = type info bits . get ( type info bits . get size (  )   -  1  -  i )  ;  int x1 = type   info   coordinates[i][0] ;  int y1 = type   info   coordinates[i][1] ;  matrix . set ( x1 y1 bit )  ;  if  ( i  <  8 )   {  int x2 = matrix . get width (  )   -  i  -  1 ;  int y2 = 8 ;  matrix . set ( x2 y2 bit )  ;   }  else  {  int x2 = 8 ;  int y2 = matrix . get height (  )   -  7  +   ( i  -  8 )  ;  matrix . set ( x2 y2 bit )  ;   }   }   }  
public  jdbi collectors   (  collector factory factory )  {  factories . add ( 0 factory )  ;  return this ;   }  
public  string   (  )  {  if  ( version string  =  =  null )   {   string builder sb = new  string builder (  )  ;  sb . append ( major )  . append ( ' . ' )  . append ( minor )  . append ( ' . ' )  . append ( micro )  ;  if  ( status  =  =   release status .  snapshot )   {  if  ( status version  >  =  0 )   {  sb . append ( ' . ' )  . append ( status version )  ;   }  sb . append ( " - snapshot" )  ;   }  else if  ( status  !  =   release status .  release || status version  !  =   - 1 )   {  sb . append ( ' ' )  . append ( status )  ;  if  ( status version  >  =  0 )   {  sb . append ( ' ' )  . append ( status version )  ;   }   }  version string = sb . to string (  )  ;   }  return version string ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 5 )  . flat map iterable ( mapper 2 )  . subscribe ( ts )  ;  ts . assert values ( 1 2 2 3 3 4 4 5 5 6 )  ;  ts . assert no
public fifo bandwidth limiter   (  )  {  return    bandwidth limiter ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  intege
@ override protected  string[]   (  )  {  final  list <  string >  error msgs = new  array list <  string >  (  )  ;  if  ( max   mismatch   rate  <  0 || max   mismatch   rate  >  1 )   {  error msgs . add ( "max   mismatch   rate must be in the range of
public   ( final  set <  metric accumulation level >  accumulation levels final  list < sam read group record >  sam rg records final  reference sequence file ref file final  file per target coverage final  file per base coverage final  interval list target intervals final  interval list probe intervals final  string probe set name final int near probe distance final int minimum mapping quality final int minimum base quality final boolean clip overlapping reads final boolean no side effects final int coverage cap final int sample size )  {  this . per target coverage = per target coverage ;  this . per base coverage = per base coverage ;  this . probe set name = probe set name ;  this . near probe distance = near probe distance ;  this . all probes = probe intervals ;  this . all targets = target intervals ;  this . coverage cap = coverage cap ;  this . sample size = sample size ;  final  list <  interval >  unique baits = this . all probes . uniqued (  )  . get intervals (  )  ;  this . probe detector = new  overlap detector <  interval >  (  - this . near probe distance 0 )  ;  this . probe detector . add all ( unique baits unique baits )  ;  this . probe territory =  interval . count bases ( unique baits )  ;  final  list <  interval >  unique targets = this . all targets . uniqued (  )  . get intervals (  )  ;  target detector = new  overlap detector <  interval >  ( 0 0 )  ;  this . target detector . add all ( unique targets unique targets )  ;  this . target territory =  interval . count bases ( unique targets )  ;  int i = 0 ;  cov = new  coverage[unique targets . size (  ) ] ;  this . coverage by target for read = new  linked hash map <  interval  coverage >  ( unique targets . size (  )  * 2 0 . 5f )  ;  for  (  final  interval target : unique targets )   {  final  coverage coverage = new  coverage ( target 0 )  ;  this . coverage by target for read . put ( target coverage )  ;  cov[i +  + ] = coverage ;   }  long genome size accumulator = 0 ;  for  (  final sam sequence record seq : this . all probes . get header (  )  . get sequence dictionary (  )  . get sequences (  )  )   {  genome size accumulator +  = seq . get sequence length (  )  ;   }  this . genome size = genome size accumulator ;  if  ( ref file  !  =  null )   {  interval to gc = new  hash map <  interval  double >  (  )  ;  for  (  final  interval target : unique targets )   {  final  reference sequence rs = ref file . get subsequence at ( target . get contig (  )  target . get start (  )  target . get end (  )  )  ;  interval to gc . put ( target  sequence util . calculate gc ( rs . get bases (  )  )  )  ;   }   }  this . minimum mapping quality = minimum mapping quality ;  this . minimum base quality = minimum base quality ;  this . clip overlapping reads = clip overlapping reads ;  this . no side effects = no side effects ;  setup ( accumulation levels sam rg records )  ;   }  
public int   (  )  {  if  ( maximum allowed character  =  =  0 )   {  maximum allowed character = default maximum allowed character (  )  ;   }  return maximum allowed character ;   }  
@ deprecated private void   (  )  {  synchronized  (    lock10 )   {  if  (    hmac256  =  =  null )   {     hmac256 = new hmac256 generator ( this )  ;   }     hmac256 initialized = true ;   }   }  
void   (  )  {  disposables . dispose (  )  ;   }  
@ override public byte[]   (  )  {  byte rv[] = super . to byte array (  )  ;  if  ( rv  =  =  null )  throw new  runtime exception ( "unable to to byte array (  ) : "  +  to string (  )  )  ;  return rv ;   }  
@ override public void   (  )  {  w . schedule ( new  on complete (  )  delay unit )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
public void   (  string moo )  {     config . set use outproxy plugin ( true )  ;   }  
private void   (  )  {  group event listener = new  group event listener (  )  {  public void group created (   group group   map params )  {   }  public void group deleting (   group group   map params )  {   }  public void group modified (   group group   map params )  {   }  public void member added (   group group   map params )  {   string userjid =  (  string ) params . get ( "member" )  ;  jid jid = new jid ( userjid )  ;  if  (  ! agent manager . has agent ( jid )  )   {  for  (   workgroup workgroup : workgroups . values (  )  )   {  for  (   request queue queue : workgroup . get request queues (  )  )   {  if  ( queue . has group ( group )  )   {  agent manager . get agents ( group )  ;   }   }   }   }   }  public void member removed (   group group   map params )  {   }  public void admin added (   group group   map params )  {   }  public void admin removed (   group group   map params )  {   }   }   ;   group event dispatcher . add listener ( group event listener )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   serialized observer <  integer >  so = new  serialized observer <  integer >  ( to )  ;   disposable d =  disposables . empty (  )  ;  so . on subsc
@ xml element wrapper ( name = "owners" )  @ xml element ( name = "owner" )  public  list <  string >    (  )  {  return owners ;   }  
private void   (  )  throws io exception  {  if  (    header written )  return ;  if  ( debug )   system . out . println ( " writing header" )  ;  out . write ( header )  ;     header written = true ;   }  
@ override public  config registry   (  )  {  return config . get (  )  ;   }  
@ test @ ignore ( "subscribe (  )  can't throw" )  public void   (  )  {  perform test using with flowable factory error in on subscribe ( false )  ;   }  
  (  router context ctx  tunnel pool manager mgr  tunnel pool settings settings  tunnel pool alias of )  {  super ( ctx mgr settings null )  ;  if  ( settings . is exploratory (  )  )  throw new  illegal argument exception (  )  ;  if  ( settings . get alias of (  )   =  =  null )  throw new  illegal argument exception (  )  ;     alias of = alias of ;   }  
public static void   (  string args[] )  {   stream sink server server = null ;  switch  ( args . length )   {  case 0: server = new  stream sink server ( "data dir" "server . key" "localhost" 7654 3 )  ;  break ;  case 2: server = new  stream sink server ( args[0] args[1] )  ;  break ;  case 4: case 5: int handlers = 3 ;  if  ( args . length  =  =  5 )   {  try  {  handlers =  integer . parse int ( args[4] )  ;   }  catch  (  number format exception nfe )   {   }   }  try  {  int port =  integer . parse int ( args[1] )  ;  server = new  stream sink server ( args[2] args[3] args[0] port handlers )  ;   }  catch  (  number format exception nfe )   {   system . out . println ( " usage:  stream sink server [i2cp host i2cp port] sink dir our dest file [handlers]" )  ;   }  break ;  default :  system . out . println ( " usage:  stream sink server [i2cp host i2cp port] sink dir our dest file [handlers]" )  ;   }  if  ( server  !  =  null )  server . run server (  )  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  us . on error ( new  test exception (  )  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . empty (  )  ;  observable . take ( 1 )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w times ( 1 )  )  . on complete (  )  ;  verify
@ test public void   (  )  {  final sam record set builder set = new sam record set builder (  )  ;  set . set read length ( 110 )  ;  final  list < sam record >  recs = set . add pair ( "q1" 0 100 90 false false "110m" "110m" false true 30 )  ;  final sa
public  safe observer <  object >    (  )  {  return new  safe observer <  object >  ( this )  ;   }  
@ override public void   (  throwable t )  {  value = null ;  error ( t )  ;   }  
private void   ( final  variant context ctx final  string reason )  {  rejects . add ( new  variant context builder ( ctx )  . filter ( reason )  . make (  )  )  ;  failed liftover +  +  ;  track lifted variant contig ( rejects by contig ctx . get contig (  )  )  ;   }  
public static  string   (  path plugin dir )  {  final  string name = get element value ( plugin dir " / plugin / parent plugin" )  ;  if  ( name  !  =  null &&  ! name . is empty (  )  )   {  return name . to lower case (  )  ;   }  return null ;   }  
@ test public void   (  )  throws  exception  {   system . gc (  )  ;   thread . sleep ( 100 )  ;  long start =  management factory . get memorymx bean (  )  . get heap memory usage (  )  . get used (  )  ;  source =  flowable . from callable ( new  calla
void   (  )  {  upstream . dispose (  )  ;  done = true ;  drain (  )  ;   }  
public int   ( int tunnel )  {  return    helper . get limit hour ( tunnel )  ;   }  
public  string   (  )  {  return get class (  )  . get simple name (  )   +  "@"  +  "[parent db = " +  parent db +  " time = " +  new  date ( time * 1000l )  +  " ds names = [" +  print list ( ds names )  +  "] values = [" +  print list ( values )  +  "]]" ;   }  
  (  maybe observer <  ?  super r >  actual  bi function <  ?  super t  ?  super u  ?  extends r >  result selector )  {  this . actual = actual ;  this . result selector = result selector ;   }  
@ override public  session id   (  )  {  return    session id ;   }  
private void   (  pub sub service service iq iq  element child element  element create element  data form publish options )  {   create node response response = create node helper ( service iq . get from (  )  child element . element ( "configure" )  create element . attribute value ( "node" )  publish options )  ;  if  ( response . new node  =  =  null )   {  send error packet ( iq response . creation status response . pubsub error )  ;   }  else  {  iq reply = iq . create resultiq ( iq )  ;   node new node = response . new node ;   string nodeid = create element . attribute value ( "node" )  ;  if  (  ! new node . get nodeid (  )  . equals ( nodeid )  )   {   element elem = reply . set child element ( "pubsub" "http: /  / jabber . org / protocol / pubsub" )  ;  elem . add element ( "create" )  . add attribute ( "node" new node . get nodeid (  )  )  ;   }  router . route ( reply )  ;   }   }  
private boolean   (  big integer ip )  {  synchronized  (    singlei pv6 blocklist )   {  return    singlei pv6 blocklist . put ( ip dummy )   =  =  null ;   }   }  
@ test public void   (  )  {   flowable . just ( 1 )  . map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . compose ( new  strip boundar
double[]   ( int arc index int ds index )  throws  rrd exception  io exception   rrd exception  {  return rrd . get archive ( arc index )  . get values (  ) [ds index] ;   }  
public void   ( boolean transfer call )  {  this . transfer call = transfer call ;   }  
public int   (  )  {  return    endpoints . size (  )  ;   }  
public static  locale   (  string locale code )  {   locale locale = null ;  if  ( locale code  !  =  null )   {   string language = null ;   string country = null ;   string variant = null ;   string tokenizer tokenizer = new  string tokenizer ( locale code "   " )  ;  if  ( tokenizer . has more tokens (  )  )   {  language = tokenizer . next token (  )  ;  if  ( tokenizer . has more tokens (  )  )   {  country = tokenizer . next token (  )  ;  if  ( tokenizer . has more tokens (  )  )   {  variant = tokenizer . next token (  )  ;   }   }   }  locale = new  locale ( language  (  ( country  !  =  null )   ?  country : "" )   (  ( variant  !  =  null )   ?  variant : "" )  )  ;   }  return locale ;   }  
protected void   (  )  {  if  ( lock )   {  passed = lock reference . try lock ( key )  ;   }  else  {  lock reference . unlock ( key )  ;   }  lock =  ! lock ;   }  
public void   (  payload payload )  {     payload = payload ;   }  
public   ( i2p app context context )  {     context = context ;     log = context . log manager (  )  . get log ( i2np message handler . class )  ;     last size =  - 1 ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   safe subscriber <  integer >  so = new  safe subscriber <  integer >  ( ts )  ;  so . on error ( new  test exception (  )  )  ;  ts . assert fai
@ check return value @ scheduler support (  scheduler support . none )  @ backpressure support (  backpressure kind . full )  @ experimental public final  completable   (  function <  ?  super t  ?  extends  completable source >  mapper boolean till the e
@ override public  publisher <  integer >    (  grouped flowable <  integer  integer >  g )  throws  exception  {  return g . observe on (  schedulers . computation (  )  )  . map (  parallel perf . this )  ;   }  
@ test public void   (  )  {   flowable . amb ( new  crashing mapped iterable <  flowable <  integer >  >  ( 1 100 100 new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   integer v )  throws  ex
  (  string string )  {  m string =  ( string  !  =  null )   ?  string : "" ;   }  
public  collection <  string >    (  )  {  return properties . get property names (  )  ;   }  
public  string   (  )  {  return username ;   }  
public void   (  message packet )  {  routing table . broadcast packet ( packet false )  ;   }  
private void   ( final int lane final  string job name final  string library params file final int concatn column fields final  string read structure final  file base calls dir final  file test data dir final  integer tile )  throws  exception  {  final  path output dir =  files . create temp directory ( job name )  ;  try  {  final  string tile prefix =  ( tile  !  =  null )   ?  tile  +  " . " : "" ;  final  file library params = new  file ( output dir . to file (  )  library params file )  ;  library params . delete on exit (  )  ;  final  list <  file >  sam files = new  array list <  file >  (  )  ;  final  line reader reader = new  buffered line reader ( new  file input stream ( new  file ( test data dir library params file )  )  )  ;  final  print writer writer = new  print writer ( library params )  ;  final  string header = reader . read line (  )  ;  writer . println ( header  +  "\toutput" )  ;  while  ( true )   {  final  string line = reader . read line (  )  ;  if  ( line  =  =  null )   {  break ;   }  final  string[] fields = line . split ( "\t" )  ;  final  file output sam = new  file ( output dir . to file (  )   string util . join ( ""  arrays . copy of range ( fields 0 concatn column fields )  )   +  " . sam" )  ;  output sam . delete on exit (  )  ;  sam files . add ( new  file ( output sam . get parent file (  )  tile prefix  +  output sam . get name (  )  )  )  ;  writer . println ( line  +  "\t"  +  output sam )  ;   }  writer . close (  )  ;  reader . close (  )  ;   list <  string >  args = new  array list <  >  (  )  ;  args . add ( "basecalls   dir = "  +  base calls dir )  ;  args . add ( "lane = "  +  lane )  ;  args . add ( "run   barcode =  hi mom" )  ;  args . add ( "read   structure = "  +  read structure )  ;  args . add ( "library   params = "  +  library params )  ;  if  ( tile  !  =  null )   {  args . add ( "process   single   tile = "  +  tile )  ;   }   assert . assert equals ( run picard command line ( args )  0 )  ;  for  (  final  file output sam : sam files )   {  io util . assert files equal ( output sam new  file ( test data dir output sam . get name (  )  )  )  ;   }   }  finally  {   test util . recursive delete ( output dir . to file (  )  )  ;   files . delete ( output dir )  ;   }   }  
void   ( int x1 int y1 int x2 int y2  paint paint  stroke stroke )  {  gd . set stroke ( stroke )  ;  gd . set paint ( paint )  ;  gd . draw line ( x1 y1 x2 y2 )  ;   }  
public   (  parallel flowable <  ?  extends t >  source  bi function < t t t >  reducer )  {  this . source = source ;  this . reducer = reducer ;   }  
public void   (  router info info )  {     recipient = info ;   }  
void   (  )  {  for  (   zip observer <  ?   ?  >  zs : observers )   {  zs . dispose (  )  ;   }   }  
@ override public void   (  )  {  inner complete ( this )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   single . equals (  single . error ( new  test exception ( " one" )  )   single . error ( new  test exception ( " two" )  )  )  . test (  )  .
public  destination   (  )  throws i2p session exception  io exception   data format exception  {  if  ( dest  =  =  null )   {  i2p session s = open (  )  ;  if  ( s  !  =  null )   {  this . dest = new  verified destination ( s . get my destination (  )  )  ;  this . priv key = s . get decryption key (  )  ;  this . signing priv key = s . get private key (  )  ;   }   }  return this . dest ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
public boolean   (  )  {  if  ( storage  =  =  null )  return false ;  return storage . complete (  )  ;   }  
@ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  @ check return value @ beta public final  parallel flowable < t >    ( int parallelism int prefetch )  {   object helper . verify positive ( paralleli
private  string   (  )  {  return settings . get chat setting (  key enum . routing   message )  . get value (  )  ;   }  
public  string   (  )  {  return    tunnel status ;   }  
public static void   ( final  file run directory final  file output directory final  string output prefix final  metrics file <  metric base  comparable <  ?  >  >  lane metrics file final  metrics file <  metric base  comparable <  ?  >  >  phasing metrics file final  read structure read structure final  string file extension final  validation stringency validation stringency final boolean is nova seq )  {  final  map <  integer  ?  extends  collection <  tile >  >  lane tiles = read lane tiles ( run directory read structure validation stringency is nova seq )  ;  write lane metrics ( lane tiles output directory output prefix lane metrics file file extension )  ;  write phasing metrics ( lane tiles output directory output prefix phasing metrics file file extension is nova seq )  ;   }  
@ before public void   (  )  {   join row mapper test t = new  join row mapper test (  )  ;  t . db rule = db rule ;  t . set up (  )  ;   }  
public  string   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  return  ( tun  !  =  null && tun . get spoofed host (  )   !  =  null )   ?  tun . get spoofed host (  )  : "" ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "bb" "ccc" "dddd" )  ;   single <  map <  integer  string >  >  mapped = source . to map ( length func duplicate )  ;   map <  integer  string >  expected = new  hash
@ override public int   (  collection <  ?  super e >  c int max elements )  {  int rv = 0 ;  e e ;  while  (  ( e = poll (  )  )   !  =  null && rv +  +   <  max elements )   {  c . add ( e )  ;   }  return rv ;   }  
private   (  context context  account account )  throws  messaging exception  {  m context = context ;  m account = account ;   host auth recv auth = account . get or create host auth recv ( context )  ;  if  ( recv auth  =  =  null )   {  throw new  messaging exception ( " no  host auth in  imap store ? " )  ;   }  m transport = new  mail transport ( context "imap" recv auth )  ;   string[] user info = recv auth . get login (  )  ;  m username = user info[0] ;  m password = user info[1] ;  final  credential cred = recv auth . get credential ( context )  ;  m useo auth =  ( cred  !  =  null )  ;  m path prefix = recv auth . m domain ;   }  
@ override public boolean   (  )  {  return delegate . has next (  )  ;   }  
@ test public void   (  )  {  final  header value impl header value = new  header value impl ( "value"  collections .  <  string  string > empty map (  )  )  ;  assert equals ( " header value should only contain value when no parameters are present . " "v
private void   (  edging record and offset record  set <  edging record and offset >  records and offsets for name )  {  if  ( records and offsets for name . size (  )   =  =  1 )   {  reads names . remove ( record . get read name (  )  )  ;   }  else  {  records and offsets for name . remove ( record . get start (  )  )  ;   }   }  
@ override public  string   (  )  {   string to string sql = sql ;  try  {  int index = to string sql . index of ( ' ? ' )  ;  int count = 0 ;  while  ( index  >   - 1 )   {   object param = params . get ( count )  ;  int type = types . get ( count )  ;  
public  string   ( int tunnel )  {  return    helper . get access list ( tunnel )  ;   }  
@ override public void   (  )  {  done = true ;  drain (  )  ;   }  
@ setup public void   (  )  {  g =  crypto constants . elgg ;  p =  crypto constants . elgp ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    ( int initial capacity )  {  return  observable cache . from ( this initial capacity )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   replay processor <  integer >  rp =  replay processor . create with time ( 1  time unit . days scheduler )  ;  assert null ( rp . get value (  )  )  ;  assert null ( r
protected void   (  )  {  synchronized  (    lock16 )   {  if  (    key ring  =  =  null )     key ring = new  key ring (  )  ;     key ring initialized = true ;   }   }  
public   (  long id  ping notifier notifier )  {  super (    timer )  ;     id = id ;     notifier = notifier ;   }  
public   ( boolean room participation )  {  this . room participation = room participation ;  if  ( room participation )   {  participations = new  array list <  conversation participation >  (  )  ;   }  else  {  participations = new  copy on write array list <  conversation participation >  (  )  ;   }   }  
@ override public void   (  string id byte data[] int offset int length )  {   sink sink ;  synchronized  (    remote peers )   {  sink =    remote peers . get ( id )  ;   }  if  ( sink  !  =  null )   {  sink . received ( data offset length )  ;   }  els
public  < t > t   (  class < t >  iface )  throws sql exception  {  return cstmt . unwrap ( iface )  ;   }  
  ( t value  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper )  {  this . value = value ;  this . mapper = mapper ;   }  
protected void   (  string text )  throws io exception  {  if  ( text  !  =  null )   {   string escaped text = escape attribute entities ( text )  ;  writer . write ( escaped text )  ;   }   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {   take until main maybe observer < t u >  parent = new  take until main maybe observer < t u >  ( observer )  ;  observer . on subscribe ( parent )  ;  other . subscribe ( parent
public   (  observable source < t >  source )  {  super ( source )  ;   }  
@ override public void   ( final  throwable t )  {  w . schedule ( new  on error ( t )  delay error  ?  delay : 0 unit )  ;   }  
@ override public  string   (  string source )  {  final  query parameter collection parsed query parameters = new  query parameter collection ( source )  ;  final  list <  query parameter >  query parameters = parsed query parameters . get parameters (  
public void   (  )  {  if  (  ! get write lock (  )  )  return ;  try  {     is closed = true ;   }  finally  {  release write lock (  )  ;   }   }  
public   ( i2p snark util util  file base file  string announce  list <  list <  string >  >  announce   list  string created   by boolean private torrent  storage listener listener )  throws io exception  {     util = util ;     base = base file ;     log = util . get context (  )  . log manager (  )  . get log (  storage . class )  ;  this . listener = listener ;     preserve file names = true ;     torrent files = get files ( base file )  ;  long total = 0 ;   array list <  long >  lengths list = new  array list <  long >  (  )  ;  for  (   torrent file tf :    torrent files )   {  long length = tf . length ;  total +  = length ;  lengths list . add (  long . value of ( length )  )  ;   }  if  ( total  <  =  0 )  throw new io exception ( " torrent contains no data" )  ;  if  ( total  >  max   total   size )  throw new io exception ( " torrent too big  ( "  +  total  +  " bytes )   max is " +  max   total   size )  ;  int pc   size ;  if  ( total  <  =  5 * 1024 * 1024 )  pc   size = default   piece   size  /  4 ;  else if  ( total  <  =  10 * 1024 * 1024 )  pc   size = default   piece   size  /  2 ;  else pc   size = default   piece   size ;  int pcs =  ( int )  (  ( total  -  1 )   /  pc   size )   +  1 ;  while  ( pcs  >   ( max   pieces  /  3 )  && pc   size  <  max   piece   size )   {  pc   size* = 2 ;  pcs =  ( int )  (  ( total  -  1 )   /  pc   size )   +  1 ;   }  piece   size = pc   size ;  pieces = pcs ;  total   length = total ;  bitfield = new  bit field ( pieces )  ;  needed = 0 ;   list <  list <  string >  >  files = new  array list <  list <  string >  >  (  )  ;  for  (   torrent file tf :    torrent files )   {   list <  string >  file = new  array list <  string >  (  )  ;   string tokenizer st = new  string tokenizer ( tf . name  file . separator )  ;  while  ( st . has more tokens (  )  )   {   string part = st . next token (  )  ;  file . add ( part )  ;   }  files . add ( file )  ;   }  if  ( files . size (  )   =  =  1 &&  ! base file . is directory (  )  )   {  files = null ;  lengths list = null ;   }  byte[] piece   hashes = fast   digest create (  )  ;  metainfo = new  meta info ( announce base file . get name (  )  null files lengths list piece   size piece   hashes total private torrent announce   list created   by )  ;   }  
@ override protected  messaging exception   (  void .  .  .  params )  {  try  {  if  (  ( m mode &  setup data fragment . check   autodiscover )   !  =  0 )   {  if  ( is cancelled (  )  )  return null ;   log utils . d (  logging . log   tag " begin aut
public   (  output stream out )  {  super ( "sam  sink  pinger" )  ;  set daemon ( true )  ;     out = out ;   }  
public  string   (  )  {  return record path ;   }  
@ test public void   (  )  {  final  keyed regex extractor <  object >  extractor = new  keyed regex extractor <  >  (  )  ;  final  object expected key = new  object (  )  ;  final  string pattern = " . * / servers /  ( [ - |\\w] +  )  /  ?  . *" ;  extr
private static  set < uri >    ( i2p app context ctx )  {   set < uri >  rv = new  hash set < uri >  ( 32 )  ;   class loader loader =  class loader . get system class loader (  )  ;  if  ( loader instanceof url class loader )   {  url class loader url class loader =  ( url class loader ) loader ;  url urls[] = url class loader . getur ls (  )  ;  for  ( int i = 0 ;  i  <  urls . length ;  i +  +  )   {  try  {  rv . add ( urls[i] . touri (  )  )  ;   }  catch  (  uri syntax exception use )   {   }   }   }  else  {   file lib dir = new  file ( ctx . get base dir (  )  "lib" )  ;   file[] files = lib dir . list files ( new  file suffix filter ( " . jar" )  )  ;  if  ( files  !  =  null )   {  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {   string name = files[i] . get name (  )  ;  if  (  ! name . equals ( "addressbook . jar" )  )  rv . add ( files[i] . touri (  )  )  ;   }   }   }  return rv ;   }  
@ test public void   (  )  {  i2p socket exception e = new i2p socket exception ( "foo" )  ;  assert that ( e . get status (  )  is (  - 1 )  )  ;  assert that ( e . get message (  )  is ( "foo" )  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  start =  publish processor . create (  )  ;   function <  integer  flowable <  integer >  >  end = new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  i
public void   (  session key key )  {     layer key = key ;   }  
@ test @ ignore ( " observers can't throw" )  public void   (  )  {   subscriber <  string >  o = observer   success (  )  ;  try  {  o . on subscribe ( throwing   disposable )  ;  new  safe subscriber <  string >  ( o )  . on complete (  )  ;  fail ( "ex
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . concat array ( just1 null )  . blocking last (  )  ;   }  
public boolean   (  )  {  return enabled ;   }  
@ override public void   (  observer <  ?  super t >  s )  {   observable source <  ?  extends t >  pub ;  try  {  pub =  object helper . require non null ( supplier . call (  )  "null  observable source supplied" )  ;   }  catch  (   throwable t )   {   
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  sampler =  publish processor . create (  )  ;   flowable <  integer >  m = source . sample ( sampler )  ;  m . su
@ override public void   (  )  {  if  (  subscription helper . cancel ( this )  )   {  queue . offer ( terminated )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . interval ( 1 null )  ;   }  
@ override public  object   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ override public void   (  )  {  if  ( won )   {  actual . on complete (  )  ;   }  else  {  if  ( parent . win ( index )  )   {  won = true ;  actual . on complete (  )  ;   }   }   }  
public void   (  boolean value )  {     lost packet id plus6 = value ;   }  
public void   (  )  {     failed lookup rate . add data ( 1 )  ;     last store failed =    context . clock (  )  . now (  )  ;   }  
public static boolean   (  )  {  return allow short names ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  ps . single (  - 99 )  . test ( false )  ;  assert true ( ps . has observers (  )  )  ;   }  
@ test public void   (  )  {   flowable . empty (  )  . concat with ( new  maybe <  integer >  (  )  {  @ override protected void subscribe actual (   maybe observer <  ?  super  integer >  s )  {   disposable bs1 =  disposables . empty (  )  ;  s . on su
@ override public  bundle   ( final  string account type )  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m return = m service . get configuration data ( account type )  ;   }   }   "get configuration
@ test public void   (  )  {   single <  boolean >  o =  observable . sequence equal (  observable .  <  string > empty (  )   observable . just ( "one" "two" "three" )  )  ;  verify result ( o false )  ;   }  
@ small test public void   (  )  {   account account1 =  provider test utils . setup account ( "account - hostauth" false m mock context )  ;  account1 . m host auth recv =  provider test utils . setup host auth ( "account - hostauth - recv"  - 1 false m 
private void   (  )  {  long how long =    options . get inactivity timeout (  )  ;  if  ( how long  <  =  0 )   {  if  (    log . should log (  log . debug )  )     log . debug ( " resetting the inactivity timer  but its gone ! " new  exception ( "where did it go ? " )  )  ;  return ;   }  how long +  =    random wait ;     activity timer . reschedule ( how long false )  ;   }  
private  string   (  )  {   hash peer = new  hash (  )  ;  try  {  peer . from base64 (    peer )  ;  return dump profile ( peer )  ;   }  catch  (   data format exception dfe )   {  return " bad peer hash "  +     peer ;   }   }  
public  macro group   (  string title )  {   collection <  macro group >  col =  collections . unmodifiable list ( macro groups )  ;  for  (   macro group group : col )   {  if  ( group . get title (  )  . equals ignore case ( title )  )   {  return group ;   }   }  return null ;   }  
@ safe varargs public static  < t >  optional < t >    (  supplier <  optional < t >  >  .  .  .  suppliers )  {  return  stream . of ( suppliers )  . flat map ( supplier  -  >  to stream ( supplier . get (  )  )  )  . find first (  )  ;   }  
@ override public int   (  string username )  {  int count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( count
@ test public void   (  )  {   publish processor <  integer >  start =  publish processor . create (  )  ;   function <  integer  flowable <  integer >  >  end = new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  i
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  {  @ override public void on next (   integer t )  {  super . on next ( t )  ;  cancel (  )  ;   }   }   ;   testing deferred scalar subscriber ds =
@ override public boolean   (  )  {  return  !    running ;   }  
public long   (  )  {  return    receive alice time ;   }  
@ test public void   (  )  {  final  blocking first subscriber <  integer >  bf = new  blocking first subscriber <  integer >  (  )  ;  final  atomic boolean b = new  atomic boolean (  )  ;   subscription s = new  subscription (  )  {  @ override public v
@ test public void   (  )  throws  exception  {  final  auth check filter filter = new  auth check filter ( admin manager login limit manager  no user servlet authenticator class . class . get name (  )  )  ;  filter . do filter ( request response filter 
private static boolean   (  )  {  if  (  !    was checked )   {  try  {   load client apps job . test client ( test   class null )  ;     has latest jetty = true ;   }  catch  (   class not found exception cnfe )   {   }     was checked = true ;   }  return    has latest jetty ;   }  
@ test public void   (  )  {   replay processor <  integer >  async =  replay processor . create with size ( 1 )  ;  async . on next ( 0 )  ;  async . on next ( 1 )  ;   flowable processor <  integer >  serial = async . to serialized (  )  ;  assert false
private static boolean   (  )  {  return false ;   }  
@ override public synchronized void   ( boolean success )  {  if  (    cis  !  =  null )   {  if  ( success )     actual length =    cis . get read (  )  ;  try  {     cis . close (  )  ;   }  catch  (  io exception ioe )   {   }     cis = null ;   }   } 
@ data provider ( name = " " )  public  object[][] invalid data files (  )  {  return new  object[][] {  { new  file (  test dir "s   1   1101   pos . txt" )  }   { new  file (  test dir "s   1   1102   pos . txt" )  }   { new  file (  test dir "s   1   1
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( "something else entirely" )  ;  mapper . map ( result set ctx )  ;   }  
private static void   (  input stream in  jar output stream out )  throws  exception  {  if  (  !    failed oracle )   {  try  {   class <  ?  >  p200 =  class . for name ( "java . util . jar .  pack200" true  class loader . get system class loader (  )  )  ;   method new unpacker = p200 . get method ( "new unpacker" )  ;   object unpacker = new unpacker . invoke ( null  (  object[] ) null )  ;   method unpack = unpacker . get class (  )  . get method ( "unpack"  input stream . class  jar output stream . class )  ;  unpack . invoke ( unpacker new  object[] { in out }  )  ;  return ;   }  catch  (   class not found exception e )   {     failed oracle = true ;   }  catch  (   no such method exception e )   {     failed oracle = true ;   }   }  if  (  !    failed apache )   {  try  {   class <  ?  >  p200 =  class . for name ( "org . apache . harmony . unpack200 .  archive" true  class loader . get system class loader (  )  )  ;   constructor <  ?  >  new unpacker = p200 . get constructor (  input stream . class  jar output stream . class )  ;   object unpacker = new unpacker . new instance ( in out )  ;   method unpack = unpacker . get class (  )  . get method ( "unpack" )  ;  unpack . invoke ( unpacker  (  object[] ) null )  ;  return ;   }  catch  (   class not found exception e )   {     failed apache = true ;   }  catch  (   no such method exception e )   {     failed apache = true ;   }   }  throw new io exception ( " unpack200 not supported" )  ;   }  
int   (  )  {  return    inbound burstk bytes per second ;   }  
private long   ( long l plainblock )  {  l plainblock^ = m   lcbciv ;  l plainblock = super . encrypt block ( l plainblock )  ;  return  ( m   lcbciv = l plainblock )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  ts . on subscribe ( new  boolean subscription (  )  )  ;  ts . assert values only (  )  ;  ts . on next ( 5 )  ;  ts . assert values only ( 5 )  ;  ts . o
private int   (  )  {  return    context . get property ( prop   max   concurrent   establish default   max   concurrent   establish )  ;   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . debounce ( 1  time unit . seconds )  . test (  )  . assert failure (  test exception . class )  ;   }  
private void   (  string service name )  {  if  ( service name  =  =  null )   {  throw new  null pointer exception ( " service name cannot be null" )  ;   }  if  ( this . service name . equals ( service name )  )   {  return ;   }  try  {  component manager . remove component ( this . service name )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  component manager . add component ( service name this )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  this . service name = service name ;   }  
public   (  observable source <  ?  extends t > [] sources  iterable <  ?  extends  observable source <  ?  extends t >  >  sources iterable  function <  ?  super  object[]  ?  extends r >  zipper int buffer size boolean delay error )  {  this . sources = sources ;  this . sources iterable = sources iterable ;  this . zipper = zipper ;  this . buffer size = buffer size ;  this . delay error = delay error ;   }  
public int   ( int tunnel )  {  return get property ( tunnel  tunnel controller . prop   max   conns   day  tunnel controller . default   max   conns   day )  ;   }  
@ override public void   ( int status code long time )  {   status code response store value = data store . get status code counts (  )  . get ( status code )  ;  if  ( value  !  =  null )   {  data store . get status code counts (  )  . put ( status code
public void   ( jid workgroupjid )  {  final x stream xstream = new x stream (  )  ;  xstream . alias ( " chat settings"  chat settings . class )  ;  xstream . alias ( " key"  key enum . class )  ;  xstream . alias ( " setting"  chat setting . class )  ;  create image settings ( workgroupjid )  ;  create text settings ( workgroupjid )  ;  create bot settings ( workgroupjid )  ;   }  
private static boolean   (  class <  ?  >  cls )  {  return is interface ( cls  client app . class )  ;   }  
@ test public void   (  )  {   list <  throwable >  error =  test helper . track plugin errors (  )  ;  try  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  final  serialized observer <  integer >  so = new  serialized obser
@ suppress warnings ( "rawtypes" )  public static void   ( @ nullable  function <  ?  super  maybe  ?  extends  maybe >  on maybe assembly )  {  if  ( lockdown )   {  throw new  illegal state exception ( " plugins can't be changed anymore" )  ;   }   rx j
public synchronized void   ( final boolean precompute single )  {   group element  bi ;  if  ( precompute single && this . precmp  =  =  null )   {  this . precmp = new  group element[32][8] ;   bi = this ;  for  ( int i = 0 ;  i  <  32 ;  i +  +  )   {   group element  bij =  bi ;  for  ( int j = 0 ;  j  <  8 ;  j +  +  )   {  final  field element recip =  bij . z . invert (  )  ;  final  field element x =  bij . x . multiply ( recip )  ;  final  field element y =  bij . y . multiply ( recip )  ;  this . precmp[i][j] = precomp ( this . curve y . add ( x )  y . subtract ( x )  x . multiply ( y )  . multiply ( this . curve . get2d (  )  )  )  ;   bij =  bij . add (  bi . to cached (  )  )  . top3 (  )  ;   }  for  ( int k = 0 ;  k  <  8 ;  k +  +  )   {   bi =  bi . add (  bi . to cached (  )  )  . top3 (  )  ;   }   }   }  if  ( this . dbl precmp  !  =  null )  return ;  this . dbl precmp = new  group element[8] ;   bi = this ;  for  ( int i = 0 ;  i  <  8 ;  i +  +  )   {  final  field element recip =  bi . z . invert (  )  ;  final  field element x =  bi . x . multiply ( recip )  ;  final  field element y =  bi . y . multiply ( recip )  ;  this . dbl precmp[i] = precomp ( this . curve y . add ( x )  y . subtract ( x )  x . multiply ( y )  . multiply ( this . curve . get2d (  )  )  )  ;   bi = this . add ( this . add (  bi . to cached (  )  )  . top3 (  )  . to cached (  )  )  . top3 (  )  ;   }   }  
public   (  )  {  super (  duplicate scoring strategy .  scoring strategy . sum   of   base   qualities sam file header .  sort order . unsorted false )  ;   }  
@ test public void   (  )  {  final  group element t = new  group element ( curve bytes   pkr )  ;  final  group element s =  group element . p3 ( curve pkr[0] pkr[1] one pkr[0] . multiply ( pkr[1] )  )  ;  assert that ( t is ( equal to ( s )  )  )  ;   }
@ override public void   (  )  {  ts . cancel (  )  ;   }  
private static byte[]   (  input stream in )  throws io exception  {  for  ( int i = 0 ;  i  <  proto   len ;  i +  +  )   {  int b = in . read (  )  ;  if  ( b  !  =  proto[i] )  throw new io exception ( " bad protocol 0x"  +   integer . to hex string ( b )   +  " at byte " +  i )  ;   }   data helper . skip ( in 8 )  ;  byte buf[] = new byte[20] ;  int read =  data helper . read ( in buf )  ;  if  ( read  !  =  buf . length )  throw new io exception ( " unable to read the hash  ( read "  +  read  +  " ) " )  ;  return buf ;   }  
@ override public void   ( final  haplotype probabilities ignored )  {  throw new  illegal argument exception ( " cannot merge  haplotype probability of normal given tumor .   merge the underlying object and create a new wrapper . " )  ;   }  
private void   (  list <  file >  l  file f )  throws io exception  {  if  (  ! f . is directory (  )  )   {  if  ( l . size (  )   >  =   snark manager . max   files   per   torrent )  throw new io exception ( " too many files  limit is "  +   snark manager . max   files   per   torrent  +  "  zip them ? " )  ;  l . add ( f )  ;   }  else  {   file[] files = f . list files (  )  ;  if  ( files  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( "warning:  skipping '"  +  f  +  "' not a normal file . " )  ;  return ;   }  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )  add files ( l files[i] )  ;   }   }  
public synchronized void   (  context context  host auth host auth )  throws  certificate exception  {  if  (  text utils . is empty ( host auth . m client cert alias )  )   {  return ;   }   scheme registry registry = get scheme registry (  )  ;   string scheme name = make scheme for client cert ( host auth . m client cert alias host auth . should trust all server certs (  )  )  ;   scheme existing = registry . get ( scheme name )  ;  if  ( existing  =  =  null )   {  if  ( log   enabled )   {   log utils . i (  logging . log   tag " registering socket factory for certificate alias ["  +  host auth . m client cert alias  +  "]" )  ;   }   key manager key manager =  key chain key manager . from alias ( context host auth . m client cert alias )  ;  boolean insecure = host auth . should trust all server certs (  )  ;  ssl socket factory ssf = ssl utils . get http socket factory ( context host auth key manager insecure )  ;  registry . register ( new  scheme ( scheme name ssf host auth . m port )  )  ;   }   }  
public static double[]   ( final  histogram <  integer >  histogram )  {  if  ( histogram  =  =  null )  throw new  picard exception ( " histogram is null and cannot be normalized" )  ;  final double histogram sum of values = histogram . get sum of values (  )  ;  final double[] normalized histogram = new double[histogram . size (  ) ] ;  for  ( int i = 0 ;  i  <  histogram . size (  )  ;  i +  +  )   {  if  ( histogram . get ( i )   !  =  null )   {  normalized histogram[i] = histogram . get ( i )  . get value (  )   /  histogram sum of values ;   }   }  return normalized histogram ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  object >  source =  publish processor . create (  )  ;   flowable <  object >  result = source . take last ( 0 1  time unit . seconds scheduler ) 
  (  unicast processor < t >  w boolean open )  {  this . w = w ;  this . open = open ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . empty (  )  . buffer ( 2 1  time unit . days )  . test (  )  . assert result (  collections . empty list (  )  )  ;   }  
@ override public void   (  )  {  exit thread = true ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  parent . inner complete (  )  ;   }  
private void   (  long value )  {     extended highest sequence number received = value ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe . just ( 1 )  . flatten as observable ( new  function <  object  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   object v )  throws  exception  {  
public void   (  list <  form field >  item fields )  {  synchronized  ( reported items )   {  reported items . add ( item fields )  ;   }   }  
@ test public void   (  )  {   observable <  integer >  error =  observable . error ( new  runtime exception (  )  )  ;   observable . just ( 1 )  . amb with ( error )  . test (  )  . assert value ( 1 )  . assert complete (  )  ;   }  
public  field element   (  field element e  field element m )  {  return new  big integer field element ( f bi . mod pow (  (  (  big integer field element ) e )  . bi  (  (  big integer field element ) m )  . bi )  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
public  array list <  string >    (  )  {   array list <  string >  user list = new  array list <  string >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   all   users )  ;  pstmt . set string ( 1 transport type . to string (  )  )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  user list . add ( rs . get string ( 1 )  )  ;   }   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return user list ;   }  
private  string   (  )  {  return settings . get chat setting (  key enum . invitation   sent   message )  . get value (  )  ;   }  
@ test public void   (  )  throws  exception  {  ctx . find argument for (  object . class  ( short ) 2000 )  . get (  )  . apply ( 2 stmt null )  ;  verify ( stmt )  . set short ( 2  ( short ) 2000 )  ;   }  
@ override public void   (  subscriber <  ?  super  integer >  s )  {   conditional subscriber <  ?  super  integer >  cs =  (  conditional subscriber <  ?  super  integer >  ) s ;  cs . on subscribe ( new  boolean subscription (  )  )  ;  cs . try on nex
public synchronized static  properties   (  )  {   properties rv = new  ordered properties (  )  ;  if  ( properties  !  =  null )   {  if  ( config prefix  =  =  null )   {  rv . put all ( properties )  ;   }  else  {  for  (   map .  entry <  object  object >  e : properties . entry set (  )  )   {   string k =  (  string ) e . get key (  )  ;  if  ( k . starts with ( config prefix )  )  rv . put ( k . substring ( config prefix . length (  )  )  e . get value (  )  )  ;   }   }   }  if  ( config  !  =  null )   {  if  ( config prefix  =  =  null )   {  rv . put all ( config )  ;   }  else  {  for  (   map .  entry <  object  object >  e : config . entry set (  )  )   {   string k =  (  string ) e . get key (  )  ;  if  ( k . starts with ( config prefix )  )  rv . put ( k . substring ( config prefix . length (  )  )  e . get value (  )  )  ;   }   }   }  return rv ;   }  
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
@ override public  map <  string  map <  string  string >  >    (  )  {  return bare presences ;   }  
@ before class public static void   (  )  {   configuration default configuration = new  configuration (  )  ;  default configuration . set name ( " test cache manager" )  ;  default configuration . set default cache configuration ( new  cache configurati
@ test public void   (  )  {  new  flowable publish multicast <  integer  integer >  (  flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )   functions .  <  flowable <  integer >  > identity (  )  16 tr
@ override public boolean   (  object o )  {  return  ( o instanceof  torrent file )  && ra ffile . get absolute path (  )  . equals (  (  (  torrent file ) o )  . ra ffile . get absolute path (  )  )  ;   }  
public boolean   (  string realm  string user  string pw )  {   string pfx = realm ;  if  ( user  !  =  null && user . length (  )   >  0 )  pfx +  = ' . '  +  user ;   string b64 =    context . get property ( pfx  +  prop   b64 )  ;  if  ( b64  =  =  null )  return false ;  return b64 . equals (  base64 . encode (  data helper . getutf8 ( pw )  )  )  ;   }  
@ override public  long   (  )  throws  exception  {  return 1l ;   }  
 list <  string >    (  file base dir  list <  integer >  expected tiles )  {  final  list <  string >  failures = new  linked list <  >  (  )  ;  if  (  ! base dir . exists (  )  )   {  failures . add ( " base directory ( "  +  base dir . get absolute path (  )   +  " )  does not exist ! " )  ;   }  else  {  if  (  ! tiles . contains all ( expected tiles )  )   {  final  list <  integer >  missing = new  array list <  >  ( expected tiles )  ;  missing . remove all ( tiles )  ;  failures . add ( " missing tile "  +  missing  +  " for file type " +  extension +  " . " )  ;   }   }  return failures ;   }  
@ override public void   (  )  {  try terminate (  )  ;   }  
public void   (  input stream in  buffer out )  throws  decoding exception  {  throw new  decoding exception ( "unsupported" )  ;   }  
@ override public boolean   (  )  {  return backing . has next (  )  ;   }  
@ test public void   (  )  throws  exception  {  expect ( "select id from something where name like '%d' and id  =  %d and name like %s" literal quoted   text literal integer literal string eof )  ;   }  
void   ( jid room  date date )  {   conversation conversation = get room conversation ( room )  ;  if  ( conversation  !  =  null )   {  remove conversation ( room . to string (  )  conversation date )  ;   }   }  
public static boolean   (  )  {  return profiling enabled ;   }  
@ override public void   ( long account id  policy policy  string security key boolean notify )  {  try  {  m security policy . set account policy ( account id policy security key notify )  ;   }  catch  (   runtime exception e )   {   log utils . e ( log
@ override public  input source   (  string public id  string system id )  throws sax exception  io exception  {  log . warn (  ( allow entities  ?  " resolving" : " removing" )   +  "  entity[public id = '"  +   ( public id  !  =  null  ?  public id : ""
@ override public  publisher <  integer >    ( final long elements )  {  final  unicast processor <  integer >  pp =  unicast processor . create (  )  ;   schedulers . io (  )  . schedule direct ( new  runnable (  )  {  @ override public void run (  )  { 
@ test public void   (  )  {   single . just ( 1 )  . flat map observable ( new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   integer v )  throws  exception  {  return  observable . range 
void   (  )  {   subscriber <  ?  super t >  actual = this . actual ;  int missed = 1 ;  long e = emitted ;  int c = consumed ;  int lim = limit ;  for  (  ;   ;   )   {  long r = requested . get (  )  ;  while  ( e  !  =  r )   {  if  ( cancelled )   {  single item = null ;  queue = null ;  return ;   }  if  ( error . get (  )   !  =  null )   {  single item = null ;  queue = null ;  actual . on error ( error . terminate (  )  )  ;  return ;   }  int os = other state ;  if  ( os  =  =  other   state   has   value )   {  t v = single item ;  single item = null ;  other state = other   state   consumed   or   empty ;  os = other   state   consumed   or   empty ;  actual . on next ( v )  ;  e +  +  ;  continue ;   }  boolean d = main done ;   simple plain queue < t >  q = queue ;  t v = q  !  =  null  ?  q . poll (  )  : null ;  boolean empty = v  =  =  null ;  if  ( d && empty && os  =  =  other   state   consumed   or   empty )   {  queue = null ;  actual . on complete (  )  ;  return ;   }  if  ( empty )   {  break ;   }  actual . on next ( v )  ;  e +  +  ;  if  (  +  + c  =  =  lim )   {  c = 0 ;  main subscription . get (  )  . request ( lim )  ;   }   }  if  ( e  =  =  r )   {  if  ( cancelled )   {  single item = null ;  queue = null ;  return ;   }  if  ( error . get (  )   !  =  null )   {  single item = null ;  queue = null ;  actual . on error ( error . terminate (  )  )  ;  return ;   }  boolean d = main done ;   simple plain queue < t >  q = queue ;  boolean empty = q  =  =  null || q . is empty (  )  ;  if  ( d && empty && other state  =  =  2 )   {  queue = null ;  actual . on complete (  )  ;  return ;   }   }  emitted = e ;  consumed = c ;  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
public void   (  address book other boolean overwrite  log log )  {  if  ( this . addresses  =  =  null )  throw new  illegal state exception (  )  ;   iterator <  map .  entry <  string  host txt entry >  >  iter = other . iterator (  )  ;  try  {  merge2 ( other iter overwrite log )  ;   }  finally  {  if  ( iter instanceof  host txt iterator )   (  (  host txt iterator ) iter )  . close (  )  ;   }   }  
byte[]   (  )  {  return    intro key ;   }  
public static socks server   ( i2p app context ctx  socket s  properties props )  throws socks exception  {  socks server serv ;  try  {   data input stream in = new  data input stream ( s . get input stream (  )  )  ;  int socks ver = in . read byte (  )  ;  switch  ( socks ver )   {  case 0x04: if  (  boolean . parse boolean ( props . get property ( i2p tunnelhttp client base . prop   auth )  )  && props . contains key ( i2p tunnelhttp client base . prop   user )  && props . contains key ( i2p tunnelhttp client base . prop   pw )  )   {  throw new socks exception ( "socks 4 / 4a not supported when authorization is required" )  ;   }  serv = new socks4a server ( ctx s props )  ;  break ;  case 0x05: serv = new socks5 server ( ctx s props )  ;  break ;  case 'c': case 'g': case 'h': case 'p':  data output stream out = new  data output stream ( s . get output stream (  )  )  ;  out . write (  data helper . getascii ( err   request   denied )  )  ;  throw new socks exception ( "http request to socks" )  ;  default : throw new socks exception ( "socks protocol version not supported  ( "  +   integer . to hex string ( socks ver )   +  " ) " )  ;   }   }  catch  ( io exception e )   {  throw new socks exception ( " connection error" e )  ;   }  return serv ;   }  
public void   ( i local status i local status )  {   log . debug ( " gadu gadu:  local status changed: "  +  i local status )  ;  get session (  )  . set presence and status (  (  (  gadu gadu transport ) get session (  )  . get transport (  )  )  . convert gadu gadu status toxmpp ( i local status . get status type (  )  )  "" )  ;   }  
  ( int max size long max age  time unit unit  scheduler scheduler )  {  this . max size =  object helper . verify positive ( max size "max size" )  ;  this . max age =  object helper . verify positive ( max age "max age" )  ;  this . unit =  object helper . require non null ( unit "unit is null" )  ;  this . scheduler =  object helper . require non null ( scheduler "scheduler is null" )  ;   timed node <  object >  h = new  timed node <  object >  ( null 0l )  ;  this . tail = h ;  this . head = h ;   }  
@ test public void   (  )  {  s1 . on next ( "a" )  ;  s1 . on next ( "b" )  ;  s2 . on next ( "1" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s2 . on next ( "2" )  ;  in order . verify ( observer times ( 1 )  )  . on next
@ test public void   (  )  {   observable <  observable <  string >  >  source =  observable . unsafe create ( new  observable source <  observable <  string >  >  (  )  {  @ override public void subscribe (   observer <  ?  super  observable <  string > 
public void   (  string s b b )  {  if  ( "connect" . equals ( s )  )   {  b . c (  )  ;  e e = b . l (  )  ;  b . k (  )  ;  k . a ( e . a ( "swf url" "" )  )  ;  k . c ( e . a ( "page url" "" )  )  ;  k . d ( e . a ( "flash ver" "" )  )  ;  if  ( e . a ( "object encoding"  double . value of ( 0 . 0d )  )  . double value (  )   =  =  0 . 0d )   {  o . b ( " connect .  error" " object encoding client must be in a amf3 format  ( not amf0 ) " )  ;  return ;   }  k . a ( o )  ;  int i = o . d (  )  ;  a a1 = o . c ( " connect .  success" " connection succeeded" )  ;  a1 . a ( "object encoding" 3d )  ;  boolean flag = k . a ( b a1 )  ;  a1 . a (  )  ;  if  (  ! flag )   {  o . a ( i )  ;  k . c (  )  ;   }   }  else if  ( "set peer info" . equals ( s )  )   {   string s1 ;  for  (  ;  b . b (  )  ;  k . n (  )  . add ( s1 )  )  s1 = b . e (  )  ;  com . jcumulus . server . rtmfp . stream .  binary writer a = o . a ( false )  ;  a . a (  ( short ) 41 )  ;  a . a (  jive globals . get int property ( "voicebridge . rtmfp . keep . alive . server" 5 )  )  ;  a . a (  jive globals . get int property ( "voicebridge . rtmfp . keep . alive . peer" 5 )  )  ;   }  else if  (  ! "init stream" . equals ( s )  )  if  ( "create stream" . equals ( s )  )   {  com . jcumulus . server . rtmfp . flow . f f = o . j (  )  ;   integer integer1 = i . get streams (  )  . a (  )  ;  u . add ( integer1 )  ;  f . a ( integer1 . int value (  )  )  ;   }  else if  ( "delete stream" . equals ( s )  )   {   integer integer =  integer . value of ( b . n (  )  . int value (  )  )  ;  u . remove ( integer )  ;  i . get streams (  )  . a ( integer )  ;   }  else if  (  ! k . a ( s b )  )  o . b ( " call .  failed"  ( new  string builder (  )  )  . append ( " method '" )  . append ( s )  . append ( "' not found" )  . to string (  )  )  ;   }  
protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;  final sam file writer writer = new sam file writer factory (  )  . make writer ( reader . get file header (  )  true output reference   sequence )  ;  if  ( create   index && writer . get file header (  )  . get sort order (  )   !  =  sam file header .  sort order . coordinate )   {  throw new  picard exception ( " can't create   index unless sort order is coordinate" )  ;   }  final  progress logger progress = new  progress logger (  log . get instance (  sam format converter . class )  )  ;  for  (  final sam record rec : reader )   {  writer . add alignment ( rec )  ;  progress . record ( rec )  ;   }   closer util . close ( reader )  ;  writer . close (  )  ;  return 0 ;   }  
  (  maybe observer <  ?  super t >  actual  bi function < t t t >  reducer )  {  this . actual = actual ;  this . reducer = reducer ;   }  
@ test public void   (  )  throws  exception  {  final  string version string = "1 . 2 . 3 - snapshot" ;   version test = new  version ( version string )  ;  assert that ( test . get major (  )  is ( 1 )  )  ;  assert that ( test . get minor (  )  is ( 2 
public static  mailbox   (  context context long account id int type )  {  final long mailbox id = find mailbox of type ( context account id type )  ;  if  ( mailbox id  !  =   mailbox . no   mailbox )   {  return  mailbox . restore mailbox with id ( context mailbox id )  ;   }  return null ;   }  
public synchronized void   ( boolean success )  {  if  ( success )   {  if  ( content  =  =  null )  content =    baos . to byte array (  )  ;   }  else  {  content = null ;   }     baos = null ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
@ after public void   (  )  {  h . close (  )  ;   }  
public void   (  session event event )  {   log . debug ( event  =  =  null  ?  "closed event is null" : event . to string (  )  )  ;  if  ( get session (  )  . is logged in (  )  )   {  get session (  )  . set login status (  transport login status . disconnected )  ;  get session (  )  . session disconnected no reconnect ( null )  ;   }   }  
public long   (  )  {  return    duration ;   }  
@ before class public static void   (  )  throws  exception  {  content remove me = io utils . to byte array (  translation filter methods match test . class . get resource as stream ( " / remove - me - element . xml" )  )  ;   }  
public   (  string id double attenuation  media info media info )  {  this . id = id ;  this . attenuation = attenuation ;  this . media info = media info ;  if  ( common mix default  =  =  false )   {  no common mix = true ;   }   logger . write file ( " new  whisper group: "  +  to string (  )  )  ;   }  
@ override public void   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {  assert that ( "tzs: / baduri|hehe" not ( matches pattern (  variant parser . variant   regex )  )  )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  throws  exception  {  return  flowable . just ( v * 10 )  . 
@ override public void   (  )  {  d =  disposable helper . disposed ;  actual . on complete (  )  ;   }  
@ test public void   (  )  {  assert that (  iterable like . is empty ( new int[] {  }  )  )  . is true (  )  ;   }  
public  string   (  string groupname )  {  try  {  find groupdn ( groupname basedn )  ;  return basedn ;   }  catch  (   exception e )   {  try  {  if  ( alternate basedn  !  =  null )   {  find groupdn ( groupname alternate basedn )  ;  return alternate basedn ;   }   }  catch  (   exception ex )   {   log . debug ( ex . get message (  )  ex )  ;   }   }  return null ;   }  
@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   user user =  (  user ) o ;  return id  =  =  user . id &&  objects . equals ( name us
public void   (  string plugin name  cache info info )  {  extra cache mappings . put ( info . get cache name (  )  info )  ;   list <  cache info >  caches = plugin caches . get ( plugin name )  ;  if  ( caches  =  =  null )   {  caches = new  array list <  >  (  )  ;  plugin caches . put ( plugin name caches )  ;   }  caches . add ( info )  ;   cache factory . set cache type property ( info . get cache name (  )  info . get type (  )  . get name (  )  )  ;   cache factory . set max size property ( info . get cache name (  )  get max size from property ( info )  )  ;   cache factory . set max lifetime property ( info . get cache name (  )  get max lifetime from property ( info )  )  ;   cache factory . set min cache size ( info . get cache name (  )  get min size from property ( info )  )  ;   }  
@ override protected void   (  session data data  element command )  {   data form form = new  data form (  data form .  type . form )  ;  form . set title ( " dispatching a group member added event . " )  ;  form . add instruction ( " fill out this form 
@ override public  presence   ( jid jid jid actorjid  string actor nickname  string reason )  throws  not allowed exception  {   presence updated presence = change occupant role ( jid muc role .  role . none )  ;  if  ( updated presence  !  =  null )   { 
public synchronized void   (  string event  string info )  {  if  ( event . contains ( " " )  || event . contains ( "\n" )  ||  ( info  !  =  null && info . contains ( "\n" )  )  )  throw new  illegal argument exception (  )  ;     cache . remove ( event )  ;     cache time . remove ( event )  ;   output stream out = null ;  try  {  out = new  secure file output stream (    file true )  ;   string builder buf = new  string builder ( 128 )  ;  buf . append (    context . clock (  )  . now (  )  )  . append ( ' ' )  . append ( event )  ;  if  ( info  !  =  null && info . length (  )   >  0 )  buf . append ( ' ' )  . append ( info )  ;  if  (  system version . is windows (  )  )  buf . append ( '\r' )  ;  buf . append ( '\n' )  ;  out . write ( buf . to string (  )  . get bytes ( "utf - 8" )  )  ;   }  catch  (  io exception ioe )   {   }  finally  {  if  ( out  !  =  null )  try  {  out . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
@ override public void   ( int index t element )  {  super . add ( index element )  ;  sync groups ( element add )  ;   }  
@ test public void   (  )  {   connectable flowable <  integer >  cf =  flowable .  <  integer > empty (  )  . publish (  )  ;  cf . connect (  )  ;   }  
private int   ( long mailbox id )  {  return  utility . get first row int ( m mock context  content uris . with appended id (  mailbox . content   uri mailbox id )  new  string[] {  mailbox columns . message   count }  null null null 0 )  ;   }  
void   ( sa mv3 stream session sess )  {  stream session = sess ;  session = sess ;   }  
public   ( final  string sample final  string library final  string read group )  {  metric = new  total number metric (  )  ;  metric . sample = sample ;  metric . library = library ;  metric . read   group = read group ;  units to metrics . put ( none or str ( sample )   +  "   "  +  none or str ( library )  +  "   " +  none or str ( read group )  metric )  ;   }  
public   ( i2p app context ctx i2p session session )  {  super ( ctx session )  ;   }  
@ test public void   (  )  {   test subscriber <  long >  ts = new  test subscriber <  long >  (  )  ;   flowable . interval ( 100 100  time unit . milliseconds scheduler )  . subscribe ( ts )  ;  scheduler . advance time by ( 100  time unit . millisecond
@ override  illumina parser <  positional data >    ( final  list <  integer >  requested tiles )  {  return new  multi tile locs parser ( tile index requested tiles data file lane )  ;   }  
public boolean   (  )  {  return success ;   }  
public  certificate store configuration   (  connection type type )  throws io exception  {  final  string key store type = get key store type ( type )  ;  final  string password = get trust store password ( type )  ;  final  string location = get trust store location ( type )  ;  final  file file = canonicalize ( location )  ;  return new  certificate store configuration ( key store type file password . to char array (  )  )  ;   }  
public boolean   (  )  {  return read enabled ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public boolean   ( int id long limit boolean nolimit )  {  sam stream session socket reader reader = get socket reader ( id )  ;  if  ( reader  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " trying to set a li
@ override public  update task   (  update type type  update method method  list < uri >  update sources  string app name  string new version long max time )  {  if  ( type  !  =   update type . plugin ||  ( method  !  =   update method . http && method  
@ test public void   (  )  throws io exception   class not found exception  {  byte[] serialized = serializer . write object ( target )  ;  assert not null ( serialized )  ;   serializable actual = serializer . read object ( serialized )  ;  assert not nu
@ test public void   (  )  throws  exception  {   scheduled executor service exec =  executors . new single thread scheduled executor (  )  ;  try  {  for  (   scheduler s : new  scheduler[] {  schedulers . single (  )   schedulers . computation (  )   sc
public   (  )  {  super ( i2p app context . get global context (  )  . simple timer2 (  )  check   time  +  5 * 1000 )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable 
private void   (  part part  string builder sb )  throws  exception  {  if  ( part . is mime type ( "text / plain" )  )   {  sb . append (  (  string ) part . get content (  )  )  . append ( "\n" )  ;   }  else if  ( part . is mime type ( "multipart / *" )  )   {   multipart mp =  (  multipart ) part . get content (  )  ;  int count = mp . get count (  )  ;  for  ( int i = 0 ;  i  <  count ;  i +  +  )   {  append message part ( mp . get body part ( i )  sb )  ;   }   }  else if  ( part . is mime type ( "message / rfc822" )  )   {  append message part (  (  part ) part . get content (  )  sb )  ;   }  else  {   }   }  
@ test public void   (  )  throws  exception  {  final  string expected = "expected" ;  final  event listener <  test event  string >  listener = e  -  >   {  if  ( e . type (  )   =  =   test event . one )   {  assert true ( " event must be fired" event 
public int   (  )  {  try  {  return  integer . parse int ( get icon node (  )  . get node value ( width )  )  ;   }  catch  (   exception e )   {   }   ;  return 0 ;   }  
@ test public void   (  )  {  final  atomic integer effect counter = new  atomic integer (  )  ;   observable <  integer >  source =  observable . just ( 1 2 3 4 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   inte
long   (  )  {  return rrd . get header (  )  . getpdp step (  )  ;   }  
public void   (  session id id )  {     session id = id ;   }  
@ override public int   ( int mode )  {  if  (  ( mode & async )   !  =  0 )   {  output fused = true ;  return async ;   }  return none ;   }  
public   ( i2p app context ctx )  {  super ( ctx )  ;   }  
@ override protected void   (  socket timeout timeout )  throws io exception  {  if  (    output stream  !  =  null )   {   }  else  {   file out file = new  file (    output file )  ;  if  ( out file . exists (  )  )     already transferred = out file . 
@ override public void   (  )  {  super . cancel (  )  ;  s . cancel (  )  ;   }  
@ override public int   (  archive candidate < e >  o )  {  return creation . compare to ( o . creation )  ;   }  
@ override public void   (  )  {  s =  subscription helper . cancelled ;  t v = item ;  if  ( v  !  =  null )   {  item = null ;  actual . on success ( v )  ;   }  else  {  v = default item ;  if  ( v  !  =  null )   {  actual . on success ( v )  ;   }  e
@ test public void   (  )  {   test helper . check disposed (  flowable . generate ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  bi consumer <  object  emitter <  object >  >  ( 
public  string   ( int tunnel )  {  return get property ( tunnel i2p tunnelhttp client . prop   jump   servers i2p tunnelhttp client . default   jump   servers )  . replace ( " " "\n" )  ;   }  
public boolean   (  )  {  return flag set ( udp packet . data   flag   explicit   ack )  ;   }  
@ override public void   (  )  {  if  ( context  !  =  null )   {   http bind manager . get instance (  )  . remove jetty handler ( context )  ;  context . destroy (  )  ;  context = null ;   }  for  (  final  string public resource : public resources )  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;   scalar subscription <  integer >  sc = new  scalar subscription <  integer >  ( ts 1 )  ;   list <  throwable >  errors =  test helper . track
@ override protected void   (  )  throws  exception  {  super . set up (  )  ;  m test context = get instrumentation (  )  . get context (  )  ;   }  
private static  string   (  resource bundle catalog  string msgid )  {  try  {  return  (  string ) catalog . get object ( msgid )  ;   }  catch  (   missing resource exception e )   {  return null ;   }   }  
@ test public void   (  )  {   observable <  boolean >  o =  observable . sequence equal (  observable . just ( "one" "two" "three" )   observable .  <  string > empty (  )  )  . to observable (  )  ;  verify result ( o false )  ;   }  
public long   (  )  {  return this . filtered bases ;   }  
public int   (  node info lhs  node info rhs )  {  byte lhs delta[] =  data helper . xor ( lhs . getnid (  )  . get data (  )     base )  ;  byte rhs delta[] =  data helper . xor ( rhs . getnid (  )  . get data (  )     base )  ;  return  data helper . compare to ( lhs delta rhs delta )  ;   }  
@ override public  char sequence   (  char sequence invalid text )  {  return "" ;   }  
@ test public void   (  )  {  destination info logic . get status code counts (  )  . put ( 200 new  status code response store ( 7l 0 )  )  ;   destination info copy = destination info logic . copy (  )  ;  destination info logic . increment status code 
@ test public void   (  )  throws  exception  {  ctx . find argument for (  long . class 3l )  . get (  )  . apply ( 1 stmt null )  ;  verify ( stmt )  . set long ( 1 3 )  ;   }  
public static boolean   (  string subdomain )  {  return get configuration ( subdomain true )   !  =  null ;   }  
public static void   ( final boolean enable )  {   utility . enable strict mode ( enable )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . from publisher ( null )  ;   }  
@ test public void   (  )  {   observable <  integer >  cache =  observable . range ( 1 5 )  . cache (  )  ;  cache . take ( 2 )  . test (  )  . assert result ( 1 2 )  ;  cache . take ( 3 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp0 =  publish proces
static  server   (  )  {  return    server ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   flowable . merge (  flowable . range ( 1 10000 )  . do on next ( new  consumer <  int
public static  big integer   (  )  {  return group order ;   }  
@ backpressure support (  backpressure kind . full )  @ check return value @ scheduler support (  scheduler support . none )  public final  < r >  flowable < r >    (  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper )  {  return
public boolean   (  )  {  return  jive globals . get boolean property ( "plugin . email . listener . ssl" false )  ;   }  
public void   (  )  {  i2p socket manager mgr = null ;  if  (    i2cp host  !  =  null )  mgr = i2p socket manager factory . create manager (    i2cp host    i2cp port new  properties (  )  )  ;  else mgr = i2p socket manager factory . create manager (  )  ;   destination peer = null ;   file input stream fis = null ;  try  {  fis = new  file input stream (    peer dest file )  ;  peer = new  destination (  )  ;  peer . read bytes ( fis )  ;   }  catch  (  io exception ioe )   {     log . error ( " error finding the peer destination to contact in "  +     peer dest file ioe )  ;  return ;   }  catch  (   data format exception dfe )   {     log . error ( " peer destination is not valid in "  +     peer dest file dfe )  ;  return ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +     send size  +  "kb to " +  peer . calculate hash (  )  . to base64 (  )  )  ;  while  ( true )   {  try  {  i2p socket sock = mgr . connect ( peer )  ;  byte buf[] = new byte[ math . min ( 32 * 1024    send size * 1024 ) ] ;   random rand = new  random (  )  ;   output stream out = sock . get output stream (  )  ;  long before sending =  system . current time millis (  )  ;  for  ( int i = 0 ;   (    send size  <  0 )  ||  ( i  <     send size )  ;  i +  = buf . length  /  1024 )   {  rand . next bytes ( buf )  ;  out . write ( buf )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " wrote "  +   (  ( 1  +  i * buf . length )   /  1024 )   +  " / " +     send size +  "kb" )  ;  if  (    write delay  >  0 )   {  try  {   thread . sleep (    write delay )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  sock . close (  )  ;  long after sending =  system . current time millis (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " sent "  +     send size  +  "kb in " +   ( after sending  -  before sending )  +  "ms" )  ;   }  catch  (   interruptedio exception iie )   {     log . error ( " timeout connecting to the peer" iie )  ;   }  catch  (   no route to host exception nrthe )   {     log . error ( " unable to connect to the peer" nrthe )  ;   }  catch  (   connect exception ce )   {     log . error ( " connection already dropped" ce )  ;   }  catch  (  i2p exception ie )   {     log . error ( " error connecting to the peer" ie )  ;  return ;   }  catch  (  io exception ioe )   {     log . error ( "io error sending" ioe )  ;  return ;   }   }   }  
public static void   (  object service  call event call event  string monitor name )  {  if  ( service  !  =  null )   {   string my event =  call event . get event string ( call event . get event (  )  )  ;   string call state = call event . get call state (  )  . to string (  )  ;   string info = call event . get info (  )   =  =  null  ?  "" : call event . get info (  )  ;   string dtmf = call event . get dtmf key (  )   =  =  null  ?  "" : call event . get dtmf key (  )  ;   string treatmentd id = call event . get treatment id (  )   =  =  null  ?  "" : call event . get treatment id (  )  ;  int no of calls = call event . get number of calls (  )  ;   string call id = call event . get call id (  )   =  =  null  ?  "" : call event . get call id (  )  ;   string conf id = call event . get conference id (  )   =  =  null  ?  "" : call event . get conference id (  )  ;   string call info = call event . get call info (  )   =  =  null  ?  "" : call event . get call info (  )  ;   }   }  
public org . xmpp . packet .  roster   (  )  {  org . xmpp . packet .  roster roster = new org . xmpp . packet .  roster (  )  ;  for  (   roster item item : roster items . values (  )  )   {  if  ( item . is only shared (  )  && item . get sub status (  )   =  =   roster item . sub   from )   {  continue ;   }  org . xmpp . packet .  roster .  ask ask = get ask status ( item . get ask status (  )  )  ;  org . xmpp . packet .  roster .  subscription sub = org . xmpp . packet .  roster .  subscription . value of ( item . get sub status (  )  . get name (  )  )  ;   list <  string >  groups = new  array list <  >  ( item . get groups (  )  )  ;  if  ( groups . contains ( null )  )   {   log . warn ( "a group is null in roster item: "  +  item . get jid (  )   +  " of user: " +  get username (  )  )  ;   }  for  (   group shared group : item . get shared groups (  )  )   {   string display name = shared group . get properties (  )  . get ( "shared roster . display name" )  ;  if  ( display name  !  =  null )   {  groups . add ( display name )  ;   }  else  {   log . warn ( " found shared group: "  +  shared group . get name (  )   +  " with no display name" )  ;   }   }  if  ( item . get sub status (  )   !  =   roster item . sub   none || item . get recv status (  )   !  =   roster item . recv   subscribe &&  ! is subscription rejected ( item )  )   {  roster . add item ( item . get jid (  )  item . get nickname (  )  ask sub groups )  ;   }   }  return roster ;   }  
@ override protected void   (  observer <  ?  super  integer >  s )  {  s . on subscribe (  disposables . empty (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 2 )  ;  s . on error ( new  test exception (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  assert equals ( 1l  object helper . verify positive ( 1l "param" )  )  ;   }  
public void   (  destination sink )  {  this . sinks . remove ( sink )  ;   }  
@ override protected  action   (  session data data )  {  return  action . complete ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . first or error (  )  . test (  )  . assert no errors (  )  . assert value ( 1 )  ;   }  
public static long   ( byte src[] int offset int num bytes )  {  if  ( num bytes  <  =  0 || num bytes  >  8 )  throw new  illegal argument exception ( " invalid number of bytes" )  ;  if  (  ( src  =  =  null )  ||  ( src . length  =  =  0 )  )  return 0 ;  long rv = 0 ;  int limit = offset  +  num bytes ;  for  ( int i = offset ;  i  <  limit ;  i +  +  )   {  rv <  <  = 8 ;  rv| = src[i] & 0xff ;   }  if  ( rv  <  0 )  throw new  illegal argument exception ( "from long got a negative ?  "  +  rv  +  ": offset = " +  offset +  " num bytes = " +  num bytes )  ;  return rv ;   }  
@ ui thread test public void   (  )  {  get activity and fields (  )  ;  assert true ( is next button enabled (  )  )  ;  m server view . set text ( " " )  ;  assert false ( is next button enabled (  )  )  ;  m server view . set text ( "serv$er . com" )  
public static  signing public key   (  signing private key priv )  {   sig type type = priv . get type (  )  ;  if  ( type  =  =  null )  throw new  illegal argument exception ( " unknown type" )  ;  try  {  switch  ( type . get base algorithm (  )  )   {  case dsa:  big integer x = new  native big integer ( 1 priv . to byte array (  )  )  ;   big integer y =  crypto constants . dsag . mod pow ( x  crypto constants . dsap )  ;   signing public key pub = new  signing public key (  )  ;  pub . set data (  sig util . rectify ( y  signing public key . keysize   bytes )  )  ;  return pub ;  case ec: ec private key ecpriv =  sig util . to javaec key ( priv )  ;   big integer s = ecpriv . gets (  )  ;  ec parameter spec spec =  ( ec parameter spec ) type . get params (  )  ;   elliptic curve curve = spec . get curve (  )  ;  ec point g = spec . get generator (  )  ;  ec point w = ec util . scalar mult ( g s curve )  ;  ec public key spec ecks = new ec public key spec ( w ecpriv . get params (  )  )  ;   key factory eckf =  key factory . get instance ( "ec" )  ;  ec public key ecpub =  ( ec public key ) eckf . generate public ( ecks )  ;  return  sig util . from java key ( ecpub type )  ;  case rsa: rsa private key rsapriv =  sig util . to javarsa key ( priv )  ;   big integer exp =  (  ( rsa key gen parameter spec ) type . get params (  )  )  . get public exponent (  )  ;  rsa public key spec rsaks = new rsa public key spec ( rsapriv . get modulus (  )  exp )  ;   key factory rsakf =  key factory . get instance ( "rsa" )  ;  rsa public key rsapub =  ( rsa public key ) rsakf . generate public ( rsaks )  ;  return  sig util . from java key ( rsapub type )  ;  case  eddsa:  eddsa private key epriv =  sig util . to java eddsa key ( priv )  ;   eddsa public key epub = new  eddsa public key ( new  eddsa public key spec ( epriv . geta (  )  epriv . get params (  )  )  )  ;  return  sig util . from java key ( epub type )  ;  default : throw new  illegal argument exception ( " unsupported algorithm" )  ;   }   }  catch  (  general security exception gse )   {  throw new  illegal argument exception ( " conversion failed" gse )  ;   }   }  
public   (  blackhole bh )  {  super ( 1 )  ;  this . bh = bh ;   }  
public  string   (  string parameter name )  throws sql exception  {  return cstmt . get string ( parameter name )  ;   }  
public static v card provider   (  )  {  return instance . provider ;   }  
@ override public void   (  )  {  main done = true ;  drain (  )  ;   }  
public   (  observable source < t >  source )  {  this . source = source ;   }  
public void   (  string s )  {  try  {     age =  long . parse long ( s )  ;  if  (    age  >  0 )     from =    context . clock (  )  . now (  )   -     age ;  else    from = 0 ;   }  catch  (   number format exception nfe )   {     age = 0 ;     from = 0 ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  intege
@ test public void   (  )  {   test helper . check disposed (  observable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {
public void   (  string business pager )  {  this . business pager = business pager ;   }  
void   (  throwable ex )  {  if  ( errors . add throwable ( ex )  )   {  if  ( error mode  !  =   error mode . end )   {  upstream . cancel (  )  ;   }  this . state = state   inactive ;  drain (  )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
@ override public void   (  )  {  if  ( state . compare and set (  state . open  state . closed )  )   {  if  ( session  !  =  null )   {  session . set status (  session . status   closed )  ;   }  try  {  deliver raw text0 ( flash client  ?  " <  / flas
public  destination   (  )  {  return    destination ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {  try  {  new  bad flowable (  )  . test (  )  ;  fail ( " should have thrown ! " )  ;   }  catch  (   null pointer exception ex )   {  if  (  !  
@ test public void   (  )  {   test resource observer <  integer >  tc = new  test resource observer <  integer >  (  )  ;  assert false ( tc . is disposed (  )  )  ;  assert equals ( 0 tc . start )  ;  assert true ( tc . values . is empty (  )  )  ;  ass
@ test public void   (  )  {   future task <  object >  ft = new  future task <  object >  ( new  runnable (  )  {  @ override public void run (  )  {   }   }   null )  ;   schedulers . single (  )  . schedule direct ( ft 100  time unit . milliseconds )  
@ test public void   (  )  throws  exception  {  final  metrics file <  illumina basecalling metrics  integer >  metrics file = run it ( 1 "125t125t" new  file ( root test dir "125t125t /  data /  intensities /  base calls" )  null false )  ;  final  illu
@ override public void   (  )  {  super . stop (  )  ;  routing table . remove component route ( get address (  )  )  ;  engine . shutdown ( this )  ;   }  
private void   ( iq packet )  {   element frag = packet . get child element (  )  ;   element data element =  (  element ) frag . element iterator (  )  . next (  )  ;  workgroup settings . add ( workgroup . getjid (  )  . to barejid (  )  data element )  ;   }  
@ override void   (  )  {  emit (  )  ;  if  ( wip . decrement and get (  )   =  =  0 )   {  actual . on complete (  )  ;   }   }  
public long   (  )  {  return m ping duration ;   }  
@ override public void   (  )  {  s . dispose (  )  ;   }  
@ test public void   (  )  {  @ suppress warnings ( "rawtypes" )  final  subscriber[] ts0 =  { null }  ;   test subscriber <  integer >  ts =  flowable . just ( 1 )  . hide (  )  . concat map delay error (  functions . just function ( new  flowable <  int
@ override public  file   (  )  {  return basis . vcf (  )  ;   }  
public void   (  string s )  {  try  {  end index =  integer . parse int ( s )  ;   }  catch  (   number format exception nfe )   {   }   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;  final  maybe subject <  integer >  ms1 =  maybe subject . create (  )  ;  final  maybe subject <  integer >  ms2 =  maybe subject . create (  )  ;   t
@ override public void   (  object t )  {  inner next (  )  ;   }  
public  message[]   (  string[] uids  message retrieval listener listener )  {  final  array list <  message >  messages = new  array list <  message >  ( uids . length )  ;  for  ( int i = 0 ;  i  <  uids . length ;  i +  +  )   {  final  string uid = uids[i] ;  final  imap message message = new  imap message ( uid this )  ;  messages . add ( message )  ;  if  ( listener  !  =  null )   {  listener . message retrieved ( message )  ;   }   }  return messages . to array (  message . empty   array )  ;   }  
public void   (  )  {  byte buf[] = new byte[1024] ;  if  ( init seed ( buf )  )  set seed ( buf )  ;   }  
private  < t extends  abstract record and offset >  wgs metrics processor impl < t >    (  progress logger progress  reference sequence file walker ref walker  abstract locus iterator < t  abstract locus info < t >  >  iterator  abstract wgs metrics collector < t >  collector )  {  return new  wgs metrics processor impl <  >  ( iterator ref walker collector progress )  ;   }  
public   (  string msg  throwable nested throwable )  {  super ( msg )  ;  this . nested throwable = nested throwable ;   }  
public final static void   (  string ifaddr )  {  if address = ifaddr ;   }  
@ test public void   (  )  {   flowable . create ( source no cancel  backpressure strategy . buffer )  . subscribe ( ts )  ;  ts . cancel (  )  ;  source no cancel . on next ( 1 )  ;  source no cancel . on next ( 2 )  ;  source no cancel . on error ( new 
public   (  router context ctx )  {     context = ctx ;     log = ctx . log manager (  )  . get log ( get class (  )  )  ;     pending connections = new  linked hash set < ntcp connection >  ( 16 )  ;     runners = new  array list <  runner >  ( 8 )  ;     live reads = new  hash set < ntcp connection >  ( 8 )  ;     read after live = new  hash set < ntcp connection >  ( 8 )  ;   }  
@ override public void   (  bundle saved instance state )  {  super . on activity created ( saved instance state )  ;  final  simple cursor adapter adapter = new  simple cursor adapter ( get activity (  )  r . layout . quick   response   item null new  st
@ override public void   ( xmpp server server )  {  instance = this ;   jive globals . migrate property ( "provider . vcard . class name" )  ;   string class name =  jive globals . get property ( "provider . vcard . class name"  defaultv card provider . c
@ override public void   (  certificate store store )  {  restart server (  )  ;   }  
@ before test public void   (  )  throws io exception  {  sams . key set (  )  . stream (  )  . for each ( key  -  >   {  try  {  bams . put ( key convert sam to bam ( sams . get ( key )  )  )  ;  bams . get ( key )  . delete on exit (  )  ;   }  catch  (
@ test public void   (  )  {  final  list <  integer >  list = new  array list <  integer >  (  )  ;   observable . just ( 1 )  . subscribe ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  list . 
public  string   (  string part name )  {   string result = null ;  if  ( is multi part request )   {  try  {   part p = http request . get part ( part name )  ;  if  ( p  !  =  null )  result = p . get content type (  )  ;   }  catch  (  io exception ioe )   {  log ( ioe )  ;   }  catch  (   servlet exception se )   {  log ( se )  ;   }  catch  (   illegal state exception ise )   {  log ( ise )  ;  throw ise ;   }   }  return result ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
private static final boolean   ( byte[] lhs int loff int llen byte[] rhs int roff int rlen )  {  return  ( llen  =  =  rlen )  &&  data helper . eq ( lhs loff rhs roff llen )  ;   }  
@ override public jid   (  )  {  current = iter . next (  )  ;  return current ;   }  
public static  property descriptor[]   (  class bean class )  throws  introspection exception  {  try  {   jive bean info bean info =  (  jive bean info )  class utils . for name ( bean class . get name (  )   +  " bean info" )  . new instance (  )  ;  return bean info . get property descriptors (  )  ;   }  catch  (   exception e )   {   }  return  introspector . get bean info ( bean class )  . get property descriptors (  )  ;   }  
public boolean   (  list <  comment >  comments )  {  synchronized  (    comment lock )   {  if  (    comments  =  =  null )   {     comments = new  comment set ( comments )  ;  return true ;   }  else  {  synchronized  (    comments )   {  return    comments . add all ( comments )  ;   }   }   }   }  
public  list <  macro >    (  )  {  return macros ;   }  
@ override public t   ( int index t element )  {  t result = super . set ( index element )  ;  sync groups ( element add )  ;  return result ;   }  
public synchronized  location   (  inet address addr )  {  int seek   country ;  try  {  seek   country = seek countryv6 ( addr )  ;  return read city record ( seek   country )  ;   }  catch  (  io exception e )   {  throw new  invalid database exception ( " error while seting up segments" e )  ;   }   }  
public void   (  )  {  synchronized  ( this )   {  release fragments (  )  ;   }   }  
@ override public boolean   (  )  {  return    socket . is closed (  )  ;   }  
@ test public void   (  )  {   test single threaded publisher on subscribe = new  test single threaded publisher ( "one" "two" "three" )  ;   flowable <  string >  w =  flowable . unsafe create ( on subscribe )  ;   subscriber <  string >  aw = serialized
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  int missed = 1 ;  for  (  ;   ;   )   {  if  ( sa . is disposed (  )  )   {  return ;   }  source . subscribe ( this )  ;  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }   }  
private static ec point   ( ec point r ec point s  elliptic curve curve )  {  if  ( r . equals ( s )  )  return double point ( r curve )  ;  else if  ( r . equals ( ec point . point   infinity )  )  return s ;  else if  ( s . equals ( ec point . point   infinity )  )  return r ;   big integer prime =  (  ( ec field fp ) curve . get field (  )  )  . getp (  )  ;   big integer tmp = r . get affinex (  )  . subtract ( s . get affinex (  )  )  ;  tmp = new  native big integer ( tmp )  ;   big integer slope =  ( r . get affiney (  )  . subtract ( s . get affiney (  )  )  )  . multiply ( tmp . mod inverse ( prime )  )  . mod ( prime )  ;  slope = new  native big integer ( slope )  ;   big integer x out =  ( slope . mod pow ( two prime )  . subtract ( r . get affinex (  )  )  )  . subtract ( s . get affinex (  )  )  . mod ( prime )  ;   big integer y out = s . get affiney (  )  . negate (  )  . mod ( prime )  ;  y out = y out . add ( slope . multiply ( s . get affinex (  )  . subtract ( x out )  )  )  . mod ( prime )  ;  ec point out = new ec point ( x out y out )  ;  return out ;   }  
@ test public void   (  )  {   array list <  string >  items = new  array list <  string >  (  )  ;  items . add ( "one" )  ;  items . add ( "two" )  ;  items . add ( "three" )  ;  assert equals (  (  long ) 3l  observable . from iterable ( items )  . cou
protected void   ( final  socket acceptor acceptor final  string filter name final  io filter filter )  {  if  ( acceptor  =  =  null )   {   log . debug ( " not adding filter ' {  } ' to acceptor that is null . " filter name )  ;  return ;   }  final  default io filter chain builder chain = acceptor . get filter chain (  )  ;  if  ( chain . contains ( compression   filter   name )  )   {   log . debug ( " adding filter ' {  } ' as the first filter after the compression filter in acceptor  {  } " filter name acceptor )  ;  chain . add after ( compression   filter   name filter name filter )  ;   }  else if  ( chain . contains ( tls   filter   name )  )   {   log . debug ( " adding filter ' {  } ' as the first filter after the tls filter in acceptor  {  } " filter name acceptor )  ;  chain . add after ( tls   filter   name filter name filter )  ;   }  else  {   log . debug ( " adding filter ' {  } ' as the last filter in acceptor  {  } " filter name acceptor )  ;  chain . add last ( filter name filter )  ;   }   }  
@ override public void   (  disposable s )  {  @ suppress warnings ( "unchecked" )   queue disposable <  integer >  qs =  (  queue disposable <  integer >  ) s ;  qs . request fusion (  queue fuseable . any )  ;  assert false ( qs . is empty (  )  )  ;  a
public void   (  node subscription subscription boolean approved )  {  if  (  ! subscription . is authorization pending (  )  )   {  return ;   }  if  ( approved )   {  subscription . approved (  )  ;   cache factory . do cluster task ( new  modify subscription task ( subscription )  )  ;   }  else  {  cancel subscription ( subscription )  ;   }   }  
private void   (  writer out  string builder buf  list <  router info >  ris  map <  hash  points >  points )  throws io exception  {   router info us =    context . router (  )  . get router info (  )  ;  byte[] ourip = getip ( us )  ;  if  ( ourip  =  =  null )  return ;  buf . append ( " < h3 id = \"ourip\" class = \"sybils\" >  floodfills close to  our ip <  / h3 > " )  ;  boolean found = false ;  for  (   router info info : ris )   {  byte[] ip = getip ( info )  ;  if  ( ip  =  =  null )  continue ;  if  ( ip[0]  =  =  ourip[0] && ip[1]  =  =  ourip[1] )   {  buf . append ( " < p id = \"sybil   info\" >  < b > " )  ;  if  ( ip[2]  =  =  ourip[2] )   {  if  ( ip[3]  =  =  ourip[3] )   {  buf . append ( " same ip as us" )  ;  add points ( points info . get hash (  )  points   us32 " same ip as us" )  ;   }  else  {  buf . append ( " same  / 24 as us" )  ;  add points ( points info . get hash (  )  points   us24 " same  / 24 as us" )  ;   }   }  else  {  buf . append ( " same  / 16 as us" )  ;  add points ( points info . get hash (  )  points   us16 " same  / 16 as us" )  ;   }  buf . append ( ": <  / b >  <  / p > " )  ;  render router info ( buf info null false false )  ;  found = true ;   }   }  if  (  ! found )  buf . append ( " < p class = \"notfound\" >  none <  / p > " )  ;  out . write ( buf . to string (  )  )  ;  out . flush (  )  ;  buf . set length ( 0 )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 0 2 )  . parallel ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer v )  thr
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final int[] count =  { 0 }  ;   flowable . combine latest (  flowable . empty (  )   flowable . error ( new  test exception (  )  )  . do on s
static  garlic message   (  router context ctx long reply token long expiration  public key recipientpk  payload garlic config data clove  hash from  destination dest  tunnel info reply tunnel int tags to send override int low tags override  session key wrapped key  set <  session tag >  wrapped tags boolean require ack  lease set bundled reply lease set )  {   session key manager skm = ctx . client manager (  )  . get client session key manager ( from )  ;  if  ( skm  =  =  null )  return null ;   garlic config config = create garlic config ( ctx reply token expiration recipientpk data clove from dest reply tunnel require ack bundled reply lease set skm )  ;  if  ( config  =  =  null )  return null ;  int tags to send = reply token  >  =  0  ?   ( tags to send override  >  0  ?  tags to send override : skm . get tags to send (  )  )  : 0 ;  int low threshold = low tags override  >  0  ?  low tags override : skm . get low threshold (  )  ;   garlic message msg =  garlic message builder . build message ( ctx config wrapped key wrapped tags tags to send low threshold skm )  ;  return msg ;   }  
private void   (  router info next peer info  build message state state  build request record req  hash next peer )  {  long our id = req . read receive tunnel id (  )  ;  long next id = req . read next tunnel id (  )  ;  boolean is ingw = req . read is inbound gateway (  )  ;  boolean is out end = req . read is outbound endpoint (  )  ;   hash from = state . from hash ;  if  ( from  =  =  null && state . from  !  =  null )  from = state . from . calculate hash (  )  ;  if  ( is ingw && is out end )   {     context . stat manager (  )  . add rate data ( "tunnel . reject hostile" 1 )  ;     log . error ( " dropping build request  ibgw + obep: "  +  req )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  return ;   }  if  ( our id  <  =  0 || our id  >   tunnel id . max   id   value || next id  <  =  0 || next id  >   tunnel id . max   id   value )   {     context . stat manager (  )  . add rate data ( "tunnel . reject hostile" 1 )  ;  if  (    log . should warn (  )  )     log . warn ( " dropping build request  bad tunnel id: "  +  req )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  return ;   }  if  (  (  ! is out end )  &&    context . router hash (  )  . equals ( next peer )  )   {     context . stat manager (  )  . add rate data ( "tunnel . reject hostile" 1 )  ;  if  (    log . should warn (  )  )     log . warn ( " dropping build request  we are the next hop: "  +  req )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  return ;   }  if  (  ! is ingw )   {  if  ( from  =  =  null ||    context . router hash (  )  . equals ( from )  )   {     context . stat manager (  )  . add rate data ( "tunnel . reject hostile" 1 )  ;  if  (    log . should warn (  )  )     log . warn ( " dropping build request  we are the previous hop: "  +  req )  ;  return ;   }   }  if  (  (  ! is out end )  &&  (  ! is ingw )  )   {  if  ( next peer . equals ( from )  )   {     context . stat manager (  )  . add rate data ( "tunnel . reject hostile" 1 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " dropping build request with the same previous and next hop: "  +  req )  ;     context . comm system (  )  . may disconnect ( from )  ;  return ;   }   }  long time = req . read request time (  )  ;  long now =  (    context . clock (  )  . now (  )   /   ( 60l * 60l * 1000l )  )  *  ( 60 * 60 * 1000 )  ;  long time diff = now  -  time ;  if  ( time diff  >  max   request   age )   {     context . stat manager (  )  . add rate data ( "tunnel . reject too old" 1 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " dropping build request too old .  .  .  replay attack ?  "  +   data helper . format duration ( time diff )   +  ": " +  req )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  return ;   }  if  ( time diff  <  0  -  max   request   future )   {     context . stat manager (  )  . add rate data ( "tunnel . reject future" 1 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " dropping build request too far in future "  +   data helper . format duration ( 0  -  time diff )   +  ": " +  req )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  return ;   }  int response ;  if  (    context . router (  )  . is hidden (  )  )   {     context . throttle (  )  . set tunnel status (    x ( " rejecting tunnels:  hidden mode" )  )  ;  response =  tunnel history . tunnel   reject   bandwidth ;   }  else  {  response =    context . throttle (  )  . accept tunnel request (  )  ;   }  long recv delay =    context . clock (  )  . now (  )   -  state . recv time ;  if  ( response  =  =  0 )   {  float p drop =  (  ( float ) recv delay )   /   ( float )  (  build requestor . request   timeout * 3 )  ;  p drop =  ( float )  math . pow ( p drop 16 )  ;  if  (    context . random (  )  . next float (  )   <  p drop )   {     context . stat manager (  )  . add rate data ( "tunnel . reject overloaded" recv delay )  ;     context . throttle (  )  . set tunnel status (    x ( " rejecting tunnels:  request overload" )  )  ;  response =  tunnel history . tunnel   reject   transient   overload ;   }  else  {     context . stat manager (  )  . add rate data ( "tunnel . accept load" recv delay )  ;   }   }   router info ri =    context . router (  )  . get router info (  )  ;  if  ( response  =  =  0 )   {  if  ( ri  =  =  null )   {  response =  tunnel history . tunnel   reject   bandwidth ;   }  else  {  char bw = ri . get bandwidth tier (  )  . char at ( 0 )  ;  if  ( bw  !  =  'o' && bw  !  =  'n' && bw  !  =  'p' && bw  !  =  'x' &&  (  ( is ingw &&  !    context . comm system (  )  . have inbound capacity ( 87 )  )  ||  ( is out end &&  !    context . comm system (  )  . have outbound capacity ( 87 )  )  )  )   {     context . stat manager (  )  . add rate data ( "tunnel . reject conn limits" 1 )  ;     context . throttle (  )  . set tunnel status (    x ( " rejecting tunnels:  connection limit" )  )  ;  response =  tunnel history . tunnel   reject   bandwidth ;   }   }   }  if  ( response  =  =  0 &&  ! is ingw )   {  if  ( from  !  =  null &&    throttler . should throttle ( from )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " rejecting tunnel  ( hop throttle )   previous hop: "  +  from  +  ": " +  req )  ;     context . stat manager (  )  . add rate data ( "tunnel . reject hop throttle" 1 )  ;  response =  tunnel history . tunnel   reject   bandwidth ;   }   }  if  ( response  =  =  0 &&  (  ! is out end )  &&    throttler . should throttle ( next peer )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " rejecting tunnel  ( hop throttle )   next hop: "  +  req )  ;     context . stat manager (  )  . add rate data ( "tunnel . reject hop throttle" 1 )  ;  response =  tunnel history . tunnel   reject   bandwidth ;   }   hop config cfg = null ;  if  ( response  =  =  0 )   {  cfg = new  hop config (  )  ;  cfg . set creation (    context . clock (  )  . now (  )  )  ;  cfg . set expiration (    context . clock (  )  . now (  )   +  10 * 60 * 1000 )  ;  cfg . setiv key ( req . readiv key (  )  )  ;  cfg . set layer key ( req . read layer key (  )  )  ;  if  ( is ingw )   {   }  else  {  if  ( from  !  =  null )   {  cfg . set receive from ( from )  ;   }  else  {  return ;   }   }  cfg . set receive tunnel id (  data helper . to long ( 4 our id )  )  ;  if  ( is out end )   {   }  else  {  cfg . set send to ( next peer )  ;  cfg . set send tunnel id (  data helper . to long ( 4 next id )  )  ;   }  boolean success ;  if  ( is out end )  success =    context . tunnel dispatcher (  )  . join outbound endpoint ( cfg )  ;  else if  ( is ingw )  success =    context . tunnel dispatcher (  )  . join inbound gateway ( cfg )  ;  else success =    context . tunnel dispatcher (  )  . join participant ( cfg )  ;  if  ( success )   {  if  (    log . should log (  log . debug )  )     log . debug ( " joining: "  +  req )  ;   }  else  {  response =  tunnel history . tunnel   reject   bandwidth ;     context . stat manager (  )  . add rate data ( "tunnel . reject dupid" 1 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( "dup id failure: "  +  req )  ;   }   }  if  ( response  !  =  0 )   {     context . stat manager (  )  . add rate data ( "tunnel . reject . "  +  response 1 )  ;     context . message history (  )  . tunnel rejected ( from new  tunnel id ( our id )  next peer  integer . to string ( response )  )  ;  if  ( from  !  =  null )     context . comm system (  )  . may disconnect ( from )  ;  if  (  (  !    context . router hash (  )  . equals ( next peer )  )  &&  (  !    context . comm system (  )  . have outbound capacity ( 81 )  )  &&  (  !    context . comm system (  )  . is established ( next peer )  )  )   {     context . stat manager (  )  . add rate data ( "tunnel . drop conn limits" 1 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " not sending rejection due to conn limits: "  +  req )  ;  return ;   }   }  else if  ( is ingw && from  !  =  null )   {     context . comm system (  )  . may disconnect ( from )  ;   }  if  (    log . should log (  log . debug )  )     log . debug ( " responding to "  +  state . msg . get unique id (  )   +  " after " +  recv delay +  " with " +  response +  " from " +   ( from  !  =  null  ?  from : "tunnel" )  +  ": " +  req )  ;   encrypted build record reply =  build response record . create (    context response req . read reply key (  )  req . read replyiv (  )  state . msg . get unique id (  )  )  ;  int records = state . msg . get record count (  )  ;  int our slot =  - 1 ;  for  ( int j = 0 ;  j  <  records ;  j +  +  )   {  if  ( state . msg . get record ( j )   =  =  null )   {  our slot = j ;  state . msg . set record ( j reply )  ;  break ;   }   }  if  (    log . should log (  log . debug )  )     log . debug ( " read slot "  +  our slot  +  " containing: " +  req +  " accepted ?  " +  response +  " recv delay " +  recv delay +  " reply message " +  req . read reply message id (  )  )  ;  long expires =    context . clock (  )  . now (  )   +  next   hop   send   timeout ;  if  (  ! is out end )   {  state . msg . set unique id ( req . read reply message id (  )  )  ;  state . msg . set message expiration ( expires )  ;   out net message msg = new  out net message (    context state . msg expires priority next peer info )  ;  if  ( response  =  =  0 )  msg . set on failed send job ( new  tunnel build next hop fail job (    context cfg )  )  ;     context . out net message pool (  )  . add ( msg )  ;   }  else  {   tunnel build reply message reply msg ;  if  ( records  =  =   tunnel build message . max   record   count )  reply msg = new  tunnel build reply message (    context )  ;  else reply msg = new  variable tunnel build reply message (    context records )  ;  for  ( int i = 0 ;  i  <  records ;  i +  +  )  reply msg . set record ( i state . msg . get record ( i )  )  ;  reply msg . set unique id ( req . read reply message id (  )  )  ;  reply msg . set message expiration ( expires )  ;   tunnel gateway message m = new  tunnel gateway message (    context )  ;  m . set message ( reply msg )  ;  m . set message expiration ( expires )  ;  m . set tunnel id ( new  tunnel id ( next id )  )  ;  if  (    context . router hash (  )  . equals ( next peer )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " we are the reply gateway for "  +  next id  +  " when replying to reply message " +  req )  ;     context . tunnel dispatcher (  )  . dispatch ( m )  ;   }  else  {   out net message out msg = new  out net message (    context m expires priority next peer info )  ;  if  ( response  =  =  0 )  out msg . set on failed send job ( new  tunnel build next hop fail job (    context cfg )  )  ;     context . out net message pool (  )  . add ( out msg )  ;   }   }   }  
private void   (  packet original packet )  {   string subject = " content filter notification !   ( "  +  original packet . get from (  )  . get node (  )   +  " ) " ;   string body ;  if  ( original packet instanceof  message )   {   message original msg =  (  message ) original packet ;  body = " disallowed content detected in message from:"  +  original msg . get from (  )   +  " to:" +  original msg . get to (  )  +  "  message was " +   ( allow on match  ?  "allowed"  +   ( content filter . is masking content (  )   ?  " and masked . " : " but not masked . " )  : "rejected . " )  +   ( violation include original packet enabled  ?  "\n original subject:"  +   ( original msg . get subject (  )   !  =  null  ?  original msg . get subject (  )  : "" )   +  "\n original content:" +   ( original msg . get body (  )   !  =  null  ?  original msg . get body (  )  : "" )  : "" )  ;   }  else  {   presence original presence =  (  presence ) original packet ;  body = " disallowed status detected in presence from:"  +  original presence . get from (  )   +  "  status was " +   ( allow on match  ?  "allowed"  +   ( content filter . is masking content (  )   ?  " and masked . " : " but not masked . " )  : "rejected . " )  +   ( violation include original packet enabled  ?  "\n original status:"  +  original presence . get status (  )  : "" )  ;   }  if  ( violation notification byim enabled )   {  if  (  log . is debug enabled (  )  )   {   log . debug ( " content filter: sending im notification" )  ;   }  send violation notificationim ( subject body )  ;   }  if  ( violation notification by email enabled )   {  if  (  log . is debug enabled (  )  )   {   log . debug ( " content filter: sending email notification" )  ;   }  send violation notification email ( subject body )  ;   }   }  
public void   (  )  {  if  (    config . get recipient (  )   !  =  null )     log . info ( "sending garlic to recipient "  +     config . get recipient (  )  . get identity (  )  . get hash (  )  . to base64 (  )  )  ;  else    log . info ( "sending garlic to public key "  +     config . get recipient public key (  )  )  ;  send garlic (  )  ;   }  
public static  uri   ( long account id )  {  final  uri .  builder base uri =  uri . parse ( "auth: /  / "  +   email content . email   package   name  +  " . account   settings / incoming / " )  . build upon (  )  ;   intent utilities . set account id ( base uri account id )  ;  return base uri . build (  )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;  resource . dispose (  )  ;   }  
public long   (  )  {  return data store . get total responses (  )  ;   }  
@ override public void   (  )  {  cancel (  )  ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts =  test subscriber . create ( 0l )  ;  new  flowable map notification <  integer  integer >  (  flowable . range ( 1 3 )  new  function <  integer  integer >  (  )  {  @ override public  integ
private void   ( qq event e )  {   log . debug ( "qq:  processing group friend . " )  ;  try  {   download group friend reply packet p =  (  download group friend reply packet ) e . get source (  )  ;  for  (   download friend entry entry : p . friends )   {  if  ( group names  !  =  null && group names . size (  )   >  entry . group )   {   string group name = group names . get ( entry . group )  ;  friend group . put ( entry . qq num group name )  ;   list <  string >  gl = new  array list <  string >  (  )  ;  gl . add ( group name )  ;  qq buddy qq buddy = new qq buddy ( get session (  )  . get buddy manager (  )  entry . qq num gl )  ;  get session (  )  . get buddy manager (  )  . store buddy ( qq buddy )  ;   }  else  {  friend group . put ( entry . qq num default group name )  ;   list <  string >  gl = new  array list <  string >  (  )  ;  gl . add ( default group name )  ;  qq buddy qq buddy = new qq buddy ( get session (  )  . get buddy manager (  )  entry . qq num gl )  ;  get session (  )  . get buddy manager (  )  . store buddy ( qq buddy )  ;   }  get session (  )  . getqq client (  )  . user    get info ( entry . qq num )  ;   }   }  catch  (   exception ex )   {   log . error ( " failed to process group friend: " ex )  ;   }  get session (  )  . getqq client (  )  . user    get list (  )  ;   }  
private static  < k v m extends  map < k v >  > m   ( m a m b )  {  b . for each (  ( k v )   -  >  put entry ( a k v )  )  ;  return a ;   }  
@ non null @ override public  disposable   ( @ non null  runnable run long delay  time unit unit )  {   pool worker w = pool . get (  )  . get event loop (  )  ;  return w . schedule direct ( run delay unit )  ;   }  
@ test public void   (  )  throws io exception  {   path base dir = create test dirs ( 2 false )  ;   file tile metrics file =  tile metrics util . render tile metrics file from basecalling directory ( base dir . to file (  )  2 true )  ;   assert . asser
public void   ( int[] data to send )  {  if  ( member receiver  !  =  null && active )   {  kt +  +  ;  if  ( kt  <  10 )   log . info ( " speaker channel push receiver audio "  +  member receiver )  ;  member receiver . handle web rtc media ( data to send sequence number +  +  )  ;   }   }  
public boolean   (  )  {  return    context . net db (  )  . is initialized (  )  &&  (    context . net db (  )  . get known routers (  )   <   reseed checker . minimum )  ||    context . get boolean property ( "i2p . always allow reseed" )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . reduce with (  functions . just callable ( 1 )  new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  exception  {  return
@ test ( expected =  no such element exception . class )  public void   (  )  {   flowable . empty (  )  . blocking single (  )  ;   }  
public void   (  )  {  for  (   persistence manager pm : persistence managers )   {  pm . delete old history entries (  )  ;   }   }  
public static  content values   (  account account )  {   content values cv = new  content values (  )  ;  cv . put (  account columns . display   name account . get display name (  )  )  ;  cv . put (  account columns . sender   name account . get sender name (  )  )  ;  cv . put (  account columns . signature account . get signature (  )  )  ;  cv . put (  account columns . sync   interval account . m sync interval )  ;  cv . put (  account columns . flags account . m flags )  ;  cv . put (  account columns . sync   lookback account . m sync lookback )  ;  cv . put (  account columns . security   sync   key account . m security sync key )  ;  return cv ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . interval ( 1 null )  ;   }  
private void   (  )  {   string hashes =    context . get property ( prop   dsalist "" )  ;  if  (  !    user dsa list . equals ( hashes )  )   {  synchronized  (    user dsa only )   {  if  ( hashes . length (  )   >  0 )   {   set <  hash >  new set = new  hash set <  hash >  (  )  ;   string tokenizer tok = new  string tokenizer ( hashes "  ;  " )  ;  while  ( tok . has more tokens (  )  )   {   string hashstr = tok . next token (  )  ;   hash hh =  convert to hash . get hash ( hashstr )  ;  if  ( hh  !  =  null )  new set . add ( hh )  ;  else    log . error ( " bad "  +  prop   dsalist  +  " entry: " +  hashstr )  ;   }     user dsa only . add all ( new set )  ;     user dsa only . retain all ( new set )  ;     user dsa list = hashes ;   }  else  {     user dsa only . clear (  )  ;     user dsa list = "" ;   }   }   }   }  
public int   (  )  {  return    min priority ;   }  
public void   (  )  {     con key . interest ops (  selection key . op   read )  ;     transport . get writer (  )  . wants write ( this "outbound connected" )  ;   }  
private static void   ( final xmpp connection xmpp connection final int max entries final  string start point final  mapped nodes mapped nodes final int max depth final int max search nodes final  string protocol final  concurrent hash map <  string  string >  visited )  {  if  ( xmpp connection  =  =  null ||  ! xmpp connection . is connected (  )  )   {  return ;   }  if  ( mapped nodes . get relay entries (  )  . size (  )   >  max entries || max depth  <  =  0 )   {  return ;   }  if  ( start point . equals ( xmpp connection . get user (  )  )  )   {  return ;   }  if  ( visited . size (  )   >  max search nodes )   {  return ;   }   jingle trackeriq result = get services ( xmpp connection start point )  ;  visited . put ( start point start point )  ;  if  ( result  !  =  null && result . get type (  )  . equals ( iq .  type . result )  )   {  for  (  final  tracker entry entry : result . get entries (  )  )   {  if  ( entry . get type (  )  . equals (  tracker entry .  type . tracker )  )   {  mapped nodes . get tracker entries (  )  . put ( entry . get jid (  )  entry )  ;  deep search ( xmpp connection max entries entry . get jid (  )  mapped nodes max depth  -  1 max search nodes protocol visited )  ;   }  else if  ( entry . get type (  )  . equals (  tracker entry .  type . relay )  )   {  if  ( protocol  =  =  null || protocol . equals ( entry . get protocol (  )  )  )   {  mapped nodes . get relay entries (  )  . put ( entry . get jid (  )  entry )  ;   }   }   }   }   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
@ override public byte[]   (  )  {  return  data helper . to long ( 4    tunnel id )  ;   }  
private void   ( int[] previous contribution int[] new contribution double front back int delay length double non dominant channel volume )  {  int echo delay length =  ( int )  math . round ( echo delay  /  ms per sample )  ;  echo delay length* =  math . abs ( front back )  ;  echo delay length* = 2 ;  if  ( echo delay length  <  =  0 )   {  return ;   }  int channel offset ;  if  ( delay length  <  0 )   {  channel offset = 1 ;  delay length =  - delay length ;   }  else  {  channel offset = 0 ;   }  if  (  logger . log level  >  =   logger . log   info )   {  if  (  ( count1 % 200 )   =  =  0 )   {   logger . println ( "adding echo"  +  " delay length "  +  delay length  +  " c off " +  channel offset +  " edl " +  echo delay length +  " echo delay " +  echo delay +  " msps " +   (  math . round ( ms per sample * 1000 )   /  1000 .  )  )  ;   }   }  int[] c = new int[packet length] ;   system . arraycopy ( new contribution 0 c 0 c . length )  ;  int in ix = 0 ;  int out ix = echo delay length ;  int length = c . length  -  echo delay length ;  if  (  logger . log level  >  =   logger . log   info )   {  if  (  ( count1 % 200 )   =  =  0 )   {   logger . println ( "in ix "  +  in ix  +  " out ix " +  out ix +  " length " +  length )  ;   }   }  for  ( int i = 0 ;  i  <  length ;  i +  +  )   {  new contribution[out ix] = clip (  ( int )  ( c[out ix]  +   ( c[in ix] * echo volume )  )  )  ;  in ix +  +  ;  out ix +  +  ;   }  if  ( previous contribution  =  =  null )   {  count1 +  +  ;  return ;   }  if  ( delay length  =  =  0 )   {  in ix = packet length  -  echo delay length ;  out ix = 0 ;  length = echo delay length ;  for  ( int i = 0 ;  i  <  length ;  i +  +  )   {  new contribution[out ix] = clip (  ( int )  ( c[out ix]  +   ( previous contribution[in ix] * echo volume )  )  )  ;  in ix +  +  ;  out ix +  +  ;   }  count1 +  +  ;  return ;   }  in ix = packet length  -  delay length  -  echo delay length  +  channel offset ;  out ix = channel offset ;  length = echo delay length ;  if  (  ( count1 % 200 )   =  =  0 )   {   logger . println ( "in ix "  +  in ix  +  " out ix " +  out ix +  " length " +  length )  ;   }  for  ( int i = 0 ;  i  <  length ;  i +  = 2 )   {  new contribution[out ix] = clip (  ( int )  ( c[out ix]  +   ( previous contribution[in ix] * echo volume * non dominant channel volume )  )  )  ;  in ix +  = 2 ;  out ix +  = 2 ;   }  if  ( channel offset  =  =  0 )   {  out ix = 1 ;   }  else  {  out ix = 0 ;   }  in ix = out ix  +  packet length  -  echo delay length ;  length = echo delay length  -  out ix ;  if  (  ( count1 % 200 )   =  =  0 )   {   logger . println ( "in ix "  +  in ix  +  " out ix " +  out ix +  " length " +  length )  ;   }  int i = 0 ;  for  ( i = 0 ;  i  <  length ;  i +  = 2 )   {  new contribution[out ix] = clip (  ( int )  ( c[out ix]  +   ( previous contribution[in ix] * echo volume )  )  )  ;  in ix +  = 2 ;  out ix +  = 2 ;   }  count1 +  +  ;   }  
@ override public boolean   (  )  {  return qs . is empty (  )  ;   }  
@ override protected  string[]   (  )  {  final  linked list <  string >  errors = new  linked list <  >  (  )  ;  if  ( read   name   format  =  =   read name format . casava   1   8 && machine   name  =  =  null )   {  errors . add ( "machine   name is 
public long   (  )  {  if  ( is flag set ( flag   no   ack )  )  return  - 1 ;  else return    ack through ;   }  
public int   (  )  {  return    flags ;   }  
public static  flowable <  event >    ( final  string type final int num instances )  {  return  flowable .  <  event > generate ( new  event consumer ( type num instances )  )  . subscribe on (  schedulers . new thread (  )  )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
@ test public void   (  )  {  final  test scheduler scheduler = new  test scheduler (  )  ;   rx java plugins . set computation scheduler handler ( new  function <  scheduler  scheduler >  (  )  {  @ override public  scheduler apply (   scheduler v )  thr
private   (  context context  account account )  throws  messaging exception  {  m context = context ;  m account = account ;   host auth recv auth = account . get or create host auth recv ( context )  ;  m transport = new  mail transport ( context "pop3" recv auth )  ;   string[] user info parts = recv auth . get login (  )  ;  m username = user info parts[0] ;  m password = user info parts[1] ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . zip ( just1 null new  bi function <  integer  object  object >  (  )  {  @ override public  object apply (   integer a   object b )  {  return null ;   }   }   )  . bl
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  object >  func = mock (  callable . class )  ;   throwable throwable = new  illegal state exception ( " test exception" )  ;  when ( func . call (  )  )  . 
public   ( i2p app context ctx  string host int port  string user  string pass  string folder )  throws io exception  {     context = ctx ;     log = ctx . log manager (  )  . get log (  persistent mail cache . class )  ;     is drafts = folder . equals (  web mail . dir   drafts )  ;     lock = get lock ( host port user pass )  ;  synchronized  (    lock )   {     cache dir = make cache dirs ( host port user pass folder )  ;   file attach = null ;  if  ( folder . equals (  web mail . dir   folder )  )   {  import mail (  )  ;   }  else if  ( folder . equals (  web mail . dir   drafts )  )   {  attach = new  secure directory (    cache dir dir   attachments )  ;  attach . mkdirs (  )  ;   }     attachment dir = attach ;   }   }  
public void   (  string level )  {   jive globals . set property ( subscription   level level )  ;   }  
@ override public void   (  system model system model )  {  final  list <  string >  endpoint ids = new  array list <  >  (  )  ;  for  (   repose cluster repose cluster : system model . get repose cluster (  )  )   {  final  destination list destination 
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   subscription helper . cancel ( other )  ;   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  maybe peek observer < t >  ( observer this )  )  ;   }  
@ override public  single source <  object >    (  integer v )  throws  exception  {  return new  single <  object >  (  )  {  @ override protected void subscribe actual (   single observer <  ?  super  object >  observer )  {  observer . on subscribe (  
public  list <  agent session >    (  )  {  return  collections . unmodifiable list ( accepted sessions )  ;   }  
@ test public void   (  )  {  final  header value impl header value = new  header value impl ( "value" 0 . 5 )  ;  assert equals ( " header value must match expected output" "value ; q = 0 . 5" header value . to string (  )  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ test ( expected =  unsupported operation exception . class )  public void   (  )  {   immediate thin scheduler . instance . schedule periodically direct (  functions . empty   runnable 1 1  time unit . seconds )  ;   }  
public static  host auth   (  context context long id )  {  return  email content . restore content with id ( context  host auth . class  host auth . content   uri  host auth . content   projection id )  ;   }  
public int   (  string l  string r )  {  int lc =    counter . count ( l )  ;  int rc =    counter . count ( r )  ;  if  ( lc  >  rc )  return  - 1 ;  if  ( lc  <  rc )  return 1 ;  return l . compare to ( r )  ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type  method method )  {  configure for type ( registry annotation sql object type )  ;   }  
public void   (  )  {  clear (  )  ;   }  
public  string   (  )  {  return delivery path ;   }  
@ override public  single source <  ?  extends  object >    (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ override public void   (  observer <  ?  super  integer >  t1 )  {  throw new  test exception (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < b u extends  collection <  ?  super t >  >  observable < u >    (  callable <  ?  extends  observable source < b >  >  boundary supplier  callable < u >  buffer suppli
@ override public boolean   (  )  {  return it  =  =  null ;   }  
private void   (  string subdomain  string description  boolean is hidden )  {   connection con = null ;   prepared statement pstmt = null ;   long serviceid =  sequence manager . nextid (  jive constants . muc   service )  ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( create   service )  ;  pstmt . set long ( 1 serviceid )  ;  pstmt . set string ( 2 subdomain )  ;  if  ( description  !  =  null )   {  pstmt . set string ( 3 description )  ;   }  else  {  pstmt . set null ( 3  types . varchar )  ;   }  pstmt . set int ( 4  ( is hidden  ?  1 : 0 )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
@ override public  string   (  http servlet request request  http servlet response response )  {  return get values ( request . get headers ( get header name (  )  )  )  ;   }  
public int   (  )  {  return major ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . from iterable ( new  iterable <  object >  (  )  {  @ override public  iterator <  object >  iterator (  )  {  return null ;   }   }   )  . blocking last (  )  ;  
public  user   (  )  {   user page user = null ;  try  {  final  auth token auth token = get auth token (  )  ;  if  ( auth token  =  =  null )   {   log . debug ( " unable to get user: no auth token on session . " )  ;  return null ;   }  final  string username = auth token . get username (  )  ;  if  ( username  =  =  null || username . is empty (  )  )   {   log . debug ( " unable to get user: no username in auth token on session . " )  ;  return null ;   }  page user = get user manager (  )  . get user ( username )  ;   }  catch  (   exception ex )   {   log . debug ( " unexpected exception  ( which is ignored )  while trying to obtain user . " ex )  ;   }  return page user ;   }  
@ test public void   (  )  {   maybe subject <  object >  other =  maybe subject . create (  )  ;   test subscriber <  object >  ts =  flowable . empty (  )  . concat with ( other )  . test (  )  ;  assert true ( other . has observers (  )  )  ;  ts . can
public  destination   (  )  {  return rx dest ;   }  
public  element   (  map <  string  string >  meta data )  {  q name q name =  document helper . createq name ( "metadata"  document helper . create namespace ( "" "http: /  / jivesoftware . com / protocol / workgroup" )  )  ;   element meta data element =  document helper . create element ( q name )  ;  for  (   map .  entry <  string  string >  entry : meta data . entry set (  )  )   {   string name = entry . get key (  )  ;   string value = entry . get value (  )  ;   element elem = meta data element . add element ( "value" )  ;  elem . add attribute ( "name" name )  . set text ( value )  ;   }  return meta data element ;   }  
  (  observer <  ?  super t >  actual  observable source <  ?  extends t >  other )  {  this . actual = actual ;  this . other = other ;  this . empty = true ;  this . arbiter = new  sequential disposable (  )  ;   }  
private void   (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( "select name prop value from "  +  table name  +  " where ownerid =  ? " )  ;  pstmt . set long ( 1 id )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  properties . put ( rs . get string ( 1 )   db connection manager . get large text field ( rs 2 )  )  ;   }   }  catch  (  sql exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  last subscriber < t >  ( observer )  )  ;   }  
@ override public r   (  result set r int column number  statement context ctx )  throws sql exception  {  java . sql .  array array = r . get array ( column number )  ;  if  ( array  =  =  null )   {  return null ;   }  try  {  return build from result s
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   observable . create ( new  observable on subscribe <  object >  (  )  {  @ override public void subscribe (   observable emitter <  object > 
public   (  flowable < t >  source long count  predicate <  ?  super  throwable >  predicate )  {  super ( source )  ;  this . predicate = predicate ;  this . count = count ;   }  
public   (  string name  string namespace )  {  this . name = name ;  this . namespace = namespace ;   }  
public  set <  hash >    (  )  {  if  (  !    initialized )  return  collections . empty set (  )  ;   set <  map .  entry <  hash  database entry >  >  entries =    ds . get map entries (  )  ;   set <  hash >  rv = new  hash set <  hash >  ( entries . size (  )  )  ;  for  (   map .  entry <  hash  database entry >  entry : entries )   {  if  ( entry . get value (  )  . get type (  )   =  =   database entry . key   type   routerinfo )   {  rv . add ( entry . get key (  )  )  ;   }   }  return rv ;   }  
@ test public void   (  )  throws io exception  {  final  string tmp dir = io util . get default tmp dir (  )  . get absolute path (  )  ;  final  string[] args = new  string[] { "input = "  +  paired   file . get absolute path (  )  "total   reads   in  
public  destination   (  )  {   string name = get host (  )  ;  if  ( name  =  =  null )  return null ;  return i2p app context . get global context (  )  . naming service (  )  . lookup ( name )  ;   }  
@ override public void   (  string message  throwable t )  {  servlet context . log ( message   prefix  +  message t )  ;  if  ( delegate  !  =  null )   {  delegate . log ( message t )  ;   }   }  
@ override public void   (  )  {  try  {  i session . get connection service (  )  . disconnect (  )  ;   }  catch  (   exception e )   {   }  if  ( listener  !  =  null )   {  try  {  i session . get connection service (  )  . remove connection listener 
private  < t extends  traversable <  tuple2 <  integer  string >  >  > void   (  generic type < t >  container type )  {  t values = db rule . get shared handle (  )  . create query ( "select int value  name from something" )  . collect into ( container type )  ;  assert that ( values )  . contains only elements of ( expected map )  ;   }  
@ test public void   (  )  {   integer h1 = route dst1 . hash code (  )  ;   integer h2 = route dst2 . hash code (  )  ;  assert that ( h1 not ( equal to ( h2 )  )  )  ;   }  
@ override public void   (  )  {  observer . on complete (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  (  bi consumer <  integer  throwable >  ) null )  ;   }  
boolean   (  )  {   font font = gdef . get font ( fonttag   axis )  ;   paint m grid color = gdef . colors[color   mgrid] ;   paint font color = gdef . colors[color   font] ;  int label offset =  ( int )  ( worker . get font ascent ( font )   /  2 )  ;  if  (  double . is nan (  ( im . maxval  -  im . minval )   /  im . magfact )  )   {  return false ;   }  int x left = im . xorigin ;  int x right = im . xorigin  +  im . xsize ;   string labfmt ;  if  ( im . scaledstep  /  im . magfact *  math . max (  math . abs ( im . quadrant )   math . abs ( 4  -  im . quadrant )  )   <  =  1 . 0 )   {  labfmt = "%5 . 2f" ;   }  else  {  labfmt =  util . sprintf ( "%%4 . %df" 1  -   (  ( im . scaledstep  /  im . magfact  >  10 . 0 ||  math . ceil ( im . scaledstep  /  im . magfact )   =  =  im . scaledstep  /  im . magfact )   ?  1 : 0 )  )  ;   }  if  ( im . symbol  !  =  ' ' || im . unit  !  =  null )   {  labfmt +  = " " ;   }  if  ( im . symbol  !  =  ' ' )   {  labfmt +  = im . symbol ;   }  if  ( im . unit  !  =  null )   {  labfmt +  = im . unit ;   }  for  ( int i = 0 ;  i  <  =  4 ;  i +  +  )   {  int y = im . yorigin  -  im . ysize * i  /  4 ;  if  ( y  >  =  im . yorigin  -  im . ysize && y  <  =  im . yorigin )   {   string graph   label =  util . sprintf ( labfmt im . scaledstep  /  im . magfact *  ( i  -  im . quadrant )  )  ;  int length =  ( int )  ( worker . get string width ( graph   label font )  )  ;  worker . draw string ( graph   label x left  -  length  -  padding   vlabel y  +  label offset font font color )  ;  worker . draw line ( x left  -  2 y x left  +  2 y m grid color tick   stroke )  ;  worker . draw line ( x right  -  2 y x right  +  2 y m grid color tick   stroke )  ;  worker . draw line ( x left y x right y m grid color grid   stroke )  ;   }   }  return true ;   }  
@ override public void   (  string username  string name )  throws  user not found exception  {  logger . finest ( "set name" )  ;   }  
private  file transfer manager   ( xmpp server server )  {  return server . get file transfer manager (  )  ;   }  
@ override public  object   (  flowable <  integer >  o )  throws  exception  {  return  flowable . just ( 1 )  . delay subscription ( o )  ;   }  
public   ( final int min depth )  {  this . min depth = min depth ;   }  
@ override public  publisher <  boolean >    ( final long elements )  {  return  flowable . range ( 1 1000 )  . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer e )  throws  exception  {  return e  =  =  500 ;   }   }
@ benchmark public  object   (  blackhole bh )  {  return observable convert . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public int   (  )  {  return 0 ;   }  
public   (  string thread name prefix  boolean daemon  integer priority  thread group thread group  long stack size )  {  if  ( thread name prefix  =  =  null || thread name prefix . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'thread name prefix' cannot be null or an empty string . " )  ;   }  this . delegate = null ;  this . thread name prefix = thread name prefix ;  this . daemon = daemon ;  this . priority = priority ;  this . thread group = thread group ;  this . stack size = stack size ;   }  
private void   (  call participant cp )  {  loginfo ( " voice bridge migrate call" )  ;  try  {  if  ( validate and adjust parameters ( cp )  )   {  if  ( cp . migrate call (  )  )   {  new  call migrator ( this cp )  . start (  )  ;  report info ( " call migrated to "  +  cp . get second party number (  )   +  " id: " +  cp . get call id (  )  )  ;   }  else  {  report error ( " call participant is not configured for migration" )  ;   }   }   }  catch  (   exception e )   {  report error ( e . to string (  )  )  ;   }   }  
public int   (  string manager name )  {   map <  streamid  local client session >  clients = sessions by manager . get ( manager name )  ;  if  ( clients  =  =  null )   {  return 0 ;   }  else  {  return clients . size (  )  ;   }   }  
public void   (  )  {   pop3 store .  pop3 folder .  uidl parser parser = m folder . new  uidl parser (  )  ;  parser . parse multi line ( "101 "  +  unique   id   1 )  ;  assert equals ( 101 parser . m message number )  ;  assert equals ( unique   id   1 parser . m unique id )  ;  assert false ( parser . m end of message )  ;  assert false ( parser . m err )  ;  parser . parse multi line ( " . " )  ;  assert true ( parser . m end of message )  ;  assert false ( parser . m err )  ;   }  
private iq   (  answer command command iq iq )  {   map <  string  string >  headers = command . get headers (  )  ;  iq reply = iq . create resultiq ( iq )  ;   string call id = iq . get to (  )  . get node (  )  ;   string caller id = headers . get ( "caller   id" )  ;   log . info ( " rayo component  answer command "  +  caller id  +  " " +  call id )  ;  if  ( caller id  !  =  null )   {  jid calljid = getjid ( call id )  ;   call handler call handler = null ;   call handler handset handler = null ;  if  ( calljid  !  =  null )   {  caller id = caller id . substring ( 5 )  ;  headers . put ( "call   protocol" "xmpp" )  ;  headers . put ( "call   owner" caller id )  ;  headers . put ( "call   action" "join" )  ;  try  {  call handler =  call handler . find call ( call id )  ;  handset handler =  call handler . find call ( jid . escape node ( caller id )  )  ;  if  ( handset handler  !  =  null )   {   call participant hp = handset handler . get call participant (  )  ;   presence presence1 = new  presence (  )  ;  presence1 . set from ( iq . get to (  )  )  ;  presence1 . set to ( caller id )  ;  set answered state ( presence1  conference manager . is transfer call ( hp . get conference id (  )  )  headers )  ;  send packet ( presence1 )  ;   }   }  catch  (   exception e )   {  reply . set error (  packet error .  condition . item   not   found )  ;  e . print stack trace (  )  ;   }   }  else  {  call handler =  call handler . find call ( call id )  ;  handset handler =  call handler . find call ( jid . escape node ( iq . get from (  )  . to string (  )  )  )  ;   }  if  ( call handler  !  =  null && handset handler  !  =  null )   {   call participant cp = call handler . get call participant (  )  ;   call participant hp = handset handler . get call participant (  )  ;   log . info ( " rayo component handle answer command found call handlers "  +  cp . get call id (  )   +  " " +  hp . get call id (  )  )  ;  try  {  long start =  system . current time millis (  )  ;  cp . set start timestamp ( start )  ;  cp . set handset ( hp )  ;  hp . set far party ( cp )  ;  hp . set start timestamp ( start )  ;  cp . set headers ( headers )  ;   string recording = cp . get conference id (  )   +  " - "  +  cp . get start timestamp (  )  +  " . au" ;   conference manager . record conference ( cp . get conference id (  )  true recording "au" )  ;   string destination = iq . get from (  )  . get node (  )  ;   string source = cp . get name (  )  ;  if  ( calljid  !  =  null )   {  source =  ( new jid ( caller id )  )  . get node (  )  ;   config . create call record ( source recording "xmpp:"  +  iq . get from (  )  cp . get start timestamp (  )  0 "dialed" )  ;   config . create call record ( destination recording "xmpp:"  +  caller id cp . get start timestamp (  )  0 "received" )  ;  send message ( new jid ( caller id )  iq . get from (  )  " call started" recording "chat" )  ;   }  else  {   config . create call record ( destination recording "sip:"  +  cp . get phone number (  )  cp . get start timestamp (  )  0 "received" )  ;  send message ( iq . get from (  )  new jid ( cp . get call id (  )   +  "@"  +  get domain (  )  )  " call started" recording "chat" )  ;   }   }  catch  (   parse exception e1 )   {  reply . set error (  packet error .  condition . internal   server   error )  ;   }   }  else reply . set error (  packet error .  condition . item   not   found )  ;   }  else reply . set error (  packet error .  condition . item   not   found )  ;  return reply ;   }  
@ test public void   (  )  throws  exception  {  final  atomic integer tries = new  atomic integer ( 3 )  ;   handle handle = db . open (  )  ;  handle . in transaction (  transaction isolation level . serializable conn  -  >   {  if  ( tries . decrement 
public void   (  string host )  {   string host addr = host ;  if  (  host interface . isi pv6 address ( host )   =  =  true )  host addr = "["  +  host  +  "]" ;  set header ( http . host host addr )  ;   }  
public static  garlic message   (  router context ctx i2np message m  session key encrypt key  session tag encrypt tag )  {   payload garlic config payload = new  payload garlic config (  )  ;  payload . set certificate (  certificate . null   cert )  ;  payload . set id ( ctx . random (  )  . next long ( i2np message . max   id   value )  )  ;  payload . set payload ( m )  ;  payload . set delivery instructions (  delivery instructions . local )  ;  payload . set expiration ( m . get message expiration (  )  )  ;   garlic message msg =  garlic message builder . build message ( ctx payload null null null encrypt key encrypt tag )  ;  return msg ;   }  
@ test public void   (  )  {   collect wgs metrics collect wgs metrics = new  collect wgs metrics (  )  ;   fast wgs metrics collector collector = new  fast wgs metrics collector ( collect wgs metrics 100 create interval list (  )  )  ;   abstract locus i
@ test public void   (  )  {   flowable <  string >  src =  flowable . empty (  )  ;  src . distinct (  )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any string (  )  )  ;  verify ( w never (  )  )  . on error ( any (  throwable . class )
@ override public i binder   (  intent intent )  {  m binder . init ( this )  ;  return m binder ;   }  
@ test public void   (  )  {  final  string query = "a = 1&b = 4&c = 111&a = 3&d = 441&a = 2" ;  final  string actual = query string normalizer . normalize ( query )  ;  final  string[] query param pairs = actual . split ( "&" )  ;  assert equals ( "uri n
@ test public void   (  )  throws io exception  {  run analysis ( "no   bq   cutoff" "minimum   quality   score = 0" )  ;   }  
static boolean   ( final  string name )  {  if  ( security properties  =  =  null )   {  load security properties (  )  ;   }  return name  !  =  null &&  ! name . starts with (  jive globals . encrypted   property   name   prefix )  && security properties . get properties (  jive globals . encrypted   property   names true )  . contains ( name )  ;   }  
@ override public  publisher <  integer >    ( final long elements )  {  final  replay processor <  integer >  pp =  replay processor . create with size (  ( int ) elements  +  10 )  ;   schedulers . io (  )  . schedule direct ( new  runnable (  )  {  @ o
@ override public  collection <  string >    (  string key  string value )  {   set <  string >  group names = new  hash set <  >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection
public  haplotype map   ( final  set <  string >  chroms )  {  final  haplotype map out = new  haplotype map ( get header (  )  )  ;  for  (  final  haplotype block block : this . haplotype blocks )   {  if  (  ! chroms . contains ( block . get first snp (  )  . get chrom (  )  )  )   {  out . add haplotype ( block )  ;   }   }  return out ;   }  
@ override protected void   ( final  message packet )  throws  unauthorized exception  {  try  {  packet received ( packet )  ;  try  {   server socket reader . super . process message ( packet )  ;   }  catch  (   unauthorized exception e )   {   log . e
public static  attachment   (  context context long id )  {  return  email content . restore content with id ( context  attachment . class  attachment . content   uri  attachment . content   projection id )  ;   }  
 throwable   (  throwable e )  {   throwable root = e . get cause (  )  ;  if  ( root  =  =  null || cause  =  =  root )   {  return e ;   }  while  ( true )   {   throwable cause = root . get cause (  )  ;  if  ( cause  =  =  null || cause  =  =  root )   {  return root ;   }  root = cause ;   }   }  
public boolean   (  )  {  synchronized  ( this )   {  return    state  =  =   state . success ;   }   }  
  (  maybe observer <  ?  super t >  actual  action on finally )  {  this . actual = actual ;  this . on finally = on finally ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   subject <  integer >  ps =  publish subject .  <  integer > create (  )  ;   test observer <  observable <  integer >  >  to = ps . window ( 5  time unit . millisecond
public  string   (  )  {  return "http / "  +  get version (  )   +  " " +  get status code (  )  +  " " +  http status . code2 string ( status code )  +  http . crlf ;   }  
private void   (  )  throws  rrd exception  {  worker . set anti aliasing ( gdef . anti aliasing )  ;  worker . clip ( im . xorigin  +  1 im . yorigin  -  gdef . height  -  1 gdef . width  -  1 gdef . height  +  2 )  ;  double areazero = mapper . ytr (  ( im . minval  >  0 . 0 )   ?  im . minval :  ( im . maxval  <  0 . 0 )   ?  im . maxval : 0 . 0 )  ;  double[] x = xtr ( dproc . get timestamps (  )  )   lasty = null ;  for  (   plot element plot element : gdef . plot elements )   {  if  ( plot element instanceof  sourced plot element )   {   sourced plot element source =  (  sourced plot element ) plot element ;  double[] y = ytr ( source . get values (  )  )  ;  if  ( source instanceof  line )   {  worker . draw polyline ( x y source . color new  basic stroke (  (  (  line ) source )  . width )  )  ;   }  else if  ( source instanceof  area )   {  worker . fill polygon ( x areazero y source . color )  ;   }  else if  ( source instanceof  stack )   {   stack stack =  (  stack ) source ;  float width = stack . get parent line width (  )  ;  if  ( width  >  =  0f )   {  worker . draw polyline ( x y stack . color new  basic stroke ( width )  )  ;   }  else  {  worker . fill polygon ( x lasty y stack . color )  ;  worker . draw polyline ( x lasty stack . get parent color (  )  new  basic stroke ( 0 )  )  ;   }   }  else  {  throw new  rrd exception ( " unknown plot source: "  +  source . get class (  )  . get name (  )  )  ;   }  lasty = y ;   }   }  worker . reset (  )  ;  worker . set anti aliasing ( false )  ;   }  
public double   (  )  {  return maximum ;   }  
public boolean   (  )  {  return    context . get boolean property (  stat manager . prop   stat   full )  ;   }  
public void   ( long delta )  {  if  ( delta  >   - 60 * 1000 && delta  <  60 * 1000 )  return ;  synchronized  (    state lock )   {  if  ( graceful shutdown in progress (  )  ||  ! is alive (  )  )  return ;   }     event log . add event (  event log . clock   shift  long . to string ( delta )  )  ;     context . router key generator (  )  . generate date based mod data (  )  ;  if  ( delta  >  0 )     log . error ( " restarting after large clock shift forward by "  +   data helper . format duration ( delta )  )  ;  else    log . error ( " restarting after large clock shift backward by "  +   data helper . format duration ( 0  -  delta )  )  ;  restart (  )  ;   }  
public   (  flowable < t >  source int size int skip  callable < c >  buffer supplier )  {  super ( source )  ;  this . size = size ;  this . skip = skip ;  this . buffer supplier = buffer supplier ;   }  
@ test public void   (  )  {   replay processor <  object >  rs =  replay processor . create (  )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has value (  )  )  ;  rs . on next ( 1 )  ;  assert equals ( 1 rs . size (  )  )  ;  assert t
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public   (  string key  string value )  {  this . key = key ;  this . value = value ;   }  
@ test public void   (  )  {   flowable <  integer >  cache =  flowable . just ( 1 2 )  . cache (  )  ;  cache . test (  )  ;  cache . take ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
public   (  maybe source < t >  source  publisher < u >  other )  {  super ( source )  ;  this . other = other ;   }  
public  multi user chat service   ( jid jid )  {   string subdomain = jid . get domain (  )  . replace ( " . "  +  xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  "" )  ;  return get multi user chat service ( subdomain )  ;   }  
@ test public void   (  )  {  final  object[] event =  { null }  ;   single . just ( 1 )  . do on success ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  throws  exception  {  event[0] = e ;   }   }   )  . test (  )  
@ override public int   (  )  throws  cannot calculate size exception  {  int size = 0 ;  size +  =  cache sizes . size of object (  )  ;  size +  =  cache sizes . size of collection ( roster items . values (  )  )  ;  size +  =  cache sizes . size of str
@ override public  string   (  )  {  return "\""  +  m string  +  "\"" ;   }  
@ override public void   (  throwable t )  {  s =  subscription helper . cancelled ;  item = null ;  actual . on error ( t )  ;   }  
public   (  iterable <  ?  extends  disposable >  resources )  {   object helper . require non null ( resources "resources is null" )  ;  this . resources = new  linked list <  disposable >  (  )  ;  for  (   disposable d : resources )   {   object helper . require non null ( d " disposable item is null" )  ;  this . resources . add ( d )  ;   }   }  
@ override public void   ( int readlimit )  {  input stream . mark ( readlimit )  ;   }  
private void   (  )  {  if  (  ! gdef . only graph &&  ! gdef . no legend )   {  int ascent =  ( int ) worker . get font ascent ( gdef . get font ( fonttag   legend )  )  ;  int box =  ( int ) get box (  )   box space =  ( int )  ( get box space (  )  )  ;  for  (   comment text c : gdef . comments )   {  if  ( c . is valid graph element (  )  )   {  int x = c . x  y = c . y  +  ascent ;  if  ( c instanceof  legend text )   {  worker . fill rect ( x y  -  box box box gdef . colors[color   frame] )  ;  worker . fill rect ( x  +  1 y  -  box  +  1 box  -  2 box  -  2 gdef . colors[color   canvas] )  ;  worker . fill rect ( x  +  1 y  -  box  +  1 box  -  2 box  -  2  (  (  legend text ) c )  . legend color )  ;  worker . draw string ( c . resolved text x  +  box space y gdef . get font ( fonttag   legend )  gdef . colors[color   font] )  ;   }  else  {  worker . draw string ( c . resolved text x y gdef . get font ( fonttag   legend )  gdef . colors[color   font] )  ;   }   }   }   }   }  
@ override protected int   (  )  {  return 1 ;   }  
private void   ( final  file plugin )  {  final j dialog dialog = new j dialog ( frame " installing  plugin" true )  ;  dialog . get content pane (  )  . set layout ( new  border layout (  )  )  ;  j progress bar bar = new j progress bar (  )  ;  bar . set indeterminate ( true )  ;  bar . set string ( " installing  plugin .   please wait .  .  . " )  ;  bar . set string painted ( true )  ;  dialog . get content pane (  )  . add ( bar  border layout . center )  ;  dialog . pack (  )  ;  dialog . set size ( 225 55 )  ;  final  swing worker <  file  void >  installer thread = new  swing worker <  file  void >  (  )  {  @ override public  file do in background (  )  {   file plugins dir = new  file ( bin dir . get parent file (  )  "plugins" )  ;   string temp name = plugin . get name (  )   +  " . part" ;   file temp plugins file = new  file ( plugins dir temp name )  ;   file real plugins file = new  file ( plugins dir plugin . get name (  )  )  ;  try  {   thread . sleep ( 2000 )  ;  copy ( plugin . touri (  )  . tourl (  )  temp plugins file )  ;  temp plugins file . rename to ( real plugins file )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }  return real plugins file ;   }  @ override public void done (  )  {  dialog . set visible ( false )  ;   }   }   ;  installer thread . execute (  )  ;  dialog . set location relative to ( frame )  ;  dialog . set visible ( true )  ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  actual . on next ( u )  ;  actual . on complete (  )  ;   }  
private void   ( final  file file )  {  try  ( final vcf file reader reader = new vcf file reader ( file false )  )  {  final sam sequence dictionary dict = reader . get file header (  )  . get sequence dictionary (  )  ;  if  ( dict  =  =  null || dict . get sequences (  )  . is empty (  )  )   {  throw new  illegal state exception ( " haplotype map vcf file must contain header: "  +  file . get absolute path (  )  )  ;   }  initialize ( new sam file header ( dict )  )  ;  final  map <  string  haplotype block >  anchor to haplotype = new  hash map <  >  (  )  ;  for  (  final  variant context vc : reader )   {  if  ( vc . getn samples (  )   >  1 )   {  throw new  illegal state exception ( " haplotype map vcf file must contain at most one sample: "  +  file . get absolute path (  )  )  ;   }  final  genotype gc = vc . get genotype ( 0 )  ;  final boolean has gc = gc  !  =  null ;  if  ( vc . get alternate alleles (  )  . size (  )   !  =  1 )   {  throw new  illegal state exception ( " haplotype map vcf file must contain exactly one alternate allele per site: "  +  vc . to string (  )  )  ;   }  if  (  ! vc . issnp (  )  )   {  throw new  illegal state exception ( " haplotype map vcf file must contain only sn ps: "  +  vc . to string (  )  )  ;   }  if  (  ! vc . has attribute ( vcf constants . allele   frequency   key )  )   {  throw new  illegal state exception ( " haplotype map vcf  variants must have an '"  +  vcf constants . allele   frequency   key  +  "' info field: " +  vc . to string (  )  )  ;   }  if  ( has gc && gc . is phased (  )  &&  ! gc . has extended attribute ( vcf constants . phase   set   key )  )   {  throw new  illegal state exception ( " haplotype map vcf  variants' genotypes that are phased must have a  phase set  ( "  +  vcf constants . phase   set   key  +  " ) " +  vc . to string (  )  )  ;   }  if  ( has gc && gc . is phased (  )  &&  ! gc . is het (  )  )   {  throw new  illegal state exception ( " haplotype map vcf  variants' genotypes that are phased must be het"  +  vc . to string (  )  )  ;   }  final  string chrom = vc . get contig (  )  ;  final int pos = vc . get start (  )  ;  final  string name = vc . getid (  )  ;  final byte ref = vc . get reference (  )  . get bases (  ) [0] ;  final byte var = vc . get alternate allele ( 0 )  . get bases (  ) [0] ;  final double temp   maf = vc . get attribute as double ( vcf constants . allele   frequency   key 0d )  ;  final boolean swapped = has gc &&  ! gc . get allele ( 0 )  . equals ( vc . get reference (  )  )  ;  final byte major  minor ;  final double maf ;  if  ( swapped )   {  major = var ;  minor = ref ;  maf = 1  -  temp   maf ;   }  else  {  major = ref ;  minor = var ;  maf = temp   maf ;   }  final  string anchor = anchor from vc ( vc )  ;  if  (  ! anchor to haplotype . contains key ( anchor )  )   {  final  haplotype block new block = new  haplotype block ( maf )  ;  anchor to haplotype . put ( anchor new block )  ;   }  final  haplotype block block = anchor to haplotype . get ( anchor )  ;  block . add snp ( new  snp ( name chrom pos major minor maf null )  )  ;   }  anchor to haplotype . values (  )  . for each ( this::add haplotype )  ;   }   }  
protected int   (  )  {  return 4  +   data helper . date   length ;   }  
@ test public void   (  )  {   multicast processor <  integer >  mp = new  multicast processor <  integer >  ( 128 true )  ;   unicast processor <  integer >  up =  unicast processor . create (  )  ;  up . subscribe ( mp )  ;   test subscriber <  integer 
@ test public void   (  )  {   observer <  string >  observer =  test helper . mock observer (  )  ;   observable <  string >  origin =  observable . unsafe create ( new  func with errors ( 2 )  )  ;  origin . retry when ( new  function <  observable <  ?
@ test ( expected exceptions = sam exception . class )  public void   (  )  {  final  string[] args = make checker args ( new  file ( "a   made   up   file / in   some   weird   location" )  1 "76t76t" new  illumina data type[] {  illumina data type .  po
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  integer >   object >  (  )  {  @ override public  object apply (   flowable <  integer >  o )  throws  exception  {  return o . all (  functions . always
  (  string type name )  {  this . type name = type name ;   }  
public   (  )  throws io exception  {  when ( mock response . get output stream (  )  )  . then return ( new  servlet output stream (  )  {  @ override public void write (  int b )  throws io exception  {   }   }   )  ;  response = new  http servlet response wrapper ( mock response  response mode . passthrough  response mode . readonly )  ;   }  
protected final  socket channel   (  )  {  return socket ;   }  
@ test public void   (  )  {  fetch from ( "http: /  / example . i2p" false )  ;   }  
@ override public  string   (  )  {  return "http: /  / jabber . org / protocol / admin#status - http - bind" ;   }  
private static void   (  string sam host int sam port )  {  test valid version ( sam host sam port )  ;  test invalid version ( sam host sam port )  ;  test corrupt line ( sam host sam port )  ;   }  
public void   (  )  {  compiled patterns . clear (  )  ;   }  
@ override public void   (  disposable s )  {   disposable helper . set once ( this s )  ;   }  
public  string   (  )  {  return business country ;   }  
@ test public void   (  )  {   test resource single observer <  integer >  rso = new  test resource single observer <  integer >  (  )  ;  assert false ( rso . is disposed (  )  )  ;   disposable d =  disposables . empty (  )  ;  rso . add ( d )  ;  asser
public void   (  registration event evt )  {  try  {  sip manager . stop (  )  ;   log . debug ( " stopped" )  ;   }  catch  (   communications exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
@ override public void   (  )  {  if  ( timer  !  =  null )   {  try  {  timer . cancel (  )  ;   }  catch  (   exception e )   {   }  timer = null ;   }  if  ( status check  !  =  null )   {  try  {  status check . cancel (  )  ;   }  catch  (   exceptio
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  setup open folder ( mock transport 0 null )  ;  m folder . open (  open mode . read   only )  ;   }  
private static boolean   (  file file  key store ks )  {  if  (  ! file . exists (  )  )  return false ;   input stream fis = null ;  try  {  fis = new  file input stream ( file )  ;  ks . load ( fis default   keystore   password . to char array (  )  )  ;  info ( " certs loaded from "  +  file )  ;   }  catch  (   general security exception gse )   {  error ( " key store load error  no default keys: "  +  file . get absolute path (  )  gse )  ;  try  {  ks . load ( null default   keystore   password . to char array (  )  )  ;   }  catch  (  io exception foo )   {   }  catch  (   general security exception e )   {   }  return false ;   }  catch  (  io exception ioe )   {  error ( " key store load error  no default keys: "  +  file . get absolute path (  )  ioe )  ;  try  {  ks . load ( null default   keystore   password . to char array (  )  )  ;   }  catch  (  io exception foo )   {   }  catch  (   general security exception e )   {   }  return false ;   }  finally  {  try  {  if  ( fis  !  =  null )  fis . close (  )  ;   }  catch  (  io exception foo )   {   }   }  return true ;   }  
@ override public void   (  context context  intent intent )  {   email broadcast processor service . process device policy message ( context device   admin   message   password   expiring )  ;   }  
@ test public void   (  )  {   replay processor <  string >  processor =  replay processor . create (  )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  (
  ( int value )  {  this . value = value ;   }  
public  hash   (  )  {  return    to router ;   }  
public  string   (  )  {  return config file (  )  . to string (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . zip with (  arrays . as list ( 1 )  new  bi function <  integer  integer  object >  (  )  {  @ override public  object apply (   integer a   integer b )  {  return null 
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . just ( 1 1 1 1 2 )  . collect into ( new  hash set <  integer >  (  )  new  bi consumer <  hash set <  integer >   integer >  (  )  {  @ override public void accept (   hash 
public synchronized long   (  )  {  return    next send ;   }  
@ override public final void   ( @ non null  disposable s )  {  if  (  end consumer helper . validate ( this . s s get class (  )  )  )   {  this . s = s ;  on start (  )  ;   }   }  
@ override public  string   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
public  event dispatcher   (  )  {  return this ;   }  
@ before public void   (  )  throws  exception  {  inet socket address = new  inet socket address (  inet address . get by address ( new byte[] { 10 1 1 11 }  )  2200 )  ;  local datastore = mock (  datastore . class )  ;  cluster view = mock (  cluster v
public int   (  )  {  if  (    context  =  =  null )  return 0 ;  else return    context . tunnel manager (  )  . get inbound client tunnel count (  )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on error ( t )  ;   }  
public synchronized long   (  )  {  return    lifetime event count ;   }  
 lease request state   (  hash h )  {   session params sp =    sessions . get ( h )  ;  if  ( sp  =  =  null )  return null ;  return sp . lease request ;   }  
@ test public void   (  )  {   test observable f = new  test observable ( "one" "throwable" "two" "three" )  ;   flowable <  string >  w =  flowable . unsafe create ( f )  ;   flowable <  string >  resume =  flowable . just ( "two resume" "three resume" )
public  notification < t >    (  )  throws  interrupted exception  {  set waiting (  )  ;   blocking helper . verify non blocking (  )  ;  return buf . take (  )  ;   }  
public int   (  )  {  return portb ;   }  
public void   ( iq packet  workgroup workgroup )  {  iq reply = iq . create resultiq ( packet )  ;  try  {   agent session agent session = workgroup . get agent manager (  )  . get agent session ( packet . get from (  )  )  ;  if  ( agent session  =  =  null )   {  reply = iq . create resultiq ( packet )  ;  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . not   authorized )  )  ;  workgroup . send ( reply )  ;  return ;   }   }  catch  (   agent not found exception e )   {  reply = iq . create resultiq ( packet )  ;  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . not   authorized )  )  ;  workgroup . send ( reply )  ;  return ;   }   element chat sessions = reply . set child element ( "chat - metadata" "http: /  / jivesoftware . com / protocol / workgroup" )  ;   element iq = packet . get child element (  )  ;   string sessionid = iq . element ( "sessionid" )  . get text trim (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;   map <  string  string >  map = new  hash map <  string  string >  (  )  ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   session   metadata )  ;  pstmt . set string ( 1 sessionid )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   string name = rs . get string ( 1 )  ;   string value = rs . get string ( 2 )  ;  map . put ( name value )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  chat sessions . add ( get meta data element ( map )  )  ;  workgroup . send ( reply )  ;   }  
@ test public void   (  )  throws io exception  {  assert equals ( " buffer should return negative one on empty single byte read"  - 1 buffer . get (  )  )  ;   }  
@ test public void   (  )  {   flowable . merge delay error (  flowable . just (  flowable . just ( 1 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )   flowable . just ( 2 )  )  )  . test (  )  . assert failure (  test 
public void   (  delivery instructions instr )  {     instructions = instr ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . sample ( 1  time unit . days true )  . test (  )  . assert result ( 1 )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  throws  exception  {  new  timed <  integer >  ( 1 5 null )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . complete (  )  . do on subscribe ( null )  ;   }  
public void   ( int encoding int sample rate int channels )  throws  parse exception  {  if  ( sample rate  =  =  8000 && channels  =  =  1 )   {  encoding =  rtp packet . pcmu   encoding ;   }  set preferred media info ( find media info ( encoding sample rate channels )  )  ;   }  
public boolean   (  )  {  return  !    found ;   }  
public jid   (  )  {  return contact ;   }  
public static  < t > void   (  subscriber <  ?  super t >  s  iterator <  ?  extends t >  it )  {  boolean has next ;  try  {  has next = it . has next (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   empty subscription . error ( e s )  ;  return ;   }  if  (  ! has next )   {   empty subscription . complete ( s )  ;  return ;   }  if  ( s instanceof  conditional subscriber )   {  s . on subscribe ( new  iterator conditional subscription < t >  (  (  conditional subscriber <  ?  super t >  ) s it )  )  ;   }  else  {  s . on subscribe ( new  iterator subscription < t >  ( s it )  )  ;   }   }  
@ test public void   (  )  {   observable . just ( 1 )  . concat with (  observable . just ( 2 )  . delay ( 500  time unit . milliseconds )  )  . skip last ( 300  time unit . milliseconds  schedulers . io (  )  true )  . test (  )  . await done ( 5  time 
void   ( int size )  {     peak throughput current total +  = size ;   }  
private void   ( int doop )  throws  rrd exception  {  if  ( doop  >  =  0 )   {  op = doop ;  expect token (  time token . number " there should be number after "  +   ( op  =  =   time token . plus  ?  ' + ' : ' - ' )  )  ;  prev   multiplier =  - 1 ;   }  int delta =  integer . parse int ( token . value )  ;  token = scanner . next token (  )  ;  if  ( token . id  =  =   time token . months   minutes )   {  switch  ( prev   multiplier )   {  case  time token . days: case  time token . weeks: case  time token . months: case  time token . years: token = scanner . resolve months minutes (  time token . months )  ;  break ;  case  time token . seconds: case  time token . minutes: case  time token . hours: token = scanner . resolve months minutes (  time token . minutes )  ;  break ;  default : if  ( delta  <  6 )   {  token = scanner . resolve months minutes (  time token . months )  ;   }  else  {  token = scanner . resolve months minutes (  time token . minutes )  ;   }   }   }  prev   multiplier = token . id ;  delta* =  ( op  =  =   time token . plus )   ?   + 1 :  - 1 ;  switch  ( token . id )   {  case  time token . years: spec . dyear +  = delta ;  break ;  case  time token . months: spec . dmonth +  = delta ;  break ;  case  time token . weeks: delta* = 7 ;  spec . dday +  = delta ;  break ;  case  time token . days: spec . dday +  = delta ;  break ;  case  time token . hours: spec . dhour +  = delta ;  break ;  case  time token . minutes: spec . dmin +  = delta ;  break ;  case  time token . seconds: default : spec . dsec +  = delta ;  break ;   }   }  
@ test public void   (  )  {   pending gateway message pending = create pending ( 949 false false )  ;   array list <  pending gateway message >  messages = new  array list <  pending gateway message >  (  )  ;  messages . add ( pending )  ;   tunnel gate
public void   (  service s )  {   node service list node = get device node (  )  . get node (  service list . elem   name )  ;  if  ( service list node  =  =  null )   {  service list node = new  node (  service list . elem   name )  ;  get device node (  )  . add node ( service list node )  ;   }  service list node . add node ( s . get service node (  )  )  ;   }  
private int   (  )  {  int removed = 0 ;  int remaining = 0 ;  long now =    context . clock (  )  . now (  )  ;  synchronized  (    inbound tag sets )   {  for  (  iterator <  tag set >  iter =    inbound tag sets . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   tag set ts = iter . next (  )  ;  if  ( ts . get date (  )   <  =  now )   {  iter . remove (  )  ;  removed +  +  ;   }   }  remaining =    inbound tag sets . size (  )  ;  if  ( remaining  >  500 )   {   map <  session key  set <  tag set >  >  inbound sets = get inbound tag sets by session key (  )  ;  for  (   map .  entry <  session key  set <  tag set >  >  e : inbound sets . entry set (  )  )   {   session key skey = e . get key (  )  ;   set <  tag set >  sets = e . get value (  )  ;  int count = sets . size (  )  ;  if  ( count  >  =  10 )   {  if  (    log . should info (  )  )     log . info ( " session key "  +  skey . to base64 (  )   +  " has " +  count +  " tag sets" )  ;  long age =  math . min ( 5 * 60 * 1000  math . max ( 60 * 1000 9 * 60 * 1000  -   (  ( count  -  10 )  * 8 * 60* 1000  /  40 )  )  )  ;  for  (   tag set ts : sets )   {   set <  session tag >  tags = ts . get tags (  )  ;  int cur size = tags . size (  )  ;  int orig size = ts . get original size (  )  ;  long expires = ts . get date (  )  ;  if  ( cur size  =  =  orig size && cur size  >  8 && expires  <  now  +  session   lifetime   max   ms  -  age )   {  if  (    log . should info (  )  )     log . info ( " removed unused tag set "  +  ts )  ;  for  (   session tag tag : tags )   {     inbound tag sets . remove ( tag )  ;   }  removed +  = cur size ;   }   }   }   }  remaining =    inbound tag sets . size (  )  ;   }   }     context . stat manager (  )  . add rate data ( "crypto . session tags remaining" remaining 0 )  ;  if  ( removed  >  0 &&    log . should info (  )  )     log . info ( " expired inbound: "  +  removed )  ;  int oremoved = 0 ;  synchronized  (    outbound sessions )   {  for  (  iterator <  outbound session >  iter =    outbound sessions . values (  )  . iterator (  )  ;  iter . has next (  )  ;   )   {   outbound session sess = iter . next (  )  ;  oremoved +  = sess . expire tags (  )  ;  if  ( sess . get last used date (  )   <  now  -   ( session   lifetime   max   ms  /  2 )  && sess . available tags (  )   <  =  0 )   {  iter . remove (  )  ;  oremoved +  +  ;   }   }   }  if  ( oremoved  >  0 &&    log . should info (  )  )     log . info ( " expired outbound: "  +  oremoved )  ;  return removed  +  oremoved ;   }  
@ data provider ( name = " " )  public  object[][] query non existant tag (  )  {  return new  object[][] {  { "ok / sorted - single . sam" }  }  ;   }  
public  presence type   (  msn user status msn status )  {  if  ( msn status . equals (  msn user status . online )  )   {  return  presence type . available ;   }  else if  ( msn status . equals (  msn user status . away )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . be   right   back )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . busy )  )   {  return  presence type . dnd ;   }  else if  ( msn status . equals (  msn user status . idle )  )   {  return  presence type . away ;   }  else if  ( msn status . equals (  msn user status . offline )  )   {  return  presence type . unavailable ;   }  else if  ( msn status . equals (  msn user status . on   the   phone )  )   {  return  presence type . dnd ;   }  else if  ( msn status . equals (  msn user status . out   to   lunch )  )   {  return  presence type . xa ;   }  else  {  return  presence type . unknown ;   }   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  integer >  source =  publish subject . create (  )  ;   observable <  timed <  integer >  >  m = source . timestamp ( scheduler )  ;  m . subscribe 
public  group element   (  )  {  return to rep (  representation . cached )  ;   }  
private static int   ( int code int[] codes )  {  return codes[code] ;   }  
private static void   ( byte[] a byte[] b )  {  for  ( int i = 0 ;  i  <  32 ;  i +  +  )   {  b[i]^ = a[i] ;   }   }  
private synchronized static void   (  )  {  if  ( openfire properties  =  =  null )   {  if  ( home  =  =  null &&  ! failed loading )   {  failed loading = true ;   string builder msg = new  string builder (  )  ;  msg . append ( " critical  error !   the home directory has not been configured  \n" )  ;  msg . append ( "which will prevent the application from working correctly . \n\n" )  ;   system . err . println ( msg . to string (  )  )  ;   }  else  {  try  {  openfire properties = new xml properties ( home  +   file . separator  +  get config name (  )  )  ;   }  catch  (  io exception ioe )   {   log . error ( ioe . get message (  )  )  ;  failed loading = true ;   }   }  if  ( openfire properties  =  =  null )   {  try  {  openfire properties = new xml properties (  )  ;   }  catch  (  io exception e )   {   log . error ( " failed to setup default openfire properties" e )  ;   }   }   }   }  
private static void   (  log log  string action  string name  list <  destination >  dests  string olddest  address book addressbook )  {  if  ( log  !  =  null )   {   string builder buf = new  string builder ( 16 )  ;  final int sz = dests . size (  )  ;  for  ( int i = 0 ;  i  <  sz ;  i +  +  )   {  buf . append ( dests . get ( i )  . to base64 (  )  . substring ( 0 6 )  )  ;  if  ( i  !  =  sz  -  1 )  buf . append ( "  " )  ;   }  log . append ( " action: "  +  action  +  " failed because" +  " destinations for " +  name +  "  ( " +  buf +  ' ) ' +  " do not include" +  "  ( " +  olddest . substring ( 0 6 )  +  ' ) ' +  " .   from: " +  addressbook . get location (  )  )  ;   }   }  
@ test public void   (  )  {   behavior processor <  object >  p =  behavior processor . create (  )  ;  p . on complete (  )  ;   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  p . on error ( new  test exception (  )  )
@ override public  servlet context   (  string s )  {  return proxy . get context ( s )  ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . with latest from ( new  crashing mapped iterable <  observable <  integer >  >  ( 1 100 100 new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >
public  date   (  )  {  return registration date ;   }  
public static int   (  )  {  return 8 ;   }  
@ test public void   (  )  {   single <  object >  cache =  single . error ( new  test exception (  )  )  . cache (  )  ;  cache . test (  )  . assert failure (  test exception . class )  ;  cache . test (  )  . assert failure (  test exception . class ) 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test observer <  integer >  to = new  test observer <  integer >  (  )  ;  final  replay subject <  integer >  rp =  replay subject . cr
protected void   (  output stream out  input stream in  output stream i2pout  input stream i2pin  socket s  socket i2ps  thread t1  thread t2 )  throws  interrupted exception  {  try  {  out . flush (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  i2pout . flush (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  i2pin . close (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  s . close (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  i2ps . close (  )  ;   }  catch  (  io exception ioe )   {   }  t1 . join ( 30 * 1000 )  ;  t2 . join ( 30 * 1000 )  ;   }  
@ override public boolean   ( boolean forced )  {  this . pinger . stop (  )  ;  this . sink . stop (  )  ;  return super . close ( forced )  ;   }  
public   ( i2p app context ctx )  {     context = ctx ;   }  
@ test public void   (  )  {   flowable . range ( 1 1000 )  . parallel ( 2 )  . run on (  schedulers . computation (  )  )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return v % 2
public int   (  )  {  throw new  unsupported operation exception (  )  ;   }  
void   (  )  {  if  ( compare and set ( 0 1 )  )   {  try  {  on finally . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }   }   }  
void   (  )  {  a ( "" false )  ;   }  
public void   (  string serial )  {  this . serial =  data helper . striphtml ( serial )  ;   }  
public void   (  signing private key spk )  {  sign it ( spk prop   sig )  ;   }  
@ override public  string   (  string username )  throws  user not found exception  {  final  auth provider provider = mapper . get auth provider ( username )  ;  if  ( provider  =  =  null )   {  throw new  user not found exception (  )  ;   }  return pr
@ test public void   (  )  {   single . just ( 1 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . empty (  )  
  (  maybe observer <  ?  super t >  actual  maybe source < t >  source )  {  this . main = new  delay maybe observer < t >  ( actual )  ;  this . source = source ;   }  
public  string   (  )  {  return title ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
@ override public void   ( t t )  {  if  ( source mode  !  =   queue subscription . async )   {  queue . offer ( t )  ;   }  parent . drain (  )  ;   }  
@ check return value @ backpressure support (  backpressure kind . unbounded   in )  @ scheduler support (  scheduler support . none )  public final  maybe < t >    (  )  {  return  rx java plugins . on assembly ( new  flowable last maybe < t >  ( this ) 
@ test public void   (  )  {  final  atomic integer dispose count = new  atomic integer (  )  ;   maybe . using (  functions . just callable ( 1 )  new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer
@ deprecated public final  key cache entry   (  )  {   key cache entry rv =    available keys . poll (  )  ;  if  ( rv  !  =  null )  return rv ;  return create new (  )  ;   }  
@ test public void   (  )  {  assert equals (  string utils . replace ( " hello  foo  foo" " foo" " world" )  " hello  world  world" )  ;  assert equals (  string utils . replace ( " hello  foo foo" " foo" " world" )  " hello  world foo" )  ;  assert equa
public boolean   (  )  {  return stopped speaking ;   }  
@ override public void   (  throwable e )  {  fail ( e . get message (  )  )  ;   }  
public static void   ( final  string[] argv )  {  new  vcf format converter (  )  . instance main with exit ( argv )  ;   }  
public int   (  hash destination )  {   tunnel pool pool =    client outbound pools . get ( destination )  ;  if  ( pool  !  =  null )  return pool . get tunnel count (  )  ;  return 0 ;   }  
public static void   (  roster event listener listener )  {  if  ( listener  =  =  null )   {  throw new  null pointer exception (  )  ;   }  listeners . add ( listener )  ;   }  
void   (  subscriber <  ?  > [] subscribers  throwable ex )  {  for  (   subscriber <  ?  >  s : subscribers )   {   empty subscription . error ( ex s )  ;   }   }  
public void   (  string name )  {  deletion marks . add last (  data helper . striphtml ( name )  )  ;   }  
public void   (  )  {   mock transport mock transport = open and inject mock transport (  )  ;  setup open folder ( mock transport new  string[] { "* id (  \"name\" \" godaddy imap\" \"version\" \"3 . 1 . 0\" ) " "ok" }  "read - write" )  ;  try  {  m folder . open (  open mode . read   write )  ;  fail ( " expected  messaging exception" )  ;   }  catch  (   messaging exception expected )   {   }   }  
@ test public void   (  )  {   observable <  integer >  w =  observable . from iterable (  arrays . as list ( 1 2 3 )  )  . take ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer t1 )  {  throw new  
@ test public void   (  )  {   replay subject <  integer >  source =  replay subject . create (  )  ;   observer <  integer >  done =  disposing observer . instance ;   observer <  integer >  o =  test helper . mock observer (  )  ;   in order in order = 
public void   ( org . xmpp . packet .  roster .  item item )  throws  shared group exception  {  set groups ( new  linked list <  >  ( item . get groups (  )  )  )  ;  set nickname ( item . get name (  )  )  ;   }  
@ override public void   (  )  {  logger . log ( " compressing filter is being destroyed .  .  . " )  ;   }  
@ data provider ( name = " output files" )  public static  object[][]   (  )  {  return new  object[][] {  { output   data   path  +  "update vcf sequence dictionary test - delete - me . vcf" }   { std   out   name }  }  ;   }  
public  date   (  )  {  return modification date ;   }  
protected  string   (  collection <  string >  values )  {  return get values (  collections . enumeration ( values )  )  ;   }  
private  string   (  destination d )  {   string hf ;   string hc ;  byte[] b = new byte[d . size (  )   +  this . cloak key . length] ;   system . arraycopy ( b 0 d . to byte array (  )  0 d . size (  )  )  ;   system . arraycopy ( b d . size (  )  this . cloak key 0 this . cloak key . length )  ;  hc =  base32 . encode ( sha256 generator . get instance (  )  . calculate hash ( b )  . get data (  )  )  ;  hf =  base32 . encode ( d . calculate hash (  )  . get data (  )  )  ;  return this . hostname . replace ( "%f" hf )  . replace ( "%c" hc )  ;   }  
@ override public  string[]   (  )  {  return new  string[] { "id" "name" "regex" "configuration" "successfully initialized" "successfully loaded configurations" "loading failed configurations" }  ;   }  
protected void   (  attributes attributes int index )  throws io exception  {  char quote = format . get attribute quote character (  )  ;  writer . write ( " " )  ;  writer . write ( attributes . getq name ( index )  )  ;  writer . write ( " = " )  ;  writer . write ( quote )  ;  write escape attribute entities ( attributes . get value ( index )  )  ;  writer . write ( quote )  ;   }  
@ test ( expected =  arithmetic exception . class )  public void   (  )  {   flowable . range ( 1 1 )  . last element (  )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer i )  {  return i  /  0 ;   }   }
@ test public void   (  )  {   maybe . from single (  single . error ( new  unsupported operation exception (  )  )  )  . test (  )  . assert failure (  unsupported operation exception . class )  ;   }  
@ test public void   (  )  {  assert true ( " should accept our response values" request pool for xml . accepts ( "post" xml xml "" )  )  ;   }  
public static void   (  router context ctx boolean yes )  {  long stamp = yes  ?  0 : last updated ( ctx )  ;  ctx . router (  )  . save config ( prop   last   hidden  long . to string ( stamp )  )  ;   }  
private   ( final boolean use original qualities )  {  this . use original qualities = use original qualities ;   }  
public   ( long exp )  {  expires = exp ;  counts = new  bit set ( max   nonce   count )  ;   }  
private void   (  comment c )  {  if  (  ! c . is hidden (  )  )   {  size -  -  ;  int r = c . get rating (  )  ;  if  ( r  >  0 )   {  if  ( c . is mine (  )  )   {  if  ( my rating  =  =  r )  my rating = 0 ;   }  else  {  total rating -  = r ;  rating size -  -  ;   }   }  modified = true ;   }   }  
  (  subscriber <  ?  super t >  actual long period  time unit unit  scheduler scheduler )  {  this . actual = actual ;  this . period = period ;  this . unit = unit ;  this . scheduler = scheduler ;   }  
private void   (  context context  cache entry entry )  throws io exception   messaging exception  {   log utils . d (  logging . log   tag " authentication cache refresh entry %d" entry . m account id )  ;  try  {  final  authentication result result = m authenticator . request refresh ( context entry . m provider id entry . m refresh token )  ;  entry . m access token = result . m access token ;  entry . m expiration time = result . m expires in seconds *  date utils . second   in   millis  +   system . current time millis (  )  ;  save entry ( context entry )  ;   }  catch  (   authentication failed exception e )   {   log utils . d (  logging . log   tag "authentication failed  clearning" )  ;  clear entry ( context entry )  ;  throw e ;   }  catch  (   messaging exception e )   {   log utils . d (  logging . log   tag "messaging exception" )  ;  throw e ;   }  catch  (  io exception e )   {   log utils . d (  logging . log   tag "io exception" )  ;  throw e ;   }   }  
static boolean   (  boolean supplier cancelled )  {  try  {  return cancelled . get as boolean (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  return true ;   }   }  
public  string   (  )  {  return description ;   }  
@ test public void   (  )  throws  exception  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   test observer <  integer >  to =  maybe . just ( 1 )  . subscribe on (  schedulers . io (  )  )  . flat map single ( new  
public void   (  string dtmf key to send )  {  if  ( telephone event payload  =  =  0 )   {   string treatment ;  if  ( dtmf key to send . equals ( "*" )  )   {  treatment = "dtmf star . au" ;   }  else if  ( dtmf key to send . equals ( "#" )  )   {  treatment = "dtmf pound . au" ;   }  else  {  treatment = "dtmf"  +  dtmf key to send  +  " . au" ;   }  try  {   treatment manager tm = new  treatment manager ( treatment 0 conference media info . get sample rate (  )  conference media info . get channels (  )  )  ;  call handler . get member (  )  . add treatment ( tm )  ;   }  catch  (  io exception e )   {   logger . println ( " unable to play dtmf key "  +  dtmf key to send  +  " " +  e . get message (  )  )  ;   }  return ;   }  if  ( dtmf key to send  !  =  null )   {  if  ( this . dtmf key to send  !  =  null )   {  this . dtmf key to send +  = dtmf key to send ;  return ;   }   }  this . dtmf key to send = dtmf key to send ;  dtmf send sequence = 0 ;   }  
@ xml element wrapper ( name = "members" )  @ xml element ( name = "member" )  public  list <  string >    (  )  {  return members ;   }  
static  attributes   (  file f )  {   input stream in = null ;  try  {  in =  ( new url ( "jar:file:"  +  f . get absolute path (  )   +  " !  / meta - inf / manifest . mf" )  )  . open stream (  )  ;   manifest man = new  manifest ( in )  ;  return man . get main attributes (  )  ;   }  catch  (  io exception ioe )   {  return null ;   }  finally  {  if  ( in  !  =  null )  try  {  in . close (  )  ;   }  catch  (  io exception e )   {   }   }   }  
public final static  string   (  string header value )  {  if  ( header value  =  =  null )  return "" ;  if  ( header value . starts with (  subscription . uuid )   =  =  false )  return header value ;  return header value . substring (  subscription . uuid . length (  )  header value . length (  )  )  ;   }  
@ override public void   ( jid unsubscriberjid jid recipientjid )  {  cancel subscription topep service ( unsubscriberjid recipientjid )  ;   }  
private void   (  )  {   message m = new  message (  message . have   none )  ;  add message ( m )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . repeat until ( new  boolean supplier (  )  {  @ override public boolean get as boolean (  )  throws  exception  {  return false ;   }   }   )  . take ( 5 )  . test (  )  . assert result ( 1 1 1 1 1 )
@ test public void   (  )  {   test helper . double on subscribe ( new  output canceller <  object >  ( new  test subscriber <  object >  (  )  null )  )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . do on complete ( new  action (  )  {  @ override public void run (  )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test (  )  . assert failure (  test exception . class )  ;  
public int   (  string stat1  string stat2 )  {   string stat name1 = stats viewer . get statistic ( stat1 ) [0] . get name (  )  ;   string stat name2 = stats viewer . get statistic ( stat2 ) [0] . get name (  )  ;  return stat name1 . to lower case (  )  . compare to ( stat name2 . to lower case (  )  )  ;   }  
@ override public  void   (  )  {  return null ;   }  
@ override protected void   (  client conn event e )  {   log . debug ( "oscar email service state change from "  +  e . get old state (  )   +  " to " +  e . get new state (  )  )  ;   }  
public static  body   ( long message id  string text content  string html content boolean save it  context context )  {   body body = new  body (  )  ;  body . m message key = message id ;  body . m html content = html content ;  body . m text content = text content ;  body . m source key = message id  +  0x1000 ;  if  ( save it )   {  body . save ( context )  ;   }  return body ;   }  
public   (  router context ctx  outbound cache cache  client message msg )  {  super ( ctx )  ;     start = ctx . clock (  )  . now (  )  ;     cache = cache ;     log = ctx . log manager (  )  . get log (  outbound client message one shot job . class )  ;  long timeout ms = overall   timeout   ms   default ;     client message = msg ;     client message id = msg . get message id (  )  ;     client message size = msg . get payload (  )  . get size (  )  ;     from = msg . get from destination (  )  ;     to = msg . get destination (  )  ;   hash to hash =    to . calculate hash (  )  ;     hash pair = new  outbound cache .  hash pair (    from . calculate hash (  )  to hash )  ;     to string = to hash . to base64 (  )  . substring ( 0 4 )  ;     lease set = ctx . net db (  )  . lookup lease set locally ( to hash )  ;  long overall expiration = msg . get expiration (  )  ;  if  ( overall expiration  >  0 )   {  if  ( overall expiration  <  24 * 60 * 60* 1000l )   {  if  (    log . should log (  log . warn )  )     log . warn ( " client bug  -  interval instead of timestamp "  +  overall expiration )  ;  overall expiration +  =    start ;   }  if  ( overall expiration  >     start )   {  long min timeout =    lease set  !  =  null  ?  overall   timeout   ms   min : overall   timeout   nols   min ;  overall expiration =  math . max ( overall expiration    start  +  min timeout )  ;  overall expiration =  math . min ( overall expiration    start  +  overall   timeout   ms   max )  ;  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  message  expiration  ( ms ) : "  +   ( overall expiration  -     start )  )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( get job id (  )   +  ":  expired before we got to it" )  ;   }   }  else  {   string param = msg . get sender config (  )  . get options (  )  . get property ( overall   timeout   ms   param )  ;  if  ( param  =  =  null )  param = ctx . router (  )  . get config setting ( overall   timeout   ms   param )  ;  if  ( param  !  =  null )   {  try  {  timeout ms =  long . parse long ( param )  ;   }  catch  (   number format exception nfe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " invalid client message timeout specified ["  +  param  +  "]  defaulting to " +  overall   timeout   ms   default nfe )  ;  timeout ms = overall   timeout   ms   default ;   }   }  overall expiration = timeout ms  +     start ;  if  (    log . should log (  log . debug )  )     log . debug ( get job id (  )   +  "  default  expiration  ( ms ) : "  +  timeout ms )  ;   }     overall expiration = overall expiration ;   }  
@ override public void   (  completable observer s )  {   concat inner observer inner = new  concat inner observer ( s sources )  ;  s . on subscribe ( inner . sd )  ;  inner . next (  )  ;   }  
@ override public void   (  transport t )  {     manager . stop and unregister ( t )  ;   }  
 string   (  list <  string >  commands boolean sensitive )  throws  messaging exception  io exception  {  open (  )  ;   string tag =  integer . to string ( m next command tag . increment and get (  )  )  ;  int len = commands . size (  )  ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {   string command to send = commands . get ( i )  ;  if  ( i  =  =  0 )   {  command to send = tag  +  " "  +  command to send ;   }  else  {   imap response response = read response (  )  ;  if  (  ! response . is continuation request (  )  )   {  throw new  messaging exception ( " expected continuation request" )  ;   }   }  m transport . write line ( command to send null )  ;  m discourse . add sent command ( sensitive  ?  imap   redacted   log : command to send )  ;   }  return tag ;   }  
public  string   (  )  {  if  (  !    context . get boolean property default true (  transport manager . prop   enable   udp )  )  return checked ;  return "" ;   }  
private void   ( final  string username final  string access token )  throws io exception   messaging exception  {  final  string auth phrase = "user = "  +  username  +  '\001' +  "auth =  bearer " +  access token +  '\001' +  '\001' ;  byte[] data =  base64 . encode ( auth phrase . get bytes (  )   base64 . no   wrap )  ;  try  {  execute sensitive command ( "auth xoauth2 "  +  new  string ( data )  "auth xoauth2  / redacted / " )  ;   }  catch  (   messaging exception me )   {  if  ( me . get message (  )  . length (  )   >  1 && me . get message (  )  . char at ( 1 )   =  =  '3' )   {  throw new  authentication failed exception ( me . get message (  )  )  ;   }  throw me ;   }   }  
public void   (  )  {  int[] skip count = new int[1] ;  char c =  text utilities . strip html entity ( "&" 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "& ; " 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&nosuch ; " 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&nbspandmore ; " 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&#abc" 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&#12b" 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&#xabc" 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;  c =  text utilities . strip html entity ( "&#x19g" 0 skip count )  ;  assert equals ( c '&' )  ;  assert equals ( 0 skip count[0] )  ;   }  
protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;   ;  reader . get file header (  )  . set sort order ( sort   order . get sort order (  )  )  ;  final sam file writer writer = new sam file writer factory (  )  . makesam orbam writer ( reader . get file header (  )  false output )  ;  writer . set progress logger ( new  progress logger ( log  ( int ) 1e7 " wrote" "records from a sorting collection" )  )  ;  final  progress logger progress = new  progress logger ( log  ( int ) 1e7 " read" )  ;  for  (  final sam record rec : reader )   {  writer . add alignment ( rec )  ;  progress . record ( rec )  ;   }  log . info ( " finished reading inputs  merging and writing to output now . " )  ;   closer util . close ( reader )  ;  writer . close (  )  ;  return 0 ;   }  
public  string   (  )  {  return cp . to string (  )  ;   }  
public void   ( int join confirmation timeout )  {  this . join confirmation timeout = join confirmation timeout ;   }  
@ override public void   (  maybe observer <  ?  super t >  t )  {  source . subscribe ( new  element at observer < t >  ( t index )  )  ;   }  
@ test public void   (  )  throws  exception  {  final  string double colon = "select 1::int" ;   parsed sql parsed = parser . parse ( double colon ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( double colon )  ;   }  
@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper ( new  something mapper (  )  )  ;   tuple1 <  something >  result = handle . create query ( "select id  name from somet
public  string   (  )  {  return kbytes to bits (    context . bandwidth limiter (  )  . get inbound burstk bytes per second (  )  )  ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  long idx = index  +  1 ;  index = idx ;   disposable d = timer ;  if  ( d  !  =  null )   {  d . dispose (  )  ;   }   debounce emitter < t >  de = new  debounce emitter < t >  ( t idx t
private void   (  string destinations )  {  if  ( destinations  =  =  null )  return ;   string tokenizer tok = new  string tokenizer ( destinations "  " )  ;  synchronized  (    addrs )   {     addrs . clear (  )  ;  while  ( tok . has more tokens (  )  )   {   string destination = tok . next token (  )  ;  try  {  i2p socket address addr = new i2p socket address ( destination )  ;     addrs . add ( addr )  ;  if  ( addr . is unresolved (  )  )   {   string name = addr . get host name (  )  ;  if  ( name . length (  )   =  =  60 && name . ends with ( " . b32 . i2p" )  )  l . log ( " warning  -   could not resolve "  +  name  +  "  perhaps it is not up  will retry when connecting . " )  ;  else l . log ( " warning  -   could not resolve "  +  name  +  "  you must add it to your address book for it to work . " )  ;   }   }  catch  (   illegal argument exception iae )   {  l . log ( " bad destination "  +  destination  +  "  -  " +  iae )  ;   }   }   }   }  
public long   (  )  {  long range[] = get content range (  )  ;  return range[1] ;   }  
public byte[]   (  )  throws  invalidb encoding exception  {  try  {  return  ( byte[] ) value ;   }  catch  (   class cast exception cce )   {  throw new  invalidb encoding exception ( cce . to string (  )  )  ;   }   }  
@ visible for testing  cursor   (  string id )  {  return m lru cache . get ( id )  ;   }  
void   (  list <  paired read sequence >  sequences  histogram <  integer >  duplication histo  histogram <  integer >  optical histo )  {  if  ( use barcodes || sequences . size (  )   <  boundary   library   size )   {  identical bases duplicate finder . search duplicates ( sequences duplication histo optical histo )  ;   }  else  {  hash based duplicates finder . search duplicates ( sequences duplication histo optical histo )  ;   }   }  
private void   (  message packet )  {   string jids =  jive globals . get property ( "xmpp . forward . admins" )  ;  if  ( jids  !  =  null && jids . trim (  )  . length (  )   >  0 )   {   string tokenizer tokenizer = new  string tokenizer ( jids "  " )  ;  while  ( tokenizer . has more tokens (  )  )   {   string username = tokenizer . next token (  )  ;   message forward = packet . create copy (  )  ;  if  ( username . contains ( "@" )  )   {  forward . set to ( username )  ;   }  else  {  forward . set to ( username  +  "@"  +  server name )  ;   }  route ( forward )  ;   }   }  else  {  for  (  jid jid : xmpp server . get instance (  )  . get admins (  )  )   {   message forward = packet . create copy (  )  ;  forward . set to ( jid )  ;  route ( forward )  ;   }   }   }  
@ test public void   (  )  {   maybe .  <  integer > empty (  )  . flat map single element ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (  final  integer integer )  throws  except
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {  final  field element f1 =  math utils . get random field element (  )  ;  final  big integer b1 =  math utils . to big integer ( f1 )  ;  final  field element f2 = f1 . square 
public  file transfer filter manager   (  )  {  return file transfer filter manager ;   }  
public  string   (  )  {  return "" ;   }  
@ override public int   (  )  {  return 0 ;   }  
@ backpressure support (  backpressure kind . full )  @ check return value @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  maybe source <  ?  extends t >  other )  {   object helper . require non null ( other "other i
public static void   (  string username )  {  if  (  ! listeners . is empty (  )  )   {  for  (   lock out event listener listener : listeners )   {  listener . account unlocked ( username )  ;   }   }   }  
public void   (  string nickname )  {   boolean changed = false ;  if  ( nickname  !  =  null )   {  if  ( this . nickname  =  =  null ||  ! this . nickname . equals ( nickname )  )   {  changed = true ;   }  this . nickname = nickname ;   }  else  {  if  ( this . nickname  =  =  null ||  ! this . nickname . equals ( get name (  )  )  )   {  changed = true ;   }  this . nickname = get name (  )  ;   }  if  ( changed && get manager (  )  . is activated (  )  )   {   log . debug ( " transport buddy:  triggering contact update for "  +  this )  ;  get manager (  )  . get session (  )  . update contact ( this )  ;   }   }  
@ override public synchronized byte   (  )  throws io exception  {  return internal buffer . get (  )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   flowable . just ( 1 )  . do on lifecycle (  functions . empty consumer (  )  new  long consumer (  )  {  @ override public void accept (  lon
public void   (  runnable job )  {     command = job ;   }  
long   (  )  throws io exception  {  return cached  ?  cache : read long (  )  ;   }  
@ test public void   (  )  {  final  test scheduler test scheduler = new  test scheduler (  )  ;  final  atomic long atomic long = new  atomic long (  )  ;   completable . timer ( 2  time unit . seconds test scheduler )  . subscribe ( new  action (  )  { 
private   ( int width int height int row size int[] bits )  {  this . width = width ;  this . height = height ;  this . row size = row size ;  this . bits = bits ;   }  
public static  string   ( byte[] source int off int len int options )  {  int dont break lines =  ( options & dont   break   lines )  ;  int gzip =  ( options & gzip )  ;  if  ( gzip  =  =  gzip )   {  java . io .  byte array output stream baos = null ;  java . util . zip . gzip output stream gzos = null ;   base64 .  output stream b64os = null ;  try  {  baos = new java . io .  byte array output stream (  )  ;  b64os = new  base64 .  output stream ( baos encode | options )  ;  gzos = new java . util . zip . gzip output stream ( b64os )  ;  gzos . write ( source off len )  ;  gzos . close (  )  ;   }  catch  (  java . io . io exception e )   {  e . print stack trace (  )  ;  return null ;   }  finally  {  try  {  gzos . close (  )  ;   }  catch  (   exception e )   {   }  try  {  b64os . close (  )  ;   }  catch  (   exception e )   {   }  try  {  baos . close (  )  ;   }  catch  (   exception e )   {   }   }  try  {  return new  string ( baos . to byte array (  )  preferred   encoding )  ;   }  catch  (  java . io .  unsupported encoding exception uue )   {  return new  string ( baos . to byte array (  )  )  ;   }   }  else  {  boolean break lines = dont break lines  =  =  0 ;  int len43 = len * 4  /  3 ;  byte[] out buff = new byte[ ( len43 )   +   (  ( len % 3 )   >  0  ?  4 : 0 )   +   ( break lines  ?   ( len43  /  max   line   length )  : 0 ) ] ;  int d = 0 ;  int e = 0 ;  int len2 = len  -  2 ;  int line length = 0 ;  for  (  ;  d  <  len2 ;  d +  = 3  e +  = 4 )   {  encode3to4 ( source d  +  off 3 out buff e options )  ;  line length +  = 4 ;  if  ( break lines && line length  =  =  max   line   length )   {  out buff[e  +  4] = new   line ;  e +  +  ;  line length = 0 ;   }   }  if  ( d  <  len )   {  encode3to4 ( source d  +  off len  -  d out buff e options )  ;  e +  = 4 ;   }  try  {  return new  string ( out buff 0 e preferred   encoding )  ;   }  catch  (  java . io .  unsupported encoding exception uue )   {  return new  string ( out buff 0 e )  ;   }   }   }  
public  string   (  )  {  return auth username  =  =  null  ?  "" : auth username ;   }  
@ test public void   (  )  {   test helper . check bad source flowable ( new  function <  flowable <  integer >   object >  (  )  {  @ override public  object apply (   flowable <  integer >  f )  throws  exception  {  return f . reduce ( sum )  . to flow
@ override public void   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
public boolean   (  list <  pending gateway message >  queue buf )  {  int max ;  boolean backlogged =    context . comm system (  )  . is backlogged (    next hop )  ;  if  ( backlogged &&    log . should log (  log . info )  )     log . info ( "ptg backlogged  queued to "  +     next hop  +  " : " +     prequeue . size (  )  +  " ib ?  " +     is inbound )  ;  if  ( backlogged )  max =    is inbound  ?  1 : 2 ;  else max =    is inbound  ?  max   ib   msgs   per   pump : max   ob   msgs   per   pump ;     prequeue . drain to ( queue buf max )  ;  if  ( queue buf . is empty (  )  )  return false ;  boolean rv =  !    prequeue . is empty (  )  ;  long start add =  system . current time millis (  )  ;  long before lock = start add ;  long after added =  - 1 ;  boolean delayed flush = false ;  long delay amount =  - 1 ;  int remaining = 0 ;  long after preprocess = 0 ;  long after expire = 0 ;  synchronized  (    queue )   {     queue . add all ( queue buf )  ;  after added =  system . current time millis (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " added before direct flush preprocessing for "  +  to string (  )   +  ": " +     queue )  ;  delayed flush =    preprocessor . preprocess queue (    queue    sender    receiver )  ;  after preprocess =  system . current time millis (  )  ;  if  ( delayed flush )  delay amount =    preprocessor . get delay amount (  )  ;     last flush =    context . clock (  )  . now (  )  ;  for  ( int i = 0 ;  i  <     queue . size (  )  ;  i +  +  )   {   pending gateway message m =    queue . get ( i )  ;  if  ( m . get expiration (  )   +   router . clock   fudge   factor  <     last flush )   {  if  (    log . should log (  log . debug )  )     log . debug ( " expire on the queue  ( size = "  +     queue . size (  )   +  " ) : " +  m )  ;     queue . remove ( i )  ;  i -  -  ;   }   }  after expire =  system . current time millis (  )  ;  remaining =    queue . size (  )  ;  if  (  ( remaining  >  0 )  &&  (    log . should log (  log . debug )  )  )     log . debug ( " remaining after preprocessing: "  +     queue )  ;   }  if  ( delayed flush )   {     delayed flush . reschedule ( delay amount )  ;   }  if  (    log . should log (  log . debug )  )   {  long complete =  system . current time millis (  )  ;     log . debug ( " time to add "  +  queue buf . size (  )   +  " messages to " +  to string (  )  +  ": " +   ( complete  -  start add )  +  " delayed ?  " +  delayed flush +  " remaining: " +  remaining +  " add: " +   ( after added  -  before lock )  +  " preprocess: " +   ( after preprocess  -  after added )  +  " expire: " +   ( after expire  -  after preprocess )  +  " queue flush: " +   ( complete  -  after expire )  )  ;   }  queue buf . clear (  )  ;  if  ( rv &&    log . should log (  log . info )  )     log . info ( "ptg remaining to "  +     next hop  +  " : " +     prequeue . size (  )  +  " ib ?  " +     is inbound +  " backlogged ?  " +  backlogged )  ;  return rv ;   }  
public void   ( int x int y )  {  int offset = y * row size  +   ( x  /  32 )  ;  bits[offset]| = 1  <  <   ( x & 0x1f )  ;   }  
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public static  < t >  flowable < t >    (  publisher <  ?  extends t >  .  .  .  sources )  {  if  ( sources . length  =  =  0 ) 
private  data processor   (  string rpn expression )  throws  rrd exception  {   data processor data processor = new  data processor ( request . get fetch start (  )  request . get fetch end (  )  )  ;  for  (   string ds name : ds names )   {  data processor . add datasource ( ds name this )  ;   }  if  ( rpn expression  !  =  null )   {  data processor . add datasource ( rpn   source   name rpn expression )  ;  try  {  data processor . process data (  )  ;   }  catch  (  io exception ioe )   {  throw new  runtime exception ( " impossible error: "  +  ioe )  ;   }   }  return data processor ;   }  
private  element   (  )  {  if  ( v card  !  =  null )   {  return v card ;   }  try  {   string xml = " < v card xmlns = \"vcard - temp\" >  < n >  < family >  dombiak <  / family >  < given >  gaston <  / given >  < middle >  maximiliano <  / middle >  <  / n >  < org >  < orgname >  jive  software <  / orgname >  < orgunit /  >  <  / org >  < fn >  gaston  maximiliano  dombiak <  / fn >  < role /  >  < desc /  >  < jabberid > gato@jivesoftware . com <  / jabberid >  < user name > 12011349 <  / user name >  < server > ss . ctbc . com . br <  / server >  < url /  >  < nickname >  gato <  / nickname >  < title /  >  < photo >  < type > image / jpeg <  / type >  < binval > ivbo rw0k ggoaaaans uhe ugaaadaaaa awcaiaaadyyg7qaaa kx0leqvr42u1zz1du1xqe xwe cztarrjryeb hrf qtry0sm yjeoq hhvf obsi85 qld4 uoxq fx iigiewk1ge0 cia2j ho1 mdgqus9tud ey3 pecfco + h0k + 3q / 3rpw19pp1h obs / eznfd6qwtjf8j + 1fh8d + m8d gjbouu9 dy / c aftha / gk + dy nv6j + 8uj lwr ao + p75pg opp5n5gyh /  afd jvcs8 os / uyair / j lz db8 edbot + yjw iyc sb glo + d td1t obfy ar xp6ok0i brr + lb + tg pr5zouno + v73ij383 sk7pby ev iwksxb fuj jdbt5wk pmm0 ij6e ifgc6tu9v jyrm gk sba5e zsyiy zkrt sr7ng + vs3s3 /  vys0v2wfgan8zfk tjsio3oa rj iv uiodjow ge gi bw9 kme9 hm kgyi fpy5t2 jcxh vt9wdy / e2vy fn + fd13pr4i dwgj hdd lzugyx hhhac1ecu dfhh + ao zhaygkz kem /  + 6xwg9r1 + 9xqt5 nwgr gcaqm sju tx cokvl ykm dalg33x up eyb sh5 mj3z arl npu3g0hq3t6i4medpp5tbwp0n wtk xb /  nqbsj6 + bsb zx / d xkpyt abf / m0pv ilcb + 827f9xg pt3pf5 iw dszy fta07 vg4 hs1dhr zvpd186 cnz0 kqd6 mtda op8pht cme6t8h2iyxf4 epx gzpbr ji ze4dl xwj8 dz6vbsim / vqkv cv djh aw csrjh hj5o5hdor adaur0f rqg5x6 lpi6nd8vri blq0 dtm7y xk vblnd0x zmq le zdco fzi nkuiz9m5q2fik / xe2nz6xz / r6j nn hyzmf yajq1g ahtrj tv bj tec22kkp vxn hs fwki0ueri amrv du qw hn4mpjx8c2 pf43j cuw igmw lk atllgai0p + bfj hlm kd7u /  + rw oa21p scdc1vafq zt50rpweif rlml /  jk hz slqbz ja6a8khab xqkppu us3i2tn + h2 uk0tbds tg6zphc8 jkhk +  rozmte7e azq + 50ane xgctr cvv wx / vhd + ktomez gmp5qxe kwp rm in uwrvuu byat yzahkz ovetrwuapag iwaxm zzqy ya2t mm / x6bheiew + uk pu24 gukjas odvdcf pos7z bwh3 ml bqqrai1si tcv4ip6 kghn8ae co4av9f6jagdb lgz nei2zgtpqoe94k8zk fml6y fcd5oi utv6m ieoiaa /  pj6oy tvroa / nddaqe eo yg klq70fy oao fadcq zanuu gp1uj1eokyulg fh myzx uks200gk2geu bkr byf fwq6 be plys1a ukgefr9p ge5r0 zlzzq uimy bt tfnc axz2ki5k5cxl3 kb bkzrj5wtu ews6g ry9yr9wixt75emq coutuy eac5pc yl mw adm5 cxfb gg467a mnv2 / svdxo sdq cxs0cxm1 pw3spu4o /  ssom kqu smr wcmqjz csh2x3oqho tq0m tkep5fff8uc1fm uww2 uq fn rwaj xt6q gwe2th / qp dzz cqmub1brbzm85eykl89ymy fbpgxb / b7jhou dkmzgag id35 ac3 hn2gg7 jy5x ykws tyd jp / pt1zpco le3dkbb ijj zmszrs4qj2hl gxh qzpu zpb3h6m qc0o jc6lf7 czb2i czv whts4c lk tk znct flnb3y / k imwdwj qgtu8f6i tyk yim am ri zn ok7d1o28wqb wge cs sa xjeen / 8vh rx1zqoac ssydll jej6y di3 / t8ryg98w2g1g0cxjjfo / qe2o + hm5di zp53f gzkh + nq kos6 tl ev9x kpqob icyt + g vze py ewp zi4z5cf rqs yj + 97 + cg fsikmr pc gbiiz4c / w inf fbwyg14d36 hldw xkaatad07kv nc8ib vjcqs qguh0sg4ch ge wz3 /  ys3cyi5a1o5upp9khb7lqrq qjrchm lf uxt cka0rvj uyzx pg rbuis czbwgsgz1v ncfv5ekouvf68gary +  den vnwo7n zpz6 yw sxs25w om ner4khfqciz sqy cxqps cf up3bxx8xu8kv6ig aru3j4si0u8od ehre + bd dwctbapqia tcoq1r do1m4 / hor8rh tx1rapfg lcdue5pabvjd tu6 mq1rap kr owhwi qmhfoh771nm etz8ukv rr7yai gor tez5 ugov rh cn dbr3assk7 / 1v svh0 ndx /  id1c kbekq sd rxf7ny dckkvl qdn apzd184e9mi / ievrd1kai gb3 so48lv9yfbmbi21vwai4 xixkeb bk bos4m skg3 prss2 uz bd3rot0d ba dlum ey coq btub gmot qr7ra qc3fkvi + zh3ipoe jolxe + joijze2 dv vahy9v hx msbqs + oc rk we lt jmlm qm + jx7joksm6 wgrqi / ee /  / zrnz8ogqr4a gwipr xqreb owtlnt cke34td2wej bd + 83 vrdgr nke hwr gwk + zn kwix7czecr pqk oeenost tqxzho7m yj khw yu7qpv dfqt ek noogpcbd + 3 bdku / 3xa + 13zj3 eo40b qi zwiqlc bqv xc6yhva5 pa4 / esu8khx6nc2rbahzy vc3si6dp36h sz oxuq tjqv2m9zo627u9k tt5qoe0zvpjgzk6 gy lsr yod vuz4 cb xaxu91 ofdlu0uc1md + 7pm2c / qxut nz vvi2j ku zalpof pmy qvhh24bmj qvw lolt jt87n1c6e4 nsa2s kc npshb3j jnqu ktzw md fjyqm vvq0ntoc80 jx03s58w hkuoa moy bnjyeidah3qbjwf4 id phzk7 lni3vap9j rkj ee fls maegbsyz /  aysa70x oc dvoyo9vz + z ivrey ov6m rtlpc85s uyxk ghnu yb32rwjmgw1lllf0d / 1h czn4p xost rzo ruwjua cj ja5m ifa kh byc / bzu ba qjzim mpb yb04pu gp yrys604hg bvv hj1m7jw io bc38it dtz jf sin bz1bq qwme hlb + ioc4zxzop rifgg17 + 7ty wcdn5 ee9j aw tvd4a39t / fnma9o kz4a kgjh0q9exq7vczy zll5mv zmhv wn lt7 hod yvwxs3l3c +  jc3z37ova jc4h9 anq9b vd4jgm sy2fqx kmm ii tao twc1 yd7qp zgkwbq / cw iltq2cjcs1g bdxt exfsebh6xn dk8uf2i ycb3q1d wlthl cfy0 aj jxn gons3nzk tvk lghl89 tc + v5zy fb4lz5 + qm9t ilhl se0ma3gfdd4x3vo2tlf6o + ua oilsi yks9jdc olm2ko rh qa yryhp + x5d on + pv to2 bvj9t85 gwt guv0 qmz bp ep zw8q5 / qmi + dnz23 mi hn10 / rqk + g jjkoru0hiv183suoi zjls ufnphei0ws jf ohav50fbq pr + uha rhia + id8vs0g vxo bs4goe gwp7 hwh2ne02 inu efyo qqzh0oixvii2tyzzzm4fh bon eiq hek8lj + ggww + wnmgzo st xi kfz5 fxkg + s0 mc8u3pahb dy95tmt2 wejt2r15a0covdlhz bhg2mdy5ydbg oj3 jk qt + xot mh4rqh + pc fb9ano qdl6z0 / ni wgt46ejcy hcjl5mg qg jmpi nvs ujrz6fy37ps tl rpa2n ssc6rq xbqu qt8 aror dr / a2sv70 cld7 uq5p4 di9 smbpj5sgh mhop rkxy cby4t dp iwi nddba + 9trlj sknf nikb4 + ymjgdk nki9e /  / 6 / i / a /  qf / fyv piz bqwqaaaaasuvork5cyii =  <  / binval >  <  / photo >  < email >  < work /  >  < internet /  >  < pref /  >  < userid > gaston@jivesoftware . com <  / userid >  <  / email >  < email >  < home /  >  < internet /  >  < pref /  >  < userid > gaston@jivesoftware . com <  / userid >  <  / email >  < tel >  < pager /  >  < work /  >  < number /  >  <  / tel >  < tel >  < cell /  >  < work /  >  < number /  >  <  / tel >  < tel >  < voice /  >  < work /  >  < number /  >  <  / tel >  < tel >  < fax /  >  < work /  >  < number /  >  <  / tel >  < tel >  < pager /  >  < home /  >  < number /  >  <  / tel >  < tel >  < cell /  >  < home /  >  < number /  >  <  / tel >  < tel >  < voice /  >  < home /  >  < number /  >  <  / tel >  < tel >  < fax /  >  < home /  >  < number /  >  <  / tel >  < adr >  < work /  >  < extadd /  >  < pcode > 97204 <  / pcode >  < region >  oregon <  / region >  < street > 317 sw  alder  st  ste 500 <  / street >  < ctry > usa <  / ctry >  < locality >  portland <  / locality >  <  / adr >  < adr >  < home /  >  < extadd /  >  < pcode /  >  < region /  >  < street /  >  < ctry /  >  < locality /  >  <  / adr >  <  / v card > " ;  v card =  document helper . parse text ( xml )  . get root element (  )  ;  return v card ;   }  catch  (   document exception e )   {  return null ;   }   }  
@ override public  configuration resource   (  string resource name )  {  final  string spec = resource name . contains ( ": /  / " )   ?  resource name :  string utils . join ( configuration root  file . separator resource name )  ;  try  {  return new  
public void   (  state variable state var )  {   string var = state var . get value (  )  ;  set status code ( http status . ok )  ;   node body node = get body node (  )  ;   node res node = create response node ( var )  ;  body node . add node ( res node )  ;   node env nodee = get envelope node (  )  ;  set content ( env nodee )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  async =  replay subject . create with size ( 1 )  ;  async . on next ( 0 )  ;  async . on next ( 1 )  ;   subject <  integer >  serial = async . to serialized (  )  ;  assert false ( serial . has
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  server name = server . get server info (  )  . getxmpp domain (  )  ;  info handler = server . getiq disco info handler (  )  ;  items handler = server . getiq disco ite
@ test public void   (  )  {   single <  boolean >  o =  observable . sequence equal (  observable . concat (  observable . just ( "one" )   observable .  <  string > error ( new  test exception (  )  )  )   observable . concat (  observable . just ( "one
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer ( 3 )  ;  final  atomic integer number of subscribe calls = new  atomic integer ( 0 )  ;   completable . from action ( new  action (  )  {  @ override public void run
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;   flowable . concat delay error ( with error (  flowable . just ( with error (  flowable . just ( 1 )  )  with error (  flowable . just ( 2 )  )  )  )  )  
@ override public void   (  session data data  element command )  {   element note = command . add element ( "note" )  ;  if  (  group manager . get instance (  )  . is read only (  )  )   {  note . add attribute ( "type" "error" )  ;  note . set text ( "
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
public void   (  )  throws  exception  {  setup copy messages ( false )  ;  m copy mock . expect ( get copy messages pattern (  )  new  string[] { get next tag ( true )   +  " ok uid copy completed" }  )  ;  int save tag = reset tag (  )  ;  expect login ( m copy mock new  string[] { "* id nil" "ok" }  false )  ;  expect select ( m copy mock "& ze vnl iqe - " "read - write" )  ;  m copy mock . expect ( get search messages pattern ( " < 4d8978ae . 0000005d@m58 . foo . com > " )  new  string[] { "*  se ar ch 777" get next tag ( true )   +  " ok uid search completed  ( 1 msgs in 3 . 14159 secs ) " }  )  ;  m copy mock . expect ( get search messages pattern ( " < 549373104msosi1:145osims@bar . com > " )  new  string[] { "* s ea rch 1818" get next tag ( true )   +  " ok uid search completed  ( 1 msgs in 2 . 71828 secs ) " }  )  ;  reset tag ( save tag )  ;  expect select ( m copy mock folder   encoded "read - write" )  ;   message update callback counter cb = new  message update callback counter (  )  ;  m folder . copy messages ( m copy messages m copy to folder cb )  ;  assert equals ( 0 cb . message not found called )  ;  assert equals ( 2 cb . message uid change called )  ;   }  
@ test public void   (  )  {   split sam by library splitter = new  split sam by library (  )  ;  splitter . input = new  file ( "testdata / picard / sam / split   test . sam" )  ;   assert . assert equals ( splitter . do work (  )  0 "sam file split shou
public void   (  )  {   mailbox unpopulated = new  mailbox (  )  ;  unpopulated . m display name = "the only thing filled in for some reason" ;   parcel p =  parcel . obtain (  )  ;  unpopulated . write to parcel ( p 0 )  ;  p . set data position ( 0 )  ;   mailbox unparcelled =  mailbox . creator . create from parcel ( p )  ;   more asserts . assert equals ( unpopulated . get hashes (  )  unparcelled . get hashes (  )  )  ;  p . recycle (  )  ;   }  
boolean   (  )  {  return    dead ;   }  
@ override public  maybe source <  integer >    (  integer v )  throws  exception  {  return null ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  execute ( "select i  '7' from bean" )  ;   }  
@ override public int   ( int mode )  {  return transitive boundary fusion ( mode )  ;   }  
@ override public  flowable <  object >    (  flowable <  object >  o )  throws  exception  {  return o . take last ( 5 )  ;   }  
private  invocation handler   (  class <  ?  >  sql object type  config registry instance config  map <  method  handler >  handlers  handle supplier handle )  {  return  ( proxy method args )   -  >   {   handler handler = handlers . get ( method )  ;   config registry method config = instance config . create copy (  )  ;  for each configurer ( method  ( configurer annotation )   -  >  configurer . configure for method ( method config annotation sql object type method )  )  ;  return handle . invoke in context ( new  extension method ( sql object type method )  method config  (  )   -  >  handler . invoke ( proxy args  =  =  null  ?  no   args : args handle )  )  ;   }   ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    ( final  consumer <  ?  super  subscription >  on subscribe final  long consumer on req
private void   (  )  throws io exception  {  if  (    header buffer . get valid (  )   >  =  max   header   size )  throw new io exception ( " max header size exceeded: "  +  max   header   size )  ;  if  (    header buffer . get valid (  )   +  1  >  =     header buffer . get data (  )  . length )   {  int new size =  ( int )  (    header buffer . get data (  )  . length * 1 . 5 )  ;   byte array new buf = new  byte array ( new byte[new size] )  ;   system . arraycopy (    header buffer . get data (  )  0 new buf . get data (  )  0    header buffer . get valid (  )  )  ;  new buf . set valid (    header buffer . get valid (  )  )  ;  new buf . set offset ( 0 )  ;  if  (    header buffer . get data (  )  . length  =  =  cache   size )     cache . release (    header buffer )  ;     header buffer = new buf ;   }   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
private void   (  account account )  {   security policy security =  security policy . get instance ( this )  ;  if  (  ! security . is active admin (  )  )   {  if  ( m tried add administrator )   {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " not active admin: repost notification" )  ;   }  repost notification ( account security )  ;  finish (  )  ;   }  else  {  m tried add administrator = true ;  final  host auth host auth = account . m host auth recv ;  if  ( host auth  =  =  null )   {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " no  host auth: repost notification" )  ;   }  repost notification ( account security )  ;  finish (  )  ;   }  else  {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " not active admin: post initial notification" )  ;   }   intent intent = new  intent (  device policy manager . action   add   device   admin )  ;  intent . put extra (  device policy manager . extra   device   admin security . get admin component (  )  )  ;  intent . put extra (  device policy manager . extra   add   explanation this . get string ( r . string . account   security   policy   explanation   fmt host auth . m address )  )  ;  start activity for result ( intent request   enable )  ;   }   }  return ;   }  if  ( security . is active ( null )  )   {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " security active ;  clear holds" )  ;   }   account . clear security hold on all accounts ( this )  ;  security . sync account ( account )  ;  security . clear notification (  )  ;  finish (  )  ;  return ;   }  security . set active policies (  )  ;  int inactive reasons = security . get inactive reasons ( null )  ;  if  (  ( inactive reasons &  security policy . inactive   need   password )   !  =  0 )   {  if  ( m tried set password )   {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " password needed ;  repost notification" )  ;   }  repost notification ( account security )  ;  finish (  )  ;   }  else  {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " password needed ;  request it via dpm" )  ;   }  m tried set password = true ;   intent intent = new  intent (  device policy manager . action   set   new   password )  ;  start activity for result ( intent request   password )  ;   }  return ;   }  if  (  ( inactive reasons &  security policy . inactive   need   encryption )   !  =  0 )   {  if  ( m tried set encryption )   {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " encryption needed ;  repost notification" )  ;   }  repost notification ( account security )  ;  finish (  )  ;   }  else  {  if  (  debug utils . debug || debug )   {   log utils . d ( tag " encryption needed ;  request it via dpm" )  ;   }  m tried set encryption = true ;   intent intent = new  intent (  device policy manager . action   start   encryption )  ;  start activity for result ( intent request   encryption )  ;   }  return ;   }  if  (  debug utils . debug || debug )   {   log utils . d ( tag " policies enforced ;  clear holds" )  ;   }   account . clear security hold on all accounts ( this )  ;  security . sync account ( account )  ;  security . clear notification (  )  ;  finish (  )  ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts =  flowable . error ( new  test exception ( " outer" )  )  . retry ( new  predicate <  throwable >  (  )  {  @ override public boolean test (   throwable e )  throws  exception  {  throw new  
@ override public synchronized void   (  )  {  if  ( socket accept thread  !  =  null )   {  try  {  socket accept thread . shutdown (  )  ;   }  finally  {  socket accept thread = null ;   }   }   }  
static int   ( byte[] in int offset )  {  int result = in[offset +  + ] & 0xff ;  result| =  ( in[offset +  + ] & 0xff )   <  <  8 ;  result| =  ( in[offset] & 0xff )   <  <  16 ;  return result ;   }  
public  element   (  )  {   element element =  document helper . create element ( q name . get ( "agent" "http: /  / jabber . org / protocol / workgroup" )  )  ;  element . add attribute ( "jid" get agentjid (  )  . to string (  )  )  ;  if  ( get nickname (  )   !  =  null )   {  element . add element ( "name" "http: /  / jivesoftware . com / protocol / workgroup" )  . set text ( get nickname (  )  )  ;   }  return element ;   }  
@ override public  string   (  )  {  return null ;   }  
@ override public  map <  string  string >    (  string username )  throws  unsupported operation exception  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con = get connection (  )  ;  pstmt = con . prep
public void   (  connection event listener lsnr )  {  if  ( lsnr  =  =  null )  return ;  listeners . remove ( lsnr )  ;   }  
public void   ( int parameter index  big decimal x )  throws sql exception  {  pstmt . set big decimal ( parameter index x )  ;   }  
public dh parameter spec   (  )  {  return new dh parameter spec ( el spec . getp (  )  el spec . getg (  )  )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . scan ( new  bi function <  object  object  object >  (  )  {  @ override public  object apply (   object a   object b )  throws  exception  {  return a ;   }   }   )  . test 
public static void   (  completable observer s )  {  s . on subscribe ( instance )  ;  s . on complete (  )  ;   }  
public boolean   ( i2np message in msg )  {  if  ( in msg . get type (  )   =  =   delivery status message . message   type )   {  return  (  (  delivery status message ) in msg )  . get message id (  )   =  =     test message key ;   }  else  {  return false ;   }   }  
@ override public  string   (  )  {  return " net db flood search" ;   }  
@ override public void   (  list <  integer >  xs )  {  lists . add ( xs )  ;   }  
protected void   (  )  {  int concurrent threads = threads running . get (  )  ;  int max threads = max concurrent threads . get (  )  ;  if  ( concurrent threads  >  max threads )   {  max concurrent threads . compare and set ( max threads concurrent threads )  ;  if  ( concurrent threads  >  1 )   {  new  runtime exception ( "should not be greater than 1" )  . print stack trace (  )  ;   }   }   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  iterable < t >    (  )  {  return new  blocking observable next < t >  ( this )  ;   }  
public void   ( boolean show signature )  {  this . show signature = show signature ;   }  
private void   ( final  list <  string >  sample list sam sequence dictionary sam sequence dictionary )  {  for  (  final  file input : input )   {  final vcf file reader in = new vcf file reader ( input false )  ;  final vcf header header = in . get file header (  )  ;  final sam sequence dictionary dict = in . get file header (  )  . get sequence dictionary (  )  ;  if  ( dict  =  =  null || dict . is empty (  )  )   {  if  ( null  =  =  sam sequence dictionary )   {  throw new  illegal argument exception ( " sequence dictionary was missing or empty for the vcf: "  +  input . get absolute path (  )   +  "  please add a sequence dictionary to this vcf or specify sequence   dictionary . " )  ;   }  header . set sequence dictionary ( sam sequence dictionary )  ;   }  else  {  if  ( null  =  =  sam sequence dictionary )   {  sam sequence dictionary = dict ;   }  else  {  try  {  sam sequence dictionary . assert same dictionary ( dict )  ;   }  catch  (  final  assertion error e )   {  throw new  illegal argument exception ( e )  ;   }   }   }  if  ( sample list . is empty (  )  )   {  sample list . add all ( header . get sample names in order (  )  )  ;   }  else  {  if  (  ! sample list . equals ( header . get sample names in order (  )  )  )   {  throw new  illegal argument exception ( " input file "  +  input . get absolute path (  )   +  " has sample names that don't match the other files . " )  ;   }   }  input readers . add ( in )  ;  input headers . add ( header )  ;   }   }  
private  connection . tls policy   (  )  {  try  {  return  connection . tls policy . value of ( tls policy property name )  ;   }  catch  (   illegal argument exception ex )   {  return null ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   debounce timed observer <  integer >  sub = new  debounce timed observer <  integer >  ( to 1  time unit . seconds new  test scheduler (  )  . creat
@ override public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write safeutf ( out nickname )  ;   }  
@ override public void   (  completable source t )  {  if  ( source fused  =  =   queue subscription . none )   {  if  (  ! queue . offer ( t )  )   {  on error ( new  missing backpressure exception (  )  )  ;  return ;   }   }  drain (  )  ;   }  
  ( final  duplicate set iterator wrapped iterator final int max edit distance to join final  string umi tag final  string assigned umi tag final boolean allow missing umis final  umi metrics metrics )  {  this . wrapped iterator = wrapped iterator ;  this . max edit distance to join = max edit distance to join ;  this . umi tag = umi tag ;  this . inferred umi tag = assigned umi tag ;  this . allow missing umis = allow missing umis ;  this . metrics = metrics ;  is open = true ;  next sets iterator =  collections . empty iterator (  )  ;   }  
@ test public void   (  )  {  final  list <  integer >  values = new  array list <  integer >  (  )  ;   action on complete = new  action (  )  {  @ override public void run (  )  throws  exception  {  values . add ( 100 )  ;   }   }   ;   maybe <  intege
@ override public  flowable <  integer >    (  integer v )  {  return  flowable . range ( v 2 )  ;   }  
 date   (  )  {  return new  date ( locked time )  ;   }  
public int   (  string sql  string[] column names )  throws sql exception  {  return cstmt . execute update ( sql column names )  ;   }  
@ override public void   (  )  {  bh . consume ( true )  ;  count down (  )  ;   }  
private  collection <  participant >    (  result set rs )  throws sql exception  {   collection <  participant >  participants = new  hash set <  participant >  (  )  ;   date start date = millis to date ( rs . get long ( "start date" )  )  ;   string participant jid = rs . get string ( "barejid" )  ;   date end date = millis to date ( rs . get long ( "last activity" )  )  ;  if  ( participant jid  !  =  null )   {   participant participant = new  participant ( start date participant jid )  ;  participant . set end ( end date )  ;  participants . add ( participant )  ;   }  return participants ;   }  
@ test ( timeout = 1000 )  public void   (  )  {   test subscriber <  long >  ts = new  test subscriber <  long >  ( 3l )  ;   flowable . range long (  long . max   value  -  1l 2l )  . subscribe ( ts )  ;  ts . assert complete (  )  ;  ts . assert no err
public boolean   (  )  {   string icon mime type = get mime type (  )  ;  if  ( icon mime type  =  =  null )  return false ;  return  ( 0  <  icon mime type . length (  )  )   ?  true : false ;   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  reduce subscriber < t >  ( observer reducer )  )  ;   }  
@ after public void   (  )  throws  exception  {  if  ( trust store  !  =  null )   {  trust store = null ;   }   }  
@ override public void   ( jid jid  string nickname  array list <  string >  groups )  {   string legacy id = get transport (  )  . convertjid toid ( jid )  ;  if  ( nickname  =  =  null || nickname . equals ( "" )  )   {  nickname = legacy id ;   }  if  
@ check return value @ scheduler support (  scheduler support . none )  public final  single < t >    ( final t value )  {   object helper . require non null ( value "value is null" )  ;  return  rx java plugins . on assembly ( new  single on error return
public void   (  string overlay image )  {  this . overlay image = overlay image ;   }  
@ test public void   (  )  {   observable . just ( 1 2 3 )  . last element (  )  ;   }  
public long   (  )  {  return    last send time ;   }  
public long   (  )  {  return msgid ;   }  
private long   (  )  {  if  (    facade . floodfill enabled (  )  )  return max   rerun   delay   ms ;  if  ( get context (  )  . router (  )  . get uptime (  )   <  startup   time ||    facade . get data store (  )  . size (  )   <  min   routers || get context (  )  . router (  )  . is hidden (  )  )  return min   rerun   delay   ms ;   router info ri = get context (  )  . router (  )  . get router info (  )  ;  if  ( ri  !  =  null && ri . get capabilities (  )  . contains ( ""  +   router . capability   bw12 )  )  return min   rerun   delay   ms ;  if  (    facade . get data store (  )  . size (  )   >  max   routers )  return max   rerun   delay   ms ;  long delay = get context (  )  . clock (  )  . now (  )   -     facade . get last explore new date (  )  ;  if  ( delay  <  min   rerun   delay   ms )  return min   rerun   delay   ms ;  else if  ( delay  >  max   rerun   delay   ms )  return max   rerun   delay   ms ;  else return delay ;   }  
public void   (  session id id )  {     session id = id ;   }  
@ override protected void   (  completable observer s )  {   disposable d =  disposables . empty (  )  ;  s . on subscribe ( d )  ;  try  {  runnable . run (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  if  (  ! d . is d
@ deprecated @ override public boolean   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public boolean   ( i2np message message )  {  if  ( message instanceof  delivery status message )   {   delivery status message msg =  (  delivery status message ) message ;  if  (    nonce  =  =  msg . get message id (  )  )   {  long time left =    expiration  -  get context (  )  . clock (  )  . now (  )  ;  if  ( time left  <  0 )   {  if  (    log . should log (  log . warn )  )     log . warn ( " took too long to get a reply from peer "  +     peer . to base64 (  )   +  ": " +   ( 0  -  time left )  +  "ms too slow" )  ;  get context (  )  . stat manager (  )  . add rate data ( "peer . test too slow" 0  -  time left )  ;   }  else  {  get context (  )  . stat manager (  )  . add rate data ( "peer . testok" get test timeout (  )   -  time left )  ;   }     match found = true ;  return true ;   }   }  return false ;   }  
private void   ( final  list <  read ends for mark duplicates >  list final boolean contains pairs )  {  if  ( contains pairs )   {  for  (  final  read ends for mark duplicates end : list )   {  if  (  ! end . is paired (  )  )   {  add index as duplicate ( end . read1 index in file )  ;   }   }   }  else  {  short max score = 0 ;   read ends for mark duplicates best = null ;  for  (  final  read ends for mark duplicates end : list )   {  if  ( end . score  >  max score || best  =  =  null )   {  max score = end . score ;  best = end ;   }   }  for  (  final  read ends for mark duplicates end : list )   {  if  ( end  !  =  best )   {  add index as duplicate ( end . read1 index in file )  ;   }   }   }   }  
public void   ( boolean distributed bridge )  {  this . distributed bridge = distributed bridge ;   }  
protected  pending gateway message   ( int size boolean include router boolean include tunnel )  {   data message m = new  data message (    context )  ;  byte data[] = new byte[size] ;     context . random (  )  . next bytes ( data )  ;  m . set data ( data )  ;  m . set unique id (    context . random (  )  . next long ( i2np message . max   id   value )  )  ;  m . set message expiration (    context . clock (  )  . now (  )   +  60 * 1000 )  ;   hash to router = null ;   tunnel id to tunnel = null ;  if  ( include router )   {  to router = new  hash ( new byte[ hash . hash   length] )  ;     context . random (  )  . next bytes ( to router . get data (  )  )  ;   }  if  ( include tunnel )  to tunnel = new  tunnel id ( 1  +     context . random (  )  . next long (  tunnel id . max   id   value )  )  ;  return new  pending gateway message ( m to router to tunnel )  ;   }  
@ xml attribute public  string   (  )  {  return key ;   }  
@ override public void   (  )  {   list <  string >  buddy list = new  array list <  string >  (  )  ;  for  (   transport buddy buddy : get buddy manager (  )  . get buddies (  )  )   {  buddy list . add ( buddy . get name (  )  )  ;   }  if  (  ! buddy 
public static  group element   ( final  group element g final  field element f )  {  final byte[] bytes = f . to byte array (  )  ;   group element h = curve . get zero (  group element .  representation . p3 )  ;  for  ( int i = 254 ;  i  >  =  0 ;  i -  -  )   {  h = double group element ( h )  ;  if  (  utils . bit ( bytes i )   =  =  1 )   {  h = add group elements ( h g )  ;   }   }  return h ;   }  
public static  < t >  consumer < t >    ( final  list < t >  list )  {  return new  consumer < t >  (  )  {  @ override public void accept (  t t )  {  list . add ( t )  ;   }   }   ;   }  
@ override public  transport session < qq buddy >    (  registration registration jid jid  presence type presence type  string verbose status  integer priority )  {   transport session < qq buddy >  session = new qq session ( registration jid this priorit
private   (  )  {  super (  )  ;   }  
private byte[]   ( byte data[]  public key target  session key key  set <  session tag >  tags for delivery  session key new key long padded size )  {  byte elg src data[] = new byte[ session key . keysize   bytes  +  32  +  158] ;   system . arraycopy ( key . get data (  )  0 elg src data 0  session key . keysize   bytes )  ;     context . random (  )  . next bytes ( elg src data  session key . keysize   bytes 32  +  158 )  ;  byte preiv[] =  simple byte cache . acquire ( 32 )  ;   system . arraycopy ( elg src data  session key . keysize   bytes preiv 0 32 )  ;  long before =    context . clock (  )  . now (  )  ;  byte elg encr[] =    context . el gamal engine (  )  . encrypt ( elg src data target )  ;  if  (    log . should log (  log . info )  )   {  long after =    context . clock (  )  . now (  )  ;     log . info ( "elg engine . encrypt of the session key took "  +   ( after  -  before )   +  "ms" )  ;   }  if  ( elg encr . length  <  514 )   {  byte elg[] = new byte[514] ;  int diff = elg . length  -  elg encr . length ;   system . arraycopy ( elg encr 0 elg diff elg encr . length )  ;  elg encr = elg ;   }  byte[] iv = half hash ( preiv )  ;   simple byte cache . release ( preiv )  ;  byte aes encr[] = encryptaes block ( data key iv tags for delivery new key padded size )  ;   simple byte cache . release ( iv )  ;  byte rv[] = new byte[elg encr . length  +  aes encr . length] ;   system . arraycopy ( elg encr 0 rv 0 elg encr . length )  ;   system . arraycopy ( aes encr 0 rv elg encr . length aes encr . length )  ;  return rv ;   }  
@ override public int   (  )  {  return parallelism ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . scan with ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   new  bi function <  object  integer  object >  (  )  {  @ ov
public static void   ( final  content resolver cr final long[] message keys final int count )  {  retry messages ( cr content   uri message keys count )  ;   }  
@ override public  single <  ?  extends  integer >    (  integer v )  throws  exception  {  return  single . just ( v )  ;   }  
private void   (  http servlet request http request  http servlet response http response  filter context filter context )  throws io exception   servlet exception  {   http servlet request maybe wrapped servlet request = http request ;   http servlet response maybe wrapped servlet response = http response ;  try  {  boolean is intra filter logging enabled = intrafilter   log . is trace enabled (  )  ;  if  ( is intra filter logging enabled )   {   servlet input stream input stream = maybe wrapped servlet request . get input stream (  )  ;  if  (  ! input stream . mark supported (  )  )   {   byte array output stream source entity = new  byte array output stream (  )  ;   raw input stream reader . instance (  )  . copy to ( input stream source entity )  ;  input stream = new  buffered servlet input stream ( new  byte array input stream ( source entity . to byte array (  )  )  )  ;   }  maybe wrapped servlet request = new  http servlet request wrapper ( maybe wrapped servlet request input stream )  ;  maybe wrapped servlet response = new  http servlet response wrapper ( maybe wrapped servlet response  response mode . passthrough  response mode . readonly )  ;  intrafilter   log . trace ( intrafilter request log (  (  http servlet request wrapper ) maybe wrapped servlet request filter context )  )  ;   }  filter context . get filter (  )  . do filter ( maybe wrapped servlet request maybe wrapped servlet response this )  ;  if  ( is intra filter logging enabled )   {  intrafilter   log . trace ( intrafilter response log (  (  http servlet response wrapper ) maybe wrapped servlet response filter context maybe wrapped servlet request . get header ( intrafilter   uuid )  )  )  ;   }   }  catch  (   exception ex )   {   string filter name = filter context . get filter (  )  . get class (  )  . get simple name (  )  ;  log . error ( " failure in filter: "  +  filter name  +  "  -   reason: " +  ex . get message (  )  ex )  ;  maybe wrapped servlet response . set status (  http servlet response . sc   internal   server   error )  ;   }   }  
public void   ( int idle time )  {  if  ( get server session idle time (  )   =  =  idle time )   {  return ;   }   jive globals . set property ( "xmpp . server . session . idle"  integer . to string ( idle time )  )  ;  if  ( idle time  <  =  0 && is multiple server connections allowed (  )  )   {   log . warn ( " allowing multiple s2s connections for each domain  without setting a "  +  "maximum idle timeout for these connections  is unrecommended !   either "  +  "set xmpp . server . session . allowmultiple to 'false' or change " +  "xmpp . server . session . idle to a  ( large )  positive value . " )  ;   }   }  
public boolean   (  )  {  return    allow zero hop ;   }  
@ override public  list < jid >    (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;   list < jid >  jids = new  array list <  >  (  )  ;  synchronized  ( get adminssql )   {  try  {  con = get connection (  ) 
protected  object   (  cluster task task )  {   cluster node info info =  cache factory . get cluster node info ( nodeid )  ;   object result = null ;  if  ( info  =  =  null && task instanceof  remote session task )   {   session remote session =  (  (  remote session task ) task )  . get session (  )  ;  if  ( remote session instanceof  client session )   {   session manager . get instance (  )  . remove session ( null remote session . get address (  )  false false )  ;   }   }  else  {  result =  ( info  =  =  null )   ?  null :  cache factory . do synchronous cluster task ( task nodeid )  ;   }  return result ;   }  
public static long   ( long value  string param name )  {  if  ( value  <  =  0l )   {  throw new  illegal argument exception ( param name  +  "  >  0 required but it was "  +  value )  ;   }  return value ;   }  
protected  string   (  )  {  return auth   realm ;   }  
@ scheduler support (  scheduler support . none )  public final void   (  consumer <  ?  super t >  on next )  {   iterator < t >  it = blocking iterable (  )  . iterator (  )  ;  while  ( it . has next (  )  )   {  try  {  on next . accept ( it . next ( 
public  collection <  string >    (  )  {  return rejections ;   }  
@ test public void   (  )  {  int num =  ( int )  (  flowable . buffer size (  )  * 2 . 1 )  ;   atomic integer c = new  atomic integer (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  incrementing integers ( c )  .
public  string   (  )  {  return  jive globals . get property ( subject " message of the  day" )  ;   }  
public void   (  )  throws  messaging exception  {   mime message message = new  mime message (  )  ;  message . set subject ( short   unicode )  ;  assert equals ( "unicode readback" short   unicode message . get subject (  )  )  ;   string raw header = message . get first header ( " subject" )  ;  assert equals ( "raw readback" short   unicode   encoded raw header )  ;   }  
@ test public void   (  )  throws  exception  {  when ( mocked request . get headers ( " accept" )  )  . then return (  collections . enumeration (  collections . singleton list ( media   type   text   plain )  )  )  ;  response message service impl . han
public void   ( int call timeout )  {  this . call timeout = call timeout ;   }  
@ test public void   (  )  throws  exception  {  h . execute ( "insert into something  ( id  name )  values  (  ?    ?  ) " 1 "hello" )  ;  h . execute ( "insert into something  ( id  name )  values  (  ?    ?  ) " 2 "world" )  ;   list <  map <  string  
private static final boolean   (  string input file  string signed file  string private key file  string version )  {   signature signature = new  trusted update (  )  . sign ( input file signed file private key file version )  ;  if  ( signature  !  =  null )   system . out . println ( " input file '"  +  input file  +  "' signed and written to '" +  signed file +  "'" )  ;  else  system . out . println ( " error signing input file '"  +  input file  +  "'" )  ;  return signature  !  =  null ;   }  
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable . just ( 1 )  . flat map ( new  function <  integer  publisher <  ?  extends  object >  >  (  )  {  @ override public  publisher <  ?  extends  object >  apply (   integer v )  throws 
void   (  unicast processor < t >  w )  {  queue . offer ( new  subject work < t >  ( w false )  )  ;  if  ( enter (  )  )   {  drain loop (  )  ;   }   }  
@ test public void   (  )  {   observable <  string >  observable1 = create observable ( new  string[] { "1" }  2000 null )  ;   observable <  string >  observable2 = create observable ( new  string[] {  }  1000 null )  ;   observable <  string >  observa
  ( int capacity hint )  {  this . buffer = new  array list <  object >  (  object helper . verify positive ( capacity hint "capacity hint" )  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single element (  )  . 
synchronized void   (  )  {  disable (  )  ;  executor . shutdown (  )  ;   statistics manager . get instance (  )  . remove statistic ( proxy transfer rate )  ;   }  
  (  with latest from observer < t u r >  wlf )  {  this . wlf = wlf ;   }  
@ override public boolean   (  )  {  return is initialized ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer counter = new  atomic integer (  )  ;   observable <  string >  o =  observable .  <  string > unsafe create ( new  observable source <  string >  (  )  {  @ override publi
private static final boolean   (  sig type type  content type ctype int ftype  string input file  string signed file  string private key file  string version  string signer name  string keypw  string kspass )  {  try  {  while  ( keypw . length (  )   <  6 )   {   system . out . print ( " enter password for key \""  +  signer name  +  "\": " )  ;  keypw =  data helper . read line (  system . in )  ;  if  ( keypw  =  =  null )   {   system . out . println ( "\neof reading password" )  ;  return false ;   }  keypw = keypw . trim (  )  ;  if  ( keypw . length (  )   >  0 && keypw . length (  )   <  6 )   system . out . println ( " key password must be at least 6 characters" )  ;   }   file pkfile = new  file ( private key file )  ;   private key pk =  key store util . get private key ( pkfile kspass signer name keypw )  ;  if  ( pk  =  =  null )   {   system . out . println ( " private key for "  +  signer name  +  " not found in keystore " +  private key file )  ;  return false ;   }   sig type old type = type ;  type =  sig util . from java key ( pk )  . get type (  )  ;  if  ( old type  !  =  type )   system . out . println ( " warning:  using private key type "  +  type  +  "  ignoring specified type " +  old type )  ;  su3 file file = new su3 file ( signed file )  ;  file . write ( new  file ( input file )  ftype ctype . get code (  )  version signer name pk type )  ;   system . out . println ( " input file '"  +  input file  +  "' signed and written to '" +  signed file +  "'" )  ;  return true ;   }  catch  (   general security exception gse )   {   system . out . println ( " error signing input file '"  +  input file  +  "'" )  ;  gse . print stack trace (  )  ;  return false ;   }  catch  (  io exception ioe )   {   system . out . println ( " error signing input file '"  +  input file  +  "'" )  ;  ioe . print stack trace (  )  ;  return false ;   }   }  
  ( final char ref final char call )  {  this . ref = ref ;  this . call = call ;   }  
@ test public void   (  )  {  final  observable <  string >  o1 =  observable . unsafe create ( new  test error observable ( "four" null "six" )  )  ;  final  observable <  string >  o2 =  observable . unsafe create ( new  test error observable ( "one" "t
@ test public void   (  )  {  assert equals ( 1  single internal helper .  to observable . values (  )  . length )  ;  assert not null (  single internal helper .  to observable . value of ( "instance" )  )  ;   }  
@ override protected void   ( final  single observer <  ?  super  long >  s )  {   timer disposable parent = new  timer disposable ( s )  ;  s . on subscribe ( parent )  ;  parent . set future ( scheduler . schedule direct ( parent delay unit )  )  ;   } 
@ test public void   (  )  {   observable . range ( 1 5 )  . do after next ( after next )  . subscribe with ( to )  . assert result ( 1 2 3 4 5 )  ;  assert equals (  arrays . as list ( 1  - 1 2  - 2 3  - 3 4  - 4 5  - 5 )  values )  ;   }  
public   ( sasl authentication sasl authentication )  {  super ( sasl authentication )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   take first source = new  take first ( to )  ;  source . on subscribe (  disposables . empty (  )  )  ;   disposable d =  disposables . empty (  )  ;
@ test public void   (  )  throws  exception  {  @ suppress warnings ( "unchecked" )   consumer <  integer >  on dispose = mock (  consumer . class )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   completable . using 
private static final int   (  string str int default value )  {  return  ( int ) get long ( str default value )  ;   }  
public static  rate averages   (  )  {  return temp . get (  )  ;   }  
  ( t value  subscriber <  ?  super t >  actual )  {  this . value = value ;  this . actual = actual ;   }  
private boolean   (  class <  ?  >  erased type )  {  return resolve default collector ( erased type )  . is defined (  )  ;   }  
private   (  )  {  super (  )  ;   }  
public static  header name   (  string name )  {  return new  header name ( name )  ;   }  
private boolean   ( jid prober jid probee )  throws  user not found exception  {   roster roster ;  roster = xmpp server . get instance (  )  . get roster manager (  )  . get roster ( prober . get node (  )  )  ;   roster item item = roster . get roster item ( probee )  ;  if  ( item . get sub status (  )   =  =   roster item . sub   both || item . get sub status (  )   =  =   roster item . sub   from )   {  return true ;   }  return false ;   }  
private synchronized void   (  )  {  if  ( file  =  =  null )   {   log . error ( " unable to save xml properties ;  no file specified" )  ;  return ;   }  boolean error = false ;   path temp file = file . get parent (  )  . resolve ( file . get file name (  )   +  " . tmp" )  ;  try  (  writer writer =  files . new buffered writer ( temp file  standard charsets . utf   8 )  )  {   output format pretty printer =  output format . create pretty print (  )  ;  xml writer xml writer = new xml writer ( writer pretty printer )  ;  xml writer . write ( document )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  error = true ;   }  if  (  ! error )   {  try  {   files . delete if exists ( file )  ;   }  catch  (  io exception e )   {   log . error ( " error deleting property file: "  +  file )  ;  return ;   }  try  {   files . copy ( temp file file  standard copy option . replace   existing )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  error = true ;   }  if  (  ! error )   {  try  {   files . delete if exists ( temp file )  ;   }  catch  (  io exception e )   {   log . error ( " error deleting temp file: "  +  temp file )  ;   }   }   }   }  
public  string   (  )  {  return destination id ;   }  
protected static  general names   (  set <  string >  san dns names )  {  final asn1 encodable vector subject alternative names = new asn1 encodable vector (  )  ;  if  ( san dns names  !  =  null )   {  for  (  final  string dns name value : san dns names )   {  subject alternative names . add ( new  general name (  general name . dns name dns name value )  )  ;   }   }  return  general names . get instance ( new der sequence ( subject alternative names )  )  ;   }  
public static o auth provider   ( final  context context final  string id final int resource id )  {  try  {  final  xml resource parser xml = context . get resources (  )  . get xml ( resource id )  ;  int xml event type ;  o auth provider provider = null ;  while  (  ( xml event type = xml . next (  )  )   !  =   xml resource parser . end   document )   {  if  ( xml event type  =  =   xml resource parser . start   tag && "provider" . equals ( xml . get name (  )  )  )   {   string provider id = get xml attribute ( context xml "id" )  ;  try  {  if  (  text utils . equals ( id provider id )  )   {  provider = new o auth provider (  )  ;  provider . id = id ;  provider . label = get xml attribute ( context xml "label" )  ;  provider . auth endpoint = get xml attribute ( context xml "auth   endpoint" )  ;  provider . token endpoint = get xml attribute ( context xml "token   endpoint" )  ;  provider . refresh endpoint = get xml attribute ( context xml "refresh   endpoint" )  ;  provider . response type = get xml attribute ( context xml "response   type" )  ;  provider . redirect uri = get xml attribute ( context xml "redirect   uri" )  ;  provider . scope = get xml attribute ( context xml "scope" )  ;  provider . state = get xml attribute ( context xml "state" )  ;  provider . client id = get xml attribute ( context xml "client   id" )  ;  provider . client secret = get xml attribute ( context xml "client   secret" )  ;  return provider ;   }   }  catch  (   illegal argument exception e )   {   log utils . w (  logging . log   tag "providers line: "  +  xml . get line number (  )   +  " ;   domain contains multiple globals" )  ;   }   }   }   }  catch  (   exception e )   {   log utils . e (  logging . log   tag " error while trying to load provider settings . " e )  ;   }  return null ;   }  
public void   (  )  {  stopped = true ;  index updater . cancel (  )  ;  if  ( searcher  !  =  null )   {  try  {  searcher . close (  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  searcher = null ;   }  try  {  directory . close (  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  directory = null ;  index properties = null ;  conversation manager = null ;  search dir = null ;  rebuild future = null ;   }  
private void   (  pub sub service service iq iq  element options element )  {   string nodeid = options element . attribute value ( "node" )  ;   string subid = options element . attribute value ( "subid" )  ;   node node ;  if  ( nodeid  =  =  null )   {  if  ( service . is collection nodes supported (  )  )   {  node = service . get root collection node (  )  ;   }  else  {   element pubsub error =  document helper . create element ( q name . get ( "nodeid - required" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;  send error packet ( iq  packet error .  condition . bad   request pubsub error )  ;  return ;   }   }  else  {  node = service . get node ( nodeid )  ;  if  ( node  =  =  null )   {  send error packet ( iq  packet error .  condition . item   not   found null )  ;  return ;   }   }   node subscription subscription ;  if  ( node . is multiple subscriptions enabled (  )  )   {  if  ( subid  =  =  null )   {   element pubsub error =  document helper . create element ( q name . get ( "subid - required" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;  send error packet ( iq  packet error .  condition . bad   request pubsub error )  ;  return ;   }  else  {  subscription = node . get subscription ( subid )  ;  if  ( subscription  =  =  null )   {   element pubsub error =  document helper . create element ( q name . get ( "invalid - subid" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;  send error packet ( iq  packet error .  condition . not   acceptable pubsub error )  ;  return ;   }   }   }  else  {   string jid attribute = options element . attribute value ( "jid" )  ;  if  ( jid attribute  =  =  null )   {   element pubsub error =  document helper . create element ( q name . get ( "jid - required" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;  send error packet ( iq  packet error .  condition . bad   request pubsub error )  ;  return ;   }  jid subscriberjid = new jid ( jid attribute )  ;  subscription = node . get subscription ( subscriberjid )  ;  if  ( subscription  =  =  null )   {   element pubsub error =  document helper . create element ( q name . get ( "not - subscribed" "http: /  / jabber . org / protocol / pubsub#errors" )  )  ;  send error packet ( iq  packet error .  condition . unexpected   request pubsub error )  ;  return ;   }   }  if  (  ! subscription . can modify ( iq . get from (  )  )  )   {  send error packet ( iq  packet error .  condition . forbidden null )  ;  return ;   }   element form element = options element . element ( q name . get ( "x" "jabber:x:data" )  )  ;  if  ( form element  !  =  null )   {  subscription . configure ( iq new  data form ( form element )  )  ;   }  else  {  send error packet ( iq  packet error .  condition . bad   request null )  ;   }   }  
public void   (  string custom options )  {     config . set custom options ( custom options )  ;   }  
@ override public void   (  completable emitter e )  throws  exception  {  e . on complete (  )  ;  response[0] = e . try on error ( new  test exception (  )  )  ;   }  
@ override public  string   (  string username )  throws  user not found exception   unsupported operation exception  {  throw new  unsupported operation exception ( " retrieve password not supported by this version of authentication provider" )  ;   }  
public int   (  )  {  return    max conns per hour ;   }  
  (  subscriber <  ?  super t >  actual  publisher <  ?  extends t >  other )  {  this . actual = actual ;  this . other = other ;  this . empty = true ;  this . arbiter = new  subscription arbiter (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  string >  func = mock (  callable . class )  ;  final  count down latch func latch = new  count down latch ( 1 )  ;  final  count down latch observer latch 
@ test public void   (  )  {   observable <  string >  source =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  observer )  {  observer . on subscribe (  dispo
@ before public void   (  )  throws  exception  {  app =  (  (  list appender )  ( ctx . get configuration (  )  . get appender ( " list0" )  )  )  . clear (  )  ;  health check service = mock (  health check service . class )  ;  health check service pro
private void   (  packet packet long send id boolean queue if no conn )  {  if  ( packet . is flag set (  packet . flag   echo )  )   {  if  ( packet . get send stream id (  )   >  0 )   {  if  (    manager . answer pings (  )  )  receive ping ( null packet )  ;  else if  (    log . should log (  log . warn )  )     log . warn ( " dropping  echo packet on unknown con: "  +  packet )  ;   }  else if  ( packet . get receive stream id (  )   >  0 )   {  receive pong ( packet )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " echo packet received with no stream i ds: "  +  packet )  ;   }  packet . release payload (  )  ;   }  else  {  if  (    log . should log (  log . info )  &&  ! packet . is flag set (  packet . flag   synchronize )  )     log . info ( " packet received on an unknown stream  ( and not an echo or syn ) : "  +  packet )  ;  if  ( send id  <  =  0 )   {   connection con =    manager . get connection by outbound id ( packet . get receive stream id (  )  )  ;  if  ( con  !  =  null )   {  if  (  ( con . get highest acked through (  )   <  =  5 )  &&  ( packet . get sequence num (  )   <  =  5 )  )   {  if  (    log . should log (  log . info )  )     log . info ( " received additional packet w / o  send streamid after the syn on "  +  con  +  ": " +  packet )  ;  receive known con ( con packet )  ;  return ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( "hrmph  received while ack of syn was in flight on "  +  con  +  ": " +  packet +  " acked: " +  con . get acked packets (  )  )  ;  receive known con ( con packet )  ;  return ;   }   }   }  else  {  if  (    log . should log (  log . warn )  )   {  boolean recent =    manager . was recently closed ( packet . get send stream id (  )  )  ;     log . warn ( " dropping pkt w /  send id but no con found  recently disconnected ?  "  +  recent  +  ' ' +  packet )  ;   }  packet . release payload (  )  ;  return ;   }  if  ( packet . is flag set (  packet . flag   synchronize )  )   {     manager . get connection handler (  )  . receive new syn ( packet )  ;   }  else if  ( queue if no conn )   {  if  (    log . should log (  log . warn )  )   {     log . warn ( " packet belongs to no other cons  putting on the syn queue: "  +  packet )  ;   }  if  (    log . should log (  log . debug )  )   {   string builder buf = new  string builder ( 128 )  ;  for  (   connection con :    manager . list connections (  )  )   {  buf . append ( con . to string (  )  )  . append ( " " )  ;   }     log . debug ( "connections: "  +  buf . to string (  )   +  " send id: " +   ( send id  >  0  ?   packet . to id ( send id )  : " unknown" )  )  ;   }     manager . get connection handler (  )  . receive new syn ( packet )  ;   }  else  {  if  ( i2p socket manager full . pcap writer  !  =  null &&    context . get boolean property ( i2p socket manager full . prop   pcap )  )  packet . logtcp dump ( null )  ;  send reset ( packet )  ;  packet . release payload (  )  ;   }   }   }  
public boolean   (  )  {  return    is running ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set on before blocking ( new  boolean supplier (  )  {  @ override public boolean get as boolean (  )  throws  exception  {  return true ;   }   }   )  ;   rx java plugins . set fail on non blocking
public int   ( byte[] in data byte[] out data int out offset )  throws  speex exception  {  if  (  logger . log level  =  =   - 59 )   {   logger . log level = 3 ;   util . dump ( "encode input: length "  +  in data . length in data 0 16 )  ;   }  long start =  current time . get time (  )  ;  if  ( big endian  =  =  false )   {  byte[] data = new byte[in data . length] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  = 2 )   {  data[i] = in data[i  +  1] ;  data[i  +  1] = in data[i] ;   }  in data = data ;   }  try  {  speex encoder . process data ( in data 0 in data . length )  ;   }  catch  (   exception e )   {   logger . println ( "in data . length "  +  in data . length  +  " out data . length " +  out data . length +  " out offset " +  out offset )  ;  e . print stack trace (  )  ;  throw new  speex exception ( " speex encode: "  +  e . get message (  )  )  ;   }  int enc size = speex encoder . get processed data byte size (  )  ;  encodes +  +  ;  encode time +  =  (  current time . get time (  )   -  start )  ;  bytes encoded +  = in data . length ;  speex encoder . get processed data ( out data out offset )  ;  if  (  logger . log level  >  =   logger . log   moredetail )   {   util . dump ( "encode data output: "  +  enc size out data 0 enc size )  ;   }  return enc size ;   }  
public  collection   (  )  {  if  ( scripts  =  =  null )   {  scripts = new  array list (  )  ;   }  return scripts ;   }  
public void   ( boolean http basic auth )  {  this . http basic auth = http basic auth ;   jive globals . set property ( "plugin . userservice . http auth . enabled" http basic auth  ?  "true" : "false" )  ;   }  
@ deprecated public int   (  )  {  return get port (  connection type . component true )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  final  atomic integer wip = new  atomic integer (  )  ;  final int indicator = 999999999 ;   observable window with size test . hot stream (  )  . wi
  ( i2p app context ctx )  {     my private value = new  native big integer ( ctx . key generator (  )  . get el gamal exponent size (  )  ctx . random (  )  )  ;     my public value =  crypto constants . elgg . mod pow (    my private value  crypto constants . elgp )  ;     extra exchanged bytes = new  byte array (  )  ;   }  
@ test public void   (  )  {   replay processor <  object >  rs =  replay processor . create unbounded (  )  ;  rs . on error ( new  test exception (  )  )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has value (  )  )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
public  rate stat   (  )  {  return    invalid reply rate ;   }  
public int   (  )  {  return row count ;   }  
public long   (  byte buffer[] srcs int offset int length )  {  throw new  unsupported operation exception (  )  ;   }  
@ override public int   (  )  {  return localmuc room manager . get number chat rooms (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  observer )  {  observer . on subscribe (  dispo
@ nullable @ suppress warnings ( "rawtypes" )  public static  function <  ?  super  connectable observable  ?  extends  connectable observable >    (  )  {  return on connectable observable assembly ;   }  
void   (  )  {  t value = get and set ( null )  ;  if  ( value  !  =  null )   {  long r = requested . get (  )  ;  if  ( r  !  =  0l )   {  actual . on next ( value )  ;   backpressure helper . produced ( requested 1 )  ;   }  else  {  cancel (  )  ;  actual . on error ( new  missing backpressure exception ( " couldn't emit value due to lack of requests ! " )  )  ;   }   }   }  
void   ( int index  throwable ex )  {  if  ( errors . add throwable ( ex )  )   {  boolean cancel others = true ;  if  ( delay error )   {  synchronized  ( this )   {   object[] latest = this . latest ;  if  ( latest  =  =  null )   {  return ;   }  cancel others = latest[index]  =  =  null ;  if  ( cancel others ||  +  + complete  =  =  latest . length )   {  done = true ;   }   }   }  if  ( cancel others )   {  cancel sources (  )  ;   }  drain (  )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
public void   ( long num )  {     unprompted db store new = num ;   }  
public   ( i2p app context ctx )  {  super ( ctx  bandwidth limits message . message   type )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just ( 1 )  . to list (  )  . to observable (  )  )  ;   test helper . check disposed (  observable . just ( 1 )  . to list (  )  )  ;   }  
@ test public void   (  )  {  try  {   exceptions . throw if fatal ( new  thread death (  )  )  ;  fail ( " didn't throw fatal exception" )  ;   }  catch  (   thread death ex )   {   }  try  {   exceptions . throw if fatal ( new  linkage error (  )  )  ; 
public static  session event   (  session session )  {  return new  session event ( session session   disconnect null )  ;   }  
public  tuple status   (  )  {  return this . tuple status ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . merge array ( 128 128  (  observable <  object > [] ) null )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "b" "cc" "dd" )  ;   observable <  map <  integer  collection <  string >  >  >  mapped = source . to multimap ( length func duplicate )  . to observable (  )  ;   ma
public void   (  )  {  final  my task task1 = new  my task ( null )  ;  task1 . unregister self (  )  ;   }  
public  conference manager   (  )  {  return conference manager ;   }  
@ test ( timeout = 1000 expected =  no such element exception . class )  public void   (  )  {   flowable <  long >  source =  flowable .  <  long > empty (  )  ;   iterable <  long >  iter = source . blocking latest (  )  ;   iterator <  long >  it = ite
@ test ( expected =  runtime exception . class )  @ ignore ( " subscribers can't throw" )  public void   (  )  {   rx java plugins . set error handler ( new  consumer <  throwable >  (  )  {  int calls ;  @ override public void accept (   throwable e )  {
private  reply waiter   (  node info n info nid tid )  {  if  (    log . should log (  log . info )  )     log . info ( " sending find node of "  +  tid  +  " to: " +  n info )  ;   map <  string  object >  map = new  hash map <  string  object >  (  )  ;  map . put ( "q" "find   node" )  ;   map <  string  object >  args = new  hash map <  string  object >  (  )  ;  args . put ( "target" tid . get data (  )  )  ;  map . put ( "a" args )  ;  return send query ( n info map true )  ;   }  
private void   (  string transport )  {   message message = generate command ( transport "average   memory   per   user" )  ;  router . route ( message )  ;   }  
@ override public void   (  )  {  cancelled = true ;  s . cancel (  )  ;  set . dispose (  )  ;   }  
@ test public void   (  )  {  final  string name = " computation scheduler test" ;   thread factory factory = new  thread factory (  )  {  @ override public  thread new thread (   runnable r )  {  return new  thread ( r name )  ;   }   }   ;  final  sched
public void   ( final sam record and reference args )  {  mapped record count +  +  ;  final sam record sam record = args . get sam record (  )  ;  final  reference sequence reference sequence = args . get reference sequence (  )  ;  final byte[] read bases = sam record . get read bases (  )  ;  final byte[] read qualities = sam record . get base qualities (  )  ;  final byte[] ref bases = reference sequence . get bases (  )  ;  if  ( sam record . get read length (  )   <  min read length )   {  small read count +  +  ;  return ;   }  else if  (  sequence util . count mismatches ( sam record ref bases true )   >   math . round ( sam record . get read length (  )  * max mismatch rate )  )   {  mismatch count +  +  ;  return ;   }  int record cpgs = 0 ;  for  (  final  alignment block alignment block : sam record . get alignment blocks (  )  )   {  final int block length = alignment block . get length (  )  ;  final int ref fragment start = alignment block . get reference start (  )   -  1 ;  final int read fragment start = alignment block . get read start (  )   -  1 ;  final byte[] ref fragment = get fragment ( ref bases ref fragment start block length )  ;  final byte[] read fragment = get fragment ( read bases read fragment start block length )  ;  final byte[] read quality fragment = get fragment ( read qualities read fragment start block length )  ;  if  ( sam record . get read negative strand flag (  )  )   {   sequence util . reverse complement ( ref fragment )  ;   sequence util . reverse complement ( read fragment )  ;   sequence util . reverse qualities ( read quality fragment )  ;   }  for  ( int i = 0 ;  i  <  block length  -  1 ;  i +  +  )   {  final int cur ref index = get cur ref index ( ref fragment start block length i sam record . get read negative strand flag (  )  )  ;  if  (  (  sequence util . bases equal ( ref fragment[i]  sequence util . c )  )  &&  (  sequence util . bases equal ( ref fragment[i  +  1]  sequence util . g )  )  )   {  if  ( is valid cpg ( ref fragment read fragment read quality fragment i )  )   {  record cpgs +  +  ;  final  cpg location cur location = new  cpg location ( sam record . get reference name (  )  cur ref index )  ;  cpg total . increment ( cur location )  ;  if  (  sequence util . is bisulfite converted ( read fragment[i] ref fragment[i] )  )   {  cpg converted . increment ( cur location )  ;   }   }  i +  +  ;   }  else if  ( isc ( ref fragment[i] read fragment[i] )  && is above cyto qc threshold ( read qualities i )  &&  sequence util . bisulfite bases equal ( false read fragment[i  +  1] ref fragment[i  +  1] )  )   {  n cyto total +  +  ;  if  (  sequence util . is bisulfite converted ( read fragment[i] ref fragment[i] )  )   {  n cyto converted +  +  ;   }   }   }   }  if  ( record cpgs  =  =  0 )   {  no cpg count +  +  ;   }   }  
public synchronized long   (  )  {  return    next send ;   }  
@ override public  container request   (  container request container request )  throws  web application exception  {  if  (  ! plugin . is enabled (  )  )   {  throw new  web application exception (  status . forbidden )  ;   }  if  (  ! plugin . get all
int   (  )  {  return v frames . size (  )  ;   }  
public  calendar   (  )  {  return cal ;   }  
@ override protected  argument   ( url url  config registry config )  {  return  ( position statement ctx )   -  >  statement . set string ( position url . to string (  )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . window ( 1 null  schedulers . single (  )  )  ;   }  
public static void   ( @ nullable  function <  ?  super  runnable  ?  extends  runnable >  handler )  {  if  ( lockdown )   {  throw new  illegal state exception ( " plugins can't be changed anymore" )  ;   }  on schedule handler = handler ;   }  
public   (  )  {  super ( " susimail -  getter" )  ;   }  
public void   (  )  {  shutting down = true ;  if  ( pico container  !  =  null )   {  pico container . stop (  )  ;  pico container . dispose (  )  ;  pico container = null ;   }  instance = null ;   }  
public url   (  )  throws  malformedurl exception  {   port port = determine url port (  )  ;   string hostname = determine hostname (  )  ;   string root path = endpoint . get root path (  )  ;   string path =  string uri utilities . concat uris ( root path uri )  ;  return new url ( port . get protocol (  )  hostname port . get number (  )  path )  ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  long p = produced ;  if  ( p  !  =  0l )   {   backpressure helper . produced ( this p )  ;   }   queue drain helper . post complete ( actual buffers this this )  ;   }  
private boolean   (  status code matcher matched code )  {  return  string utils . equals ignore case ( matched code . get overwrite (  )  . value (  )   overwrite type . if   empty . value (  )  )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 3 )  . parallel ( 1 )  . sequential delay error ( 1 )  . rebatch requests ( 1 )  . test (  )  . assert result ( 1 2 3 )  ;   }  
@ override public void   (  )  {  s =  subscription helper . cancelled ;  if  (  ! done )   {  done = true ;  actual . on complete (  )  ;   }   }  
public void   ( boolean follow alias referrals )  {  this . follow alias referrals = follow alias referrals ;  properties . put ( "ldap . auto follow alias referrals"  string . value of ( follow alias referrals )  )  ;   }  
@ override public int   (  )  {  return max file size ;   }  
public   ( final  string ref final  string leading final  string trailing final  string zero )  {  this . ref = ref ;  this . leading = leading ;  this . trailing = trailing ;  this . zero = zero ;   }  
@ override public void   (  group group  map params )  {  apply affiliation change and send presence ( new jid (  (  string ) params . get ( "admin" )  )  )  ;   }  
@ after class public static void   (  )  {  handle . close (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . combine latest delay error (  arrays . as list ( just1 )  null 128 )  ;   }  
public synchronized boolean   (  )  {  return body  !  =  null ;   }  
private boolean   ( final sam record record )  {  final  object noise attribute = record . get attribute (  reserved tag constants . xn )  ;  return  ( noise attribute  !  =  null && noise attribute . equals ( 1 )  )  ;   }  
public  data structure   (  )  {  return new  send message message (  )  ;   }  
public  string   (  )  {  return get header value ( http . nts )  ;   }  
  (  observer <  ?  super t >  actual  function <  ?  super  throwable  ?  extends  observable source <  ?  extends t >  >  next supplier boolean allow fatal )  {  this . actual = actual ;  this . next supplier = next supplier ;  this . allow fatal = allow fatal ;  this . arbiter = new  sequential disposable (  )  ;   }  
public void   (  string key )  {  this . key = key ;   }  
@ override public boolean   (  string hostname  destination d  properties options )  {   buffered writer out = null ;  if  (  ! get write lock (  )  )  return false ;  try  {  if  (    is closed )  return false ;  try  {  if  ( get key ( hostname )   !  =
@ override public  compression policy   (  )  {  return compression policy ;   }  
public static void   ( final  supported illumina format format final  file intensity dir final int lane final  list <  integer >  tiles final int[] cycles final  string compression )  {   string lane dir =  string . value of ( lane )  ;  while  ( lane dir . length (  )   <  3 )   {  lane dir = "0"  +  lane dir ;   }  lane dir = "l"  +  lane dir ;  final  file basecall dir = new  file ( intensity dir " base calls" )  ;  final  file basecall lane dir = new  file ( basecall dir lane dir )  ;  final  file intensity lane dir = new  file ( intensity dir lane dir )  ;  switch  ( format )   {  case  barcode: make per tile files ( basecall dir lane tiles maybe add ext ( "   barcode . txt" compression )  true )  ;  break ;  case  pos: make per tile files ( intensity dir lane tiles maybe add ext ( "   pos . txt" compression )  false )  ;  break ;  case  locs: make per tile files ( intensity lane dir lane tiles maybe add ext ( " . locs" null )  false )  ;  break ;  case  clocs: make per tile files ( intensity lane dir lane tiles maybe add ext ( " . clocs" null )  false )  ;  break ;  case  filter: make per tile files ( basecall lane dir lane tiles maybe add ext ( " . filter" null )  true )  ;  break ;  case  bcl: make per tile per cycle files ( basecall lane dir lane tiles cycles " . bcl" )  ;  break ;   }   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . delay ( 100  time unit . milliseconds )  . test ( 5 )  . await count ( 5 )  . assert values ( 1 2 3 4 5 )  . request more ( 5 )  . await done ( 5  time unit . seconds )  . assert result ( 1 2 3 4
@ override protected int   (  )  {  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  if  ( input . get absolute file (  )  . equals ( output . get absolute file (  )  )  )   {  throw new  illegal argument ex
@ data provider ( name = "test lane metrics" )  public  object[][]   (  )  {  return new  object[][] {  { "130321   sl - mak   0035   fc000000000 - a306b" }   { "130318   sl - hbb   0226   bfcc1wymacxx" }   { "130401   sl - hac   0022   bh07pbadxx" }  }  
public synchronized fifo bandwidth limiter .  request   (  )  {  verify not released (  )  ;  return    bandwidth request ;   }  
static public  < t s extends t > void   ( final t base final s derived )  {  final  class < t >  base clazz =  (  class < t >  ) base . get class (  )  ;  for  (   field f : base clazz . get fields (  )  )   {  try  {  f . set ( derived f . get ( base )  )  ;   }  catch  (   illegal access exception e )   {  throw new  runtime exception ( e . get message (  )   +  "when trying to access"  +  f . get name (  )  )  ;   }   }   }  
@ override public void   ( t t )  {  parent . other success ( t )  ;   }  
@ override public void   ( b t )  {  if  ( done )   {  return ;   }  parent . inner next (  )  ;   }  
@ override public boolean   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public   (  maybe source < t >  source  consumer <  ?  super t >  on after success )  {  super ( source )  ;  this . on after success = on after success ;   }  
void   (  )  {   disposable helper . dispose ( timer )  ;   worker w = worker ;  if  ( w  !  =  null )   {  w . dispose (  )  ;   }   }  
private void   (  )  {  for  ( int i = 0 ;  i  <     controllers . size (  )  ;  i +  +  )   {   tunnel controller controller =    controllers . get ( i )  ;  controller . destroy tunnel (  )  ;   }  if  (    log . should log (  log . info )  )     log . info (    controllers . size (  )   +  " controllers stopped" )  ;   }  
public void   (  snac request request )  {  int family = request . get command (  )  . get family (  )  ;  if  (  ! is pending ( family )  )   {  throw new  illegal argument exception ( " family 0x"  +   integer . to hex string ( family )   +  " is not pending" )  ;   }  pending snacs . add ( request )  ;   }  
@ override public boolean   ( final  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;  final  four channel intensity data that =  (  four channel intensity data ) o ; 
@ override public  map <  string  cached rate limit >    (  string user )  {  final  map <  string  cached rate limit >  account rate limit map = get user rate limit map ( user )  ;  return  collections . unmodifiable map ( account rate limit map )  ;   }
public static boolean   (  )  {  return    has wrapper ;   }  
private  file   (  )  {   string pattern =    manager . get base logfilename (  )  ;   file f = new  file ( pattern )  ;   file base = null ;  if  (  ! f . is absolute (  )  )  base =    manager . get context (  )  . get log dir (  )  ;  if  (  ( pattern . index of ( '#' )   <  0 )  &&  ( pattern . index of ( '@' )   <  =  0 )  )   {  if  ( base  !  =  null )  return new  file ( base pattern )  ;  else return f ;   }  int max =    manager . get rotation limit (  )  ;  if  (    rotation num  =  =   - 1 )   {  return get first file ( base pattern max )  ;   }     rotation num +  +  ;  if  (    rotation num  >  max )     rotation num = 0 ;   string newf = replace ( pattern    rotation num )  ;  if  ( base  !  =  null )  return new  file ( base newf )  ;  return new  file ( newf )  ;   }  
public  string   (  )  {   string builder buf = new  string builder ( 512 )  ;   string status =  news helper . get update status (  )  ;  boolean need space = false ;  if  ( status . length (  )   >  0 )   {  buf . append ( " < h4 class = \"sb   info sb   update\" > " )  . append ( status )  . append ( " <  / h4 > \n" )  ;  need space = true ;   }   string dver =  news helper . update version downloaded (  )  ;  if  ( dver  =  =  null )   {  dver =  news helper . devsu3 version downloaded (  )  ;  if  ( dver  =  =  null )  dver =  news helper . unsigned version downloaded (  )  ;   }  if  ( dver  !  =  null &&  !  news helper . is update in progress (  )  &&  !    context . router (  )  . graceful shutdown in progress (  )  )   {  if  ( need space )  buf . append ( " < hr > " )  ;  else need space = true ;  buf . append ( " < h4 class = \"sb   info sb   update\" >  < b > " )  . append (    t ( " update downloaded" )  )  . append ( " < br > " )  ;  if  (    context . has wrapper (  )  )  buf . append (    t ( " click  restart to install" )  )  ;  else buf . append (    t ( " click  shutdown and restart to install" )  )  ;  buf . append ( ' ' )  . append (    t ( " version  { 0 } "  data helper . escapehtml ( dver )  )  )  ;  buf . append ( " <  / b >  <  / h4 > " )  ;   }  boolean avail = update available (  )  ;  boolean unsigned avail = unsigned update available (  )  ;  boolean devsu3 avail = devsu3 update available (  )  ;   string constraint = avail  ?   news helper . update constraint (  )  : null ;   string unsigned constraint = unsigned avail  ?   news helper . unsigned update constraint (  )  : null ;   string devsu3 constraint = devsu3 avail  ?   news helper . devsu3 update constraint (  )  : null ;  if  ( avail && constraint  !  =  null &&  !  news helper . is update in progress (  )  &&  !    context . router (  )  . graceful shutdown in progress (  )  )   {  if  ( need space )  buf . append ( " < hr > " )  ;  else need space = true ;  buf . append ( " < h4 class = \"sb   info sb   update\" >  < b > " )  . append (    t ( " update available" )  )  . append ( ": < br > " )  ;  buf . append (    t ( " version  { 0 } " get update version (  )  )  )  . append ( " < br > " )  ;  buf . append ( constraint )  . append ( " <  / b >  <  / h4 > " )  ;  avail = false ;   }  if  ( unsigned avail && unsigned constraint  !  =  null &&  !  news helper . is update in progress (  )  &&  !    context . router (  )  . graceful shutdown in progress (  )  )   {  if  ( need space )  buf . append ( " < hr > " )  ;  else need space = true ;  buf . append ( " < h4 class = \"sb   info sb   update\" >  < b > " )  . append (    t ( " update available" )  )  . append ( ": < br > " )  ;  buf . append (    t ( " version  { 0 } " get unsigned update version (  )  )  )  . append ( " < br > " )  ;  buf . append ( unsigned constraint )  . append ( " <  / b >  <  / h4 > " )  ;  unsigned avail = false ;   }  if  ( devsu3 avail && devsu3 constraint  !  =  null &&  !  news helper . is update in progress (  )  &&  !    context . router (  )  . graceful shutdown in progress (  )  )   {  if  ( need space )  buf . append ( " < hr > " )  ;  else need space = true ;  buf . append ( " < h4 class = \"sb   info sb   update\" >  < b > " )  . append (    t ( " update available" )  )  . append ( ": < br > " )  ;  buf . append (    t ( " version  { 0 } " get devsu3 update version (  )  )  )  . append ( " < br > " )  ;  buf . append ( devsu3 constraint )  . append ( " <  / b >  <  / h4 > " )  ;  devsu3 avail = false ;   }  if  (  ( avail || unsigned avail || devsu3 avail )  &&  !  news helper . is update in progress (  )  &&  !    context . router (  )  . graceful shutdown in progress (  ) &&    context . port mapper (  )  . get port (  port mapper . svc   http   proxy )   >  0 && get action (  )   =  =  null && get update nonce (  )   =  =  null )   {  if  ( need space )  buf . append ( " < hr > " )  ;  long nonce =    context . random (  )  . next long (  )  ;   string prev =  system . get property ( "net . i2p . router . web .  update handler . nonce" )  ;  if  ( prev  !  =  null )   system . set property ( "net . i2p . router . web .  update handler . nonce prev" prev )  ;   system . set property ( "net . i2p . router . web .  update handler . nonce" nonce  +  "" )  ;   string uri = get requesturi (  )  ;  buf . append ( " < form action = \"" )  . append ( uri )  . append ( "\" method = \"post\" > \n" )  ;  buf . append ( " < input type = \"hidden\" name = \"update nonce\" value = \"" )  . append ( nonce )  . append ( "\"  > \n" )  ;  if  ( avail )   {  buf . append ( " < button type = \"submit\" class = \"download\" name = \"update action\" value = \"signed\"  > " )  . append (    t ( " download  { 0 }   update" get update version (  )  )  )  . append ( " <  / button >  < br > \n" )  ;   }  if  ( devsu3 avail )   {  buf . append ( " < button type = \"submit\" class = \"download\" name = \"update action\" value = \" devsu3\"  > " )  . append (    t ( " download  signed < br >  development  update < br >  { 0 } " get devsu3 update version (  )  )  )  . append ( " <  / button >  < br > \n" )  ;   }  if  ( unsigned avail )   {  buf . append ( " < button type = \"submit\" class = \"download\" name = \"update action\" value = \" unsigned\"  > " )  . append (    t ( " download  unsigned < br >  update  { 0 } " get unsigned update version (  )  )  )  . append ( " <  / button >  < br > \n" )  ;   }  buf . append ( " <  / form > \n" )  ;   }  return buf . to string (  )  ;   }  
public int   (  )  {  return rating ;   }  
@ test public void   (  )  throws  exception  {  final  file output dict =  file . create temp file ( " create sequence dictionary test . " " . dict" )  ;  output dict . delete (  )  ;  output dict . delete on exit (  )  ;  final  string[] argv =  { "refe
private void   (  session id id int status )  {   session status message msg = new  session status message (  )  ;  msg . set session id ( id )  ;  msg . set status ( status )  ;  try  {     runner . do send ( msg )  ;   }  catch  (  i2cp message exception ime )   {  if  (    log . should log (  log . warn )  )     log . warn ( " error writing out the session status message" ime )  ;   }   }  
@ test public void   (  )  throws  exception  {   next observer <  integer >  no = new  next observer <  integer >  (  )  ;  no . set waiting (  )  ;  no . on next (  notification . create on next ( 1 )  )  ;  no . set waiting (  )  ;  no . on next (  not
public void   (  node node )  {  set root node ( node )  ;   }  
@ test public void   (  )  {   test helper . check utility class (  observable blocking subscribe . class )  ;   }  
@ test public void   (  )  {  final int[] call =  { 0 }  ;   observable . just ( 1 )  . do after terminate ( new  action (  )  {  @ override public void run (  )  throws  exception  {  call[0] +  +  ;   }   }   )  . test (  )  . assert result ( 1 )  ;  as
@ check return value @ scheduler support (  scheduler support . none )  public final  single < t >    (  action on finally )  {   object helper . require non null ( on finally "on finally is null" )  ;  return  rx java plugins . on assembly ( new  single 
@ test public void   (  )  {   observable . range ( 1 5 )  . switch map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . jus
  (  observer <  ?  super r >  downstream  function <  ?  super t  ?  extends  maybe source <  ?  extends r >  >  mapper int prefetch  error mode error mode )  {  this . downstream = downstream ;  this . mapper = mapper ;  this . error mode = error mode ;  this . errors = new  atomic throwable (  )  ;  this . inner = new  concat map maybe observer < r >  ( this )  ;  this . queue = new  spsc linked array queue < t >  ( prefetch )  ;   }  
private void   ( http request http req )  {   string uri = http req . geturi (  )  ;   debug . message ( "http get request recieved  =  "  +  uri )  ;  if  ( uri  =  =  null )   {  http req . return bad request (  )  ;  return ;   }   device emb dev ;   service emb service ;  byte file byte[] = new byte[0] ;   string content type = null ;   string content language = null ;  if  ( is descriptionuri ( uri )   =  =  true )   {   string local addr = http req . get local address (  )  ;  if  (  ( local addr  =  =  null )  ||  ( local addr . length (  )   <  =  0 )  )  local addr =  host interface . get interface (  )  ;  content type = xml . default   content   type ;  content language = xml . default   content   language ;  file byte = get description data ( local addr )  ;   }  else if  (  ( emb dev = get device by descriptionuri ( uri )  )   !  =  null )   {   string local addr = http req . get local address (  )  ;  content type = xml . default   content   type ;  content language = xml . default   content   language ;  file byte = emb dev . get description data ( local addr )  ;   }  else if  (  ( emb service = get service byscpdurl ( uri )  )   !  =  null )   {  content type = xml . default   content   type ;  content language = xml . default   content   language ;  file byte = emb service . getscpd data (  )  ;   }  else if  ( is icon bytesuri ( uri )   =  =  true )   {   icon dev icon = get icon byuri ( uri )  ;  if  ( dev icon  !  =  null )   {  content type = dev icon . get mime type (  )  ;  file byte = dev icon . get bytes (  )  ;   }   }  else  {  http req . return bad request (  )  ;  return ;   }  http response http res = new http response (  )  ;  http res . set status code ( http status . ok )  ;  if  ( content type  !  =  null )   {  http res . set content type ( content type )  ;   }  if  ( content language  !  =  null )   {  http res . set content language ( content language )  ;   }  http res . set content ( file byte )  ;  http req . post ( http res )  ;   }  
  ( boolean x )  {  answer = x ;   }  
public int   (  )  {  int found = 0 ;  for  ( int i = 0 ;  i  <     fragments . length ;  i +  +  )  if  (    fragments[i]  !  =  null )  found +  +  ;  return found ;   }  
  ( int field int size )  {  if  ( size  <  3 )   {  throw new  illegal argument exception (  )  ;   }  m field = field ;  m size = size ;   }  
@ test public void   (  )  {   observable <  integer >  source = new  observable <  integer >  (  )  {  @ override public void subscribe actual (   observer <  ?  super  integer >  s )  {  s . on subscribe (  disposables . empty (  )  )  ;  s . on next ( 
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . timeout ( 1  time unit . days  flowable . just ( 1 )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe maybe ( new  function <  maybe <  object >   maybe source <  object >  >  (  )  {  @ override public  maybe source <  object >  apply (   maybe <  object >  v )  throws  exception  {  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ bandwidth limits message" )  ;  buf . append ( "\n\t in: " )  . append ( data[0] )  ;  buf . append ( "\n\t out: " )  . append ( data[1] )  ;  buf . 
@ override public void   (  )  {  for  (  ;   ;   )   {   cached worker pool curr = pool . get (  )  ;  if  ( curr  =  =  none )   {  return ;   }  if  ( pool . compare and set ( curr none )  )   {  curr . shutdown (  )  ;  return ;   }   }   }  
public void   ( float v )  throws io exception  {  delegate . write float ( v )  ;   }  
@ override public int   (  session data data )  {  return 1 ;   }  
public boolean   (  conversation conversation )  {  return false ;   }  
public void   (  string sn  string nickname )  {  try  {   transport buddy buddy = get buddy manager (  )  . get buddy ( get transport (  )  . convertid tojid ( sn )  )  ;  buddy . set nickname ( nickname )  ;  try  {  get transport (  )  . add or update roster item ( getjid (  )  buddy . get name (  )  buddy . get nickname (  )  buddy . get groups (  )  )  ;   }  catch  (   user not found exception e )   {   }   }  catch  (   not found exception e )   {   }   }  
public static  body part   (  string mime type  string text )  throws  messaging exception  {  final  text body text body = new  text body ( text )  ;  final  mime body part text part = new  mime body part ( text body )  ;  text part . set header (  mime header . header   content   type mime type )  ;  return text part ;   }  
public static void   (  string args[] )  {   string con options = "i2cp . tcp . host = localhost i2cp . tcp . port = 7654 tunnels . inbound depth = 0" ;  if  ( args . length  >  0 )   {  con options = "" ;  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )  con options = con options  +  " "  +  args[i] ;   }  try  {   test util . startup bridge ( 6000 )  ;  run test ( "localhost" 6000 con options )  ;   }  catch  (   throwable t )   {     log . error ( " error running test" t )  ;   }  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   system . exit ( 0 )  ;   }  
@ before @ after public void   (  )  {   rx java plugins . reset (  )  ;   }  
@ override public int   (  )  {  return this . position info . y qseq coord ;   }  
@ override public void   (  string column label long x )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public  object   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ override public boolean   (  type container type )  {   class <  ?  >  erased type = get collection type ( container type )  ;  final boolean has collector = collectors . contains key ( erased type )  ;  return  ( has collector || has default implementa
@ override public void   (  )  {  try  {  while  ( running . get (  )  &&  ! task . is disposed (  )  )   {  o . on next ( count . increment and get (  )  )  ;  time has passed . count down (  )  ;   }  o . on complete (  )  ;   }  catch  (   throwable e 
@ suppress warnings ( "unused" )  private void   (  array list <  string >  policies  string policies to add  string preference name )  {   policy . add policy string to list ( policies to add policies )  ;  if  ( policies . size (  )   >  0 )   {   prefe
@ override public void   (  )  {  done = true ;  drain (  )  ;   }  
private  object   (  element element )  {  return new  put on speaker command (  )  ;   }  
@ before public void   (  )  throws  exception  {  db =  jdbi . create ( db rule . get connection factory (  )  )  ;  db . set transaction handler ( new  serializable transaction runner (  )  )  ;   }  
public   (  mail cache mail cache )  {  super ( mail cache )  ;   }  
public static  mime type   (  string variant )  {  final  matcher matcher = variant   regex . matcher ( variant )  ;   mime type media type = null ;  if  ( matcher . matches (  )  )   {  if  ( variant . to lower case (  )  . contains ( "xml" )  )   {  media type =  mime type . application   xml ;   }  else if  ( variant . to lower case (  )  . contains ( "json" )  )   {  media type =  mime type . application   json ;   }   }  return media type ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . concat map maybe delay error ( new  function <  integer  maybe source <  ?  extends  object >  >  (  )  {  @ override public  maybe source <  ?  extends  object >  apply (   integer v )  throws  e
  (  maybe observer <  ?  super t >  actual )  {  this . actual = actual ;  this . set = new  composite disposable (  )  ;   }  
@ test public void   (  )  throws io exception  {   path base dir = create test dirs ( 0 true )  ;   file tile metrics file =  tile metrics util . render tile metrics file from basecalling directory ( base dir . to file (  )  0 false )  ;   assert . asser
public static  integer   (  date date )  {  return  integer . value of ( date . get seconds (  )  )  ;   }  
private void   (  whisper group whisper group )  {  synchronized  ( conference manager )   {  synchronized  ( whisper groups )   {  whisper group . add call ( this )  ;  double attenuation = whisper group . get attenuation (  )  ;  if  ( this . whisper group  !  =  null && this . whisper group . get attenuation (  )   =  =  0 )   {  attenuation = 0 ;   }  synchronized  ( mix manager )   {  if  ( whisper group . has common mix (  )   =  =  true &&  ( cp . get input treatment (  )   =  =  null || cp . is recorder (  )   =  =  true )  )   {  mix manager . add mix ( whisper group attenuation )  ;   }  else  {  mix manager . remove mix ( member receiver )  ;   }   }  if  ( whisper group . get attenuation (  )   =  =  0 )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " call "  +  cp  +  " entered 0 attenuation " +  "start whispering now ! " )  ;   }  set whispering ( whisper group )  ;  if  (  logger . log level  >  =   logger . log   moreinfo )   {  synchronized  ( mix manager )   {  mix manager . show descriptors (  )  ;   }   }  return ;   }  if  (  logger . log level  >  =   logger . log   moreinfo )   {  synchronized  ( mix manager )   {  mix manager . show descriptors (  )  ;   }   }   }   }   }  
public static x509 certificate[]   (  )  throws  exception  {  int length = 4 ;  final  key pair generator key pair generator =  key pair generator . get instance ( "rsa" )  ;  key pair generator . initialize ( 512 )  ;   key pair subject key pair = key pair generator . generate key pair (  )  ;   key pair issuer key pair = subject key pair ;  final x509 certificate[] result = new x509 certificate[length] ;  for  ( int i = length  -  1 ;  i  >  =  0 ;  i -  -  )   {  boolean is valid =  ( i  !  =  length  -  1 )  ;  result[i] = generate test certificate ( is valid issuer key pair subject key pair i )  ;  issuer key pair = subject key pair ;  subject key pair = key pair generator . generate key pair (  )  ;   }  return result ;   }  
 < t r >  function < t r >    ( r dummy2 )  {  return new  function < t r >  (  )  {  @ override public r apply (  t t1 )  {  throw new  runtime exception ( " forced failure" )  ;   }   }   ;   }  
  (  observer <  ?  super t >  actual )  {  this . actual = actual ;  this . main disposable = new  atomic reference <  disposable >  (  )  ;  this . other observer = new  other observer ( this )  ;  this . error = new  atomic throwable (  )  ;   }  
@ override public long   (  )  {  return 1 ;   }  
public void   (  )  {  for  (   imap response r : m responses to destroy )   {  r . destroy (  )  ;   }  m responses to destroy . clear (  )  ;   }  
public void   (  )  {     kad . clear (  )  ;     node map . clear (  )  ;   }  
@ test ( data provider = "bad bases" expected exceptions =  illegal argument exception . class )  public void   ( final char wrong base )  {   transition . transition of ( wrong base 'a' )  ;   }  
public boolean   (  string shell command )  {  return execute ( shell command consume   output wait   for   exit   status )  ;   }  
@ override public boolean   (  )  {  return disposed ;   }  
private static  element   (  element element  string url )  {  final  iterator <  element >  url bookmarks = element . element iterator ( "url" )  ;  while  ( url bookmarks . has next (  )  )   {   element url element = url bookmarks . next (  )  ;   string url value = url element . attribute value ( "url" )  ;  if  ( url value . equals ignore case ( url )  )   {  return url element ;   }   }  return null ;   }  
public void   (  string message  string recipient )  {  if  ( message  =  =  null || message . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'message' cannot be null or an empty  string . " )  ;   }  if  ( recipient  =  =  null || recipient . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'recipient' cannot be null or an empty  string . " )  ;   }   task engine . get instance (  )  . submit ( new  sms task ( session pool message recipient )  )  ;   }  
public  string   (  )  {  return  integer . to string (  math . round (    context . bandwidth limiter (  )  . get outboundk bytes per second (  )  * 1 . 024f )  )  ;   }  
@ override public void   (  print writer pw )  {  super . print stack trace ( pw )  ;  if  ( nested throwable  !  =  null )   {  nested throwable . print stack trace ( pw )  ;   }   }  
public static long[]   (  http servlet request request  string name long default num )  {   string[] param values = request . get parameter values ( name )  ;  if  ( param values  =  =  null || param values . length  =  =  0 )   {  return new long[0] ;   }  long[] values = new long[param values . length] ;  for  ( int i = 0 ;  i  <  param values . length ;  i +  +  )   {  try  {  values[i] =  long . parse long ( param values[i] )  ;   }  catch  (   exception e )   {  values[i] = default num ;   }   }  return values ;   }  
public static boolean   (  atomic reference <  disposable >  field  disposable d )  {  if  (  ! field . compare and set ( null d )  )   {  if  ( field . get (  )   =  =  disposed )   {  d . dispose (  )  ;   }  return false ;   }  return true ;   }  
private void   (  conference member m1  conference member m2  mix descriptor md )  {  if  ( m1 . get whisper group (  )   =  =  null )   {  return ;   }  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  m1  +  " adjust private mix descriptor: " +  " md " +  md +  " pm for " +  m2 )  ;   }  if  ( m2 . get whisper group (  )   =  =  null || m2 . get whisper group (  )  . is member ( m1 )   =  =  false )   {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  m1  +  " not member of " +  m2 . get whisper group (  )  +  "  ev is 0" )  ;   }  mix manager . set attenuation ( md 0 )  ;  return ;   }  double attenuation ;  if  ( m1 . get whisper group (  )   =  =  m2 . get whisper group (  )  )   {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  m1  +  " full volume" )  ;   }  attenuation = 1 . 0 ;   }  else  {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " call "  +  m1  +  " attenuating to " +  m1 . get whisper group (  )  . get attenuation (  )  )  ;   }  attenuation = m1 . get whisper group (  )  . get attenuation (  )  ;   }  mix manager . set attenuation ( md attenuation )  ;  if  ( m1 . is conference muted (  )  )   {  mix manager . set muted ( md true )  ;   }  else  {  mix manager . set muted ( md false )  ;  if  ( m1 . is conference silenced (  )  )   {   member receiver member receiver =  (  member receiver ) md . get mix data source (  )  ;  if  ( member receiver . get whisper group (  )   =  =  conference whisper group )   {   logger . println ( " call "  +  cp  +  " mute pm for member in main conf" )  ;  mix manager . set muted ( md true )  ;   }   }   }   }  
private void   (  exception e )  throws  remote exception  {  log . error ( " error occured while consuming  crowd rest service" e )  ;  throw new  remote exception ( e . get message (  )  )  ;   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps1 =  publish subject . create (  )  ;  final  publish subject <  integer >  ps2 =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  ( 
@ suppress warnings ( "unchecked" )  @ override public  publisher <  long >    ( long elements )  {  return  flowable . concat array eager (  flowable . from iterable ( iterate ( elements  /  2 )  )   flowable . from iterable ( iterate ( elements  -  elem
@ override public void   (  )  {  set ( cancelled )  ;  value = null ;   }  
@ override public void   (  disposable d )  {  assert false ( d . is disposed (  )  )  ;  d . dispose (  )  ;  d . dispose (  )  ;  assert true ( d . is disposed (  )  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   test observer <  integer >  to = pp1 . single (  - 99 )  . amb with ( pp
private void   (  )  {     last send time =    created ;     last receive time =    created ;     last rate updated =    created ;     cur read block = new byte[block   size] ;     prev read block = new byte[block   size] ;     transport . establishing ( this )  ;   }  
@ override public int   (  session data data )  {  return 0 ;   }  
void   ( int snac family  string host  byte block cookie )  {   log . debug ( " connection to service "  +  snac family  +  " on host " +  host )  ;   service connection conn ;  if  ( snac family  =  =   mail check cmd . family   mailcheck )   {  conn = new  email connection ( new  conn descriptor ( host  jive globals . get int property ( property prefix  +  " . connectport" 5190 )  )  this cookie snac family )  ;   }  else  {  conn = new  service connection ( new  conn descriptor ( host  jive globals . get int property ( property prefix  +  " . connectport" 5190 )  )  this cookie snac family )  ;   }  conn . connect (  )  ;   }  
@ override public void   (  throwable ex )  {  if  (  exception helper . add throwable ( error ex )  )   {  drain (  )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
boolean   (  )  {  return m transport  !  =  null && m transport . is open (  )  ;   }  
@ override public void   (  integer value )  {  assert false ( qd . is empty (  )  )  ;  qd . clear (  )  ;  assert true ( qd . is empty (  )  )  ;  qd . cancel (  )  ;   }  
@ override public void   (  string name )  {  cache . set name ( name )  ;   }  
public   (  flowable < t >  source  function <  ?  super t  ?  extends  single source <  ?  extends r >  >  mapper boolean delay errors )  {  this . source = source ;  this . mapper = mapper ;  this . delay errors = delay errors ;   }  
public  list <  security audit event >    (  string username  integer skip events  integer num events  date start time  date end time )  throws  audit write only exception  {  if  ( provider . is write only (  )  )   {  throw new  audit write only exception (  )  ;   }  return provider . get events ( username skip events num events start time end time )  ;   }  
public static  string   ( final  node parent node final  string child name final boolean trim )  throws  rrd exception  {  final  node list children = parent node . get child nodes (  )  ;  for  ( int i = 0 ;  i  <  children . get length (  )  ;  i +  +  )   {  final  node child = children . item ( i )  ;  if  ( child . get node name (  )  . equals ( child name )  )   {  return get value ( child trim )  ;   }   }  throw new  rrd exception ( "xml  error  no such child: "  +  child name )  ;   }  
public void   (  hash client  tunnel pool settings settings )  {  set settings (    client inbound pools client settings )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  handle . create query ( "select id  foo from thing where  ( foo  bar )  in  (  < keys >  ) " )  . bind bean list ( "keys"  collections . empty list (  )  
private static  string   (  string[] array )  {   string builder buf = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  array . length ;  i +  +  )   {  buf . append ( array[i] )  ;  if  ( i  !  =  array . length  -  1 )   {  buf . append ( ' ' )  ;   }   }  return buf . to string (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  maybe subject . create (  )  )  ;   }  
@ override public void   ( int timeout )  throws  socket exception  {  i2p socket options opts =    socket . get options (  )  ;  if  ( opts  =  =  null )  throw new  socket exception ( " no options" )  ;  if  ( timeout  =  =  0 )  timeout =  - 1 ;  opts 
private   (  map <  string be value >  m byte[] my   id byte[] infohash  meta info metainfo i2p snark util util )  throws io exception  {  be value reason = m . get ( "failure reason" )  ;  if  ( reason  !  =  null )   {  failure   reason = reason . get string (  )  ;  interval =  - 1 ;  peers = null ;   }  else  {  failure   reason = null ;  be value be interval = m . get ( "interval" )  ;  if  ( be interval  =  =  null )  throw new  invalidb encoding exception ( " no interval given" )  ;  else interval = be interval . get int (  )  ;  be value be peers = m . get ( "peers" )  ;  if  ( be peers  =  =  null )   {  peers =  collections . empty set (  )  ;   }  else  {   set <  peer >  p ;  try  {  p = get peers ( be peers . get bytes (  )  my   id infohash metainfo util )  ;   }  catch  (   invalidb encoding exception ibe )   {  p = get peers ( be peers . get list (  )  my   id infohash metainfo util )  ;   }  peers = p ;   }  be value bev = m . get ( "complete" )  ;  if  ( bev  !  =  null )  try  {  complete = bev . get int (  )  ;  if  ( complete  <  0 )  complete = 0 ;   }  catch  (   invalidb encoding exception ibe )   {   }  bev = m . get ( "incomplete" )  ;  if  ( bev  !  =  null )  try  {  incomplete = bev . get int (  )  ;  if  ( incomplete  <  0 )  incomplete = 0 ;   }  catch  (   invalidb encoding exception ibe )   {   }   }   }  
 remote host id   (  )  {  return    remote host id ;   }  
@ override public void   (  )  {  disposed = true ;  scheduler . schedule direct ( this )  ;   }  
@ test public void   (  )  {   flowable <  string >  o =  flowable . from iterable (  arrays . as list ( "one" "two" "three" )  )  ;   list <  string >  actual = o . to list (  )  . blocking get (  )  ;   assert . assert equals (  arrays . as list ( "one"
@ override public void   (  )  {  qd . clear (  )  ;   }  
private  string   ( final  object[] objs )  {  final  string buffer sb = new  string buffer (  )  ;  for  ( int i = 0 ;  i  <  objs . length ;  i +  +  )   {  sb . append ( objs[i] )  ;  if  ( i  !  =   ( objs . length  -  1 )  )   {  sb . append ( " " )  ;   }   }  return sb . to string (  )  ;   }  
private void   (  rate r )  {  for  (   summary listener lsnr :    listeners )   {  if  ( lsnr . get rate (  )  . equals ( r )  )   {     listeners . remove ( lsnr )  ;  lsnr . stop listening (  )  ;  return ;   }   }   }  
public   (  key store trust trust )  {  super (  )  ;  this . trust store = trust trust ;   }  
private void   (  configured ratelimit configured rate limit  calendar cal  cached rate limit cached limit )  {   list <  http method >  http methods = configured rate limit . get http methods (  )  ;  if  ( http methods . is empty (  )  )   {  http methods =  collections . singleton list (  http method . all )  ;   }  for  (   http method method : http methods )   {  final  rate limit limit = new  rate limit (  )  ;  limit . set value ( configured rate limit . get value (  )  )  ;  limit . set unit ( configured rate limit . get unit (  )  )  ;  limit . set verb ( method )  ;  long earliest expiration date =  system . current time millis (  )  ;  int remaining requests = configured rate limit . get value (  )  ;  if  ( cached limit  !  =  null )   {  earliest expiration date = cached limit . get next expiration time (  )  ;  remaining requests = cached limit . max amount (  )   -  cached limit . amount (  )  ;   }  cal . set time in millis ( earliest expiration date )  ;  limit . set remaining ( remaining requests )  ;  limit . set next available ( datatype   factory . newxml gregorian calendar (  (  gregorian calendar ) cal )  )  ;  final  string config id = configured rate limit . get id (  )  ;   resource rate limits rate limits = live rate limit map . get ( config id )  ;  if  ( rate limits  =  =  null )   {  rate limits = new  resource rate limits (  )  ;  rate limits . set regex ( configured rate limit . get uri regex (  )  )  ;  rate limits . set uri ( configured rate limit . get uri (  )  )  ;  live rate limit map . put ( config id rate limits )  ;   }  rate limits . get limit (  )  . add ( limit )  ;   }   }  
public   (  chatbot session session  workgroup wg )  {  super (  )  ;  this . userjid = session . get userjid (  )  ;  this . userid = userjid . to barejid (  )  ;  this . anonymous user = false ;  this . workgroup = wg ;  this . communication method = session . get chatbot (  )  ;  set notify ( true )  ;  meta data . put all ( session . get attributes (  )  )  ;  if  (  ! meta data . contains key ( "userid" )  )   {  meta data . put ( "userid"  arrays . as list ( userjid . to string (  )  )  )  ;   }   }  
public static void   (  string msg  keyed stack lock test thread .  .  .  threads )  throws  interrupted exception  {  for  (   keyed stack lock test thread t : threads )   {  if  (  ! t . started (  )  )   {  t . exec (  )  ;   }   }  int iterations = 0 ;  while  (  ! threads finished ( threads )  &&  +  + iterations  <  50 )   {   thread . sleep ( 10 )  ;   }  for  (   keyed stack lock test thread t : threads )   {  assert true ( msg t . passed (  )  )  ;   }   }  
public ssdp search socket   ( int n )  {  return  ( ssdp search socket ) get ( n )  ;   }  
public   (  )  {  super ( " rayo: xep 0327  -   offhook" )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  final  group element g =  math utils . get random group element (  )  ;  final  group element h = g . top3 (  )  ;   assert . assert that ( h  is equal . equal to ( g )  )  ;   a
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  single subject <  integer >  cs =  single subject . create (  )  ;   test observer <  integ
@ override protected void   (  observer <  ?  super t >  observer )  {   collection <  ?  super k >  collection ;  try  {  collection =  object helper . require non null ( collection supplier . call (  )  " the collection supplier returned a null collecti
@ test public void   (  )  {  final  publish subject <  object >  subject =  publish subject . create (  )  ;  final  disposable disposable =  observable . just ( " leak" )  . repeat when ( new  function <  observable <  object >   observable source <  ob
@ benchmark public  object   (  blackhole bh )  {  return flowable convert . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( parent d )  ;   }  
public static  set < x509 certificate >    (  collection < x509 certificate >  certificates )  {  if  ( certificates  =  =  null )   {  return  collections . empty set (  )  ;   }  return filter valid ( certificates . to array ( new x509 certificate[certificates . size (  ) ] )  )  ;   }  
private static void   ( final  file db snp file final sam sequence dictionary sequence dictionary final  map <  db snp bit set util  set <  variant type >  >  bit sets to variant types final  interval list intervals final  optional <  log >  log )  {  final  optional <  progress logger >  progress = log . map ( l  -  >  new  progress logger ( l  ( int ) 1e5 " read" "variants" )  )  ;  final vcf file reader variant reader = new vcf file reader ( db snp file intervals  !  =  null )  ;  final  iterator <  variant context >  variant iterator ;  if  ( intervals  !  =  null )   {  variant iterator = new  by interval list variant context iterator ( variant reader intervals )  ;   }  else  {  variant iterator = variant reader . iterator (  )  ;   }  while  ( variant iterator . has next (  )  )   {  final  variant context kv = variant iterator . next (  )  ;  for  (  final  map .  entry <  db snp bit set util  set <  variant type >  >  tuple : bit sets to variant types . entry set (  )  )   {  final  db snp bit set util bitset = tuple . get key (  )  ;  final  set <  variant type >  variants to match = tuple . get value (  )  ;   bit set bits = bitset . sequence to bit set . get ( kv . get contig (  )  )  ;  if  ( bits  =  =  null )   {  final int n bits ;  if  ( sequence dictionary  =  =  null )  n bits = kv . get end (  )   +  1 ;  else n bits = sequence dictionary . get sequence ( kv . get contig (  )  )  . get sequence length (  )   +  1 ;  bits = new  bit set ( n bits )  ;  bitset . sequence to bit set . put ( kv . get contig (  )  bits )  ;   }  if  ( variants to match . is empty (  )  ||  ( kv . issnp (  )  && variants to match . contains (  variant type . snp )  )  ||  ( kv . is indel (  )  && variants to match . contains (  variant type . insertion )  ) ||  ( kv . is indel (  )  && variants to match . contains (  variant type . deletion )  )  )   {  for  ( int i = kv . get start (  )  ;  i  <  =  kv . get end (  )  ;  i +  +  )  bits . set ( i true )  ;   }   }  progress . map ( p  -  >  p . record ( kv . get contig (  )  kv . get start (  )  )  )  ;   }   closer util . close ( variant reader )  ;   }  
private boolean   ( final sam file header in header final  sort order sort order final boolean sanitizing )  {  return  ( in header . get sort order (  )   =  =  sort order )  ||  ( sort order  =  =   sort order . queryname && sanitizing )  ;   }  
@ test public void   (  )  {   observable . just ( 1 2 3 )  . single or error (  )  . test (  )  . assert no values (  )  . assert error (  illegal argument exception . class )  ;   }  
@ override public boolean   (  string role to broadcast )  {  return "none" . equals ( role to broadcast )  || roles to broadcast presence . contains ( role to broadcast )  ;   }  
public int   (  )  {  return failed to recover ;   }  
@ test public void   (  )  {   timed <  integer >  timed = new  timed <  integer >  ( 1 5  time unit . seconds )  ;  assert equals ( 1 timed . value (  )  . int value (  )  )  ;  assert equals ( 5 timed . time (  )  )  ;  assert equals ( 5000 timed . time
@ suppress warnings ( "unchecked" )  public static  < t >  comparator < t >    (  )  {  return  (  comparator < t >  ) natural   comparator ;   }  
@ test @ ignore ( " observers can't throw" )  public void   (  )  {  try  {  new  safe subscriber <  string >  ( observer   onerror   notimplemented (  )  )  . on error ( new  safe subscriber test exception ( "error ! " )  )  ;  fail ( "expects exception 
public  string   (  )  {  if  (  security . get property ( security   negative   ttl )   !  =  null )   {  if  (  system . get property ( system   negative   ttl )   !  =  null )   {  return both ;   }  return security ;   }  if  (  system . get property ( system   negative   ttl )   !  =  null )   {  return system ;   }  return default ;   }  
public  color   (  )  {  return background color ;   }  
public  statistic   (  string stat key )  {  return statistics . get ( stat key )  ;   }  
public  string   (  )  {  return get header value ( http . content   type )  ;   }  
private static int   ( byte[] source int src offset byte[] destination int dest offset )  {  byte decode0 = decodabet[source[src offset +  + ]] ;  byte decode1 = decodabet[source[src offset +  + ]] ;  if  ( decode0  <  0 || decode1  <  0 )  return  - 1 ;  if  ( source[src offset]  =  =  equals   sign )   {  if  ( source[src offset  +  1]  !  =  equals   sign )  return  - 1 ;  if  (  ( decode1 & 0x0f )   !  =  0 )  return  - 1 ;  int out buff =  ( decode0  <  <  18 )  |  ( decode1  <  <  12 )  ;  destination[dest offset] =  ( byte )  ( out buff  >  >  16 )  ;  return 1 ;   }  else if  ( source[src offset  +  1]  =  =  equals   sign )   {  byte decode2 = decodabet[source[src offset]] ;  if  ( decode2  <  0 )  return  - 1 ;  if  (  ( decode2 & 0x03 )   !  =  0 )  return  - 1 ;  int out buff =  ( decode0  <  <  18 )  |  ( decode1  <  <  12 )  |  ( decode2  <  <  6 )  ;  destination[dest offset +  + ] =  ( byte )  ( out buff  >  >  16 )  ;  destination[dest offset] =  ( byte )  ( out buff  >  >  8 )  ;  return 2 ;   }  else  {  byte decode2 = decodabet[source[src offset +  + ]] ;  byte decode3 = decodabet[source[src offset]] ;  if  ( decode2  <  0 || decode3  <  0 )  return  - 1 ;  int out buff =  ( decode0  <  <  18 )  |  ( decode1  <  <  12 )  |  ( decode2  <  <  6 ) | decode3 ;  destination[dest offset +  + ] =  ( byte )  ( out buff  >  >  16 )  ;  destination[dest offset +  + ] =  ( byte )  ( out buff  >  >  8 )  ;  destination[dest offset] =  ( byte )  ( out buff )  ;  return 3 ;   }   }  
public void   ( boolean sent enabled )  {  this . sent enabled = sent enabled ;   }  
public void   (  string stat key  statistic definition )  {  statistics . put ( stat key definition )  ;   }  
@ override public void   ( int value )  {  configured rate limit . set value ( value )  ;   }  
public static void   ( long n  meter .  .  .  meters )  {  for  (   meter meter : meters )   {  meter . mark ( n )  ;   }   }  
public int   (  )  {  return 3 ;   }  
public int   (  )  {  return tcp port ;   }  
@ test ( expected exceptions =  picard exception . class )  public void   (  )  throws  exception  {  final  file output dict =  file . create temp file ( " create sequence dictionary test . " " . dict" )  ;  output dict . delete on exit (  )  ;  final  s
@ override public void   (  account account )  {   intent intent =  account security . action update security intent ( m context account . m id true )  ;   string account name = account . get display name (  )  ;   string ticker = m context . get string (
@ test public void   (  )  {  assert equals (  observable . empty (  )   observable . empty (  )  )  ;   }  
protected void   (  )  {     running = true ;  int cur delay = 1000 ;  final  string port mapper service =  ( this instanceof ssl client listener runner )   ?   port mapper . svc   i2cp   ssl :  port mapper . svc   i2cp ;  while  (    running )   {  try  {     socket = get server socket (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " server socket created  before accept: "  +     socket )  ;  if  (    port  >  0 )   {     context . port mapper (  )  . register ( port mapper service    socket . get inet address (  )  . get host address (  )     port )  ;   }  cur delay = 1000 ;     listening = true ;  while  (    running )   {  try  {   socket socket =    socket . accept (  )  ;  if  ( validate ( socket )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " connection received" )  ;  socket . set keep alive ( true )  ;  run connection ( socket )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " refused connection from "  +  socket . get inet address (  )  )  ;  try  {  socket . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  catch  (  io exception ioe )   {  if  ( is alive (  )  )     log . error ( " server error accepting" ioe )  ;   }  catch  (   throwable t )   {  if  ( is alive (  )  )     log . error ( " fatal error running client listener  -  killing the thread ! " t )  ;     listening = false ;  return ;   }   }   }  catch  (  io exception ioe )   {  if  ( is alive (  )  )     log . error ( " error listening on port "  +     port ioe )  ;   }  finally  {  if  (    port  >  0 )   {     context . port mapper (  )  . unregister ( port mapper service )  ;   }   }     listening = false ;  if  (    socket  !  =  null )   {  try  {     socket . close (  )  ;   }  catch  (  io exception ioe )   {   }     socket = null ;   }  if  (  ! is alive (  )  )  break ;  if  ( cur delay  <  60 * 1000 )     log . error ( " error listening  waiting "  +   ( cur delay  /  1000 )   +  "s before we try again" )  ;  else    log . log (  log . crit "i2cp error listening to port "  +     port  +  "  -  is another i2p instance running ?   resolve conflicts and restart" )  ;  try  {   thread . sleep ( cur delay )  ;   }  catch  (   interrupted exception ie )   {   }  cur delay =  math . min ( cur delay * 3 60 * 1000 )  ;   }  if  ( is alive (  )  )     log . error ( "canceling i2cp listen" new  exception ( "i2cp  listen cancelled !  !  ! " )  )  ;     running = false ;   }  
@ test public void   (  )  {   test helper . check double on subscribe flowable ( new  function <  flowable <  object >   flowable <  flowable <  object >  >  >  (  )  {  @ override public  flowable <  flowable <  object >  >  apply (   flowable <  object
public  result   (  )  {  return result ;   }  
@ override public url   (  string path )  throws  malformedurl exception  {  return context . get resource ( path )  ;   }  
public   (  observable < t >  source  completable source other )  {  super ( source )  ;  this . other = other ;   }  
  (  time zone time zone boolean daylight int style  locale locale )  {  m time zone = time zone ;  if  ( daylight )   {  style| = 0x80000000 ;   }  m style = style ;  m locale = locale ;   }  
private static  string   (  )  {  return  system . get property ( i2p client . prop   tcp   host "127 . 0 . 0 . 1" )  ;   }  
@ override public void   (  string name  object value )  throws sax not recognized exception  sax not supported exception  {  for  ( int i = 0 ;  i  <  lexical   handler   names . length ;  i +  +  )   {  if  ( lexical   handler   names[i] . equals ( name
@ test public void   (  )  {   observable <  string >  o1 =  observable . just ( "one" "two" )  ;   observable <  string >  o2 =  observable . just ( "three" "four" )  ;   observable <  string >  o3 =  observable . just ( "five" "six" )  ;  @ suppress war
void   ( io exception ioe )  {  synchronized  (    data lock )   {  if  (    stream error  =  =  null )     stream error = ioe ;     locally closed = true ;     data lock . notify all (  )  ;   }   }  
public long   (  )  {  return accumulated response size ;   }  
@ override public void   (  string name )  throws sax exception  {  try  {  write entity ref ( name )  ;   }  catch  (  io exception e )   {  handle exception ( e )  ;   }  if  ( lexical handler  !  =  null )   {  lexical handler . start entity ( name )  
public void   (  )  {     running = false ;  if  (    socket  !  =  null )  try  {     socket . close (  )  ;     socket = null ;   }  catch  (  io exception ioe )   {   }   }  
public final boolean   (  )  {  return get and set ( cancelled )   !  =  cancelled ;   }  
public static  string   (  string input )  {  final  string[] xss =  { " < " " > " "\"" "'" "%" " ; " " ) " " ( " "&" " + " " - " }  ;  for  ( int i = 0 ;  i  <  xss . length ;  i +  +  )   {  input = input . replace ( xss[i] "" )  ;   }  return input ;   }  
public static  rate limiting handler   (  rate limiting configuration configuration object  event service event service  distributed datastore datastore )  {   rate limit cache rate limit cache = new  managed rate limit cache ( datastore )  ;   rate limiting service rate limiting service =  rate limiting service factory . create rate limiting service ( rate limit cache configuration object )  ;   optional <  pattern >  describe limits uri regex = configuration object . get request endpoint (  )   !  =  null  ?   optional . of (  pattern . compile ( configuration object . get request endpoint (  )  . get uri regex (  )  )  )  :  optional . empty (  )  ;  boolean include absolute limits = configuration object . get request endpoint (  )   !  =  null && configuration object . get request endpoint (  )  . is include absolute limits (  )  ;  return new  rate limiting handler ( new  rate limiting service helper ( rate limiting service new  active limits writer (  )  new  combined limits writer (  )  )  event service include absolute limits describe limits uri regex configuration object . is over limit429 response code (  )  configuration object . get datastore warn limit (  )  . int value (  )  )  ;   }  
public   ( long message id  object data[] int size )  {  if  ( size  >  max   fragments )  throw new  illegal argument exception (  )  ;     bitfield message id = message id ;  int ack count = 0 ;  int highest received =  - 1 ;  long acks = 0 ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  if  ( data[i]  !  =  null )   {  acks| = mask ( i )  ;  ack count +  +  ;  highest received = i ;   }   }     fragment acks = acks ;     ack count = ack count ;     highest received = highest received ;   }  
public void   (  io buffer byte buffer )  throws  exception  {  if  ( buffer  =  =  null )   {  byte buffer . position ( byte buffer . limit (  )  )  ;  return ;   }  invalidate buffer (  )  ;  if  ( buffer . length (  )   >  max buffer size )   {  buffer = null ;  final  protocol decoder exception ex = new  protocol decoder exception ( " stopped parsing never ending stanza" )  ;  ex . set hexdump ( " ( redacted hex dump of never ending stanza ) " )  ;  throw ex ;   }   char buffer char buffer =  char buffer . allocate ( byte buffer . capacity (  )  )  ;  encoder . reset (  )  ;  encoder . decode ( byte buffer . buf (  )  char buffer false )  ;  char[] buf = new char[char buffer . position (  ) ] ;  char buffer . flip (  )  ;  char buffer . get ( buf )  ;  int read char = buf . length ;  if  ( read char  =  =  0 )   {  return ;   }  buffer . append ( buf )  ;  char ch ;  boolean is high surrogate = false ;  for  ( int i = 0 ;  i  <  read char ;  i +  +  )   {  ch = buf[i] ;  if  ( ch  <  0x20 && ch  !  =  0x9 && ch  !  =  0xa && ch  !  =  0xd && ch  !  =  0x0 )   {  buffer = null ;  throw new xml not well formed exception ( " character is invalid in: "  +  ch )  ;   }  if  ( is high surrogate )   {  if  (  character . is low surrogate ( ch )  )   {  is high surrogate = false ;   }  else  {  buffer = null ;  throw new  exception ( " found high surrogate not followed by low surrogate" )  ;   }   }  else if  (  character . is high surrogate ( ch )  )   {  is high surrogate = true ;   }  else if  (  character . is low surrogate ( ch )  )   {  buffer = null ;  throw new  exception ( " found low surrogate char without a preceding high surrogate" )  ;   }  if  ( status  =  =  xml lightweight parser . tail )   {  if  ( depth  <  1 && ch  =  =  head . char at ( tail count )  )   {  tail count +  +  ;  if  ( tail count  =  =  head . length (  )  )   {  int end = buffer . length (  )   -  read char  +   ( i  +  1 )  ;   string msg = buffer . substring ( start last msg end )  ;  found msg ( msg )  ;  start last msg = end ;   }   }  else  {  tail count = 0 ;  status = xml lightweight parser . inside ;   }   }  else if  ( status  =  =  xml lightweight parser . pretail )   {  if  ( ch  =  =  xml lightweight parser . cdata   start[cdata offset] )   {  cdata offset +  +  ;  if  ( cdata offset  =  =  xml lightweight parser . cdata   start . length )   {  status = xml lightweight parser . inside   cdata ;  cdata offset = 0 ;  continue ;   }   }  else  {  cdata offset = 0 ;  status = xml lightweight parser . inside ;   }  if  ( ch  =  =  ' / ' )   {  status = xml lightweight parser . tail ;  depth -  -  ;   }  else if  ( ch  =  =  ' ! ' )   {  status = xml lightweight parser . inside ;   }  else  {  depth +  +  ;   }   }  else if  ( status  =  =  xml lightweight parser . verify   close   tag )   {  if  ( ch  =  =  ' > ' )   {  depth -  -  ;  status = xml lightweight parser . outside ;  if  ( depth  <  1 )   {  int end = buffer . length (  )   -  read char  +   ( i  +  1 )  ;   string msg = buffer . substring ( start last msg end )  ;  found msg ( msg )  ;  start last msg = end ;   }   }  else if  ( ch  =  =  ' < ' )   {  status = xml lightweight parser . pretail ;  inside children tag = true ;   }  else  {  status = xml lightweight parser . inside ;   }   }  else if  ( status  =  =  xml lightweight parser . inside   param   value )   {  if  ( ch  =  =  '"' )   {  status = xml lightweight parser . inside ;   }   }  else if  ( status  =  =  xml lightweight parser . inside   cdata )   {  if  ( ch  =  =  xml lightweight parser . cdata   end[cdata offset] )   {  cdata offset +  +  ;  if  ( cdata offset  =  =  xml lightweight parser . cdata   end . length )   {  status = xml lightweight parser . outside ;  cdata offset = 0 ;   }   }  else if  ( cdata offset  =  =  xml lightweight parser . cdata   end . length  -  1 && ch  =  =  xml lightweight parser . cdata   end[cdata offset  -  1] )   {   }  else  {  cdata offset = 0 ;   }   }  else if  ( status  =  =  xml lightweight parser . inside )   {  if  ( ch  =  =  xml lightweight parser . cdata   start[cdata offset] )   {  cdata offset +  +  ;  if  ( cdata offset  =  =  xml lightweight parser . cdata   start . length )   {  status = xml lightweight parser . inside   cdata ;  cdata offset = 0 ;  continue ;   }   }  else  {  cdata offset = 0 ;  status = xml lightweight parser . inside ;   }  if  ( ch  =  =  '"' )   {  status = xml lightweight parser . inside   param   value ;   }  else if  ( ch  =  =  ' > ' )   {  status = xml lightweight parser . outside ;  if  ( inside root tag &&  ( "stream:stream > " . equals ( head . to string (  )  )  ||  ( " ? xml > " . equals ( head . to string (  )  )  )  ||  ( "flash:stream > " . equals ( head . to string (  )  )  )  )  )   {  int end = buffer . length (  )   -  read char  +   ( i  +  1 )  ;  while  ( start last msg  <  end && ' < '  !  =  buffer . char at ( start last msg )  )   {  start last msg +  +  ;   }   string msg = buffer . substring ( start last msg end )  ;  found msg ( msg )  ;  start last msg = end ;   }  inside root tag = false ;   }  else if  ( ch  =  =  ' / ' )   {  status = xml lightweight parser . verify   close   tag ;   }   }  else if  ( status  =  =  xml lightweight parser . head )   {  if  ( ch  =  =  ' ' || ch  =  =  ' > ' )   {  head . append ( ' > ' )  ;  if  ( ch  =  =  ' > ' )  status = xml lightweight parser . outside ;  else status = xml lightweight parser . inside ;  inside root tag = true ;  inside children tag = false ;  continue ;   }  else if  ( ch  =  =  ' / ' && head . length (  )   >  0 )   {  status = xml lightweight parser . verify   close   tag ;  depth -  -  ;   }  head . append ( ch )  ;   }  else if  ( status  =  =  xml lightweight parser . init )   {  if  ( ch  =  =  ' < ' )   {  status = xml lightweight parser . head ;  depth = 1 ;   }  else  {  start last msg +  +  ;   }   }  else if  ( status  =  =  xml lightweight parser . outside )   {  if  ( ch  =  =  ' < ' )   {  status = xml lightweight parser . pretail ;  cdata offset = 1 ;  inside children tag = true ;   }   }   }  if  ( head . length (  )   >  0 &&  ( " / stream:stream > " . equals ( head . to string (  )  )  ||  ( " / flash:stream > " . equals ( head . to string (  )  )  )  )  )   {  found msg ( " <  / stream:stream > " )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber <  list <  integer >  >  ts = pp . to l
public static boolean   (  file zipfile )  {   zip file zip = null ;  try  {  byte buf[] = new byte[16 * 1024] ;  zip = new  zip file ( zipfile )  ;   enumeration <  ?  extends  zip entry >  entries = zip . entries (  )  ;  boolean p200 test required = true ;  while  ( entries . has more elements (  )  )   {   zip entry entry =  (  zip entry ) entries . next element (  )  ;  if  ( entry . get name (  )  . index of ( " .  . " )   !  =   - 1 )   {  return false ;   }  if  ( entry . is directory (  )  )   {   }  else  {  if  ( p200 test required &&  ( entry . get name (  )  . ends with ( " . jar . pack" )  || entry . get name (  )  . ends with ( " . war . pack" )  )  )   {  if  (  ! is pack200 supported (  )  )   {   system . err . println ( "error:  zip verify failed  your jvm does not support unpack200" )  ;  return false ;   }  p200 test required = false ;   }  try  {   input stream in = zip . get input stream ( entry )  ;  while  (  ( in . read ( buf )  )   !  =   - 1 )   {   }  in . close (  )  ;   }  catch  (  io exception ioe )   {  return false ;   }   }   }  return true ;   }  catch  (  io exception ioe )   {  return false ;   }  finally  {  if  ( zip  !  =  null )   {  try  {  zip . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }   }  
@ test public void   (  )  {   test scheduler s = new  test scheduler (  )  ;   observable <  long >  interval =  observable . interval ( 100  time unit . milliseconds s )  . publish (  )  . ref count (  )  ;  final  list <  long >  list1 = new  array lis
private static  variant context   ( final  variant context ctx final  set <  string >  samples )  {  final  variant context builder builder = new  variant context builder ( ctx )  ;  final  genotypes context new genotypes = ctx . get genotypes (  )  . subset to samples ( samples )  ;  builder . alleles ( ctx . get alleles (  )  )  ;  return builder . genotypes ( new genotypes )  . make (  )  ;   }  
@ override public void   (  )  {  threads running . increment and get (  )  ;  try  {  if  ( s  =  =  null )   {   system . out . println ( " test multi threaded observable on next: null" )  ;  throw npe ;   }  else  {   system . out . println ( " test mu
public   (  byte payload[] )  {        payload type =  byte . value of (  ( byte ) 0 )  ;     extension header =  integer . value of ( 0 )  ;     marker =  boolean . value of ( false )  ;     padding =  boolean . value of ( false )  ;     sequence number =  integer . value of ( 0 )  ;     synchronization source =  long . value of ( 0l )  ;     timestamp =  long . value of ( 0l )  ;  set payload ( payload )  ;   }  
public  prepared batch   (  string sql )  {  return new  prepared batch ( this sql )  ;   }  
protected void   ( long ms to wait  connection con )  {  con . schedule connection event ( ms to wait )  ;   }  
private synchronized  properties   (  string config file )  {   file cfg file = new  file ( config file )  ;  if  (  ! cfg file . is absolute (  )  )  cfg file = new  file ( i2p app context . get global context (  )  . get config dir (  )  config file )  ;  if  (  ! cfg file . exists (  )  )   {  if  (    log . should log (  log . error )  )     log . error ( " unable to load the controllers from "  +  cfg file . get absolute path (  )  )  ;  throw new  illegal argument exception ( " unable to load the controllers from "  +  cfg file . get absolute path (  )  )  ;   }   properties props = new  properties (  )  ;  try  {   data helper . load props ( props cfg file )  ;  return props ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . error )  )     log . error ( " error reading the controllers from "  +  cfg file . get absolute path (  )  ioe )  ;  throw new  illegal argument exception ( " error reading the controllers from "  +  cfg file . get absolute path (  )  ioe )  ;   }   }  
@ override public  zone id   (  )  {  return  zone id . system default (  )  ;   }  
  ( final  admin manager admin manager final  login limit manager login limit manager final  string servlet request authenticator class name )  {  this . admin manager = admin manager ;  this . login limit manager = login limit manager ;   auth check filter . instance = this ;   servlet request authenticator authenticator = null ;  if  (  ! servlet request authenticator class name . is empty (  )  )   {  try  {  final  class clazz =  class utils . for name ( servlet request authenticator class name )  ;  authenticator =  (  servlet request authenticator ) clazz . new instance (  )  ;   }  catch  (  final  exception e )   {   log . error ( " error loading  servlet request authenticator: "  +  servlet request authenticator class name e )  ;   }   }  this . servlet request authenticator = authenticator ;   }  
@ override public int   (  session data data )  {  return 1 ;   }  
public void   (  dialog terminated event dte )  {  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( "process dialog terminated called" )  ;   }   }  
@ override public  iterator <  integer >    (  )  {  return new  iterator <  integer >  (  )  {  @ override public void remove (  )  {   }  @ override public  integer next (  )  {  return generated . get and increment (  )  ;   }  @ override public boolea
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  {  @ override public void on next (   integer t )  {  super . on next ( t )
private static  string   (  string pfx  string msg dcc helper helper )  {  int ctcp = msg . index of ( 0x01 )  ;  if  ( ctcp  >  0 )  msg = msg . substring ( 0 ctcp )  ;   string[] args =  data helper . split ( msg " " 5 )  ;  if  ( args . length  <  =  0 )  return null ;   string type = args[0] ;  boolean haveip = true ;  if  ( type  =  =  "resume" || type  =  =  "accept" )   {  haveip = false ;   }  else if  (  !  ( type . equals ( "chat" )  || type . equals ( "send" )  )  )   {  if  ( allow   all   dcc   in )   {  if  ( ctcp  >  0 )  return pfx  +  msg  +   ( char ) 0x01 ;  return pfx  +  msg ;   }  return null ;   }  if  ( helper  =  =  null ||  ! helper . is enabled (  )  )  return null ;  if  ( args . length  <  3 )  return null ;  if  ( haveip && args . length  <  4 )  return null ;   string arg = args[1] ;  int next arg = 2 ;   string b32 = null ;  if  ( haveip )  b32 = args[next arg +  + ] ;  int c port ;  try  {   string cp = args[next arg +  + ] ;  c port =  integer . parse int ( cp )  ;   }  catch  (   number format exception nfe )   {  return null ;   }  if  ( c port  <  0 || c port  >  65535 )  return null ;  int port =  - 1 ;  if  ( haveip )   {  if  ( c port  >  0 )  port = helper . new incoming ( b32 c port type )  ;  else port = c port ;   }  else if  ( type . equals ( "accept" )  )   {  port = helper . accept incoming ( c port )  ;   }  else if  ( type . equals ( "resume" )  )   {  port = helper . resume incoming ( c port )  ;   }  if  ( port  <  0 )  return null ;   string builder buf = new  string builder ( 256 )  ;  buf . append ( pfx )  . append ( type )  . append ( ' ' )  . append ( arg )  . append ( ' ' )  ;  if  ( haveip )   {  if  ( port  >  0 )   {  byte[] myip = helper . get local address (  )  ;  buf . append (  data helper . from long ( myip 0 myip . length )  )  . append ( ' ' )  ;   }  else  {  buf . append ( "0 " )  ;   }   }  buf . append ( port )  ;  while  ( args . length  >  next arg )   {  buf . append ( ' ' )  . append ( args[next arg +  + ] )  ;   }  if  ( pfx . index of ( 0x01 )   >  =  0 )  buf . append (  ( char ) 0x01 )  ;  return buf . to string (  )  ;   }  
private static  callable <  integer >    ( final  runtime exception e )  {  return new  callable <  integer >  (  )  {  @ override public  integer call (  )  throws  exception  {  throw e ;   }   }   ;   }  
@ override public final void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {  if  (  backpressure helper . add ( this n )   =  =  0l )   {  if  ( n  =  =   long . max   value )   {  fast path (  )  ;   }  else  {  slow path ( n )  ;   
private sam record   ( final int read length final  illumina adapter pair adapter pair final int adapter position )  {  final  string adapter string = adapter pair . get3 prime adapter in read order (  )  ;  final int replacement length =  math . min ( adapter string . length (  )  read length  -  adapter position )  ;  final  string adapter substring = adapter string . substring ( 0 replacement length )  ;  final  string read bases = replace substring ( make bogus read string ( read length )  adapter substring adapter position adapter substring . length (  )  )  ;  final sam record rec = new sam record ( null )  ;  rec . set read string ( read bases )  ;  return rec ;   }  
@ test public void   (  )  {  final  test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (  org . reactivestreams .  subscriber <  ?  super  integer
public static  collection <  bookmark >    (  )  {   list <  bookmark >  bookmarks = new  array list <  bookmark >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( select   bookmarks )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  long bookmarkid = rs . get long ( 1 )  ;  try  {   bookmark bookmark = new  bookmark ( bookmarkid )  ;  bookmarks . add ( bookmark )  ;   }  catch  (   not found exception nfe )   {   log . error ( nfe . get message (  )  nfe )  ;   }   }   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return bookmarks ;   }  
protected int   (  )  {  return 4  +  data   size ;   }  
public synchronized boolean   (  )  {  return header only ;   }  
public   (  flowable < t >  source long count long time  time unit unit  scheduler scheduler int buffer size boolean delay error )  {  super ( source )  ;  this . count = count ;  this . time = time ;  this . unit = unit ;  this . scheduler = scheduler ;  this . buffer size = buffer size ;  this . delay error = delay error ;   }  
public   (  string cache key int ttl in seconds byte[] payload  remote behavior requested remote behavior )  {  this . cache key = cache key ;  this . ttl in seconds = ttl in seconds ;  this . payload =  array utilities . null safe copy ( payload )  ;  this . requested remote behavior = requested remote behavior ;   }  
public  multi user chat service impl   (  string subdomain  string description  boolean is hidden )  throws  already exists exception  {  if  ( get multi user chat serviceid ( subdomain )   !  =  null )  throw new  already exists exception (  )  ;   multi user chat service impl muc = new  multi user chat service impl ( subdomain description is hidden )  ;  insert service ( subdomain description is hidden )  ;  register multi user chat service ( muc )  ;  return muc ;   }  
@ override public void   (  yahoo buddy contact )  {  if  ( contact . get groups (  )   =  =  null || contact . get groups (  )  . is empty (  )  )   {   list <  string >  default group = new  array list <  string >  (  )  ;  default group . add ( default
public void   ( int frequency )  {   jive globals . set property ( "plugin . email . listener . frequency"  integer . to string ( frequency )  )  ;   }  
public  character   (  )  {  return wrapped char ;   }  
public long   (  )  {  long when =  - 1 ;  for  (   job queue runner runner :    queue runners . values (  )  )   {  long cur = runner . get last end (  )  ;  if  ( cur  >  when )  cur = when ;   }  return when ;   }  
public void   (  )  {   host auth ha = new  host auth (  )  ;  ha . m flags = 0x00000000 ;  ha . set login ( "user" "password" )  ;  assert equals (  host auth . flag   authenticate ha . m flags )  ;  ha . m flags = 0x00000000 ;  ha . set login ( "user" "" )  ;  assert equals (  host auth . flag   authenticate ha . m flags )  ;  ha . m flags = 0xffffffff ;  ha . set login ( "" "password" )  ;  assert equals ( ~ host auth . flag   authenticate ha . m flags )  ;  ha . m flags = 0x00000000 ;  ha . set login ( "user" null )  ;  assert equals (  host auth . flag   authenticate ha . m flags )  ;  ha . m flags = 0xffffffff ;  ha . set login ( null "password" )  ;  assert equals ( ~ host auth . flag   authenticate ha . m flags )  ;  ha . m flags = 0xffffffff ;  ha . set login ( null null )  ;  assert equals ( ~ host auth . flag   authenticate ha . m flags )  ;   }  
public void   (  )  throws json exception  {  final json object json = new json object (  )  ;  json . put (  email content .  host auth columns . protocol "imap" )  ;  json . put (  email content .  host auth columns . address "dhoff@example . com" )  ;  json . put (  email content .  host auth columns . port 1337 )  ;  json . put (  email content .  host auth columns . flags 293847 )  ;  json . put (  email content .  host auth columns . login "dhoff" )  ;  json . put (  email content .  host auth columns . password "daknightrida" )  ;  json . put (  email content .  host auth columns . domain "example . com" )  ;  json . put (  email content .  host auth columns . client   cert   alias "i'm a client cert alias" )  ;  json . put (  host auth . json   tag   credential  credential . empty . to json (  )  )  ;  final  host auth ha =  host auth . from json ( json )  ;  assert equals ( "imap" ha . m protocol )  ;  assert equals ( "dhoff@example . com" ha . m address )  ;  assert equals ( 1337 ha . m port )  ;  assert equals ( 293847 ha . m flags )  ;  assert equals ( "dhoff" ha . m login )  ;  assert equals ( "daknightrida" ha . m password )  ;  assert equals ( "example . com" ha . m domain )  ;  assert equals ( "i'm a client cert alias" ha . m client cert alias )  ;  assert equals (  credential . empty ha . m credential )  ;  assert null ( ha . m server cert )  ;  assert equals (  - 1 ha . m credential key )  ;   }  
public long   (  )  {  return downloaded . get (  )  ;   }  
@ test public void   (  )  {   completable observer consumer = new  resource completable observer (  )  {  @ override public void on error (   throwable t )  {   }  @ override public void on complete (  )  {   }   }   ;   disposable sub1 =  disposables . 
public int   (  )  {  return    max total conns per day ;   }  
public  representative read indexer   (  )  {  final  representative read indexer rni = new  representative read indexer (  )  ;  try  {  try  {  rni . read index in file = this . in . read int (  )  ;   }  catch  (  final eof exception eof )   {  return null ;   }  rni . set size = this . in . read int (  )  ;  rni . representative read index in file = this . in . read int (  )  ;  return rni ;   }  catch  (  final io exception ioe )   {  throw new  picard exception ( " exception writing  read ends to file . " ioe )  ;   }   }  
  (  single observer <  ?  super  boolean >  actual  predicate <  ?  super t >  predicate )  {  this . actual = actual ;  this . predicate = predicate ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  try  {  parent . on subscribe . accept ( s )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  s . c
public void   (  limits l  output stream output )  {  entiy transform . transform ( limits   object   factory . create limits ( l )  output )  ;   }  
public void   (  string language )  {  this . language = language ;   }  
@ override public boolean   ( jid requester )  {  return super . has permission ( requester )  ||  internal component manager . get instance (  )  . has component ( requester )  ;   }  
private void   (  string username  list <  user property >  properties )  throws  service exception  {   user user = get and check user ( username )  ;  user . get properties (  )  . clear (  )  ;  if  ( properties  !  =  null )   {  for  (   user property property : properties )   {  user . get properties (  )  . put ( property . get key (  )  property . get value (  )  )  ;   }   }   }  
@ override public void   ( t t )  {  if  ( value  =  =  null )   {  value = t ;  d . dispose (  )  ;  count down (  )  ;   }   }  
private void   (  file search dir )  throws io exception  {   file index properties file = new  file ( search dir "indexprops . xml" )  ;  if  (  ! index properties file . exists (  )  )   {  org . dom4j .  document doc =  document factory . get instance (  )  . create document (  document factory . get instance (  )  . create element ( "search" )  )  ;   writer out = null ;  try  {  out = new  file writer ( index properties file )  ;  xml writer outputter = new xml writer ( out  output format . create pretty print (  )  )  ;  outputter . write ( doc )  ;  outputter . flush (  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  try  {  if  ( out  !  =  null )   {  out . close (  )  ;   }   }  catch  (   exception e )   {   }   }   }  index properties = new xml properties ( index properties file )  ;   }  
public   ( int i )  {  super ( i )  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   single . using (  functions . just callable (  disposables . empty (  )  )  mapper disposer throws false )  . test (  )  . assert result ( 1 
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c = error . completable . retry ( new  bi predicate <  integer  throwable >  (  )  {  @ override public boolean test (   integer n   throwable e )  {  return
@ override public  string   (  )  {  return " fragment "  +  num  +  "  ( " +  state . fragment size ( num )  +  " bytes )  of " +  state ;   }  
public   (  observable source < t >  source long limit )  {  super ( source )  ;  this . limit = limit ;   }  
public void   (  client message msg )  {  if  (    manager  !  =  null )     manager . message received ( msg )  ;  else    log . error ( " null manager on message received ! " )  ;   }  
public void   (  agent session agent  user request request )  {  try  {   room interceptor manager interceptor manager =  room interceptor manager . get instance (  )  ;   workgroup manager workgroup manager =  workgroup manager . get instance (  )  ;   string userjid = request . get userjid (  )  . to string (  )  ;  final  workgroup session workgroup = request . get workgroup (  )  ;  final  string sessionid = request . get sessionid (  )  ;   string workgroup name = getjid (  )  . get node (  )  ;  final  string service name = workgroup manager . getmuc service name (  )  ;  final  string room name = sessionid  +  "@"  +  service name ;  final  string roomjid = room name  +  " / "  +  workgroup name ;   join room join room = new  join room ( get fulljid (  )  . to string (  )  roomjid )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  join room false false )  ;  send ( join room )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  join room false true )  ;   map <  string  collection <  string >  >  fields = new  hash map <  string  collection <  string >  >  (  )  ;   list <  string >  values = new  array list <  string >  (  )  ;  values . add ( "0" )  ;  fields . put ( "muc#roomconfig   publicroom" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( room name )  ;  fields . put ( "muc#roomconfig   roomdesc" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( "1" )  ;  fields . put ( "muc#roomconfig   changesubject" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( "0" )  ;  fields . put ( "muc#roomconfig   persistentroom" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( "moderators" )  ;  fields . put ( "muc#roomconfig   whois" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( "0" )  ;  fields . put ( "anonymous" values )  ;  values = new  array list <  string >  (  )  ;  values . add ( "participant" )  ;  values . add ( "visitor" )  ;  values . add ( "moderators" )  ;  fields . put ( "muc#roomconfig   presencebroadcast" values )  ;   room configuration conf = new  room configuration ( fields )  ;  conf . set to ( room name )  ;  conf . set from ( get fulljid (  )  )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  conf false false )  ;  send ( conf )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  conf false true )  ;  requests . put ( sessionid request )  ;   invitation invitation = new  invitation ( agent . getjid (  )  . to string (  )  sessionid )  ;  invitation . set to ( room name )  ;  invitation . set from ( get fulljid (  )  )  ;   element element = invitation . add child element ( "offer" "http: /  / jabber . org / protocol / workgroup" )  ;  element . add attribute ( "jid" userjid )  ;  element = invitation . add child element ( "session" "http: /  / jivesoftware . com / protocol / workgroup" )  ;  element . add attribute ( "workgroup" session workgroup . getjid (  )  . to string (  )  )  ;  element . add attribute ( "id" sessionid )  ;  if  ( request . is anonymous user (  )  )   {  element = invitation . add child element ( "user" "http: /  / jivesoftware . com / protocol / workgroup" )  ;  element . add attribute ( "id" request . get userid (  )  )  ;   }  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  invitation false false )  ;  send ( invitation )  ;  interceptor manager . invoke interceptors ( getjid (  )  . to barejid (  )  invitation false true )  ;  send user invitiation ( request room name )  ;  request . invitations sent ( sessionid )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
public boolean   (  mail mail )  {  synchronized  (    lock )   {  return locked   save mail ( mail )  ;   }   }  
@ override public boolean   (  object obj )  {  if  ( this  =  =  obj )  return true ;  if  ( obj  =  =  null )  return false ;  if  ( get class (  )   !  =  obj . get class (  )  )  return false ;   localmuc room other =  (  localmuc room ) obj ;  if  ( 
public   (  string message  throwable cause )  {  super ( message cause )  ;   }  
@ test public void   (  )  {  final  atomic integer subscribe counter = new  atomic integer (  )  ;  final  atomic integer sent event counter = new  atomic integer (  )  ;  final  atomic integer event counter = new  atomic integer (  )  ;  sync   infinite
@ before class public void   (  )  throws io exception  {  na12891   r1 =  sam test utils . create indexed bam ( na12891   r1   sam na12891   r1   sam )  ;  na12891   r2 =  sam test utils . create indexed bam ( na12891   r2   sam na12891   r2   sam )  ;  
@ override protected boolean   (  string opcode  properties props )  {   string dest = "bug ! " ;  boolean ok = false ;   string nick =  (  string ) props . remove ( "id" )  ;  if  ( nick  =  =  null )  return write string ( session   error "id not specif
  ( int count )  {  this . num failures = count ;   }  
private void   (  cache <  ?   ?  >  cache  entry listener listener )  {  if  ( cache instanceof  cache wrapper )   {   cache wrapped =  (  (  cache wrapper ) cache )  . get wrapped cache (  )  ;  if  ( wrapped instanceof  clustered cache )   {   (  (  clustered cache ) wrapped )  . add entry listener ( listener false )  ;  entry listeners . put ( cache listener )  ;   }   }   }  
@ test public void   (  )  throws  exception  {  final double tolerance = 0 . 02 ;  final double expected result =  . 9617 ;  final int max depth = 500 ;  final double[] depth distribution = new double[max depth  +  1] ;  final double[] quality distributi
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  function <  ?  super  flowable <  object >   ?  extends  publisher <  ?  >  >  handler )  {  return from publisher ( to flowable (  )  . repeat when ( h
public long[]   (  data input in )  throws io exception  {  return  ( long[] ) read object ( in )  ;   }  
public  document   (  )  throws  document exception  io exception   xml pull parser exception  {   document factory df = get document factory (  )  ;   document document = df . create document (  )  ;   element parent = null ;   xml pull parser pp = getxpp parser (  )  ;  int count = 0 ;  while  ( true )   {  int type =  - 1 ;  type = pp . next token (  )  ;  switch  ( type )   {  case  xml pull parser . processing   instruction:  {   string text = pp . get text (  )  ;  int loc = text . index of ( " " )  ;  if  ( loc  >  =  0 )   {  document . add processing instruction ( text . substring ( 0 loc )  text . substring ( loc  +  1 )  )  ;   }  else  {  document . add processing instruction ( text "" )  ;   }  break ;   }  case  xml pull parser . comment:  {  if  ( parent  !  =  null )   {  parent . add comment ( pp . get text (  )  )  ;   }  else  {  document . add comment ( pp . get text (  )  )  ;   }  break ;   }  case  xml pull parser . cdsect:  {   string text = pp . get text (  )  ;  if  ( parent  !  =  null )   {  parent . addcdata ( text )  ;   }  else  {  if  ( text . trim (  )  . length (  )   >  0 )   {  throw new  document exception ( " cannot have text content outside of the root document" )  ;   }   }  break ;   }  case  xml pull parser . entity   ref:  {   string text = pp . get text (  )  ;  if  ( parent  !  =  null )   {  parent . add text ( text )  ;   }  else  {  if  ( text . trim (  )  . length (  )   >  0 )   {  throw new  document exception ( " cannot have an entityref outside of the root document" )  ;   }   }  break ;   }  case  xml pull parser . end   document:  {  return document ;   }  case  xml pull parser . start   tag:  {  q name qname =  ( pp . get prefix (  )   =  =  null )   ?  df . createq name ( pp . get name (  )  pp . get namespace (  )  )  : df . createq name ( pp . get name (  )  pp . get prefix (  )  pp . get namespace (  )  )  ;   element new element ;  boolean drop namespace = false ;  if  ( pp . get prefix (  )   =  =  null && ignored   namespace   on   stanza . contains ( qname . get namespaceuri (  )  )  )   {  drop namespace = true ;  for  (  element el = parent ;  el  !  =  null ;  el = el . get parent (  )  )   {  final  string defaultns = el . get namespace for prefix ( "" )  . geturi (  )  ;  if  ( defaultns . equals ( "" )  )   {  break ;   }  if  (  ! defaultns . equals ( qname . get namespaceuri (  )  )  )   {  drop namespace = false ;  break ;   }   }   }  if  ( drop namespace )   {  new element = df . create element ( pp . get name (  )  )  ;   }  else  {  new element = df . create element ( qname )  ;   }  int ns start = pp . get namespace count ( pp . get depth (  )   -  1 )  ;  int ns end = pp . get namespace count ( pp . get depth (  )  )  ;  for  ( int i = ns start ;  i  <  ns end ;  i +  +  )   {  final  string namespace prefix = pp . get namespace prefix ( i )  ;  final  string namespace uri = pp . get namespace uri ( i )  ;  if  ( namespace prefix  !  =  null )   {  new element . add namespace ( namespace prefix namespace uri )  ;   }  else if  ( parent  =  =  null && ignored   namespace   on   stanza . contains ( namespace uri )  )   {   }  else if  (  !  ( drop namespace && namespace uri . equals ( qname . get namespaceuri (  )  )  )  )   {  new element . add namespace ( "" namespace uri )  ;   }   }  for  ( int i = 0 ;  i  <  pp . get attribute count (  )  ;  i +  +  )   {  q name qa =  ( pp . get attribute prefix ( i )   =  =  null )   ?  df . createq name ( pp . get attribute name ( i )  )  : df . createq name ( pp . get attribute name ( i )  pp . get attribute prefix ( i )  pp . get attribute namespace ( i )  )  ;  new element . add attribute ( qa pp . get attribute value ( i )  )  ;   }  if  ( parent  !  =  null )   {  parent . add ( new element )  ;   }  else  {  document . add ( new element )  ;   }  parent = new element ;  count +  +  ;  break ;   }  case  xml pull parser . end   tag:  {  if  ( parent  !  =  null )   {  parent = parent . get parent (  )  ;   }  count -  -  ;  if  ( count  <  1 )   {  last active =  system . current time millis (  )  ;  return document ;   }  break ;   }  case  xml pull parser . text:  {   string text = pp . get text (  )  ;  if  ( parent  !  =  null )   {  parent . add text ( text )  ;   }  else  {  if  ( text . trim (  )  . length (  )   >  0 )   {  throw new  document exception ( " cannot have text content outside of the root document" )  ;   }   }  break ;   }  default :  {   }   }   }   }  
@ override protected void   (  subscriber <  ?  super  boolean >  s )  {  source . subscribe ( new  any subscriber < t >  ( s predicate )  )  ;   }  
  (  http servlet request http request  compressing stream factory compressing stream factory  compressing filter context context )  {  super ( http request )  ;  this . http request = http request ;  this . compressing stream factory = compressing stream factory ;  this . context = context ;   }  
public  skip span < k v >    ( k key int[] search )  {  if  ( n keys  =  =  0 )   {  search[0] =  - 1 ;  return this ;   }  if  ( keys[n keys  -  1] . compare to ( key )   <  0 )   {  if  ( next  =  =  null )   {  search[0] =  (  - 1 *  ( n keys  -  1 )  )   -  1 ;  return this ;   }  return next . get span ( key search )  ;   }  search[0] = binary search ( key )  ;  return this ;   }  
public void   ( boolean debug enabled )  {  this . debug enabled = debug enabled ;   jive globals . set property ( "mail . debug"  boolean . to string ( debug enabled )  )  ;  session = null ;   }  
public void   (  )  {   string id =  imap store . get imap id ( m test context "user - name" "host - name" capability   response . flatten (  )  )  ;   hash map <  string  string >  map = tokenize imap id ( id )  ;  assert equals ( m test context . get package name (  )  map . get ( "name" )  )  ;  assert equals ( "android" map . get ( "os" )  )  ;  assert not null ( map . get ( "os - version" )  )  ;  assert not null ( map . get ( "vendor" )  )  ;  assert not null ( map . get ( "aguid" )  )  ;  id =  imap store . make common imap id ( "package name" "version" "code name" "model" "id" "vendor" "network - operator" )  ;  map = tokenize imap id ( id )  ;  assert equals ( "package name" map . get ( "name" )  )  ;  assert equals ( "android" map . get ( "os" )  )  ;  assert equals ( "version ;  id" map . get ( "os - version" )  )  ;  assert equals ( "vendor" map . get ( "vendor" )  )  ;  assert equals ( null map . get ( "x - android - device - model" )  )  ;  assert equals ( "network - operator" map . get ( "x - android - mobile - net - operator" )  )  ;  assert equals ( null map . get ( "aguid" )  )  ;  id =  imap store . make common imap id ( "package name" "" "rel" "model" "id" "vendor" "" )  ;  map = tokenize imap id ( id )  ;  assert equals ( "package name" map . get ( "name" )  )  ;  assert equals ( "android" map . get ( "os" )  )  ;  assert equals ( "1 . 0 ;  id" map . get ( "os - version" )  )  ;  assert equals ( "vendor" map . get ( "vendor" )  )  ;  assert equals ( "model" map . get ( "x - android - device - model" )  )  ;  assert equals ( null map . get ( "x - android - mobile - net - operator" )  )  ;  assert equals ( null map . get ( "aguid" )  )  ;   }  
public  persistence manager   ( jid jid )  {   log . debug ( " getting  persistence manager for  {  } " jid )  ;  if  ( xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( jid )   !  =  null )   {   log . debug ( " using  muc persistence manager" )  ;  return muc persistence manager ;   }  return persistence manager ;   }  
@ override public void   (  servlet config config )  throws  servlet exception  {  super . init ( config )  ;  chat settings manager =  chat settings manager . get instance (  )  ;   }  
public   (  object value  string label )  {  this . value = value ;  this . label = label ;   }  
public void   (  rrd updater other )  throws io exception   rrd exception  {  if  (  !  ( other instanceof  robin )  )   {  throw new  rrd exception ( " cannot copy  robin object to "  +  other . get class (  )  . get name (  )  )  ;   }   robin robin =  (  robin ) other ;  int rows diff = rows  -  robin . rows ;  if  ( rows diff  =  =  0 )   {  robin . pointer . set ( pointer . get (  )  )  ;  robin . values . write bytes ( values . read bytes (  )  )  ;   }  else  {  for  ( int i = 0 ;  i  <  robin . rows ;  i +  +  )   {  int j = i  +  rows diff ;  robin . store ( j  >  =  0  ?  get value ( j )  :  double .  nan )  ;   }   }   }  
@ test public void   (  )  {   single . using (  functions . just callable ( 1 )   functions . just function (  single . just ( 1 )  )   functions . empty consumer (  )  false )  . test (  )  . assert result ( 1 )  ;   }  
@ override public void   ( final long n )  {  if  (  subscription helper . validate ( n )  )   {   subscription s = this . s . get (  )  ;  if  ( s  !  =  null )   {  request upstream ( n s )  ;   }  else  {   backpressure helper . add ( requested n )  ; 
@ test public void   (  )  {   observable publish <  integer >  source =  (  observable publish <  integer >  )  observable . just ( 1 )  . publish (  )  ;   test observer <  integer >  to1 = new  test observer <  integer >  (  )  ;  source . subscribe ( 
protected void   (  string msg )  {  if  ( msg  =  =  null )  return ;     notices . add ( msg )  ;   }  
public boolean   (  )  {  return true ;   }  
@ override public  credential   (  parcel in )  {  return new  credential ( in )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
public synchronized int   (  )  {  return    messages processed  -     old messages processed ;   }  
@ test public void   (  )  {   observable <  integer >  ids =  observable . just ( 1 2 )  ;   observable <  string >  m = ids . flat map ( new  function <  integer  observable <  string >  >  (  )  {  @ override public  observable <  string >  apply (   i
private void   (  )  {  if  ( next tile  =  =  null )   {  throw new  no such element exception ( " no more tiles to advance ! " )  ;   }  if  ( current iterator  !  =  null )   {  current iterator . close (  )  ;   }  current iterator = make tile iterator ( tile to files . get ( next tile )  )  ;  current tile = next tile ;  next tile = tile to files . higher key ( next tile )  ;   }  
@ override public boolean   (  )  {  return  subscription helper . is cancelled ( first . get (  )  )  ;   }  
public synchronized void   ( int check interval )  {  check interval in milliseconds = check interval ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   register column mapper factory register column mapper factory =  (  register column mapper factory ) annotation ;  try  {   column mapper fa
@ test public void   (  )  {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  object >  to = ps . concat map maybe ( new  function <  integer  maybe source <  ?  extends  object >  >  (  )  {  @ override publ
@ test public void   (  )  {  byte[] zero = zero . to byte array (  )  ;  assert that ( zero . length is ( equal to ( bytes   zero . length )  )  )  ;  assert that ( zero is ( equal to ( bytes   zero )  )  )  ;  byte[] one = one . to byte array (  )  ;  a
@ override public void   (  throwable t )  {  parent . other error ( t )  ;   }  
public   (  )  {  super (    context . simple timer2 (  )  check   interval )  ;   }  
void   (  string address  registration event .  type type )  {   registration event evt = new  registration event ( address type )  ;  for  ( int i = listeners . size (  )   -  1 ;  i  >  =  0 ;  i -  -  )   {   ( listeners . get ( i )  )  . registration failed ( evt )  ;   }   }  
@ test public void   (  )  {   bad flowable dispose bf = new  bad flowable dispose (  )  ;  try  {  bf . ref count (  )  . test (  )  . cancel (  )  ;  fail ( " should have thrown" )  ;   }  catch  (   test exception expected )   {   }   }  
  ( t value  function <  ?  super t  ?  extends  observable source <  ?  extends r >  >  mapper )  {  this . value = value ;  this . mapper = mapper ;   }  
@ override public void   (  )  {  actual . on complete (  )  ;   }  
public  el gamal parameter spec   (  )  {  return el spec ;   }  
  ( final  string id final  string object name final  string attribute final boolean periodic )  {  this . id = id ;  this . object name = object name ;  this . attribute = attribute ;  this . periodic = periodic ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test observer <  boolean >  to = pp . single element (  )  . contains ( 1 )  . test (  )  ;  assert true ( pp . has subscribers (  )  )  ;  to . canc
@ override public void   (  subscriber <  ?  super  string >  observer )  {  this . observer = observer ;  observer . on subscribe ( s )  ;   }  
@ override public boolean   (  )  {  if  ( is direct (  )  )  return super . is not empty (  )  ;  return total size (  )   >  0 ;   }  
public   (  router context context  client manager manager i2cp message queue queue )  {  super ( context manager null )  ;  this . queue = queue ;   }  
private   (  stats field field )  {  this . field = field ;   }  
  (  completable observer downstream  function <  ?  super t  ?  extends  completable source >  mapper boolean delay errors )  {  this . downstream = downstream ;  this . mapper = mapper ;  this . delay errors = delay errors ;  this . errors = new  atomic throwable (  )  ;  this . inner = new  atomic reference <  switch map inner observer >  (  )  ;   }  
public void   ( iq iq )  {   string from = iq . get from (  )  . get domain (  )  ;  if  (    waiting foriq response . contains ( from )  )   {   element packet = iq . get child element (  )  ;   document doc = packet . get document (  )  ;   list <  node >  nodes =  xpath helper . find nodes in document ( doc " /  / disco:identity[@category = 'gateway']" )  ;  if  ( nodes . size (  )   >  0 )   {  update interceptors ( from )  ;   }     waiting foriq response . remove ( from )  ;   }   }  
@ test public void   (  )  {   replay subject <  integer >  async =  replay subject . create (  )  ;  async . on complete (  )  ;   subject <  integer >  serial = async . to serialized (  )  ;  assert false ( serial . has observers (  )  )  ;  assert true
public byte[]   ( byte data[]  public key public key )  {  if  (  ( data  =  =  null )  ||  ( data . length  >  =  223 )  )  throw new  illegal argument exception ( " data to encrypt must be  <  223 bytes at the moment" )  ;  if  ( public key  =  =  null )  throw new  illegal argument exception ( " null public key specified" )  ;  long start =    context . clock (  )  . now (  )  ;  byte d2[] = new byte[1  +   hash . hash   length  +  data . length] ;  do  {     context . random (  )  . next bytes ( d2 0 1 )  ;   }  while  ( d2[0]  =  =  0 )  ;     context . sha (  )  . calculate hash ( data 0 data . length d2 1 )  ;   system . arraycopy ( data 0 d2 1  +   hash . hash   length data . length )  ;   big integer m = new  native big integer ( 1 d2 )  ;  if  ( m . compare to (  crypto constants . elgp )   >  =  0 )  throw new  illegal argument exception ( "argh .   data cannot be larger than the  el gamal prime .  fixme" )  ;   big integer aalpha = new  native big integer ( 1 public key . get data (  )  )  ;   big integer yk[] = get nextyk (  )  ;   big integer k = yk[1] ;   big integer y = yk[0] ;   big integer d = aalpha . mod pow ( k  crypto constants . elgp )  ;  d = d . multiply ( m )  ;  d = d . mod (  crypto constants . elgp )  ;  byte[] ybytes = y . to byte array (  )  ;  byte[] dbytes = d . to byte array (  )  ;  byte[] out = new byte[514] ;   system . arraycopy ( ybytes 0 out  ( ybytes . length  <  257  ?  257  -  ybytes . length : 0 )   ( ybytes . length  >  257  ?  257 : ybytes . length )  )  ;   system . arraycopy ( dbytes 0 out  ( dbytes . length  <  257  ?  514  -  dbytes . length : 257 )   ( dbytes . length  >  257  ?  257 : dbytes . length )  )  ;  long end =    context . clock (  )  . now (  )  ;  long diff = end  -  start ;  if  ( diff  >  1000 )   {  if  (    log . should log (  log . warn )  )     log . warn ( " took too long to encrypt  el gamal block  ( "  +  diff  +  "ms ) " )  ;   }     context . stat manager (  )  . add rate data ( "crypto . el gamal . encrypt" diff )  ;  return out ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   publish processor <  integer >  pp1 =  publish processor . create (  )  ;   publish processor <  integer >  pp2 =  publish processor . create (  )  ;   test observer <  integer >  to =  m
private static int   (  string scheme )  {  if  ( https . equals ignore case ( scheme )  )   {  return default   https   port ;   }  if  ( http . equals ignore case ( scheme )  )   {  return default   http   port ;   }  return  - 1 ;   }  
private  set <  session tag >    ( int num tags )  {   set <  session tag >  tags = new  hash set <  session tag >  ( num tags )  ;  for  ( int i = 0 ;  i  <  num tags ;  i +  +  )  tags . add ( new  session tag ( true )  )  ;  return tags ;   }  
@ override public  string   (  )  {  if  ( is complete (  )  )   {  return username ;   }  else  {  throw new  illegal state exception ( "scram - sha - 1 authentication not completed" )  ;   }   }  
@ before public void   (  )  {  scheduler = new  test scheduler (  )  ;  inner scheduler = scheduler . create worker (  )  ;  observer =  test helper . mock observer (  )  ;   }  
public  public suffix list   ( final  reader reader )  throws io exception  {  final  list <  string >  rules = new  array list <  string >  (  )  ;  final  list <  string >  exceptions = new  array list <  string >  (  )  ;  final  buffered reader r = new  buffered reader ( reader )  ;  final  string builder sb = new  string builder ( 256 )  ;  boolean more = true ;  while  ( more )   {  more = read line ( r sb )  ;   string line = sb . to string (  )  ;  if  ( line . is empty (  )  )   {  continue ;   }  if  ( line . starts with ( " /  / " )  )   {  continue ;   }  if  ( line . starts with ( " . " )  )   {  line = line . substring ( 1 )  ;   }  final boolean is exception = line . starts with ( " ! " )  ;  if  ( is exception )   {  line = line . substring ( 1 )  ;   }  if  ( is exception )   {  exceptions . add ( line )  ;   }  else  {  rules . add ( line )  ;   }   }  return new  public suffix list ( rules exceptions )  ;   }  
@ nullable @ override public final t   (  )  {  if  ( it  =  =  null )   {  return null ;   }  if  (  ! once )   {  once = true ;   }  else  {  if  (  ! it . has next (  )  )   {  return null ;   }   }  return  object helper . require non null ( it . next
@ override protected byte[]   (  )  throws i2cp message exception  io exception  {  if  (    date  =  =  null )  throw new i2cp message exception ( " unable to write out the message as there is not enough data" )  ;   byte array output stream os = new  by
@ test public void   (  )  {   test subscriber <  integer >  ts =  test subscriber . create (  )  ;  ts . on subscribe ( new  boolean subscription (  )  )  ;  ts . assert not complete (  )  ;  ts . on complete (  )  ;  try  {  ts . assert not complete (  
@ test public void   (  )  {  final  flowable <  string >  o1 =  flowable . unsafe create ( new  test error flowable ( "one" "two" "three" )  )  ;  final  flowable <  string >  o2 =  flowable . unsafe create ( new  test error flowable ( "four" "five" "six
public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
private  peer state   ( long id )  {  return    outbound . get (  long . value of ( id )  )  ;   }  
public   ( i2p app context ctx  string name int initial capacity )  {  super ( ctx name initial capacity )  ;  stat   drop =  ( "codel . "  +  name  +  " . drop . " )  . intern (  )  ;  stat   delay =  ( "codel . "  +  name  +  " . delay" )  . intern (  )  ;  for  ( int i = 0 ;  i  <  priorities . length ;  i +  +  )   {  ctx . stat manager (  )  . create rate stat ( stat   drop  +  priorities[i] "queue delay of dropped items by priority" " router" rates )  ;   }  ctx . stat manager (  )  . create rate stat ( stat   delay "average queue delay" " router" rates )  ;     id =       id . increment and get (  )  ;   }  
void   (  buffer close subscriber < t c >  closer long idx )  {  subscribers . delete ( closer )  ;  boolean make done = false ;  if  ( subscribers . size (  )   =  =  0 )   {  make done = true ;   subscription helper . cancel ( upstream )  ;   }  synchronized  ( this )   {   map <  long c >  bufs = buffers ;  if  ( bufs  =  =  null )   {  return ;   }  queue . offer ( buffers . remove ( idx )  )  ;   }  if  ( make done )   {  done = true ;   }  drain (  )  ;   }  
public   (  class < t >  configuration class url xsd stream source  class loader loader )  throws jaxb exception  {  super ( configuration class xsd stream source loader )  ;   }  
private boolean   ( int len long expires )  {  if  (    max bytes per second  <  =  0 )  return true ;     lock . lock (  )  ;  try  {  int wait count = 0 ;  while  ( true )   {  long now =    context . clock (  )  . now (  )  ;  if  ( wait count  >  0 && expires  >  0 && expires  <  now )   {     context . stat manager (  )  . add rate data ( "client . send dropped" len 0 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " dropping "  +  len  +  " byte msg expired in queue" )  ;  return false ;   }  long period = now  -     send period begin time ;  if  ( period  >  =  2000 )   {     send period bytes = len ;     send period begin time = now ;  if  (    log . should log (  log . debug )  )     log . debug ( " new period after idle  "  +  len  +  " bytes" )  ;  return true ;   }  if  ( period  >  =  1000 )   {  if  (    send period bytes  >  0 &&  (  (    send period begin time  /  1000 )  & 0x01 )   =  =  0 )     send period bytes +  = len  -     max bytes per second ;  else    send period bytes = len ;     send period begin time +  = 1000 ;  if  (    log . should log (  log . debug )  )     log . debug ( " new period  "  +  len  +  " bytes" )  ;  return true ;   }  if  (    send period bytes  +  len  <  =     max bytes per second )   {     send period bytes +  = len ;  if  (    log . should log (  log . debug )  )     log . debug ( " sending "  +  len  +  "   elapsed " +  period +  "ms  total " +     send period bytes +  " bytes" )  ;  return true ;   }  if  ( wait count  >  =  2 )   {     context . stat manager (  )  . add rate data ( "client . send dropped" len 0 )  ;  if  (    log . should log (  log . warn )  )     log . warn ( " dropping "  +  len  +  " byte msg after waiting " +  wait count +  " times" )  ;  return false ;   }     context . stat manager (  )  . add rate data ( "client . send throttled"  +  + wait count 0 )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " throttled "  +  len  +  " bytes  wait #" +  wait count +  ' ' +   ( 1000  -  period )  +  "ms" )  ;  try  {     lock . new condition (  )  . await ( 1000  -  period  time unit . milliseconds )  ;   }  catch  (   interrupted exception ie )   {   }   }   }  finally  {     lock . unlock (  )  ;   }   }  
public void   (  )  {     is running = false ;   }  
public  string   (  )  {  return title ;   }  
public http header   (  string name )  {  int n headers = getn headers (  )  ;  for  ( int n = 0 ;  n  <  n headers ;  n +  +  )   {  http header header = get header ( n )  ;   string header name = header . get name (  )  ;  if  ( header name . equals ignore case ( name )   =  =  true )  return header ;   }  return null ;   }  
private  imap list   ( char opening char closing )  throws io exception   messaging exception  {  expect ( opening )  ;  final  imap list list = new  imap list (  )  ;  parse elements ( list closing )  ;  expect ( closing )  ;  return list ;   }  
private void   (  remote host id from udp packet reader .  peer test reader test info long nonce  peer test state state )  {   peer state charlie ;   router info charlie info = null ;  int sz = from . getip (  )  . length ;  boolean isi pv6 = sz  =  =  16 ;  if  ( state  =  =  null )   {  charlie =    transport . pick test peer ( charlie isi pv6 from )  ;   }  else  {  charlie =    transport . get peer state ( new  remote host id ( state . get charlieip (  )  . get address (  )  state . get charlie port (  )  )  )  ;   }  if  ( charlie  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to pick a charlie  ( no peer )   i pv6 ?  "  +  isi pv6 )  ;  return ;   }  charlie info =    context . net db (  )  . lookup router info locally ( charlie . get remote peer (  )  )  ;  if  ( charlie info  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to pick a charlie  ( no ri )   i pv6 ?  "  +  isi pv6 )  ;  return ;   }   inet address aliceip = null ;   session key alice intro key = null ;  try  {  aliceip =  inet address . get by address ( from . getip (  )  )  ;  alice intro key = new  session key ( new byte[ session key . keysize   bytes] )  ;  test info . read intro key ( alice intro key . get data (  )  0 )  ;   router address raddr =    transport . get target address ( charlie info )  ;  if  ( raddr  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to pick a charlie  ( no addr )   i pv6 ?  "  +  isi pv6 )  ;  return ;   }  udp address addr = new udp address ( raddr )  ;  byte[] ikey = addr . get intro key (  )  ;  if  ( ikey  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to pick a charlie  ( no ikey )   i pv6 ?  "  +  isi pv6 )  ;  return ;   }   session key charlie intro key = new  session key ( ikey )  ;  long now =    context . clock (  )  . now (  )  ;  boolean is new = false ;  if  ( state  =  =  null )   {  is new = true ;  state = new  peer test state ( bob isi pv6 nonce now )  ;   }  else  {  if  ( state . get receive alice time (  )   >  now  -   ( resend   timeout  /  2 )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " too soon  not retransmitting: "  +  state )  ;  return ;   }   }  state . set aliceip ( aliceip )  ;  state . set alice port ( from . get port (  )  )  ;  state . set alice intro key ( alice intro key )  ;  state . set charlieip ( charlie . get remoteip address (  )  )  ;  state . set charlie port ( charlie . get remote port (  )  )  ;  state . set charlie intro key ( charlie intro key )  ;  state . set last send time ( now )  ;  state . set receive alice time ( now )  ;  if  ( state . increment packets relayed (  )   >  max   relayed   per   test   bob )   {  if  (    log . should log (  log . warn )  )     log . warn ( " too many  not retransmitting: "  +  state )  ;  return ;   }  if  ( is new )   {     active tests . put (  long . value of ( nonce )  state )  ;     context . simple timer2 (  )  . add event ( new  remove test ( nonce )  max   charlie   lifetime )  ;   }  udp packet packet =    packet builder . build peer test to charlie ( aliceip from . get port (  )  alice intro key nonce charlie . get remoteip address (  )  charlie . get remote port (  )  charlie . get current cipher key (  )  charlie . get currentmac key (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " receive from  alice: "  +  state )  ;     transport . send ( packet )  ;   }  catch  (   unknown host exception uhe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " unable to build the aliceip from "  +  from uhe )  ;     context . stat manager (  )  . add rate data ( "udp . test badip" 1 )  ;   }   }  
private void   (  string lang  string jid )  {  xmpp session . increment client packet count (  )  ;   string builder sb = new  string builder ( 250 )  ;  sb . append ( " < open " )  ;  if  ( jid  !  =  null )   {  sb . append ( "to = '" )  . append ( jid )  . append ( "' " )  ;   }  sb . append ( "from = '" )  . append ( xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  )  . append ( "' " )  ;  sb . append ( "id = '" )  . append ( xmpp session . get streamid (  )  . to string (  )  )  . append ( "' " )  ;  sb . append ( "xmlns = '" )  . append ( framing   namespace )  . append ( "' " )  ;  sb . append ( "xml:lang = '" )  . append ( lang )  . append ( "' " )  ;  sb . append ( "version = '1 . 0' /  > " )  ;  deliver ( sb . to string (  )  )  ;   }  
@ test public void   (  )  {  final  binary file iterator <  integer >  bb iter = m map backed iterator factory . get integer iterator (  ( int )  bin file . length (  )   bin file )  ;   assert . assert equals ( bb iter . get header bytes (  )  header as
public void   (  string name int value )  {  set argument value ( name  integer . to string ( value )  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   flowable . from iterable (  arrays . as list ( 1 2 3 )  )  . take ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer 
@ override public int   ( byte[] b int off int len )  throws io exception  {  check for closed stream (  )  ;  return normalize buffer read length ( shared buffer . get ( b off len )  )  ;   }  
public void   (  )  {  previous contribution = current contribution ;  current contribution = get linear data (  rtp packet . packet   period )  ;   }  
@ override public boolean   (  )  {  return pos  <  mod count . length ;   }  
@ test public void   (  )  {   single <  integer >  observable =  flowable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . single ( 2 )  ;   single 
public boolean   (  object obj )  {  if  ( 0  <  =  index of ( obj )  )  return false ;  return super . add ( obj )  ;   }  
static void   (  class <  ?  >  clazz )  {  for  (   method m : clazz . get methods (  )  )   {  if  ( m . get declaring class (  )   =  =  clazz )   {  if  (  ( m . get modifiers (  )  &  modifier . static )   =  =  0 )   {  if  (  ( m . get modifiers (  )  &  (  modifier . public |  modifier . final )  )   =  =   modifier . public )   {  fail ( " not final: "  +  m )  ;   }   }   }   }   }  
@ override public void   (  )  throws  illegal state exception  {  super . start (  )  ;  info handler . set server node info provider ( namespace this )  ;  items handler . set server node info provider ( namespace this )  ;  add default commands (  )  ;
private url   (  string resource name )  {  try  {  return new url ( resource name )  ;   }  catch  (   malformedurl exception murle )   {  log . trace ( " unable to build url for resource  it is a configuration file" murle )  ;   }  return null ;   }  
public  list <  string >    (  string username )  throws  service exception  {   user user = get and check user ( username )  ;   collection <  group >  groups =  group manager . get instance (  )  . get groups ( user )  ;   list <  string >  group names = new  array list <  string >  (  )  ;  for  (   group group : groups )   {  group names . add ( group . get name (  )  )  ;   }  return group names ;   }  
public  map <  string  string[] >    (  )  {  return success configuration loadinginformation ;   }  
private  number   ( int pos )  {   object obj = map . get ( pos )  ;  if  ( obj  =  =  null )   {  if  (  ! map . contains key ( pos )  )   {  throw new  illegal argument exception (  string . format ( " parameter at %d does not exist" pos )  )  ;   }  return null ;   }  if  ( obj instanceof  number )   {  return  (  number ) obj ;   }  else  {  throw new  illegal argument exception (  string . format ( " parameter at %d is not a number but %s" pos obj . get class (  )  )  )  ;   }   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  if  ( t  =  =  1 )   {  ps . on complete (  )  ;  dispose (  )  ;   }   }  
@ test public void   (  )  {   observable <  string >  o =  observable . from iterable (  arrays .  <  string > as list ( "one" "two" "three" )  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  o . subscribe ( observer )  ;  v
public  string   ( int tunnel )  {  return get property ( tunnel "i2cp . access list" "" )  . replace ( " " "\n" )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
public   (  )  {  super ( " rayo: xep 0327  -   public" )  ;   }  
@ override public void   (  throwable e )  {  e . print stack trace (  )  ;  cdl . count down (  )  ;   }  
@ test public void   (  )  {   replay processor <  object >  as =  replay processor . create (  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . get throwable (  )  )  ;  as . on complete 
public void   (  )  {  run client (    class name    client name    args    ctx    log    thread group    cl )  ;   }  
 router info   (  )  {   sig type type = get sig type config ( get context (  )  )  ;   router info info = new  router info (  )  ;   output stream fos1 = null ;  try  {  info . set addresses ( get context (  )  . comm system (  )  . create addresses (  )  )  ;  info . set published ( get current publish date ( get context (  )  )  )  ;   object keypair[] = get context (  )  . key generator (  )  . generatepki keypair (  )  ;   public key pubkey =  (  public key ) keypair[0] ;   private key privkey =  (  private key ) keypair[1] ;   simple data structure signing keypair[] = get context (  )  . key generator (  )  . generate signing keys ( type )  ;   signing public key signing pub key =  (  signing public key ) signing keypair[0] ;   signing private key signing priv key =  (  signing private key ) signing keypair[1] ;   router identity ident = new  router identity (  )  ;   certificate cert = create certificate ( get context (  )  signing pub key )  ;  ident . set certificate ( cert )  ;  ident . set public key ( pubkey )  ;  ident . set signing public key ( signing pub key )  ;  byte[] padding ;  int pad len =  signing public key . keysize   bytes  -  signing pub key . length (  )  ;  if  ( pad len  >  0 )   {  padding = new byte[pad len] ;  get context (  )  . random (  )  . next bytes ( padding )  ;  ident . set padding ( padding )  ;   }  else  {  padding = null ;   }  info . set identity ( ident )  ;   properties stats = get context (  )  . stat publisher (  )  . publish statistics ( ident . get hash (  )  )  ;  info . set options ( stats )  ;  info . sign ( signing priv key )  ;  if  (  ! info . is valid (  )  )  throw new  data format exception ( " router info we just built is invalid: "  +  info )  ;   ( new  file ( get context (  )  . get router dir (  )  keys   filename )  )  . delete (  )  ;   file ifile = new  file ( get context (  )  . get router dir (  )  info   filename )  ;  fos1 = new  buffered output stream ( new  secure file output stream ( ifile )  )  ;  info . write bytes ( fos1 )  ;   file kfile = new  file ( get context (  )  . get router dir (  )  keys2   filename )  ;   private key file pkf = new  private key file ( kfile pubkey signing pub key cert privkey signing priv key padding )  ;  pkf . write (  )  ;   map <  string  string >  map = new  hash map <  string  string >  ( 2 )  ;  byte rk[] = new byte[32] ;  get context (  )  . random (  )  . next bytes ( rk )  ;  map . put (  router . prop   ib   random   key  base64 . encode ( rk )  )  ;  get context (  )  . random (  )  . next bytes ( rk )  ;  map . put (  router . prop   ob   random   key  base64 . encode ( rk )  )  ;  get context (  )  . router (  )  . save config ( map null )  ;  get context (  )  . key manager (  )  . set keys ( pubkey privkey signing pub key signing priv key )  ;  if  (    log . should log (  log . info )  )     log . info ( " router info created and stored at "  +  ifile . get absolute path (  )   +  " with private keys stored at " +  kfile . get absolute path (  )  +  " [" +  info +  "]" )  ;  get context (  )  . router (  )  . event log (  )  . add event (  event log . rekeyed ident . calculate hash (  )  . to base64 (  )  )  ;   }  catch  (   general security exception gse )   {     log . log (  log . crit " error building the new router information" gse )  ;   }  catch  (   data format exception dfe )   {     log . log (  log . crit " error building the new router information" dfe )  ;   }  catch  (  io exception ioe )   {     log . log (  log . crit " error writing out the new router information" ioe )  ;   }  finally  {  if  ( fos1  !  =  null )  try  {  fos1 . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  return info ;   }  
@ test public void   (  )  {   observable .  <  integer > error ( new  test exception (  )  )  . do after next ( after next )  . subscribe with ( to )  . assert failure (  test exception . class )  ;  assert true ( values . is empty (  )  )  ;   }  
@ test public void   (  )  {   scheduler pool factory . shutdown (  )  ;   scheduler pool factory . shutdown (  )  ;   scheduler pool factory . try start ( false )  ;  assert null (  scheduler pool factory . purge   thread . get (  )  )  ;   scheduler poo
private  node   ( int err code )  {  return create fault response node ( err code u pnp status . code2 string ( err code )  )  ;   }  
public   (  publisher < t >  source  function <  ?  super t  ?  extends  publisher <  ?  extends r >  >  mapper int prefetch  error mode error mode )  {  this . source = source ;  this . mapper = mapper ;  this . prefetch = prefetch ;  this . error mode = error mode ;   }  
public static  string   (  string subdomain  string name  string default value )  {  final  string value = get property ( subdomain name )  ;  if  ( value  !  =  null )   {  return value ;   }  else  {  return default value ;   }   }  
public void   (  string name  string description  string group long periods[] )  {  if  ( ignore stat ( name )  )  return ;  create required rate stat ( name description group periods )  ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write boolean ( out authenticated )  ;   }  
public int   (  )  {  return get socket (  )  . get local port (  )  ;   }  
public  optional <  type >    (  type container type )  {  return get config (  jdbi collectors . class )  . find element type for ( container type )  ;   }  
public   ( i2p app context context )  {     log = context . log manager (  )  . get log ( dsa engine . class )  ;     context = context ;   }  
@ test public void   (  )  throws  exception  {   system . gc (  )  ;   thread . sleep ( 100 )  ;  long start =  management factory . get memorymx bean (  )  . get heap memory usage (  )  . get used (  )  ;  source =  observable . from callable ( new  cal
public void   ( final  four channel intensity data noise )  {  this . noise = noise ;   }  
public synchronized void   (  )  {  if  ( stop )  return ;  stop = true ;  locked   halt (  )  ;   thread t = thread ;  if  ( t  !  =  null )   {  t . interrupt (  )  ;  thread = null ;   }   }  
public void   (  string s )  {  super . cancel request ( s )  ;   call handler other call = this . other call ;  this . other call = null ;  if  ( other call  !  =  null )   {   logger . println ( "other call is "  +  other call . get call participant (  )  )  ;  other call . cancel request ( " bridged  call ended" )  ;   }   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  if  ( 1  /  v  <  0 )   {   system . out . println ( " shou
@ test public void   (  )  throws  throwable  {   callable <  observable <  string >  >  factory = mock (  callable . class )  ;   observable <  string >  first observable =  observable . just ( "one" "two" )  ;   observable <  string >  second observable
public void   ( int tunnel quantity )  {     tunnel quantity out = tunnel quantity ;   }  
public void   ( long when )  {     expiration = when ;   }  
public  string   ( int tunnel )  {  return    helper . get lease set signing private key ( tunnel )  ;   }  
public i channel   (  )  {  return channel ;   }  
public   (  group group )  {  this . group = group ;   }  
protected void   (  create lease set message message )  {  if  (  ( message . get lease set (  )   =  =  null )  ||  ( message . get private key (  )   =  =  null )  ||  ( message . get signing private key (  )   =  =  null )  )   {  if  (    log . should log (  log . error )  )     log . error ( " null lease set granted: "  +  message )  ;     runner . disconnect client ( " invalid  create lease set message" )  ;  return ;   }   session id id = message . get session id (  )  ;   session config cfg =    runner . get config ( id )  ;  if  ( cfg  =  =  null )   {   list <  session id >  current =    runner . get session ids (  )  ;   string msg = " create lease set invalid session: "  +  id  +  " current: " +  current ;  if  (    log . should log (  log . error )  )     log . error ( msg )  ;     runner . disconnect client ( msg )  ;  return ;   }   destination dest = cfg . get destination (  )  ;   destination ndest = message . get lease set (  )  . get destination (  )  ;  if  (  ! dest . equals ( ndest )  )   {  if  (    log . should log (  log . error )  )     log . error ( " different destination in ls" )  ;     runner . disconnect client ( " different destination in ls" )  ;  return ;   }   lease set keys keys =    context . key manager (  )  . get keys ( dest )  ;  if  ( keys  =  =  null ||  ! message . get private key (  )  . equals ( keys . get decryption key (  )  )  )   {   public key pk ;  try  {  pk = message . get private key (  )  . to public (  )  ;   }  catch  (   illegal argument exception iae )   {  if  (    log . should log (  log . error )  )     log . error ( " bad private key in ls" )  ;     runner . disconnect client ( " bad private key in ls" )  ;  return ;   }  if  (  ! pk . equals ( message . get lease set (  )  . get encryption key (  )  )  )   {  if  (    log . should log (  log . error )  )     log . error ( " private / public crypto key mismatch in ls" )  ;     runner . disconnect client ( " private / public crypto key mismatch in ls" )  ;  return ;   }     context . key manager (  )  . register keys ( dest message . get signing private key (  )  message . get private key (  )  )  ;   }  else if  (  ! message . get signing private key (  )  . equals ( keys . get revocation key (  )  )  )   {     context . key manager (  )  . register keys ( dest message . get signing private key (  )  message . get private key (  )  )  ;   }  try  {     context . net db (  )  . publish ( message . get lease set (  )  )  ;   }  catch  (   illegal argument exception iae )   {  if  (    log . should log (  log . error )  )     log . error ( " invalid leaseset from client" iae )  ;     runner . disconnect client ( " invalid leaseset: "  +  iae )  ;  return ;   }  if  (    log . should log (  log . info )  )     log . info ( " new lease set granted for destination "  +  dest )  ;     runner . lease set created ( message . get lease set (  )  )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . switch map maybe (  functions . just function (  maybe . never (  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
public  string   (  )  {  return get header value ( http . connection )  ;   }  
public boolean   ( jid jid )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( is   user   listed )  ;  pstmt . set string ( 1 transport type . to string (  )  )  ;  pstmt . set string ( 2 jid . get node (  )  )  ;  rs = pstmt . execute query (  )  ;  rs . next (  )  ;  return  ( rs . get int ( 1 )   >  0 )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return false ;   }  
public  version   (  )  {  return version ;   }  
public static final  boolean[]   ( int tile )  {  switch  ( tile )   {  case 1: return s   1   0001   filter ;  case 2: return s   1   0002   filter ;  case 3: return s   1   0003   filter ;  case 4: return s   1   0004   filter ;   }  throw new  runtime exception ( " you shouldn't reach this statement ! " )  ;   }  
public  data form   (  )  {  return data form ;   }  
public void   (  string email address )  {  m email address = email address ;   }  
@ test public void   (  )  {  final  string query = "b = 4&c = 111&a = 1&a = 2&a = 3&d = 441" ;  final  string actual = query string normalizer . normalize ( query )  ;  final  string[] query param pairs = actual . split ( "&" )  ;  assert equals ( "uri n
@ override public  bundle   (  account authenticator response response  account account  bundle options )  {  return null ;   }  
@ test public void   (  )  {   flowable . create ( new  flowable on subscribe <  object >  (  )  {  @ override public void subscribe (   flowable emitter <  object >  s )  throws  exception  {  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  s . on next ( 
public  inet socket address   (  )  {  return addressa    ;   }  
@ test public void   (  )  {  final int[] calls =  { 0 }  ;   flowable <  integer >  o = new  connectable flowable <  integer >  (  )  {  @ override public void connect (   consumer <  ?  super  disposable >  connection )  {  calls[0] +  +  ;   }  @ overr
public void   ( int proto int port )  {  throw new  unsupported operation exception ( " use  muxed impl" )  ;   }  
  (  string cfgstr )  {  this . cfgstr = cfgstr ;   }  
private void   ( http request http req )  {  if  ( http req . issoap action (  )   =  =  true )   {  soap action recieved ( http req )  ;  return ;   }  http req . return bad request (  )  ;   }  
@ override public void   (  )  {  probe presences ( service )  ;   }  
private boolean   ( int id )  throws io exception  {  if  ( id  <  1 || id  >  6 )   {  return false ;   }  final int[] pnm   formats =  { format   pbm format   pgm format   ppm }  ;  format = pnm   formats[ ( id  -  1 )  % 3] ;  boolean has pixel resolution = false ;   string s ;  while  ( true )   {  s = read line (  )  ;  if  ( s  !  =  null )   {  s = s . trim (  )  ;   }  if  ( s  =  =  null || s . length (  )   <  1 )   {  continue ;   }  if  ( s . char at ( 0 )   =  =  '#' )   {  if  ( collect comments && s . length (  )   >  1 )   {  add comment ( s . substring ( 1 )  )  ;   }  continue ;   }  if  (  ! has pixel resolution )   {  int space index = s . index of ( ' ' )  ;  if  ( space index  =  =   - 1 )   {  return false ;   }   string width string = s . substring ( 0 space index )  ;  space index = s . last index of ( ' ' )  ;  if  ( space index  =  =   - 1 )   {  return false ;   }   string height string = s . substring ( space index  +  1 )  ;  try  {  width =  integer . parse int ( width string )  ;  height =  integer . parse int ( height string )  ;   }  catch  (   number format exception nfe )   {  return false ;   }  if  ( width  <  1 || height  <  1 )   {  return false ;   }  if  ( format  =  =  format   pbm )   {  bits per pixel = 1 ;  return true ;   }  has pixel resolution = true ;   }  else  {  int max sample ;  try  {  max sample =  integer . parse int ( s )  ;   }  catch  (   number format exception nfe )   {  return false ;   }  if  ( max sample  <  0 )   {  return false ;   }  for  ( int i = 0 ;  i  <  25 ;  i +  +  )   {  if  ( max sample  <   ( 1  <  <   ( i  +  1 )  )  )   {  bits per pixel = i  +  1 ;  if  ( format  =  =  format   ppm )   {  bits per pixel* = 3 ;   }  return true ;   }   }  return false ;   }   }   }  
public static  string   ( final byte[] dgst   raw final  string key   type final int key   size final  string prefix final boolean unicode final boolean html )  {  final  string augmentation   string = unicode  ?  u   augmentation   string : a   augmentation   string ;  final char box   top = unicode  ?  u   box   top : a   box   top ;  final char box   bottom = unicode  ?  u   box   bottom : a   box   bottom ;  final char box   left = unicode  ?  u   box   left : a   box   left ;  final char box   right = unicode  ?  u   box   right : a   box   right ;  final char box   tl = unicode  ?  u   box   tl : a   box   tl ;  final char box   tr = unicode  ?  u   box   tr : a   box   tr ;  final char box   bl = unicode  ?  u   box   bl : a   box   bl ;  final char box   br = unicode  ?  u   box   br : a   box   br ;  final  string nl =  system . get property ( "line . separator" )  ;  final int dgst   raw   len = dgst   raw . length ;  final byte[][] field = new byte[fldsize   x][fldsize   y] ;  final byte[][] color = new byte[fldsize   x][fldsize   y] ;  final int len = augmentation   string . length (  )   -  1 ;  int prefix   len = 0 ;  if  ( prefix  !  =  null )  prefix   len = prefix . length (  )  ;  int x = fldsize   x  /  2 ;  int y = fldsize   y  /  2 ;  for  ( int i = 0 ;  i  <  dgst   raw   len ;  i +  +  )   {  int input ;  input = dgst   raw[i] ;  for  ( int b = 0 ;  b  <  4 ;  b +  +  )   {  x +  =  (  ( input & 0x1 )   !  =  0 )   ?  1 :  - 1 ;  y +  =  (  ( input & 0x2 )   !  =  0 )   ?  1 :  - 1 ;  x =  math . max ( x 0 )  ;  y =  math . max ( y 0 )  ;  x =  math . min ( x fldsize   x  -  1 )  ;  y =  math . min ( y fldsize   y  -  1 )  ;  if  (  ( field[x][y] & 0xff )   <  len  -  2 )  field[x][y] +  +  ;  color[x][y] =  ( byte ) i ;  input = input  >  >  2 ;   }   }  field[fldsize   x  /  2][fldsize   y  /  2] =  ( byte )  ( len  -  1 )  ;  field[x][y] =  ( byte ) len ;  final  string size   txt ;  if  ( key   size  >  0 )  size   txt =  string . format ( " %4d" key   size )  ;  else size   txt = "" ;   string builder retval = new  string builder ( 1024 )  ;  long base = 0 ;  if  ( html )   {  int clen =  math . min ( 3 dgst   raw   len )  ;  byte[] cbase = new byte[clen] ;  for  ( int i = 0 ;  i  <  clen ;  i +  +  )   {  cbase[i] =  ( byte )  (  ( dgst   raw[i] & 0xff )  * 5  /  8 )  ;   }  base =  data helper . from long ( cbase 0 clen )  ;  retval . append ( " < font color = \"#" )  . append ( get color ( base 0 )  )  . append ( "\" >  < pre > \n" )  ;   }  if  ( prefix   len  >  0 )  retval . append (  string . format ( "%s"  +  box   tl  +  box   top +  box   top +  "[%4s%s]" prefix key   type size   txt )  )  ;  else retval . append (  string . format ( ""  +  box   tl  +  box   top +  box   top +  "[%4s%s]" key   type size   txt )  )  ;  for  ( int i = 0 ;  i  <  fldsize   x  -   math . max ( key   type . length (  )  4 )   -  9 ;  i +  +  )  retval . append ( box   top )  ;  retval . append ( box   tr )  ;  retval . append ( nl )  ;  if  ( prefix   len  >  0 )   {  retval . append ( prefix )  ;   }  for  ( y = 0 ;  y  <  fldsize   y ;  y +  +  )   {  retval . append ( box   left )  ;  for  ( x = 0 ;  x  <  fldsize   x ;  x +  +  )   {  int idx =  math . min ( field[x][y] len )  ;  if  ( html && idx  !  =  0 )  retval . append ( " < span style = \"color: #" )  . append ( get color ( base color[x][y] & 0xff )  )  . append ( "\" > " )  ;  retval . append ( augmentation   string . char at ( idx )  )  ;  if  ( html && idx  !  =  0 )  retval . append ( " <  / span > " )  ;   }  retval . append ( box   right )  ;  retval . append ( nl )  ;  if  ( prefix   len  >  0 )   {  retval . append ( prefix )  ;   }   }  retval . append ( box   bl )  ;  for  ( int i = 0 ;  i  <  fldsize   x ;  i +  +  )  retval . append ( box   bottom )  ;  retval . append ( box   br )  ;  retval . append ( nl )  ;  if  ( html )  retval . append ( " <  / pre >  <  / font > \n" )  ;  return retval . to string (  )  ;   }  
@ override public  set <  illumina data type >    (  )  {  return supported   types ;   }  
public void   (  )  {   device list dev list = get device list (  )  ;  int dev cnt = dev list . size (  )  ;   device dev[] = new  device[dev cnt] ;  for  ( int n = 0 ;  n  <  dev cnt ;  n +  +  )  dev[n] = dev list . get device ( n )  ;  for  ( int n = 0 ;  n  <  dev cnt ;  n +  +  )   {  if  ( dev[n] . is expired (  )   =  =  true )   {   debug . message ( " expired device  =  "  +  dev[n] . get friendly name (  )  )  ;  remove device ( dev[n] )  ;   }   }   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . parallel (  )  . do on subscribe ( new  consumer <  subscription >  (  )  {  @ override public void accept (   subscription s )  throws  exception  {  throw new  test exception (  )  ;   }   }   )
@ override protected  flowable processor <  object >    (  )  {  return  async processor . create (  )  ;   }  
public boolean   (  )  {  if  ( next element  =  =  null )   {  next element = get next element (  )  ;  if  ( next element  =  =  null )   {  return false ;   }   }  return true ;   }  
@ check return value @ non null public static  < t >  maybe subject < t >    (  )  {  return new  maybe subject < t >  (  )  ;   }  
private void   (  )  throws io exception  {  add treatment ( "silence . 100ms . au" )  ;   }  
@ override public void   (  )  {  lazy set ( true )  ;  upstream . cancel (  )  ;  parent . remove ( this )  ;   }  
public int   (  )  {  return size ;   }  
private void   ( boolean locked )  {  if  ( locked )   {  this . locked time =  system . current time millis (  )  ;   }  else  {  this . locked time = 0 ;   }  muc persistence manager . update room lock ( this )  ;   }  
public  set <  map .  entry <  string  statistic >  >    (  )  {  return statistics . entry set (  )  ;   }  
@ test public void   (  )  {  int num msgs =    options . get inbound buffer size (  )   /     options . get max message size (  )  ;  byte orig[] = new byte[   options . get inbound buffer size (  ) ] ;     context . random (  )  . next bytes ( orig )  ;
private   (  )  {  throw new  illegal state exception ( " no instances ! " )  ;   }  
private  string   (  parameter parameter )  {  return  string . format ( "%s constructor parameter %s" constructor . get declaring class (  )  . get simple name (  )  parameter . get name (  )  )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public void   (  object output out )  throws io exception  {  room . write external ( out )  ;   }  
public void   ( long end timestamp )  {  this . end timestamp = end timestamp ;   }  
@ override public v   ( k key v value )  {  list . remove ( key )  ;  v v ;  if  ( max size  >  0 && list . size (  )   =  =  max size )   {  k k = list . get ( 0 )  ;  list . remove ( 0 )  ;  v = map . remove ( k )  ;   }  else  {  v = null ;   }  list .
public static void   ( final sam record record final  reference sequence file walker ref seq walker final boolean is bisulfite sequence )  {  final byte[] reference bases = ref seq walker . get ( record . get reference index (  )  )  . get bases (  )  ;   sequence util . calculate md and nm tags ( record reference bases true  ! is bisulfite sequence )  ;  if  ( is bisulfite sequence )   {  record . set attribute ( sam tag . nm . name (  )   sequence util . calculate sam nm tag ( record reference bases 0 is bisulfite sequence )  )  ;   }  fix uq ( record ref seq walker is bisulfite sequence )  ;   }  
public static  string   (  )  {  return sip config . preferred video codec ;   }  
private void   (  )  {  final long[] high quality coverage histogram array = new long[coverage cap  +  1] ;  int zero coverage targets = 0 ;  long total coverage = 0 ;  long max depth = 0 ;  final int[] target bases depth =  { 0 1 2 10 20 30 40 50 100 }  ;  final int[] target bases = new int[target bases depth . length] ;  for  (  final  coverage c : this . high quality coverage by target . values (  )  )   {  if  (  ! c . has coverage (  )  )   {  zero coverage targets +  +  ;  high quality coverage histogram array[0] +  = c . interval . length (  )  ;  target bases[0] +  = c . interval . length (  )  ;  continue ;   }  for  (  final int depth : c . get depths (  )  )   {  total coverage +  = depth ;  high quality coverage histogram array[ math . min ( depth coverage cap ) ] +  +  ;  max depth =  math . max ( max depth depth )  ;  for  ( int i = 0 ;  i  <  target bases depth . length ;  i +  +  )   {  if  ( depth  >  =  target bases depth[i] )  target bases[i] +  +  ;  else break ;   }   }   }  if  ( target bases[0]  !  =  high quality coverage by target . key set (  )  . stream (  )  . map to int (  interval::length )  . sum (  )  )   {  throw new  picard exception ( "the number of target bases with at least 0x coverage does not equal the number of target bases" )  ;   }  for  ( int i = 0 ;  i  <  high quality coverage histogram array . length ;   +  + i )   {  high quality depth histogram . increment ( i high quality coverage histogram array[i] )  ;   }  metrics . mean   target   coverage =  ( double ) total coverage  /  metrics . target   territory ;  metrics . median   target   coverage = high quality depth histogram . get median (  )  ;  metrics . max   target   coverage = max depth ;  metrics . fold   80   base   penalty = metrics . mean   target   coverage  /  high quality depth histogram . get percentile ( 0 . 2 )  ;  metrics . zero   cvg   targets   pct = zero coverage targets  /   ( double ) all targets . get intervals (  )  . size (  )  ;  metrics . pct   target   bases   1x =  ( double ) target bases[1]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   2x =  ( double ) target bases[2]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   10x =  ( double ) target bases[3]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   20x =  ( double ) target bases[4]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   30x =  ( double ) target bases[5]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   40x =  ( double ) target bases[6]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   50x =  ( double ) target bases[7]  /   ( double ) target bases[0] ;  metrics . pct   target   bases   100x =  ( double ) target bases[8]  /   ( double ) target bases[0] ;   }  
public   (  )  {   jive globals . migrate property ( "hybrid user property provider . primary provider . class name" )  ;   jive globals . migrate property ( "hybrid user property provider . secondary provider . class name" )  ;   jive globals . migrate property ( "hybrid user property provider . tertiary provider . class name" )  ;  final  user property provider primary =  mapped user property provider . instantiate ( "hybrid user property provider . primary provider . class name" )  ;  if  ( primary  !  =  null )   {  providers . add ( primary )  ;   }  final  user property provider secondary =  mapped user property provider . instantiate ( "hybrid user property provider . secondary provider . class name" )  ;  if  ( secondary  !  =  null )   {  providers . add ( secondary )  ;   }  final  user property provider tertiary =  mapped user property provider . instantiate ( "hybrid user property provider . tertiary provider . class name" )  ;  if  ( tertiary  !  =  null )   {  providers . add ( tertiary )  ;   }  if  ( providers . is empty (  )  )   {   log . error ( " at least one  user property provider must be specified via openfire . xml or the system properties ! " )  ;   }   }  
public void   ( int b )  {  if  ( 0x20  <  =  b && b  <  =  0x7e )   {  m receiving line . append (  ( char ) b )  ;   }  else if  ( b  =  =  '\n' )   {  add receiving line to buffer (  )  ;   }  else if  ( b  =  =  '\r' )   {   }  else  {  final  string hex = "00"  +   integer . to hex string ( b )  ;  m receiving line . append ( "\\x"  +  hex . substring ( hex . length (  )   -  2 hex . length (  )  )  )  ;   }   }  
@ test public void   (  )  {   subscription arbiter sa = new  subscription arbiter (  )  ;  sa . get and increment (  )  ;  sa . requested = 0 ;  sa . missed requested . set ( 1 )  ;  sa . drain loop (  )  ;  assert equals ( 1 sa . requested )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public static void   (  string conference id )  throws  parse exception  {  synchronized  ( conference list )   {   conference manager conference manager = find conference manager ( conference id )  ;  if  ( conference manager . get member list (  )  . size (  )   >  0 )   {  throw new  parse exception ( "can't remove conference: '"  +  conference id  +  "' because there are still calls in progress" 0 )  ;   }  conference manager . set permanent ( false )  ;  conference manager . end (  )  ;   }   }  
public void   ( boolean on )  {  if  ( on  !  =     is choked )   {     is choked = on ;  if  (    log . should warn (  )  )     log . warn ( " choked changed to "  +  on  +  " on " +  this )  ;   }  if  ( on )   {  congestion occurred (  )  ;  get options (  )  . set window size ( 1 )  ;   }   }  
@ test public void   (  )  {   test observer <  void >  to =  completable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  completable source >  (  )  { 
public void   (  string resource name )  {  watch map . remove ( resource name )  ;   }  
public   (  certificate store configuration configuration boolean create if absent )  throws  certificate store config exception  {  super ( configuration create if absent )  ;   }  
@ override public synchronized void   (  event < t p >  e )  {  if  (  ! fired )   {  only once ( e )  ;  fired = true ;   }  e . event manager (  )  . squelch ( this event class )  ;   }  
@ test public void   (  )  {   async processor <  integer >  async =  async processor . create (  )  ;  async . on next ( 1 )  ;  async . on complete (  )  ;   flowable processor <  integer >  serial = async . to serialized (  )  ;  assert false ( serial 
@ test public void   (  )  {   completable . never (  )  . hide (  )  . test (  )  . assert not complete (  )  . assert no errors (  )  ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . never (  )  ;  assert same ( o  (  (  (  has upstream observable source <  ?  >  ) o . publish (  )  )  . source (  )  )  )  ;   }  
@ override public synchronized boolean   (  )  {  close ( true )  ;  sock mgr . destroy socket manager (  )  ;  return true ;   }  
@ xml element public boolean   (  )  {  return can occupants change subject ;   }  
@ data provider ( name = " " )  public  object[][] negative test data (  )  {  return new  object[][] {  { new  supported illumina format[] {  bcl  filter }  new  illumina data type[] {  base calls  illumina data type .  quality scores  illumina data type
@ test public void   (  )  {   single . merge delay error (  single . just ( 1 )   single .  <  integer > error ( new  test exception (  )  )   single . just ( 2 )  )  . test (  )  . assert failure (  test exception . class 1 2 )  ;   }  
public void   (  string host )  {     i2cp host =  ( host  !  =  null  ?  host . trim (  )  : null )  ;   }  
public   (  flowable < t >  source  function <  ?  super t  ?  extends  iterable <  ?  extends r >  >  mapper int prefetch )  {  super ( source )  ;  this . mapper = mapper ;  this . prefetch = prefetch ;   }  
private boolean   (  string user agent )  {  if  ( user agent  !  =  null )   {  for  (   pattern pattern : context . get user agent patterns (  )  )   {  if  ( pattern . matcher ( user agent )  . matches (  )  )   {  return context . is include user agent patterns (  )  ;   }   }   }  return  ! context . is include user agent patterns (  )  ;   }  
@ test public void   (  )  {   test subscriber <  object >  ts1 = new  test subscriber <  object >  ( 0l )  ;  final  test subscriber <  object >  ts2 = new  test subscriber <  object >  ( 0l )  ;   flowable . range ( 1  flowable . buffer size (  )  * 2 )
@ test ( data provider = "  data" )  public void test same unclipped5 prime opposite strand ( final  file input )  {  final  abstract mark duplicates command line program tester tester = new  by sum of baseq and in original ordermd tester (  )  ;  final  
@post @ path ( " / group /  { groupname } " )  public  response   ( @ default value ( "conference" )  @ query param ( "servicename" )   string service name @ path param ( "groupname" )   string groupname @ path param ( "room name" )   string room name )  
@ pre destroy public void   (  )  {  configuration service . unsubscribe from ( "container . cfg . xml" configuration listener )  ;   }  
void   (  remote host id from udp packet reader reader )  {  if  (  !  transport util . is valid port ( from . get port (  )  )  ||  !    transport . is valid ( from . getip (  )  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " receive session request from invalid: "  +  from )  ;  return ;   }  boolean is new = false ;   inbound establish state state =    inbound states . get ( from )  ;  if  ( state  =  =  null )   {  if  (  ! should allow inbound establishment (  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " dropping inbound establish  increase "  +  prop   max   concurrent   establish )  ;     context . stat manager (  )  . add rate data ( "udp . establish dropped" 1 )  ;  return ;   }  if  (    context . blocklist (  )  . is blocklisted ( from . getip (  )  )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " receive session request from blocklisted ip: "  +  from )  ;     context . stat manager (  )  . add rate data ( "udp . establish badip" 1 )  ;  return ;   }  if  (  !    transport . allow connection (  )  )  return ;  byte[] fromip = from . getip (  )  ;  state = new  inbound establish state (    context fromip from . get port (  )     transport . get external port ( fromip . length  =  =  16 )     transport . getdh builder (  )  )  ;  state . receive session request ( reader . get session request reader (  )  )  ;  if  (    replay filter . add ( state . get receivedx (  )  0 8 )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( " duplicate x in session request from: "  +  from )  ;     context . stat manager (  )  . add rate data ( "udp . dupdhx" 1 )  ;  return ;   }   inbound establish state old state =    inbound states . put if absent ( from state )  ;  is new = old state  =  =  null ;  if  (  ! is new )  state = old state ;   }  if  ( is new )   {  if  ( state . is introduction requested (  )  &&    transport . can introduce (  )  && state . get sent port (  )   >  =  1024 && state . get sentip (  )  . length  =  =  4 )   {  long tag = 1  +     context . random (  )  . next long ( max   tag   value )  ;  state . set sent relay tag ( tag )  ;   }  else  {   }  if  (    log . should log (  log . info )  )     log . info ( " received new session request "  +  state )  ;   }  else  {  if  (    log . should log (  log . debug )  )     log . debug ( " receive dup session request from: "  +  state )  ;   }  notify activity (  )  ;   }  
@ test public void   (  )  {  int expected = 42 ;  when ( b . available (  )  )  . then return ( expected )  ;  int avail = buffer . available (  )  ;  verify ( b )  . available (  )  ;  assert equals ( expected avail )  ;   }  
public  data structure   (  )  throws  data format exception  {   signing public key public key = new  signing public key (  )  ;  byte data[] = new byte[ signing public key . keysize   bytes] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )  data[i] =  ( byte )  ( i % 16 )  ;  public key . set data ( data )  ;  return public key ;   }  
@ override public void   (  bad to string bad to string )  {   system . out . println ( " on  next" )  ;  fail ( " on next shouldn't be reached" )  ;   }  
private void   (  )  {   list <  def >  def list = new  array list <  def >  (  )  ;  for  (   source source : sources . values (  )  )   {  if  ( source instanceof  def )   {  def list . add (  (  def ) source )  ;   }   }  def sources = def list . to array ( new  def[def list . size (  ) ] )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as flowable ( new  function <  object  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   object v )  throws  exception  {  return  arrays . as list ( 1 2 3 )
public void   (  )  {  if  ( resample count  =  =  0 )   {  return ;   }  double avg =  ( double ) total time  /  resample count ;  long time units per second =  current time . get time units per second (  )  ;  avg =  ( avg  /  time units per second )  * 1000 ;   string s = "" ;  if  ( id  !  =  null )   {  s +  = " call "  +  id  +  ": " ;   }   logger . write file ( s  +  avg  +  "ms avg upsample time from " +  in sample rate +  " / " +  in channels +  " to " +  out sample rate +  " / " +  out channels )  ;  low pass filter . print statistics (  )  ;   }  
protected static  string   (  string s  string p int n )  {  return  messages . get string ( n s p )  ;   }  
@ override public  command[]   (  )  {  return empty   command   array ;   }  
private void   ( final  file input final  file output )  {  final  string[] args =  { "input = "  +  input "output = "  +  output "sort   order = coordinate" }  ;   sort sam sort sam = new  sort sam (  )  ;   assert . assert equals ( sort sam . instance main ( args )  0 " sort did not succeed" )  ;   }  
@ override public void   (  )  {  f . on complete (  )  ;   }  
@ test public void   (  )  {   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  integer >  t1 )  {  t1 . on subscribe ( new  boolean subscription
public  list <  string >    (  string attribute  string search filter int start index int num results  string suffix to trim boolean escapeji ds )  {   list <  string >  results = new  array list <  >  (  )  ;  int page size =  - 1 ;   string page size str = properties . get ( "ldap . paged results size" )  ;  if  ( page size str  !  =  null )   {  try  {  page size =  integer . parse int ( page size str )  ;   }  catch  (   number format exception e )   {   }   }   boolean client side sort = false ;   string client side sort str = properties . get ( "ldap . client side sorting" )  ;  if  ( client side sort str  !  =  null )   {  client side sort =  boolean . value of ( client side sort str )  ;   }   ldap context ctx = null ;   ldap context ctx2 = null ;  try  {  ctx = get context ( basedn )  ;   list <  control >  base tmp request controls = new  array list <  >  (  )  ;  if  (  ! client side sort )   {  base tmp request controls . add ( new  sort control ( new  string[] { attribute }   control . noncritical )  )  ;   }  if  ( page size  >  0 )   {  base tmp request controls . add ( new  paged results control ( page size  control . noncritical )  )  ;   }   control[] base request controls = base tmp request controls . to array ( new  control[base tmp request controls . size (  ) ] )  ;  ctx . set request controls ( base request controls )  ;   search controls search controls = new  search controls (  )  ;  if  ( is sub tree search (  )  )   {  search controls . set search scope (  search controls . subtree   scope )  ;   }  else  {  search controls . set search scope (  search controls . onelevel   scope )  ;   }  search controls . set returning attributes ( new  string[] { attribute }  )  ;  int skip =  - 1 ;  int last res =  - 1 ;  if  (  ! client side sort )   {  if  ( start index  !  =   - 1 )   {  skip = start index ;   }  if  ( num results  !  =   - 1 )   {  last res = start index  +  num results ;   }   }  byte[] cookie ;  int count = 0 ;  do  {  cookie = null ;   naming enumeration <  search result >  answer = ctx . search ( "" search filter search controls )  ;  while  ( answer . has more elements (  )  )   {  count +  +  ;  if  ( skip  >  0 && count  <  =  skip )   {  answer . next (  )  ;  continue ;   }  if  ( last res  !  =   - 1 && count  >  last res )   {  answer . next (  )  ;  break ;   }   string result =  (  string ) answer . next (  )  . get attributes (  )  . get ( attribute )  . get (  )  ;  if  ( suffix to trim  !  =  null && suffix to trim . length (  )   >  0 && result . ends with ( suffix to trim )  )   {  result = result . substring ( 0 result . length (  )   -  suffix to trim . length (  )  )  ;   }  results . add ( escapeji ds  ?  jid . escape node ( result )  : result )  ;   }   control[] controls = ctx . get response controls (  )  ;  if  ( controls  !  =  null )   {  for  (   control control : controls )   {  if  ( control instanceof  paged results response control )   {   paged results response control prrc =  (  paged results response control ) control ;  cookie = prrc . get cookie (  )  ;   }   }   }  answer . close (  )  ;   list <  control >  tmp request controls = new  array list <  >  (  )  ;  if  (  ! client side sort )   {  tmp request controls . add ( new  sort control ( new  string[] { attribute }   control . noncritical )  )  ;   }  if  ( page size  >  0 )   {  tmp request controls . add ( new  paged results control ( page size cookie  control . critical )  )  ;   }   control[] request controls = tmp request controls . to array ( new  control[tmp request controls . size (  ) ] )  ;  ctx . set request controls ( request controls )  ;   }  while  ( cookie  !  =  null &&  ( last res  =  =   - 1 || count  <  =  last res )  )  ;  if  ( alternate basedn  !  =  null &&  ( last res  =  =   - 1 || count  <  =  last res )  )   {  ctx2 = get context ( alternate basedn )  ;  ctx2 . set request controls ( base request controls )  ;  do  {  cookie = null ;   naming enumeration <  search result >  answer = ctx2 . search ( "" search filter search controls )  ;  while  ( answer . has more elements (  )  )   {  count +  +  ;  if  ( skip  >  0 && count  <  =  skip )   {  answer . next (  )  ;  continue ;   }  if  ( last res  !  =   - 1 && count  >  last res )   {  answer . next (  )  ;  break ;   }   string result =  (  string ) answer . next (  )  . get attributes (  )  . get ( attribute )  . get (  )  ;  if  ( suffix to trim  !  =  null && suffix to trim . length (  )   >  0 && result . ends with ( suffix to trim )  )   {  result = result . substring ( 0 result . length (  )   -  suffix to trim . length (  )  )  ;   }  results . add ( escapeji ds  ?  jid . escape node ( result )  : result )  ;   }   control[] controls = ctx2 . get response controls (  )  ;  if  ( controls  !  =  null )   {  for  (   control control : controls )   {  if  ( control instanceof  paged results response control )   {   paged results response control prrc =  (  paged results response control ) control ;  cookie = prrc . get cookie (  )  ;   }   }   }  answer . close (  )  ;   list <  control >  tmp request controls = new  array list <  >  (  )  ;  if  (  ! client side sort )   {  tmp request controls . add ( new  sort control ( new  string[] { attribute }   control . noncritical )  )  ;   }  if  ( page size  >  0 )   {  tmp request controls . add ( new  paged results control ( page size cookie  control . critical )  )  ;   }   control[] request controls = tmp request controls . to array ( new  control[tmp request controls . size (  ) ] )  ;  ctx2 . set request controls ( request controls )  ;   }  while  ( cookie  !  =  null &&  ( last res  =  =   - 1 || count  <  =  last res )  )  ;   }  if  ( client side sort )   {   collections . sort ( results )  ;  if  ( start index  !  =   - 1 || num results  !  =   - 1 )   {  if  ( start index  =  =   - 1 )   {  start index = 0 ;   }  if  ( num results  =  =   - 1 )   {  num results = results . size (  )  ;   }  int end index =  math . min ( start index  +  num results results . size (  )   -  1 )  ;  results = results . sub list ( start index end index )  ;   }   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  try  {  if  ( ctx  !  =  null )   {  ctx . set request controls ( null )  ;  ctx . close (  )  ;   }  if  ( ctx2  !  =  null )   {  ctx2 . set request controls ( null )  ;  ctx2 . close (  )  ;   }   }  catch  (   exception ignored )   {   }   }  return results ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   thread . current thread (  )  . interrupt (  )  ;  try  {  ts . await done ( 5  time unit . seconds )  ;   }  catch  (   runtime exception ex ) 
@ override public int   (  object o1  object o2 )  {  return 0 ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  throws  exception  {  return 1  /  v  >  0 ;   }   }    parallel failure handling .
private boolean   (  )  throws io exception  {  byte[] a = new byte[44] ;  if  ( read ( a )   !  =  a . length )   {  return false ;   }  width = get int little endian ( a 16 )  ;  height = get int little endian ( a 20 )  ;  if  ( width  <  1 || height  <  1 )   {  return false ;   }  bits per pixel = get short little endian ( a 26 )  ;  if  ( bits per pixel  !  =  1 && bits per pixel  !  =  4 && bits per pixel  !  =  8 && bits per pixel  !  =  16 && bits per pixel  !  =  24 && bits per pixel  !  =  32 )   {  return false ;   }  int x =  ( int )  ( get int little endian ( a 36 )  * 0 . 0254 )  ;  if  ( x  >  0 )   {  set physical width dpi ( x )  ;   }  int y =  ( int )  ( get int little endian ( a 40 )  * 0 . 0254 )  ;  if  ( y  >  0 )   {  set physical height dpi ( y )  ;   }  format = format   bmp ;  return true ;   }  
public void   (  )  {  lease set cache . clear (  )  ;  lease cache . clear (  )  ;  synchronized  ( tunnel cache )   {  backlogged tunnel cache . clear (  )  ;  tunnel cache . clear (  )  ;   }  last reply request cache . clear (  )  ;   }  
public void   (  list <  google mail sender >  senders )  {  this . senders = senders ;   }  
default  < t >  result iterable < t >    (  row mapper < t >  mapper )  {  return scan result set (  ( supplier ctx )   -  >   result iterable . of ( supplier mapper ctx )  )  ;   }  
  (  string .  .  .  values )  {  values to return = values ;   }  
public void   ( final  session session )  {   string clients allowed =  jive globals . get property ( "clients . allowed" "all" )  ;  final boolean disconnect if no match =  ! "all" . equals ( clients allowed )  ;  if  ( disconnect if no match )   {  task engine . schedule ( new  timer task (  )  {  @ override public void run (  )  {  request software version ( session )  ;   }   }   5000 )  ;   }   }  
public synchronized boolean   (  )  {  return part  !  =  null ;   }  
public static  uri   (  string type long id )  {  return  uri . parse ( ui uri string ( type id )  )  ;   }  
public void   (  )  throws io exception  {   string domain name = xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;  try  {  if  ( "call" . equals ( cp . get display name (  )  )  && " speaker" . equals ( cp . get protocol (  )  )  )   {  member sender . set channel ( new  speaker channel ( cp . get other call (  )  . get member receiver (  )  )  )  ;   }  set state (  call state . answered )  ;  set endpoint address ( null  ( byte ) 0  ( byte ) 0  ( byte ) 0 )  ;  set state (  call state . established )  ;   }  catch  (   exception e )   {   log . error ( " call "  +  cp  +  ":  speaker call agent: initiate call exception " )  ;  e . print stack trace (  )  ;   }   }  
@ override public boolean   (  )  {  return disposed ;   }  
@ override protected  runnable   ( i2p app context ctx i2p session session )  {  return new  server runner ( ctx session )  ;   }  
private static boolean   (  string dest )  {  return  (  ( dest . length (  )   =  =  min   dest   length && dest . ends with ( "aa" )  )  ||  ( dest . length (  )   >  min   dest   length && dest . length (  )   <  =  max   dest   length )  )  &&  (  ( dest . length (  )  % 4 )   !  =  1 )  && b64   pattern . matcher ( dest )  . matches (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  future <  ?  >  f = ps . single (  - 99 )  . to future (  )
public void   (  control point ctrl point )  {  int n sockets = size (  )  ;  for  ( int n = 0 ;  n  <  n sockets ;  n +  +  )   {  ssdp notify socket sock = getssdp notify socket ( n )  ;  sock . set control point ( ctrl point )  ;   }   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test helper . check disposed ( pp . single element (  )  . contains ( 1 )  )  ;   }  
public long   (  )  {  return stanza . get (  )  ;   }  
public boolean   ( k bucket < nid >  kbucket nid to add )  {  long now =    ctx . clock (  )  . now (  )  ;  if  ( kbucket . get last changed (  )   >  now  -  min   bucket   age )  return false ;   set < nid >  entries = kbucket . get entries (  )  ;  for  (  nid nid : entries )   {  if  ( nid . last seen (  )   <  now  -  max   node   age )   {  if  ( kbucket . remove ( nid )  )  return true ;   }   }  return entries . size (  )   <     max ;   }  
@ override public  connection   (  )  throws sql exception  {  if  ( data source  =  =  null )   {  throw new sql exception ( " data source has not been initialized . " )  ;   }  return data source . get connection (  )  ;   }  
static long   (  router context context )  {  return context . clock (  )  . now (  )  ;   }  
@ override @ transactional ( propagation =  propagation . requires   new )  public void   (  callback c )  {  c . call ( jdbi )  ;   }  
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write boolean ( out originator )  ;   externalizable util . get instance (  )  . write safeutf ( out room name )  ;   externalizable util 
@ xml element public boolean   (  )  {  return login restricted to nickname ;   }  
public   (  keyed stack lock update lock  object update key )  {  this . update lock = update lock ;  this . update key = update key ;   }  
static  format information   ( int masked format info1 int masked format info2 )  {   format information format info = do decode format information ( masked format info1 masked format info2 )  ;  if  ( format info  !  =  null )   {  return format info ;   }  return do decode format information ( masked format info1 ^ format   info   mask   qr masked format info2 ^ format   info   mask   qr )  ;   }  
public  notification < t >    (  )  throws  interrupted exception  {  set waiting (  )  ;   blocking helper . verify non blocking (  )  ;  return buf . take (  )  ;   }  
@ override public void   ( t value )  {   completable source cs ;  try  {  cs =  object helper . require non null ( mapper . apply ( value )  " the mapper returned a null  completable source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if
@ override public void   (  transformer exception te )  {  throw exception   log . new exception ( stock   error   msg  +  te . get message and location (  )  te  runtime exception . class )  ;   }  
@ override public void   (  drop target drag event drop target drag event )  {  drop target drag event . accept drag (  dnd constants . action   copy   or   move )  ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  flowable <  integer >  >  ts = pp . 
  ( t t )  {  this . t = t ;   }  
@ test public void   (  )  throws io exception  {  run analysis ( "with   intervals" "intervals = "  +  intervals )  ;   }  
@ override public void   (  observer <  ?  super t >  s )  {  if  ( once . compare and set ( false true )  )   {  s . on subscribe ( this )  ;  actual . lazy set ( s )  ;  if  ( cancelled . get (  )  )   {  actual . lazy set ( null )  ;   }  else  {  drai
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  ps . test ( true )  ;  assert false ( ps . has observers (  )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public static  < t >  flowable < t >    (  publisher <  ?  extends t >  source1  publisher <
public  string   (  )  {  return " process  reply for  kademlia  search" ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   observable <  integer >  m = source . skip until (  observable . empty (  )  )  ;  m . subscribe ( observer )  ;  verify ( observer never (  )  )  . 
public   (  observable source < t >  source  predicate <  ?  super t >  predicate )  {  super ( source )  ;  this . predicate = predicate ;   }  
@ override public sql warning   (  )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  string >  func = mock (  callable . class )  ;  final  count down latch func latch = new  count down latch ( 1 )  ;  final  count down latch observer latch 
public void   ( long when )  {     last sent to successfully = when ;   }  
public static  set <  string >    (  document web xml  string filter name )  {  return get url patterns ( "filter" web xml filter name )  ;   }  
public void   ( http request listener listener )  {  int n servers = size (  )  ;  for  ( int n = 0 ;  n  <  n servers ;  n +  +  )   {  http server server = gethttp server ( n )  ;  server . add request listener ( listener )  ;   }   }  
private int   (  )  {  int i = b ;  b +  +  ;  return i ;   }  
public boolean   (  )  {  http server thread = null ;  return true ;   }  
public  map .  entry <  string  read ends for mark duplicates >    (  )  {  try  {  final  string key = read ends for mark duplicates codec . get input stream (  )  . readutf (  )  ;  final  read ends for mark duplicates record = read ends for mark duplicates codec . decode (  )  ;  return new  abstract map .  simple entry < java . lang .  string  read ends for mark duplicates >  ( key record )  ;   }  catch  (  io exception e )   {  throw new  picard exception ( " error loading  read ends for mark duplicates map from disk" e )  ;   }   }  
public void   ( int boot id )  {  set header ( http . bootid   upnp   org boot id )  ;   }  
boolean   (  )  {  return debug ;   }  
@ test public void   (  )  {  final  atomic integer atomic integer = new  atomic integer ( 0 )  ;   completable . error ( new  runtime exception (  )  )  . do on event ( new  consumer <  throwable >  (  )  {  @ override public void accept (  final  throwa
public int   (  router info us )  {  int ct = 0 ;   status status = ctx . comm system (  )  . get status (  )  ;  switch  ( status )   {  case ok: case ipv4   unknown   ipv6   ok: case ipv4   firewalled   ipv6   ok: case ipv4   snat   ipv6   ok: case ipv4   snat   ipv6   unknown: case ipv4   firewalled   ipv6   unknown: case ipv4   unknown   ipv6   firewalled: case ipv4   ok   ipv6   firewalled: case different: case reject   unsolicited:  collection <  router address >  at = us . get addresses (  )  ;  if  ( at . is empty (  )  )  return 0 ;  ct = get connect mask ( at )  ;  break ;  case ipv4   disabled   ipv6   ok: case ipv4   disabled   ipv6   unknown: case ipv4   disabled   ipv6   firewalled: if  (  ! isntcp disabled (  )  )  ct| = ntcp   v6 ;  if  (  ! isssu disabled (  )  )  ct| = ssu   v6 ;  break ;  case ipv4   ok   ipv6   unknown: case disconnected: case hosed: case unknown: default : if  (  ! isntcp disabled (  )  )  ct| = ntcp   v4 ;  if  (  ! isssu disabled (  )  )  ct| = ssu   v4 ;  break ;   }  return ct ;   }  
@ override public void   (  observer <  ?  super u >  t )  {  source . subscribe ( new  map observer < t u >  ( t function )  )  ;   }  
@ override public void   (  )  {  disposed = true ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on lifecycle ( new  consumer <  disposable >  (  )  {  @ override public void accept (   disposable s )  {   }   }   null )  ;   }  
public void   (  )  {     counter . clear (  )  ;   }  
@ override public  file visit result   (  path file  basic file attributes attrs )  throws io exception  {  try  {   files . delete if exists ( file )  ;   }  catch  (  io exception e )   {   log . debug ( " plugin removal: could not delete:  {  } " file 
@ override public void   ( long response size )  {  data store . process response size ( response size )  ;   }  
static boolean   (  router context ctx  public key key  hash local int min tag override )  {   session key manager skm = ctx . client manager (  )  . get client session key manager ( local )  ;  if  ( skm  =  =  null )  return true ;   session key cur key = skm . get current key ( key )  ;  if  ( cur key  =  =  null )  return true ;  if  ( min tag override  >  0 )  return skm . should send tags ( key cur key min tag override )  ;  return skm . should send tags ( key cur key )  ;   }  
@ override public boolean   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
public  string   (  )  {  return  router version . full   version ;   }  
@ override public boolean   (  menu item item )  {  switch  ( item . get item id (  )  )   {  case android . r . id . home: on back pressed (  )  ;  break ;  case r . id . feedback   menu   item:  utils . send feedback ( this m feedback uri false )  ;  br
public static boolean   (  string name boolean default value )  {   string value = get property ( name )  ;  if  ( value  !  =  null )   {  return  boolean . value of ( value )  ;   }  else  {  return default value ;   }   }  
public   (  )  {  provider =  user manager . get user provider (  )  ;   }  
@ override public void   (  )  {  s . cancel (  )  ;   }  
public   ( i2p app context ctx )  {     log = ctx . log manager (  )  . get log (  server . class )  ;  if  (  system . get property ( "debug" )   !  =  null )  set debug enabled ( true )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 1 5 )  . observe on (  schedulers . single (  )  )  . test ( 0l )  ;  ts . cancel (  )  ;   }  
@ nullable @ override public t   (  )  throws  exception  {  t v = qs . poll (  )  ;  if  ( v  =  =  null && sync fused )   {  run finally (  )  ;   }  return v ;   }  
public void   (  )  {  if  (  type . user  =  =  type )   {   agent session agent session = null ;  try  {  agent session =  workgroup manager . get instance (  )  . get agent manager (  )  . get agent ( invitee )  . get agent session (  )  ;   }  catch  (   agent not found exception e )   {   }  if  ( true )   {  sendmuc invitiation (  )  ;  offer accepted =  system . current time millis (  )  ;   }  else  {   workgroup workgroup = agent session . get workgroups (  )  . iterator (  )  . next (  )  ;   request queue request queue = workgroup . get request queues (  )  . iterator (  )  . next (  )  ;  get meta data (  )  . put ( "agent"  arrays . as list ( invitee . to string (  )  )  )  ;  get meta data (  )  . put ( "ignore"  arrays . as list ( inviter . to barejid (  )  )  )  ;  request queue . get dispatcher (  )  . inject request ( this )  ;   }   }  else if  (  type . queue  =  =  type )   {   workgroup target workgroup =  workgroup manager . get instance (  )  . get workgroup ( invitee . get node (  )  )  ;  if  ( target workgroup  =  =  null )   {  send error message ( " specified workgroup was not found . " )  ;  return ;   }  try  {   request queue request queue = target workgroup . get request queue ( invitee . get resource (  )  )  ;  get meta data (  )  . put ( "ignore"  arrays . as list ( inviter . to barejid (  )  )  )  ;  request queue . get dispatcher (  )  . inject request ( this )  ;   }  catch  (   not found exception e )   {  send error message ( " specified queue was not found . " )  ;   }   }  else if  (  type . workgroup  =  =  type )   {   workgroup target workgroup =  workgroup manager . get instance (  )  . get workgroup ( invitee . get node (  )  )  ;  if  ( target workgroup  !  =  null )   {   request queue request queue =  routing manager . get instance (  )  . get best queue ( target workgroup user request )  ;  get meta data (  )  . put ( "ignore"  arrays . as list ( inviter . to barejid (  )  )  )  ;  request queue . get dispatcher (  )  . inject request ( this )  ;   }  else  {  send error message ( " specified workgroup was not found . " )  ;   }   }   }  
private static double   ( double x double c double n )  {  return c  /  x  -  1  +   math . exp (  - n  /  x )  ;   }  
public  big integer   (  )  {  return    my public value ;   }  
@ test @ ignore ( " subscribers can't throw" )  public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  atomic reference <  throwable >  exception = new  atomic reference <  throwable > 
public void   (  advertiser adv )  {  advertiser = adv ;   }  
@ override public void   (  http servlet request request  http servlet response response )  throws io exception  {   input stream sis = request . get input stream (  )  ;  byte[] buffer = new byte[1024] ;  int bytes read ;  while  (  ( bytes read = sis . 
public  byte buffer   (  byte buffer net  byte buffer app )  throws ssl exception  {   byte buffer out = app ;  out = resize application buffer ( out )  ;  try  {  tls engine result = tls engine . unwrap ( net out )  ;   }  catch  (  ssl exception e )   {  if  ( e . get message (  )  . starts with ( " unsupported record version  unknown - " )  )   {  throw new ssl exception ( " we appear to have received plain text data where we expected encrypted data .  a common cause for this is a peer sending us a plain - text error message when it shouldn't send a message  but close the socket instead )  . " e )  ;   }  else  {  throw e ;   }   }  log ( "server unwrap: " tls engine result )  ;  if  ( tls engine result . get handshake status (  )   =  =   handshake status . need   task )   {  do tasks (  )  ;   }  return out ;   }  
public static short   ( long l )  {  return  ( short )  ( int )  ( 0x13880l  /   ( l * 4l )  )  ;   }  
@ check return value @ backpressure support (  backpressure kind . error )  @ scheduler support (  scheduler support . none )  public final  < t right t left end t right end r >  flowable < r >    (  publisher <  ?  extends t right >  other  function <  ?
@ override public void   (  )  {  if  ( get and set ( cancelled )   !  =  cancelled )   {  parent . remove ( this )  ;  parent . manage requests (  )  ;   }   }  
void   (  observer <  ?  >  a )  {   throwable ex =  exception helper . terminate ( error )  ;  for  (   unicast subject < t right >  up : lefts . values (  )  )   {  up . on error ( ex )  ;   }  lefts . clear (  )  ;  rights . clear (  )  ;  a . on error ( ex )  ;   }  
public  string   (  snark snark )  {   meta info meta = snark . get meta info (  )  ;   storage storage = snark . get storage (  )  ;  if  ( meta  !  =  null && storage  !  =  null )   {   string reject message = validate torrent ( meta )  ;  if  ( reject message  !  =  null )   {  add message ( reject message )  ;  snark . stop torrent (  )  ;  return null ;   }  save torrent status ( meta storage . get bit field (  )  null storage . get base (  )  storage . get preserve file names (  )  0 snark . is stopped (  )  )  ;   string name = storage . get base name (  )  ;  try  {  name =  ( new  file ( get data dir (  )  storage . get base name (  )   +  " . torrent" )  )  . get canonical path (  )  ;   string announce = snark . get trackerurl (  )  ;  if  ( announce  !  =  null )  meta = meta . reannounce ( announce )  ;  synchronized  (    snarks )   {  locked   write meta info ( meta name are files public (  )  )  ;     snarks . remove ( snark . get name (  )  )  ;     snarks . put ( name snark )  ;   }     magnets . remove ( snark . get name (  )  )  ;  remove magnet status ( snark . get info hash (  )  )  ;  add message no escape (    t ( " starting up torrent  { 0 } " linkify ( snark )  )  )  ;  return name ;   }  catch  (  io exception ioe )   {  add message (    t ( " failed to copy torrent file to  { 0 } " name )  )  ;     log . error ( " failed to write torrent file" ioe )  ;   }   }  return null ;   }  
public void   ( boolean deliver payloads )  {  this . deliver payloads = deliver payloads ;   }  
public static  < t >  row mapper < t >    (  class < t >  type  string prefix )  {  return new  field mapper <  >  ( type prefix )  ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 100 2 100 )  )  . filter (  functions . always true (  )  )  . test ( 5l )  . assert failure (  test exception . class 0 )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final int[] call =  { 0 }  ;   completable . complete (  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  throws  exception  {  call[0] +  +  
public double[]   (  string key  time period time period )  {   stat definition def = engine . get definition ( key ) [0] ;  long last time = def . get last sample time (  )  ;  return def . get min ( time period . get start time ( last time )  last time )  ;   }  
public  session manager   (  )  {  return  (  session manager ) modules . get (  session manager . class )  ;   }  
@ override public  input stream   (  )  throws io exception  {  return new  byte array input stream ( source array )  ;   }  
@ override protected void   (  )  {  handle . close (  )  ;  jdbi = null ;   }  
public   (  observable < t >  upstream  consumer <  ?  super  disposable >  on subscribe  action on dispose )  {  super ( upstream )  ;  this . on subscribe = on subscribe ;  this . on dispose = on dispose ;   }  
private   (  extensions that )  {  factories . add all ( that . factories )  ;   }  
@ override public  string   (  )  {  return  downsample sam . class . get simple name (  )  ;   }  
public  tunnel id   ( int hop )  {  return    config[hop] . get send tunnel (  )  ;   }  
@ override public int   (  )  {  return user   idle ;   }  
@ test public void   (  )  {  final int[] count =  { 0 }  ;   flowable . range ( 1 5 )  . parallel ( 2 )  . concat map delay error ( new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   integer v
@ test public void   (  )  throws  exception  {  final  file output dir =  files . create temp directory ( "picard revert sam test" )  . to file (  )  ;  output dir . delete on exit (  )  ;  final  string args[] = new  string[1] ;  args[0] = " -  - help" 
private void   (  string name  string value boolean is encrypted )  {   encryptor encryptor = get encryptor (  )  ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( insert   property )  ;  pstmt . set string ( 1 name )  ;  pstmt . set string ( 2 is encrypted  ?  encryptor . encrypt ( value )  : value )  ;  pstmt . set int ( 3 is encrypted  ?  1 : 0 )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public int   (  )  {  return  ( start  /  range )   +  1 ;   }  
@ override public void   (  throwable e )  {  throw new  test exception (  )  ;   }  
public synchronized long   (  )  {  return    period ;   }  
public void   ( long now )  {  last seen = now ;   }  
@ override public void   (  consumer <  ?  super  disposable >  connection )  {  boolean do connect ;   publish observer < t >  ps ;  for  (  ;   ;   )   {  ps = current . get (  )  ;  if  ( ps  =  =  null || ps . is disposed (  )  )   {   publish observe
@ test public void   (  )  {   test helper . check double on subscribe maybe ( new  function <  maybe <  integer >   maybe <  integer >  >  (  )  {  @ override public  maybe <  integer >  apply (   maybe <  integer >  f )  throws  exception  {  return f .
  (  subscriber <  ?  super  long >  actual )  {  this . actual = actual ;   }  
static void   ( sq lite database db )  {   string s = "  ( "  +   quick response columns .    id  +  " integer primary key autoincrement  " +   quick response columns . text +  " text  " +   quick response columns . account   key +  " integer" +  " )  ; " ;  db . execsql ( "create table "  +   quick response . table   name  +  s )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on each (  (  consumer <  notification <  integer >  >  ) null )  ;   }  
private void   (  private event event  document document )  {  document . add element ( new q name ( "private" namespace )  )  ;   }  
public void   (  )  {   monitoring plugin plugin =  (  monitoring plugin ) xmpp server . get instance (  )  . get plugin manager (  )  . get plugin (  monitoring constants . name )  ;   conversation manager conversation manager =  (  conversation manager ) plugin . get module (  conversation manager . class )  ;  for  (   conversation event event : events )   {  try  {  event . run ( conversation manager )  ;   }  catch  (   exception e )   {   log . error ( " error while processing chat archiving event" e )  ;   }   }   }  
public static void   ( byte[] byte data int byte data offset int byte data length int[] int data )  {  int in ix = byte data offset ;  for  ( int i = 0 ;  i  <  int data . length ;  i +  +  )   {  short s =  ( short )  (  (  ( byte data[in ix]  <  <  8 )  & 0xff00 )  |  ( byte data[in ix  +  1] & 0xff )  )  ;  int data[i] =  ( int ) s ;  in ix +  = 2 ;   }   }  
public  constructor bean   (  string query )  {  return db rule . get shared handle (  )  . create query ( query )  . map to (  constructor bean . class )  . find only (  )  ;   }  
@ override public void   (  throwable e )  {   single source <  ?  extends t >  source ;  try  {  source =  object helper . require non null ( next function . apply ( e )  " the next function returned a null  single source . " )  ;   }  catch  (   throwab
@ override public void   (  dialog interface dialog int which )  {  dialog . cancel (  )  ;   }  
private boolean   (  message message  chatbot session session )  {   string command = message . get body (  )  . trim (  )  ;  if  ( get help command (  )  . equals ignore case ( command )  )   {  send help message ( message )  ;  return true ;   }  else if  ( get bye command (  )  . equals ignore case ( command )  )   {  user depart queue ( message )  ;  return true ;   }  if  ( session . get current step (  )   =  =  1 )   {  if  ( get repeat command (  )  . equals ignore case ( command )  )   {  send join question ( message session )  ;  return true ;   }  else if  ( get position command (  )  . equals ignore case ( command )  )   {  send reply ( message get not in queue message (  )  )  ;  return true ;   }   }  else if  ( session . get current step (  )   =  =  2 )   {  if  ( get back command (  )  . equals ignore case ( command )  )   {  send previous question ( message session )  ;  return true ;   }  else if  ( get repeat command (  )  . equals ignore case ( command )  )   {  repeat question ( message session )  ;  return true ;   }  else if  ( get position command (  )  . equals ignore case ( command )  )   {  send reply ( message get not in queue message (  )  )  ;  return true ;   }   }  else if  ( session . get current step (  )   =  =  3 )   {  if  ( get position command (  )  . equals ignore case ( command )  )   {  try  {   user request request =  user request . get request ( workgroup message . get from (  )  )  ;  request . update queue status ( true )  ;   }  catch  (   not found exception e )   {  send reply ( message get not in queue message (  )  )  ;   }  return true ;   }   }  else if  ( session . get current step (  )   =  =  6 )   {  if  ( get repeat command (  )  . equals ignore case ( command )  )   {  send email question ( message . get from (  )  session )  ;  return true ;   }   }  else if  ( session . get current step (  )   =  =  7 )   {  if  ( get repeat command (  )  . equals ignore case ( command )  )   {  send get email question ( message session )  ;  return true ;   }   }  return false ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c =  completable . merge array delay error ( normal . completable )  ;  c . blocking await (  )  ;  normal . assert subscriptions ( 1 )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
static void   (  )  {  synchronized  ( i2p app context . class )   {     global app context = null ;   }   }  
private int   (  http client http client  http request base http method proxy request  http servlet response response )  throws io exception   http exception  {  try  {   http response http response = http client . execute ( http method proxy request )  ;  int response code = http response . get status line (  )  . get status code (  )  ;   http component response processor response processor = new  http component response processor ( http response response response code )  ;  if  ( response code  >  =   http servlet response . sc   multiple   choices && response code  <   http servlet response . sc   not   modified )   {  response processor . send translated redirect ( response code )  ;   }  else  {  response processor . process (  )  ;   }  return response code ;   }  catch  (   client protocol exception ex )   {  if  (  throwables . get root cause ( ex )  instanceof  read limit reached exception )   {  log . error ( " error reading request content" ex )  ;  response . send error (  http servlet response . sc   request   entity   too   large " error reading request content" )  ;   }  else  {  log . error ( " error processing outgoing request" ex )  ;  return  - 1 ;   }   }  return 1 ;   }  
public  string   (  )  {   string buffer str = new  string buffer (  )  ;  str . append ( get status line string (  )  )  ;  str . append ( get header string (  )  )  ;  str . append ( http . crlf )  ;  return str . to string (  )  ;   }  
@ override public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ override public  callable statement   (  connection conn  string sql  statement context ctx )  throws sql exception  {  return conn . prepare call ( sql )  ;   }  
public void   (  input stream in )  throws  data format exception  io exception  {     gateway =  hash . create ( in )  ;     tunnel id = new  tunnel id (  )  ;     tunnel id . read bytes ( in )  ;     end =  data helper . read date ( in )  ;   }  
  (  cached worker pool pool )  {  this . pool = pool ;  this . tasks = new  composite disposable (  )  ;  this . thread worker = pool . get (  )  ;   }  
@ override public void   (  )  {   subscription helper . cancel ( this )  ;   }  
@ experimental @ check return value @ scheduler support (  scheduler support . none )  public final  < r > r   ( @ non null  observable converter < t  ?  extends r >  converter )  {  return  object helper . require non null ( converter "converter is null"
public  string   (  )  {  return " features  component" ;   }  
public static  checksum exception   (  throwable cause )  {  return is stack trace  ?  new  checksum exception ( cause )  : instance ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public boolean   ( int tunnel )  {  return    helper . get delay open ( tunnel )  ;   }  
@ test public void   (  )  {  assert equals ( 0  string uri utilities . index of uri fragment ( " / v1" " / v1" )  )  ;  assert equals ( 0  string uri utilities . index of uri fragment ( " / v1 / " " / v1" )  )  ;   }  
@ test public void   (  )  {   flowable . error ( new  test exception (  )  )  . on error return item ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  final  single subject <  integer >  ms1 =  single subject . create (  )  ;  final  single subject <  integer >  ms2 =  single subject . create (  )  ;   t
@ override public void   (  session session )  {  remove session ( session )  ;   }  
public void   ( t t )  {  long r = get (  )  ;  if  ( r  =  =   long . min   value )   {  return ;   }  if  ( r  !  =  0l )   {  actual . on next ( t )  ;   backpressure helper . produced cancel ( this 1 )  ;   }  else  {  cancel (  )  ;  actual . on error ( new  missing backpressure exception ( " could not emit value due to lack of requests" )  )  ;   }   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . window ( 1  time unit . days  schedulers . single (  )  2 true )  . test (  )  . assert subscribed (  )  . assert error (  test exception . class )  . assert not complete (
@ override public synchronized void   (  field f )  {  super . set field ( f )  ;  mask =  big integer . one . shift left ( f . getb (  )   -  1 )  . subtract (  big integer . one )  ;   }  
@ test ( expected =  unsupported operation exception . class )  public void   (  )  {  q . offer ( 1 2 )  ;   }  
@ test public void   (  )  throws  document exception  io exception  {  logger . finest ( "test import user" )  ;   in exporter testobject = new  xep227 exporter ( "server name" offline messages store v card manager private storage user manager roster ite
public  list <  agent chat session >    (  )  {  return agent list ;   }  
private  short   (  byte bytes[] )  {  if  (  array extensions . get length ( bytes )  . int value (  )   <  4 )  return  short . value of (  ( short )  - 1 )  ;  else return  bit assistant . to short network ( bytes  integer . value of ( 2 )  )  ;   }  
@ test public void   (  )  {  final  publish processor <  integer >  source =  publish processor . create (  )  ;  final  test subscriber <  integer >  tsw = new  test subscriber <  integer >  (  )  {  boolean once ;  @ override public void on next (   in
@ test public void   (  )  {  assert that ( parse string ( "insert into foo  ( xyz )  values  ( :bar\\:\\:some   strange   type ) " )  )  . is equal to ( "insert into foo  ( xyz )  values  (  ? ::some   strange   type ) " )  ;   }  
@ test public void   (  )  {   subscription s = mock (  subscription . class )  ;   disposables . from subscription ( s )  . dispose (  )  ;  verify ( s )  . cancel (  )  ;  verify ( s never (  )  )  . request ( any int (  )  )  ;   }  
public static void   ( final double num variants final long interval base count final  genotype concordance counts counter )  {  final double count missing missing = interval base count  -  num variants ;  final  truth and call states missing missing = new  truth and call states (  truth state . missing  call state . missing )  ;  counter . increment ( missing missing count missing missing )  ;   }  
@ test public void   (  )  throws  exception  {  run standard test ( 1 "multiplexed barcode . " "barcode . params" 1 "25t8b25t" basecalls   dir test   data   dir )  ;   }  
@ override public void   (  )  {  if  (  ! done )   {  done = true ;  buffer . complete (  )  ;  replay final (  )  ;   }   }  
public long   (  )  {  return request input bytes ;   }  
@ test public void   (  )  throws  exception  {  try  ( final  handle h = db . open handle (  )  )  {  assert that thrown by (  (  )   -  >  h . execute ( "select * from something where id  =  any ( :ids ) "  collections . singleton ( 1 )  )  )  . is inst
private void   (  string[] args )  throws  ticker exception  {  for  ( int i = 0 ;  i  <  args . length ;  i +  +  )   {  if  ( args[i] . equals ignore case ( " - t" )  )   {  i +  +  ;  time period = get int arg ( args i )  ;   }  else if  ( args[i] . equals ignore case ( " - d" )  )   {  i +  +  ;  duration = get int arg ( args i )  ;   }  else if  ( args[i] . equals ignore case ( " - s" )  )   {  i +  +  ;  stat frequency = get int arg ( args i )  ;   }  else if  ( args[i] . equals ignore case ( " - c" )  )   {  i +  +  ;  if  ( i  >  =  args . length )   {  usage (  )  ;   }  ticker class name = args[i] ;   }  else  {  usage (  )  ;   }   }  if  ( time period  =  =  0 )   {  time period = 20 ;   }  if  ( duration  =  =  0 )   {  duration = 10 ;   }  if  ( stat frequency  =  =  0 )   {  stat frequency = 200 ;   }  if  ( ticker class name  =  =  null )   {  ticker class name = "com . sun . voip .  ticker sleep" ;   }   ticker factory ticker factory =  ticker factory . get instance (  )  ;  ticker = ticker factory . create ticker ( ticker class name " ticker test" )  ;   }  
public static  group element   ( final  curve curve final  field element x final  field element y final  field element z final  field element t )  {  return new  group element ( curve  representation . p3 x y z t )  ;   }  
@ test public void   (  )  {  assert that ( new  big integer field element ( ed25519 field  big integer . zero )  is ( equal to ( zero )  )  )  ;  assert that ( new  big integer field element ( ed25519 field  big integer . value of ( 1000 )  )  is ( equal
public   (  string hoststxt )  {   file dummy = new  file ( " / dev / null" )  ;  this . etags file = dummy ;  this . last modified file = dummy ;  this . last fetched file = dummy ;  this . delay = 0 ;  this . proxy host = "127 . 0 . 0 . 1" ;  this . proxy port = 4444 ;   subscription sub = new  subscription ( "file:"  +  hoststxt null null null )  ;  this . subscriptions =  collections . singleton list ( sub )  ;   }  
private void   (  )  {  try  {   string context = "agent selector . " ;   string class name = get property ( context  +  "class name" )  ;  if  ( class name  =  =  null )   {  return ;   }   class agent selector class = load class ( class name )  ;  agent selector =  (  agent selector ) agent selector class . new instance (  )  ;   collection <  string >  props = get children property names ( context  +  "properties" get property names (  )  )  ;   map <  string  string >  agent selector props = new  hash map <  string  string >  (  )  ;  for  (   string key : props )   {   string value = get property ( key )  ;  agent selector props . put ( key . substring ( key . last index of ( " . " )   +  1 )  value )  ;   }   bean utils . set properties ( agent selector agent selector props )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  
@ override public void   (  throwable t )  {   disposable helper . dispose ( this )  ;  actual . on error ( t )  ;   }  
@ override public void   (  )  {   system . out . println ( " completed" )  ;  completed . set ( true )  ;   }  
private iq   ( iq iq )  {  final iq reply packet ;  if  ( iq  =  =  null )   {  throw new  illegal argument exception ( " argument 'iq' cannot be null . " )  ;   }  final iq .  type type = iq . get type (  )  ;  if  ( type  !  =  iq .  type . get && type  !  =  iq .  type . set )   {  throw new  illegal argument exception ( " argument 'iq' must be of type 'get' or 'set'" )  ;   }  final  element child element = iq . get child element (  )  ;  if  ( child element  =  =  null )   {  reply packet = iq . create resultiq ( iq )  ;  reply packet . set error ( new  packet error (  condition . bad   request org . xmpp . packet .  packet error .  type . modify "iq stanzas of type 'get' and 'set' must contain one and only one child element  ( rfc 3920 section 9 . 2 . 3 )  . " )  )  ;  return reply packet ;   }  final  string namespace = child element . get namespaceuri (  )  ;  if  ( namespace  =  =  null )   {  reply packet = iq . create resultiq ( iq )  ;  reply packet . set error (  condition . feature   not   implemented )  ;  return reply packet ;   }  if  ( namespace . equals ( namespace   jabber   iq   search )  )   {  reply packet = handle search request ( iq )  ;   }  else if  ( namespace . equals ( iq disco info handler . namespace   disco   info )  )   {  reply packet = handle disco info ( iq )  ;   }  else if  ( namespace . equals ( iq disco items handler . namespace   disco   items )  )   {  reply packet = iq . create resultiq ( iq )  ;  reply packet . set child element ( "query" iq disco items handler . namespace   disco   items )  ;   }  else  {  reply packet = iq . create resultiq ( iq )  ;  reply packet . set error (  condition . feature   not   implemented )  ;   }  return reply packet ;   }  
@ test public void   (  )  {   observable <  string >  w =  observable . empty (  )  ;   observable <  string >  skip = w . skip ( 1 )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  skip . subscribe ( observer )  ;  verify ( o
@ override public void   (  )  throws  exception  {  number of subscribe calls . increment and get (  )  ;  if  ( atomic integer . decrement and get (  )   !  =  0 )   {  throw new  runtime exception (  )  ;   }   }  
@ test public void   (  )  {   test scheduler sch = new  test scheduler (  )  ;   replay processor <  integer >  source =  replay processor . create with time ( 1  time unit . milliseconds sch )  ;  source . on next ( 1 )  ;  sch . advance time by ( 2  ti
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   observable . error ( new  test exception (  )  )  . delay ( 1  time unit . milliseconds scheduler )  . subscribe ( new  disposable observer <  object >  (  )  {  @ ove
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  ts . on subscribe ( new  boolean subscription (  )  )  ;   queue drain <  integer  integer >  qd = new  queue drain <  integer  integer >  (  )  
@ override public void   (  session data session data  element command )  {   element note = command . add element ( "note" )  ;   map <  string  list <  string >  >  data = session data . get data (  )  ;   string wg name = get ( data "name" 0 )  ;   str
public int   ( long account id )  {  return m account color array . get resource id ( get account color index ( account id )  undefined   resource   id )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout ( 1  time unit . seconds null just1 )  ;   }  
@ setup public void   (  )  {   integer[] source array = new  integer[count] ;   arrays . fill ( source array 777 )  ;   flowable <  integer >  source =  flowable . from array ( source array )  ;  flowable plain = source . concat map ( new  function <  in
@ test public void   (  )  {   list <  something >  result = db rule . get shared handle (  )  . create query ( select   by   name )  . bind ( "name"  validation . invalid ( "eric" )  )  . map to bean (  something . class )  . list (  )  ;  assert that ( 
private long   ( long time )  {  return time  /  1000 ;   }  
@ override public void   (  test observer <  integer >  f )  throws  exception  {  throw new  illegal argument exception (  )  ;   }  
@ test public void   (  )  {   maybe . empty (  )  . switch if empty (  single .  <  integer > error ( new  test exception (  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
private static byte[]   ( byte[] source )  {  int len58 ;  if  ( source . length  <  =  1 )  len58 = source . length ;  else len58 = source . length * 5  /  8 ;  byte[] out buff = new byte[len58] ;  int out buff posn = 0 ;  int usedbits = 0 ;  for  ( int i = 0 ;  i  <  source . length ;  i +  +  )   {  int fivebits ;  if  (  ( source[i] & 0x80 )   !  =  0 || source[i]  <  '2' || source[i]  >  'z' )  fivebits = bad   encoding ;  else fivebits = decodabet[source[i]  -  '2'] ;  if  ( fivebits  >  =  0 )   {  if  ( usedbits  =  =  0 )   {  out buff[out buff posn] =  ( byte )  (  ( fivebits  <  <  3 )  & 0xf8 )  ;  usedbits = 5 ;   }  else if  ( usedbits  <  3 )   {  out buff[out buff posn]| =  ( fivebits  <  <   ( 3  -  usedbits )  )  & dmask[usedbits] ;  usedbits +  = 5 ;   }  else if  ( usedbits  =  =  3 )   {  out buff[out buff posn +  + ]| = fivebits ;  usedbits = 0 ;   }  else  {  out buff[out buff posn +  + ]| =  ( fivebits  >  >   ( usedbits  -  3 )  )  & dmask[usedbits] ;  byte next =  ( byte )  ( fivebits  <  <   ( 11  -  usedbits )  )  ;  if  ( out buff posn  <  len58 )   {  out buff[out buff posn] = next ;  usedbits -  = 3 ;   }  else if  ( next  !  =  0 )   {  return null ;   }   }   }  else  {  return null ;   }   }  return out buff ;   }  
public static double   ( long start )  {  double elapsed = get time (  )   -  start ;  return elapsed  /  time units per second ;   }  
@ override public void   (  throwable t )  {  s =  disposable helper . disposed ;  item = null ;  actual . on error ( t )  ;   }  
public  tunnel id   (  )  {  return    to tunnel ;   }  
@ suppress warnings ( "unchecked" )  public void   ( iq packet muc role role )  throws  forbidden exception   conflict exception   cannot be invited exception   not acceptable exception  {  if  ( muc role .  affiliation . owner  !  =  role . get affiliati
  (  string name )  {  this . name = name ;   }  
@ test public void   (  )  throws  exception  {  fo . on next ( 1 )  ;  fo . on complete (  )  ;  fo . on complete (  )  ;  assert equals ( 1 fo . get ( 5  time unit . milliseconds )  . int value (  )  )  ;   }  
public   (  map <  string  ?  >  args )  {  this . args = args ;   }  
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  )  {  return cache with initial capacity ( 16 )  ;   }  
public void   (  )  {  set first line ( "" )  ;  clear headers (  )  ;  set content ( new byte[0] false )  ;  set content input stream ( null )  ;   }  
public void   (  string val )  {     cert signer = val ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  last time = scheduler . now ( unit )  ;  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public static int   ( final byte[] read final byte[] adapter sequence final int min match final double max error rate )  {  if  ( read  =  =  null || read . length  <  min match )  return no   match ;  final int min clip position = 0 ;  read   loop: for  ( int start = read . length  -  min match ;  start  >  min clip position  -  1 ;   -  - start )   {  final int length =  math . min ( read . length  -  start adapter sequence . length )  ;  final int mismatches allowed =  ( int )  ( length * max error rate )  ;  int mismatches = 0 ;  for  ( int i = 0 ;  i  <  length ;   +  + i )   {  if  (  !  sequence util . is no call ( adapter sequence[i] )  &&  !  sequence util . bases equal ( adapter sequence[i] read[start  +  i] )  &&  +  + mismatches  >  mismatches allowed )   {  continue read   loop ;   }   }  return start ;   }  return no   match ;   }  
public  list <  naming service >    (  )  {  return null ;   }  
@ test public void   (  )  {   flowable . range ( 1 0 )  ;   }  
private boolean   (  )  {  if  (    packet . get ack time (  )   >  0 )  return false ;  if  (    reset sent on . get (  )   >  0 ||    reset received . get (  )  ||    final disconnect . get (  )  )   {     packet . cancelled (  )  ;  return false ;   }  boolean resend = false ;  boolean is lowest = false ;  synchronized  (    outbound packets )   {  if  (    packet . get sequence num (  )   =  =     highest acked through  +  1 ||    packet . get num sends (  )   >  1 ||    active resends . get (  )   <   math . max ( 3  (    options . get window size (  )   +  1 )   /  2 )  )  is lowest = true ;  if  (    outbound packets . contains key (  long . value of (    packet . get sequence num (  )  )  )  )  resend = true ;   }  if  (  ( resend )  &&  (    packet . get ack time (  )   <  =  0 )  )   {  boolean fast retransmit =  (  (    packet . getnac ks (  )   >  =  fast   retransmit   threshold )  &&  (    packet . get num sends (  )   =  =  1 )  )  ;  if  (  (  ! is lowest )  &&  (  ! fast retransmit )  )   {  if  (    log . should log (  log . info )  )     log . info ( " delaying resend of "  +     packet  +  " with " +     active resends +  " active resend  " +     outbound packets . size (  )  +  " unacked  window size  =  " +     options . get window size (  )  )  ;  force reschedule ( 1333 )  ;     next send = 1333  +     context . clock (  )  . now (  )  ;  return false ;   }  if  ( fast retransmit )     context . stat manager (  )  . add rate data ( "stream . fast retransmit"    packet . get lifetime (  )     packet . get lifetime (  )  )  ;  if  (    is choking )   {     packet . set optional delay (  packet . send   delay   choke )  ;     packet . set flag (  packet . flag   delay   requested )  ;   }  else if  (    unchokes to send . decrement and get (  )   >  0 )   {     packet . set optional delay ( 0 )  ;     packet . set flag (  packet . flag   delay   requested )  ;   }  else  {     packet . set flag (  packet . flag   delay   requested false )  ;   }     packet . set resend delay ( get options (  )  . get resend delay (  )   /  1000 )  ;  if  (    packet . get receive stream id (  )   <  =  0 )     packet . set receive stream id (    receive stream id . get (  )  )  ;  if  (    packet . get send stream id (  )   <  =  0 )     packet . set send stream id (    send stream id . get (  )  )  ;  int new window size = get options (  )  . get window size (  )  ;  if  (    is choked )   {  congestion occurred (  )  ;  get options (  )  . set window size ( 1 )  ;   }  else if  (    ack since congestion . get (  )  )   {  if  (    packet . get sequence num (  )   >     last congestion highest unacked )   {  congestion occurred (  )  ;     context . stat manager (  )  . add rate data ( "stream . con . window size at congestion" new window size    packet . get lifetime (  )  )  ;  new window size /  = 2 ;  if  ( new window size  <  =  0 )  new window size = 1 ;  get options (  )  . doublerto (  )  ;  get options (  )  . set window size ( new window size )  ;  if  (    log . should log (  log . info )  )     log . info ( " congestion  resending packet "  +     packet . get sequence num (  )   +  "  ( new window size " +  new window size +  " / " +  get options (  )  . get window size (  )  +  " )  for " +   connection . this . to string (  )  )  ;  window adjusted (  )  ;   }   }  int num sends =    packet . get num sends (  )   +  1 ;  if  ( num sends  -  1  >     options . get max resends (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " disconnecting  too many resends of "  +     packet )  ;     packet . cancelled (  )  ;  disconnect ( false )  ;   }  else if  ( num sends  >  =  3 &&    packet . is flag set (  packet . flag   close )  &&    packet . get payload size (  )   <  =  0 &&    outbound packets . size (  )   <  =  1 && get close received on (  )   >  0 )   {  if  (    log . should log (  log . info )  )     log . info ( " too many close resends  disconnecting: "  +   connection . this . to string (  )  )  ;     packet . cancelled (  )  ;  disconnect ( true )  ;   }  else  {  long rto =    options . getrto (  )  ;  if  ( rto  <  min   resend   delay )  rto = min   resend   delay ;  long timeout = rto  <  <   ( num sends  -  1 )  ;  if  (  ( timeout  >  max   resend   delay )  ||  ( timeout  <  =  0 )  )  timeout = max   resend   delay ;     next send = timeout  +     context . clock (  )  . now (  )  ;  if  (    outbound queue . enqueue (    packet )  )   {  if  ( num sends  =  =  2 )     active resends . increment and get (  )  ;  if  (    log . should log (  log . info )  )     log . info ( " resent packet "  +   ( fast retransmit  ?  " ( fast )  " : " ( timeout )  " )   +     packet +  " next resend in " +  timeout +  "ms" +  " active resends: " +     active resends +  "  ( wsize " +  new window size +  " lifetime " +   (    context . clock (  )  . now (  )   -     packet . get created on (  )  )  +  "ms ) " )  ;     unacked packets received . set ( 0 )  ;     last send time =    context . clock (  )  . now (  )  ;  reset activity timer (  )  ;   }  force reschedule ( timeout )  ;   }  if  (  (    packet . get ack time (  )   >  0 )  &&  (    packet . get num sends (  )   >  1 )  )   {     active resends . decrement and get (  )  ;  synchronized  (    outbound packets )   {     outbound packets . notify all (  )  ;   }   }  return true ;   }  else  {  return false ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . group by ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   null )  ;   }  
@ override public void   (  )  {  parent . inner complete ( this )  ;   }  
public void   (  )  {     running = false ;  if  (    socket  !  =  null )  try  {     socket . close (  )  ;     socket = null ;   }  catch  (  io exception ioe )   {   }   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . filter (  functions . always true (  )  )  . take ( 5 )  . test (  )  . assert result ( 1 2 3 4 5 )  ;   }  
public int   (  )  {  return ds names . length ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flat map single element ( new  function <  integer  single source <  integer >  >  (  )  {  @ override public  single source <  integer >  apply (  final  integer integer )  throws  exception  {  throw 
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . concat eager (  arrays . as list (  flowable . just ( 1 )   flowable . just ( 2 )  )  )  . test (  )  . assert result ( 1 2 )  ;   }  
public void   (  )  {  if  (  !    is running )  return ;  if  (    known nodes . size (  )   >  0 )   ( new i2p app thread ( new  explorer thread (  )  "dht  explore" true )  )  . start (  )  ;  else schedule ( 60 * 1000 )  ;   }  
public int   (  )  {  int conversation count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( conversation   count )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  conversation count = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return conversation count ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . from array ( 1 3 5 6 )  ;   observable <  boolean >  any even = o . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer i )  {  return i % 2  =  =
@ override public  observable <  integer >    (  integer f )  throws  exception  {  return new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  s )  {  s . on subscribe (  disposables . emp
public int   (  )  {  return length ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
public static  date   (  date date )  {  return new  date ( date . get time (  )  )  ;   }  
double   (  )  throws io exception  {  return cached  ?  cache : read double (  )  ;   }  
@ override public  string   (  )  {  return configured rate limit . get id (  )  ;   }  
public   ( int status  string reason int external port )  {  this . status = status ;  this . reason string = reason ;  this . external port = external port ;   }  
@ test public void   (  )  {   test observer <  void >  to =  flowable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  r
@ test public void   (  )  throws  interrupted exception  {  final  serial disposable sd = new  serial disposable (  )  ;   single observer <  string >  ts = new  single observer <  string >  (  )  {  @ override public void on subscribe (   disposable d )
@ override public void   (  disposable s )  {  sa . update ( s )  ;   }  
public  string   (  )  {  return conference answer treatment ;   }  
@ override public void   (  metrics configuration metricsc )  {  shutdown graphite (  )  ;  jmx reporter . stop (  )  ;  if  ( metricsc . get graphite (  )   !  =  null )   {  for  (   graphite server gs : metricsc . get graphite (  )  . get server (  )  
public synchronized  signing private key   (  )  {  return    signing private key ;   }  
public  string   (  )  {  return payload ;   }  
public void   (  string presence status )  {  this . presence status = presence status ;   }  
boolean   (  hash h int over )  {  if  (    max  >  0 )  return this . counter . count ( h )   >     max  +  over ;  return false ;   }  
@ test public void   (  )  {  final  test observer <  void >  to = new  test observer <  void >  (  )  ;   completable . merge delay error (  flowable . just ( new  completable (  )  {  @ override protected void subscribe actual (   completable observer s
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test observer <  void >  to =  completable . merge (  flowable . just ( pp . ignore elements (  )  )  )  . test (  )  ;  assert true ( pp . has subsc
public   (  )  {     id =       id . increment and get (  )  ;   }  
public h   (  )  {  return b ;   }  
void   ( final  observer <  ?  super t >  observer final  composite disposable current base )  {   disposable d = disconnect ( current base )  ;   connection observer s = new  connection observer ( observer current base d )  ;  observer . on subscribe ( s )  ;  source . subscribe ( s )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 )  . parallel (  )  . map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . filter (  f
private boolean   ( long objectid  object data )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( add   queue   agent )  ;  if  (  (  boolean ) data )   {  pstmt . set int ( 1 group   type )  ;   }  else  {  pstmt . set int ( 1 agent   type )  ;   }  pstmt . set long ( 2 objectid )  ;  pstmt . set long ( 3 id )  ;  pstmt . execute update (  )  ;  return true ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }  return false ;   }  
@ test public void   (  )  {   maybe . merge delay error (  maybe . just ( 1 )   maybe . error ( new  test exception (  )  )   maybe . just ( 2 )  )  . test (  )  . assert failure (  test exception . class 1 2 )  ;   maybe . merge delay error (  maybe . e
private void   (  )  {  if  ( close listener  !  =  null )   {  try  {  close listener . on connection close ( session )  ;   }  catch  (   exception e )   {   log . error ( " error notifying listener: "  +  close listener e )  ;   }   }   }  
public void   (  )  {  open = false ;  try  {  ss . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  
@ override protected void   (  subscriber <  ?  super  integer >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  observer . on complete (  )  ;  observer . on next ( 1 )  ;  observer . on error ( new  test exception (  )  )
public long   (  )  {  return read timeout ;   }  
protected  string   (  )  {  final  string property name = type . get prefix (  )   +  "protocols" ;  final  string default value = "" ;  if  ( type . get fallback (  )   =  =  null )   {  return  jive globals . get property ( property name default value )  . trim (  )  ;   }  else  {  return  jive globals . get property ( property name get connection listener ( type . get fallback (  )  )  . get encryption protocols comma separated (  )  )  . trim (  )  ;   }   }  
public static void   (  subscription s int prefetch )  {  s . request ( prefetch  <  0  ?   long . max   value : prefetch )  ;   }  
public v   (  )  {  v o ;  if  ( index  <  ss . n keys )   {  o = ss . vals[index] ;   }  else  {  throw new  no such element exception (  )  ;   }  if  ( index  <   ( ss . n keys  -  1 )  )   {  index +  +  ;   }  else if  ( ss . next  !  =  null )   {  ss = ss . next ;  index = 0 ;   }  else  {  index = ss . n keys ;   }  return o ;   }  
public   ( i2p app context context i2p session impl session boolean reduce boolean shutdown )  {  if  (  !  ( reduce || shutdown )  )  throw new  illegal argument exception ( " at least one must be enabled" )  ;     context = context ;     log = context . log manager (  )  . get log (  session idle timer . class )  ;     session = session ;   properties props = session . get options (  )  ;  long minimum time =  long . max   value ;  long reduce time = 0 ;  long shutdown time = 0 ;  int reduce quantity = 0 ;  if  ( reduce )   {  reduce quantity = 1 ;   string p = props . get property ( "i2cp . reduce quantity" )  ;  if  ( p  !  =  null )   {  try  {  reduce quantity =  math . max (  integer . parse int ( p )  1 )  ;   }  catch  (   number format exception nfe )   {   }   }  reduce time = default   reduce   time ;  p = props . get property ( "i2cp . reduce idle time" )  ;  if  ( p  !  =  null )   {  try  {  reduce time =  math . max (  long . parse long ( p )  minimum   time )  ;   }  catch  (   number format exception nfe )   {   }   }  minimum time = reduce time ;   }  if  ( shutdown )   {  shutdown time = default   close   time ;   string p = props . get property ( "i2cp . close idle time" )  ;  if  ( p  !  =  null )   {  try  {  shutdown time =  math . max (  long . parse long ( p )  minimum   time )  ;   }  catch  (   number format exception nfe )   {   }   }  minimum time =  math . min ( minimum time shutdown time )  ;  if  ( reduce && shutdown time  <  =  reduce time )  reduce = false ;   }     reduce enabled = reduce ;     reduce quantity = reduce quantity ;     reduce time = reduce time ;     shutdown enabled = shutdown ;     shutdown time = shutdown time ;     minimum time = minimum time ;   }  
public   (  )  {  super ( null )  ;   }  
@ override protected  wgs metrics collector   ( final int coverage cap final  interval list intervals )  {  assert  ( coverage cap  =  =  this . collector . coverage cap )  ;  return this . collector ;   }  
@ suppress warnings ( "unused" )  @ test public void   (  )  {   observable <  movie >  horror movies =  observable .  <  movie > just ( new  horror movie (  )  )  ;   observable <  movie >  reduce result = horror movies . scan ( new  bi function <  movie
private void   (  string script property name  string script property value )  {  try  {  if  ( script property name . index of ( "js . " )   =  =  0 && script property name . index of ( " . path" )   !  =  script property name . length (  )   -  5 )   {   string script path = script property value ;   string script home path =  jive globals . get property ( script property name  +  " . path" plugin directory path )  ;   log . info ( "execute script executable path "  +  script path  +  " " +  script home path )  ;   node thread node thread = new  node thread (  )  ;  node thread . start ( node exe path  +  " "  +  script path new  file ( script home path )  )  ;  scripts . put ( script property name node thread )  ;   }   }  catch  (   throwable t )   {   log . error ( " error running  nodej  scripts " t )  ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to =  test observer . create (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;  to . assert values only (  )  ;  to . on next ( 5 )  ;  to . assert values only ( 5 )  ;  to . on next ( 
  ( final  string cigar final boolean reverse strand final int mapq final boolean one of the best )  {  this . cigar = cigar ;  this . reverse strand = reverse strand ;  this . mapq = mapq ;  this . one of the best = one of the best ;   }  
public void   (  request queue request queue )  {   workgroup workgroup = request queue . get workgroup (  )  ;  for  (   agent session session : workgroup . get agent sessions (  )  )   {  if  ( session . has requested agent info (  )  )   {  iq iq = new iq ( iq .  type . set )  ;  iq . set from ( workgroup . getjid (  )  )  ;  iq . set to ( session . getjid (  )  )  ;   element agent status request = iq . set child element ( "agent - status - request" "http: /  / jabber . org / protocol / workgroup" )  ;   element agent info = get agent info (  )  ;  agent info . add attribute ( "type" "remove" )  ;  agent status request . add ( agent info )  ;  workgroup . send ( iq )  ;   }   }   }  
public static  encoding provider   (  )  {  return instance ;   }  
public int   (  )  {  return    quantity ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map iterable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  {  return null ;   }   
@ override public  string   (  )  {   string builder buf = new  string builder ( 1024 )  ;  buf . append (    entries . size (  )  )  ;  buf . append ( " entries in  ( " )  . append (    begin )  . append ( ' ' )  . append (    end )  ;  buf . append ( " 
@ test public void   (  )  {   observer <  string >  observer =  test helper . mock observer (  )  ;   test observer <  string >  to = new  test observer <  string >  ( observer )  ;  with timeout . subscribe ( observer )  ;  test scheduler . advance time
public  conference sender   (  )  {  return conference sender ;   }  
public void   (  )  {     may disconnect = true ;   }  
@ override public void   (  )  {   throwable ex = error ;  if  ( ex  !  =  null )   {  error = null ;  actual . on error ( ex )  ;   }  else  {  actual . on complete (  )  ;   }   }  
public   ( final  illumina file map tiles to files )  {  super ( tiles to files )  ;   }  
public void   (  string l )  {     debug = "2" . equals ( l )  ;     lease =    debug || "1" . equals ( l )  ;   }  
 string   (  )  {  return this . ver attribute ;   }  
protected void   ( int state  string info )  {  call state = new  call state ( state )  ;   call event call event = new  call event (  call event . state   changed )  ;  call event . set call state ( call state )  ;   string s = "" ;  if  ( state  =  =   call state . invited || state  =  =   call state . established )   {  s +  = " conference receiver port = '"  +  call handler . get receive address (  )  . get port (  )   +  "'" ;   media info media info = call handler . get conference manager (  )  . get media info (  )  ;  s +  = "  conference payload = '"  +  media info . get payload (  )   +  "'" ;  s +  = "  bridgeip address = '"  +   bridge . get private host (  )   +  "'" ;  s +  = "  bridge info = '"  +   bridge . get private host (  )   +  ":" +   bridge . get private control port (  )  +  ":" +   bridge . get private sip port (  )  +  ":" +   bridge . get public host (  )  +  ":" +   bridge . get public control port (  )  +  ":" +   bridge . get public sip port (  )  +  "'" ;   }  if  ( info  !  =  null )   {  s = info  +  " "  +  s ;   }  call event . set info ( s )  ;   logger . println ( " call "  +  call handler  +  " " +  call state )  ;  send call event notification ( call event )  ;  if  ( state  =  =   call state . established )   {   string treatment = cp . get call established treatment (  )  ;  if  ( treatment  !  =  null )   {  call established treatment = initialize treatment ( treatment 0 )  ;  if  ( call established treatment  !  =  null )   {  add treatment ( call established treatment )  ;   }   }   }  if  ( invite timeout thread  =  =  null && state  =  =   call state . invited )   {  invite timeout thread = new  thread ( this )  ;  invite timeout thread . start (  )  ;   }   }  
@ test public void   (  )  {   observer <  string >  observer =  test helper . mock observer (  )  ;   test observer <  string >  to = new  test observer <  string >  ( observer )  ;  with timeout . subscribe ( observer )  ;  test scheduler . advance time
@ test public void   (  )  {  assert null ( formatter . get logic (  )  )  ;   }  
private void   (  agent history model model )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   session   metadata )  ;  pstmt . set string ( 1 model . get sessionid (  )  )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {   string name = rs . get string ( 1 )  ;   string value = rs . get string ( 2 )  ;  if  ( name . equals ( "username" )  )   {  model . set name ( value )  ;   }  else if  ( name . equals ( "email" )  )   {  model . set email ( value )  ;   }  else if  ( name . equals ( "question" )  )   {  model . set question ( value )  ;   }   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "one" "two" "three" "four" "five" "six" )  ;   observable <  grouped observable <  integer  integer >  >  grouped = source . group by ( length length )  ;   map <  intege
public long   (  )  {  return    bytes remaining ;   }  
@ override public void   (  jdbi db )  {  db . register argument ( new  date time argument factory (  )  )  ;  db . register column mapper ( new  date time mapper (  )  )  ;   }  
public   (  string name long max size long max lifetime )  {  this . name = name ;  this . max cache size = max size ;  this . max lifetime = max lifetime ;  map = new  hash map <  >  ( 103 )  ;  last accessed list = new org . jivesoftware . util .  linked list <  >  (  )  ;  age list = new org . jivesoftware . util .  linked list <  >  (  )  ;   }  
public int   (  )  {  return  jive globals . get int property ( "update . proxy . port"  - 1 )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  10000 ;  i +  +  )   {  final byte[] bytes = new byte[32] ;  random . next bytes ( bytes )  ;  bytes[31] =  ( byte )  ( bytes[31] & 0x7f )  ;  final  big integer b1 =  math utils . to big integer ( b
@ deprecated public void   ( boolean interest )  {   peer state s = state ;  if  ( s  !  =  null )  s . set interesting ( interest )  ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  action on cancel )  {  return do on lifecycle (  functions . empty consumer (  )   f
public static  file   (  string prefix  string suffix  file directory )  throws io exception  {   file rv =  file . create temp file ( prefix suffix directory )  ;   secure file output stream . set perms ( rv )  ;  return rv ;   }  
@ test public void   (  )  {   observable . range ( 1 10 )  . subscribe with ( new  test observer <  integer >  (  )  )  . assert result ( 1 2 3 4 5 6 7 8 9 10 )  ;   }  
@ override public void   (  )  {  qd . on next ( 1 )  ;   }  
@ override public boolean   (  )  {  return is cancelled . get (  )  ;   }  
public  node   (  )  {   node fault node = get fault node (  )  ;  if  ( fault node  =  =  null )  return null ;  return fault node . get node ends with ( soap . fault   code )  ;   }  
public void   ( ssdp packet ssdp packet )  {  device search response ( ssdp packet )  ;   }  
@ override public void   (  config registry registry  annotation annotation  class <  ?  >  sql object type )  {   configurer delegate = new  register argument factory impl (  )  ;   register argument factories factories =  (  register argument factories 
@ override protected void   (  )  throws  exception  {  super . set up (  )  ;  m test apk package name = get context (  )  . get package name (  )   +  " . tests" ;   }  
public int   (  )  {  if  ( distributed bridge  !  =  null )   {  return distributed bridge . get number of members ( conference id )  ;   }  return get member list (  )  . size (  )  ;   }  
private void   (  prep buffer buf )  {  if  (    closed . get (  )  )  return ;  if  (  ! is established (  )  )   {  return ;   }  long now =    context . clock (  )  . now (  )  ;  if  (    next meta time  <  =  now )   {  send meta (  )  ;     next meta time = now  +   ( meta   frequency  /  2 )   +     context . random (  )  . next int ( meta   frequency  /  2 )  ;   }   out net message msg = null ;  synchronized  (    outbound )   {  if  (    current outbound  !  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( "attempt for multiple outbound messages with "  +   system . identity hash code (    current outbound )   +  " already waiting and " +     outbound . size (  )  +  " queued" )  ;  return ;   }  msg =    outbound . poll (  )  ;  if  ( msg  =  =  null )  return ;     current outbound = msg ;   }  buffered prepare ( msg buf )  ;     context . aes (  )  . encrypt ( buf . unencrypted 0 buf . encrypted 0    session key    prev write end 0 buf . unencrypted length )  ;   system . arraycopy ( buf . encrypted buf . encrypted . length  -  16    prev write end 0    prev write end . length )  ;     transport . get pumper (  )  . wants write ( this buf . encrypted )  ;  if  (    next info time  <  =  now )   {  enqueue info message (  )  ;     next info time = now  +   ( info   frequency  /  2 )   +     context . random (  )  . next int ( info   frequency )  ;   }   }  
@ test public void   (  )  {   maybe . sequence equal (  maybe . just ( 1 )   maybe . just ( 2 )  new  bi predicate <  integer  integer >  (  )  {  @ override public boolean test (   integer a   integer b )  throws  exception  {  throw new  test exception
public void   ( long n )  {  request ( n )  ;   }  
public int   (  )  {  if  (    context  =  =  null )  return 0 ;  else return    context . tunnel manager (  )  . get outbound tunnel count (  )  ;   }  
public static void   (  workgroup workgroup  string sessionid  agent session agent session )  {  for  (   workgroup event listener listener : listeners )   {  try  {  listener . agent left chat support ( workgroup sessionid agent session )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   }  
@ test public void   (  )  {   test helper . check double on subscribe maybe ( new  function <  maybe <  integer >   maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   maybe <  integer >  c )  throws  exception 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test subscriber <  long >  ts = new  test subscriber <  long >  (  )  ;  final  test scheduler scheduler = new  test scheduler (  )  ;  
public   (  system model config )  {  domains = new  hash map <  >  (  )  ;  for  (   cluster domain : config . get repose cluster (  )  )   {  domains . put ( domain . get id (  )  new  cluster wrapper ( domain )  )  ;   }  for  (   cluster domain : config . get service cluster (  )  )   {  domains . put ( domain . get id (  )  new  cluster wrapper ( domain )  )  ;   }   }  
@ override public  completable   (  completable f )  throws  exception  {  return f . hide (  )  ;   }  
@ override public  string   (  )  {  return    socket . to string (  )  ;   }  
@ test public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  intege
@ override public void   ( final  subscriber <  ?  super  object >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  new  thread ( new  runnable (  )  {  @ override public void run (  )  {  try  {  observer . on error ( new  
private double[][]   (  string function long start time long end time int data points )  {   rrd db db = null ;  try  {  db = new  rrd db ( get db path (  )  true )  ;   fetch data data ;  if  ( data points  >  0 )   {  data = db . create fetch request ( function start time end time get resolution ( start time end time data points )  )  . fetch data (  )  ;   }  else  {  data = db . create fetch request ( function start time end time )  . fetch data (  )  ;   }  return data . get values (  )  ;   }  catch  (  io exception e )   {   log . error ( " error initializing  rrdb" e )  ;   }  catch  (   rrd exception e )   {   log . error ( " error initializing  rrdb" e )  ;   }  finally  {  try  {  if  ( db  !  =  null )   {  db . close (  )  ;   }   }  catch  (  io exception e )   {   log . error ( " unable to release  rrdb resources" e )  ;   }   }  return null ;   }  
public void   (  )  {  for  (   request request : get requests (  )  )   {  request . cancel (  request .  cancel type . agent   not   found )  ;   }  requests . clear (  )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  consumer <  ?  super  throwable >  on error )  {  return do on lifecycle (  functions . empty consumer (  )  on error  functions . empty   action  funct
@ override public boolean   (  file dir  string name )  {  boolean accept = false ;   string small name = name . to lower case (  )  ;  if  ( small name . ends with ( " . jar" )  )   {  accept = true ;   }  else if  ( small name . ends with ( " . zip" )  
public  presence router   (  )  {  return  (  presence router ) modules . get (  presence router . class )  ;   }  
@ test public void   (  )  throws  exception  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  behavior subject <  object >  p =  behavior subject . create (  )  ;  final  test observer <  object >  to = new  tes
public void   (  string value )  {  method = value ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ garlic message: " )  ;  buf . append ( " data length: " )  . append ( get data (  )  . length )  . append ( " bytes" )  ;  buf . append ( "]" )  ;  r
@ override public boolean   ( final  object o )  {  return o instanceof  tile && this . get number (  )   =  =   (  (  tile ) o )  . get number (  )  ;   }  
  (  single observer <  ?  super r >  t  function <  ?  super t  ?  extends r >  mapper )  {  this . t = t ;  this . mapper = mapper ;   }  
public void   (  byte value[] )  throws  exception  {  if  ( value  !  =  null &&  array extensions . get length ( value )  . int value (  )  % 4  !  =  0 )   {  throw new  exception ( " data must be a multiple of four bytes . " )  ;   }  else  {        data = value ;  return ;   }   }  
@ override public  observable source <  object >    (  observable <  throwable >  v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (   observable <  object >  o )  throws  exc
private void   ( udp packet reader reader udp packet packet  outbound establish state state )  {     state = 35 ;  if  (    log . should log (  log . debug )  )   {   string builder buf = new  string builder ( 128 )  ;  buf . append ( " attempting to receive a packet on a known outbound state: " )  ;  buf . append ( state )  ;  buf . append ( " mac key: " )  . append ( state . getmac key (  )  )  ;  buf . append ( " intro key: " )  . append ( state . get intro key (  )  )  ;     log . debug ( buf . to string (  )  )  ;   }  boolean is valid = false ;  if  ( state . getmac key (  )   !  =  null )   {     state = 36 ;  is valid = packet . validate ( state . getmac key (  )  )  ;  if  ( is valid )   {  if  (    log . should log (  log . info )  )     log . info ( " valid introduction packet received for outbound established con: "  +  packet )  ;     state = 37 ;  packet . decrypt ( state . get cipher key (  )  )  ;  handle packet ( reader packet null state null  auth type . session )  ;     state = 38 ;  return ;   }   }  is valid = packet . validate ( state . get intro key (  )  )  ;  if  ( is valid )   {  if  (    log . should log (  log . info )  )     log . info ( " valid packet received for "  +  state  +  " with  bob's intro key: " +  packet )  ;     state = 39 ;  packet . decrypt ( state . get intro key (  )  )  ;  handle packet ( reader packet null state null  auth type . bobintro )  ;     state = 40 ;  return ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " invalid introduction packet received for outbound established con with old intro key  falling back: "  +  packet )  ;   }     state = 41 ;  receive packet ( reader packet outbound   fallback )  ;     state = 42 ;   }  
public void   ( http request listener listener )  {  http request listener list . add ( listener )  ;   }  
public   ( t us int b value )  {     b value = b value ;     big us = new  big integer ( 1 us . get data (  )  )  ;     distance cache = new lhm cache < t  integer >  ( 256 )  ;   }  
@ override public  health check service proxy   (  )  {   health check service proxy proxy = new  health check service proxy impl (  )  ;  reports . put ( proxy new  hash map <  >  (  )  )  ;  return proxy ;   }  
public static  group element   ( final  group element g final  group element .  representation repr )  {   big integer x ;   big integer y ;  final  big integer gx = to big integer ( g . getx (  )  . to byte array (  )  )  ;  final  big integer gy = to big integer ( g . gety (  )  . to byte array (  )  )  ;  final  big integer gz = to big integer ( g . getz (  )  . to byte array (  )  )  ;  final  big integer gt = null  =  =  g . gett (  )   ?  null : to big integer ( g . gett (  )  . to byte array (  )  )  ;  switch  ( g . get representation (  )  )   {  case p2: case p3: x = gx . multiply ( gz . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  y = gy . multiply ( gz . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  break ;  case p1p1: x = gx . multiply ( gz . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  y = gy . multiply ( gt . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  break ;  case cached: x = gx . subtract ( gy )  . multiply ( gz . multiply ( new  big integer ( "2" )  )  . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  y = gx . add ( gy )  . multiply ( gz . multiply ( new  big integer ( "2" )  )  . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  break ;  case precomp: x = gx . subtract ( gy )  . multiply ( new  big integer ( "2" )  . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  y = gx . add ( gy )  . multiply ( new  big integer ( "2" )  . mod inverse ( getq (  )  )  )  . mod ( getq (  )  )  ;  break ;  default : throw new  unsupported operation exception (  )  ;   }  switch  ( repr )   {  case p2: return  group element . p2 ( curve to field element ( x )  to field element ( y )  get field (  )  . one )  ;  case p3: return  group element . p3 ( curve to field element ( x )  to field element ( y )  get field (  )  . one to field element ( x . multiply ( y )  . mod ( getq (  )  )  )  )  ;  case p1p1: return  group element . p1p1 ( curve to field element ( x )  to field element ( y )  get field (  )  . one get field (  )  . one )  ;  case cached: return  group element . cached ( curve to field element ( y . add ( x )  . mod ( getq (  )  )  )  to field element ( y . subtract ( x )  . mod ( getq (  )  )  )  get field (  )  . one to field element ( d . multiply ( new  big integer ( "2" )  )  . multiply ( x )  . multiply ( y )  . mod ( getq (  )  )  )  )  ;  case precomp: return  group element . precomp ( curve to field element ( y . add ( x )  . mod ( getq (  )  )  )  to field element ( y . subtract ( x )  . mod ( getq (  )  )  )  to field element ( d . multiply ( new  big integer ( "2" )  )  . multiply ( x )  . multiply ( y )  . mod ( getq (  )  )  )  )  ;  default : throw new  unsupported operation exception (  )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( just1 new  callable <  collection <  integer >  >  (  )  {  @ override public  collection <  integer >  call (  )  {  return null ;   }   }   )  . blocking subs
@ test ( timeout = 30000 )  public void   (  )  throws  interrupted exception  {   flowable <  integer >  source =  flowable . just ( 1 2 3 4 5 6 )  ;   maybe <  integer >  reduced = source . reduce ( new  bi function <  integer  integer  integer >  (  ) 
@ test public void   (  )  {   observer <  object >  o =  test helper . mock observer (  )  ;  final  list <  integer >  list =  arrays . as list ( 1 2 3 )  ;   function <  integer  list <  integer >  >  func = new  function <  integer  list <  integer > 
@ suppress warnings ( "deprecation" )  public  data structure   (  )  throws  data format exception  {   router info info = new  router info (  )  ;   hash set <  router address >  addresses = new  hash set <  router address >  (  )  ;   data structure st
@ test public void   (  )  {  final  group element neutral =  group element . p3 ( curve curve . get field (  )  . zero curve . get field (  )  . one curve . get field (  )  . one curve . get field (  )  . zero )  ;  for  ( int i = 0 ;  i  <  1000 ;  i + 
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;  final  test exception ex = new  test exception (  )  ;   observable . range ( 1 5 )  . concat with (  observable .  <  integer > error ( ex )  )  . subscri
public int   (  )  {  return  integer . parse int (  jive globals . get property ( jn   test   stun   port   property "19302" )  )  ;   }  
public double   (  )  {  return population likelihood ;   }  
private static  string   (  string file path )  {  return file path . substring ( file path . last index of ( ' / ' )   +  1 file path . last index of ( ' . ' )  )  ;   }  
public  diploid genotype   (  )  {  return this . genotypes[0] ;   }  
@ test public void   (  )  {   observable <  string >  skip =  observable . just ( "one" "two" "three" )  . skip ( 1 )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  skip . subscribe ( observer )  ;  verify ( observer never ( 
@ test public void   (  )  {   observable <  string >  w =  observable . just ( "one" "fail" "two" "three" "fail" )  ;  w = w . map ( new  function <  string  string >  (  )  {  @ override public  string apply (   string s )  {  if  ( "fail" . equals ( s 
@ test public void   (  )  {   message message = new  message (  )  ;  message . set type (  message .  type . error )  ;  assert false (  offline message store . should store message ( message )  )  ;   }  
private  observable <  integer >    ( final  atomic integer generated )  {   observable <  integer >  o =  observable . from iterable ( new  iterable <  integer >  (  )  {  @ override public  iterator <  integer >  iterator (  )  {  return new  iterator <  integer >  (  )  {  @ override public void remove (  )  {   }  @ override public  integer next (  )  {  return generated . get and increment (  )  ;   }  @ override public boolean has next (  )  {  return true ;   }   }   ;   }   }   )  ;  return o ;   }  
@ test public void   (  )  {   behavior processor <  string >  processor =  behavior processor . create default ( "default" )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  processor . subscribe ( observer )  ;  processor 
private void   (  database store message msg  router info peer long expiration )  {  long token = 1  +  get context (  )  . random (  )  . next long ( i2np message . max   id   value )  ;   hash client = msg . get key (  )  ;   hash to = peer . get identity (  )  . get hash (  )  ;   tunnel info reply tunnel = get context (  )  . tunnel manager (  )  . select inbound tunnel ( client to )  ;  if  ( reply tunnel  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " no reply inbound tunnels available ! " )  ;  fail (  )  ;  return ;   }   tunnel id reply tunnel id = reply tunnel . get receive tunnel id ( 0 )  ;  msg . set reply token ( token )  ;  msg . set reply tunnel ( reply tunnel id )  ;  msg . set reply gateway ( reply tunnel . get peer ( 0 )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( get job id (  )   +  ": send ( db store )  w /  token expected "  +  token )  ;   tunnel info out tunnel = get context (  )  . tunnel manager (  )  . select outbound tunnel ( client to )  ;  if  ( out tunnel  !  =  null )   {  i2np message sent ;  boolean should encrypt = supports encryption ( peer )  ;  if  ( should encrypt )   {   message wrapper .  wrapped message wm =  message wrapper . wrap ( get context (  )  msg client peer )  ;  if  ( wm  =  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " fail garlic encrypting from: "  +  client )  ;  fail (  )  ;  return ;   }  sent = wm . get message (  )  ;     state . add pending ( to wm )  ;   }  else  {     state . add pending ( to )  ;     state . reply timeout ( to )  ;  get context (  )  . job queue (  )  . add job ( new  wait job ( get context (  )  )  )  ;  return ;   }   send success job on reply = new  send success job ( get context (  )  peer out tunnel sent . get message size (  )  )  ;   failed job on fail = new  failed job ( get context (  )  peer get context (  )  . clock (  )  . now (  )  )  ;   store message selector selector = new  store message selector ( get context (  )  get job id (  )  peer token expiration )  ;  if  (    log . should log (  log . debug )  )   {  if  ( should encrypt )     log . debug ( "sending encrypted store to "  +  peer . get identity (  )  . get hash (  )   +  " through " +  out tunnel +  ": " +  sent )  ;  else    log . debug ( "sending store to "  +  peer . get identity (  )  . get hash (  )   +  " through " +  out tunnel +  ": " +  sent )  ;   }  get context (  )  . message registry (  )  . register pending ( selector on reply on fail )  ;  get context (  )  . tunnel dispatcher (  )  . dispatch outbound ( sent out tunnel . get send tunnel id ( 0 )  null to )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " no outbound tunnels to send a db store out  -  delaying .  .  . " )  ;     state . reply timeout ( to )  ;   job waiter = new  wait job ( get context (  )  )  ;  waiter . get timing (  )  . set start after ( get context (  )  . clock (  )  . now (  )   +  3 * 1000 )  ;  get context (  )  . job queue (  )  . add job ( waiter )  ;   }   }  
public   (  token handler semicolon handler )  {  this . semicolon handler = semicolon handler ;   }  
@ test ( timeout = 5000 )  public void   (  )  throws  interrupted exception  {  int n = 10 ;   function <  object[]  list <  object >  >  func = new  function <  object[]  list <  object >  >  (  )  {  @ override public  list <  object >  apply (   objec
public static boolean   (  atomic reference <  disposable >  field  disposable d )  {   object helper . require non null ( d "d is null" )  ;  if  (  ! field . compare and set ( null d )  )   {  d . dispose (  )  ;  if  ( field . get (  )   !  =  disposed )   {  report disposable set (  )  ;   }  return false ;   }  return true ;   }  
@ override public void   (  roster roster  roster item item )  {  roster cache . put ( roster . get username (  )  roster )  ;   }  
@ override public void   (  session session )  {  remove session ( session )  ;   }  
public void   (  connection con )  {  con . disconnect complete (  )  ;   }  
@ override public  socket   ( final  socket socket final  string host final int port final boolean auto close )  throws io exception   unknown host exception  {  ssl socket ssl socket =  ( ssl socket ) socketfactory . create socket ( socket host port auto
public void   ( long tag )  {     they relay to us as = tag ;   }  
protected boolean   (  properties props )  {  if  ( props . is empty (  )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " no parameters specified in stream send message" )  ;  return false ;   }  int id ;   {   string strid = props . get property ( "id" )  ;  if  ( strid  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( "id not specified in stream send message" )  ;  return false ;   }  try  {  id =  integer . parse int ( strid )  ;   }  catch  (   number format exception e )   {  if  (    log . should log (  log . debug )  )     log . debug ( " invalid stream send id specified: "  +  strid )  ;  return false ;   }   }  int size ;   {   string strsize = props . get property ( "size" )  ;  if  ( strsize  =  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " size not specified in stream send message" )  ;  return false ;   }  try  {  size =  integer . parse int ( strsize )  ;   }  catch  (   number format exception e )   {  if  (    log . should log (  log . debug )  )     log . debug ( " invalid stream send size specified: "  +  strsize )  ;  return false ;   }  if  (  ! check size ( size )  )   {  if  (    log . should log (  log . debug )  )     log . debug ( " specified size  ( "  +  size  +  " )  is out of protocol limits" )  ;  return false ;   }   }  try  {  if  (  ! stream session . send bytes ( id get client socket (  )  . socket (  )  . get input stream (  )  size )  )   {  if  (    log . should log (  log . warn )  )     log . warn ( "stream send ["  +  size  +  "] failed" )  ;  boolean rv = write string ( "stream closed result = cant   reach   peer id = "  +  id  +  " message = \" send of " +  size +  " bytes failed\"\n" )  ;  stream session . close connection ( id )  ;  return rv ;   }  return true ;   }  catch  (  eof exception e )   {  if  (    log . should log (  log . debug )  )     log . debug ( " too few bytes with stream send message  ( expected: "  +  size )  ;  return false ;   }  catch  (  io exception e )   {  if  (    log . should log (  log . debug )  )     log . debug ( " caught io exception while parsing stream send message" e )  ;  return false ;   }   }  
public  string   (  )  {   string buffer sb = new  string buffer ( "[ data source: offset = 0x" )  ;  sb . append (  long . to hex string ( offset )  )  ;  sb . append ( "  size = 0x" )  ;  sb . append (  long . to hex string ( size )  )  ;  sb . append ( "  name = " )  ;  sb . append ( name )  ;  sb . append ( "  type = " )  ;  sb . append ( type . to string (  )  )  ;  sb . append ( "  min heartbeat = " )  ;  sb . append ( minimum heartbeat )  ;  sb . append ( "  min = " )  ;  sb . append ( minimum )  ;  sb . append ( "  max = " )  ;  sb . append ( maximum )  ;  sb . append ( "]" )  ;  sb . append ( "\n\t\t" )  ;  sb . append ( pdp status block . to string (  )  )  ;  return sb . to string (  )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to =  observer fusion . new test (  queue fuseable . any )  ;   take first source = new  take first ( to )  ;   disposable d =  disposables . empty (  )  ;  source . on subscribe ( d )  ;  to . as
public void   (  sink sink )  {  this . sink = sink ;   }  
private static  local outgoing server session   (  connection connection xmpp packet reader reader  string local domain  string remote domain  string id )  {  final  logger log =  logger factory . get logger (  log . get name (  )   +  "[ dialback over tls for: "  +  local domain +  " to: " +  remote domain +  "  (  stream id: " +  id +  " ) ]" )  ;  if  (  server dialback . is enabled (  )  ||  server dialback . is enabled for self signed (  )  )   {  log . debug ( " trying to connecting using dialback over tls . " )  ;   server dialback method = new  server dialback ( connection local domain )  ;   outgoing server socket reader new socket reader = new  outgoing server socket reader ( reader )  ;  if  ( method . authenticate domain ( new socket reader local domain remote domain id )  )   {  log . debug ( " dialback over tls was successful . " )  ;   streamid streamid = new  basic streamid factory (  )  . create streamid ( id )  ;   local outgoing server session session = new  local outgoing server session ( local domain connection new socket reader streamid )  ;  connection . init ( session )  ;  session . set address ( new jid ( null remote domain null )  )  ;  return session ;   }  else  {  log . debug ( " dialback over tls failed" )  ;  return null ;   }   }  else  {  log . debug ( " skipping server dialback attempt as it has been disabled by local configuration . " )  ;  return null ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  assert true (  observable scalarx map . try scalarx map subscribe ( new  one callable publisher (  )  to new  function <  integer  observable source 
public int   (  )  {  return    max req ;   }  
@ override protected void   (  single observer <  ?  super r >  observer )  {   single source <  ?  extends t > [] sources = this . sources ;  int n = sources . length ;  if  ( n  =  =  1 )   {  sources[0] . subscribe ( new  single map .  map single obser
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   flowable . error ( new  test exception (  )  )  . buffer (  flowable . never (  )   functions . just function (  flowable . never (  )  )  )  . test (  )  . assert failure (  test excepti
@ override public  transport session <  yahoo buddy >    (  registration registration jid jid  presence type presence type  string verbose status  integer priority )  {   transport session <  yahoo buddy >  session = new  yahoo session ( registration jid 
@ override public void   (  object t )  {  if  (  ! has value )   {  has value = true ;   }  parent . inner next ( index t )  ;   }  
public   (  completable source[] sources  iterable <  ?  extends  completable source >  sources iterable )  {  this . sources = sources ;  this . sources iterable = sources iterable ;   }  
public static void   ( boolean send to cluster )  {  if  ( send to cluster )   {   cache factory . do synchronous cluster task ( new  flush task (  )  false )  ;   }  if  ( items to add . get first (  )   =  =  null && items to delete . get first (  )   =  =  null )   {  return ;   }   connection con = null ;  boolean rollback = false ;   linked list <  retry wrapper >  add list = null ;   linked list <  published item >  del list = null ;  synchronized  ( items pending )   {  add list = items to add ;  del list = items to delete ;  items to add = new  linked list <  >  (  )  ;  items to delete = new  linked list <  >  (  )  ;  int copied = 0 ;  for  (   string key : items pending . key set (  )  )   {  if  (  ! item cache . contains key ( key )  )   {  item cache . put ( key  (  (  (  retry wrapper ) items pending . get ( key )  . object )  )  . get (  )  )  ;  copied +  +  ;   }   }  if  ( log . is debug enabled (  )  && copied  >  0 )   {  log . debug ( " added "  +  copied  +  " pending items to published item cache" )  ;   }  items pending . clear (  )  ;   }  try  {  con =  db connection manager . get transaction connection (  )  ;  write pending items ( con add list del list )  ;   }  catch  (  sql exception se )   {  log . error ( " failed to flush pending items ;  initiating rollback" se )  ;   linked list node <  retry wrapper >  node = add list . get last (  )  ;  while  ( node  !  =  null )   {  save published item ( node . object )  ;  node . remove (  )  ;  node = add list . get last (  )  ;   }  rollback = true ;   }  finally  {   db connection manager . close transaction connection ( con rollback )  ;   }   }  
protected   ( jid address  operation operation )  {  super ( operation )  ;  this . address = address ;   }  
@ test public void   (  )  throws  exception  {  check scheduler bad method (  single . class . get simple name (  )  )  ;   }  
private iq   (  dtmf command command iq iq )  {   log . info ( " rayo component handle dtmf command "  +  iq . get from (  )  )  ;  iq reply = iq . create resultiq ( iq )  ;  try  {   call handler call handler =  call handler . find call ( iq . get to (  )  . get node (  )  )  ;  call handler . dtmf keys ( command . get tones (  )  )  ;   }  catch  (   no such element exception e )   {  reply . set error (  packet error .  condition . item   not   found )  ;   }  return reply ;   }  
public void   (  )  throws  messaging exception  {  long account1 id = 1 ;  long mailbox1 id = 1 ;   email content .  message local message1 =  provider test utils . setup message ( "make - legacy" account1 id mailbox1 id false true m provider context )  ;   message get message1 =  legacy conversions . make message ( m provider context local message1 )  ;  check legacy message ( "no body" local message1 get message1 )  ;   email content .  message local message2 =  provider test utils . setup message ( "make - legacy" account1 id mailbox1 id true false m provider context )  ;  local message2 . m flags& = ~ email content .  message . flag   type   mask ;  local message2 . save ( m provider context )  ;   message get message2 =  legacy conversions . make message ( m provider context local message2 )  ;  check legacy message ( "simple body" local message2 get message2 )  ;   email content .  message local message3 =  provider test utils . setup message ( "make - legacy" account1 id mailbox1 id true false m provider context )  ;  local message3 . m flags& = ~ email content .  message . flag   type   mask ;  local message3 . m flags| =  email content .  message . flag   type   reply ;  local message3 . save ( m provider context )  ;   message get message3 =  legacy conversions . make message ( m provider context local message3 )  ;  check legacy message ( "reply - to" local message3 get message3 )  ;   email content .  message local message4 =  provider test utils . setup message ( "make - legacy" account1 id mailbox1 id true false m provider context )  ;  local message4 . m flags& = ~ email content .  message . flag   type   mask ;  local message4 . m flags| =  email content .  message . flag   type   forward ;  local message4 . save ( m provider context )  ;   message get message4 =  legacy conversions . make message ( m provider context local message4 )  ;  check legacy message ( "forwarding" local message4 get message4 )  ;   }  
@ data provider ( name = "test collect illumina lane metrics" )  public  object[][]   (  )  {  return new  object[][] {  { "a7le0" new  read structure ( "25t8b8b25t" )  false }   { "c2mfaacxx" new  read structure ( "95t101t" )  false }   { "h7batadxx" new
public   (  string msg  throwable nested throwable )  {  super ( msg )  ;  this . nested throwable = nested throwable ;   }  
public void   (  )  {   host auth ha = new  host auth (  )  ;  ha . set login ( "user:password" )  ;  assert equals ( "user" ha . m login )  ;  assert equals ( "password" ha . m password )  ;  ha . set login ( "%20us%20er%20:password" )  ;  assert equals ( "%20us%20er%20" ha . m login )  ;  assert equals ( "password" ha . m password )  ;  ha . set login ( "user:%20pass%20word%20" )  ;  assert equals ( "user" ha . m login )  ;  assert equals ( "%20pass%20word%20" ha . m password )  ;  ha . set login ( "user:" )  ;  assert equals ( "user" ha . m login )  ;  assert equals ( "" ha . m password )  ;  ha . set login ( ":password" )  ;  assert equals ( "" ha . m login )  ;  assert equals ( "password" ha . m password )  ;  ha . set login ( "" )  ;  assert null ( ha . m login )  ;  assert null ( ha . m password )  ;  ha . set login ( null )  ;  assert null ( ha . m login )  ;  assert null ( ha . m password )  ;  ha . set login ( "userpassword" )  ;  assert equals ( "userpassword" ha . m login )  ;  assert null ( ha . m password )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   maybe . merge array (  maybe . just ( 1 )  )  . test (  )  . assert result ( 1 )  ;   }  
public void   ( long delta )  {  if  ( delta  <  0 )   {  offset changed ( delta )  ;   }  else  {  synchronized  (    job lock )   {     job lock . notify all (  )  ;   }   }   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  final  group element g =  math utils . to representation (  math utils . get random group element (  )   group element .  representation . precomp )  ;  g . to cached (  )  
@ test public void   (  )  {  assert null ( regex list . matches ( match   against )  )  ;   }  
@ test ( expected exceptions =  index out of bounds exception . class )  public void   (  )  {  test counter . increment ( 40 )  ;   }  
public static byte   ( int sample )  {  return linear to ulaw table[sample & 0xffff] ;   }  
 cluster task   (  string text )  {  return new  deliver raw text server task ( pair text )  ;   }  
public  group element   (  )  {  return a ;   }  
public  string   (  )  {  return remote host ;   }  
public static  byte[]   (  long value )  {   byte bytes[] = get long bytes ( value )  ;  if  ( is little endian (  )  . boolean value (  )  )  reverse ( bytes )  ;  return bytes ;   }  
public void   (  )  {  if  ( m password mode  =  =  password   mode   none )   {  m password max fails = 0 ;  m max screen lock time = 0 ;  m password min length = 0 ;  m password complex chars = 0 ;  m password history = 0 ;  m password expiration days = 0 ;   }  else  {  if  (  ( m password mode  !  =  password   mode   simple )  &&  ( m password mode  !  =  password   mode   strong )  )   {  throw new  illegal argument exception ( "password mode" )  ;   }  if  ( m password mode  =  =  password   mode   simple )   {  m password complex chars = 0 ;   }   }   }  
@ suppress warnings ( "rawtypes" )  @ test public void   (  )  {  try  {   rx java plugins . set on connectable observable assembly ( new  function <  connectable observable  connectable observable >  (  )  {  @ override public  connectable observable app
@ override public  jdbi   (  )  throws  exception  {  final  jdbi jdbi =  jdbi . create (  (  )   -  >   data source utils . get connection ( data source )  )  ;  if  ( auto install plugins )   {  jdbi . install plugins (  )  ;   }  plugins . for each ( j
@ override public void   ( boolean expunge )  {  try  {  execute simple command ( "quit" )  ;   }  catch  (   exception e )   {   }  m transport . close (  )  ;   }  
public int   (  )  {  return channels . size (  )  ;   }  
public void   (  )  {  synchronized  ( this )   {  if  ( worker  !  =  null && worker . is alive (  )  )  throw new  runtime exception ( " stat collecting already started" )  ;  polled sessions = new  concurrent linked queue <  >  (  )  ;   map <  long  io session >  sessions = service . get managed sessions (  )  ;  if  ( sessions  !  =  null )   {  for  (   io session io session : sessions . values (  )  )   {  add session ( io session )  ;   }   }  service . add listener ( service listener )  ;  worker = new  worker (  )  ;  worker . start (  )  ;   }   }  
@ override protected void   ( final  single observer <  ?  super t >  s )  {  source . subscribe ( new  do on event ( s )  )  ;   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  expect login ( mock )  ;   folder folder = m store . get folder ( "inbox" )  ;  mock . expect ( get next tag ( false )   +  " select \"inbox\"" new  string[] { "* flags  ( \\ answered \\ flagged \\ draft \\ deleted \\ seen  non junk $ forwarded  junk"  +  " $ label4 $ label1 $ label2 $ label3 $ label5 $mdn sent  old ) " "* ok [permanentflags  ( \\ answered \\ flagged \\ draft \\ deleted \\ seen  non junk"  +  " $ forwarded  junk $ label4 $ label1 $ label2 $ label3 $ label5 $mdn sent  old \\* ) ]" "* 6406 exists" "* 0 recent" "* ok [unseen 5338]" "* ok [uidvalidity 1055957975]" "* ok [uidnext 449625]" "* no [alert]  mailbox is at 98% of quota" get next tag ( true )   +  " ok [read - write]  completed" }  )  ;  folder . open (  open mode . read   write )  ;  assert equals ( 6406 folder . get message count (  )  )  ;   }  
private  consumer <  observable <  string >  >    ( final  list <  string >  list final  list <  list <  string >  >  lists )  {  return new  consumer <  observable <  string >  >  (  )  {  @ override public void accept (   observable <  string >  string observable )  {  string observable . subscribe ( new  default observer <  string >  (  )  {  @ override public void on complete (  )  {  lists . add ( new  array list <  string >  ( list )  )  ;  list . clear (  )  ;   }  @ override public void on error (   throwable e )  {  fail ( e . get message (  )  )  ;   }  @ override public void on next (   string args )  {  list . add ( args )  ;   }   }   )  ;   }   }   ;   }  
@ test public void   (  )  {   flowable <  integer >  pp = new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;   disposable 
public void   (  )  {  for  ( int i = 0 ;  i  <  100 ;  i +  +  )   {   session key key =    context . key generator (  )  . generate session key (  )  ;  byte[] iv = new byte[16] ;     context . random (  )  . next bytes ( iv )  ;  byte[] plain = new byte[256] ;     context . random (  )  . next bytes ( plain )  ;  byte[] e = new byte[plain . length] ;     context . aes (  )  . encrypt ( plain 0 e 0 key iv plain . length )  ;  byte[] d = new byte[e . length] ;     context . aes (  )  . decrypt ( e 0 d 0 key iv d . length )  ;  boolean same = true ;  assert true (  data helper . eq ( plain d )  )  ;   }   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   flowable . range ( 1 5 )  . buffer ( 1  time unit . days  schedulers . single (  )  2  functions .  <  integer > create array list ( 16 )  true )  . test (  )  . assert result (  arrays .
public  bundle   (  )  {  if  ( m results  !  =  null )   {  return m results ;   }  final  bundle results = new  bundle ( 2 )  ;  results . put string ( extra   password get password (  )  )  ;  results . put string ( extra   client   cert get client certificate (  )  )  ;  return results ;   }  
public void   (  )  {   message auth request = new  message (  )  ;  auth request . add extension ( node . get auth request form ( this )  )  ;  node . get service (  )  . broadcast ( node auth request node . get owners (  )  )  ;   }  
private static void   (  string test sam name )  throws io exception  {  final  file test dir = new  file ( "testdata / picard / analysis / directed /  collect hs metrics / " )  ;  final  file reference = new  file ( "testdata / picard / quality / chrm . reference . fasta" )  ;  final  string read group id = " test read group" ;  final  string sample = " test sample" ;  final  string platform = " illumina" ;  final  string library = " test library" ;  final int num reads = 1 ;  final int read length = 10 ;   file sam file =  file . create temp file ( test sam name " . bam" test dir )  ;  final sam record set builder set builder = create testsam builder ( reference read group id sample platform library )  ;  set builder . set read length ( read length )  ;   int stream . range ( 0 num reads )  . for each ( i  -  >  set builder . add pair ( " mediocre baseq"  +  i 0 1 200 false false read length  +  "m" read length  +  "m" false true 40 )  )  ;  final sam file writer writer = new sam file writer factory (  )  . set create index ( true )  . makebam writer ( set builder . get header (  )  false sam file )  ;  set builder . for each ( writer::add alignment )  ;  writer . close (  )  ;   }  
public void   ( final  string new ds name )  throws  rrd exception  io exception  {  if  ( new ds name . length (  )   >   rrd string . string   length )   {  throw new  rrd exception ( " invalid datasource name specified: "  +  new ds name )  ;   }  if  ( parent db . contains ds ( new ds name )  )   {  throw new  rrd exception ( " datasource already defined in this rrd: "  +  new ds name )  ;   }  ds name . set ( new ds name )  ;  m   primitive ds name = null ;   }  
public void   (  )  {   mailbox test mailbox = new  mailbox (  )  ;   store . update mailbox ( test mailbox 1l "inbox" ' / ' true  mailbox . type   mail )  ;  assert equals ( 1l test mailbox . m account key )  ;  assert equals ( "inbox" test mailbox . m display name )  ;  assert equals ( "inbox" test mailbox . m server id )  ;  assert equals ( ' / ' test mailbox . m delimiter )  ;   store . update mailbox ( test mailbox 2l "inbox / a" ' / ' true  mailbox . type   mail )  ;  assert equals ( 2l test mailbox . m account key )  ;  assert equals ( "a" test mailbox . m display name )  ;  assert equals ( "inbox / a" test mailbox . m server id )  ;  assert equals ( ' / ' test mailbox . m delimiter )  ;   store . update mailbox ( test mailbox 3l "inbox / a / b / c / d" ' / ' true  mailbox . type   mail )  ;  assert equals ( 3l test mailbox . m account key )  ;  assert equals ( "d" test mailbox . m display name )  ;  assert equals ( "inbox / a / b / c / d" test mailbox . m server id )  ;  assert equals ( ' / ' test mailbox . m delimiter )  ;   store . update mailbox ( test mailbox 4l "inbox / a / b / c" '\0' true  mailbox . type   mail )  ;  assert equals ( 4l test mailbox . m account key )  ;  assert equals ( "inbox / a / b / c" test mailbox . m display name )  ;  assert equals ( "inbox / a / b / c" test mailbox . m server id )  ;  assert equals ( '\0' test mailbox . m delimiter )  ;   }  
private void   (  peer state peer )  {  if  (    log . should log (  log . info )  )     log . info ( " completing to the peer after ib confirm: "  +  peer )  ;   delivery status message dsm = new  delivery status message (    context )  ;  dsm . set arrival (    networkid )  ;  dsm . set message expiration (    context . clock (  )  . now (  )   +  data   message   timeout )  ;  dsm . set message id (    context . random (  )  . next long ( i2np message . max   id   value )  )  ;   hash hash = peer . get remote peer (  )  ;  if  (  ( hash  !  =  null )  &&  (  !    context . banlist (  )  . is banlisted ( hash )  )  &&  (  !    transport . is unreachable ( hash )  )  )   {   database store message dbsm = get our info (  )  ;   list < i2np message >  msgs = new  array list < i2np message >  ( 2 )  ;  msgs . add ( dsm )  ;  msgs . add ( dbsm )  ;     transport . send ( msgs peer )  ;   }  else  {     transport . send ( dsm peer )  ;  if  (    log . should log (  log . warn )  )     log . warn ( "not publishing to the peer after confirm plus delay  ( with banlist ) : "  +   ( hash  !  =  null  ?  hash . to string (  )  : "unknown" )  )  ;   }   }  
@ test public void   (  )  {   observable . range ( 1 5 )  . switch map (  functions . just function (  observable . just ( 1 )  )  )  . test (  )  . assert result ( 1 1 1 1 1 )  ;   }  
private void   ( final vcf header output header final  sorting collection <  variant context >  sorted output )  {  final  progress logger write progress = new  progress logger ( log 25000 "wrote" "records" )  ;  final  enum set <  options >  options = create   index  ?   enum set . of (  options . index   on   the   fly )  :  enum set . none of (  options . class )  ;  final  variant context writer out = new  variant context writer builder (  )  . set reference dictionary ( output header . get sequence dictionary (  )  )  . set options ( options )  . set output file ( output )  . build (  )  ;  out . write header ( output header )  ;  for  (  final  variant context variant context : sorted output )   {  out . add ( variant context )  ;  write progress . record ( variant context . get contig (  )  variant context . get start (  )  )  ;   }  out . close (  )  ;   }  
public  string   (  )  {  return "x" ;   }  
@ override protected void   (  observer <  ?  super r >  s )  {  source . subscribe ( new  flat map iterable observer < t r >  ( s mapper )  )  ;   }  
@ override protected int   (  )  {  final  illumina data provider factory factory = new  illumina data provider factory ( basecalls   dir lane read   structure new  bcl quality evaluation strategy (  bcl quality evaluation strategy . illumina   alleged   
@ test public void   (  )  {   test helper . check disposed (  flowable . just ( 1 )  . to list (  )  . to flowable (  )  )  ;   test helper . check disposed (  flowable . just ( 1 )  . to list (  )  )  ;   }  
double[]   (  )  {  return values ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  subdomain =  externalizable util . get instance (  )  . read safeutf ( in )  ;  description =  externalizable util . get instance (  )  . read safeutf ( in 
public void   ( final  per tile per cycle file util pcfu final  file parent dir final int[] cycles )  {  final  cycle illumina file map cfm = pcfu . get files ( cycles )  ;  final  cycle illumina file map cfmw tiles = pcfu . get files ( default   tiles cycles )  ;  final  cycle illumina file map cfm no cycles ;  if  (  arrays . equals ( cycles default   cycles )  )   {  cfm no cycles = pcfu . get files (  )  ;   }  else  {  cfm no cycles = null ;   }   assert . assert equals ( cfm . size (  )  cycles . length )  ;  for  (  final int cycle : cycles )   {  final  illumina file map t file iter = cfm . get ( cycle )  ;  final  illumina file map t file iter2 = cfmw tiles . get ( cycle )  ;  final  illumina file map t file iter3 ;  if  ( cfm no cycles  !  =  null )   {  t file iter3 = cfm no cycles . get ( cycle )  ;   }  else  {  t file iter3 = null ;   }  for  (  final  integer tile : default   tiles )   {  final  file tc file = t file iter . get ( tile )  ;  final  file tc file2 = t file iter2 . get ( tile )  ;   assert . assert equals ( tc file . get absolute path (  )  tc file2 . get absolute path (  )  )  ;  if  ( t file iter3  !  =  null )   {  final  file tf file3 = t file iter3 . get ( tile )  ;   assert . assert equals ( tc file . get absolute path (  )  tf file3 . get absolute path (  )  )  ;   }   assert . assert equals ( tc file make per tile per cycle file path ( parent dir default   lane tile cycle pcfu . extension )  )  ;   assert . assert true ( tc file . exists (  )  )  ;   assert . assert true ( tc file . length (  )   >  0 )  ;   }   }   }  
@ override public void   (  disposable s )  throws  exception  {  throw new  test exception (  )  ;   }  
public static  datastore access control   (  distributed datastore configuration config  list <  inet address >  cluster members )  {   list <  inet address >  host access list = new  linked list <  >  (  )  ;  boolean allow all = config . get allowed hosts (  )  . is allow all (  )  ;  host access list . add all ( cluster members )  ;  if  (  ! allow all )   {  host access list . add all ( get configured allowed hosts ( config )  )  ;   }  if  ( allow all )   {  log . info ( " the distributed datastore component is configured in allow - all mode meaning that any host can access  store and delete cached objects . " )  ;   }  else  {  log . info ( " the distributed datastore component has access controls configured meaning that only the configured hosts and cluster members "  +  "can access  store and delete cached objects . " )  ;   }  log . debug ( " allowed  hosts: "  +  host access list . to string (  )  )  ;  return new  datastore access control ( host access list allow all )  ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  )  {  if  (  ! done )   {  done = true ;  buffer . complete (  )  ;  for  (   inner subscription < t >  rp : subscribers . get and set ( terminated )  )   {  buffer . replay ( rp )  ;   }   
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public final  < u v >  flowable < v >    ( final  function <  ?  super t  ?  extends  iterable <  ?  extends u >  >  mapper final
@ override public  flowable <  object >    (  flowable <  object >  o )  throws  exception  {  return  flowable . using (  functions . just callable ( 1 )   functions . just function ( o )   functions . empty consumer (  )  )  ;   }  
private void   (  http request base base  map <  string  string >  headers )  {  final  set <  map .  entry <  string  string >  >  entries = headers . entry set (  )  ;  for  (   map .  entry <  string  string >  entry : entries )   {  base . add header ( entry . get key (  )  entry . get value (  )  )  ;   }   }  
public int   (  )  {  return height ;   }  
public int   (  )  {  return    node map . size (  )  ;   }  
public pep service   (  string jid )  {  pep service pep service = null ;  final  lock lock =  cache factory . get lock ( jid pep services )  ;  try  {  lock . lock (  )  ;  if  ( pep services . contains key ( jid )  )   {  pep service = pep services . get ( jid )  ;   }  else  {  pep service = loadpep service fromdb ( jid )  ;  pep services . put ( jid pep service )  ;   }   }  finally  {  lock . unlock (  )  ;   }  return pep service ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   test subscriber <  integer >  ts =  maybe . concat (  arrays . as list (  maybe . just ( 1 )   maybe . just ( 2 )  )  )  . test ( 0l )  ;  ts . assert empty (  )  ;  ts . request ( 1 )  ;
public void   (  )  {  try  {  while  (  ! quit && peer . is connected (  )  )   {   message m = null ;   peer state state = null ;  boolean should flush ;  synchronized  ( send queue )   {  should flush =  ! quit && peer . is connected (  )  && send queue . is empty (  )  ;   }  if  ( should flush )  dout . flush (  )  ;  synchronized  ( send queue )   {  while  (  ! quit && peer . is connected (  )  && send queue . is empty (  )  )   {  try  {  send queue . wait ( 60 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }   }  state = peer . state ;  if  (  ! quit && state  !  =  null && peer . is connected (  )  )   {   iterator <  message >  it = send queue . iterator (  )  ;  while  ( m  =  =  null && it . has next (  )  )   {   message nm = it . next (  )  ;  if  ( nm . type  =  =   message . piece )   {  if  ( state . choking )   {  it . remove (  )  ;  if  ( peer . supports fast (  )  )   {   message r = new  message (  message . reject nm . piece nm . begin nm . length )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +  peer  +  ": " +  r )  ;  r . send message ( dout )  ;   }   }  nm = null ;   }  else if  ( nm . type  =  =   message . request && state . choked )   {  it . remove (  )  ;  nm = null ;   }  if  ( nm  !  =  null )   {  m = nm ;  it . remove (  )  ;   }   }  if  ( m  =  =  null )   {  m = send queue . poll (  )  ;   }   }   }  if  ( m  !  =  null )   {  if  (    log . should log (  log . debug )  )     log . debug ( " send "  +  peer  +  ": " +  m )  ;  last sent =  system . current time millis (  )  ;  if  ( m . type  =  =   message . choke )  remove message (  message . piece )  ;  int remainder = 0 ;  if  ( m . type  =  =   message . piece )   {  if  ( m . len  <  =   peer state . partsize )   {  state . uploaded ( m . len )  ;   }  else  {  state . uploaded (  peer state . partsize )  ;  remainder = m . len  -   peer state . partsize ;   }   }  m . send message ( dout )  ;  if  ( remainder  >  0 )  state . uploaded ( remainder )  ;  m = null ;   }   }   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . info )  )     log . info ( "io error sending to "  +  peer ioe )  ;   }  catch  (   throwable t )   {     log . error ( " error sending to "  +  peer t )  ;  if  ( t instanceof  out of memory error )  throw  (  out of memory error ) t ;   }  finally  {  quit = true ;  peer . disconnect (  )  ;   }   }  
@ test public void   (  )  {  perform test using ( false )  ;   }  
public  collection <  string >    (  )  {  return users ;   }  
  (  subscriber <  ?  super t >  actual  maybe source <  ?  extends t >  other )  {  super ( actual )  ;  this . other = other ;  this . other disposable = new  atomic reference <  disposable >  (  )  ;   }  
private void   (  )  {  if  ( port  <  =  0 || port  >  =  65535 )  throw new  illegal argument exception ( " bad port" )  ;  byte[] compact info = new byte[length] ;   system . arraycopy ( nid . get data (  )  0 compact info 0 nid . hash   length )  ;   system . arraycopy ( hash . get data (  )  0 compact info nid . hash   length  hash . hash   length )  ;   data helper . to long ( compact info nid . hash   length  +   hash . hash   length 2 port )  ;  set data ( compact info )  ;   }  
synchronized  index searcher   (  )  throws io exception  {  if  ( searcher  =  =  null )   {  searcher = new  index searcher ( directory )  ;   }  else if  (  ! searcher . get index reader (  )  . is current (  )  )   {  searcher . close (  )  ;  searcher = new  index searcher ( directory )  ;   }  return searcher ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 1l )  {  @ override public void on next (   integer t )  {  super . on next ( t )  ;  request ( 1 )  ;   }   }   ;   flowable . range ( 1 5 )  . filter 
@ test ( timeout = 5000 )  public void   (  )  {   flowable <  integer >  source =  flowable . just ( 1 )  . all ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return false ;   }   }   )  . flat map publisher (
public void   (  group shared group )  {  shared groups . add ( shared group . get name (  )  )  ;  invisible shared groups . remove ( shared group . get name (  )  )  ;   }  
public static void   (  map <  string  host txt entry >  map  file file )  throws io exception  {  boolean success = false ;  if  (  ! is windows )   {   file tmp =  secure file . create temp file ( "temp - " " . tmp" file . get absolute file (  )  . get parent file (  )  )  ;  write ( map new  buffered writer ( new  output stream writer ( new  secure file output stream ( tmp )  "utf - 8" )  )  )  ;  success = tmp . rename to ( file )  ;  if  (  ! success )   {  tmp . delete (  )  ;   }   }  if  (  ! success )   {  write ( map new  buffered writer ( new  output stream writer ( new  secure file output stream ( file )  "utf - 8" )  )  )  ;   }   }  
@ override public void   (  object t )  {  count +  +  ;   }  
public   (  string message )  {  super ( message )  ;   }  
public void   ( iq packet )  throws  unauthorized exception   packet exception  {  if  ( packet  =  =  null )   {  throw new  illegal argument exception ( " argument 'packet' cannot be null . " )  ;   }  final  string xmlns ;  final  element child =  ( packet )  . get child element (  )  ;  if  ( child  !  =  null )   {  xmlns = child . get namespaceuri (  )  ;   }  else  {  xmlns = null ;   }  if  ( xmlns  =  =  null )   {   log . debug ( " cannot process this stanza  as it has no namespace:"  +  packet . toxml (  )  )  ;  final iq error = iq . create resultiq ( packet )  ;  error . set error (  condition . bad   request )  ;  parent . send packet ( error )  ;  return ;   }  final  element remove = packet . get child element (  )  . element ( "remove" )  ;  if  ( remove  !  =  null )   {  handle deregister ( packet )  ;   }  else  {  switch  ( packet . get type (  )  )   {  case get: get registration form ( packet )  ;  break ;  case set: set registration form ( packet )  ;  break ;  default : break ;   }   }   }  
public synchronized boolean   (  )  {  return    load in progress  !  =  null ;   }  
public void   ( int id )  {  this . id = id ;   }  
@ test public void   (  )  {   observable . range ( 1 1000 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe .  <
private v   ( k key )  throws io exception  {  seek data (  )  ;  int cur page = this . page ;  int[] cur next page = new int[1] ;  cur next page[0] = this . overflow page ;  int[] page counter = new int[1] ;  page counter[0] = header   len ;  int fail = 0 ;  for  ( int i = 0 ;  i  <  this . n keys ;  i +  +  )   {  if  (  ( page counter[0]  +  4 )   >   block file . pagesize )   {   block file . page seek ( this . bf . file cur next page[0] )  ;  int magic = bf . file . read int (  )  ;  if  ( magic  !  =   block file . magic   cont )   {  bf . log . error ( " lost "  +   ( this . n keys  -  i )   +  " entries  -   bad  skip span magic number 0x" +   integer . to hex string ( magic )  +  " on page " +  cur next page[0] )  ;  lost entries ( i cur page )  ;  break ;   }  cur page = cur next page[0] ;  cur next page[0] = this . bf . file . read unsigned int (  )  ;  page counter[0] = cont   header   len ;   }  int ksz = this . bf . file . read unsigned short (  )  ;  int vsz = this . bf . file . read unsigned short (  )  ;  page counter[0] +  = 4 ;  byte[] k = new byte[ksz] ;  try  {  cur page = this . bf . read multi page data ( k cur page page counter cur next page )  ;   }  catch  (  io exception ioe )   {  bf . log . error ( " lost "  +   ( this . n keys  -  i )   +  " entries  -   error loading " +  this +  " on page " +  cur page ioe )  ;  lost entries ( i cur page )  ;  break ;   }  k ckey = this . key ser . construct ( k )  ;  if  ( ckey  =  =  null )   {  cur page = this . bf . skip multi page bytes ( vsz cur page page counter cur next page )  ;  bf . log . error ( " null deserialized key in entry "  +  i  +  " page " +  cur page )  ;  fail +  +  ;  continue ;   }  int diff = ckey . compare to ( key )  ;  if  ( diff  =  =  0 )   {  byte[] v = new byte[vsz] ;  try  {  cur page = this . bf . read multi page data ( v cur page page counter cur next page )  ;   }  catch  (  io exception ioe )   {  bf . log . error ( " lost "  +   ( this . n keys  -  i )   +  " entries  -   error loading " +  this +  " on page " +  cur page ioe )  ;  lost entries ( i cur page )  ;  break ;   }  v rv = this . val ser . construct ( v )  ;  if  ( rv  =  =  null )   {  bf . log . error ( " null deserialized value in entry "  +  i  +  " page " +  cur page +  " key = " +  ckey )  ;  fail +  +  ;   }  if  ( fail  >  0 )  repair ( fail )  ;  return rv ;   }  if  ( diff  >  0 )   {  if  ( fail  >  0 )  repair ( fail )  ;  return null ;   }  cur page = this . bf . skip multi page bytes ( vsz cur page page counter cur next page )  ;   }  if  ( fail  >  0 )  repair ( fail )  ;  return null ;   }  
public static void   (  prepared statement pstmt int parameter index  string value )  throws sql exception  {  if  ( is stream text required (  )  )   {   reader body reader ;  try  {  body reader = new  string reader ( value )  ;  pstmt . set character stream ( parameter index body reader value . length (  )  )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;  throw new sql exception ( " failed to set text field . " )  ;   }   }  else  {  pstmt . set string ( parameter index value )  ;   }   }  
public  string   (  )  {  return ifexists ;   }  
@ override public boolean   (  object o )  {  if  ( o  =  =  this )  return true ;  if  (  !  ( o instanceof  eddsa private key )  )  return false ;   eddsa private key pk =  (  eddsa private key ) o ;  return  arrays . equals ( seed pk . get seed (  )  )
public  chatbot session   ( jid user boolean create )  {   string fulljid = user . to string (  )  ;   chatbot session session = sessions . get ( fulljid )  ;  if  ( session  =  =  null && create )   {  synchronized  ( fulljid . intern (  )  )   {  session = sessions . get ( fulljid )  ;  if  ( session  =  =  null )   {  session = new  chatbot session ( user this )  ;  sessions . put ( fulljid session )  ;   }   }   }  return session ;   }  
@ test public void   (  )  {  final int num = 10 ;  final  atomic integer upstream count = new  atomic integer (  )  ;   object count =  flowable . range ( 1 num )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   inte
public void   ( final int reference sequence index final int alignment start final boolean is duplicate final  string cigar final int default quality score )  {  final  abstract mark duplicates command line program tester tester = get tester (  )  ;  tester . add mate pair ( "runid:1:1:15993:13361" 2 41212324 41212310 false false false false "33s35m" "19s49m" true true false false false default   base   quality )  ;  tester . add mate pair ( "runid:2:2:15993:13362" 2 41212324 41212310 false false true true "33s35m" "19s49m" true true false false false default   base   quality )  ;  final  string barcode tag = "bc" ;  for  (  final sam record record : new  iterable adapter < sam record >  ( tester . get record iterator (  )  )  )   {  record . set attribute ( barcode tag " barcode1" )  ;   }  tester . add arg ( "barcode   tag = "  +  barcode tag )  ;  tester . run test (  )  ;   }  
@ override public void   (  string property  map params )  {  if  ( "provider . auth . class name" . equals ( property )  )   {  init provider (  )  ;   }   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ check return value @ scheduler support (  scheduler support . none )  public static  < t >  observable < t >    (  observable source <  ?  extends t >  source1  observable source <  ?  extends t >  s
private  config   (  validator item validator item boolean is delegating double delegation quality boolean multi role match  string config root  string component name )  {   config config = new  config (  )  ;  config . setxsd engine ( validator item . get xsd engine (  )  . value (  )  )  ;  config . setxsl engine ( validator item . get xsl engine (  )  . value (  )  )  ;  config . set result handler ( get handlers ( validator item is delegating delegation quality multi role match config root component name )  )  ;  config . set check well formed ( validator item . is check well formed (  )  )  ;  config . set checkxsd grammar ( validator item . is check xsd grammar (  )  || validator item . is check grammars (  )  )  ;  config . set checkjson grammar ( validator item . is check grammars (  )  )  ;  config . set check elements ( validator item . is check elements (  )  )  ;  config . setx path version ( validator item . get xpath version (  )  )  ;  config . set check plain params ( validator item . is check plain params (  )  )  ;  config . set doxsd grammar transform ( validator item . is do xsd grammar transform (  )  )  ;  config . set enable pre process extension ( validator item . is enable pre process extension (  )  )  ;  config . set remove dups ( validator item . is remove dups (  )  )  ;  config . set validate checker ( validator item . is validate checker (  )  )  ;  config . set joinx path checks ( validator item . is join xpath checks (  )  )  ;  config . set check headers ( validator item . is check headers (  )  )  ;  config . set enable ignorexsd extension ( validator item . is enable ignore xsd extension (  )  )  ;  config . set enable rax roles extension ( validator item . is enable rax roles (  )  )  ;  config . set mask rax roles403 ( validator item . is mask rax roles403 (  )  )  ;  config . set set param defaults ( true )  ;  config . set enable authenticated by extension ( true )  ;  return config ;   }  
@ override public void   (  string arg0  string arg1 )  {  if  ( arg0 . equals (  translate . prop   lang )  )   {  tray manager . language changed (  )  ;   }   }  
private void   (  graphics2d g float x float y float size int patch int turn boolean invert  color fill color  color stroke color )  {  assert patch  >  =  0 ;  assert turn  >  =  0 ;  patch% = patch types . length ;  turn% = 4 ;  if  (  ( patch flags[patch] & patch   inverted )   !  =  0 )  invert =  ! invert ;   shape shape = patch shapes[patch] ;  double scale =  (  ( double ) size )   /   (  ( double ) patch size )  ;  float offset = size  /  2 . 0f ;  g . set color ( invert  ?  fill color : background color )  ;  g . fill ( new  rectangle2d .  float ( x y size size )  )  ;   affine transform savet = g . get transform (  )  ;  g . translate ( x  +  offset y  +  offset )  ;  g . scale ( scale scale )  ;  g . rotate (  math . to radians ( turn * 90 )  )  ;  if  ( stroke color  !  =  null )   {  g . set color ( stroke color )  ;  g . draw ( shape )  ;   }  g . set color ( invert  ?  background color : fill color )  ;  g . fill ( shape )  ;  g . set transform ( savet )  ;   }  
public  string   (  )  {   string buffer buf = new  string buffer (  )  ;  buf . append ( " < " )  . append ( get element name (  )  )  . append ( " xmlns = \"" )  . append ( get namespace (  )  )  . append ( "\"" )  ;  if  ( query  !  =  null )   {  buf . append ( " q = \"" )  . append ( query )  . append ( "\"" )  ;   }  if  ( newer than time  !  =  null )   {  buf . append ( " newer - than - time = \"" )  . append ( newer than time . get time (  )  )  . append ( "\"" )  ;   }  if  ( newer than tid  !  =  null )   {  buf . append ( " newer - than - tid = \"" )  . append ( newer than tid )  . append ( "\"" )  ;   }  buf . append ( " /  > " )  ;  return buf . to string (  )  ;   }  
public   (  string prefix  object bean )  {  super ( prefix bean )  ;  this . property descriptors = class   property   descriptors . get ( bean . get class (  )  )  ;   }  
public synchronized void   (  )  {  starting = true ;  try  {  x   start torrent (  )  ;     started time =    util . get context (  )  . clock (  )  . now (  )  ;   }  finally  {  starting = false ;   }   }  
public int   (  )  {  return    resend delay ;   }  
@ override public  time unit   (  )  {  return configured rate limit . get unit (  )  ;   }  
public byte[]   (  )  {  return content ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 2 3 4 5 )  ;   iterable <  string >  it =  arrays . as list ( "a" "b" "c" "d" "e" )  ;   square str square str = new  square str (  )  ;  o . map ( square str )  . zip with
@ xml element wrapper ( name = "admin groups" )  @ xml element ( name = "admin group" )  public  list <  string >    (  )  {  return admin groups ;   }  
private void   (  )  {  synchronized  (    outbound packets )   {  if  (    outbound packets . is empty (  )  )  return ;  for  (   packet local pl :    outbound packets . values (  )  )   {  pl . cancelled (  )  ;   }     outbound packets . clear (  )  ;     outbound packets . notify all (  )  ;   }   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  completable transformer transformer )  {  return wrap (  object helper . require non null ( transformer "transformer is null" )  . apply ( this )  )  ; 
public static void   ( boolean allow short names )  {   conference manager . allow short names = allow short names ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  atomic integer wip = new  atomic integer (  )  ;  final  atomic throwable error = new  atomic throwable (  )  ;  final  test observer < 
@ test public void   (  )  {   test scheduler test = new  test scheduler (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . hide (  )  . subscribe on ( test )  . subscribe ( to )  ;  to . dispo
public static void   (  string[] args )  {  boolean error = false ;   string created   by = null ;   string announce = null ;   getopt g = new  getopt ( " storage" args "a:c:" )  ;  try  {  int c ;  while  (  ( c = g . getopt (  )  )   !  =   - 1 )   {  switch  ( c )   {  case 'a': announce = g . get optarg (  )  ;  break ;  case 'c': created   by = g . get optarg (  )  ;  break ;  case ' ? ': case ':': default : error = true ;  break ;   }   }   }  catch  (  runtime exception e )   {  e . print stack trace (  )  ;  error = true ;   }  if  ( error || args . length  -  g . get optind (  )   !  =  1 )   {   system . err . println ( " usage:  storage [ - a announceurl] [ - c created - by] file - or - dir" )  ;   system . exit ( 1 )  ;   }   file base = new  file ( args[g . get optind (  ) ] )  ;  i2p app context ctx = i2p app context . get global context (  )  ;  i2p snark util util = new i2p snark util ( ctx )  ;   file file = null ;   file output stream out = null ;  try  {   storage storage = new  storage ( util base announce null created   by false null )  ;   meta info meta = storage . get meta info (  )  ;  file = new  file ( storage . get base name (  )   +  " . torrent" )  ;  out = new  file output stream ( file )  ;  out . write ( meta . get torrent data (  )  )  ;   string hex =  data helper . to string ( meta . get info hash (  )  )  ;   system . out . println ( " created: "  +  file )  ;   system . out . println ( " info hash: "  +  hex )  ;   string basename = base . get name (  )  . replace ( " " "%20" )  ;   string magnet =  magneturi . magnet   full  +  hex  +  "&dn = " +  basename ;  if  ( announce  !  =  null )  magnet +  = "&tr = "  +  announce ;   system . out . println ( " magnet: "  +  magnet )  ;   }  catch  ( io exception ioe )   {  if  ( file  !  =  null )  file . delete (  )  ;  ioe . print stack trace (  )  ;   system . exit ( 1 )  ;   }  finally  {  try  {  if  ( out  !  =  null )  out . close (  )  ;   }  catch  ( io exception ioe )   {   }   }   }  
public   (  class <  ?  extends t >  wrapped class )  {  this . wrapped class = wrapped class ;   }  
@ test public void   (  )  {   test helper . check disposed (  observable . just ( 1 )  . on error return item ( 1 )  )  ;   }  
@ override public boolean   ( final sam record record )  {  return record . get mapping quality (  )   <  min mapq ;   }  
private static i2p app context   (  )  {  return i2p app context . get global context (  )  ;   }  
@ override public void   (  node node jid user )  {   pub sub engine . presence subscription required ( this node user )  ;   }  
private   (  )  {  host =  jive globals . get property ( "mail . smtp . host" "localhost" )  ;  port =  jive globals . get int property ( "mail . smtp . port" 25 )  ;  username =  jive globals . get property ( "mail . smtp . username" )  ;  password =  jive globals . get property ( "mail . smtp . password" )  ;  ssl enabled =  jive globals . get boolean property ( "mail . smtp . ssl" )  ;  debug enabled =  jive globals . get boolean property ( "mail . debug" )  ;   }  
public static  sorted set <  string >    (  )  {  return get addresses ( true true )  ;   }  
@ xml element public  string   (  )  {  return role ;   }  
public boolean   (  )  {  if  ( is close connection (  )   =  =  true )  return false ;  if  ( is keep alive connection (  )   =  =  true )  return true ;   string http ver = gethttp version (  )  ;  boolean ishttp10 =  ( 0  <  http ver . index of ( "1 . 0" )  )   ?  true : false ;  if  ( ishttp10  =  =  true )  return false ;  return true ;   }  
public synchronized void   (  string algorithm )  throws  certificate store config exception  {  final int key size ;  final  string sign algorithm ;  switch  ( algorithm . to upper case (  )  )   {  case "rsa": key size =  jive globals . get int property ( "cert . rsa . keysize" 2048 )  ;  sign algorithm = "sha256withrsaencryption" ;  break ;  case "dsa": key size =  jive globals . get int property ( "cert . dsa . keysize" 1024 )  ;  sign algorithm = "sha256withdsa" ;  break ;  default : throw new  illegal argument exception ( " unsupported algorithm '"  +  algorithm  +  "' .   use 'rsa' or 'dsa' . " )  ;   }  final  string name =  jive globals . get property ( "xmpp . domain" )  . to lower case (  )  ;  final  string alias = name  +  "   "  +  algorithm . to lower case (  )  ;  final int validity in days = 5 * 365 ;  final  set <  string >  san dns names =  certificate manager . determine subject alternate name dns name values (  )  ;   log . info ( " generating a new private key and corresponding self - signed certificate for domain name ' {  } '  using the  {  }  algorithm  ( sign - algorithm:  {  }  with a key size of  {  }  bits )  .   certificate will be valid for  {  }  days . " name algorithm sign algorithm key size validity in days )  ;  try  {  final  key pair key pair = generate key pair ( algorithm . to upper case (  )  key size )  ;  final x509 certificate cert =  certificate manager . createx509v3 certificate ( key pair validity in days name name name sign algorithm san dns names )  ;  store . set key entry ( alias key pair . get private (  )  configuration . get password (  )  new x509 certificate[] { cert }  )  ;  persist (  )  ;   }  catch  (  certificate store config exception|io exception| general security exception ex )   {  reload (  )  ;  throw new  certificate store config exception ( " unable to generate new self - signed "  +  algorithm  +  " certificate . " ex )  ;   }   }  
private  internal component manager   (  )  {  return  (  internal component manager ) modules . get (  internal component manager . class )  ;   }  
public int   (  string b32 int port  string type )  {  dcc client manager tracker ;  synchronized  ( this )   {  if  (    dcc client manager  =  =  null )   {  if  (    log . should log (  log . info )  )     log . info ( " starting dcc  client" )  ;     dcc client manager = new dcc client manager ( sock mgr l i2p tunnelirc client . this get tunnel (  )  )  ;   }  tracker =    dcc client manager ;   }  int rv = tracker . new incoming ( b32 port type )  ;  if  (    log . should log (  log . info )  )     log . info ( " new incoming "  +  type  +  ' ' +  b32 +  ' ' +  port +  " returns " +  rv )  ;  return rv ;   }  
public void   (  )  throws  communications exception  {  init properties (  )  ;  sip config . set system properties (  )  ;  this . sip factory =  sip factory . get instance (  )  ;  sip factory . set path name ( sip stack path )  ;  try  {  address factory = sip factory . create address factory (  )  ;  header factory = sip factory . create header factory (  )  ;  message factory = sip factory . create message factory (  )  ;   }  catch  (   peer unavailable exception ex )   {   log . error ( "start" ex )  ;  throw new  communications exception ( " could not create factories ! " ex )  ;   }  try  {  sip stack = sip factory . create sip stack (  system . get properties (  )  )  ;   (  (  sip comm router ) sip stack . get router (  )  )  . set outbound proxy ( sip config . get outbound proxy (  )  )  ;   }  catch  (   peer unavailable exception ex )   {   log . error ( "start" ex )  ;  throw new  communications exception ( " cannot connect ! \n"  +  " cannot reach proxy . \n check your connection . "  +  " (  syntax: < proxy   address:port / transport >  ) " ex )  ;   }  try  {  boolean successfully bound = false ;  while  (  ! successfully bound )   {  try  {  public ip address = new  inet socket address ( local address local port )  ;  listening point = sip stack . create listening point ( local port transport )  ;   }  catch  (   invalid argument exception ex )   {  local port =  ( int )  (  ( 65000  -  1024 )  *  math . random (  )  )   +  1024 ;  try  {   thread . sleep ( 1000 )  ;   }  catch  (   exception e )   {   }  continue ;   }  successfully bound = true ;   }   }  catch  (   transport not supported exception ex )   {  throw new  communications exception ( " transport "  +  transport  +  " is not suppported by the stack ! \n  try specifying another" +  " transport in  mais property files . \n" ex )  ;   }  try  {  sip provider = sip stack . create sip provider ( listening point )  ;   }  catch  (   object in use exception ex )   {   log . error ( "start" ex )  ;  throw new  communications exception ( " could not create factories ! \n" ex )  ;   }  try  {  sip provider . add sip listener ( this )  ;   }  catch  (   too many listeners exception exc )   {  throw new  communications exception ( " could not register  sip manager as a sip listener ! " exc )  ;   }  sip security manager . set header factory ( header factory )  ;  sip security manager . set transaction creator ( sip provider )  ;  sip security manager . set sip man callback ( this )  ;  contact header = null ;  from header = null ;  via headers = null ;  max forwards header = null ;  is started = true ;   }  
@ after test private void   (  )  {  io util . delete directory tree ( root test dir )  ;   }  
public   (  )  {  super ( null )  ;   }  
public void   (  input stream in )  throws  data format exception  io exception  {     severity id =  ( int )  data helper . read long ( in 1 )  ;   }  
public void   ( long timeout )  {  offer timeout = timeout ;   }  
  ( double grid int lfac1 int lfac2 int lfac3 int lfac4 )  {  this . grid = grid ;  lfac = new int[] { lfac1 lfac2 lfac3 lfac4 }  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  thread t0 =  thread . current thread (  )  ;   worker w =  schedulers . computation (  )  . create worker (  )  ;  try  {  w . schedule ( 
 pattern   (  )  {  return pattern ;   }  
@ test public void   (  )  {   map <  string  string >  m1 = get map ( " one" )  ;   map <  string  string >  m2 = get map ( " two" )  ;   observable <  map <  string  string >  >  o =  observable . just ( m1 m2 )  ;   observable <  string >  m = o . map 
@ test public void   (  )  throws  exception  {  @ suppress warnings ( "unchecked" )   future <  object >  future = mock (  future . class )  ;   object value = new  object (  )  ;  when ( future . get (  )  )  . then return ( value )  ;   observer <  obj
@ override public boolean   (  )  throws sql exception  {  return false ;   }  
public   (  transport buddy manager <  my spaceim buddy >  manager  integer userid )  {  super ( manager  string . value of ( userid )   string . value of ( userid )   arrays . as list ( "im  buddies" )  )  ;   }  
public boolean   (  )  {  return  ( 0  <  first line . length (  )  )   ?  true : false ;   }  
protected void   (  )  {   string treatment = cp . get call answered treatment (  )  ;  int repeat count = 0 ;  if  ( cp . get join confirmation timeout (  )   !  =  0 )   {  repeat count = 30 ;   }  call answered treatment = initialize treatment ( treatment repeat count )  ;  if  ( call handler . is first member (  )  )   {  treatment = cp . get first conference member treatment (  )  ;  if  ( treatment  !  =  null )   {  call answered treatment = initialize treatment ( treatment repeat count )  ;   }   }   }  
@ data provider ( name = " " )  public  object[][] varied accumulation levels (  )  {  return new  object[][] {  { make set (  metric accumulation level . all   reads )  }   { make set (  metric accumulation level . all   reads  metric accumulation level 
public  key generator   (  )  {  if  (  !    key generator initialized )  initialize key generator (  )  ;  return    key generator ;   }  
public static void   (  datagram socket socket )  {  int len =  rtp packet . get data size (  rtp packet . pcm   encoding  rtp packet . max   sample   rate 2 )  ;  len +  =  rtp packet . header   size ;  byte[] data = new byte[len] ;   datagram packet packet = new  datagram packet ( data len )  ;  int count = 0 ;  try  {  socket . set so timeout ( 1 )  ;  while  ( true )   {  try  {  socket . receive ( packet )  ;  count +  +  ;   }  catch  (   socket timeout exception e )   {  break ;   }  catch  (  io exception e )   {   logger . println ( " error flushing socket "  +  e . get message (  )  )  ;  break ;   }   }   }  catch  (   socket exception e )   {   logger . println ( " can't flush receiver socket ! " )  ;   }  if  ( count  >  0 )   {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " packets flushed: "  +  count )  ;   }   }  try  {  socket . set so timeout ( 0 )  ;   }  catch  (   socket exception e )   {   logger . println ( " can't set socket timeout to 0 ! " )  ;   }   }  
public   (  string progname  string[] argv  string optstring  long opt[] long   options boolean long   only )  {  if  ( optstring . length (  )   =  =  0 )  optstring = " " ;  this . progname = progname ;  this . argv = argv ;  this . optstring = optstring ;  this . long   options = long   options ;  this . long   only = long   only ;  if  (  system . get property ( "gnu . posixly   correct" null )   =  =  null )  posixly   correct = false ;  else  {  posixly   correct = true ;     messages =  resource bundle . get bundle ( "gnu / getopt /  messages bundle"  locale . us )  ;   }  if  ( optstring . char at ( 0 )   =  =  ' - ' )   {  ordering = return   in   order ;  if  ( optstring . length (  )   >  1 )  this . optstring = optstring . substring ( 1 )  ;   }  else if  ( optstring . char at ( 0 )   =  =  ' + ' )   {  ordering = require   order ;  if  ( optstring . length (  )   >  1 )  this . optstring = optstring . substring ( 1 )  ;   }  else if  ( posixly   correct )   {  ordering = require   order ;   }  else  {  ordering = permute ;   }   }  
public byte[]   (  )  {  return seed ;   }  
@ override public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write boolean ( out alternatejid  !  =  null )  ;  if  ( alternatejid  !  =  null )   {   externalizabl
void   (  )  {  done = true ;   throwable ex = new  null pointer exception ( " subscription not set ! " )  ;  try  {  actual . on subscribe (  empty subscription . instance )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( new  composite exception ( ex e )  )  ;  return ;   }  try  {  actual . on error ( ex )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( new  composite exception ( ex e )  )  ;   }   }  
private void   (  )  throws io exception  {  if  (  ! is read only (  )  )   {  final  string canonical path =  util . get canonical path ( get path (  )  )  ;  synchronized  ( m   open files )   {  if  ( m   open files . contains ( canonical path )  )   {  throw new io exception ( " file \""  +  get path (  )   +  "\" already open for r / w access .  " +  " you cannot open the same file for r / w access twice" )  ;   }  else  {  m   open files . add ( canonical path )  ;   }   }   }   }  
@ test public void   (  )  {   single subject <  integer >  ss =  single subject . create (  )  ;  try  {  ss . on error ( null )  ;  fail ( " no  null pointer exception thrown" )  ;   }  catch  (   null pointer exception ex )   {  assert equals ( "on err
@ override protected void   (  input stream in int size )  throws i2cp message exception  io exception  {  try  {     session id = new  session id (  )  ;     session id . read bytes ( in )  ;     status =  ( int )  data helper . read long ( in 1 )  ;   }
public  output stream   (  )  {  return m out ;   }  
void   (  throwable ex int index )  {  if  ( get and set ( 0 )   >  0 )   {  dispose except ( index )  ;  actual . on error ( ex )  ;   }  else  {   rx java plugins . on error ( ex )  ;   }   }  
@ override public void   (  throwable e )  {  o . set ( e )  ;  finish . count down (  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;  final  single subject <  integer >  ms1 =  single subject . create (  )  ;  final  single subject <  integer >  ms2 =  single subject . create (  )  ;
@ test public void   (  )  {  check action called (  observable .  <  string > error ( new  runtime exception ( "expected" )  )  )  ;   }  
private  request queue   (  workgroup workgroup  map <  string  list <  string >  >  meta data )  {   request queue best queue = null ;  int best match =  - 1 ;  int current match ;  for  (   request queue request queue : workgroup . get request queues (  )  )   {  if  (  ! request queue . is opened (  )  )   {  continue ;   }  int overflow value = request queue . get overflow type (  )  . ordinal (  )  ;  switch  ( overflow value )   {  case 1: if  ( request queue . get agent session list (  )  . contains available agents (  )  )   {  current match = calculate match score ( request queue meta data )  ;  if  ( current match  >  best match )   {  best queue = request queue ;  best match = current match ;   }   }  break ;  case 2: current match = calculate match score ( request queue meta data )  ;  if  ( current match  >  best match )   {  if  (  ! request queue . get agent session list (  )  . contains available agents (  )  && request queue . get backup queue (  )   !  =  null )   {  best queue = request queue . get backup queue (  )  ;   }  else  {  best queue = request queue ;   }  best match = current match ;   }  break ;  default : current match = calculate match score ( request queue meta data )  ;  if  ( current match  >  best match )   {  best queue = request queue ;  best match = current match ;   }   }   }  return best queue ;   }  
@ override public int   (  )  {  return    manager . count active send peers (  )  ;   }  
private void   (  vector v  graphics g  color c )  {  g . set color ( c )  ;   dimension d = get size (  )  ;  int height = d . height ;   point previous point = null ;  int size = v . size (  )  ;  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  try  {   point point1 = previous point ;   point point2 = new  point ( i  (  (  point ) v . element at ( i )  )  . y )  ;  if  ( point1  =  =  null )  point1 = point2 ;  previous point = point2 ;  g . draw line ( point1 . x height  -  point1 . y point2 . x height  -  point2 . y )  ;   }  catch  (   no such element exception e )   {  break ;   }   }   }  
public  string   (  )  {  return    context . get property (  client manager facade impl . prop   client   port  integer . to string (  client manager facade impl . default   port )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  error . do on error ( null )  ;   }  
public void   (  string alias  string pem certificates  string pem private key  string pass phrase )  throws  certificate store config exception  {  if  ( alias  =  =  null || alias . trim (  )  . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'alias' cannot be null or an empty  string . " )  ;   }  if  ( pem certificates  =  =  null || pem certificates . trim (  )  . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'pem certificates' cannot be null or an empty  string . " )  ;   }  if  ( pem private key  =  =  null || pem private key . trim (  )  . is empty (  )  )   {  throw new  illegal argument exception ( " argument 'pem private key' cannot be null or an empty  string . " )  ;   }  alias = alias . trim (  )  ;  pem certificates = pem certificates . trim (  )  ;  try  {  if  ( store . contains alias ( alias )  )   {  throw new  certificate store config exception ( " certificate already exists for alias: "  +  alias )  ;   }  final  collection < x509 certificate >  certificates =  certificate manager . parse certificates ( pem certificates )  ;  if  ( certificates . is empty (  )  )   {  throw new  certificate store config exception ( " no certificate was found in the input . " )  ;   }  final  list < x509 certificate >  ordered =  certificate utils . order ( certificates )  ;  if  (  ! is for this domain ( ordered . get ( 0 )  )  )   {  throw new  certificate store config exception ( " the supplied certificate chain does not cover the domain of this xmpp service . " )  ;   }  final  private key private key =  certificate manager . parse private key ( pem private key pass phrase )  ;  store . set key entry ( alias private key configuration . get password (  )  ordered . to array ( new x509 certificate[ordered . size (  ) ] )  )  ;  persist (  )  ;   log . info ( " installed a new private key and corresponding certificate chain . " )  ;   }  catch  (   certificate exception| key store exception|io exception e )   {  reload (  )  ;  throw new  certificate store config exception ( " unable to install a certificate into an identity store . " e )  ;   }   }  
public void   (  string s )  {  if  ( s  !  =  null )     new proxypw = s . trim (  )  ;   }  
public boolean   (  client client  listener i )  {  log . info ( "on subscribe "  +  i . get publication (  )  . c (  )  )  ;   string publish name = i . get publication (  )  . c (  )  ;  if  (  rtmfp call agent . publish handlers . contains key ( publish name )   =  =  false )   {   rtmfp call agent . publish handlers . put ( publish name com . jcumulus . server . rtmfp . publisher . e . i . get streams (  )  . a ( publish name )  )  ;   }  return true ;   }  
private  result iterator <  ?  >    ( final  handle handle final  prepared batch batch )  {  if  (  ! handle . is in transaction (  )  && sql batch . transactional (  )  )   {  return handle . in transaction ( c  -  >  batch intermediate . apply ( batch )  )  ;   }  else  {  return batch intermediate . apply ( batch )  ;   }   }  
public void   (  )  {  flush entries (  )  ;  update settings (  )  ;  requeue ( write   delay )  ;   }  
@ test ( timeout = 10000 )  public void   (  )  {  for  ( int i = 0 ;  i  <  50 ;  i +  +  )   {  final  replay subject <  string >  subject =  replay subject . create unbounded (  )  ;  final  atomic reference <  string >  value1 = new  atomic reference 
@ test public void   (  )  throws io exception  {  byte[] data written = fill ( new byte[default   size  +  10] )  ;  source buffer . put ( data written )  ;   byte buffer dest = source buffer . copy (  )  ;  byte[] data read = new byte[data written . len
@ override public long   (  )  {  return signed next long (  )  ;   }  
public int   (  tracker l  tracker r )  {  return l . name . to lower case (  )  . compare to ( r . name . to lower case (  )  )  ;   }  
private int   (  )  {  long time = calendar . get time (  )  . get time (  )   /  1000l ;  return  ( time  <  rrd graph . im . start )   ?   - 1 :  ( time  >  rrd graph . im . end )   ?   + 1 : 0 ;   }  
public final static boolean   (  string host )  {  try  {   inet address addr =  inet address . get by name ( host )  ;  if  ( addr instanceof  inet6 address )  return true ;  return false ;   }  catch  (   exception e )   {   }  return false ;   }  
private static void   (  )  {   system . err . println ( " eep head [ - p 127 . 0 . 0 . 1[:4444]] [ - c]\n"  +  " [ - n #retries]  ( default 0 ) \n"  +  " [ - t timeout]  ( default 60 sec ) \n" +  " [ - u username] [ - x password] url\n" +  "  ( use  - c or  - p :0 for no proxy ) " )  ;   }  
  ( final int metrics code )  {  this . metrics code = metrics code ;   }  
public  state variable data   (  )  {   node node = get state variable node (  )  ;   state variable data user data =  (  state variable data ) node . get user data (  )  ;  if  ( user data  =  =  null )   {  user data = new  state variable data (  )  ;  node . set user data ( user data )  ;  user data . set node ( node )  ;   }  return user data ;   }  
public  collection < jid >    (  )  {  return  admin manager . get instance (  )  . get admin accounts (  )  ;   }  
@ test public void   (  )  {   unicast processor <  integer >  us =  unicast processor . create ( false )  ;   test subscriber <  integer >  ts = us . to (  subscriber fusion .  <  integer > test ( 1  queue fuseable . any false )  )  ;  us . check termina
public   (  )  {  super ( " rayo: xep 0327  -   unmute" )  ;   }  
protected boolean   ( final  string path )  {  return  util . file exists ( path )  ;   }  
@ test public void   (  )  {   observable <  integer >  w =  observable . from iterable (  arrays . as list ( 1 2 3 )  )  . take ( 2 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer t1 )  {  throw new  
public void   (  agent session agent session )  {   workgroup event dispatcher . agent departed ( this agent session )  ;   workgroup manager . get instance (  )  . update workgroup status ( this )  ;   }  
@ test public void   (  )  {   completable c =  completable . complete (  )  ;  assert same ( c  (  (  has upstream completable source )  maybe . from completable ( c )  )  . source (  )  )  ;   }  
@ test public void   (  )  {   test observable source = new  test observable ( mock (  disposable . class )  "one" )  ;  final  runtime exception test exception = new  runtime exception ( "test exception" )  ;   observer <  string >  observer =  test help
@ override public void   (  throwable e )  throws  exception  {  list . add ( "on error" )  ;   }  
  (  router context ctx )  {  this . context = ctx ;  this . counter = new  object counter <  hash >  (  )  ;  ctx . simple timer2 (  )  . add periodic event ( new  cleaner (  )  clean   time )  ;   }  
public void   ( udp packet packet )  {  if  ( packet  =  =  null ||  !    keep running )  return ;  int psz = packet . get packet (  )  . get length (  )  ;  if  ( psz  >   peer state . max   mtu )   {     log . error ( " dropping large udp packet "  +  psz  +  " bytes: " +  packet )  ;  return ;   }  if  (    dummy )   {  packet . release (  )  ;  return ;   }  packet . request outbound bandwidth (  )  ;  try  {     outbound queue . put ( packet )  ;   }  catch  (   interrupted exception ie )   {  packet . release (  )  ;  return ;   }  if  (    log . should log (  log . debug )  )   {     log . debug ( " added the packet onto the queue with a lifetime of "  +  packet . get lifetime (  )  )  ;   }   }  
public static  map <  string  string >    ( i2p app context ctx )  {   map <  string  string >  rv = new  hash map <  string  string >  (  )  ;   list <  string >  names = get plugins (  )  ;  for  (   string name : names )   {   properties props = plugin properties ( ctx name )  ;   string pubkey = props . get property ( "key" )  ;   string signer = props . get property ( "signer" )  ;  if  ( pubkey  !  =  null && signer  !  =  null && pubkey . length (  )   =  =  172 && signer . length (  )   >  0 )  rv . put ( pubkey signer )  ;   }  return rv ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {   observable . error ( new  test exception (  )  )  . buffer ( 2 1  time unit . days )  . test (  )  . assert failure (  test exception . class )  ;   }  
public  string   (  )  {  return this . from domain ;   }  
@ test public void   (  )  {   flowable . range ( 0 100000 )  . take last ( 100000 )  . subscribe ( new  default subscriber <  integer >  (  )  {  @ override public void on start (  )  {  request (  long . max   value )  ;   }  @ override public void on c
public static  variant context   ( final  variant context vc final  collection <  string >  annotations to reverse final  collection <  string >  annotations to drop )  {  if  (  ! vc . is biallelic (  )  ||  ! vc . issnp (  )  )   {  throw new  illegal argument exception ( "swap ref alt can only process biallelic  snps  found "  +  vc . to string (  )  )  ;   }  final  variant context builder swapped builder = new  variant context builder ( vc )  ;  swapped builder . attribute ( swapped   alleles true )  ;  swapped builder . alleles (  arrays . as list ( vc . get alleles (  )  . get ( 1 )  . get base string (  )  vc . get alleles (  )  . get ( 0 )  . get base string (  )  )  )  ;  final  map <  allele  allele >  allele map = new  hash map <  >  (  )  ;  allele map . put ( vc . get alleles (  )  . get ( 0 )  swapped builder . get alleles (  )  . get ( 1 )  )  ;  allele map . put ( vc . get alleles (  )  . get ( 1 )  swapped builder . get alleles (  )  . get ( 0 )  )  ;  final  genotypes context swapped genotypes =  genotypes context . create ( vc . get genotypes (  )  . size (  )  )  ;  for  (  final  genotype genotype : vc . get genotypes (  )  )   {  final  list <  allele >  swapped alleles = new  array list <  >  (  )  ;  for  (  final  allele allele : genotype . get alleles (  )  )   {  if  ( allele . is no call (  )  )   {  swapped alleles . add ( allele )  ;   }  else  {  swapped alleles . add ( allele map . get ( allele )  )  ;   }   }  final  genotype builder builder = new  genotype builder ( genotype )  . alleles ( swapped alleles )  ;  if  ( genotype . hasad (  )  && genotype . getad (  )  . length  =  =  2 )   {  final int[] ad =  array utils . clone ( genotype . getad (  )  )  ;   array utils . reverse ( ad )  ;  builder . ad ( ad )  ;   }  else  {  builder . noad (  )  ;   }  if  ( genotype . haspl (  )  && genotype . getpl (  )  . length  =  =  3 )   {  final int[] pl =  array utils . clone ( genotype . getpl (  )  )  ;   array utils . reverse ( pl )  ;  builder . pl ( pl )  ;   }  else  {  builder . nopl (  )  ;   }  swapped genotypes . add ( builder . make (  )  )  ;   }  swapped builder . genotypes ( swapped genotypes )  ;  for  (  final  string key : vc . get attributes (  )  . key set (  )  )   {  if  ( annotations to drop . contains ( key )  )   {  swapped builder . rm attribute ( key )  ;   }  else if  ( annotations to reverse . contains ( key )  &&  ! vc . get attribute as string ( key "" )  . equals ( vcf constants . missing   value   v4 )  )   {  final double attribute to reverse = vc . get attribute as double ( key  - 1 )  ;  if  ( attribute to reverse  <  0 || attribute to reverse  >  1 )   {  log . warn ( " trying to reverse attribute "  +  key  +  " but found value that isn't between 0 and 1:  ( " +  attribute to reverse +  " )  in variant " +  vc +  " .   results might be wrong . " )  ;   }  swapped builder . attribute ( key 1  -  attribute to reverse )  ;   }   }  return swapped builder . make (  )  ;   }  
public static  comparator <  snark >    ( int type  string lang i2p snark servlet servlet )  {  boolean rev = type  <  0 ;   comparator <  snark >  rv ;  switch  ( type )   {  case  - 1: case 0: case 1: default : rv = new  torrent name comparator ( lang )  ;  if  ( rev )  rv =  collections . reverse order ( rv )  ;  break ;  case  - 2: case 2: rv = new  status comparator ( rev lang )  ;  break ;  case  - 3: case 3: rv = new  peers comparator ( rev lang )  ;  break ;  case  - 4: case 4: rv = new eta comparator ( rev lang )  ;  break ;  case  - 5: case 5: rv = new  size comparator ( rev lang )  ;  break ;  case  - 6: case 6: rv = new  downloaded comparator ( rev lang )  ;  break ;  case  - 7: case 7: rv = new  uploaded comparator ( rev lang )  ;  break ;  case  - 8: case 8: rv = new  down rate comparator ( rev lang )  ;  break ;  case  - 9: case 9: rv = new  up rate comparator ( rev lang )  ;  break ;  case  - 10: case 10: rv = new  remaining comparator ( rev lang )  ;  break ;  case  - 11: case 11: rv = new  ratio comparator ( rev lang )  ;  break ;  case  - 12: case 12: rv = new  file type comparator ( rev lang servlet )  ;  break ;   }  return rv ;   }  
@ override protected void   (  )  {  final  metrics file <  base distribution by cycle metrics  ?  >  metrics = get metrics file (  )  ;  hist . add to metrics file ( metrics )  ;  metrics . write ( output )  ;  if  ( hist . is empty (  )  )   {  log . wa
public  editor   (  string key float value )  {  m temp values . put ( key value )  ;  return this ;   }  
@ test public void   (  )  {   flowable . range ( 1 5 )  . parallel (  )  . compose ( new  parallel transformer <  integer  integer >  (  )  {  @ override public  parallel flowable <  integer >  apply (   parallel flowable <  integer >  pf )  {  return pf
public void   (  )  {   account account1 =  provider test utils . setup account ( "message - delete" true m mock context )  ;  long account1 id = account1 . m id ;   mailbox box1 =  provider test utils . setup mailbox ( "box1" account1 id true m mock context )  ;  long box1 id = box1 . m id ;   message message1 =  provider test utils . setup message ( "message1" account1 id box1 id false true m mock context )  ;  long message1 id = message1 . m id ;   message message2 =  provider test utils . setup message ( "message2" account1 id box1 id false true m mock context )  ;  long message2 id = message2 . m id ;   string selection =  email content .  message columns . account   key  +  " =  ?  and "  +   email content .  message columns . mailbox   key +  " =  ? " ;   string[] sel args = new  string[] {  string . value of ( account1 id )   string . value of ( box1 id )  }  ;  int num messages =  email content . count ( m mock context  message . content   uri selection sel args )  ;  assert equals ( 2 num messages )  ;   uri uri =  content uris . with appended id (  message . content   uri message1 id )  ;  m mock context . get content resolver (  )  . delete ( uri null null )  ;  num messages =  email content . count ( m mock context  message . content   uri selection sel args )  ;  assert equals ( 1 num messages )  ;  uri =  content uris . with appended id (  message . content   uri message2 id )  ;  m mock context . get content resolver (  )  . delete ( uri null null )  ;  num messages =  email content . count ( m mock context  message . content   uri selection sel args )  ;  assert equals ( 0 num messages )  ;   }  
public int   (  )  {  return    messages read . get (  )  ;   }  
public boolean   (  naming service ns boolean head )  {  return false ;   }  
public  session key   (  )  {  return    reply key ;   }  
public   (  sessions sessions )  {  this . sessions = sessions ;   }  
@ override public void   (  )  {  parent . inner complete (  )  ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;  nickname =  externalizable util . get instance (  )  . read safeutf ( in )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . concat array (  (  completable[] ) null )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . delay ( 1  time unit . seconds null )  ;   }  
public   (  string sql  list <  string >  values )  {  this . sql = sql ;  this . values = values ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "bb" "ccc" "dddd" )  ;   function <  string  string >  duplicate err = new  function <  string  string >  (  )  {  @ override public  string apply (   string t1 )  { 
public int   (  file file )  {  for  ( int i = 0 ;  i  <     torrent files . size (  )  ;  i +  +  )   {   file f =    torrent files . get ( i )  . ra ffile ;  if  ( f . equals ( file )  )  return i ;   }  return  - 1 ;   }  
public   ( final  list <  file >  read1 alignments final  list <  file >  read2 alignments  file reference fasta )  {  final  list < sam file header >  headers = new  array list <  >  (  )  ;  final  list <  sam reader >  read1 = new  array list <  >  ( read1 alignments . size (  )  )  ;  final  list <  sam reader >  read2 = new  array list <  >  ( read2 alignments . size (  )  )  ;  for  (  final  file f : read1 alignments )   {  final  sam reader r =  sam reader factory . make default (  )  . reference sequence ( reference fasta )  . open ( f )  ;  headers . add ( r . get file header (  )  )  ;  read1 . add ( r )  ;   }  for  (  final  file f : read2 alignments )   {  final  sam reader r =  sam reader factory . make default (  )  . reference sequence ( reference fasta )  . open ( f )  ;  headers . add ( r . get file header (  )  )  ;  read2 . add ( r )  ;   }  final  sam file header merger header merger = new  sam file header merger ( sam file header .  sort order . coordinate headers false )  ;  read1 iterator = new  peekable iterator <  >  ( new  suffix triming sam record iterator ( new  merging sam record iterator ( header merger read1 true )  " / 1" )  )  ;  read2 iterator = new  peekable iterator <  >  ( new  suffix triming sam record iterator ( new  merging sam record iterator ( header merger read2 true )  " / 2" )  )  ;  header = header merger . get merged header (  )  ;   }  
@ test public void   (  )  throws io exception  {  buffer = new  cyclic byte buffer (  )  ;  final byte[] random bytes = new byte[64] ;  new  random (  system . nano time (  )  )  . next bytes ( random bytes )  ;  buffer . put ( random bytes )  ;  final b
@ test public void   (  )  {   flowable . just ( 1 )  . zip with (  flowable . just ( 2 )  new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   integer a   integer b )  throws  exception  {  return a  +  b ;   }  
@ override public  sorting collection .  codec <  read ends for mark duplicates >    (  )  {  return new  read ends for mark duplicates with barcodes codec (  )  ;   }  
public long   (  )  {  return    context . clock (  )  . now (  )   -     started on ;   }  
public  packet   (  packet packet )  throws  packet rejected exception  {  return null ;   }  
@ test @ ignore ( " nulls are not allowed with rs" )  public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0 )  ;   flowable . range ( 1 2 )  . flat map ( new  function <  integer  flowable <  integer >  >  (  ) 
public  string   (  )  {  return  fastq to sam . class . get simple name (  )  ;   }  
private void   ( final  collection <  packet >  packets )  {  if  ( packets  =  =  null )   {  return ;   }   task engine . get instance (  )  . submit ( new  runnable (  )  {  @ override public void run (  )  {  for  (   packet packet : packets )   {  try  {  backup deliverer . deliver ( packet )  ;   }  catch  (   unauthorized exception e )   {   log . error ( " unable to deliver message to backup deliverer" e )  ;   }   }   }   }   )  ;   }  
void   (  cursor c long nano time )  {  if  ( c instanceof  cached cursor )   {  m stats . hit times +  = nano time ;  m stats . hits +  +  ;   }  else  {  if  ( c . get count (  )   =  =  1 )   {  m stats . miss times +  = nano time ;  m stats . miss +  +  ;   }   }   }  
public   (  )  throws  naming exception  {  super (  )  ;   }  
public  plugin   (  string canonical name )  {  return plugins loaded . get ( canonical name . to lower case (  )  )  ;   }  
public void   ( int len )  {  set header ( http . cache   control "max - age = "  +   integer . to string ( len )  )  ;   }  
public  data reader   (  )  {  return    data reader ;   }  
public  device list   (  )  {   device list dev list = new  device list (  )  ;   node dev list node = get device node (  )  . get node (  device list . elem   name )  ;  if  ( dev list node  =  =  null )  return dev list ;  int n node = dev list node . getn nodes (  )  ;  for  ( int n = 0 ;  n  <  n node ;  n +  +  )   {   node node = dev list node . get node ( n )  ;  if  (  device . is device node ( node )   =  =  false )  continue ;   device dev = new  device ( node )  ;  dev list . add ( dev )  ;   }  return dev list ;   }  
private   ( long time period int data points )  {  this . time period = time period ;  this . data points = data points ;   }  
  (  single observer <  ?  super  boolean >  actual  bi predicate <  ?  super t  ?  super t >  is equal )  {  super ( 2 )  ;  this . actual = actual ;  this . is equal = is equal ;  this . observer1 = new  equal observer < t >  ( this )  ;  this . observer2 = new  equal observer < t >  ( this )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts0 =  subscriber fusion . new test (  queue fuseable . async )  ;   flowable . range ( 1 5 )  . do after next ( after next )  . filter (  functions . always true (  )  )  . subscribe ( ts0 )  ;
public   (  )  {  super ( new url[] {  }  find parent class loader (  )  )  ;   }  
protected  object   (  )  {  return socketw lock ;   }  
@ override public void   (  throwable e )  {  if  ( this . d  =  =   disposable helper . disposed )   {   rx java plugins . on error ( e )  ;  return ;   }  on error inner ( e )  ;   }  
@ test public void   (  )  {   test helper . check invalid parallel subscribers (  flowable . just ( 1 )  . parallel ( 1 )  . filter (  functions . always true (  )   parallel failure handling . error )  )  ;   }  
@ override public boolean   (  )  {  return    alive &&    alias of . is alive (  )  ;   }  
@ override public int   (  )  {  return producer index . get (  )  ;   }  
@ test public void   (  )  {   test observer <  object >  to =  observable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  observable source <  object >
@ override public  observable <  boolean >    (  )  {  return  rx java plugins . on assembly ( new  observable sequence equal < t >  ( first second comparer buffer size )  )  ;   }  
double[]   (  )  {  return timestamps ;   }  
public int   (  )  {  int tags = 0 ;  long now =    context . clock (  )  . now (  )  ;  synchronized  (    tag sets )   {  for  ( int i = 0 ;  i  <     tag sets . size (  )  ;  i +  +  )   {   tag set set =    tag sets . get ( i )  ;  if  ( set . get date (  )   +  session   tag   duration   ms  >  now )   {  int sz = set . get tags (  )  . size (  )  ;  if  (  ! set . get acked (  )  )  sz =  ( sz  +  2 )   /  3 ;  tags +  = sz ;   }   }   }  return tags ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  this . value = null ;  actual . on error ( t )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on terminate ( null )  ;   }  
@ override public  string   (  )  {  return info ;   }  
public void   (  string host )  {  this . host = host ;   jive globals . set property ( "mail . smtp . host" host )  ;  session = null ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . flatten as observable ( new  function <  integer  iterable <  integer >  >  (  )  {  @ override public  iterable <  integer >  apply (   integer v )  throws  exception  {  return new  crashing iterable 
public void   ( t value )  {  head[0] = value ;   }  
@ test public void   (  )  {   single . merge delay error (  single . just ( 1 )   single .  <  integer > error ( new  test exception (  )  )  )  . test (  )  . assert failure (  test exception . class 1 )  ;   }  
@ test public void   (  )  {   single <  boolean >  observable =  flowable . sequence equal (  flowable . concat (  flowable . just ( "one" )   flowable .  <  string > error ( new  test exception (  )  )  )   flowable . just ( "one" "two" "three" )  )  ; 
public static  list <  user entity >    (  collection <  user >  users  string user search )  {   list <  user entity >  result = new  array list <  user entity >  (  )  ;  for  (   user user : users )   {  if  ( user search  !  =  null )   {  if  (  ! user . get username (  )  . contains ( user search )  )   {  continue ;   }   }  result . add ( convert user to user entity ( user )  )  ;   }  return result ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  public void   (  )  throws  exception  {  i2p app context ctx = new i2p app context (  )  ;  router dir = ctx . get router dir (  )  ;   input stream is = get class (  )  . get resource as stream ( " /
@ override public int   (  )  throws sql exception  {  return concur   read   only ;   }  
static long   ( long array[] )  {  long rate = 0 ;  int i = 0 ;  int factor = 0 ;  synchronized  ( array )   {  for  (  ;  i  <  rate   depth ;  i +  +  )   {  if  ( array[i]  <  0 )  break ;  int f = rate   depth  -  i ;  rate +  = array[i] * f ;  factor +  = f ;   }   }  if  ( i  =  =  0 )  return 0 ;  return rate  /   ( factor * check   period  /  1000 )  ;   }  
@ override public boolean   (  object obj )  {  return  (  ( obj instanceof  summary listener )  &&  (  (  summary listener ) obj )  .    rate . equals (    rate )  )  ;   }  
protected int   (  )  {  for  (  final  file target interval : target   intervals )  io util . assert file is readable ( target interval )  ;  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  if  ( per   target   coverage  !  =  null )  io util . assert file is writable ( per   target   coverage )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;  final  interval list target intervals =  interval list . from files ( target   intervals )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  target intervals . get header (  )  . get sequence dictionary (  )  )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  get probe intervals (  )  . get header (  )  . get sequence dictionary (  )  )  ;   reference sequence file ref = null ;  if  ( reference   sequence  !  =  null )   {  io util . assert file is readable ( reference   sequence )  ;  ref =  reference sequence file factory . get reference sequence file ( reference   sequence )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  ref . get sequence dictionary (  )  input reference   sequence )  ;   }  final collector collector = make collector ( metric   accumulation   level reader . get file header (  )  . get read groups (  )  ref per   target   coverage per   base   coverage target intervals get probe intervals (  )  get probe set name (  )  near   distance )  ;  final  progress logger progress = new  progress logger ( log )  ;  for  (  final sam record record : reader )   {  collector . accept record ( record null )  ;  progress . record ( record )  ;   }  final  metrics file < metric  integer >  metrics = get metrics file (  )  ;  collector . finish (  )  ;  collector . add all levels to file ( metrics )  ;  metrics . write ( output )  ;   closer util . close ( reader )  ;  return 0 ;   }  
public   (  output stream output stream )  {  super ( " shell command  writer" )  ;   output stream writer output stream writer = new  output stream writer ( output stream )  ;  this . buffered writer = new  buffered writer ( output stream writer )  ;   }  
public static  file   ( final  map <  integer  ?  extends  collection <  tile >  >  lane tiles final  file output directory final  string output prefix final  metrics file <  metric base  comparable <  ?  >  >  lane metrics file final  string file extension )  {  lane tiles . entry set (  )  . for each ( entry  -  >   {  final  illumina lane metrics lane metric = new  illumina lane metrics (  )  ;  lane metric . lane = entry . get key (  )  . long value (  )  ;  lane metric . cluster   density = calculate lane density from tiles ( entry . get value (  )  )  ;  lane metrics file . add metric ( lane metric )  ;   }   )  ;  return write metrics ( lane metrics file output directory output prefix  illumina lane metrics . get extension (  )   +  file extension )  ;   }  
public static  header   ( byte[] data )  {  byte[] length array = new byte[2] ;   system . arraycopy ( data 2 length array 0 2 )  ;  int length = unsigned short to int ( length array )  ;  byte[] cutted data ;  int offset = 20 ;  while  ( length  >  0 )   {  cutted data = new byte[length] ;   system . arraycopy ( data offset cutted data 0 length )  ;   header h = parse header ( cutted data )  ;  if  ( h . get type (  )   =  =  mapped   address )   {  return h ;   }  length -  = h . get length (  )  ;  offset +  = h . get length (  )  ;   }  return null ;   }  
public static boolean   (  string type )  {  return type   std   client . equals ( type )  || type   http   client . equals ( type )  || type   socks . equals ( type ) || type   socks   irc . equals ( type ) || type   connect . equals ( type ) || type   streamr   client . equals ( type ) || type   irc   client . equals ( type )  ;   }  
void   (  throwable exc  subscriber <  ?  >  a  simple queue <  ?  >  q )  {   exceptions . throw if fatal ( exc )  ;   exception helper . add throwable ( error exc )  ;  q . clear (  )  ;  cancel all (  )  ;  error all ( a )  ;   }  
public boolean   (  )  {  return senior member ;   }  
public   (  object counter <  string >  o )  {     o = o ;   }  
private static  state   (  session object session object  request wrapper request  state state )  {  if  ( state  =  =   state . auth )   {   string user = request . get parameter ( user )  ;   string pass = request . get parameter ( pass )  ;   string host = request . get parameter ( host )  ;   string pop3 port = request . get parameter ( pop3 )  ;   string smtp port = request . get parameter ( smtp )  ;  boolean fixed ports =  boolean . parse boolean (  config . get property ( config   ports   fixed "true" )  )  ;  if  ( fixed ports )   {  host =  config . get property ( config   host default   host )  ;  pop3 port =  config . get property ( config   ports   pop3 ""  +  default   pop3port )  ;  smtp port =  config . get property ( config   ports   smtp ""  +  default   smtpport )  ;   }  boolean do continue = true ;  boolean offline = button pressed ( request offline )  ;  if  ( button pressed ( request login )  || offline )   {  if  ( user  =  =  null || user . length (  )   =  =  0 )   {  session object . error +  =    t ( " need username for authentication . " )   +  '\n' ;  do continue = false ;   }  if  ( pass  =  =  null || pass . length (  )   =  =  0 )   {  session object . error +  =    t ( " need password for authentication . " )   +  '\n' ;  do continue = false ;   }  if  ( host  =  =  null || host . length (  )   =  =  0 )   {  session object . error +  =    t ( " need hostname for connect . " )   +  '\n' ;  do continue = false ;   }  int pop3 port no = 0 ;  if  ( pop3 port  =  =  null || pop3 port . length (  )   =  =  0 )   {  session object . error +  =    t ( " need port number for pop3 connect . " )   +  '\n' ;  do continue = false ;   }  else  {  try  {  pop3 port no =  integer . parse int ( pop3 port )  ;  if  ( pop3 port no  <  0 || pop3 port no  >  65535 )   {  session object . error +  =    t ( "pop3 port number is not in range 0 .  . 65535 . " )   +  '\n' ;  do continue = false ;   }   }  catch  (   number format exception nfe )   {  session object . error +  =    t ( "pop3 port number is invalid . " )   +  '\n' ;  do continue = false ;   }   }  int smtp port no = 0 ;  if  ( smtp port  =  =  null || smtp port . length (  )   =  =  0 )   {  session object . error +  =    t ( " need port number for smtp connect . " )   +  '\n' ;  do continue = false ;   }  else  {  try  {  smtp port no =  integer . parse int ( smtp port )  ;  if  ( smtp port no  <  0 || smtp port no  >  65535 )   {  session object . error +  =    t ( "smtp port number is not in range 0 .  . 65535 . " )   +  '\n' ;  do continue = false ;   }   }  catch  (   number format exception nfe )   {  session object . error +  =    t ( "smtp port number is invalid . " )   +  '\n' ;  do continue = false ;   }   }  if  ( do continue )   {  session object . smtp port = smtp port no ;  state = threaded startup ( session object offline state host pop3 port no user pass )  ;   }   }   }  return state ;   }  
@ before public void   (  )  {  unit = new  vavr collector factory (  )  ;   }  
@ test public void   (  )  throws  exception  {  try  (  handle h = db rule . open handle (  )  )  {  h . execute ( "insert into something  ( id  name )  values  ( 1  ' keith' ) " )  ;   }   string value = db rule . get jdbi (  )  . with handle ( handle  
@ benchmark public  object   (  blackhole bh )  {  return observable dedicated . subscribe with ( new  perf consumer ( bh )  )  ;   }  
@ override public synchronized void   (  )  {  super . stop running (  )  ;  queue . close (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  message message = new  message (  )  ;  final  list <  packet >  packets = new  array list <  >  (  )  ;  packets . add ( message )  ;  final  http session .  deliverable deliverable = new  http sess
@ override public boolean   (  )  {  return persistent ;   }  
@ override public void   ( long n )  {  requested ( n )  ;   }  
private t   (  )  {  try  {  return type . new instance (  )  ;   }  catch  (   exception e )   {  throw new  illegal argument exception (  string . format ( "a bean  %s  was mapped "  +  "which was not instantiable" type . get name (  )  )  e )  ;   }   }  
public synchronized void   (  )  {     restart pending = true ;  set active ( false )  ;   }  
private static  list <  header >    (  map <  string  string >  header values )  {  final  list <  header >  headers = new  array list <  >  (  )  ;  for  (   string header : header values . key set (  )  )   {   string values = header values . get ( header )  ;  for  (   string value : values . split ( " " )  )   {   header header1 = mock (  header . class )  ;  when ( header1 . get name (  )  )  . then return ( header )  ;  when ( header1 . get value (  )  )  . then return ( value )  ;  headers . add ( header1 )  ;   }   }  return headers ;   }  
public void   ( int[] int data byte[] byte data )  throws  speex exception  {  if  ( speex encoder  =  =  null )   {  speex encoder = new  speex encoder ( my media info . get sample rate (  )  my media info . get channels (  )  )  ;   logger . println ( " call "  +  cp  +  " created  speex encoder" )  ;   }  speex encoder . encode ( int data byte data  rtp packet . header   size )  ;   }  
@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;  handle . execute ( "create table user  ( id integer primary key  name varchar ) " )  ;  handle . execute ( "insert into user values  ( 1  ' alice' ) " )  ;  handle . execute ( "
@ test ( timeout = 5000 )  public void   (  )  {  final  worker w =  schedulers . trampoline (  )  . create worker (  )  ;  try  {  final int[] calls =  { 0 }  ;   thread . current thread (  )  . interrupt (  )  ;  w . schedule ( new  runnable (  )  {  @ 
public static boolean   (  http servlet request request  string name boolean default val )  {   string temp = request . get parameter ( name )  ;  if  ( "true" . equals ( temp )  || "on" . equals ( temp )  )   {  return true ;   }  else if  ( "false" . equals ( temp )  || "off" . equals ( temp )  )   {  return false ;   }  else  {  return default val ;   }   }  
int   (  )  throws io exception  {  return align ( alignment )  ;   }  
public int   (  )  {  if  ( comments  =  =  null )   {  return 0 ;   }  else  {  return comments . size (  )  ;   }   }  
public  map <  string  conversation info >    ( boolean format participants )  {   map <  string  conversation info >  cons = new  hash map <  string  conversation info >  (  )  ;   monitoring plugin plugin =  (  monitoring plugin ) xmpp server . get instance (  )  . get plugin manager (  )  . get plugin (  monitoring constants . name )  ;   conversation manager conversation manager =  (  conversation manager ) plugin . get module (  conversation manager . class )  ;   collection <  conversation >  conversations = conversation manager . get conversations (  )  ;   list <  conversation >  l conversations =  arrays . as list ( conversations . to array ( new  conversation[conversations . size (  ) ] )  )  ;  for  (  iterator <  conversation >  i = l conversations . iterator (  )  ;  i . has next (  )  ;   )   {   conversation con = i . next (  )  ;   conversation info info = to conversation info ( con format participants )  ;  cons . put (  long . to string ( con . get conversationid (  )  )  info )  ;   }  return cons ;   }  
public boolean   (  )  {  return  !    context . get boolean property ( prop   xframe )  ;   }  
public synchronized short   (  )  {  verify not released (  )  ;  return    priority ;   }  
public void   (  data output out byte[] value )  throws io exception  {  strategy . write byte array ( out value )  ;   }  
public  array list <  session entry >    (  string order attr  string order )  {  return db . get all session entries ( order attr order )  ;   }  
public static  string   (  string string  string regex  string replacement )  {  return string . replace all ( regex replacement )  ;   }  
public void   (  object data )  {  user data = data ;   }  
@ override public void   (  garlic config config )  {  throw new  unsupported operation exception (  )  ;   }  
boolean   ( final  simple queue < t >  q  observer <  ?  super t >  a )  {   throwable ex = error ;  if  ( ex  !  =  null )   {  actual . lazy set ( null )  ;  q . clear (  )  ;  a . on error ( ex )  ;  return true ;   }  else  {  return false ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  subject <  integer >  s =  publish subject .  <  integer > create (  )  . to serialized (  )  ;   test observer <  integer >  to = s . t
@ before public void   (  )  {  cache = new  cache ( uuid . randomuuid (  )  . to string (  )  20000 false false 5 2 )  ;  cache manager . add cache ( cache )  ;  datastore = new eh cache datastore ( cache )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer ( 5 )  ;   completable c =  completable . from action ( new  action (  )  {  @ override public void run (  )  {  if  ( calls . decrement and get (  )   !  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  setup open folder ( mock )  ;  mock . expect ( get next tag ( false )   +  " status \""  +  folder   encoded +  "\" \\ ( unseen\\ ) " new  string[] { "* status  { 5 } " folder   encoded  +  "  ( unseen 10 ) " get next tag ( true )   +  " ok status completed" }  )  ;  m folder . open (  open mode . read   write )  ;  int unread count = m folder . get unread message count (  )  ;  assert equals ( "get unread message count with literal string" 10 unread count )  ;   }  
@ override public  executor service   (  )  {  return  executors . new cached thread pool (  )  ;   }  
public void   ( long now )  {     enqueue time = now ;   }  
public   (  router context context  tunnel creator config config )  {  super ( context null null null )  ;     config = config ;  if  ( config . is inbound (  )  )     in distributor = new  inbound message distributor ( context config . get destination (  )  )  ;  else    out distributor = new  outbound message distributor ( context  out net message . priority   my   data )  ;   }  
@ override public  integer   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
private void   (  )  {     file lock . write lock (  )  . unlock (  )  ;   }  
@ override public void   (  cache cache )  {  if  ( cache instanceof  cache wrapper )   {  cache =  (  (  cache wrapper ) cache )  . get wrapped cache (  )  ;   }   clustered cache clustered =  (  clustered cache ) cache ;  clustered . destroy (  )  ;   }
@ override public  object   (  cluster task <  ?  >  task byte[] nodeid )  {  if  ( cluster  =  =  null )   {  return null ;   }   member member = get member ( nodeid )  ;   object result = null ;  if  ( member  !  =  null )   {  logger . debug ( " execut
public synchronized double   (  )  {  if  (  (    last event count  >  0 )  &&  (    lifetime total event time  >  0 )  )   {  double event time =  ( double )    lifetime total event time  /   ( double )    lifetime event count ;  double max events =    period  /  event time ;  double num periods = get lifetime periods (  )  ;  double avg events per period =    lifetime event count  /  num periods ;  return avg events per period  /  max events ;   }  return 0 . 0d ;   }  
private void   (  )  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   queues )  ;  pstmt . set long ( 1 id )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  load request queue ( rs . get long ( 1 )  )  ;   }   }  catch  (  sql exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
public void   (  packet packet )  {  if  ( packet instanceof  presence )   {   presence presence =  (  presence ) packet ;  if  ( presence . is available (  )  || presence . get type (  )   =  =   presence .  type . unavailable || presence . get type (  )   =  =   presence .  type . error )   {  probed presence . put ( presence . get from (  )  . to string (  )  presence )  ;   }   }   }  
public  linked queue node < e >    (  )  {  return get (  )  ;   }  
public  flowable < t >    (  )  {  return new  burst < t >  ( error items )  ;   }  
boolean   ( boolean d boolean empty  observer <  ?  super r >  a boolean delay error  zip observer <  ?   ?  >  source )  {  if  ( cancelled )   {  cancel (  )  ;  return true ;   }  if  ( d )   {  if  ( delay error )   {  if  ( empty )   {   throwable e = source . error ;  cancel (  )  ;  if  ( e  !  =  null )   {  a . on error ( e )  ;   }  else  {  a . on complete (  )  ;   }  return true ;   }   }  else  {   throwable e = source . error ;  if  ( e  !  =  null )   {  cancel (  )  ;  a . on error ( e )  ;  return true ;   }  else if  ( empty )   {  cancel (  )  ;  a . on complete (  )  ;  return true ;   }   }   }  return false ;   }  
@ override public void   (  )  {  pp1 . on error ( ex )  ;   }  
protected static boolean   ( final  list <  allele >  alleles final  reference sequence reference sequence final int start final int end )  {  final  string ref string =  string util . bytes to string ( reference sequence . get bases (  )  start  -  1 end  -  start  +  1 )  ;  final  allele ref allele = alleles . stream (  )  . filter (  allele::is reference )  . find any (  )  . or else throw (  (  )   -  >  new  illegal state exception ( " error: no reference allele was present" )  )  ;  return  ( ref string . equals ignore case ( ref allele . get base string (  )  )  )  ;   }  
@ suppress warnings (  { "rawtypes" "unchecked" }  )  @ override public  publisher <  list <  long >  >    ( long elements )  {  return  flowable . from iterable ( iterate ( elements )  )  . window (  flowable . just ( 1 )  . concat with (  flowable .  < 
public final static int   ( byte lhs[] byte rhs[] )  {  if  (  ( rhs  =  =  null )  &&  ( lhs  =  =  null )  )  return 0 ;  if  ( lhs  =  =  null )  return  - 1 ;  if  ( rhs  =  =  null )  return 1 ;  if  ( rhs . length  <  lhs . length )  return 1 ;  if  ( rhs . length  >  lhs . length )  return  - 1 ;  for  ( int i = 0 ;  i  <  rhs . length ;  i +  +  )   {  if  (  ( rhs[i] & 0xff )   >   ( lhs[i] & 0xff )  )  return  - 1 ;  else if  (  ( rhs[i] & 0xff )   <   ( lhs[i] & 0xff )  )  return 1 ;   }  return 0 ;   }  
@ override public float   (  string column label )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  string t )  {   system . out . println ( "t: "  +  t )  ;   }  
@ test public void   (  )  {   flowable .  <  integer > empty (  )  . publish (  functions .  <  flowable <  integer >  > identity (  )  )  . test ( 0l )  . assert result (  )  ;   }  
@ override void   (  )  {  on error ( new  missing backpressure exception ( "create: could not emit value due to lack of requests" )  )  ;   }  
@ override public  string   (  )  {  return  help constants . doc   cat   variant   evaluation   summary ;   }  
public   (  router context ctx  flood search job job )  {  super ( ctx )  ;     search = job ;   }  
@ test public void   (  )  {  final  atomic integer subscribe count = new  atomic integer (  )  ;  final  atomic integer next count = new  atomic integer (  )  ;   flowable <  integer >  r =  flowable . just ( 1 2 3 4 5 6 7 8 9 )  . do on subscribe ( new 
public  node   (  string name )  {  if  ( name  =  =  null )  return null ;  int n lists = size (  )  ;  for  ( int n = 0 ;  n  <  n lists ;  n +  +  )   {   node node = get node ( n )  ;   string node name = node . get name (  )  ;  if  ( name . compare to ( node name )   =  =  0 )  return node ;   }  return null ;   }  
@ override public void   (  )  {  super . cancel (  )  ;  d . dispose (  )  ;   }  
public boolean   (  )  {  return pattern . matcher ( root . to string (  )  )  . find (  )  ;   }  
@ test public void   (  )  {   my dao my dao = db . on demand (  my dao . class )  ;   out parameters out parameters = my dao . call multiple out parameters ( 1 9 )  ;  assert that ( out parameters . get int ( "c" )  )  . is equal to ( 9 )  ;  assert that
@ override public void   (  )  {  if  ( connection  !  =  null )   {  connection = null ;   }  if  ( listener  !  =  null )   {  listener = null ;   }   }  
  ( final  output mapping output mapping final  map <  illumina parser  set <  illumina data type >  >  parsers to data types final  file basecall directory final int lane )  {  super ( lane output mapping )  ;  this . basecall directory = basecall directory ;  final int num parsers = parsers to data types . size (  )  ;  if  ( num parsers  =  =  0 )   {  throw new  picard exception ( " there were 0 parsers passed to  illumina data provider ! " )  ;   }  int i = 0 ;  parsers = new  illumina parser[num parsers] ;  data types = new  illumina data type[num parsers][] ;  for  (  final  map .  entry <  illumina parser  set <  illumina data type >  >  p tod : parsers to data types . entry set (  )  )   {  parsers[i] = p tod . get key (  )  ;  final  set <  illumina data type >  dts = p tod . get value (  )  ;  data types[i] = new  illumina data type[dts . size (  ) ] ;  dts . to array ( data types[i +  + ] )  ;   }   }  
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . take until (  functions . always false (  )  )  )  ;   }  
protected static  node   (  node parent node  string child name )  throws  rrd exception  {  return  util .  xml . get first child node ( parent node child name )  ;   }  
@ override protected void   (  http servlet request request  http servlet response response )  throws  servlet exception  io exception  {   string statistic key = request . get parameter ( "stat" )  ;   string time period = request . get parameter ( "time
@ override public boolean   (  )  {  return false ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map iterable ( new  function <  integer  iterable <  object >  >  (  )  {  @ override public  iterable <  object >  apply (   integer v )  {  return null ;   }   } 
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . buffer ( 1 1  (  callable <  list <  integer >  >  ) null )  ;   }  
private   (  string name )  {  m name = name ;  m start = get current time (  )  ;  m last split = m start ;   log utils . w (  logging . log   tag " stop watch ( "  +  m name  +  " )  start" )  ;   }  
@ test ( timeout = 2000 )  public void   (  )  {   observable <  long >  source =  observable . interval ( 40 40  time unit . milliseconds scheduler )  ;   observable <  list <  long >  >  result = source . buffer ( 100 60  time unit . milliseconds schedu
@ override public int   ( int mode )  {   queue subscription < t >  fs = qs ;  if  ( fs  !  =  null )   {  int m = fs . request fusion ( mode & ~ queue fuseable . boundary )  ;  this . source mode = m ;  return m ;   }  return  queue fuseable . none ;   }
@ override public  string   (  )  {   object o = value ;  if  ( o  =  =  null )   {  return " on complete notification" ;   }  if  (  notification lite . is error ( o )  )   {  return " on error notification["  +   notification lite . get error ( o )   + 
@ data provider ( name = " " )  public  object[][] get singleton sample data (  )  {  final  list <  object[] >  retval = new  array list <  >  ( 10 )  ;  final  allele a ref =  allele . create ( "a" true )  ;  final  allele g =  allele . create ( "g" fal
private  optional <  extension factory >    (  class <  ?  >  extension type )  {  return factories . stream (  )  . filter ( factory  -  >  factory . accepts ( extension type )  )  . find first (  )  ;   }  
private static  tunnel build message   (  router context ctx  tunnel pool pool  pooled tunnel creator config cfg  tunnel info paired tunnel  build executor exec )  {   log log = ctx . log manager (  )  . get log (  build requestor . class )  ;  long reply tunnel = 0 ;   hash reply router ;  boolean use variable = send   variable && cfg . get length (  )   <  =  medium   records ;  if  ( cfg . is inbound (  )  )   {  reply router = ctx . router hash (  )  ;   }  else  {  reply tunnel = paired tunnel . get receive tunnel id ( 0 )  . get tunnel id (  )  ;  reply router = paired tunnel . get peer ( 0 )  ;   }   tunnel build message msg ;   list <  integer >  order ;  if  ( use variable )   {  if  ( cfg . get length (  )   <  =  short   records )   {  msg = new  variable tunnel build message ( ctx short   records )  ;  order = new  array list <  integer >  ( short   order )  ;   }  else  {  msg = new  variable tunnel build message ( ctx medium   records )  ;  order = new  array list <  integer >  ( medium   order )  ;   }   }  else  {  msg = new  tunnel build message ( ctx )  ;  order = new  array list <  integer >  ( order )  ;   }   collections . shuffle ( order ctx . random (  )  )  ;  cfg . set reply order ( order )  ;  if  ( log . should log (  log . debug )  )  log . debug ( " build order: "  +  order  +  " for " +  cfg )  ;  for  ( int i = 0 ;  i  <  msg . get record count (  )  ;  i +  +  )   {  int hop = order . get ( i )  . int value (  )  ;   public key key = null ;  if  (  build message generator . is blank ( cfg hop )  )   {   }  else  {   hash peer = cfg . get peer ( hop )  ;   router info peer info = ctx . net db (  )  . lookup router info locally ( peer )  ;  if  ( peer info  =  =  null )   {  if  ( log . should log (  log . warn )  )  log . warn ( " peer selected for hop "  +  i  +  " / " +  hop +  " was not found locally: " +  peer +  " for " +  cfg )  ;  return null ;   }  else  {  key = peer info . get identity (  )  . get public key (  )  ;   }   }  if  ( log . should log (  log . debug )  )  log . debug ( cfg . get reply message id (  )   +  ": record "  +  i +  " / " +  hop +  " has key " +  key )  ;   build message generator . create record ( i hop msg cfg reply router reply tunnel ctx key )  ;   }   build message generator . layered encrypt ( ctx msg cfg order )  ;  return msg ;   }  
public  string   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  if  ( tun  !  =  null )   {  if  ( "streamrclient" . equals ( tun . get type (  )  )  )  return tun . get target host (  )  ;  else return tun . get listen on interface (  )  ;   }  else return "127 . 0 . 0 . 1" ;   }  
private void   ( http request soap req )  {   string uri = soap req . geturi (  )  ;   service ctl service = get service by controlurl ( uri )  ;  if  ( ctl service  !  =  null )   {   action request crl req = new  action request ( soap req )  ;  device control request recieved ( crl req ctl service )  ;  return ;   }  soap bad action recieved ( soap req )  ;   }  
@ override public void   (  throwable t )  {  if  ( error  =  =  null )   {  error = t ;  for  (  ;   ;   )   {   disposable a = s . get (  )  ;  if  ( a  =  =  this || a  =  =   disposable helper . disposed )   {   rx java plugins . on error ( t )  ;  re
@ override public boolean   (  string hostname  destination d  properties options )  {  return super . put ( hostname . to lower case (  locale . us )  d options )  ;   }  
@ override public  boolean   (  )  {  return true ;   }  
public final boolean   ( byte buf[] )  {  boolean ok = false ;  final byte[] tbuf = new byte[buf . length] ;   thread t = new i2p thread ( new  secure random init ( tbuf )  " secure random init" true )  ;  t . start (  )  ;  try  {  t . join ( 10 * 1000 )  ;  synchronized  ( tbuf )   {  for  ( int i = 0 ;  i  <  tbuf . length ;  i +  +  )   {  if  ( tbuf[i]  !  =  0 )   {  ok = true ;  break ;   }   }  if  ( ok )   system . arraycopy ( tbuf 0 buf 0 buf . length )  ;   }   }  catch  (   interrupted exception ie )   {   }  if  (  !  system version . is windows (  )  )  ok = seed from file ( new  file ( " / dev / urandom" )  buf )  || ok ;   file local file = new  file (    context . get config dir (  )  seedfile )  ;  ok = seed from file ( local file buf )  || ok ;  return ok ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  try  {  on error . accept ( t )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plug
public static  string   (  )  {   console update manager mgr =  console update manager . get instance (  )  ;  if  ( mgr  =  =  null )  return "" ;  return mgr . get status (  )  ;   }  
public  security audit logs   (  string username int offset int limit long start time time stamp long end time time stamp )  throws  service exception  {   date start time = null ;   date end time = null ;  if  ( start time time stamp  !  =  0 )   {  start time = new  date ( start time time stamp * 1000 )  ;   }  if  ( end time time stamp  !  =  0 )   {  end time = new  date ( end time time stamp * 1000 )  ;   }   list <  security audit event >  events = new  array list <  security audit event >  (  )  ;  try  {  events =  security audit manager . get instance (  )  . get events ( username offset limit start time end time )  ;   }  catch  (   audit write only exception e )   {  throw new  service exception ( " could not get security audit logs  because the permission is set to write only" " security logs" " audit write only exception"  response .  status . forbidden )  ;   }   list <  security audit log >  security audit logs = new  array list <  security audit log >  (  )  ;  for  (   security audit event event : events )   {   security audit log log = new  security audit log ( event . get msgid (  )  event . get username (  )  event . get event stamp (  )  . get time (  )   /  1000 event . get summary (  )  event . get node (  )  event . get details (  )  )  ;  security audit logs . add ( log )  ;   }  return new  security audit logs ( security audit logs )  ;   }  
@ override public void   (  )  {  int idle time =  session manager . get instance (  )  . get server session idle time (  )  ;  if  ( idle time  =  =   - 1 )   {  return ;   }  final long deadline =  system . current time millis (  )   -  idle time ;  for
@get @ produces (  {  media type . application   xml  media type . application   json }  )  public  msg archive entity   ( @ path param ( "jid" )   string jid str )  throws  service exception  {  jid jid = new jid ( jid str )  ;  int msg count = archive .
@ override public synchronized void   ( int readlimit )  {  original stream . mark ( readlimit )  ;   }  
public static boolean   (  atomic reference <  disposable >  field  disposable d )  {  for  (  ;   ;   )   {   disposable current = field . get (  )  ;  if  ( current  =  =  disposed )   {  if  ( d  !  =  null )   {  d . dispose (  )  ;   }  return false ;   }  if  ( field . compare and set ( current d )  )   {  if  ( current  !  =  null )   {  current . dispose (  )  ;   }  return true ;   }   }   }  
private static void   ( final  context context  store remote store  mailbox mailbox boolean change read boolean change flagged boolean change mailbox boolean change answered  email content .  message old message final  email content .  message new message )  throws  messaging exception  {   mailbox new mailbox = mailbox ;  mailbox = get remote mailbox for message ( context old message )  ;  if  ( new message . m server id  =  =  null || new message . m server id . equals ( "" )  || new message . m server id . starts with ( local   serverid   prefix )  ||  ( mailbox  =  =  null )  )   {  return ;   }  if  ( mailbox . m type  =  =   mailbox . type   drafts || mailbox . m type  =  =   mailbox . type   outbox )   {  return ;   }   folder remote folder = remote store . get folder ( mailbox . m server id )  ;  if  (  ! remote folder . exists (  )  )   {  return ;   }  remote folder . open (  open mode . read   write )  ;  if  ( remote folder . get mode (  )   !  =   open mode . read   write )   {  return ;   }   message remote message = remote folder . get message ( new message . m server id )  ;  if  ( remote message  =  =  null )   {  return ;   }  if  (  debug utils . debug )   {   log utils . d (  logging . log   tag " update for msg id = "  +  new message . m id  +  " read = " +  new message . m flag read +  " flagged = " +  new message . m flag favorite +  " answered = " +   (  ( new message . m flags &  email content .  message . flag   replied   to )   !  =  0 )  +  " new mailbox = " +  new message . m mailbox key )  ;   }   message[] messages = new  message[] { remote message }  ;  if  ( change read )   {  remote folder . set flags ( messages flag   list   seen new message . m flag read )  ;   }  if  ( change flagged )   {  remote folder . set flags ( messages flag   list   flagged new message . m flag favorite )  ;   }  if  ( change answered )   {  remote folder . set flags ( messages flag   list   answered  ( new message . m flags &  email content .  message . flag   replied   to )   !  =  0 )  ;   }  if  ( change mailbox )   {   folder to folder = remote store . get folder ( new mailbox . m server id )  ;  if  (  ! remote folder . exists (  )  )   {  return ;   }  remote message . set message id ( new message . m message id )  ;  remote folder . copy messages ( messages to folder new  message update callbacks (  )  {  @ override public void on message uid change (   message message   string new uid )  {   content values cv = new  content values (  )  ;  cv . put (  message columns . server   id new uid )  ;  context . get content resolver (  )  . update (  content uris . with appended id (  email content .  message . content   uri new message . m id )  cv null null )  ;   }  @ override public void on message not found (   message message )  {   }   }   )  ;  remote message . set flag (  flag . deleted true )  ;  remote folder . expunge (  )  ;   }  remote folder . close ( false )  ;   }  
public void   (  service service )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( "delete from of external services where serviceid =  ? " )  ;  pstmt . set long ( 1 service . get database id (  )  )  ;  if  ( pstmt . execute update (  )   =  =  0 )   {   log . warn ( " the query to remove  {  }  service at  {  }  from the database did not remove anything . " service . get type (  )  service . get host (  )  )  ;   }  else  {  services . remove ( service )  ;   log . info ( " removed  {  }  service at  {  }  . " service . get type (  )  service . get host (  )  )  ;   }   }  catch  (   exception e )   {   log . error ( " unable to remove service  (  {  }  at  {  }  )  from database ! " service . get type (  )  service . get host (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
private   (  context context )  {  m context = context . get application context (  )  ;  m resources = m context . get resources (  )  ;  m account color array = m resources . obtain typed array ( r . array . combined   view   account   colors )  ;  m account colors = m resources . get int array ( r . array . combined   view   account   colors )  ;  m account color paints = new  paint[m account colors . length] ;  for  ( int i = 0 ;  i  <  m account colors . length ;  i +  +  )   {   paint p = new  paint (  )  ;  p . set color ( m account colors[i] )  ;  m account color paints[i] = p ;   }   }  
public void   (  long value )  {     synchronization source = value ;   }  
public int   ( int tunnel )  {  return get property ( tunnel  tunnel controller . prop   max   total   conns   hour 0 )  ;   }  
@ test ( expected =  runtime exception . class )  @ ignore ( " subscribers can't throw" )  public void   (  )  {   rx java plugins . set error handler ( new  consumer <  throwable >  (  )  {  @ override public void accept (   throwable e )  {  throw new  
public static  ticker factory   (  )  {  if  ( ticker factory  !  =  null )   {  return ticker factory ;   }  ticker factory = new  ticker factory (  )  ;  return ticker factory ;   }  
public boolean   (  )  {  return nr of errors  =  =  0 ;   }  
@ before public void   (  )  {  final  parameter filter factory parameter filter factory = new  array white list parameter filter factory ( new  string[] { "a" "b" "c" "d" }  )  ;  query string normalizer = new  query string normalizer ( parameter filter 
@ override public void   (  string property  map params )  {  if  ( "provider . user . class name" . equals ( property )  )   {  init provider (  )  ;   }  if  ( "provider . userproperty . class name" . equals ( property )  )   {  init property provider (
@ override public final void   (  )  {  lazy set ( fused   consumed )  ;  value = null ;   }  
@ before public void   (  )  throws  exception  {  h = db rule . get jdbi (  )  . open (  )  ;  h . execute ( "create alias to   degrees for \"java . lang .  math . to degrees\"" )  ;  h . execute ( "create alias test   procedure for \"org . jdbi . v3 . c
public  string   (  )  {  return  collect rna seq metrics . class . get simple name (  )  ;   }  
static void   ( final  context context final  account account  pop3 folder remote folder  array list <  pop3 message >  unsynced messages final  mailbox to mailbox )  throws  messaging exception  {  if  (  debug utils . debug )   {   log utils . d ( tag " loading "  +  unsynced messages . size (  )   +  " unsynced messages" )  ;   }  try  {  int cnt = unsynced messages . size (  )  ;  for  ( int i = 0 ;  i  <  cnt ;  i +  +  )   {  final  pop3 message message = unsynced messages . get ( i )  ;  remote folder . fetch body ( message  pop3 store . fetch   body   sane   suggested   size  /  76 null )  ;  int flag =  email content .  message . flag   loaded   complete ;  if  (  ! message . is complete (  )  )   {  flag =  email content .  message . flag   loaded   partial ;   }  if  (  debug utils . debug )   {   log utils . d ( tag " message is "  +   ( message . is complete (  )   ?  "" : "not " )   +  "complete" )  ;   }   utilities . copy one message to provider ( context message account to mailbox flag )  ;   }   }  catch  (  io exception e )   {  throw new  messaging exception (  messaging exception . ioerror )  ;   }   }  
@ override public void   (  )  {  request ( 10 )  ;   }  
@ test public void   (  )  {   handle handle = db rule . get shared handle (  )  ;  handle . register row mapper (  bean mapper . factory (  nested prefix bean . class )  )  ;  handle . execute ( "insert into something  ( id  name )  values  ( 1  'foo' ) 
public  listener list   (  )  {  return control action listener list ;   }  
@ override public int   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public void   (  string column label  reader reader )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
public static boolean   (  string dest )  {  byte[] b =  base64 . decode ( dest )  ;  if  ( b  =  =  null || b . length  <  663 )  return false ;   byte array input stream dest key stream = new  byte array input stream ( b )  ;  try  {   destination d =  destination . create ( dest key stream )  ;  new  private key (  )  . read bytes ( dest key stream )  ;   signing private key spk = new  signing private key ( d . get signing public key (  )  . get type (  )  )  ;  spk . read bytes ( dest key stream )  ;   }  catch  (   data format exception e )   {  return false ;   }  catch  (  io exception e )   {  return false ;   }  return dest key stream . available (  )   =  =  0 ;   }  
public   ( long delay  time unit unit  scheduler scheduler )  {  this . delay = delay ;  this . unit = unit ;  this . scheduler = scheduler ;   }  
public   (  set <  session tag >  tags  session key key long date int id )  {  if  ( key  =  =  null )  throw new  illegal argument exception ( " missing key" )  ;  if  ( tags  =  =  null )  throw new  illegal argument exception ( " missing tags" )  ;     session tags = tags ;     key = key ;     date = date ;     id = id ;     orig size = tags . size (  )  ;   }  
@ test public void   (  )  throws  exception  {   connection c = mock (  connection . class )  ;  db rule . get jdbi (  )  . install plugin ( new  jdbi plugin (  )  {  @ override public  connection customize connection (   connection conn )  {  return c ;
private static void   (  string host int port  string con options )  {     log . info ( "\n\n testing a dest generate  ( should come back with 'dest reply pub = val priv = val' ) \n\n\n" )  ;  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;     log . debug ( "line read for valid version: "  +  line )  ;   string req = "session create style = stream destination = test naming "  +  con options  +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . debug ( " response to creating the session with destination test naming: "  +  line )  ;     log . debug ( " the above should contain session status result = ok\n\n\n" )  ;   string lookup = "dest generate\n" ;  out . write (  data helper . getascii ( lookup )  )  ;  line = reader . read line (  )  ;     log . info ( " response from the dest generate: "  +  line )  ;     log . debug ( " the abouve should be a dest reply" )  ;  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  s . close (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
@ deprecated public  string   (  )  {   string builder opts = new  string builder ( 64 )  ;  for  (   map .  entry <  object  object >  e :    config . entry set (  )  )   {   string key =  (  string ) e . get key (  )  ;  if  ( key . starts with ( pfx   
@ test public void   (  )  throws  exception  {  exception . expect (  illegal argument exception . class )  ;  find sql on classpath ( "this - does - not - exist" )  ;   }  
public void   ( boolean is seed )  {  this . is seed = is seed ;   }  
@ test public void   (  )  {   assert . assert false (  localmuc room . is privileged to change affiliation and role ( muc role .  affiliation . member muc role .  role . moderator muc role .  affiliation . owner muc role .  role . moderator muc role .  a
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
@ test public void   (  )  {  check scheduler support (  single . class )  ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  f 
public void   (  )  {  while  (    is running )   {   async buffer a buff = null ;  try  {  a buff =    empty buffers . take (  )  ;   }  catch  (   interrupted exception ie )   {  continue ;   }  long before =  system . current time millis (  )  ;  do fill ( a buff . buffer )  ;  long after =  system . current time millis (  )  ;  boolean should wait =    full buffers . size (  )   >  1 ;     full buffers . offer ( a buff )  ;     context . stat manager (  )  . add rate data ( "prng . buffer fill time" after  -  before 0 )  ;  if  ( should wait )   {   thread . yield (  )  ;  long wait time =  ( after  -  before )  * 5 ;  if  ( wait time  <  =  0 )  wait time = 50 ;  else if  ( wait time  >  5000 )  wait time = 5000 ;  try  {   thread . sleep ( wait time )  ;   }  catch  (   interrupted exception ie )   {   }   }   }   }  
@ test public void   (  )  {  try  {  filter . set patterns ( "$*[" )  ;  fail ( "expected  pattern syntax exception" )  ;   }  catch  (   pattern syntax exception e )   {   }   }  
@ override public synchronized void   (  inet socket address address  string reason )  {  for  (   cluster member member : cluster members )   {  if  ( member . get member address (  )  . equals ( address )  )   {  log . warn ( " cluster member \""  +  me
public   (  list <  long >  conversationi ds )  {  this . conversationi ds = conversationi ds ;   }  
@ test public void   (  )  {   test helper . check double on subscribe observable ( new  function <  observable <  object >   observable source <  object >  >  (  )  {  @ override public  observable source <  object >  apply (   observable <  object >  o 
public   (  local client session session )  {  presence = session . get presence (  )  ;  default list = session . get default list (  )   !  =  null  ?  session . get default list (  )  . get name (  )  : null ;  active list = session . get active list (  )   !  =  null  ?  session . get active list (  )  . get name (  )  : null ;  offline flood stopped = session . is offline flood stopped (  )  ;   }  
public void   (  )  {  get context (  )  . net db (  )  . startup (  )  ;   }  
@ override public  list <  integer >    (  )  throws  exception  {  return new  array list <  integer >  (  )  ;   }  
public   ( java . io .  input stream in int options )  {  super ( in )  ;  this . break lines =  ( options & dont   break   lines )   !  =  dont   break   lines ;  this . encode =  ( options & encode )   =  =  encode ;  this . buffer length = encode  ?  4 : 3 ;  this . buffer = new byte[buffer length] ;  this . position =  - 1 ;  this . line length = 0 ;  this . options = options ;  this . alphabet = get alphabet ( options )  ;  this . decodabet = get decodabet ( options )  ;   }  
static  context handler   (  string app name )  {   context handler collection server = get console server (  )  ;  if  ( server  =  =  null )  return null ;   handler handlers[] = server . get handlers (  )  ;  if  ( handlers  =  =  null )  return null ;   string path = ' / '  +  app name ;  for  ( int i = 0 ;  i  <  handlers . length ;  i +  +  )   {  if  (  !  ( handlers[i] instanceof  context handler )  )  continue ;   context handler ch =  (  context handler ) handlers[i] ;  if  ( path . equals ( ch . get context path (  )  )  )  return ch ;   }  return null ;   }  
@ override public  destination   (  string hostname  properties lookup options  properties stored options )  {   destination rv = lookup2 ( hostname lookup options stored options )  ;  if  ( rv  =  =  null )   {  hostname = hostname . to lower case (  loc
@ test public void   (  )  {  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  s )  {   disposable bs1 =  disposables . empty (  )  ;  s . on subscribe ( bs1 )  ;   disposable bs2 =  di
@ override public void   (  )  {  m connectivity manager = new  email connectivity manager ( this log   tag )  ;  m account manager stub = new  account manager stub ( this )  ;  final int mask =  attachment . flag   download   forward |  attachment . flag
@ test public void   (  )  {   type optional string = new  generic type <  optional <  string >  >  (  )  {   }   . get type (  )  ;  assert that ( factory . accepts ( optional string )  )  . is true (  )  ;  assert that ( factory . accepts (  optional . 
  (  type return type )  {  element type =  generic types . find generic parameter ( return type  stream . class )  . or else throw (  (  )   -  >  new  illegal state exception ( " cannot reflect  stream < t >  element type t in method return type "  +  return type )  )  ;   }  
public boolean   ( final  string column label )  {  return column label indices . contains key ( column label )  ;   }  
@ override public void   ( xmpp server server )  {  super . initialize ( server )  ;  xmpp server = server ;  deliverer = server . get packet deliverer (  )  ;  transport handler = server . get transport handler (  )  ;   }  
@ test public void   (  )  throws sql exception  {  test projection mapper ( new  generic type <  tuple4 <  ?   ?   ?   ?  >  >  (  )  {   }    tuple . of ( 1 2 3 4 )  )  ;   }  
public static x509 certificate   (  file ks  string kspw  string alias  string keypw int valid days )  throws  general security exception  io exception  {   input stream fis = null ;   output stream fos = null ;  try  {   key store key store =  key store . get instance (  key store . get default type (  )  )  ;  fis = new  file input stream ( ks )  ;  char[] pwchars = kspw  !  =  null  ?  kspw . to char array (  )  : null ;  key store . load ( fis pwchars )  ;  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }  fis = null ;  char[] keypwchars = keypw . to char array (  )  ;  if  ( alias  =  =  null )   {  for  (  enumeration <  string >  e = key store . aliases (  )  ;  e . has more elements (  )  ;   )   {  alias = e . next element (  )  ;  break ;   }  if  ( alias  =  =  null )  throw new  general security exception ( "no private keys found" )  ;   }   private key pk =  (  private key ) key store . get key ( alias keypwchars )  ;  if  ( pk  =  =  null )  throw new  general security exception ( "private key not found: "  +  alias )  ;   certificate[] certs = key store . get certificate chain ( alias )  ;  if  ( certs . length  !  =  1 )  throw new  general security exception ( " bad cert chain length" )  ;  x509 certificate cert =  ( x509 certificate ) certs[0] ;   object[] rv =  self signed generator . renew ( cert pk valid days )  ;  cert =  ( x509 certificate ) rv[2] ;  certs[0] = cert ;  key store . set key entry ( alias pk keypwchars certs )  ;  fos = new  secure file output stream ( ks )  ;  key store . store ( fos pwchars )  ;  return cert ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }  if  ( fos  !  =  null )  try  {  fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
  (  merge with subscriber <  ?  >  parent )  {  this . parent = parent ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   new  function <  object  publisher <  integer >  >  (  )  { 
@ override public void   (  subscription s )  {   subscription helper . set once ( this s  long . max   value )  ;   }  
@ override public void   (  group group  map params )  {  if  ( "property deleted" . equals ( params . get ( "type" )  )  )   {  return ;   }   string key changed =  (  string ) params . get ( "property key" )  ;   string original value =  (  string ) par
@ override protected void   (  single observer <  ?  super r >  observer )  {  source . subscribe ( new  reduce seed observer < t r >  ( observer reducer seed )  )  ;   }  
public  router throttle   (  )  {  return    throttle ;   }  
boolean   (  hash h )  {  int num tunnels = this . context . tunnel manager (  )  . get participating count (  )  ;  int limit =  math . max ( min   limit  math . min ( max   limit num tunnels * percent   limit  /  100 )  )  ;  return this . counter . increment ( h )   >  limit ;   }  
@ override public  input source   (  string public id  string system id )  throws sax exception  io exception  {  throw new io exception ( " external entity denied: "  +  public id  +  "  /  /  " +  system id )  ;   }  
public  string   (  )  {   string buffer buffer = new  string buffer ( "" )  ;  for  ( int row = 0 ;  row  <  get row count (  )  ;  row +  +  )   {  buffer . append ( timestamps[row] )  ;  buffer . append ( ": " )  ;  for  ( int ds index = 0 ;  ds index  <  get column count (  )  ;  ds index +  +  )   {  buffer . append (  util . format double ( values[ds index][row] true )  )  ;  buffer . append ( " " )  ;   }  buffer . append ( "\n" )  ;   }  return buffer . to string (  )  ;   }  
public void   ( boolean is configuaration loaded )  {  this . is configuaration loaded = is configuaration loaded ;   }  
public void   (  string subdomain )  {  transport sessions . put ( subdomain new  concurrent hash map <  string  long >  ( 64 0 . 75f 1 )  )  ;   log . debug ( " added key to transport session map: "  +  subdomain )  ;   }  
@ test public void   (  )  {  buffer . allocate (  )  ;  assert equals ( " should have default buffer size" default   size buffer . remaining (  )  )  ;   }  
public void   (  collection <  string >  groups )  {  this . groups = groups ;  save to db (  )  ;  insert bookmark permissions (  )  ;   }  
  (  string sip req type )  {  this . sip req type = sip req type ;   }  
private static void   (  http servlet response resp )  {  resp . set character encoding ( "utf - 8" )  ;  resp . set content type ( "text / html ;  charset = utf - 8" )  ;  resp . set header ( " cache -  control" "max - age = 86400  no - cache  must - revalidate" )  ;  resp . set header ( " content -  security -  policy" "default - src 'self' ;  style - src 'self' 'unsafe - inline' ;  script - src 'self' 'unsafe - inline'" )  ;  resp . set date header ( " expires" 86400 )  ;  resp . set header ( " pragma" "no - cache" )  ;  resp . set header ( "x -  frame -  options" "sameorigin" )  ;  resp . set header ( "x - xss -  protection" "1 ;  mode = block" )  ;  resp . set header ( "x -  content -  type -  options" "nosniff" )  ;  resp . set header ( " referrer -  policy" "no - referrer" )  ;  resp . set header ( " accept -  ranges" "none" )  ;   }  
public  string[]   (  )  {  return sources . key set (  )  . to array ( new  string[0] )  ;   }  
  (  subscriber <  ?  super r >  actual  function <  ?  super t  ?  extends r >  mapper  bi function <  ?  super  long  ?  super  throwable  parallel failure handling >  error handler )  {  this . actual = actual ;  this . mapper = mapper ;  this . error handler = error handler ;   }  
@ test public void   (  )  {  assert equals ( 1  test observer .  empty observer . values (  )  . length )  ;  assert not null (  test observer .  empty observer . value of ( "instance" )  )  ;   }  
@ override public void   ( char[] ch int start int length )  throws sax exception  {  if  ( ch  =  =  null || ch . length  =  =  0 || length  <  =  0 )   {  return ;   }  try  {   string string = new  string ( ch start length )  ;  if  ( escape text )   {
@ override protected void   (  observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 1 )  ;  observer . on next ( 2 )  ;  observer . on complete (  )  ;  observer . on next ( 3 )  ;
public long   (  )  {  return last seen ;   }  
public  set <  string >    (  )  {  throw new  unsupported operation exception (  )  ;   }  
public boolean   (  )  {  return  plugin starter . plugins enabled (    context )  ;   }  
@ test @ ignore ( " null values are not allowed" )  public void   (  )  {   flowable <  string >  w =  flowable . from iterable (  arrays . as list ( "one" null "three" )  )  ;   single <  list <  string >  >  observable = w . to list (  )  ;   single obs
private float   (  color c1  color c2 )  {  float dx = c1 . get red (  )   -  c2 . get red (  )  ;  float dy = c1 . get green (  )   -  c2 . get green (  )  ;  float dz = c1 . get blue (  )   -  c2 . get blue (  )  ;  return  ( float )  math . sqrt ( dx * dx  +  dy * dy  +  dz * dz )  ;   }  
@ test public void   (  )  throws  document exception  io exception  {  logger . finest ( "test import user" )  ;   in exporter testobject = new  xep227 exporter ( "server name" offline messages store v card manager private storage user manager roster ite
public void   ( int len )  {  set header ( http . cache   control "max - age = "  +   integer . to string ( len )  )  ;   }  
@ override public  object   (  )  throws  exception  {  return new byte[100 * 1000 * 1000] ;   }  
@ test public void   (  )  {   test helper . check disposed (  completable subject . create (  )  )  ;   }  
private static double   ( final  collection <  tile >  tiles )  {  double area = 0 ;  double clusters = 0 ;  for  (  final  tile tile : tiles )   {  if  ( tile . get cluster density (  )   >  0 )  area +  =  ( tile . get cluster count (  )   /  tile . get cluster density (  )  )  ;  clusters +  = tile . get cluster count (  )  ;   }  return  ( area  >  0 )   ?  clusters  /  area : 0 . 0 ;   }  
public long   (  )  {  return last seen ;   }  
public void   (  )  {  iq router iq router = server . getiq router (  )  ;  iq disco info handler iq disco info handler = server . getiq disco info handler (  )  ;  for  (  iq handler iq handler : iq handlers )   {  element2 handlers . remove ( iq handler . get info (  )  . get name (  )  )  ;  try  {  iq handler . stop (  )  ;  iq handler . destroy (  )  ;   }  catch  (   exception e )   {   log . warn ( " unable to stop and destroy "  +  iq handler . get class (  )  )  ;   }  if  ( iq handler instanceof  server features provider )   {  for  (  iterator <  string >  i =  (  (  server features provider ) iq handler )  . get features (  )  ;  i . has next (  )  ;   )   {  if  ( iq disco info handler  !  =  null )   {  iq disco info handler . remove server feature ( i . next (  )  )  ;   }   }   }  if  ( muc )   {   multi user chat manager manager = server . get multi user chat manager (  )  ;  for  (   multi user chat service muc service : manager . get multi user chat services (  )  )   {  muc service . removeiq handler ( iq handler )  ;  muc service . remove extra feature ( namespace )  ;   }   }   }  if  ( iq router  !  =  null )   {  iq router . remove handler ( iq dispatcher )  ;   }   }  
public  cluster view   (  )  {  return cluster configuration . get cluster view (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  assert same (  flowable . empty (  )   flowable . amb array (  )  )  ;   }  
@ override public void   (  )  {  s . dispose (  )  ;   }  
public boolean   (  )  {  return  ( cpuid . get extendedecxcpu flags (  )  &  ( 1  <  <  21 )  )   !  =  0 ;   }  
@ test public void   (  )  {   group element a = curve . get zero (  group element .  representation . precomp )  ;   group element b =  group element . precomp ( curve two zero ten )  ;  assert that ( a . cmov ( b 0 )  is ( equal to ( a )  )  )  ;  asser
public void   (  )  {  sdc . datagram listener . datagram received ( sdc b client address )  ;   }  
@ override protected  string   (  )  {  return "rx" ;   }  
@ override public  handle   (  )  {  return handle ;   }  
@ test public void   (  )  throws  exception  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   functions . error   consumer . accept ( new  test exception (  )  )  ;   test helper . assert undeliverable ( errors 0  te
void   (  inner observer inner  throwable e )  {  set . delete ( inner )  ;  if  ( errors . add throwable ( e )  )   {  if  (  ! delay errors )   {  d . dispose (  )  ;  set . dispose (  )  ;   }  active . decrement and get (  )  ;  drain (  )  ;   }  else  {   rx java plugins . on error ( e )  ;   }   }  
public static final  string   (  string text )  {  final  string html color = tohtml color ( tooltip   color )  ;  final  string tool tip = " < html >  < table bg color = "  +  html color  +  " >  < tr >  < td >  < b > " +  text +  " <  / b >  <  / td >  <  / tr >  <  / table >  <  / table > " ;  return tool tip ;   }  
public void   ( i2p session session )  {  if  (    log . should log (  log . warn )  )     log . warn ( "krpc disconnected" )  ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . concat (  observable . just ( 0 )   observable .  <  integer > error ( new  test exception ( " forced failure" )  )  )  ;   observable <  integer >  m = source . group by ( ide
@ test public void   (  )  {  final  atomic integer counter = new  atomic integer (  )  ;   composite disposable s = new  composite disposable (  )  ;  s . add (  disposables . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  cou
@ test ( timeout = 5000 expected =  null pointer exception . class )  public void   (  )  {   completable c =  completable . concat ( new  iterable <  completable >  (  )  {  @ override public  iterator <  completable >  iterator (  )  {  return null ;   
public  response   (  service exception exception )  {   error response error response = new  error response (  )  ;  error response . set resource ( exception . get resource (  )  )  ;  error response . set message ( exception . get message (  )  )  ;  error response . set exception ( exception . get exception (  )  )  ;  log . error ( exception . get exception (  )   +  ": "  +  exception . get message (  )  +  " with resource " +  exception . get resource (  )  exception . get exception (  )  )  ;   response builder response builder =  response . status ( exception . get status (  )  )  . entity ( error response )  ;   list <  media type >  accepts = headers . get acceptable media types (  )  ;  if  ( accepts  !  =  null && accepts . size (  )   >  0 )   {   media type media type = accepts . get ( 0 )  ;  response builder = response builder . type ( media type )  ;   }  else  {  response builder = response builder . type ( headers . get media type (  )  )  ;   }  return response builder . build (  )  ;   }  
public   (  observable source < t >  source  action on finally )  {  super ( source )  ;  this . on finally = on finally ;   }  
public byte[]   (  )  {  return a ;   }  
public  string   (  )  {  return algo name ;   }  
public void   ( int ssrc )  {  rtcp data[8] =  ( byte )  (  ( ssrc  >  >  24 )  & 0xff )  ;  rtcp data[9] =  ( byte )  (  ( ssrc  >  >  16 )  & 0xff )  ;  rtcp data[10] =  ( byte )  (  ( ssrc  >  >  8 )  & 0xff )  ;  rtcp data[11] =  ( byte )  ( ssrc & 0xff )  ;   }  
private void   (  )  {   message m = new  message (  message . have   all )  ;  add message ( m )  ;   }  
@ override public final void   ( t t )  {  if  (  ! try on next ( t )  &&  ! done )   {  s . request ( 1 )  ;   }   }  
public void   (  )  {  context = i2p app context . get global context (  )  ;  log = context . log manager (  )  . get log ( k bucket set . class )  ;  byte[] us = new byte[ hash . hash   length] ;  context . random (  )  . next bytes ( us )  ;  us hash = new  hash ( us )  ;  set = new k bucket set <  hash >  ( context us hash k b )  ;  add random ( 1000 )  ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  event =  type . values (  ) [ externalizable util . get instance (  )  . read int ( in ) ] ;  service =  externalizable util . get instance (  )  . read saf
@ test public void   (  )  {   flowable .  <  integer > error ( new  test exception (  )  )  . switch map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception
private static void   (  private key pk  output stream out )  throws io exception   invalid key exception  {  byte[] buf = pk . get encoded (  )  ;  if  ( buf  =  =  null )  throw new  invalid key exception ( "encoding unsupported for this key" )  ;  writepem ( buf "private key" out )  ;   }  
@ override public void   ( long n )  {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }  
private  list <  hash >    (  hash key int num closest  set <  hash >  already checked )  {   hash rkey = get context (  )  . routing key generator (  )  . get routing key ( key )  ;  k bucket set <  hash >  ks =    facade . getk buckets (  )  ;  if  ( ks  =  =  null )  return new  array list <  hash >  (  )  ;  return  (  (  floodfill peer selector )    peer selector )  . select floodfill participants ( rkey num closest already checked ks )  ;   }  
public  object   (  string string )  {  return http request . get attribute ( string )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  ps =  publish subject . create (  )  ;  ps . publish (  )  . auto connect ( 0 )  ;  assert true ( ps . has observers (  )  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  interrupted exception  {   flowable . empty (  )  . on backpressure buffer (  - 1 empty   action drop   oldest )  ;   }  
public  eddsa parameter spec   (  )  {  return ed dsa spec ;   }  
public  string   (  )  {  return address ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  publish subject <  integer >  sampler =  publish subject . 
@ override public void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  s . on next ( 1 )  ;  s . on next ( 2 )  ;  s . on next ( 3 )  ;  s . on error ( new io exception (  )  )  ;  s . on complete (
@ override public long   (  )  {  return 1 ;   }  
@ override public  string   (  )  {  return name ;   }  
public static  statement context   (  handle handle )  {  return new  statement context ( handle . get config (  )  )  ;   }  
private muc user   ( jid userjid  string room name )  {  if  ( router  =  =  null )   {  throw new  illegal state exception ( " not initialized" )  ;   }   localmuc user user ;  synchronized  ( userjid . to string (  )  . intern (  )  )   {  user = users . get ( userjid )  ;  if  ( user  =  =  null )   {  if  ( room name  !  =  null )   {   localmuc room localmuc room = localmuc room manager . get room ( room name )  ;  if  ( localmuc room  !  =  null )   {  muc role occupant = localmuc room . get occupant by fulljid ( userjid )  ;  if  ( occupant  !  =  null &&  ! occupant . is local (  )  )   {  return new  remotemuc user ( userjid localmuc room )  ;   }   }   }  user = new  localmuc user ( this router userjid )  ;  users . put ( userjid user )  ;   }   }  return user ;   }  
public void   ( int duration )  {  this . duration = duration ;   }  
public static  string   (  )  {  return sip config . registrar address ;   }  
public void   (  handler handler )  {  if  (    log . should info (  )  )     log . info ( " unregister "  +  handler )  ;  synchronized  (    handlers )   {     handlers . remove ( handler )  ;   }   }  
@ override public void   ( int readlimit )  {  is . mark ( readlimit )  ;   }  
@ test public void   (  )  {   async processor <  string >  processor =  async processor . create (  )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;   test subscriber <  string >  ts = new  test subscriber <  string >  ( o
public static int   (  )  {  int count = 0 ;   string sql = "select count ( * )  from of sip user" ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( sql )  ;   result set rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  count = rs . get int ( 1 )  ;   }  rs . close (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  try  {  if  ( pstmt  !  =  null )   {  pstmt . close (  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  try  {  if  ( con  !  =  null )   {  con . close (  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }   }  return count ;   }  
@ test public void   (  )  {   flowable . never (  )  . window ( 1  time unit . seconds 1 )  . test ( 0l true )  . assert empty (  )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on error ( t )  ;   }  
public  string   (  )  {  if  ( event  <  0 || event  >  last   event )   {  return " invalid  event: "  +  event ;   }   string s = event string[event] ;  if  ( event  =  =  state   changed )   {  s = call state . to string (  )  ;   }  if  ( info  !  =  null && info . length (  )   >  0 )   {  s +  = " "  +  info ;   }  if  ( event  =  =  dtmf   key )   {  s +  = " dtmf key = '"  +  dtmf key  +  "'" ;   }  else if  ( event  =  =  treatment   done )   {  s +  = "  treatment = '"  +  treatment id  +  "'" ;   }  else if  ( event  =  =  number   of   calls )   {  s +  = "  number of calls = '"  +  number of calls  +  "'" ;   }  if  ( call id  !  =  null && call id . length (  )   >  0 )   {  s +  = "  call id = '"  +  call id  +  "'" ;   }  if  ( conference id  !  =  null && conference id . length (  )   >  0 )   {  s +  = "  conference id = '"  +  conference id  +  "'" ;   }  if  ( call info  !  =  null && call info . length (  )   >  0 )   {  s +  = "  call info = '"  +  call info  +  "'" ;   }  return  bridge version . get version (  )   +  " "  +  s ;   }  
public void   (  string s )  throws io exception  {  delegate . write chars ( s )  ;   }  
public int   (  )  {  if  (    context  =  =  null )  return 0 ;  else return    context . tunnel manager (  )  . get outbound client tunnel count (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject .  <  integer > create (  )  . join (  observable . just ( 1 )   functions . just function (  observable . never (  )  )   functions . just function (  observable . never (  ) 
public static  lock out provider   (  )  {  return  lock out manager container . instance . provider ;   }  
@ test public void   (  )  {  final  list <  object >  list = new  array list <  object >  (  )  ;   test exception ex = new  test exception (  )  ;  assert true (  maybe .  <  integer > error ( ex )  . do on event ( new  bi consumer <  integer  throwable
public int   (  )  {  return next value . y qseq coord ;   }  
  (  switch map single subscriber <  ?  r >  parent )  {  this . parent = parent ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  atomic reference <  maybe observer <  ?  super  intege
@ suppress warnings ( "unchecked" )  public static boolean   ( iq iq )  {  if  ( iq  =  =  null )   {  throw new  illegal argument exception ( " argument 'iq' cannot be null . " )  ;   }  if  ( iq . get type (  )   !  =  iq .  type . set )   {  return fal
protected int   ( byte[] out int cur index )  throws i2np message exception  {   system . arraycopy (    data 0 out cur index    data . length )  ;  return cur index  +     data . length ;   }  
private void   (  )  {   statistic statistic = new  statistic (  )  {  @ override public  string get name (  )  {  return  locale utils . get localized string ( "muc . stats . outgoing . name" )  ;   }  @ override public  type get stat type (  )  {  return  type . rate ;   }  @ override public  string get description (  )  {  return  locale utils . get localized string ( "muc . stats . outgoing . description" )  ;   }  @ override public  string get units (  )  {  return  locale utils . get localized string ( "muc . stats . outgoing . label" )  ;   }  @ override public double sample (  )  {  double msgcnt = 0 ;  for  (   multi user chat service service : get multi user chat services (  )  )   {  msgcnt +  = service . get outgoing message count ( true )  ;   }  return msgcnt ;   }  @ override public boolean is partial sample (  )  {  return false ;   }   }   ;   statistics manager . get instance (  )  . add multi statistic ( outgoing stat key traffic stat group statistic )  ;   }  
int   (  )  {  int peers = 0 ;  for  (   transport t :    transports . values (  )  )   {  peers +  = t . count active peers (  )  ;   }  return peers ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;   flowable .  <  integer > empty (  )  . default if empty ( 1 )  . subscribe ( ts )  ;  ts . assert no values (  )  ;  ts . assert not terminate
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
@ test public void   (  )  throws  exception  {   merger bi function <  integer >  merger = new  merger bi function <  integer >  ( new  comparator <  integer >  (  )  {  @ override public int compare (   integer o1   integer o2 )  {  return o1 . compare 
@ test public void   (  )  {   completable . using ( new  callable <  object >  (  )  {  @ override public  object call (  )  throws  exception  {  return 1 ;   }   }   new  function <  object  completable source >  (  )  {  @ override public  completable
public int   ( final t o )  {  smart add ( o )  ;  return super . index of ( o )  ;   }  
public   (  observable source < t >  source int count )  {  super ( source )  ;  this . count = count ;   }  
@ override public final void   (  )  {   future <  ?  >  f = get (  )  ;  if  ( f  !  =  finished && f  !  =  disposed )   {  if  ( compare and set ( f disposed )  )   {  if  ( f  !  =  null )   {  f . cancel ( runner  !  =   thread . current thread (  ) 
@ deprecated public static synchronized int   (  context context  string mailbox name )  {  if  ( s server mailbox names . size (  )   =  =  0 )   {  s server mailbox names . put ( context . get string ( r . string . mailbox   name   server   inbox )   ma
@ test public void   (  )  {   publish subject <  object >  as =  publish subject . create (  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . get throwable (  )  )  ;  as . on error ( new
@ nullable @ override public  integer   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
private void   (  chat information chat info )  {   connection con = null ;   prepared statement pstmt = null ;   result set result = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( agents   in   session )  ;  pstmt . set string ( 1 chat info . get sessionid (  )  )  ;  result = pstmt . execute query (  )  ;  while  ( result . next (  )  )   {  chat info . get agentji ds (  )  . add ( result . get string ( 1 )  )  ;   }   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  if  ( result  !  =  null )   {  try  {  result . close (  )  ;   }  catch  (  sql exception e )   {   log . error ( e . get message (  )  e )  ;   }   }   db connection manager . close connection ( pstmt con )  ;   }   }  
public void   ( boolean is init )  {  do cluster task ( new  set initialized task ( address is init )  )  ;   }  
@ override public org . cybergarage . xml .  node   (  node parent node org . w3c . dom .  node dom node int rank )  {  int dom node type = dom node . get node type (  )  ;   string dom node name = dom node . get node name (  )  ;   string dom node value 
@ override public void   (  connection close listener listener )  {  listeners . remove ( listener )  ;   }  
@ suppress warnings ( "unchecked" )  void   (  inner subscription < t >  p )  {  for  (  ;   ;   )   {   inner subscription < t > [] c = subscribers . get (  )  ;  int len = c . length ;  if  ( len  =  =  0 )   {  return ;   }  int j =  - 1 ;  for  ( int 
public void   ( long id )  {     last send id . set ( id )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ override public  object   (  string name )  throws sax not recognized exception  sax not supported exception  {  for  ( int i = 0 ;  i  <  lexical   handler   names . length ;  i +  +  )   {  if  ( lexical   handler   names[i] . equals ( name )  )   {  
@ override public boolean   (  )  {  return false ;   }  
@ benchmark public void   (  blackhole bh )  {  observe on maybe . subscribe with ( new  perf async consumer ( bh )  )  . await ( 1 )  ;   }  
public  data structure   (  )  {  return new  signing public key (  )  ;   }  
@ test public void   (  )  {  try  {   maybe . just ( 1 )  . compose ( new  maybe transformer <  integer  integer >  (  )  {  @ override public  maybe <  integer >  apply (   maybe <  integer >  v )  {  throw new  test exception ( " forced failure" )  ;  
@ check return value @ experimental @ non null public final  < r >  parallel flowable < r >    ( @ non null  function <  ?  super t  ?  extends r >  mapper @ non null  bi function <  ?  super  long  ?  super  throwable  parallel failure handling >  error 
public boolean   (  string nonce )  {  if  ( mailbox  =  =  null && login   nonce . equals ( nonce )  )  return true ;  synchronized  ( nonces )   {  return nonces . contains ( nonce )  ;   }   }  
@ test public void   (  )  throws  exception  {  when ( mocked request . get headers ( " accept" )  )  . then return (  collections . enumeration (  collections . singleton list ( media   type   application   json )  )  )  ;  response message service impl
public jid   (  )  {  return jid ;   }  
@ test public void   (  )  {   observable . switch on next delay error (  observable . just (  observable . just ( 1 )  )  )  . test (  )  . assert result ( 1 )  ;   }  
public boolean   (  )  {  return    manager  =  =  null &&    connecting ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  parallel invalid (  )  . map (  functions . identity (  )   parallel failure handling . error )  . sequential (  )  . test (  )  ;   test
@ override public void   ( t t )  {   object helper . require non null ( t "on next called with null .   null values are generally not allowed in 2 . x operators and sources . " )  ;  if  ( terminal event . get (  )   !  =  null )   {  return ;   }   obje
@ test public void   (  )  {   maybe <  integer >  observable =  flowable . just ( 1 )  . first element (  )  ;  observable . subscribe ( wm )  ;   in order in order = in order ( wm )  ;  in order . verify ( wm times ( 1 )  )  . on success ( 1 )  ;  in or
public void   (  )  {  map . clear (  )  ;   }  
@ override public final void   (  )  {  cancelled = true ;   disposable d = this . d ;  if  ( d  !  =  null )   {  d . dispose (  )  ;   }   }  
private void   ( final boolean use barcodes )  {  final int size in bytes ;  if  ( use barcodes )   {  size in bytes =  read ends for mark duplicates with barcodes . get size of (  )  ;   }  else  {  size in bytes =  read ends for mark duplicates . get size of (  )  ;   }  max   records   in   ram =  ( int )  (  runtime . get runtime (  )  . max memory (  )   /  size in bytes )   /  2 ;  final int max in memory =  ( int )  (  (  runtime . get runtime (  )  . max memory (  )  * sorting   collection   size   ratio )   /  size in bytes )  ;  log . info ( " will retain up to "  +  max in memory  +  " data points before spilling to disk . " )  ;  final  read ends for mark duplicates codec frag codec  pair codec  disk codec ;  if  ( use barcodes )   {  frag codec = new  read ends for mark duplicates with barcodes codec (  )  ;  pair codec = new  read ends for mark duplicates with barcodes codec (  )  ;  disk codec = new  read ends for mark duplicates with barcodes codec (  )  ;   }  else  {  frag codec = new  read ends for mark duplicates codec (  )  ;  pair codec = new  read ends for mark duplicates codec (  )  ;  disk codec = new  read ends for mark duplicates codec (  )  ;   }  this . pair sort =  sorting collection . new instance (  read ends for mark duplicates . class pair codec new  read endsmd comparator ( use barcodes )  max in memory tmp   dir )  ;  this . frag sort =  sorting collection . new instance (  read ends for mark duplicates . class frag codec new  read endsmd comparator ( use barcodes )  max in memory tmp   dir )  ;  final  sam header and iterator header and iterator = open inputs ( true )  ;  final sam file header .  sort order assumed sort order = header and iterator . header . get sort order (  )  ;  final sam file header header = header and iterator . header ;  final  read ends for mark duplicates map tmp = new  disk based read ends for mark duplicates map ( max   file   handles   for   read   ends   map disk codec )  ;  long index = 0 ;  final  progress logger progress = new  progress logger ( log  ( int ) 1e6 " read" )  ;  final  closeable iterator < sam record >  iterator = header and iterator . iterator ;  if  ( null  =  =  this . library id generator )   {  this . library id generator = new  library id generator ( header )  ;   }   string duplicate query name = null ;  long duplicate index = no   such   index ;  while  ( iterator . has next (  )  )   {  final sam record rec = iterator . next (  )  ;  if  ( program   record   id  !  =  null )   {  pg ids seen . add ( rec . get string attribute ( sam tag . pg . name (  )  )  )  ;   }  if  ( assumed sort order  =  =  sam file header .  sort order . queryname &&  ! rec . get read name (  )  . equals ( duplicate query name )  )   {  duplicate query name = rec . get read name (  )  ;  duplicate index = index ;   }  if  ( rec . get read unmapped flag (  )  )   {  if  ( rec . get reference index (  )   =  =   - 1 && assumed sort order  =  =  sam file header .  sort order . coordinate )   {  break ;   }   }  else if  (  ! rec . is secondary or supplementary (  )  )   {  final long index for read = assumed sort order  =  =  sam file header .  sort order . queryname  ?  duplicate index : index ;  final  read ends for mark duplicates fragment end = build read ends ( header index for read rec use barcodes )  ;  this . frag sort . add ( fragment end )  ;  if  ( rec . get read paired flag (  )  &&  ! rec . get mate unmapped flag (  )  )   {  final  string key = rec . get attribute (  reserved tag constants . read   group   id )   +  ":"  +  rec . get read name (  )  ;   read ends for mark duplicates paired ends = tmp . remove ( rec . get reference index (  )  key )  ;  if  ( paired ends  =  =  null )   {  paired ends = fragment end . clone (  )  ;  tmp . put ( paired ends . read2 reference index key paired ends )  ;   }  else  {  final int mates ref index = fragment end . read1 reference index ;  final int mates coordinate = fragment end . read1 coordinate ;  if  ( rec . get first of pair flag (  )  )   {  paired ends . orientation for optical duplicates =  read ends . get orientation byte ( rec . get read negative strand flag (  )  paired ends . orientation  =  =   read ends . r )  ;  if  ( use barcodes )   (  (  read ends for mark duplicates with barcodes ) paired ends )  . read one barcode = get read one barcode value ( rec )  ;   }  else  {  paired ends . orientation for optical duplicates =  read ends . get orientation byte ( paired ends . orientation  =  =   read ends . r rec . get read negative strand flag (  )  )  ;  if  ( use barcodes )   (  (  read ends for mark duplicates with barcodes ) paired ends )  . read two barcode = get read two barcode value ( rec )  ;   }  if  ( mates ref index  >  paired ends . read1 reference index ||  ( mates ref index  =  =  paired ends . read1 reference index && mates coordinate  >  =  paired ends . read1 coordinate )  )   {  paired ends . read2 reference index = mates ref index ;  paired ends . read2 coordinate = mates coordinate ;  paired ends . read2 index in file = index for read ;  paired ends . orientation =  read ends . get orientation byte ( paired ends . orientation  =  =   read ends . r rec . get read negative strand flag (  )  )  ;  if  ( paired ends . read2 reference index  =  =  paired ends . read1 reference index && paired ends . read2 coordinate  =  =  paired ends . read1 coordinate && paired ends . orientation  =  =   read ends . rf )   {  paired ends . orientation =  read ends . fr ;   }   }  else  {  paired ends . read2 reference index = paired ends . read1 reference index ;  paired ends . read2 coordinate = paired ends . read1 coordinate ;  paired ends . read2 index in file = paired ends . read1 index in file ;  paired ends . read1 reference index = mates ref index ;  paired ends . read1 coordinate = mates coordinate ;  paired ends . read1 index in file = index for read ;  paired ends . orientation =  read ends . get orientation byte ( rec . get read negative strand flag (  )  paired ends . orientation  =  =   read ends . r )  ;   }  paired ends . score +  =  duplicate scoring strategy . compute duplicate score ( rec this . duplicate   scoring   strategy )  ;  this . pair sort . add ( paired ends )  ;   }   }   }   +  + index ;  if  ( progress . record ( rec )  )   {  log . info ( " tracking "  +  tmp . size (  )   +  " as yet unmatched pairs .  " +  tmp . size in ram (  )  +  " records in ram . " )  ;   }   }  log . info ( " read "  +  index  +  " records .  " +  tmp . size (  )  +  " pairs never matched . " )  ;  iterator . close (  )  ;  this . pair sort . done adding (  )  ;  this . frag sort . done adding (  )  ;   }  
@ test public void   (  )  {   maybe . just ( 1 )  . contains ( 2 )  . test (  )  . assert result ( false )  ;   }  
@ override public void   (  observer <  ?  super t >  s )  {  s state ;  try  {  state = state supplier . call (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   empty disposable . error ( e s )  ;  return ;   }   generator
public void   (  im event im event )  {   log . debug ( " same time:  opened im session: "  +  im event )  ;   }  
  (  maybe observer <  ?  super r >  actual  function <  ?  super t  ?  extends  maybe source <  ?  extends u >  >  mapper  bi function <  ?  super t  ?  super u  ?  extends r >  result selector )  {  this . inner = new  inner observer < t u r >  ( actual result selector )  ;  this . mapper = mapper ;   }  
@ test public void   (  )  {   flowable . never (  )  . merge with (  maybe . error ( new  test exception (  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
void   (  )  {     alive = false ;  synchronized  (    job lock )   {     timed jobs . clear (  )  ;     ready jobs . clear (  )  ;     job lock . notify all (  )  ;   }   job poison = new  poison job (  )  ;  for  (   job queue runner runner :    queue runners . values (  )  )   {  runner . stop running (  )  ;     ready jobs . offer ( poison )  ;   }     queue runners . clear (  )  ;     job stats . clear (  )  ;     runner id . set ( 0 )  ;   }  
private  cursor   ( final  cursor input cursor final long account id final  string[] ui projection )  {  final  matrix cursor mc = new  matrix cursor with cached columns ( ui projection )  ;  if  ( input cursor  !  =  null )   {  try  {  remap folder cursor ( input cursor mc account id ui projection )  ;   }  finally  {  input cursor . close (  )  ;   }   }  return mc ;   }  
public int   (  )  throws io exception  {  if  ( indicator  =  =  0 )   {  indicator = in . read (  )  ;  if  ( in   special   map )  sha   digest . update (  ( byte ) indicator )  ;   }  return indicator ;   }  
public void   (  string email )  {  this . email = email ;   }  
public void   ( i2p session session int severity )  {  if  (    log . should log (  log . error )  )     log . error ( " abuse reported with severity "  +  severity )  ;     manager . disconnect all hard (  )  ;   }  
public boolean   (  string gateway )  {  return configured gateways . contains ( gateway )  ;   }  
  (  list <  string >  config properties )  {  this . config properties = config properties ;   }  
public boolean   (  class <  ?  >  extension type )  {  return find factory for ( extension type )  . is present (  )  ;   }  
@ test ( data provider = "negative test data" )  public void   ( final  illumina file util .  supported illumina format[] formats final  illumina data type[] data types final  list <  string >  files to delete final  list <  string >  files to empty final
public int   (  )  {  return    begin ;   }  
@ override public void   (  )  {  actual . on error ( new  no such element exception (  )  )  ;   }  
public void   ( byte[] buffer )  {  this . buffer = buffer ;  packet . set data ( buffer )  ;   }  
@ override public boolean   (  collection <  ?  >  c )  {  boolean b = list . retain all ( c )  ;  lazy set ( list . size (  )  )  ;  return b ;   }  
public void   (  string property  map <  string  object >  params )  {  if  ( property . equals ( "conversation . metadata archiving" )  )   {  metadata archiving enabled = true ;   }  else if  ( property . equals ( "conversation . message archiving" )  )   {  message archiving enabled = false ;   }  else if  ( property . equals ( "conversation . room archiving" )  )   {  room archiving enabled = false ;   }  else if  ( property . equals ( "conversation . room archiving stanzas" )  )   {  room archiving stanzas enabled = false ;   }  else if  ( property . equals ( "conversation . rooms archived" )  )   {  rooms archived =  collections . empty list (  )  ;   }  else if  ( property . equals ( "conversation . idle time" )  )   {  idle time = default   idle   time *  jive constants . minute ;   }  else if  ( property . equals ( "conversation . max time" )  )   {  max time = default   max   time *  jive constants . minute ;   }  else if  ( property . equals ( "conversation . max age" )  )   {  max age = default   max   age *  jive constants . day ;   }  else if  ( property . equals ( "conversation . max retrievable" )  )   {  max retrievable = default   max   retrievable *  jive constants . day ;   }  else if  ( property . equals ( "conversation . max time debug" )  )   {   log . info ( " monitoring plugin max time reset back to "  +  default   max   time  +  " minutes" )  ;  max time = default   max   time *  jive constants . minute ;   }   }  
private void   (  snark snark  map <  string  string[] >  post params )  {  boolean yes = post params . get ( "enable comments" )   !  =  null ;     manager . set saved comments enabled ( snark yes )  ;   }  
public void   (  string affiliation )  {  this . affiliation = affiliation ;   }  
@ data provider ( name = " " )  public  object[][] data test debug option (  )  {  return new  object[][] {  { null false }   { true true }   { false false }  }  ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   completable . merge delay error ( new  flowable <  completable >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  su
  (  throwable e )  {  this . e = e ;   }  
private void   ( int previous token end int current token start  list <  format argument handler >  arg handler list )  {  final  string between elements = format template . substring ( previous token end current token start )  ;  if  (  ! is empty ( between elements )  )   {  arg handler list . add ( handle argument (  log argument group extractor . string entity ( between elements )  )  )  ;   }   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  int count ;  @ override public void accept (   integer v )  throws  exception  {  if  ( count +  +   =  =  1 )   {  return ;   }
@ override protected  string[]   (  )  {  return new  string[] {  jingle channeliq . namespace  jingle trackeriq . namespace }  ;   }  
public void   (  string username  string roster jid  roster item entity roster item entity )  throws  service exception   user not found exception   user already exists exception   shared group exception  {  get and check user ( username )  ;   roster roster = get user roster ( username )  ;  jid jid = new jid ( roster jid )  ;   roster item roster item = roster . get roster item ( jid )  ;  if  ( roster item entity . get nickname (  )   !  =  null )   {  roster item . set nickname ( roster item entity . get nickname (  )  )  ;   }  if  ( roster item entity . get groups (  )   !  =  null )   {  roster item . set groups ( roster item entity . get groups (  )  )  ;   }   user utils . check sub type ( roster item entity . get subscription type (  )  )  ;  roster item . set sub status (  roster item .  sub type . get type from int ( roster item entity . get subscription type (  )  )  )  ;  roster . update roster item ( roster item )  ;   }  
public int   (  )  {  return i ;   }  
@ override public void   (  subscription t )  throws  exception  {  t . request (  long . max   value )  ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . cancel (  )  ;  s =  subscription helper . cancelled ;  o
  ( u buffer )  {  this . buffer = buffer ;   }  
private   (  )  {  super ( new  byte array output stream (  data helper . max   uncompressed )  )  ;     buffer =  (  byte array output stream ) out ;   }  
public void   (  packet packet )  {   log . debug ( packet . toxml (  )  )  ;  if  ( packet instanceof iq )   {  iq iq =  ( iq ) packet ;  if  ( iq .  type . error  =  =  iq . get type (  )  || iq .  type . result  =  =  iq . get type (  )  )   {  return ;   }  processiq ( iq )  ;   }   }  
public byte[]   (  )  {  return  arrays . copy of range ( e 0 d )  ;   }  
@ override public void   (  )  {  us . subscribe ( to2 )  ;   }  
public  tunnel pool settings   (  hash client )  {   tunnel pool pool =    client outbound pools . get ( client )  ;  if  ( pool  !  =  null )  return pool . get settings (  )  ;  else return null ;   }  
  ( int eax int ebx int ecx int edx )  {  this . eax = eax ;  this . ebx = ebx ;  this . ecx = ecx ;  this . edx = edx ;   }  
int   ( int a )  {  if  ( a  =  =  0 )   {  throw new  illegal argument exception (  )  ;   }  return log table[a] ;   }  
  ( t[] array )  {  this . array = array ;   }  
@ before public void   (  )  {  w =  test helper . mock subscriber (  )  ;  wo =  test helper . mock single observer (  )  ;  wm =  test helper . mock maybe observer (  )  ;   }  
private void   (  )  {  if  ( closed )   {  throw new  illegal state exception ( " stream is closed" )  ;   }   }  
@ override public short   (  )  {  return this . read group ;   }  
@ test public void   (  )  throws  interrupted exception  {   observable <  integer >  source =  observable . just ( 1 2 3 4 5 6 )  ;   single <  integer >  reduced = source . reduce ( 0 sum )  ;   integer r = reduced . blocking get (  )  ;  assert equals
@ test public void   (  )  {   test observer <  integer >  to =  observable .  <  integer > error ( new  test exception ( " outer" )  )  . flat map (  functions . just function (  observable . just ( 1 )  )  new  function <  throwable  observable <  integ
@ check return value @ scheduler support (  scheduler support . none )  @ backpressure support (  backpressure kind . full )  private static  completable   (  publisher <  ?  extends  completable source >  sources int max concurrency boolean delay errors 
boolean   (  )  {   font font = gdef . get font ( fonttag   axis )  ;   paint grid color = gdef . colors[color   grid] ;   paint m grid color = gdef . colors[color   mgrid] ;   paint font color = gdef . colors[color   font] ;  int label offset =  ( int )  ( worker . get font ascent ( font )   /  2 )  ;  int labfact = 2 ;  double range = im . maxval  -  im . minval ;  double scaledrange = range  /  im . magfact ;  double gridstep ;  if  (  double . is nan ( scaledrange )  )   {  return false ;   }   string labfmt = null ;  if  (  double . is nan ( im . ygridstep )  )   {  if  ( gdef . alty grid )   {  int decimals =  ( int )  math . ceil (  math . log10 (  math . max (  math . abs ( im . maxval )   math . abs ( im . minval )  )  )  )  ;  if  ( decimals  <  =  0 )   {  decimals = 1 ;   }  int fractionals =  ( int )  math . floor (  math . log10 ( range )  )  ;  if  ( fractionals  <  0 )   {  labfmt =  util . sprintf ( "%%%d . %df" decimals  -  fractionals  +  1  - fractionals  +  1 )  ;   }  else  {  labfmt =  util . sprintf ( "%%%d . 1f" decimals  +  1 )  ;   }  gridstep =  math . pow ( 10 fractionals )  ;  if  ( gridstep  =  =  0 )   {  gridstep = 0 . 1 ;   }  if  ( range  /  gridstep  <  5 )   {  gridstep /  = 10 ;   }  if  ( range  /  gridstep  >  15 )   {  gridstep* = 10 ;   }  if  ( range  /  gridstep  >  5 )   {  labfact = 1 ;  if  ( range  /  gridstep  >  8 )   {  labfact = 2 ;   }   }  else  {  gridstep /  = 5 ;  labfact = 5 ;   }   }  else  {  int minimum label count = 3 ;  y lab selectedy lab = null ;  while  ( selectedy lab  =  =  null )   {  selectedy lab = findy lab ( minimum label count )  ;  minimum label count -  -  ;   }  gridstep = selectedy lab . grid * im . magfact ;  labfact = find label factor ( selectedy lab )  ;   }   }  else  {  gridstep = im . ygridstep ;  labfact = im . ylabfact ;   }  int x0 = im . xorigin  x1 = x0  +  im . xsize ;  int sgrid =  ( int )  ( im . minval  /  gridstep  -  1 )  ;  int egrid =  ( int )  ( im . maxval  /  gridstep  +  1 )  ;  double scaledstep = gridstep  /  im . magfact ;  for  ( int i = sgrid ;  i  <  =  egrid ;  i +  +  )   {  int y = this . mapper . ytr ( gridstep * i )  ;  if  ( y  >  =  im . yorigin  -  im . ysize && y  <  =  im . yorigin )   {  if  ( i % labfact  =  =  0 )   {   string graph   label ;  if  ( i  =  =  0 || im . symbol  =  =  ' ' )   {  if  ( scaledstep  <  1 )   {  if  ( i  !  =  0 && gdef . alty grid )   {  graph   label =  util . sprintf ( labfmt scaledstep * i )  ;   }  else  {  graph   label =  util . sprintf ( "%4 . 1f" scaledstep * i )  ;   }   }  else  {  graph   label =  util . sprintf ( "%4 . 0f" scaledstep * i )  ;   }   }  else  {  if  ( scaledstep  <  1 )   {  graph   label =  util . sprintf ( "%4 . 1f %c" scaledstep * i im . symbol )  ;   }  else  {  graph   label =  util . sprintf ( "%4 . 0f %c" scaledstep * i im . symbol )  ;   }   }  int length =  ( int )  ( worker . get string width ( graph   label font )  )  ;  worker . draw string ( graph   label x0  -  length  -  padding   vlabel y  +  label offset font font color )  ;  worker . draw line ( x0  -  2 y x0  +  2 y m grid color tick   stroke )  ;  worker . draw line ( x1  -  2 y x1  +  2 y m grid color tick   stroke )  ;  worker . draw line ( x0 y x1 y m grid color grid   stroke )  ;   }  else if  (  !  ( gdef . no minor grid )  )   {  worker . draw line ( x0  -  1 y x0  +  1 y grid color tick   stroke )  ;  worker . draw line ( x1  -  1 y x1  +  1 y grid color tick   stroke )  ;  worker . draw line ( x0 y x1 y grid color grid   stroke )  ;   }   }   }  return true ;   }  
@ override public  optional <  column mapper <  ?  >  >    (  type type  config registry config )  {  return maps . equals ( type )   ?   optional . of ( mapper )  :  optional . empty (  )  ;   }  
public boolean   (  archived message message )  {  return false ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   publish subject <  integer >  ps =  publish subject . create (  )  ;   test observer <  integer >  to = ps . timeout (  functions . just func
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 0 100000 )  . on error resume next (  observable . just ( 1 )  )  . observe on (  schedulers . computation (  )  )  . map ( new
public static  integer   (  byte value[]  integer start index )  {   byte bytes[] = new  byte[4] ;  for  ( int i = 0 ;  i  <  bytes . length ;  i +  +  )  bytes[i] = value[start index . int value (  )   +  i] ;  if  ( is little endian (  )  . boolean value (  )  )  reverse ( bytes )  ;  return to integer ( bytes  integer . value of ( 0 )  )  ;   }  
public  string   (  )  {  return description ;   }  
@ override public  iterator <  roster item >    (  string username )  {   linked list <  roster item >  item list = new  linked list <  >  (  )  ;   map <  long  roster item >  items byid = new  hash map <  >  (  )  ;   connection con = null ;   prepared 
public  string   (  )  {  return hostname ;   }  
private  list <  string >    (  string .  .  .  args )  {   list <  string >  list = new  array list <  string >  (  )  ;  for  (   string arg : args )   {  list . add ( arg )  ;   }  return list ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer generated1 = new  atomic integer (  )  ;   observable <  integer >  o1 = create infinite observable ( generated1 )  . subscribe on (  schedulers . computation (  )  )  ;   
@ test public void   (  )  {  try  {  new  composite exception (  )  ;  fail ( " composite exception should fail if errors is empty" )  ;   }  catch  (   illegal argument exception e )   {  assert equals ( "errors is empty" e . get message (  )  )  ;   } 
@ override public void   (  )  {  compressed = true ;  try  {  if  ( tls stream handler  =  =  null )   {  z output stream out = new z output stream (  server traffic counter . wrap output stream ( socket . get output stream (  )  )  j zlib . z   best   c
public int   (  )  {  return    consecutive failed sends ;   }  
public boolean   (  )  {  return positionals . is empty (  )  && named . is empty (  )  && named argument finder . is empty (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   publish processor <  integer >  pp =  publish processor . create (  )  ;  final  disposable[] ds =  { null }  ;  pp . single element (  )  . u
private void   (  )  {  if  ( extended information  !  =  null && presence  !  =  null )   {   element muc user = presence . get element (  )  . element ( q name . get ( "x" "http: /  / jabber . org / protocol / muc#user" )  )  ;  if  ( muc user  !  =  null )   {  presence . get element (  )  . remove ( muc user )  ;   }   element exi = extended information . create copy (  )  ;  presence . get element (  )  . add ( exi )  ;   }   }  
@ override public  string   (  )  {  return "i2p logger" ;   }  
@ test public void   (  )  {   connectable flowable <  integer >  source =  flowable . range ( 1 10 )  . replay ( 2 )  ;  source . connect (  )  ;   test subscriber <  integer >  ts1 = new  test subscriber <  integer >  ( 2l )  ;  source . subscribe ( ts1
void   ( boolean is enabled )  {  if  (  ! is enabled )   {  delete secured accounts ( m context )  ;   }   }  
public static  conversation event   ( jid roomjid jid user  string nickname  date date )  {   conversation event event = new  conversation event (  )  ;  event . type =  type . occupant joined ;  event . roomjid = roomjid ;  event . user = user ;  event . nickname = nickname ;  event . date = date ;  return event ;   }  
@ test public void   (  )  {   flowable . just ( 1 2 3 4 5 )  . concat map eager ( new  function <  integer  flowable <  integer >  >  (  )  {  @ override public  flowable <  integer >  apply (   integer i )  throws  exception  {  return i  =  =  3  ?   f
public  socket channel   (  socket address local )  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   publish processor <  integer >  other =  publish processor . create (  )  ;   flowable <  integer >  result = source . with latest from ( other c
public   (  skip span < k v >  ss int index )  {  if  ( ss  =  =  null )   {  throw new  null pointer exception (  )  ;   }  this . ss = ss ;  this . index = index ;   }  
public void   ( final  context c final int count )  {  if  ( count  !  =  m total count )   {  final  content values values = new  content values ( 1 )  ;  values . put (  mailbox columns . total   count count )  ;  update ( c values )  ;  m total count = count ;   }   }  
@ override public void   (  subscription s )  {  if  (  !  subscription helper . validate ( this . s s )  )   {  return ;   }  this . s = s ;  u b ;  try  {  b =  object helper . require non null ( buffer supplier . call (  )  " the supplied buffer is nul
@ test public void   (  )  {   set <  string >  one = null ;   set <  string >  two = new  hash set (  )  ;  two . add ( "abc" )  ;  assert false (  set utilities . null safe equals ( one two )  )  ;   }  
private void   (  string app )  {  try  {   plugin starter . start plugin (    context app )  ;   properties props =  plugin starter . plugin properties (    context app )  ;   string name =  config clients helper . striphtml ( props "console link name   "  +   messages . get language (    context )  )  ;  if  ( name  =  =  null )  name =  config clients helper . striphtml ( props "console link name" )  ;   string url =  config clients helper . striphtml ( props "console linkurl" )  ;  if  ( name  !  =  null && url  !  =  null && name . length (  )   >  0 && url . length (  )   >  0 )   {  app = " < a href = \""  +  url  +  "\" > " +  name +  " <  / a > " ;  add form notice no escape (    t ( " started plugin  { 0 } " app )  )  ;   }  else  {  add form notice (    t ( " started plugin  { 0 } " app )  )  ;   }   }  catch  (   throwable e )   {  add form error (    t ( " error starting plugin  { 0 } " app )   +  ": "  +  e )  ;     log . error ( " error starting plugin "  +  app e )  ;   }   }  
@ test ( expected =  illegal state exception . class )  public void   (  )  throws  exception  {  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  h . create update ( "insert into something  ( id  nam
public boolean   (  )  {  return this . skip ;   }  
@ test public void   (  )  {   rx thread factory tf = new  rx thread factory ( " test" 1 )  ;  assert equals ( " rx thread factory[ test]" tf . to string (  )  )  ;   thread t = tf . new thread (  functions . empty   runnable )  ;  assert true ( t . is da
@ test public void   (  )  {   test helper . check double on subscribe observable to completable ( new  function <  observable <  object >   completable >  (  )  {  @ override public  completable apply (   observable <  object >  f )  throws  exception  {
public  privacy list   (  string username )  {  if  (  ! database contains privacy lists . get (  )  )   {  return null ;   }   string list name = null ;   string list value = null ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   default   privacy   list )  ;  pstmt . set string ( 1 username )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  list name = rs . get string ( 1 )  ;  list value = rs . get string ( 2 )  ;   }  else  {  return null ;   }   }  catch  (   exception e )   {   log . error ( " error loading default privacy list of username: "  +  username e )  ;  return null ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   privacy list privacy list = null ;  sax reader xml reader = null ;  try  {  xml reader = xml readers . take (  )  ;   element list element = xml reader . read ( new  string reader ( list value )  )  . get root element (  )  ;  privacy list = new  privacy list ( username list name true list element )  ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  finally  {  if  ( xml reader  !  =  null )   {  xml readers . add ( xml reader )  ;   }   }  return privacy list ;   }  
public void   (  string value )  {  get icon node (  )  . set node ( url value )  ;   }  
public static final synchronized  naming service   ( i2p app context context )  {   naming service instance = null ;   string dflt = context . is router context (  )   ?  default   impl : backup   impl ;   string impl = context . get property ( prop   impl default   impl )  ;  if  ( impl . equals ( old   default   impl )  )  impl = dflt ;  try  {   class <  ?  >  cls =  class . for name ( impl )  ;   constructor <  ?  >  con = cls . get constructor ( i2p app context . class )  ;  instance =  (  naming service ) con . new instance ( context )  ;   }  catch  (   exception ex )   {   log log = context . log manager (  )  . get log (  naming service . class )  ;  if  (  ! impl . equals ( backup   impl )  )   {  log . error ( " cannot load naming service "  +  impl  +  "  using  hosts txt naming service" ex )  ;  instance = new  hosts txt naming service ( context )  ;   }  else  {  log . error ( " cannot load naming service "  +  impl  +  "  only  . b32 . i2p lookups will succeed" ex )  ;  instance = new  dummy naming service ( context )  ;   }   }  return instance ;   }  
private void   (  status status boolean isi pv6 )  {  if  (    log . should log (  log . info )  )     log . info ( " test results  ( i pv6 ?  "  +  isi pv6  +  " ) : status  =  " +  status )  ;     transport . set reachability status ( status isi pv6 )  ;   }  
private void   (  )  {  info . release write lock (  )  ;  database . release write lock (  )  ;   }  
public void   ( boolean notify delete )  {  this . notify delete = notify delete ;   }  
@ override public void   (  )  {  stop plugins (    context )  ;   }  
@ test public void   (  )  {  final  publish subject <  integer >  ps1 =  publish subject . create (  )  ;  final  publish subject <  integer >  ps2 =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  ( 
public void   (  )  {   string[] lines = get lines (  )  ;  if  ( lines . length  =  =  0 )   {  return ;   }   log utils . w (  logging . log   tag " last network activities:" )  ;  for  (   string r : get lines (  )  )   {   log utils . w (  logging . log   tag "%s" r )  ;   }  init buffer (  )  ;   }  
@ override public void   ( boolean recurse )  {  throw new  error ( " imap store . delete (  )  not yet implemented" )  ;   }  
public   (  router context ctx )  {  super ( ctx )  ;     started = ctx . clock (  )  . now (  )  ;   }  
@ override public void   (  subscription s )  {   subscription helper . set once ( this s batch size )  ;   }  
@ test public void   (  )  {   flowable <  string >  source =  flowable . just ( "a" "b" "cc" "dd" )  ;   flowable <  map <  integer  collection <  string >  >  >  mapped = source . to multimap ( length func duplicate )  . to flowable (  )  ;   map <  int
public  string   (  )  {  return description ;   }  
@ override protected  list <  action >    (  session data data )  {  return  collections . singleton list (  action . complete )  ;   }  
  (  single observer <  ?  super t >  actual  consumer <  ?  super t >  on after success )  {  this . actual = actual ;  this . on after success = on after success ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  observable <  integer >  (  )  {  @ override protected void subscribe actual (   observer <  ?  super  integer >  observer )  {  observer
public boolean   (  )  {  return  ( limit pair  =  =  null )  ||  ( limit pair . get value (  )  . max amount (  )   -  limit pair . get value (  )  . amount (  )   >  =  0 )  ;   }  
@ override public void   (  throwable e )  {  observer . on error ( e )  ;   }  
@ override public boolean   (  workgroup workgroup  user request request )  {  for  (   request queue request queue : workgroup . get request queues (  )  )   {  if  ( request queue  !  =  null && request queue . is opened (  )  )   {  request queue . add
@ override synchronized void   (  )  {  if  (    log . should log (  log . warn )  )     log . warn ( to string (  )   +  ":  shutdown called" )  ;     alive = false ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ xml element ( name = "groupname" )  public  list <  string >    (  )  {  return group names ;   }  
public void   ( long message id boolean successfully sent long time to send )  {  if  (  !    do log )  return ;   string builder buf = new  string builder ( 128 )  ;  buf . append ( get prefix (  )  )  ;  buf . append ( " send payload message in [" )  . append ( message id )  . append ( "] in [" )  . append ( time to send )  . append ( "] successfully ?  " )  . append ( successfully sent )  ;  add entry ( buf . to string (  )  )  ;   }  
private static long   ( byte ip[] )  {  long rv = 0 ;  if  ( ip . length  =  =  16 )   {  for  ( int i = 0 ;  i  <  8 ;  i +  +  )  rv| =  ( ip[i] & 0xffl )   <  <   (  ( 7  -  i )  * 8 )  ;  return rv ;   }  else  {  for  ( int i = 0 ;  i  <  4 ;  i +  +  )  rv| =  ( ip[i] & 0xff )   <  <   (  ( 3  -  i )  * 8 )  ;  return rv & 0xffffffffl ;   }   }  
protected  key   (  key key )  throws  invalid key exception  {  throw new  invalid key exception ( " no other  el gamal key providers known" )  ;   }  
public boolean   (  string prop name )  {  return get property ( prop name true )  ;   }  
public static  string   ( long time )  {  int a time ;  int minutes ;  int seconds ;   string display string ;  if  ( time  >  0 )   {  a time =  ( int )  ( time )   /  1000 ;  minutes = a time  /  60 ;  seconds = a time % 60 ;  if  ( minutes  !  =  0 )   {  display string = minutes  +  " min  "  +  seconds +  " sec . " ;   }  else  {  display string = seconds  +  " seconds" ;   }   }  else  {  return "0 seconds" ;   }  return display string ;   }  
@ test public void   (  )  throws  versioned host not found exception  {  assert equals ( local endpoint configuration data . get host for version mapping ( version1 )  )  ;   }  
public void   ( iq packet  workgroup workgroup  string key )  {  iq reply = iq . create resultiq ( packet )  ;   chat setting setting = get chat setting ( workgroup key )  ;  if  ( setting  =  =  null )   {  reply . set child element ( packet . get child element (  )  . create copy (  )  )  ;  reply . set error ( new  packet error (  packet error .  condition . item   not   found )  )  ;  workgroup . send ( reply )  ;  return ;   }   element web settings = reply . set child element ( "chat - settings" "http: /  / jivesoftware . com / protocol / workgroup" )  ;   element root = web settings . add element ( "chat - setting" )  ;  root . add element ( "key" )  . set text ( setting . get key (  )  . to string (  )  )  ;  root . add element ( "value" )  . set text ( setting . get value (  )  )  ;  root . add element ( "type" )  . set text (  integer . to string ( setting . get type (  )  . get type (  )  )  )  ;  workgroup . send ( reply )  ;   }  
public void   (  )  {  decodes = 0 ;  decode time = 0 ;   }  
public long   (  )  throws io exception  {  return nan seconds . get (  )  ;   }  
public boolean   ( iq packet )  {   element iq = packet . get child element (  )  ;   string name = iq . get name (  )  ;  return "chat - sessions" . equals ( name )  ;   }  
public void   (  plugin manager manager  file plugin directory )  {  boolean found incompatible plugin = false ;  try  {  if  ( check for enterprise plugin (  )  )   {   system . out . println ( " enterprise plugin found .   stopping  bookmarks  plugin . " )  ;  found incompatible plugin = true ;   }  if  ( check for incompatible client control plugin (  )  )   {   system . out . println ( " client control plugin v1 . 3 . 1 or earlier found .   stopping  bookmarks  plugin . " )  ;  found incompatible plugin = true ;   }   }  catch  (   exception ex )   {   log . warn ( " an exception occurred while determining if there are incompatible plugins .   assuming everything is ok . " ex )  ;   }  if  ( found incompatible plugin )   {  throw new  illegal state exception ( " this plugin cannot run next to the  enterprise plugin  ( any version )  or the  client control plugin v1 . 3 . 1 or earlier . " )  ;   }  bookmark interceptor = new  bookmark interceptor (  )  ;  bookmark interceptor . start (  )  ;   }  
@ test public void   (  )  throws  exception  {   parsed sql parsed = parser . parse ( "#bo0 '#nope'    %&^& *@ #id" ctx )  ;  assert that ( parsed . get sql (  )  )  . is equal to ( " ?  '#nope'    %&^& *@  ? " )  ;   }  
private boolean   ( jid recipientjid  message packet boolean is private )  {   list <  client session >  sessions = new  array list <  >  (  )  ;  for  (  jid address : get routes ( recipientjid packet . get from (  )  )  )   {   client session session = get client route ( address )  ;  if  ( session  !  =  null && session . is initialized (  )  )   {  sessions . add ( session )  ;   }   }   list <  client session >  non negative priority sessions = get non negative sessions ( sessions 0 )  ;  if  ( packet . get type (  )   =  =   message .  type . error )   {   log . debug ( " error stanza to bare jid discarded:  {  } " packet . toxml (  )  )  ;  return true ;   }  if  ( packet . get type (  )   =  =   message .  type . groupchat )   {   log . debug ( " groupchat stanza to bare jid discarded:  {  } " packet . toxml (  )  )  ;  return false ;   }  if  ( non negative priority sessions . is empty (  )  )   {   log . debug ( " unable to route packet .   no session is available so store offline .   {  }  " packet . toxml (  )  )  ;  return false ;   }  for  (   client session session : non negative priority sessions )   {  if  ( packet . get type (  )   =  =   message .  type . headline )   {  session . process ( packet )  ;   }  else if  ( should carbon copy to resource ( session packet is private )  )   {  session . process ( packet )  ;   }  else if  (  jive globals . get boolean property ( "route . really - all - resources" false )  )   {  session . process ( packet )  ;   }   }  if  ( packet . get type (  )   =  =   message .  type . headline )   {  return true ;   }  if  (  jive globals . get boolean property ( "route . really - all - resources" false )  )   {  return true ;   }   list <  client session >  highest priority sessions = get highest priority sessions ( non negative priority sessions )  ;  if  ( highest priority sessions . size (  )   =  =  1 )   {  if  (  ! should carbon copy to resource ( highest priority sessions . get ( 0 )  packet is private )  )   {  highest priority sessions . get ( 0 )  . process ( packet )  ;   }   }  else  {  if  (  !  jive globals . get boolean property ( "route . all - resources" false )  )   {   collections . sort ( highest priority sessions new  comparator <  client session >  (  )  {  @ override public int compare (   client session o1   client session o2 )  {  int this val = get show value ( o1 )  ;  int another val = get show value ( o2 )  ;  return  ( this val  <  another val  ?   - 1 :  ( this val  =  =  another val  ?  0 : 1 )  )  ;   }  private int get show value (   client session session )  {   presence .  show show = session . get presence (  )  . get show (  )  ;  if  ( show  =  =   presence .  show . chat )   {  return 1 ;   }  else if  ( show  =  =  null )   {  return 2 ;   }  else if  ( show  =  =   presence .  show . away )   {  return 3 ;   }  else if  ( show  =  =   presence .  show . xa )   {  return 4 ;   }  else  {  return 5 ;   }   }   }   )  ;   list <  client session >  targets = new  array list <  >  (  )  ;   presence .  show show filter = highest priority sessions . get ( 0 )  . get presence (  )  . get show (  )  ;  for  (   client session session : highest priority sessions )   {  if  ( session . get presence (  )  . get show (  )   =  =  show filter )   {  targets . add ( session )  ;   }  else  {  break ;   }   }   collections . sort ( targets new  comparator <  client session >  (  )  {  @ override public int compare (   client session o1   client session o2 )  {  return o2 . get last active date (  )  . compare to ( o1 . get last active date (  )  )  ;   }   }   )  ;   client session session = targets . get ( 0 )  ;  if  (  ! should carbon copy to resource ( session packet is private )  )   {  session . process ( packet )  ;   }   }  else  {  for  (   client session session : highest priority sessions )   {  if  (  ! should carbon copy to resource ( session packet is private )  )   {  session . process ( packet )  ;   }   }   }   }  return true ;   }  
void   (  print stream s  number format number format )  {   string buffer sb = new  string buffer ( "ds[" )  ;  sb . append ( name )  ;  s . print ( sb )  ;  s . print ( "] . type  =  \"" )  ;  s . print ( type )  ;  s . println ( "\"" )  ;  s . print ( sb )  ;  s . print ( "] . minimal   heartbeat  =  " )  ;  s . println ( minimum heartbeat )  ;  s . print ( sb )  ;  s . print ( "] . min  =  " )  ;  s . println (  double . is nan ( minimum )   ?  " nan" : number format . format ( minimum )  )  ;  s . print ( sb )  ;  s . print ( "] . max  =  " )  ;  s . println (  double . is nan ( maximum )   ?  " nan" : number format . format ( maximum )  )  ;  s . print ( sb )  ;  s . print ( "] . last   ds  =  " )  ;  s . println ( pdp status block . last reading )  ;  s . print ( sb )  ;  s . print ( "] . value  =  " )  ;  double value = pdp status block . value ;  s . println (  double . is nan ( value )   ?  " nan" : number format . format ( value )  )  ;  s . print ( sb )  ;  s . print ( "] . unknown   sec  =  " )  ;  s . println ( pdp status block . unknown seconds )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;  final int[] call =  { 0 }  ;   completable . error ( new  test exception (  )  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  throws  except
public synchronized void   (  )  {     initialized = false ;  if  (    kb  !  =  null )     kb . clear (  )  ;  if  (    ds  !  =  null )     ds . stop (  )  ;     explore keys . clear (  )  ;     negative cache . clear (  )  ;   }  
public  string   (  )  {  return " handle  database  lookup  message" ;   }  
public  string   (  )  {  return email ;   }  
public int   (  )  {  return id ;   }  
@ override public  integer   (  integer a  integer b )  throws  exception  {  throw new  illegal state exception (  )  ;   }  
public  string   (  )  {  return get checked ( prop   oldhome )  ;   }  
public static  < t >  function <  observable < t >   test observer < t >  >    ( final int mode final boolean cancelled )  {  return new  test function callback < t >  ( mode cancelled )  ;   }  
@ test public void   (  )  {   flowable . empty (  )  . sample (  flowable . timer ( 1  time unit . days )  true )  . test (  )  . assert result (  )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 2 )  . map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . concat map delay error ( 
public boolean   (  )  {  return    stopping ;   }  
@ data provider ( name = " " )   iterator <  object[] >  swap allele data (  )  {   list <  object[] >  tests = new  array list <  >  (  )  ;  final  variant context vc base = new  variant context builder ( "test" "20" 10 10 ac )  . make (  )  ;  final  g
public double   (  )  throws io exception  {  return min value . get (  )  ;   }  
public static  string   (  inet socket address remote endpoint boolean use https )  {  return "http"  +   ( use https  ?  "s" : "" )   +  ": /  / " +  remote endpoint . get address (  )  . get host address (  )  +  ":" +  remote endpoint . get port (  )  +  cache   uri   path ;   }  
@ test public void   (  )  {   worker w =  schedulers . io (  )  . create worker (  )  ;   worker w2 =  schedulers . io (  )  . create worker (  )  ;  int m = 10000 ;  if  (  runtime . get runtime (  )  . available processors (  )   <  3 )   {  m = 1000 ;
@ override protected void   ( final  completable observer t )  {  source . subscribe ( new  ignore elements subscriber < t >  ( t )  )  ;   }  
public void   ( i2p session session  string message  throwable error )  {  if  (    log . should log (  log . debug )  )     log . debug ( "i2p error: "  +  message error )  ;  stop running (  )  ;   }  
public  string   (  )  {  return "buzz" ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   publish processor <  integer >  source =  publish processor . create (  )  ;   test observer <  integer >  to = source . single (  - 99 )  . take unt
@ override public void   (  )  {  request ( 3 )  ;   }  
@ override public  file visit result   (  path dir io exception exc )  throws io exception  {  try  {   files . delete if exists ( dir )  ;   }  catch  (  io exception e )   {   log . debug ( " plugin removal: could not delete:  {  } " dir )  ;  throw e ;
public void   (  date date )  {  this . date = date ;   }  
public double[]   (  string ds name )  throws  rrd exception  {  for  ( int ds index = 0 ;  ds index  <  get column count (  )  ;  ds index +  +  )   {  if  ( ds name . equals ( ds names[ds index] )  )   {  return get values ( ds index )  ;   }   }  throw new  rrd exception ( " datasource ["  +  ds name  +  "] not found" )  ;   }  
@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
@ override protected void   (  )  {  super . client ready (  )  ;  request ( new  mail status request (  )  )  ;  request ( new  activate mail cmd (  )  )  ;  start keep alive (  )  ;   }  
@ test ( expected exceptions =  unsupported operation exception . class )  public void   (  )  {  final  abstract illumina position file reader reader = new  mock position file reader ( "s   1   1   pos . txt" 0 0 null null )  ;  reader . remove (  )  ;  
@ override public  closeable iterator <  row >    (  )  {  if  ( extant iterator  !  =  null )   {  throw new  concurrent modification exception ( " only one iterator allowed at a time . " )  ;   }  extant iterator = new  the iterator (  )  ;  return exta
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . on error resume next (  flowable .  <  integer > never (  )  )  ;   }  
@ override public byte[]   ( byte[] response )  throws  sasl exception  {  if  ( is complete (  )  )   {  throw new  illegal state exception ( " authentication exchange already completed . " )  ;   }  complete = true ;  if  (  !  jive globals . get boolea
public static boolean   (  file src  file dst boolean overwrite existing boolean quiet )  {  if  ( dst . exists (  )  && dst . is directory (  )  )  dst = new  file ( dst src . get name (  )  )  ;  if  (  ! src . exists (  )  )  return false ;  if  ( dst . exists (  )  &&  ! overwrite existing )  return false ;   input stream in = null ;   output stream out = null ;  try  {  in = new  file input stream ( src )  ;  out = new  file output stream ( dst )  ;  int read ;  byte buf[] = new byte[4096] ;  while  (  ( read = in . read ( buf )  )   !  =   - 1 )   {  out . write ( buf 0 read )  ;   }  return true ;   }  catch  (  io exception ioe )   {  if  (  ! quiet )  ioe . print stack trace (  )  ;  return false ;   }  finally  {  try  {  if  ( in  !  =  null )  in . close (  )  ;   }  catch  (  io exception ioe )   {   }  try  {  if  ( out  !  =  null )  out . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   maybe . just ( 1 )  . flat map single ( null )  ;   }  
@ data provider (  )  public  object[][]   (  )  {  return new  object[][] { new  object[] {  arrays . as list (  )   arrays . as list (  )  }  new  object[] {  arrays . as list ( "female1" "female2" "female3" )   arrays . as list ( "male1" "male2" "male3
public   ( boolean rev )  {     rev = rev ;   }  
@ after test private void   (  )  {  io util . delete directory tree ( temp dir )  ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
private void   (  offer offer )  {   request queue backup = null ;  if  (  request queue .  overflow type . overflow   backup . equals ( queue . get overflow type (  )  )  )   {  backup = queue . get backup queue (  )  ;  if  ( backup  !  =  null &&  ! backup . get agent session list (  )  . contains available agents (  )  )   {  backup = null ;   }   }  else if  (  request queue .  overflow type . overflow   random . equals ( queue . get overflow type (  )  )  )   {  backup = get random queue (  )  ;   }  if  ( backup  !  =  null )   {  offer . cancel (  )  ;   user request request =  (  user request ) offer . get request (  )  ;  queue . remove request ( request )  ;   log . debug ( "rr  -   overflowing request: "  +  request  +  " to queue: " +  backup . get address (  )  )  ;  backup . add request ( request )  ;   }   }  
@ override public v   (  object key )  {  return cache . get ( key )  ;   }  
private void   (  )  {  if  (  !    processed )   {  if  (    valid )  process form (  )  ;     processed = true ;   }   }  
public void   (  )  throws io exception  {  sample = 0 ;  time remaining = duration ;   }  
public   (  hash dest )  {     inbound settings = new  tunnel pool settings ( dest true )  ;     outbound settings = new  tunnel pool settings ( dest false )  ;   }  
@ override public synchronized boolean   (  )  {  return this . socket acceptor  !  =  null && this . socket acceptor . get managed session count (  )   =  =  0 ;   }  
public  string   (  )  {  return protocol ;   }  
public int   (  )  {  return session list . size (  )  ;   }  
@ test public void   (  )  {   blocking multi observer <  integer >  bmo = new  blocking multi observer <  integer >  (  )  ;  bmo . dispose (  )  ;   disposable d =  disposables . empty (  )  ;  bmo . on subscribe ( d )  ;   }  
@ override public  string   (  object key )  {   string value ;  synchronized  ( this )   {  value = properties . remove ( key )  ;   collection <  string >  prop names = get property names (  )  ;  for  (   string name : prop names )   {  if  ( name . st
@ transaction default  something   ( int id  string name )  throws io exception  {  insert ( id name )  ;  throw new io exception ( "woof" )  ;   }  
public void   (  folder selector adapter .  folder row row )  {  final boolean add =  ! row . is selected (  )  ;  if  (  ! add )   {  return ;   }  m adapter . get count (  )  ;  for  ( int i = 0 ;  i  <  m adapter . get count (  )  ;  i +  +  )   {   object item = m adapter . get item ( i )  ;  if  ( item instanceof  folder row )   {   (  (  folder row ) item )  . set is selected ( false )  ;   }   }  m checked state . clear (  )  ;  row . set is selected ( add )  ;  m adapter . notify data set changed (  )  ;  m checked state . put ( row . get folder (  )  add )  ;  final  button button = m dialog . get button (  alert dialog . button   positive )  ;  button . set enabled ( true )  ;   }  
public void   (  packet packet )  {  if  ( packet instanceof iq )   {  iq iq packet =  ( iq ) packet ;   element child element =  ( iq packet )  . get child element (  )  ;   string namespace = null ;  if  ( child element  !  =  null )   {  namespace = child element . get namespaceuri (  )  ;   }  if  ( iq .  type . get  =  =  iq packet . get type (  )  )   {  if  ( "http: /  / jabber . org / protocol / disco#info" . equals ( namespace )  )   {  handle disco info ( iq packet )  ;   }  else if  ( "http: /  / jabber . org / protocol / disco#items" . equals ( namespace )  )   {  handle disco items ( iq packet )  ;   }  else if  ( "jabber:iq:version" . equals ( namespace )  )   {  iq reply = iq . create resultiq ( iq packet )  ;   element version = reply . set child element ( "query" "jabber:iq:version" )  ;  version . add element ( "name" )  . set text ( " client  control  manager" )  ;  version . add element ( "version" )  . set text ( "3 . 5" )  ;  send packet ( reply )  ;   }  else  {  iq reply = iq . create resultiq ( iq packet )  ;  reply . set error (  packet error .  condition . service   unavailable )  ;  send packet ( reply )  ;   }   }  else if  ( iq .  type . error  =  =  iq packet . get type (  )  || iq .  type . result  =  =  iq packet . get type (  )  )   {  if  ( "jabber:iq:version" . equals ( namespace )  )   {  handle client version ( iq packet )  ;   }   }  else  {  iq reply = iq . create resultiq ( iq packet )  ;  reply . set error (  packet error .  condition . service   unavailable )  ;  send packet ( reply )  ;   }   }   }  
@ override public int   (  )  {  return 600 ;   }  
public void   (  hash us )  {     us = us ;   }  
@ override public void   (  )  {  done = true ;  parent . drain (  )  ;   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
public static  type token <  ?  >    (  type type )  {  return new  simple type token <  >  ( type )  ;   }  
public static long   ( final long[] nums )  {  return nums[index of max ( nums ) ] ;   }  
private void   (  string text )  {  boolean error delivering = false ;   io buffer buffer =  io buffer . allocate ( text . length (  )  )  ;  buffer . set auto expand ( true )  ;  try  {  buffer . put ( text . get bytes (  standard charsets . utf   8 )  )  ;  if  ( flash client )   {  buffer . put (  ( byte ) '\0' )  ;   }  buffer . flip (  )  ;  io session lock . lock (  )  ;  try  {  io session . write ( buffer )  ;   }  finally  {  io session lock . unlock (  )  ;   }   }  catch  (   exception e )   {   log . debug ( " error delivering raw text:\n"  +  text e )  ;  error delivering = true ;   }  if  ( error delivering )   {  close (  )  ;   }   }  
void   ( int piece int begin int length  data loader loader )  {   message m = new  message ( piece begin length loader )  ;  add message ( m )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
@ override public final void   (  )  {  super . start running (  )  ;  startall (  )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . lift ( new  single operator <  integer  integer >  (  )  {  @ override public  single observer <  integer >  apply (  final  single observer <  ?  super  integer >  s )  throws  exception  {  return ne
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . observe on (  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert failure (  test exception . class )  ;   }  
@ override public void   (  )  throws io exception  {  digest bytes = digest . digest (  )  ;   }  
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
@ test public void   (  )  {   observable <  string >  obs =  observable . just ( "one" "two" "six" )  ;   observer <  boolean >  observer =  test helper . mock observer (  )  ;  obs . all ( new  predicate <  string >  (  )  {  @ override public boolean t
@ test public void   (  )  {  final sam read group record rg1 = new sam read group record ( "rg1" )  ;  final sam read group record rg2 = new sam read group record ( "rg2" )  ;  final  map <  string  file >  output map = new  hash map <  string  file >  (
public static  inet socket address   ( final  sel datagram channel channel final  string stun server final int port )  {  final  header[] h = new  header[1] ;  try  {  channel . set datagram listener ( new  datagram listener (  )  {  public void datagram received (   sel datagram channel channel   byte buffer buffer   socket address address )  {  final byte b[] = new byte[buffer . position (  ) ] ;  buffer . rewind (  )  ;  buffer . get ( b 0 b . length )  ;  h[0] = parse response ( b )  ;   }   }   )  ;  channel . send ( createstun change request (  )  new  inet socket address ( stun server port )  )  ;   thread . sleep ( 100 )  ;  for  ( int i = 0 ;  i  <  5 ;  i +  +  )   {   thread . sleep ( 100 )  ;  if  ( h[0]  !  =  null )   {  return h[0] . get address (  )  ;   }  if  ( i % 2  =  =  0 )   {  channel . send ( createstun change request (  )  new  inet socket address ( stun server port )  )  ;   }   }  return null ;   }  catch  (  io exception e )   {  return null ;   }  catch  (   interrupted exception e )   {  return null ;   }   }  
public void   ( boolean enabled )  {   jive globals . set property ( "plugin . email . listener . ssl"  boolean . to string ( enabled )  )  ;   }  
public synchronized void   (  )  throws io exception  {  try  {  unmap file (  )  ;   }  finally  {  super . close (  )  ;   }   }  
@ override public long   (  )  {  return 1 ;   }  
@ override public void   ( long n )  {  b . set ( true )  ;   }  
void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ test public void   (  )  {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  maybe subject <  integer >  cs =  maybe subject . create (  )  ;   test subscriber <  integer >  ts = pp . merge with ( cs )  . subscribe
@ override public void   (  object t )  {  o . set ( t )  ;  finish . count down (  )  ;   }  
@ override public void   (  )  throws io exception  {  original stream . flush (  )  ;   }  
@ after class public void   (  )  {  io util . delete directory tree ( output   data   path )  ;   }  
@ override public void   (  )  {  subscription . cancel (  )  ;   }  
public static void   ( boolean force private mix )  {   mix manager . force private mix = force private mix ;   }  
public static  command line program properties   (  class clazz )  {  return  (  command line program properties ) clazz . get annotation (  command line program properties . class )  ;   }  
public void   (  handler handler )  {  extension handlers . remove handler ( handler )  ;  if  ( handler . is started (  )  )   {  try  {  handler . stop (  )  ;   }  catch  (   exception e )   {   log . warn ( " unable to stop the handler that was removed:  {  } " handler e )  ;   }   }   }  
private  crosscheck metric   ( final  fingerprint result match result final  match results results final  fingerprint id details left pu details final  fingerprint id details right pu details final  crosscheck metric .  data type type )  {  final  crosscheck metric metric = new  crosscheck metric (  )  ;  metric . left   group   value = left pu details . group ;  metric . right   group   value = right pu details . group ;  metric . result = match result ;  metric . lod   score = results . getlod (  )  ;  metric . lod   score   tumor   normal = results . get lodtn (  )  ;  metric . lod   score   normal   tumor = results . get lodnt (  )  ;  metric . data   type = type ;  metric . left   run   barcode = left pu details . run barcode ;  metric . left   lane = left pu details . run lane ;  metric . left   molecular   barcode   sequence = left pu details . molecular barcode ;  metric . left   library = left pu details . library ;  metric . left   sample = left pu details . sample ;  metric . left   file = left pu details . file ;  metric . right   run   barcode = right pu details . run barcode ;  metric . right   lane = right pu details . run lane ;  metric . right   molecular   barcode   sequence = right pu details . molecular barcode ;  metric . right   library = right pu details . library ;  metric . right   sample = right pu details . sample ;  metric . right   file = right pu details . file ;  return metric ;   }  
public boolean   (  )  {  return is conference silenced ;   }  
public   ( i2p app context ctx long receive tunnel id  hash peer long next tunnel id  hash next hop long next msg id  session key layer key  session key iv key  session key reply key byte iv[] boolean is in gateway boolean is out endpoint )  {  byte buf[] = new byte[length] ;     data = buf ;   data helper . to long ( buf off   recv   tunnel 4 receive tunnel id )  ;   system . arraycopy ( peer . get data (  )  0 buf off   our   ident  hash . hash   length )  ;   data helper . to long ( buf off   send   tunnel 4 next tunnel id )  ;   system . arraycopy ( next hop . get data (  )  0 buf off   send   ident  hash . hash   length )  ;   system . arraycopy ( layer key . get data (  )  0 buf off   layer   key  session key . keysize   bytes )  ;   system . arraycopy ( iv key . get data (  )  0 buf off   iv   key  session key . keysize   bytes )  ;   system . arraycopy ( reply key . get data (  )  0 buf off   reply   key  session key . keysize   bytes )  ;   system . arraycopy ( iv 0 buf off   reply   iv iv   size )  ;  if  ( is in gateway )  buf[off   flag]| = flag   unrestricted   prev ;  else if  ( is out endpoint )  buf[off   flag]| = flag   outbound   endpoint ;  long truncated hour = ctx . clock (  )  . now (  )  ;  truncated hour -  = ctx . random (  )  . next int ( 90 * 1000 )  ;  truncated hour /  =  ( 60l * 60l * 1000l )  ;   data helper . to long ( buf off   req   time 4 truncated hour )  ;   data helper . to long ( buf off   send   msg   id 4 next msg id )  ;  ctx . random (  )  . next bytes ( buf off   send   msg   id  +  4 padding   size )  ;  byte wroteiv[] = read replyiv (  )  ;  if  (  !  data helper . eq ( iv wroteiv )  )  throw new  runtime exception ( "foo" )  ;   }  
protected static  string   ( final  variant context vc )  {  final  string[] sample name = new  string[1] ;  if  ( vc . get genotypes (  )  . stream (  )  . filter ( genotype  -  >  genotype . is het (  )  || genotype . is hom var (  )  )  . limit ( 2 )  . peek ( genotype  -  >  sample name[0] = genotype . get sample name (  )  )  . map to int ( genotype  -  >  genotype . is het (  )   ?  1 : 2 )  . reduce (  integer::sum )  . or else ( 0 )   =  =  1 )   {  return sample name[0] ;   }  else  {  return null ;   }   }  
public int   (  )  {  return test timeout ;   }  
public void   ( int direction )  throws sql exception  {  cstmt . set fetch direction ( direction )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . do on event ( new  bi consumer <  integer  throwable >  (  )  {  @ override public void accept (   integer v   throwable e )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  future subscriber <  integer >  fs = new  future subscriber <  integer >  (  )  ;  if  ( i % 3  =  =  0 )   {  fs . on subscribe ( new  
public int   (  )  {  synchronized  (    outbound messages )   {  return    concurrent messages allowed ;   }   }  
public boolean   (  )  {  if  ( ssdp uni sock  =  =  null )  return true ;  try  {  ssdp uni sock . close (  )  ;  ssdp uni sock = null ;   }  catch  (   exception e )   {   debug . warning ( e )  ;  return false ;   }  return true ;   }  
public  optional <  argument >    ( int position )  {  return  optional . of nullable ( positionals . get ( position )  )  ;   }  
@ test public void   (  )  {   observable . error ( new  test exception (  )  )  . do finally ( this )  . test (  )  . assert failure (  test exception . class )  ;  assert equals ( 1 calls )  ;   }  
@ test public void   (  )  throws  exception  {  final  unicast processor <  integer >  us =  unicast processor . create (  )  ;  final  count down latch cdl = new  count down latch ( 1 )  ;  us . observe on (  schedulers . single (  )  )  . subscribe ( n
public int   ( final sam record rec1 final sam record rec2 )  {  if  ( rec1 . get read unmapped flag (  )  )   {  if  ( rec2 . get read unmapped flag (  )  )  return 0 ;  else return 1 ;   }  else if  ( rec2 . get read unmapped flag (  )  )   {  return  - 1 ;   }  return  - sam utils . compare mapqs ( rec1 . get mapping quality (  )  rec2 . get mapping quality (  )  )  ;   }  
public static  string   (  intent intent )  {  return get string from intent ( intent account   name   param )  ;   }  
public static void   (  string infile  string outfile )  {   string encoded =  base64 . encode from file ( infile )  ;  java . io .  output stream out = null ;  try  {  out = new java . io .  buffered output stream ( new java . io .  file output stream ( outfile )  )  ;  out . write ( encoded . get bytes ( "us - ascii" )  )  ;   }  catch  (  java . io . io exception ex )   {  ex . print stack trace (  )  ;   }  finally  {  try  {  out . close (  )  ;   }  catch  (   exception ex )   {   }   }   }  
public long   (  )  {  return    started time ;   }  
@ override public  string   (  string str )  throws  encoding exception  {  str = str . trim (  )  ;  int l = str . index of ( ": " )  ;  if  ( l  <  =  0 || l  >  =  64 )  throw new  encoding exception ( "bad field - name: "  +  str )  ;  l +  = 2 ;  boo
@ override public void   ( final jaxb element source final t target )  {   transformer pooled object ;  try  {  pooled object = xslt resource pool . borrow object (  )  ;  try  {  pooled object . transform ( new jaxb source ( jaxb context source )  new  s
public void   (  list <  string >  usernames )  {  if  ( admin list  =  =  null )   {  admin list = new  array list <  >  (  )  ;   }  else  {  admin list . clear (  )  ;   }   list < jid >  admins = new  array list <  >  (  )  ;  for  (   string username : usernames )   {  admins . add ( xmpp server . get instance (  )  . createjid ( username null )  )  ;   }  admin list . add all ( admins )  ;  provider . set admins ( admins )  ;   }  
public void   (  action packet action )  {  this . packet action = packet action ;   }  
public void   ( int msgs )  {     lifetime dup message received . add and get ( msgs )  ;   }  
public int   (  )  {  return    status ;   }  
public static  class   (  string class name )  throws  class not found exception  {  return instance . load class ( class name )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  < r >  single < r >    ( final  single operator <  ?  extends r  ?  super t >  lift )  {   object helper . require non null ( lift "on lift is null" )  ;  return  rx jav
 genericgf poly[]   (  genericgf poly other )  {  if  (  ! field . equals ( other . field )  )   {  throw new  illegal argument exception ( " genericgf polys do not have same  genericgf field" )  ;   }  if  ( other . is zero (  )  )   {  throw new  illegal argument exception ( " divide by 0" )  ;   }   genericgf poly quotient = field . get zero (  )  ;   genericgf poly remainder = this ;  int denominator leading term = other . get coefficient ( other . get degree (  )  )  ;  int inverse denominator leading term = field . inverse ( denominator leading term )  ;  while  ( remainder . get degree (  )   >  =  other . get degree (  )  &&  ! remainder . is zero (  )  )   {  int degree difference = remainder . get degree (  )   -  other . get degree (  )  ;  int scale = field . multiply ( remainder . get coefficient ( remainder . get degree (  )  )  inverse denominator leading term )  ;   genericgf poly term = other . multiply by monomial ( degree difference scale )  ;   genericgf poly iteration quotient = field . build monomial ( degree difference scale )  ;  quotient = quotient . add or subtract ( iteration quotient )  ;  remainder = remainder . add or subtract ( term )  ;   }  return new  genericgf poly[] { quotient remainder }  ;   }  
@ override public  observable <  integer >    (  boolean t1 )  {  return  observable . just ( 2 )  . delay ( 500  time unit . milliseconds )  ;   }  
public void   (  )  {  this . enabled = false ;  stopstun service (  )  ;  stop local (  )  ;   }  
public void   ( jid componentjid )  {  main interceptor . remove transport ( componentjid . to string (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  byte[] temp = null ;   byte array output stream baos = new  byte array output stream (  )  ;   data helper . write long ( baos 4 42 )  ;  temp = baos . to byte array (  )  ;  long l ;   byte array input str
public   (  string message  throwable cause )  {  super ( message cause )  ;   }  
public   (  reader reader int length )  {  this . value = reader ;  this . length = length ;   }  
public boolean   (  )  {  return has publicip ;   }  
@ test public void   (  )  {   observable . range ( 1 10 )  . switch map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  if  ( v % 2  =  = 
@ override public boolean   (  )  {  return true ;   }  
public static synchronized  sms service   (  )  {  if  ( instance  =  =  null )   {  instance = new  sms service (  )  ;   }  return instance ;   }  
public void   ( final int num to skip )  {  bb iterator . skip elements ( num to skip * 2 )  ;   }  
@ benchmark public void   (  input input )  throws  interrupted exception  {  input . observable . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  {  return  flowab
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  thread t0 =  thread . current thread (  )  ;   worker w =  schedulers . computation (  )  . create worker (  )  ;  try  {  w . schedule ( 
private  input stream   (  )  {  return new  input stream (  )  {  @ override public synchronized int read (  )  throws io exception  {  do read (  )  ;  if  (  ! in appbb . has remaining (  )  )   {  return  - 1 ;   }  return in appbb . get (  )  ;   }  @ override public synchronized int read (  byte[] bytes  int off  int len )  throws io exception  {  if  ( in appbb . position (  )   =  =  0 )   {  do read (  )  ;   }  else  {  in appbb . flip (  )  ;   }  len =  math . min ( len in appbb . remaining (  )  )  ;  if  ( len  =  =  0 )   {  return  - 1 ;   }  in appbb . get ( bytes off len )  ;  if  ( in appbb . has remaining (  )  )   {  in appbb . compact (  )  ;   }  else  {  in appbb . clear (  )  ;   }  return len ;   }   }   ;   }  
static int   (  byte matrix matrix )  {  int num dark cells = 0 ;  byte[][] array = matrix . get array (  )  ;  int width = matrix . get width (  )  ;  int height = matrix . get height (  )  ;  for  ( int y = 0 ;  y  <  height ;  y +  +  )   {  byte[] arrayy = array[y] ;  for  ( int x = 0 ;  x  <  width ;  x +  +  )   {  if  ( arrayy[x]  =  =  1 )   {  num dark cells +  +  ;   }   }   }  int num total cells = matrix . get height (  )  * matrix . get width (  )  ;  int five percent variances =  math . abs ( num dark cells * 2  -  num total cells )  * 10  /  num total cells ;  return five percent variances * n4 ;   }  
private boolean   (  object shell command boolean consume output boolean wait for exit status )  {   process process ;   string name = null ;  try  {  if  ( shell command instanceof  string )   {  name =  (  string ) shell command ;  if  ( debug )   system . out . println ( " shell command exec \""  +  name  +  "\" consume ?  " +  consume output +  " wait ?  " +  wait for exit status )  ;  process =  runtime . get runtime (  )  . exec ( name )  ;   }  else if  ( shell command instanceof  string[] )   {   string[] arr =  (  string[] ) shell command ;  if  ( debug )   {  name =  arrays . to string ( arr )  ;   system . out . println ( " shell command exec \""  +  name  +  "\" consume ?  " +  consume output +  " wait ?  " +  wait for exit status )  ;   }  process =  runtime . get runtime (  )  . exec ( arr )  ;   }  else  {  throw new  class cast exception ( "shell command must be a  string or a  string[]" )  ;   }  if  ( consume output )   {   thread process stderr consumer = new  stream consumer ( process . get error stream (  )  )  ;  process stderr consumer . start (  )  ;   thread process stdout consumer = new  stream consumer ( process . get input stream (  )  )  ;  process stdout consumer . start (  )  ;   }  else  {     error stream = process . get error stream (  )  ;     input stream = process . get input stream (  )  ;     output stream = process . get output stream (  )  ;   thread process stderr reader = new  stream reader (    error stream )  ;  process stderr reader . start (  )  ;   thread process stdin writer = new  stream writer (    output stream )  ;  process stdin writer . start (  )  ;   thread process stdout reader = new  stream reader (    input stream )  ;  process stdout reader . start (  )  ;   }  if  ( wait for exit status )   {  if  ( debug )   system . out . println ( " shell command waiting for \""  +  name  +  '\"' )  ;  try  {  process . wait for (  )  ;   }  catch  (   interrupted exception e )   {  if  ( debug )   {   system . out . println ( " shell command exception waiting for \""  +  name  +  '\"' )  ;  e . print stack trace (  )  ;   }  if  (  ! consume output )  kill streams (  )  ;  return false ;   }  if  (  ! consume output )  kill streams (  )  ;  if  ( debug )   system . out . println ( " shell command exit value is "  +  process . exit value (  )   +  " for \"" +  name +  '\"' )  ;  if  ( process . exit value (  )   >  0 )  return false ;   }   }  catch  (  io exception e )   {  if  ( debug )   {   system . out . println ( " shell command execute exception for \""  +  name  +  '\"' )  ;  e . print stack trace (  )  ;   }  return false ;   }  return true ;   }  
@ override public void   (  )  {  parent . inner complete ( index )  ;   }  
public  blocklist   (  )  {  return    blocklist ;   }  
@ override public  string   (  )  {  return  interval list tools . class . get simple name (  )  ;   }  
public v   ( int start k key )  {  for  ( int i =  math . min ( start levels . length  -  1 )  ;  i  >  =  0 ;  i -  -  )   {  if  (  ( levels[i]  !  =  null )  &&  ( levels[i] . key (  )  . compare to ( key )   <  =  0 )  )   {  return levels[i] . get ( i key )  ;   }   }  return bottom . get ( key )  ;   }  
public long   (  )  {  return    expiration ;   }  
public void   ( final sam record record )  {  if  ( record . get not primary alignment flag (  )  )  return ;  final boolean mapped in pair = record . get read paired flag (  )  &&  ! record . get read unmapped flag (  )  &&  ! record . get mate unmapped flag (  ) &&  ! record . get supplementary alignment flag (  )  ;  final byte[] base qualities = record . get base qualities (  )  ;  int bases aligned in record = 0 ;  if  (  ! record . get read unmapped flag (  )  )   {  for  (  final  alignment block block : record . get alignment blocks (  )  )   {  bases aligned in record +  = block . get length (  )  ;   }   }  if  (  ! record . get supplementary alignment flag (  )  )   {  this . metrics . total   reads +  +  ;  if  (  ! record . get read fails vendor quality check flag (  )  )   {  this . metrics . pf   reads +  +  ;  if  (  ! record . get duplicate read flag (  )  )   {  this . metrics . pf   unique   reads +  +  ;  if  (  ! record . get read unmapped flag (  )  )   {  this . metrics . pf   uq   reads   aligned +  +  ;   }   }   }   }  if  ( record . get read fails vendor quality check flag (  )  )  return ;  if  (  ! record . get supplementary alignment flag (  )  )  this . metrics . pf   bases +  = record . get read length (  )  ;  if  (  ! record . get read unmapped flag (  )  )   {  this . metrics . pf   bases   aligned +  = bases aligned in record ;  if  (  ! record . get duplicate read flag (  )  )   {  this . metrics . pf   uq   bases   aligned +  = bases aligned in record ;   }   }  if  ( record . get read unmapped flag (  )  )  return ;  final  interval read = new  interval ( record . get reference name (  )  record . get alignment start (  )  record . get alignment end (  )  )  ;  final  collection <  interval >  targets = target detector . get overlaps ( read )  ;  final  collection <  interval >  probes = probe detector . get overlaps ( read )  ;  if  (  ! record . get supplementary alignment flag (  )  && record . get read paired flag (  )  && record . get first of pair flag (  ) &&  ! record . get read unmapped flag (  ) &&  ! record . get mate unmapped flag (  ) &&  ! probes . is empty (  )  )   {   +  + this . metrics . pf   selected   pairs ;  if  (  ! record . get duplicate read flag (  )  )   +  + this . metrics . pf   selected   unique   pairs ;   }   {  final int mapped bases = bases aligned in record ;  int on bait bases = 0 ;  if  (  ! probes . is empty (  )  )   {  for  (  final  interval bait : probes )   {  for  (  final  alignment block block : record . get alignment blocks (  )  )   {  final int end =  coord math . get end ( block . get reference start (  )  block . get length (  )  )  ;  for  ( int pos = block . get reference start (  )  ;  pos  <  =  end ;   +  + pos )   {  if  ( pos  >  =  bait . get start (  )  && pos  <  =  bait . get end (  )  )   +  + on bait bases ;   }   }   }  this . metrics . on   probe   bases +  = on bait bases ;  this . metrics . near   probe   bases +  =  ( mapped bases  -  on bait bases )  ;   }  else  {  this . metrics . off   probe   bases +  = mapped bases ;   }   }  if  ( record . get duplicate read flag (  )  )   {  this . metrics . pct   exc   dupe +  = bases aligned in record ;  return ;   }  if  ( this . mapq filter . filter out ( record )  )  return ;  final sam record rec ;  if  ( clip overlapping reads )   {  final int num overlapping bases to clip = sam utils . get num overlapping aligned bases to clip ( record )  ;  rec = sam utils . clip overlapping aligned bases ( record num overlapping bases to clip no side effects )  ;  metrics . pct   exc   overlap +  = num overlapping bases to clip ;  if  ( rec . get read unmapped flag (  )  )  return ;   }  else  {  rec = record ;   }  final  set <  interval >  covered targets = new  hash set <  >  (  )  ;  for  (  final  alignment block block : rec . get alignment blocks (  )  )   {  final int length = block . get length (  )  ;  final int ref start = block . get reference start (  )  ;  final int read start = block . get read start (  )  ;  for  ( int offset = 0 ;  offset  <  length ;   +  + offset )   {  final int ref pos = ref start  +  offset ;  final int read pos = read start  +  offset ;  final int qual = base qualities[read pos  -  1] ;  if  ( qual  <  =  2 )   {  metrics . pct   exc   baseq +  +  ;  continue ;   }  boolean is on target = false ;  for  (  final  interval target : targets )   {  if  ( ref pos  >  =  target . get start (  )  && ref pos  <  =  target . get end (  )  )   {  final int target offset = ref pos  -  target . get start (  )  ;  if  ( qual  >  =  minimum base quality )   {   +  + metrics . on   target   bases ;  if  ( mapped in pair )   +  + metrics . on   target   from   pair   bases ;  final  coverage high quality coverage = high quality coverage by target . get ( target )  ;  high quality coverage . add base ( target offset )  ;  if  (  ! covered targets . contains ( target )  )   {  high quality coverage . increment read count (  )  ;  covered targets . add ( target )  ;  is on target = true ;   }   }  else  {  this . metrics . pct   exc   baseq +  +  ;   }  unfiltered coverage by target . get ( target )  . add base ( target offset )  ;  if  ( unfiltered coverage by target . get ( target )  . get depths (  ) [target offset]  <  =  coverage cap )   {  baseq histogram array[qual] +  +  ;   }   }   }  if  (  ! is on target )  this . metrics . pct   exc   off   target +  +  ;   }   }   }  
public synchronized static void   (  )  {  i2p app context ctx = i2p app context . get global context (  )  ;  properties = new  properties (  )  ;   input stream iv = null ;  try  {  iv =  config . class . get resource as stream ( " / susimail . properties" )  ;  properties . load ( iv )  ;   }  catch  (  io exception e )   {   log log = ctx . log manager (  )  . get log (  config . class )  ;  log . error ( " could not open web - inf / classes / susimail . properties  ( possibly in jar ) " e )  ;   }  finally  {  if  ( iv  !  =  null )  try  {  iv . close (  )  ;   }  catch  (  io exception ioe )   {   }   }  try  {   file cfg = new  file ( i2p app context . get global context (  )  . get config dir (  )  "susimail . config" )  ;  if  ( cfg . exists (  )  )   {  config = new  ordered properties (  )  ;   data helper . load props ( config cfg )  ;   }   }  catch  (  io exception e )   {   log log = ctx . log manager (  )  . get log (  config . class )  ;  log . error ( " could not open susimail . config" e )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable processor <  integer >  subject =  publish processor .  <  integer > create (  )  . to serialized (  )  ;  subject . on error ( null )  ;  subject . blocking subscribe
@ override public boolean   (  string t )  {  throw e ;   }  
protected  string[]   (  )  {  if  ( total   reads   in   input  <  0 )   {  return new  string[] {  string . format ( " cannot set total   reads   in   input to a number less than 1  found %d . " total   reads   in   input )  }  ;   }  if  ( split   to   n   files  <  =  1 && split   to   n   reads  <  =  1 )   {  return new  string[] {  string . format ( " one of split   to   n   files or split   to   n   reads must be greater than 0 .  "  +  " found split   to   n   files is %d and split   to   n   reads is %d . " split   to   n   files split   to   n   reads )  }  ;   }  return null ;   }  
@ override public void   (  throwable e )  {   concat map delay error observer <  ?  r >  p = parent ;  if  ( p . error . add throwable ( e )  )   {  if  (  ! p . till the end )   {  p . d . dispose (  )  ;   }  p . active = false ;  p . drain (  )  ;   }
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
public   (  )  {  super . filter = new  array list <  filter >  (  )  ;   }  
@ override public void   ( t t )  {  if  ( not skipping )   {  actual . on next ( t )  ;   }  else  {  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . dispose (  )  ;  actual
@post public  response   ( @ default value ( "conference" )  @ query param ( "servicename" )   string service name muc room entity muc room entity )  throws muc service exception  {  muc room controller . get instance (  )  . create chat room ( service na
public  list <  integer >    (  )  {  final  list <  integer >  ret = new  array list <  integer >  ( tiles . size (  )  )  ;  for  (  final  tile index record rec : tiles )  ret . add ( rec . tile )  ;  return ret ;   }  
@ test public void   (  )  {  final  atomic reference <  throwable >  received exception = new  atomic reference <  throwable >  (  )  ;   subscription s = mock (  subscription . class )  ;   test flowable w = new  test flowable ( s "one" )  ;   function 
@ test public void   (  )  {   flowable . range ( 1 3 )  . flat map iterable (  functions . just function (  arrays . as list ( 1 )  )  1 )  . take ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
@ test public void   (  )  {   parallel flowable test . check subscriber count (  flowable . range ( 1 5 )  . parallel (  )  . concat map (  functions . just function (  flowable . just ( 1 )  )  )  )  ;   }  
public  lease set   (  )  {  return    lease set ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
@ override public boolean   ( jid jid )  {  return users cache . contains key ( jid . to string (  )  )  || is anonymous route ( jid )  ;   }  
public   (  router context ctx )  {  super (  )  ;     ctx = ctx ;  add from properties (  )  ;   }  
public static  version   ( int dimension )  throws  format exception  {  if  ( dimension % 4  !  =  1 )   {  throw  format exception . get format instance (  )  ;   }  try  {  return get version for number (  ( dimension  -  17 )   /  4 )  ;   }  catch  (   illegal argument exception ignored )   {  throw  format exception . get format instance (  )  ;   }   }  
@ test public void   (  )  {   behavior processor <  string >  processor =  behavior processor . create default ( "default" )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  processor . subscribe ( observer )  ;  processor 
boolean   (  partial piece pp )  {  int piece = pp . get piece (  )  ;  byte[] hash ;  try  {  hash = pp . get hash (  )  ;   }  catch  (  io exception ioe )   {     log . warn ( " error checking" ioe )  ;  return false ;   }  for  ( int i = 0 ;  i  <  20 ;  i +  +  )   {  if  ( hash[i]  !  =  piece   hashes[20 * piece  +  i] )  return false ;   }  return true ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on error ( t )  ;   }  
public   (  single source < t >  source  observable source < u >  other )  {  this . source = source ;  this . other = other ;   }  
public  argument list   (  )  {   argument list argument list = new  argument list (  )  ;   node argument list node = get action node (  )  . get node (  argument list . elem   name )  ;  if  ( argument list node  =  =  null )  return argument list ;  int node cnt = argument list node . getn nodes (  )  ;  for  ( int n = 0 ;  n  <  node cnt ;  n +  +  )   {   node node = argument list node . get node ( n )  ;  if  (  argument . is argument node ( node )   =  =  false )  continue ;   argument argument = new  argument ( get service node (  )  node )  ;  argument list . add ( argument )  ;   }  return argument list ;   }  
@ data provider ( name = " " )  public  object[][] bam files sources (  )  {  return new  object[][] {  { na12891   r1 na12891   r2 0 }   { na12892   r1 na12892   r2 0 }   { na12891   r1 na12892   r1 0 }   { na12892   r2 na12891   r2 0 }   { na12892   r2 
public boolean   (  )  {  return    may disconnect ;   }  
public boolean   (  )  {  return should log ( debug )  ;   }  
@ test public void   (  )  {  assert equals ( " empty consumer"  functions . empty   consumer . to string (  )  )  ;   }  
@ override public void   ( t value )  {  d =  disposable helper . disposed ;   single observer <  ?  super t >  a = actual ;  if  ( a  !  =  null )   {  actual = null ;  a . on success ( value )  ;   }   }  
protected   ( i2p socket manager mgr  properties props sam stream receiver recv int listenport )  throws io exception   data format exception  sam exception  {  this . recv = recv ;     log = i2p app context . get global context (  )  . log manager (  )  . get log ( get class (  )  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "sam stream session instantiated" )  ;  can create = true ;   properties allprops =  (  properties )  system . get properties (  )  . clone (  )  ;  allprops . put all ( props )  ;     is own session = false ;  socket mgr = mgr ;  socket mgr . add disconnect listener ( new  disconnect listener (  )  )  ;  force flush =  boolean . parse boolean ( allprops . get property ( prop   force   flush default   force   flush )  )  ;  listen protocol = i2p session . proto   streaming ;  listen port = listenport ;  server = null ;   }  
public   (  string name byte[] source array )  {  this . source array =  array utilities . null safe copy ( source array )  ;  this . name = name ;   }  
@ override public final void   (  )  {  lazy set ( fused   consumed )  ;  value = null ;   }  
public boolean   (  media info media info )  {  try  {  get media info ( media info . get sample rate (  )  media info . get channels (  )  media info . get encoding (  )  )  ;   }  catch  (  io exception e )   {  return false ;   }  return true ;   }  
void   (  )  {  if  ( m parser  !  =  null )   {  m parser . destroy responses (  )  ;   }   }  
@ test public void   (  )  {   observable <  string >  o1 =  observable . just ( "one" "two" )  ;   observable <  string >  o2 =  observable . just ( "three" "four" )  ;   observable <  string >  o3 =  observable . just ( "five" "six" )  ;   observable < 
protected void   (  string s )  {     mgr . notify progress ( this s )  ;   }  
private static void   (  string host int port  string con options  string name )  {     log . info ( "\n\n testing a name lookup  ( should come back with 'naming reply result = ok value = some name ) \n\n\n" )  ;  try  {   socket s = new  socket ( host port )  ;   output stream out = s . get output stream (  )  ;  out . write (  data helper . getascii ( "hello version min = 1 . 0 max = 1 . 0\n" )  )  ;   buffered reader reader = new  buffered reader ( new  input stream reader ( s . get input stream (  )  )  )  ;   string line = reader . read line (  )  ;     log . debug ( "line read for valid version: "  +  line )  ;   string req = "session create style = stream destination = test naming "  +  con options  +  "\n" ;  out . write (  data helper . getascii ( req )  )  ;  line = reader . read line (  )  ;     log . debug ( " response to creating the session with destination test naming: "  +  line )  ;     log . debug ( " the above should contain session status result = ok\n\n\n" )  ;   string lookup = "naming lookup name = "  +  name  +  "\n" ;  out . write (  data helper . getascii ( lookup )  )  ;  line = reader . read line (  )  ;     log . info ( " response from the lookup for ["  +  name  +  "]: " +  line )  ;     log . debug ( " the abouve should be a naming reply" )  ;  try  {   thread . sleep ( 5 * 1000 )  ;   }  catch  (   interrupted exception ie )   {   }  s . close (  )  ;   }  catch  (   exception e )   {     log . error ( " error testing for valid version" e )  ;   }   }  
public db history   (  )  {  return    db history ;   }  
public int   (  )  {  return porta ;   }  
@ test public void   (  )  throws io exception  {  final  file input = new  file ( test   data   dir "summary   alignment   bisulfite   test . sam" )  ;  final  file reference = new  file ( test   data   dir "summary   alignment   stats   test . fasta" ) 
@ test public void   (  )  {  final  disposable d =  disposables . empty (  )  ;   maybe .  <  integer > create ( new  maybe on subscribe <  integer >  (  )  {  @ override public void subscribe (   maybe emitter <  integer >  e )  throws  exception  {  e 
@ override public int   (  )  throws io exception  {  int num bytes = 0 ;  synchronized  (    data lock )   {  if  (    locally closed )  throw new io exception ( " input stream closed" )  ;  throw any error (  )  ;  for  ( int i = 0 ;  i  <     ready dat
void   (  )  {  first . cancel (  )  ;  first . clear (  )  ;  second . cancel (  )  ;  second . clear (  )  ;   }  
public int   (  )  {  return port ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( null new  bi function <  integer  object  object >  (  )  {  @ override public  object apply (   integer a   object b )  {  return 1 ;   }   }   )  ;   }  
@ test public void   (  )  {   observable .  <  integer > just ( 1 )  . hide (  )  . concat map eager ( new  function <  integer  observable source <  integer >  >  (  )  {  @ override public  observable source <  integer >  apply (   integer v )  throws 
@ override public void   (  )  {  workgroup lock . read lock (  )  . lock (  )  ;  try  {  for  (   workgroup group : workgroups . values (  )  )   {  try  {   chat search manager . get instance for ( group )  . update index ( false )  ;   }  catch  (  io
@ before public void   (  )  {  fs = new  future subscriber <  integer >  (  )  ;   }  
  ( final  rrd db parent db final  data importer reader final int ds index )  throws io exception   rrd exception  {  this ( parent db null )  ;  ds name . set ( reader . get ds name ( ds index )  )  ;  m   primitive ds name = null ;  ds type . set ( reader . get ds type ( ds index )  )  ;  m   primitive ds type = null ;  heartbeat . set ( reader . get heartbeat ( ds index )  )  ;  min value . set ( reader . get min value ( ds index )  )  ;  max value . set ( reader . get max value ( ds index )  )  ;  last value . set ( reader . get last value ( ds index )  )  ;  accum value . set ( reader . get accum value ( ds index )  )  ;  nan seconds . set ( reader . get nan seconds ( ds index )  )  ;   }  
static void   (  cyclic barrier cb )  {  try  {  cb . await (  )  ;   }  catch  (   interrupted exception ex )   {  ex . print stack trace (  )  ;   }  catch  (   broken barrier exception ex )   {  ex . print stack trace (  )  ;   }   }  
@ check return value @ non null public static  < t >  behavior processor < t >    ( t default value )  {   object helper . require non null ( default value "default value is null" )  ;  return new  behavior processor < t >  ( default value )  ;   }  
private void   (  conference member old member )  {   mix manager mix manager = old member . get mix manager (  )  ;  synchronized  ( mix manager )   {   array list mix descriptors = mix manager . get mix descriptors (  )  ;  for  ( int i = 0 ;  i  <  mix descriptors . size (  )  ;  i +  +  )   {   mix descriptor md =  (  mix descriptor ) mix descriptors . get ( i )  ;  if  ( md . is private mix (  )   =  =  false )   {  continue ;   }   member receiver mr =  (  member receiver ) md . get mix data source (  )  ;  if  ( mr . get member (  )   =  =  old member )   {  continue ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( "pre - migrate member "  +  old member  +  " has pm for " +  mr )  ;   logger . println ( "pre - migrate member "  +  old member  +  " mix descriptors " +  old member . get mix descriptors (  )  )  ;   }  synchronized  ( mix map )   {  apply private mix ( mr . get member (  )  md . get spatial values (  )  )  ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " call "  +  cp  +  "  set private mix for " +  mr +  " to " +  md )  ;   }   }  for  ( int i = 0 ;  i  <  mix descriptors . size (  )  ;  i +  +  )   {   mix descriptor md =  (  mix descriptor ) mix descriptors . get ( i )  ;  if  ( md . is private mix (  )   =  =  false )   {  continue ;   }   member receiver mr =  (  member receiver ) md . get mix data source (  )  ;  if  ( mr . get member (  )   =  =  old member )   {  continue ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( old member  +  " removing pm for "  +  mr . get member (  )  )  ;   }  old member . remove private mix ( mr . get member (  )  )  ;   }   }   }  
@ test ( data provider = "ok files" )  public void   ( final  string sam filename )  throws io exception  {  final  file sam file = new  file ( test   data   dir sam filename )  ;  final  file pair1 file = new temp fastq file ( "pair1" " . fastq . gz" )  
public void   ( boolean persistent )  {  this . persistent = persistent ;   }  
public final boolean   ( byte addr[] )  {  if  ( addr  =  =  null )  return false ;  if  ( is publicly routable ( addr )  &&  ( addr . length  !  =  16 ||    havei pv6 address )  )  return true ;  return allow local (  )  ;   }  
@ override protected int   (  )  {  return write sam text (  system . out )  ;   }  
@ inject public   (  configuration service configuration service  health check service health check service  tracer tracer @ value (  repose spring properties . core . config   root )   string config root @ value (  repose spring properties . core . repos
@ override public void   (  string old name  string new name )  throws  group already exists exception  {  throw new  unsupported operation exception ( " cannot modify read - only groups" )  ;   }  
@ override public void   (  )  {  ts . request ( 3 )  ;   }  
ntcp connection   ( ntcp connection con )  {  ntcp connection removed = null ;   router identity ident = con . get remote peer (  )  ;  if  ( ident  !  =  null )   {  synchronized  (    con lock )   {  removed =    con by ident . remove ( ident . calculate hash (  )  )  ;   }   }  return removed ;   }  
public int   (  )  {  int active peers = 0 ;  long hide before =    context . clock (  )  . now (  )   -  6 * 60 * 60* 1000 ;  get read lock (  )  ;  try  {  for  (   peer profile profile :    failing peers . values (  )  )   {  if  ( profile . get last send successful (  )   >  =  hide before )  active peers +  +  ;  else if  ( profile . get last heard from (  )   >  =  hide before )  active peers +  +  ;   }  for  (   peer profile profile :    not failing peers . values (  )  )   {  if  ( profile . get last send successful (  )   >  =  hide before )  active peers +  +  ;  else if  ( profile . get last heard from (  )   >  =  hide before )  active peers +  +  ;   }   }  finally  {  release read lock (  )  ;   }  return active peers ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish processor <  integer >  pp =  publish processor .  <  integer > create (  )  ;   test subscriber <  flowable <  integer >  >  ts = pp . window ( 5  time unit .
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . msn . password" "kraken" )  ;   }  
public void   (  integer integer )  {  a . debug (  ( new  string builder (  )  )  . append ( " stream " )  . append ( integer )  . append ( " deleted" )  . to string (  )  )  ;  d . remove ( integer )  ;   }  
@ override public boolean   (  object o )  {  if  ( o  =  =  null )   {  return false ;   }  if  (  !  ( o instanceof  news entry )  )   {  return false ;   }   news entry e =  (  news entry ) o ;  return this . compare to ( e )   =  =  0 ;   }  
@ test public void   (  )  {   async subject <  string >  subject =  async subject . create (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "one" )  ;  subject . on 
public boolean   (  string stat name )  {  return    context . is router context (  )  &&  !    context . get boolean property ( prop   stat   full )  ;   }  
public void   (  string s )  {  if  ( s  !  =  null )   {  try  {     config . set post check time (  integer . parse int ( s . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
@ test public void   (  )  throws io exception  {  processor . process (  )  ;  verify ( servlet response )  . set status ( eq ( 200 )  )  ;  for  (   header header : headers )   {  verify ( servlet response )  . add header ( header . get name (  )  heade
private void   (  string property boolean enabled )  {  if  (  ( log   debug   enabled )  . equals ( property )  )   {   log . set debug enabled ( enabled )  ;   }   }  
private   (  router context ctx  hop config cfg )  {  super ( ctx )  ;     cfg = cfg ;   }  
public boolean   (  throwable t )  {  return  exception helper . add throwable ( this t )  ;   }  
static void   (  string builder e  rx method m  string wrong pre  string word  string base type name )  {  int jdx = 0 ;  int idx ;  for  (  ;   ;   )   {  idx = m . javadoc . index of ( wrong pre  +  " "  +  word jdx )  ;  if  ( idx  >  =  0 )   {  e . append ( "java . lang .  runtime exception: a / an typo " )  . append ( word )  . append ( "\r\n at io . reactivex . " )  . append ( base type name )  . append ( "  ( " )  . append ( base type name )  . append ( " . java:" )  . append ( m . javadoc line  +  line number ( m . javadoc idx )   -  1 )  . append ( " ) \r\n\r\n" )  ;  jdx = idx  +  6 ;   }  else  {  break ;   }   }  jdx = 0 ;  for  (  ;   ;   )   {  idx = m . javadoc . index of ( wrong pre  +  "  { @link "  +  word jdx )  ;  if  ( idx  >  =  0 )   {  e . append ( "java . lang .  runtime exception: a / an typo " )  . append ( word )  . append ( "\r\n at io . reactivex . " )  . append ( base type name )  . append ( "  ( " )  . append ( base type name )  . append ( " . java:" )  . append ( m . javadoc line  +  line number ( m . javadoc idx )   -  1 )  . append ( " ) \r\n\r\n" )  ;  jdx = idx  +  6 ;   }  else  {  break ;   }   }  jdx = 0 ;  for  (  ;   ;   )   {  idx = m . javadoc . index of ( wrong pre  +  "  { @linkplain "  +  word jdx )  ;  if  ( idx  >  =  0 )   {  e . append ( "java . lang .  runtime exception: a / an typo " )  . append ( word )  . append ( "\r\n at io . reactivex . " )  . append ( base type name )  . append ( "  ( " )  . append ( base type name )  . append ( " . java:" )  . append ( m . javadoc line  +  line number ( m . javadoc idx )   -  1 )  . append ( " ) \r\n\r\n" )  ;  jdx = idx  +  6 ;   }  else  {  break ;   }   }  jdx = 0 ;  for  (  ;   ;   )   {  idx = m . javadoc . index of ( wrong pre  +  "  { @code "  +  word jdx )  ;  if  ( idx  >  =  0 )   {  e . append ( "java . lang .  runtime exception: a / an typo " )  . append ( word )  . append ( "\r\n at io . reactivex . " )  . append ( base type name )  . append ( "  ( " )  . append ( base type name )  . append ( " . java:" )  . append ( m . javadoc line  +  line number ( m . javadoc idx )   -  1 )  . append ( " ) \r\n\r\n" )  ;  jdx = idx  +  6 ;   }  else  {  break ;   }   }   string javadoc2 = m . javadoc . replace ( "\n" " " )  . replace ( "\r" " " )  . replace ( " * " " " )  . replace all ( "\\s + " " " )  ;  int kk = 0 ;  for  (  ;   ;   )   {  int jj = javadoc2 . index of ( " { @" kk )  ;  if  ( jj  <  0 )   {  break ;   }  int nn = javadoc2 . index of ( " " jj  +  2 )  ;  int mm = javadoc2 . index of ( " } " jj  +  2 )  ;  javadoc2 = javadoc2 . substring ( 0 jj )   +  javadoc2 . substring ( nn  +  1 mm )   +  javadoc2 . substring ( mm  +  1 )  ;  kk = mm  +  1 ;   }  jdx = 0 ;  for  (  ;   ;   )   {  idx = javadoc2 . index of ( wrong pre  +  " "  +  word jdx )  ;  if  ( idx  >  =  0 )   {  e . append ( "java . lang .  runtime exception: a / an typo " )  . append ( word )  . append ( "\r\n at io . reactivex . " )  . append ( base type name )  . append ( "  ( " )  . append ( base type name )  . append ( " . java:" )  . append ( m . javadoc line )  . append ( " ) \r\n\r\n" )  ;  jdx = idx  +  wrong pre . length (  )   +  1 +  word . length (  )  ;   }  else  {  break ;   }   }   }  
@ before public void   (  )  {  logger ref = mock (  logger . class )  ;  cause = new  illegal state exception (  )  ;   }  
public void   ( http socket value )  {  http socket = value ;   }  
@ test @ suppress warnings ( "unchecked" )  public void   (  )  {   flowable . never (  )  . buffer ( new  callable <  publisher <  long >  >  (  )  {  int count ;  @ override public  publisher <  long >  call (  )  throws  exception  {  if  ( count +  + 
 simple plain queue < t >    (  )  {   simple plain queue < t >  q = queue ;  if  ( q  =  =  null )   {  q = new  spsc array queue < t >  ( buffer size (  )  )  ;  queue = q ;   }  return q ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   debounce timed subscriber <  integer >  sub = new  debounce timed subscriber <  integer >  ( ts 1  time unit . seconds new  test scheduler (  ) 
public  string   (  )  {  return version ;   }  
@ test ( timeout = 5000 expected =  null pointer exception . class )  public void   (  )  {   completable c =  completable . merge (  arrays . as list ( normal . completable  (  completable ) null )  )  ;  c . blocking await (  )  ;   }  
public  string   (  )  {  return " synchronize  keys to  disk" ;   }  
@ override public boolean   (  )  {  return s . is disposed (  )  ;   }  
public  map <  string  string >    (  )  {  return headers ;   }  
@ override public int   (  )  {  int size = 0 ;  size +  =  cache sizes . size of object (  )  ;  size +  =  cache sizes . size of string ( initiator )  ;  size +  =  cache sizes . size of string ( target )  ;  size +  =  cache sizes . size of string ( se
public void   (  output stream out )  throws io exception  {  if  (    renderer  =  =  null ||    db  =  =  null )  throw new io exception ( " no rrd  check logs for previous errors" )  ;     renderer . render ( out )  ;   }  
public void   ( long t )  {  this . last fetched = t ;   }  
public   (  single source < t >  source  single operator <  ?  extends r  ?  super t >  on lift )  {  this . source = source ;  this . on lift = on lift ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "bb" "ccc" "dddd" )  ;   observable <  map <  integer  string >  >  mapped = source . to map ( length func )  . to observable (  )  ;   map <  integer  string >  expe
public int   (  )  throws io exception  {  return delegate . read int (  )  ;   }  
public  certificate   ( int effort )  {   certificate c = set cert type (  certificate . certificate   type   hashcash )  ;  long begin =  system . current time millis (  )  ;   system . out . println ( " starting hashcash generation now .  .  . " )  ;   string resource = this . dest . get public key (  )  . to base64 (  )   +  this . dest . get signing public key (  )  . to base64 (  )  ;   hash cash hc ;  try  {  hc =  hash cash . mint cash ( resource effort )  ;   }  catch  (   no such algorithm exception e )   {  return null ;   }   system . out . println ( " generation took: "  +   data helper . format duration (  system . current time millis (  )   -  begin )  )  ;   system . out . println ( " full  hashcash is: "  +  hc )  ;   string hcs = hc . to string (  )  ;  int end1 = 0 ;  for  ( int i = 0 ;  i  <  3 ;  i +  +  )   {  end1 = 1  +  hcs . index of ( ':' end1 )  ;  if  ( end1  <  0 )   {   system . out . println ( " bad hashcash" )  ;  return null ;   }   }  int start2 = hcs . index of ( ':' end1 )  ;  if  ( start2  <  0 )   {   system . out . println ( " bad hashcash" )  ;  return null ;   }  hcs = hcs . substring ( 0 end1 )   +  hcs . substring ( start2 )  ;   system . out . println ( " short  hashcash is: "  +  hcs )  ;  c . set payload (  data helper . getutf8 ( hcs )  )  ;  return c ;   }  
@ override public boolean   (  file transfer transfer )  throws  file transfer rejected exception  {  if  ( transfer  !  =  null )   {  fire file transfer start ( transfer . get sessionid (  )  false )  ;   string streamid = transfer . get sessionid (  ) 
public int   (  )  {  if  (  ! is initialized )  throw new  illegal argument exception ( "not initialized" )  ;  if  ( complete )  return 0 ;  return total chunks  -  have . count (  )  ;   }  
public byte[]   (  dest entry de )  {   byte array output stream baos = new  byte array output stream ( 1024 )  ;  int sz = de . dest list  !  =  null  ?  de . dest list . size (  )  : 1 ;  try  {  baos . write (  ( byte ) sz )  ;  for  ( int i = 0 ;  i  <  sz ;  i +  +  )   {   properties p ;   destination d ;  if  ( i  =  =  0 )   {  p = de . props ;  d = de . dest ;   }  else  {  p = de . props list . get ( i )  ;  d = de . dest list . get ( i )  ;   }  try  {  write properties ( baos p )  ;   }  catch  (   data format exception dfe )   {  log error ( "db  write  fail  -  properties too big ? " dfe )  ;  baos . write ( new byte[2] )  ;   }  d . write bytes ( baos )  ;   }   }  catch  (  io exception ioe )   {  log error ( "db  write  fail" ioe )  ;   }  catch  (   data format exception dfe )   {  log error ( "db  write  fail" dfe )  ;   }  return baos . to byte array (  )  ;   }  
@ test public void   (  )  {   publish subject <  observable <  integer >  >  ps =  publish subject . create (  )  ;   test observer <  integer >  to =  observable . switch on next delay error ( ps 2 )  . test (  )  ;  ps . on next (  observable . just ( 
@ override public  reference sequence   ( final  string contig final long start final long stop )  {  return null ;   }  
@ override public boolean   ( boolean forced )  {  if  (  ! open )  return true ;  super . close ( forced )  ;  if  (  ! forced &&  ! finished )   {  l . log ( " there are still pings running ! " )  ;  return false ;   }  l . log ( " closing pinger "  +  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   flowable . just ( 1 )  . concat map eager ( to just  flowable . buffer size (  )  0 )  ;   }  
@ override public void   (  )  {  try  {  observer . on error ( new  error ( "failure" )  )  ;   }  catch  (   throwable e )   {  exception . set ( e )  ;   }  latch . count down (  )  ;   }  
 < t extends  comparable >  sorted set < t >    (  set < t >  in )  {  return new  tree set <  >  ( in )  ;   }  
public long   (  )  {  try  {  return inf . get bytes read (  )  ;   }  catch  (   runtime exception e )   {  return 0 ;   }   }  
@ override public void   ( int number  worker callback callback )  {   object helper . verify positive ( number "number  >  0 required" )  ;  pool . get (  )  . create workers ( number callback )  ;   }  
public void   (  string call end treatment )  {  this . call end treatment = call end treatment ;   }  
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  @ suppress warnings ( "unchecked" )  public static  < t >  flowable < t >    ( final  publisher <  ?  extends t >  sour
@ override @ suppress warnings (  { "unchecked" "rawtypes" }  )  public void   ( t t )  {   switch map single observer < r >  current = inner . get (  )  ;  if  ( current  !  =  null )   {  current . dispose (  )  ;   }   single source <  ?  extends r >  
public void   (  )  {  if  ( get and increment (  )   !  =  0 )   {  return ;   }  final  observer <  ?  super t >  child = this . child ;  int missed = 1 ;  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  int s = state . size (  )  ;  if  ( s  !  =  0 )   {   object[] b = current buffer ;  if  ( b  =  =  null )   {  b = state . head (  )  ;  current buffer = b ;   }  final int n = b . length  -  1 ;  int j = index ;  int k = current index in buffer ;  while  ( j  <  s )   {  if  ( cancelled )   {  return ;   }  if  ( k  =  =  n )   {  b =  (  object[] ) b[n] ;  k = 0 ;   }   object o = b[k] ;  if  (  notification lite . accept ( o child )  )   {  return ;   }  k +  +  ;  j +  +  ;   }  if  ( cancelled )   {  return ;   }  index = j ;  current index in buffer = k ;  current buffer = b ;   }  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }  
public boolean   (  )  {  if  ( rtp datagram socket  =  =  null )   {  return true ;   }  return rtp datagram socket . is closed (  )  ;   }  
public rtcp packet[]   (  byte encrypted bytes[] )  {   encryption mode    var0 = get encryption mode (  )  ;  if  (    var0  !  =  null  ?     var0 . equals (  encryption mode .  null )  :    var0  =  =   encryption mode .  null )   {   log . info ( "decryptrtcp no encryption found" )  ;  return rtcp packet . parse bytes ( encrypted bytes )  ;   }  if  (  array extensions . get length ( encrypted bytes )  . int value (  )   <  12  +     rtcp integrity size . int value (  )  )   {   log . info ( "decryptrtcp packet too small" )  ;  return null ;   }   byte buffer[] =  bit assistant . sub array ( encrypted bytes  integer . value of ( 0 )   integer . value of (  array extensions . get length ( encrypted bytes )  . int value (  )   -     rtcp integrity size . int value (  )  )  )  ;   byte buffer2[] =  bit assistant . sub array ( encrypted bytes  integer . value of (  array extensions . get length ( encrypted bytes )  . int value (  )   -     rtcp integrity size . int value (  )  )     rtcp integrity size )  ;   byte buffer4[] =  bit assistant . sub array (  crypto . get hmac sha1 (    rtcp decryption auth buffer )   integer . value of ( 0 )     rtcp integrity size )  ;  if  (  !  bit assistant . sequences are equal ( buffer2 buffer4 )  . boolean value (  )  )   {   log . info ( "decryptrtcp sequences  are not  equal" )  ;  return null ;   }   long ssrc =  bit assistant . to long from integer network ( buffer  integer . value of ( 4 )  )  ;   byte buffer5[] =  bit assistant . sub array ( buffer  integer . value of (  array extensions . get length ( buffer )  . int value (  )   -  4 )  )  ;  buffer5[0] = new  byte (  ( byte )  ( buffer5[0] . byte value (  )  & 0x7f )  )  ;   integer num2 =  bit assistant . to integer network ( buffer5  integer . value of ( 0 )  )  ;   byte data[] =  bit assistant . sub array ( buffer  integer . value of ( 8 )   integer . value of (  array extensions . get length ( buffer )  . int value (  )   -  12 )  )  ;   byte buffer7[] ;  if  (    rtcp decryption  =  =  null )  buffer7 = data ;  else buffer7 =    rtcp decryption . decrypt ( data ssrc new  long (  ( new  integer ( num2 . int value (  )  )  )  . long value (  )  )  )  ;   array list list = new  array list (  )  ;   array list extensions . add range ( list  bit assistant . sub array ( buffer  integer . value of ( 0 )   integer . value of ( 8 )  )  )  ;   array list extensions . add range ( list buffer7 )  ;  return rtcp packet . parse bytes (  (  byte[] ) list . to array ( new  byte[0] )  )  ;   }  
@ override public void   ( i binder binder )  {  m service = i email service .  stub . as interface ( binder )  ;   }  
@ override public final void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  schedule (  )  ;   }   }  
public int   ( int tunnel )  {  return get property ( tunnel  tunnel controller . prop   max   total   conns   day 0 )  ;   }  
protected  string[]   (  )  {  try  {  final boolean is bam or sam file = is bam or sam ( io util . get path ( input )  )  ;  if  (  ! is bam or sam file && ignore   read   groups )   {  return new  string[] { " the parameter ignore   read   groups can only be used with bam / sam inputs . " }  ;   }  if  ( is bam or sam file && observed   sample   alias  !  =  null )   {  return new  string[] { " the parameter observed   sample   alias can only be used with a vcf input . " }  ;   }   }  catch  (  io exception e )   {  e . print stack trace (  )  ;   }  return super . custom command line validation (  )  ;   }  
@ override void   (  )  {  if  ( wip . get and increment (  )   =  =  0 )   {  do  {  boolean d = done ;  emit (  )  ;  if  ( d )   {  actual . on complete (  )  ;  return ;   }   }  while  ( wip . decrement and get (  )   !  =  0 )  ;   }   }  
@ override protected void   (  handle handle )  {  handle . execute ( "create table something  ( id serial  name varchar ( 50 )   create   time timestamp default now (  )  ) " )  ;   }  
@ override public void   (  throwable e )  {  parent . inner error ( e index )  ;   }  
private  optional <  string >    ( final  list <  filter >  filters final  object input object final  string input file variable )  {  if  ( filters . contains ( filter )  && input object  =  =  null )  return  optional . of (  string . format ( "%s must be specified when using filter = %s  but it was null . " input file variable filter )  )  ;  if  (  ! filters . contains ( filter )  && input object  !  =  null )  return  optional . of (  string . format ( "%s may only be specified when using filter from %s  filter value: %s  %s value: %s" input file variable  string . join ( "  " filters . stream (  )  . map (  enum::to string )  . collect (  collectors . to list (  )  )  )  filter input file variable input object )  )  ;  return  optional . empty (  )  ;   }  
@ test public void   (  )  {  final  test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . just ( 1 )  . flat map maybe ( new  function <  integer  maybe source <  object >  >  (  )  {  @ override public  maybe source <  o
  (  handle handle )  {  this . handle = handle ;   }  
void   (  subscriber <  ?  super r >  a  iterator <  ?  extends r >  iterator )  {  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  r v ;  try  {  v = iterator . next (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  a . on error ( ex )  ;  return ;   }  a . on next ( v )  ;  if  ( cancelled )   {  return ;   }  boolean b ;  try  {  b = iterator . has next (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  a . on error ( ex )  ;  return ;   }  if  (  ! b )   {  a . on complete (  )  ;  return ;   }   }   }  
private void   (  array list bad channels )  {  while  ( bad channels . size (  )   >  0 )   {   datagram channel dc =  (  datagram channel ) bad channels . remove ( 0 )  ;  try  {  dc . close (  )  ;  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( " closed datagram channel "  +  dc )  ;   }   }  catch  (  io exception e )   {   logger . println ( " unable to close channel !  "  +  e . get message (  )  )  ;   }   }   }  
protected void   (  )  throws io exception  {   string encoding = format . get encoding (  )  ;  if  (  ! format . is suppress declaration (  )  )   {  if  ( encoding . equals ( "utf8" )  )   {  writer . write ( " <  ? xml version = \"1 . 0\"" )  ;  if  (  ! format . is omit encoding (  )  )   {  writer . write ( " encoding = \"utf - 8\"" )  ;   }  writer . write ( " ?  > " )  ;   }  else  {  writer . write ( " <  ? xml version = \"1 . 0\"" )  ;  if  (  ! format . is omit encoding (  )  )   {  writer . write ( " encoding = \""  +  encoding  +  "\"" )  ;   }  writer . write ( " ?  > " )  ;   }  if  ( format . is new line after declaration (  )  )   {  println (  )  ;   }   }   }  
public int   (  )  {  return  jive globals . get int property ( "xmpp . session . detach . timeout" 10 * 60 * 1000 )  ;   }  
@ test ( data provider = " " expected exceptions =  illegal argument exception . class )  public void check sample map failures data ( final  file input sample map final  file second input sample map )  throws io exception  {   file metrics =  file . crea
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . start with (  (  integer ) null )  ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  public void   (  string i2cp host int i2cp port  map opts )  {  if  ( i2cp host  !  =  null )     i2cp host = i2cp host ;  if  ( i2cp port  >  0 )     i2cp port = i2cp port ;  if  ( opts  !  =  null ) 
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   maybe <  integer >  source = pp . single element (  )  . cache (  )  ;  assert false ( pp . has subscribers (  )  )  ;  assert not null (  (  (  mayb
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . on error return item ( 1 )  . test (  )  . assert result ( 1 )  ;   }  
public boolean   (  )  {  return dtmf suppression ;   }  
public int   (  )  {  return current limit amount ;   }  
@ override public boolean   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
public void   (  )  {  m pairs . add ( new  transaction (  transaction . action   client   close )  )  ;   }  
@ override public void   (  grouped unicast < k v >  value )  {  evicted groups . offer ( value )  ;   }  
private void   (  observable <  event >  es  atomic integer subscribe counter )  throws  interrupted exception  {  final  atomic integer event counter = new  atomic integer (  )  ;  final  atomic integer group counter = new  atomic integer (  )  ;  final  count down latch latch = new  count down latch ( 1 )  ;  es . group by ( new  function <  event  integer >  (  )  {  @ override public  integer apply (   event e )  {  return e . source ;   }   }   )  . take ( 1 )  . flat map ( new  function <  grouped observable <  integer  event >   observable <  string >  >  (  )  {  @ override public  observable <  string >  apply (   grouped observable <  integer  event >  event grouped observable )  {   system . out . println ( "test unsubscribe  =  >   grouped observable  key: "  +  event grouped observable . get key (  )  )  ;  group counter . increment and get (  )  ;  return event grouped observable . take ( 20 )  . map ( new  function <  event  string >  (  )  {  @ override public  string apply (   event event )  {  return "test unsubscribe  =  >   source: "  +  event . source  +  "  message: " +  event . message ;   }   }   )  ;   }   }   )  . subscribe ( new  default observer <  string >  (  )  {  @ override public void on complete (  )  {  latch . count down (  )  ;   }  @ override public void on error (   throwable e )  {  e . print stack trace (  )  ;  latch . count down (  )  ;   }  @ override public void on next (   string output message )  {   system . out . println ( output message )  ;  event counter . increment and get (  )  ;   }   }   )  ;  if  (  ! latch . await ( 2000  time unit . milliseconds )  )   {  fail ( "timed out so likely did not unsubscribe correctly" )  ;   }  assert equals ( 1 subscribe counter . get (  )  )  ;  assert equals ( 1 group counter . get (  )  )  ;  assert equals ( 20 event counter . get (  )  )  ;   }  
@ override protected void   (  observer <  ?  super r >  s )  {   group join disposable < t left t right t left end t right end r >  parent = new  group join disposable < t left t right t left end t right end r >  ( s left end right end result selector ) 
public jid   (  string username )  {  if  ( username  !  =  null &&  ! username . is empty (  )  )   {  try  {  if  ( username . contains ( "@" )  )   {  jid jid = new jid ( username )  ;  if  ( user manager . is registered user ( jid )  )   {  return jid ;   }   }  else if  ( user manager . is registered user ( username )  )   {  return xmpp server . createjid ( username null )  ;   }   }  catch  (   illegal argument exception e )   {   }   }  return null ;   }  
public  tunnel pool settings   (  hash client )  {  return null ;   }  
public void   ( jid roomjid jid user  string nickname )  {  if  (  cluster manager . is senior cluster member (  )  )   {  conversation manager . joined group conversation ( roomjid user nickname new  date (  )  )  ;   }  else  {   conversation events queue events queue = conversation manager . get conversation events queue (  )  ;  events queue . add group chat event ( conversation manager . get room conversation key ( roomjid )   conversation event . occupant joined ( roomjid user nickname new  date (  )  )  )  ;   }   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   test subscriber <  list <  integer >  >  ts = pp . parallel (  )  . reduce ( new  callable <  list <  integer >  >  (  )  {  @ override public  list 
@ override protected  string[]   (  )  {  if  ( min   q  <  0 )  return new  string[] { "min   q must be  >  =  0" }  ;  if  ( max   q  >  sam utils . max   phred   score )  return new  string[] { "max   q must be  <  =  "  +  sam utils . max   phred   sc
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer subs count = new  atomic integer ( 0 )  ;  final  test observer <  string >  to = new  test observer <  string >  (  )  ;   observable source <  string >  on subscribe = ne
@ override public void   (  )  {  synchronized  ( this )   {  buffer = null ;   }  s . cancel (  )  ;  w . dispose (  )  ;   }  
private boolean   ( final  file vcf )  {  return  tribble . index file ( vcf )  . exists (  )  ||  tribble . tabix index file ( vcf )  . exists (  )  ;   }  
@ test public void   (  )  {  final  list <  integer >  expected =  arrays . as list ( 1 )  ;  for  ( int i = 0 ;  i  <  100000 ;  i +  +  )   {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . subsc
public int   (  )  {  return    max conns per day ;   }  
@ test public void   (  )  {   atomic integer c = new  atomic integer (  )  ;  final  atomic integer total received = new  atomic integer (  )  ;  final  atomic integer batches = new  atomic integer (  )  ;  final  atomic integer received = new  atomic in
@ override protected void   (  )  {     sender = new  inbound sender (    context    config . get config ( 0 )  )  ;     receiver = new  inbound test receiver (    config )  ;   }  
public int   (  )  throws sql exception  {  return stmt . get fetch direction (  )  ;   }  
@ override public  reference sequence   (  )  {  if  (  ! done )   {  done = true ;  return get sequence ( record . get sequence name (  )  )  ;   }  return null ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . from future ( new  future task <  object >  (  functions . empty   runnable null )  1  time unit . seconds null )  ;   }  
double   (  )  {  return get font height ( fonttag   legend )  * legend   leading ;   }  
public void   (  )  {     ignore = true ;     events . clear (  )  ;   }  
public  destination   (  )  {  return    remote destination ;   }  
@ override public  observable <  long >    (  )  {  return  rx java plugins . on assembly ( new  observable count < t >  ( source )  )  ;   }  
@ override protected void   ( long offset byte[] b )  {  int pos =  ( int ) offset ;  for  ( int i = 0 ;  i  <  b . length ;  i +  +  )   {  buffer[pos +  + ] = b[i] ;   }   }  
public  skip span < k v >    ( int start k key int[] search )  {  for  ( int i =  math . min ( start levels . length  -  1 )  ;  i  >  =  0 ;  i -  -  )   {  if  (  ( levels[i]  !  =  null )  &&  ( levels[i] . key (  )  . compare to ( key )   <  =  0 )  )   {  return levels[i] . get span ( i key search )  ;   }   }  return bottom . get span ( key search )  ;   }  
public i2p session   (  )  {  return    session ;   }  
public byte[]   (  )  {  byte iv[] = new byte[iv   size] ;   system . arraycopy (    data off   reply   iv iv 0 iv   size )  ;  return iv ;   }  
@ override public  set <  session tracking mode >    (  )  {  return context . get default session tracking modes (  )  ;   }  
public char[]   (  )  {  return password ;   }  
public static int   (  input stream in byte target[] int offset int length )  throws io exception  {  int cur = 0 ;  while  ( cur  <  length )   {  int num read = in . read ( target offset  +  cur length  -  cur )  ;  if  ( num read  =  =   - 1 )   {  throw new eof exception ( "eof after reading "  +  cur  +  " bytes of " +  length +  " byte value" )  ;   }  cur +  = num read ;   }  return offset  +  cur ;   }  
public  component session   ( byte[] nodeid jid address )  {  return new  remote component session ( nodeid address )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   single . from future ( null 1  time unit . seconds )  ;   }  
public synchronized void   (  string[] args )  {  change state ( stopped )  ;   }  
@ override public  string   (  )  {  return "presence" ;   }  
@ test public void   (  )  {  final  test observer <  object >  to = new  test observer <  object >  (  )  ;   future task <  object >  ft = new  future task <  object >  ( new  runnable (  )  {  @ override public void run (  )  {  to . cancel (  )  ;   }
@ test public void   (  )  {   flowable <  string >  other =  flowable . just ( "a" "b" "c" )  ;   flowable <  string >  source = underlying subject . timeout ( timeout time   unit test scheduler other )  ;   subscriber <  string >  observer =  test helpe
public  string   (  string s  string p int n )  {  return  messages . get string ( n s p    context )  ;   }  
public  string   (  )  {  return this . get class (  )  . get name (  )  ;   }  
public static boolean   (  )  {  return common mix default ;   }  
private  string   (  string host )  {  return  host interface . get hosturl ( host gethttp port (  )  get event suburi (  )  )  ;   }  
@ override public void   (  )  {  accepting mode . run (  )  ;  shutdown (  )  ;   }  
private static double   ( byte[] array int pointer )  {  double r = 0 . 0 ;  for  ( int i = 0 ;  i  <  8 ;  i +  +  )   {  r +  = unsigned byte to short ( array[pointer  +  i] )  *  math . pow ( 2  ( 3  -  i )  * 8 )  ;   }  return r ;   }  
@ override protected byte[]   (  )  throws i2cp message exception  io exception  {  if  (    session id  =  =  null ||    session config  =  =  null )  throw new i2cp message exception ( " unable to write out the message as there is not enough data" )  ; 
@ test public void   (  )  {   unicast processor <  integer >  ap =  unicast processor . create ( false )  ;  ap . on next ( 1 )  ;  ap . on error ( new  runtime exception (  )  )  ;   test subscriber <  integer >  ts =  subscriber fusion . new test (  qu
public boolean   (  )  {  return "true" . equals ( get properties (  )  . get property ( "chatbot . enabled" )  )  ;   }  
@ test public void   (  )  {   flowable . just ( 1 2 3 )  . last element (  )  ;   }  
public void   (  )  throws  exception  {  expect messaging exception ( "" )  ;  expect messaging exception ( "\r" )  ;  expect messaging exception ( "\r\n" )  ;  expect messaging exception ( "*\r\n" )  ;  expect messaging exception ( "1\r\n" )  ;  expect messaging exception ( "* \r\n" )  ;  expect messaging exception ( "1 \r\n" )  ;  expect messaging exception ( "* a  ( \r\n" )  ;  expect messaging exception ( "* a  ) \r\n" )  ;  expect messaging exception ( "* a  (  (  ) \r\n" )  ;  expect messaging exception ( "* a  (  )  ) \r\n" )  ;  expect messaging exception ( "* a [\r\n" )  ;  expect messaging exception ( "* a ]\r\n" )  ;  expect messaging exception ( "* a [[]\r\n" )  ;  expect messaging exception ( "* a []]\r\n" )  ;  expect messaging exception ( "* a  ( [ ) ]\r\n" )  ;  expect messaging exception ( "* a" )  ;  expect messaging exception ( "*  { 3 } " )  ;  expect messaging exception ( "*  { 3 } \r\nab" )  ;   }  
@ test public void   (  )  {  final  atomic long requested = new  atomic long (  long . min   value )  ;  assert equals (  long . min   value  backpressure helper . add cancel ( requested 1 )  )  ;  assert equals (  long . min   value  backpressure helper
@ test public void   (  )  throws io exception  sax exception  {  mock request . add header ( accept application   xml   value )  ;  http servlet request wrapper = new  http servlet request wrapper ( mock request )  ;  http servlet response wrapper = new 
@ override public void   (  )  throws  exception  {  throw new  test exception (  )  ;   }  
@ before public void   (  )  {  handle = db rule . open handle (  )  ;  handle . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  handle . create update ( "insert into something  ( id  name )  values  ( 2
private void   (  byte value[] )  {     local key = value ;   }  
public static void   (  string[] args )  {  try  {  setupconn ( args )  ;  chatter ( args )  ;   }  catch  (   unknown host exception ex )   {   logger . get logger (  main . class . get name (  )  )  . log (  level . severe null ex )  ;   }  catch  (  io exception ex )   {   logger . get logger (  main . class . get name (  )  )  . log (  level . severe null ex )  ;   }  try  {  deleteconn ( args )  ;   }  catch  (   unknown host exception ex )   {   logger . get logger (  main . class . get name (  )  )  . log (  level . severe null ex )  ;   }  catch  (  io exception ex )   {   logger . get logger (  main . class . get name (  )  )  . log (  level . severe null ex )  ;   }  catch  (   runtime exception ex )   {   logger . get logger (  main . class . get name (  )  )  . log (  level . severe null ex )  ;   }   }  
@ override public boolean   (  person fruit t1 )  {  return ppf . person . id  =  =  t1 . person id ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . range ( 1 6 )  . do on request ( this )  . limit ( 5 )  . test ( 0l )  ;  assert equals ( 0 requests . size (  )  )  ;  ts . request ( 1 )  ;  ts . assert value ( 1 )  ;  ts . r
@ override public int   (  )  {  return context . get effective minor version (  )  ;   }  
@ override public boolean   (  )  {  return subscribers . get (  )  . length  !  =  0 ;   }  
@ test public void   (  )  throws  unknown host exception  {  final  get get command = new  get ( "object - key" new  inet socket address (  inet address . get by address ( new byte[] { 127 0 0 1 }  )  1000 )  null false )  ;   assert . assert equals ( " 
public byte[]   (  destination peer int from port int to port long timeout ms byte[] payload )  {   ping request req = new  ping request ( null )  ;  long id = assign ping id ( req )  ;   packet local packet = new  packet local (    context peer    session )  ;  packet . set send stream id ( id )  ;  packet . set flag (  packet . flag   echo |  packet . flag   no   ack |  packet . flag   signature   included )  ;  packet . set optional from (  )  ;  packet . set local port ( from port )  ;  packet . set remote port ( to port )  ;  packet . set payload ( new  byte array ( payload )  )  ;  if  ( timeout ms  >  max   ping   timeout )  timeout ms = max   ping   timeout ;  if  (    log . should log (  log . info )  )   {     log . info (  string . format ( "about to ping %s port %d from port %d timeout = %d payload = %d" peer . calculate hash (  )  . to string (  )  to port from port timeout ms payload . length )  )  ;   }     outbound queue . enqueue ( packet )  ;  packet . release payload (  )  ;  synchronized  ( req )   {  if  (  ! req . pong received (  )  )  try  {  req . wait ( timeout ms )  ;   }  catch  (   interrupted exception ie )   {   }   }     pending pings . remove ( id )  ;  boolean ok = req . pong received (  )  ;  if  (  ! ok )  return null ;   byte array ba = req . get payload (  )  ;  if  ( ba  =  =  null )  return new byte[0] ;  byte[] rv = new byte[ba . get valid (  ) ] ;   system . arraycopy ( ba ba . get offset (  )  rv 0 ba . get valid (  )  )  ;  return rv ;   }  
boolean   ( boolean d boolean empty  subscriber <  ?  super t >  a boolean delay error )  {  if  ( cancelled . get (  )  )   {  queue . clear (  )  ;  return true ;   }  if  ( d )   {  if  ( delay error )   {  if  ( empty )   {   throwable e = error ;  if  ( e  !  =  null )   {  a . on error ( e )  ;   }  else  {  a . on complete (  )  ;   }  return true ;   }   }  else  {   throwable e = error ;  if  ( e  !  =  null )   {  queue . clear (  )  ;  a . on error ( e )  ;  return true ;   }  else if  ( empty )   {  a . on complete (  )  ;  return true ;   }   }   }  return false ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  single < t >    ( long index )  {  if  ( index  <  0 )   {  throw new  index out of bounds exception ( "index  >  =  0 required but it was "  +  index )  ;   }  return  
@ xml element ( name = "group" )  @ json property ( value = "groups" )  public  list <  group entity >    (  )  {  return groups ;   }  
@ test public void   (  )  {   publish processor <  integer >  pp =  publish processor . create (  )  ;   flowable . range ( 1 10 )  . subscribe ( pp )  ;  assert true ( pp . has complete (  )  )  ;   publish processor <  integer >  pp2 =  publish process
@ override public boolean   (  )  {  return parser . has next (  )  ;   }  
@ test public void   (  )  {   maybe . error ( new  test exception (  )  )  . subscribe on (  schedulers . single (  )  )  . test (  )  . await done ( 5  time unit . seconds )  . assert failure (  test exception . class )  ;   }  
@ override public  bundle   ( final  host auth compat host auth com )  throws  remote exception  {  set task ( new  proxy task (  )  {  @ override public void run (  )  throws  remote exception  {  m return = m service . validate ( host auth com )  ;   } 
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  test subscriber <  integer >  ts1 = new  test subscriber <  integer >  ( 0l )  ;   flowable . just ( 1 )  . publish ( new  function <  f
@ override protected xmpp packet reader   (  )  {  xmpp packet reader parser = new xmpp packet reader (  )  ;  factory . set namespace aware ( true )  ;  parser . setxpp factory ( factory )  ;  return parser ;   }  
@ override public int   (  java spec version that )  {  if  ( that  =  =  null )   {  return 1 ;   }  int result =  integer . compare ( get major (  )  that . get major (  )  )  ;  if  ( result  =  =  0 )   {  result =  integer . compare ( get minor (  ) 
public static  < t u >  function < t  publisher < t >  >    ( final  function <  ?  super t  ?  extends  publisher < u >  >  item delay )  {  return new  item delay function < t u >  ( item delay )  ;   }  
@ test ( expected =  datastore operation exception . class )  public void   (  )  throws  exception  {  final int ttl = 30 ;  final  patch patch command = new  patch (  time unit . minutes new  test patch (  )  ttl "somekey" new  inet socket address (  in
void   (  )  {  if  ( get and increment (  )   =  =  0 )   {  int missed = 1 ;  for  (  ;   ;   )   {  if  ( sa . is cancelled (  )  )   {  return ;   }  long p = produced ;  if  ( p  !  =  0l )   {  produced = 0l ;  sa . produced ( p )  ;   }  source . subscribe ( this )  ;  missed = add and get (  - missed )  ;  if  ( missed  =  =  0 )   {  break ;   }   }   }   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   test scheduler scheduler = new  test scheduler (  )  ;   test observer <  integer >  to = new  observable <  integer >  (  )  {  @ override p
public void   ( int octet count )  {  rtcp data[24] =  ( byte )  (  ( octet count  >  >  24 )  & 0xff )  ;  rtcp data[25] =  ( byte )  (  ( octet count  >  >  16 )  & 0xff )  ;  rtcp data[26] =  ( byte )  (  ( octet count  >  >  8 )  & 0xff )  ;  rtcp data[27] =  ( byte )  ( octet count  >  >  0xff )  ;   }  
public void   (  destination dest  string reason int severity )  {  if  (    dead )  return ;     context . job queue (  )  . add job ( new  report abuse job (    context this dest reason severity )  )  ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable .  <  integer > empty (  )  . first element (  )  ;  o . subscribe ( wm )  ;   in order in order = in order ( wm )  ;  in order . verify ( wm times ( 1 )  )  . on complete (  )  ;  in orde
  (  observer <  ?  super t >  actual t[] array )  {  this . actual = actual ;  this . array = array ;   }  
@ test ( data provider = " " )  public void test default min group count ( final  string test name final int num duplicates final int num read pairs examined )  throws io exception  {  final  file input = new  file ( test   data   dir test name )  ;  fina
@ override public  void   (  )  {  return null ;   }  
@ override public void   (  event <  application deployment event  list <  string >  >  e )  {  log . info ( " {  } : {  }   -  -   application collection has been modified .   application that changed:  {  } " cluster id node id e . payload (  )  )  ;   
private void   (  )  {   statistic active session statistic = new i18n statistic ( sessions   key  monitoring constants . name  statistic .  type . count )  {  public double sample (  )  {  return  session manager . get instance (  )  . get user sessions count ( false )  ;   }  public boolean is partial sample (  )  {  return false ;   }   }   ;  statistics manager . add statistic ( sessions   key active session statistic )  ;   }  
  ( final  string five prime final  string three prime )  {  this . three prime = three prime ;  this . three prime bytes =  string util . string to bytes ( three prime )  ;  this . five prime = five prime ;  this . five prime read order =  sequence util . reverse complement ( five prime )  ;  this . five prime bytes =  string util . string to bytes ( five prime )  ;  this . five prime read order bytes =  string util . string to bytes ( five prime read order )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . flat map ( new  function <  integer  publisher <  integer >  >  (  )  {  @ override public  publisher <  integer >  apply (   integer v )  {  return just1 ;   }   }   nu
@ override protected void   (  subscriber <  ?  super r >  s )  {   group join subscription < t left t right t left end t right end r >  parent = new  group join subscription < t left t right t left end t right end r >  ( s left end right end result selec
private void   ( final  gc object gc obj final sam record rec final  string group final byte[] gc final byte[] ref bases )  {  if  (  ! rec . get read paired flag (  )  || rec . get first of pair flag (  )  )   +  + gc obj . total clusters ;  final int pos = rec . get read negative strand flag (  )   ?  rec . get alignment end (  )   -  scan window size : rec . get alignment start (  )  ;   +  + gc obj . total aligned reads ;  if  ( pos  >  0 )   {  final int window gc = gc[pos] ;  if  ( window gc  >  =  0 )   {   +  + gc obj . reads by gc[window gc] ;  gc obj . bases by gc[window gc] +  = rec . get read length (  )  ;  gc obj . errors by gc[window gc] +  =  sequence util . count mismatches ( rec ref bases bisulfite )   +   sequence util . count inserted bases ( rec )   +   sequence util . count deleted bases ( rec )  ;   }   }  if  ( gc obj . group  =  =  null )   {  gc obj . group = group ;   }   }  
@ nullable @ suppress warnings ( "rawtypes" )  public static  bi function <  ?  super  flowable  ?  super  subscriber  ?  extends  subscriber >    (  )  {  return on flowable subscribe ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  subscription d )  {  qd =  (  queue subscription <  integer >  ) d ;  assert equals (  queue fuseable . async qd . request fusion (  queue fuseable . any )  )  ;   }  
void   (  output stream outs )  throws io exception  {  if  ( a   count  >  0 )   {  outs . write ( a   count )  ;  outs . write ( accum 0 a   count )  ;  a   count = 0 ;   }   }  
private void   ( byte[] bitmap boolean is all )  {  if  (    log . should log (  log . debug )  )   {  if  ( bitmap  !  =  null )     log . debug ( peer  +  " rcv bitfield bytes: "  +  bitmap . length )  ;  else if  ( is all )     log . debug ( peer  +  " rcv bitfield have   all" )  ;  else    log . debug ( peer  +  " rcv bitfield have   none" )  ;   }  synchronized  ( this )   {  if  ( bitfield  !  =  null )   {  if  (    log . should log (  log . warn )  )     log . warn ( " got unexpected bitfield message from "  +  peer )  ;  return ;   }  if  ( metainfo  =  =  null )   {  if  ( bitmap  !  =  null )   {  bitfield = new  bit field ( bitmap bitmap . length * 8 )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( "have   x w / o metainfo: "  +  is all )  ;  if  ( is all )   {  if  ( haves before meta info  =  =  null )  haves before meta info = new  array list <  integer >  ( 1 )  ;  else haves before meta info . clear (  )  ;  haves before meta info . add ( piece   all )  ;   }   }  return ;   }  else  {  if  ( bitmap  !  =  null )   {  bitfield = new  bit field ( bitmap metainfo . get pieces (  )  )  ;   }  else  {  bitfield = new  bit field ( metainfo . get pieces (  )  )  ;  if  ( is all )  bitfield . set all (  )  ;   }   }   }  boolean interest = listener . got bit field ( peer bitfield )  ;  set interesting ( interest )  ;  if  ( bitfield . complete (  )  &&  ! interest )   {  if  (    log . should log (  log . warn )  )     log . warn ( " disconnecting seed that connects to seeds: "  +  peer )  ;  peer . disconnect ( true )  ;   }   }  
public rtcp report block[]   (  )  {  return    report blocks ;   }  
public void   (  session session )  {   log . debug ( " rayo plugin session created "  +  session . get address (  )  . to string (  )   +  "\n" +   (  (  client session ) session )  . get presence (  )  . toxml (  )  )  ;   }  
@ override protected void   (  )  {  try  {  glassfish . start (  )  ;   runtime . get runtime (  )  . add shutdown hook ( new  thread (  )  {  @ override public void run (  )  {  stop repose (  )  ;   }   }   )  ;   file war = new  file ( war location ) 
public  field element   (  )  {  return pow ( f . get qm5d8 (  )  )  ;   }  
public   (  router context ctx )  {  super ( ctx )  ;   }  
private synchronized void   (  client app state state  exception e )  {     state = state ;  if  (    mgr  !  =  null )     mgr . notify ( this state null e )  ;   }  
public static boolean   (  )  {  return    is slow ||  !  native big integer . is native (  )  ;   }  
private void   ( final  illumina data provider factory factory final  read structure read structure final  extract illumina barcodes .  barcode metric metricacagtg final int barcode position )  {  int num reads = 0 ;  final  base illumina data provider data provider = factory . make data provider (  )  ;  while  ( data provider . has next (  )  )   {  final  cluster data cluster = data provider . next (  )  ;  if  ( metricacagtg . barcode . equals ( cluster . get matched barcode (  )  )  )   {   +  + num reads ;   }   assert . assert equals ( cluster . get read ( read structure . templates . get indices (  ) [0] )  . get qualities (  )  . length barcode position  -  1 )  ;   assert . assert equals ( cluster . get read ( read structure . templates . get indices (  ) [0] )  . get bases (  )  . length barcode position  -  1 )  ;   }   assert . assert equals ( num reads metricacagtg . reads )  ;  data provider . close (  )  ;   }  
public void   (  string moo )  {     should save = true ;   }  
static boolean   ( final  string host final  string domain root )  {  if  ( domain root  =  =  null )   {  return false ;   }  return host . ends with ( domain root )  &&  ( host . length (  )   =  =  domain root . length (  )  || host . char at ( host . length (  )   -  domain root . length (  )   -  1 )   =  =  ' . ' )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  maybe < t >    (  predicate <  ?  super t >  predicate )  {   object helper . require non null ( predicate "predicate is null" )  ;  return  rx java plugins . on assembl
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  flowable <  integer >  (  )  {  @ override protected void subscribe actual (   subscriber <  ?  super  integer >  s )  {  s . on subscrib
private  string   (  rate rate double fudge quantity )  {   string builder buf = new  string builder ( 128 )  ;  buf . append ( num ( rate . get average value (  )  )  )  . append ( ' ; ' )  ;  buf . append ( num ( rate . get extreme average value (  )  )  )  . append ( ' ; ' )  ;  buf . append ( pct ( rate . get percentage of lifetime value (  )  )  )  . append ( ' ; ' )  ;  if  ( rate . get lifetime total event time (  )   >  0 )   {  buf . append ( "0 ; 0 ; 0 ; 0 ; " )  ;   }  buf . append ( num ( fudge quantity )  )  . append ( ' ; ' )  ;  return buf . to string (  )  ;   }  
@ suppress warnings ( "rawtypes" )  @ test public void   (  )  {  try  {   rx java plugins . set on flowable assembly ( new  function <  flowable  flowable >  (  )  {  @ override public  flowable apply (   flowable t )  {  return new  flowable range ( 1 2
void   (  hash h )  {     verifies in progress . add ( h )  ;   }  
@ override public int   (  )  {  return  arrays . hash code ( this . to byte array (  )  )  ;   }  
@ override public void   (  )  {  underlying iterator . close (  )  ;   }  
public void   (  output stream out )  throws  data format exception  io exception  {   data helper . write long ( out 2    flags )  ;   data helper . write long ( out 6    date )  ;   }  
public   (  genericgf field )  {  this . field = field ;  this . cached generators = new  array list <  >  (  )  ;  cached generators . add ( new  genericgf poly ( field new int[] { 1 }  )  )  ;   }  
@ deprecated public boolean   (  )  {  return is enabled (  connection type . socket   c2s true )  ;   }  
public static  < t u > void   (  function <  maybe < t >   ?  extends  maybe source < u >  >  composer )  {   publish processor < t >  pp =  publish processor . create (  )  ;   test subscriber < u >  ts = new  test subscriber < u >  (  )  ;  try  {  new  maybe to flowable < u >  ( composer . apply ( pp . single element (  )  )  )  . subscribe ( ts )  ;   }  catch  (   throwable ex )   {  throw  exception helper . wrap or throw ( ex )  ;   }  assert true ( " not subscribed to source ! " pp . has subscribers (  )  )  ;  ts . cancel (  )  ;  assert false ( " dispose not propagated ! " pp . has subscribers (  )  )  ;   }  
public  string   (  )  {  return clean ( css )  ;   }  
public void   (  object input in )  throws io exception   class not found exception  {  super . read external ( in )  ;  streamid =  basic streamid factory . create streamid (  externalizable util . get instance (  )  . read safeutf ( in )  )  ;   }  
@ test ( expected =  no such element exception . class )  public void   (  )  {  final  object invoked = new  object (  )  ;   collection <  flowable <  object >  >  observables =  collections . empty list (  )  ;   flowable <  object >  result =  flowabl
protected  output stream   (  )  throws io exception  {  return s . get output stream (  )  ;   }  
@ test public void   (  )  throws  exception  {  assert not null (  reflection tools . construct (  string . class )  )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( requested n )  ;  drain (  )  ;   }   }  
public   (  input stream in )  {  set version ( http . version )  ;  set ( in )  ;  set content input stream ( null )  ;   }  
public  string   (  )  {  return get checked ( udp transport . prop   laptop   mode )  ;   }  
public void   (  )  {  if  (    total max  >  0 )     current total . set ( 0 )  ;  if  (    max  >  0 )   conn throttler . this . counter . clear (  )  ;   }  
@ override public void   (  throwable t )  {  if  (  ! try on error ( t )  )   {   rx java plugins . on error ( t )  ;   }   }  
void   (  )  {  if  ( once . compare and set ( false true )  )   {  parent . emit ( index value )  ;   }   }  
  (  output stream output stream  stats callback stats callback )  {  assert output stream  !  =  null && stats callback  !  =  null ;  this . output stream = output stream ;  this . stats callback = stats callback ;   }  
public  data structure   (  )  {  return new  create session message (  )  ;   }  
@ test public void   (  )  {   replay processor <  integer >  async =  replay processor . create with size ( 1 )  ;  async . on complete (  )  ;   flowable processor <  integer >  serial = async . to serialized (  )  ;  assert false ( serial . has subscri
private void   ( int start )  {  for  ( int i =  ( n keys  -  1 )  ;  i  >  =  start ;  i -  -  )   {  keys[i  +  1] = keys[i] ;  vals[i  +  1] = vals[i] ;   }  n keys +  +  ;   }  
public  pattern   (  )  {  return regex pattern ;   }  
@ override public  string   (  )  {  boolean wrote = false ;   string builder b = new  string builder (  )  ;  b . append ( " {  positional: { " )  ;  for  (   map .  entry <  integer  argument >  entry : positionals . entry set (  )  )   {  wrote = true 
@ override public boolean   (  )  {  return true ;   }  
private synchronized void   (  )  {  if  ( openfired  !  =  null )   {  try  {  try  (  writer out = new  output stream writer ( new  buffered output stream ( openfired . get output stream (  )  )  )  )  {  out . write ( "exit\n" )  ;   }  final  thread waiting =  thread . current thread (  )  ;   thread waiter = new  thread (  )  {  @ override public void run (  )  {  try  {  openfired . wait for (  )  ;  waiting . interrupt (  )  ;   }  catch  (   interrupted exception ie )   {   }   }   }   ;  waiter . start (  )  ;  try  {   thread . sleep ( 10000 )  ;  waiter . interrupt (  )  ;  openfired . destroy (  )  ;   }  catch  (   interrupted exception ie )   {   }  card layout . show ( card panel "main" )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }  openfired = null ;   }  
@ override public void   (  throwable t )  {  if  (  ! try on error ( t )  )   {   rx java plugins . on error ( t )  ;   }   }  
private  string   (  output stream sam out  string version boolean is master sam event handler event handler int mode  string user  string password  string opts )  {  synchronized  ( sam out )   {  try  {  if  ( user  !  =  null && password  !  =  null )  sam out . write (  ( "hello version min = 1 . 0 max = "  +  version  +  " user = \"" +  user . replace ( "\"" "\\\"" )  +  "\" password = \"" +  password . replace ( "\"" "\\\"" )  +  "\"\n" )  . get bytes ( "utf - 8" )  )  ;  else sam out . write (  ( "hello version min = 1 . 0 max = "  +  version  +  '\n' )  . get bytes ( "utf - 8" )  )  ;  sam out . flush (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " hello sent" )  ;   string his version = event handler . wait for hello reply (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " hello reply found: "  +  his version )  ;  if  ( his version  =  =  null )  throw new io exception ( " hello failed" )  ;  if  (  ! is master )  return "ok" ;     isv3 =  version comparator . comp ( his version "3" )   >  =  0 ;  if  (    isv3 )   {     isv32 =  version comparator . comp ( his version "3 . 2" )   >  =  0 ;  byte[] id = new byte[5] ;     context . random (  )  . next bytes ( id )  ;     v3id =  base32 . encode ( id )  ;  if  (    isv32 )     v3id = "xxxx"  +     v3id ;     con options = "id = "  +     v3id ;   }  boolean master mode ;   string command ;  if  ( mode  >  =  master )   {  master mode = true ;  command = "add" ;  mode -  = master ;   }  else  {  master mode = false ;  command = "create destination = transient" ;   }   string style ;  if  ( mode  =  =  stream )  style = "stream" ;  else if  ( mode  =  =  dg || mode  =  =  v1dg )  style = "datagram" ;  else style = "raw" ;  if  ( master mode )   {  if  ( mode  =  =  v1dg || mode  =  =  v1raw )  throw new  illegal argument exception ( "v1 dg / raw incompatible with master session" )  ;   string req = "session create destination = transient style = master id = master send "  +  opts  +  '\n' ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  sam out . flush (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "session create style = master sent" )  ;  boolean ok = event handler . wait for session create reply (  )  ;  if  (  ! ok )  throw new io exception ( "session create style = master failed" )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "session create style = master reply found: "  +  ok )  ;  if  ( mode  !  =  stream )  opts +  = " port = 9999" ;   }   string req = "session "  +  command  +  " style = " +  style +  ' ' +     con options +  ' ' +  opts +  '\n' ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  sam out . flush (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "session "  +  command  +  " sent" )  ;  boolean ok ;  if  ( master mode )  ok = event handler . wait for session add reply (  )  ;  else ok = event handler . wait for session create reply (  )  ;  if  (  ! ok )  throw new io exception ( "session "  +  command  +  " failed" )  ;  if  (    log . should log (  log . debug )  )     log . debug ( "session "  +  command  +  " reply found: " +  ok )  ;  if  ( master mode )   {  req = "session add style = stream from   port = 99 id = stream99\n" ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  req = "session add style = stream from   port = 98 id = stream98\n" ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  req = "session remove id = stream99\n" ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  sam out . flush (  )  ;   }  req = "naming lookup name = me\n" ;  sam out . write ( req . get bytes ( "utf - 8" )  )  ;  sam out . flush (  )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " naming lookup sent" )  ;   string destination = event handler . wait for naming reply ( "me" )  ;  if  (    log . should log (  log . debug )  )     log . debug ( " naming lookup reply found: "  +  destination )  ;  if  ( destination  =  =  null )   {     log . error ( " no naming lookup reply found ! " )  ;  return null ;   }  else  {     log . info ( " we are "  +  destination )  ;   }  return destination ;   }  catch  (  io exception e )   {     log . error ( " error handshaking" e )  ;  return null ;   }   }   }  
public  encryption mode   (  )  {  return    encryption mode ;   }  
public void   ( boolean speex encode )  {  this . speex encode = speex encode ;   }  
private  string   (  )  {  return get device type (  )  ;   }  
public static int   (  string workgroup name  date start date  date end date )  {   workgroup workgroup = get workgroup ( workgroup name )  ;  if  ( workgroup  =  =  null )   {  return 0 ;   }  int count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( workgroup   request   count )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  pstmt . set string ( 2  string utils . date to millis ( start date )  )  ;  pstmt . set string ( 3  string utils . date to millis ( end date )  )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  count = rs . get int ( 1 )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return count ;   }  
public  collection <  string >    (  )  {  return presence states ;   }  
@ test public void   (  )  {   test observer <  object >  to = new  test observer <  object >  (  )  ;   observable . just ( 1 )  . flat map ( new  function <  integer  observable <  object >  >  (  )  {  @ override public  observable <  object >  apply (
@ override public  string   (  )  {  return null ;   }  
public void   ( boolean sub tree search )  {  this . sub tree search = sub tree search ;  properties . put ( "ldap . sub tree search"  string . value of ( sub tree search )  )  ;   }  
@ test public void   (  )  {   flowable <  string >  source =  flowable . just ( "a" "bb" "ccc" "dddd" )  ;   single <  map <  integer  string >  >  mapped = source . to map ( length func )  ;   map <  integer  string >  expected = new  hash map <  intege
public  sam record with ordinal   (  )  {  return this . sam record with ordinal ;   }  
@ test public void   (  )  {   observable <  long >  source =  observable . interval ( 1 1  time unit . milliseconds )  . take ( 1000 )  . subscribe on (  schedulers . io (  )  )  ;   observable <  long >  cached = source . replay (  )  . auto connect (  
public boolean   (  agent agent )  {  if  ( agents . contains ( agent )  )   {  return true ;   }  for  (   group group : get group objects (  )  )   {  if  ( group . is user ( agent . get agentjid (  )  )  )   {  return true ;   }   }  return false ;   }  
@ test public void   (  )  {  final  test observer <  integer >  to =  test observer . create (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;   thread . current thread (  )  . interrupt (  )  ;  to . await terminal event (  )  ;  assert true 
public double   ( final  genotype concordance scheme scheme final boolean missing sites flag )  {  return calculate genotype concordance util ( scheme missing sites flag true )  ;   }  
public void   (  timer task task  date first time long period )  {   timer task wrapper task wrapper = new  timer task wrapper ( task )  ;  wrapped tasks . put ( task task wrapper )  ;  timer . schedule at fixed rate ( task wrapper first time period )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . timeout ( 1  time unit . seconds  schedulers . single (  )  null )  ;   }  
public static byte[]   (  string data )  {  return data  =  =  null  ?  null :  base32 hex . decode ( data . to upper case (  )  )  ;   }  
@delete @ path ( " /  { room name } " )  public  response   ( @ path param ( "room name" )   string room name @ default value ( "conference" )  @ query param ( "servicename" )   string service name )  throws muc service exception  {  muc room controller .
public  client app   (  string class name  string[] args )  {  for  (   map .  entry <  client app  string[] >  e :    clients . entry set (  )  )   {  if  ( e . get key (  )  . get class (  )  . get name (  )  . equals ( class name )  &&  arrays . equals ( e . get value (  )  args )  )  return e . get key (  )  ;   }  return null ;   }  
@ override public void   (  )  {  try  {   system . out . println ( "running  test observable thread" )  ;  for  (   string s : values )   {   system . out . println ( " test observable on next: "  +  s )  ;  observer . on next ( s )  ;   }  observer . on
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  composite disposable cd = new  composite disposable (  )  ;   runnable run = new  runnable (  )  {  @ override public void run (  )  {  
  (  string token name  string element name )  {  this . token name = token name ;  this . element name = element name ;  this . element class = null ;   }  
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . yahoo . username" "kraken" )  ;   }  
public void   (  plugin manager manager  file plugin directory )  {  int history days =  jive globals . get int property ( history   days   property default   history   days )  ;   property event dispatcher . add listener ( this )  ;  persistence managers = new  array list <  persistence manager >  (  )  ;  persistence managers . add ( new  default persistence manager (  )  )  ;  try  {   class . for name ( "com . reucon . openfire . phpbb3 .  phpbb3 auth provider" )  ;  persistence managers . add ( new  phpbb3 persistence manager (  )  )  ;   }  catch  (   class not found exception e )   {   }  set all offline (  )  ;  set history days ( history days )  ;  for  (   client session session :  session manager . get instance (  )  . get sessions (  )  )   {  session created ( session )  ;   }   session event dispatcher . add listener ( this )  ;   presence event dispatcher . add listener ( this )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   consumer <  integer >  source next = mock (  consumer . class )  ;   action source completed = mock (  action . class )  ;   action source unsubscribed = mock (  action
public long   (  )  {  return    date ;   }  
@ test public void   (  )  throws io exception  {  final byte expected = 0x1 ;  buffer . put ( expected )  ;  assert equals ( " byte in buffer should be same as the byte put into the buffer" expected buffer . get (  )  )  ;   }  
public void   ( i2p session session )  {     l . disconnected ( session )  ;   }  
@ override protected void   ( final long offset final byte[] b )  {  m   write lock . lock (  )  ;  try  {  m   byte buffer . position (  ( int ) offset )  ;  m   byte buffer . put ( b )  ;   }  finally  {  m   write lock . unlock (  )  ;   }   }  
@ override public  set <  string >    (  )  throws  unsupported operation exception  {  return search   fields ;   }  
public long   (  )  {  return    congestion window end ;   }  
public  optional <  node >    (  system model system model )  {   optional <  node >  local node =  optional . empty (  )  ;  for  (   cluster repose cluster : system model . get repose cluster (  )  )   {  if  ( repose cluster . get id (  )  . equals ( cluster id )  )   {  local node = get local node ( repose cluster )  ;   }   }  return local node ;   }  
public void   (  hash peer )  {  if  ( true )  return ;     choked peers . add ( peer )  ;  synchronized  (    next lock )   {     next lock . notify all (  )  ;   }   }  
public static void   (  view v )  {  if  ( v  =  =  null )   {  throw new  null pointer exception (  )  ;   }  for  (  ;   ;   )   {  assert true ( "visibility for "  +  v  view . visible  =  =  v . get visibility (  )  )  ;   view parent parent = v . get parent (  )  ;  if  ( parent  =  =  null ||  !  ( parent instanceof  view )  )   {  break ;   }  v =  (  view ) parent ;   }   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  @ test public void   (  )  throws  exception  {   observable <  integer >  source =  observable . just ( 1 )  ;  try  {   observable . just ( source source source )  . concat map eager (  (  function )
private static  list <  configured limit group >    (  configured limit group group )  {  final  list <  configured limit group >  list = new  linked list <  >  (  )  ;  list . add ( group )  ;  return list ;   }  
@ check return value @ non null public static  < t >  async subject < t >    (  )  {  return new  async subject < t >  (  )  ;   }  
@ override public void   (  file transfer event listener event listener )  {  event listeners . add ( event listener )  ;   }  
private void   (  string ignore string )  {  ignore list . clear (  )  ;   string tokenizer tokenizer = new  string tokenizer ( ignore string " " )  ;  while  ( tokenizer . has more tokens (  )  )   {   string username = tokenizer . next token (  )  . trim (  )  ;  ignore list . add ( username )  ;   }   }  
public static  test   (  )  {   test suite suite = new  test suite ( "net . i2p . client . i2p client test suite" )  ;  suite . add test suite ( i2p client test . class )  ;  suite . add test suite (  datagram test . class )  ;  return suite ;   }  
public void   (  string flags )  {  if  ( flags  !  =  null )   {  try  {     sort flags =  integer . parse int ( flags )  ;   }  catch  (   number format exception nfe )   {     sort flags = 0 ;   }   }  else  {     sort flags = 0 ;   }   }  
@ test public void   (  )  {   observable . concat delay error (  observable . just (  observable . just ( 1 )   observable . just ( 2 )   observable . just ( 3 )  . concat with (  observable .  <  integer > error ( new  test exception (  )  )  )   observ
public static int   (  router context ctx )  {  int min port =  math . min ( 65535  math . max ( 1 ctx . get property ( prop   min   port min   random   port )  )  )  ;  int max port =  math . min ( 65535  math . max ( min port ctx . get property ( prop   max   port max   random   port )  )  )  ;  return min port  +  ctx . random (  )  . next int ( 1  +  max port  -  min port )  ;   }  
public int   (  )  {  return row size ;   }  
@ override public  mappers   (  )  {  return new  mappers (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  atomic integer wip = new  atomic integer (  )  ;  final  atomic throwable error = new  atomic throwable (  )  ;  final  test subscriber 
@ override public  string   (  )  {  return " failed establish state: " ;   }  
protected boolean   (  string opcode  properties props )  {  if  ( stream session  =  =  null )   {     log . error ( "stream message received  but no stream session exists" )  ;  return false ;   }  if  ( opcode . equals ( "send" )  )   {  return exec stream send ( props )  ;   }  else if  ( opcode . equals ( "connect" )  )   {  return exec stream connect ( props )  ;   }  else if  ( opcode . equals ( "close" )  )   {  return exec stream close ( props )  ;   }  else  {  if  (    log . should warn (  )  )     log . warn ( " unrecognized stream message opcode: \""  +  opcode  +  "\"" )  ;  return false ;   }   }  
private void   ( final int total cycle count final  tile data tile data final  cycle data current cycle data )  throws io exception  {  final byte[] tile byte array = new byte[tile data . compressed block size] ;  final  input stream stream = this . streams[total cycle count] ;  long data left = tile data . file position  -  stream . skip ( tile data . file position )  ;  while  ( data left  >  0 )   {  data left -  = stream . skip ( data left )  ;   }  final int read bytes = stream . read ( tile byte array )  ;  if  ( read bytes  !  =  tile data . compressed block size )   {  throw new  picard exception (  string . format ( " error while reading from bcl file for cycle %d .   offending file on disk is %s"  ( total cycle count  +  1 )  this . stream files[total cycle count] . get absolute path (  )  )  )  ;   }  final  byte array input stream byte input stream = new  byte array input stream (  arrays . copy of range ( tile byte array 0 read bytes )  )  ;  byte[] decompressed byte array = decompress tile ( total cycle count tile data byte input stream )  ;  byte[] un nibbled byte array = promote nibbles to bytes ( decompressed byte array )  ;  cached tile[total cycle count] = filter non pf reads ( tile data current cycle data un nibbled byte array )  ;  cached tile position[total cycle count] = 0 ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  mergen sync streams ofn ( 1 1000000 )  . subscribe ( ts )  ;  ts . await terminal event (  )  ;  ts . assert no errors (  )  ;  assert equals ( 1
@ override public void   (  disposable s )  {  subscribed . set ( true )  ;   }  
public  set <  string >    (  properties options )  {  return  collections . empty set (  )  ;   }  
public void   ( final  string font tag final  font font final boolean set all final boolean keep sizes )  throws  rrd exception  {  this . set font ( get font tag by name ( font tag )  font set all keep sizes )  ;   }  
public static void   (  array list array  object elements[] )  {   object arr$[] = elements ;  int len$ = arr$ . length ;  for  ( int i$ = 0 ;  i$  <  len$ ;  i$ +  +  )   {   object element = arr$[i$] ;  array . add ( element )  ;   }   }  
@ test public void   (  )  {   list <  user bean >  users = handle . create query ( "select id  name from user" )  . map to bean (  user bean . class )  . list (  )  ;  assert that ( users )  . extracting ( "name" )  . contains ( " alice" " bob" " charlie
synchronized void   (  snac request request )  {   log . debug ( " handling request "  +  request )  ;  int family = request . get command (  )  . get family (  )  ;  if  ( snac mgr . is pending ( family )  )   {  snac mgr . add request ( request )  ;  return ;   }   basic flap connection conn = snac mgr . get conn ( family )  ;  if  ( conn  !  =  null )   {  conn . send request ( request )  ;   }  else  {  if  (  !  ( request . get command (  )  instanceof  service request )  )   {  snac mgr . set pending ( family true )  ;  snac mgr . add request ( request )  ;  request ( new  service request ( family )  )  ;   }  else  {   log . debug ( "eep !  can't find a service redirector server . " )  ;   }   }   }  
public static  string   (  )  {  final  string builder sb = new  string builder (  )  ;  sb . append (  jive globals . get home directory (  )  )  ;  if  (  ! sb . substring ( sb . length (  )   -  1 )  . starts with (  file . separator )  )   {  sb . append (  file . separator )  ;   }  sb . append ( "logs" )  ;  sb . append (  file . separator )  ;  return sb . to string (  )  ;   }  
@ test public void   (  )  {  final  log argument group extractor extractor =  log argument group extractor . instance ( "" "" "" ""  log format argument . remote   host )  ;  http log formatter . set logic ( extractor formatter )  ;  assert that ( format
public void   (  )  {  if  ( this . sub file  !  =  null )   {  this . sub file . delete (  )  ;   }  else if  ( this . addresses  !  =  null )   {  try  {  this . addresses . clear (  )  ;   }  catch  (   unsupported operation exception uoe )   {   }   }   }  
@ override public void   (  subscriber <  ?  super t >  s )  {   publisher <  ?  extends t >  pub ;  try  {  pub =  object helper . require non null ( supplier . call (  )  " the publisher supplied is null" )  ;   }  catch  (   throwable t )   {   excepti
@ override public  presence   ( jid jid muc role sender role )  throws  forbidden exception  {  if  ( muc role .  affiliation . admin  !  =  sender role . get affiliation (  )  && muc role .  affiliation . owner  !  =  sender role . get affiliation (  )  
public int   (  )  throws io exception  {  return delegate . read unsigned byte (  )  ;   }  
@ override public void   ( long n )  {  s . request ( n )  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder ( 64 )  ;  buf . append ( " test peer " )  . append (    peer . to base64 (  )  . substring ( 0 4 )  )  ;  buf . append ( " with nonce " )  . append (    nonce )  ;  return buf
@ test public void   (  )  {   publish subject <  integer >  start =  publish subject . create (  )  ;   function <  integer  observable <  integer >  >  end = new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable < 
public double   (  )  {  long num runs =    num runs . get (  )  ;  if  ( num runs  >  0 )  return    total pending time . get (  )   /   ( double ) num runs ;  else return 0 ;   }  
public void   (  )  {  int n sockets = size (  )  ;  for  ( int n = 0 ;  n  <  n sockets ;  n +  +  )   {  ssdp search socket sock = getssdp search socket ( n )  ;  sock . close (  )  ;   }  clear (  )  ;   }  
public void   ( i2np message message )  {     message = message ;   }  
@ override public void   (  observer <  ?  super  integer >  o )  {   disposable d =  disposables . empty (  )  ;  o . on subscribe ( d )  ;  o . on next ( 1 )  ;  o . on next ( 2 )  ;  o . on next ( 3 )  ;   }  
@ override int   (  )  {  return  jive globals . get int property ( "xmpp . component . idle" 6 * 60 * 1000 )   /  1000 ;   }  
@ override protected void   (  subscriber <  ?  super  integer >  s )  {  s . on subscribe ( new  boolean subscription (  )  )  ;  subscriber . set ( s )  ;   }  
@ before public void   (  )  {  scheduler = new  test scheduler (  )  ;  inner scheduler = scheduler . create worker (  )  ;   }  
@ override public  string   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {   flowable . from iterable ( new  crashing iterable ( 100 2 100 )  )  . filter (  functions . always true (  )  )  . test (  )  . assert failure (  test exception . class 0 )  ;   }  
@ test public void   (  )  {   flowable .  <  integer > empty (  )  . subscribe ( w )  ;  verify ( w )  . on complete (  )  ;  verify ( w never (  )  )  . on next ( any (  integer . class )  )  ;  verify ( w never (  )  )  . on error ( any (  throwable . 
@ test public void   (  )  {  final  test async error observable o1 = new  test async error observable ( "one" "two" "three" )  ;  final  test async error observable o2 = new  test async error observable ( "four" "five" "six" )  ;  final  test async error
@ test public void   (  )  {   flowable <  integer >  o =  flowable . range ( 1  flowable . buffer size (  )  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . assert no values (  )  ;  ts . request ( 1 )  ;  o .
@ test public void   (  )  throws  exception  {  h . execute ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  ;  h . execute ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  ;  try  (  result iterator <  something >  i
public boolean   (  string addr int port  string msg )  {  try  {   inet address inet addr =  inet address . get by name ( addr )  ;   datagram packet dgm packet = new  datagram packet ( msg . get bytes (  )  msg . length (  )  inet addr port )  ;  ssdp uni sock . send ( dgm packet )  ;   }  catch  (   exception e )   {   debug . warning ( "addr  =  "  +  ssdp uni sock . get local address (  )  . get host name (  )  )  ;   debug . warning ( "port  =  "  +  ssdp uni sock . get local port (  )  )  ;   debug . warning ( e )  ;  return false ;   }  return true ;   }  
public   (  comparator <  ?  super t >  comparator )  {  this . comparator = comparator ;   }  
@ test public void   (  )  {   flowable .  <  integer > empty (  )  . scan ( 0 sum )  . test ( 1 )  . assert result ( 0 )  ;   }  
public void   (  localmuc room other room )  {  start time = other room . start time ;  locked time = other room . locked time ;  owners = other room . owners ;  admins = other room . admins ;  members = other room . members ;  outcasts = other room . outcasts ;  natural language name = other room . natural language name ;  description = other room . description ;  can occupants change subject = other room . can occupants change subject ;  max users = other room . max users ;  roles to broadcast presence = other room . roles to broadcast presence ;  public room = other room . public room ;  persistent = other room . persistent ;  moderated = other room . moderated ;  members only = other room . members only ;  can occupants invite = other room . can occupants invite ;  password = other room . password ;  can anyone discoverjid = other room . can anyone discoverjid ;  log enabled = other room . log enabled ;  login restricted to nickname = other room . login restricted to nickname ;  can change nickname = other room . can change nickname ;  registration enabled = other room . registration enabled ;  subject = other room . subject ;  roomid = other room . roomid ;  creation date = other room . creation date ;  modification date = other room . modification date ;  empty date = other room . empty date ;  saved todb = other room . saved todb ;  muc service = other room . muc service ;   }  
public void   (  database entry entry )  {  if  (    db entry  !  =  null )  throw new  illegal state exception (  )  ;     db entry = entry ;   }  
public void   (  user user )  {  jid userjid = xmpp server . get instance (  )  . createjid ( user . get username (  )  null )  ;  for  (   group group : get groups ( userjid )  )   {  if  ( group . get admins (  )  . contains ( userjid )  )   {  if  ( group . get admins (  )  . remove ( userjid )  )   {  group cache . remove ( group . get name (  )  )  ;   }   }  else  {  if  ( group . get members (  )  . remove ( userjid )  )   {  group cache . remove ( group . get name (  )  )  ;   }   }   }   }  
 overlap detector <  gene >    (  )  {  final  overlap detector <  gene >  overlap detector = new  overlap detector <  gene >  ( 0 0 )  ;  final int expected columns =  ref flat columns . values (  )  . length ;  final  tabbed text file with header parser parser = new  tabbed text file with header parser ( ref flat file  ref flat column labels )  ;  final  map <  string  list <  tabbed text file with header parser .  row >  >  ref flat lines by gene = new  hash map <  string  list <  tabbed text file with header parser .  row >  >  (  )  ;  for  (  final  tabbed text file with header parser .  row row : parser )   {  final int line number = parser . get current line number (  )  ;  if  ( row . get fields (  )  . length  !  =  expected columns )   {  throw new  annotation exception ( " wrong number of fields in ref flat file "  +  ref flat file  +  " at line " +  line number )  ;   }  final  string gene name = row . get field (  ref flat columns . gene   name . name (  )  )  ;  final  string transcript name = row . get field (  ref flat columns . transcript   name . name (  )  )  ;  final  string transcript description = gene name  +  ":"  +  transcript name ;  final  string chromosome = row . get field (  ref flat columns . chromosome . name (  )  )  ;  if  (  ! is sequence recognized ( chromosome )  )   {  log . debug ( " skipping "  +  transcript description  +  " due to unrecognized sequence " +  chromosome )  ;   }  else  {   list <  tabbed text file with header parser .  row >  transcript lines = ref flat lines by gene . get ( gene name )  ;  if  ( transcript lines  =  =  null )   {  transcript lines = new  array list <  tabbed text file with header parser .  row >  (  )  ;  ref flat lines by gene . put ( gene name transcript lines )  ;   }  transcript lines . add ( row )  ;   }   }  int longest interval = 0 ;  int num intervals over1mb = 0 ;  for  (  final  list <  tabbed text file with header parser .  row >  transcript lines : ref flat lines by gene . values (  )  )   {  try  {  final  gene gene = make gene from ref flat lines ( transcript lines )  ;  overlap detector . add lhs ( gene gene )  ;  if  ( gene . length (  )   >  longest interval )  longest interval = gene . length (  )  ;  if  ( gene . length (  )   >  1000000 )   +  + num intervals over1mb ;   }  catch  (   annotation exception e )   {  log . debug ( e . get message (  )   +  "  -  -  skipping" )  ;   }   }  log . debug ( " longest gene: "  +  longest interval  +  " ;  number of genes  >  1mb: " +  num intervals over1mb )  ;  return overlap detector ;   }  
@ benchmark public  object   (  )  {  return flowable . blocking last (  )  ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  upstream . subscribe ( new  subscriber observer < t >  ( s )  )  ;   }  
public  string   (  )  {   string media preference = "pcmu / 8000 / 1" ;  if  ( handset . codec  =  =  null || "opus" . equals ( handset . codec )  )  media preference = "pcm / 48000 / 2" ;  return media preference ;   }  
@ test public void   (  )  {   observable <  integer >  w =  observable . empty (  )  ;   observable <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  {  return true ;   }   }   )  .
public   (  callable <  ?  extends  throwable >  error supplier )  {  this . error supplier = error supplier ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  new  parallel invalid (  )  . reduce ( new  bi function <  object  object  object >  (  )  {  @ override public  object apply (   object a   o
synchronized  fetch data   (  fetch request request )  throws io exception   rrd exception  {  if  ( closed )   {  throw new  rrd exception ( "rrd already closed  cannot fetch data" )  ;   }   archive archive = find matching archive ( request )  ;  return archive . fetch data ( request )  ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 2 3 )  ;  o . take ( 1 )  . subscribe ( w )  ;  verify ( w times ( 1 )  )  . on next ( any int (  )  )  ;  verify ( w )  . on next ( 1 )  ;  verify ( w times ( 1 )  )  . on
public void   (  session listener listener )  {  listeners . add ( listener )  ;   }  
@ override public boolean   (  object obj )  {  if  ( obj  =  =  this )  return true ;  if  ( obj  =  =  null ||  !  ( obj instanceof  signing private key )  )  return false ;   signing private key s =  (  signing private key ) obj ;  return    type  =  =
private void   (  string name sam sequence dictionary dict )  {  log . info ( name )  ;  for  (  final sam sequence record contig : dict . get sequences (  )  )   {  log . info ( " sn = %s ln = %d%n" contig . get sequence name (  )  contig . get sequence length (  )  )  ;   }   }  
public void   ( boolean handle session progress )  {  this . handle session progress = handle session progress ;   }  
private boolean   (  array wrapper w boolean add if new )  {  boolean seen =    previous . contains ( w )  ;  if  (  ! seen )   {  if  ( add if new )  seen =  !    current . add ( w )  ;  else seen =    current . contains ( w )  ;   }  if  ( seen )   {     current duplicates +  +  ;   }  return seen ;   }  
private boolean   (  )  {  try  {  boolean rv =    reorganize lock . write lock (  )  . try lock ( 3000  time unit . milliseconds )  ;  if  (  (  ! rv )  &&    log . should log (  log . warn )  )     log . warn ( "no lock  size is: "  +     reorganize lock . get queue length (  )  new  exception ( "rats" )  )  ;  return rv ;   }  catch  (   interrupted exception ie )   {   }  return false ;   }  
public   (  request proxy service proxy service  string target host )  {  this . target host = target host ;  this . proxy service = proxy service ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer counter = new  atomic integer (  )  ;   observable <  string >  o =  observable .  <  string > unsafe create ( new  observable source <  string >  (  )  {  @ override publi
 cpcg metrics   (  )  {  final  cpcg metrics m = new  cpcg metrics (  )  ;  m . library = this . library ;  m . context = this . context ;  m . total   sites = this . sites ;  m . total   bases = this . ref ccontrolc  +  this . ref coxidatedc  +  this . ref ccontrola +  this . ref coxidateda +  this . ref gcontrolc +  this . ref goxidatedc +  this . ref gcontrola +  this . ref goxidateda ;  m . ref   oxo   bases = this . ref coxidatedc  +  ref goxidatedc ;  m . ref   nonoxo   bases = this . ref ccontrolc  +  this . ref gcontrolc ;  m . ref   total   bases = m . ref   oxo   bases  +  m . ref   nonoxo   bases ;  m . alt   nonoxo   bases = this . ref ccontrola  +  this . ref gcontrola ;  m . alt   oxo   bases = this . ref coxidateda  +  this . ref goxidateda ;  m . oxidation   error   rate =  math . max ( m . alt   oxo   bases  -  m . alt   nonoxo   bases 1 )   /   ( double ) m . total   bases ;  m . oxidation   q =  - 10 *  math . log10 ( m . oxidation   error   rate )  ;  m . c   ref   ref   bases = this . ref ccontrolc  +  this . ref coxidatedc ;  m . g   ref   ref   bases = this . ref gcontrolc  +  this . ref goxidatedc ;  m . c   ref   alt   bases = this . ref ccontrola  +  this . ref coxidateda ;  m . g   ref   alt   bases = this . ref gcontrola  +  this . ref goxidateda ;  final double c ref error rate = m . c   ref   alt   bases  /   ( double )  ( m . c   ref   alt   bases  +  m . c   ref   ref   bases )  ;  final double g ref error rate = m . g   ref   alt   bases  /   ( double )  ( m . g   ref   alt   bases  +  m . g   ref   ref   bases )  ;  m . c   ref   oxo   error   rate =  math . max ( c ref error rate  -  g ref error rate 1e - 10 )  ;  m . g   ref   oxo   error   rate =  math . max ( g ref error rate  -  c ref error rate 1e - 10 )  ;  m . c   ref   oxo   q =  - 10 *  math . log10 ( m . c   ref   oxo   error   rate )  ;  m . g   ref   oxo   q =  - 10 *  math . log10 ( m . g   ref   oxo   error   rate )  ;  return m ;   }  
public static  bundle   ( final long mailbox id )  {  final  bundle bundle = new  bundle ( 2 )  ;  bundle . put int ( sync   extra   mailbox   count 1 )  ;  bundle . put long ( format mailbox id extra ( 0 )  mailbox id )  ;  return bundle ;   }  
private boolean   ( byte byte1 byte byte2 int bits )  {  int shift = byte   size  -  bits ;  int first =  ( byte1  >  >  shift )   <  <  shift ;  int second =  ( byte2  >  >  shift )   <  <  shift ;  return  ( first ^ second )   =  =  0 ;   }  
public void   ( boolean debug enabled )  {  this . ldap debug enabled = debug enabled ;  properties . put ( "ldap . ldap debug enabled"  boolean . to string ( debug enabled )  )  ;   }  
static  file   (  string path )  throws io exception  {   file file = new  file ( path )  ;  if  (  ! file . is absolute (  )  )   {  file = new  file (  jive globals . get home directory (  )   +   file . separator  +  path )  ;   }  return file ;   }  
@ override protected void   (  input stream in int size )  throws i2cp message exception  io exception  {  try  {     date =  data helper . read date ( in )  ;  if  ( size  >   data helper . date   length )     version =  data helper . read string ( in ) 
@ test public void   (  )  {  final  flowable <  integer >  inner =  flowable . range ( 1 2 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  ;   test subscriber <  integer >  ts =  test subscriber . create (  )  ;   flo
@ override public  sql statement parameter customizer   (  class <  ?  >  sql object type  method method  parameter param int index  type type )  {  return bind sql statement customizer factory . create for parameter ( null sql object type method param in
static void   (  list <  throwable >  list int index  string message )  {  assert true ( list . get ( index )  . to string (  )  list . get ( index )  . get cause (  )  instanceof  test exception )  ;  assert equals ( message list . get ( index )  . get cause (  )  . get message (  )  )  ;   }  
public long   (  )  {  return uploaded . get (  )  ;   }  
private  string   (  string s )  {  if  ( s  =  =  null )   {  return "" ;   }  return s . trim (  )  ;   }  
@ override public int   (  introducer i )  {  return skey . compare to ( i . skey )  ;   }  
public  string   (  )  {  return resource ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  flowable <  integer >  cache =  flowable . range ( 1 500 )  . cache (  )  ;  final  test subscriber <  integer >  ts1 = new  test subscr
@ override public int   (  )  {  if  (    data  =  =  null )  return 0 ;  int rv =    data[0] ;  for  ( int i = 1 ;  i  <  4 ;  i +  +  )  rv^ =  (    data[i]  <  <   ( i * 8 )  )  ;  return rv ;   }  
@ test public void   (  )  {   observable <  string >  subject =  observable . just ( "one" "two" "three" "four" "five" )  ;   observable <  observable <  string >  >  windowed = subject . window ( 3 3 )  ;   list <  list <  string >  >  windows = to list
public  string   (  )  {  return this . dm note ;   }  
public boolean   (  disposable o )  {  return  disposable helper . set once ( other o )  ;   }  
@ test public void   (  )  {  final  prepared batch b = h . prepare batch ( "insert into something  ( id  name )  values  ( :id  :name ) " )  ;  b . bind bean ( new  something ( 1 " eric" )  )  . add (  )  ;  b . bind bean ( new  something ( 2 " brian" ) 
private void   (  inbound establish state inbound state )  {   out net message msg ;  while  (  ( msg = inbound state . get next queued message (  )  )   !  =  null )   {     transport . failed ( msg " expired during failed establish" )  ;   }   }  
public void   ( long id )  {  if  (  (    receive stream id set )  &&  (    receive stream id  >  0 )  &&    receive stream id  !  =  id )  throw new  runtime exception ( " receive stream id already set ["  +     receive stream id  +  "  " +  id +  "]" )  ;     receive stream id set = true ;     receive stream id = id ;   }  
public void   ( final  metrics file <  quality yield metrics  integer >  metrics file )  {  metrics file . add metric ( metrics )  ;   }  
@ override public  cluster node info   ( byte[] nodeid )  {  if  ( cluster  =  =  null )   {  return null ;   }   cluster node info result = null ;   member member = get member ( nodeid )  ;  if  ( member  !  =  null )   {  result = new  hazelcast cluster
public void   ( long delta )  {  update job timings ( delta )  ;  synchronized  (    job lock )   {     job lock . notify all (  )  ;   }   }  
public  result set   (  )  throws sql exception  {  return cstmt . execute query (  )  ;   }  
@ test public void   (  )  {   replay subject <  integer >  rp =  replay subject . create (  )  ;  assert false ( rp . has observers (  )  )  ;   test observer <  integer >  to = rp . test (  )  ;  assert true ( rp . has observers (  )  )  ;  to . cancel 
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  handle . execute ( "insert into intervals ( id  foo )  values (  ?    ?  ) " 12  duration . of nanos ( 100 )  )  ;   }  
public boolean   (  )  {  return subscribers . get (  )   =  =  terminated && value  !  =  null ;   }  
public void   (  string user display )  {  this . user display = user display ;   }  
public boolean   ( i2np message message )  {  if  ( message  =  =  null )  return false ;  if  ( message instanceof  database store message )   {   database store message dsm =  (  database store message ) message ;  if  (    search . get key (  )  . equals ( dsm . get key (  )  )  )   {     search . decrement remaining (  )  ;     match found = true ;  return true ;   }   }  else if  ( message instanceof  database search reply message )   {   database search reply message dsrm =  (  database search reply message ) message ;  if  (    search . get key (  )  . equals ( dsrm . get search key (  )  )  )   {     context . profile manager (  )  . db lookup reply ( dsrm . get from hash (  )  0 dsrm . get num replies (  )  0 0  system . current time millis (  )   -     search . get created (  )  )  ;  if  (    search . should processdsrm (  )  )   {  if  (    log . should log (  log . info )  )     log . info (    search . get job id (  )   +  ":  processing dsrm via  single lookup job  apparently from "  +  dsrm . get from hash (  )  )  ;     context . job queue (  )  . add job ( new  single lookup job (    context dsrm )  )  ;   }  else if  (    log . should log (  log . info )  )   {  int remaining =    search . get lookups remaining (  )  ;     log . info (    search . get job id (  )   +  ": got a dsrm apparently from "  +  dsrm . get from hash (  )  +  " when we were looking for " +     search . get key (  )  +  "  with " +  remaining +  " outstanding searches" )  ;   }  int remaining =    search . decrement remaining ( dsrm . get from hash (  )  )  ;  return remaining  <  =  0 ;   }   }  return false ;   }  
public void   (  handset handset )  {  this . handset = handset ;   byte local crypto byte[] =  convert . from base64 string ( handset . local crypto )  ;   byte remote crypto byte[] =  convert . from base64 string ( handset . remote crypto )  ;  if  (  array extensions . get length ( local crypto byte )  . int value (  )   !  =  30 ||  array extensions . get length ( remote crypto byte )  . int value (  )   !  =  30 )   log . error ( " unexpected key / salt length . " )  ;  else  {  local crypto key =  bit assistant . sub array ( local crypto byte  integer . value of ( 0 )   integer . value of ( 16 )  )  ;  local crypto salt =  bit assistant . sub array ( local crypto byte  integer . value of ( 16 )   integer . value of ( 14 )  )  ;  remote crypto key =  bit assistant . sub array ( remote crypto byte  integer . value of ( 0 )   integer . value of ( 16 )  )  ;  remote crypto salt =  bit assistant . sub array ( remote crypto byte  integer . value of ( 16 )   integer . value of ( 14 )  )  ;   log . info ( " crypto  suite "  +  handset . crypto suite  +  " " +  handset . local crypto +  " " +  handset . remote crypto +  " " +  " " +  handset . codec +  " " +  handset . stereo )  ;  try  {  encryptor = new  encryptor ( sdp crypto suite . get encryption mode ( handset . crypto suite )  local crypto key local crypto salt remote crypto key remote crypto salt )  ;  encryptor2 = new  encryptor ( sdp crypto suite . get encryption mode ( handset . crypto suite )  remote crypto key remote crypto salt local crypto key local crypto salt )  ;  decoder =  opus . decoder   create ( sample rate channels )  ;  if  ( decoder  =  =  0 )   log . error ( " opus decoder creation error " )  ;  if  ( decoder  =  =  0 )   {  handset . codec = "pcmu" ;   log . warn ( " opus decoder creation failure  pcmu will be used in default" )  ;   }   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }   }   }  
public  string   (  string sessionid )  {   string notes = null ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( get   notes )  ;  pstmt . set string ( 1 sessionid )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  notes =  db connection manager . get large text field ( rs 1 )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return notes ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  final  atomic integer wip = new  atomic integer (  )  ;  final int indicator = 999999999 ;   flowable window with size test . hot stream (  )  . 
public  string   ( final  string column label )  {  final  integer key = column label indices . get ( column label )  ;  if  ( key  =  =  null )  throw new  no such element exception (  string . format ( "column %s in %s" column label parser . get file name (  )  )  )  ;  return fields[key] ;   }  
@ test public void   (  )  {   unicast subject <  integer >  ap =  unicast subject . create ( false )  ;  ap . on next ( 1 )  ;  ap . on error ( new  runtime exception (  )  )  ;   test observer <  integer >  to =  observer fusion . new test (  queue fuse
@ test public void   (  )  throws io exception  {   input stream stream =  input stream merger . merge ( null stream2 stream3 )  ;   string expected = stream   data2  +  stream   data3 ;   buffered reader reader = new  buffered reader ( new  input stream 
@ test public void   (  )  {   test observer <  string >  to = new  test observer <  string >  (  )  ;   observable . just ( 1 2 3 )  . compose ( new  observable transformer <  integer  string >  (  )  {  @ override public  observable <  string >  apply (
@ override public  element   (  )  {  q name q name =  document helper . createq name ( "session"  document helper . create namespace ( "" "http: /  / jivesoftware . com / protocol / workgroup" )  )  ;   element session element =  document helper . create
public void   ( boolean visible )  {  get properties (  )  . put ( name   visible   property  string . value of ( visible )  )  ;   }  
public void   ( byte val[] )  {   map <  string byte[] >  props =  collections . singleton map ( seed val )  ;  init ( props )  ;  fill block (  )  ;   }  
@ override public void   (  throwable e )  {  throw new  runtime exception ( e )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  flowable . just ( 1 )  . concat with (  flowable .  <  integer > never (  )  )  . reduce ( new  bi function <  integer  integer  integer >  (  )  {  @ override public  integer apply (   in
public  result set   (  string sql )  throws sql exception  {  return stmt . execute query ( sql )  ;   }  
public   (  publisher <  ?  extends t >  publisher )  {  this . publisher = publisher ;   }  
private void   (  string module )  {  try  {   class <  module >  mod class =  (  class <  module >  ) loader . load class ( module )  ;   module mod = mod class . new instance (  )  ;  this . modules . put ( mod class mod )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;  logger . error (  locale utils . get localized string ( "admin . error" )  e )  ;   }   }  
private sam stream session   (  string dest keystream  string direction  properties props )  throws io exception   data format exception  sam exception  {  return new sam stream session ( dest keystream direction props this )  ;   }  
@ test public void   (  )  {   iterator <  object >  it =  observable . never (  )  . blocking next (  )  . iterator (  )  ;  try  {   thread . current thread (  )  . interrupt (  )  ;  it . next (  )  ;   }  catch  (   runtime exception ex )   {  assert 
public boolean   (  file pathname )  {   string file name = pathname . get name (  )  . to lower case (  )  ;  return  ( file name . equals ignore case ( "enterprise . jar" )  )  ;   }  
public static  column mapper <  ?  >    (  type type )  {  return new  optional mapper <  >  ( type )  ;   }  
@ test public void   (  )  {   flowable . range ( 1 10 )  . flat map maybe ( new  function <  integer  maybe source <  integer >  >  (  )  {  @ override public  maybe source <  integer >  apply (   integer v )  throws  exception  {  return  maybe . empty 
@ override public synchronized  destination info   (  string destination id )  {  return destinations . get ( destination id )  . copy (  )  ;   }  
public void   (  )  {     started =    context . clock (  )  . now (  )  ;     context . stat manager (  )  . add rate data ( "send . "  +     connection id  +  " . started" 1 0 )  ;  final long to send =  ( new  file (    data file )  )  . length (  )  ;  byte data[] = new byte[8192] ;  long last send =    context . clock (  )  . now (  )  ;  while  (  !    closed )   {  try  {  int read =    in . read ( data )  ;  long now =    context . clock (  )  . now (  )  ;  if  ( read  =  =   - 1 )   {  if  (    log . should log (  log . debug )  )     log . debug ( "eof from the data for "  +     connection id  +  " after " +   ( now  -  last send )  )  ;  break ;   }  else if  ( read  >  0 )   {  if  (    log . should log (  log . debug )  )     log . debug ( " sending "  +  read  +  " on " +     connection id +  " after " +   ( now  -  last send )  )  ;  last send = now ;  if  (    sam out  !  =  null )   {  synchronized  (    sam out )   {  if  (  !    isv3 ||    mode  =  =  v1dg ||    mode  =  =  v1raw )   {   string m ;  if  (    mode  =  =  stream )   {  m = "stream send id = "  +     connection id  +  " size = " +  read +  "\n" ;   }  else if  (    mode  =  =  v1dg )   {  m = "datagram send destination = "  +     remote destination  +  " size = " +  read +  "\n" ;   }  else if  (    mode  =  =  v1raw )   {  m = "raw send destination = "  +     remote destination  +  " size = " +  read +  "\n" ;   }  else  {  throw new io exception ( "unsupported mode "  +     mode )  ;   }  byte msg[] =  data helper . getutf8 ( m )  ;     sam out . write ( msg )  ;   }     sam out . write ( data 0 read )  ;     sam out . flush (  )  ;   }   }  else  {   byte array output stream baos = new  byte array output stream ( read  +  1024 )  ;  baos . write (  data helper . getutf8 ( "3 . 0 " )  )  ;  baos . write (  data helper . getutf8 (    v3id )  )  ;  baos . write (  ( byte ) ' ' )  ;  baos . write (  data helper . getutf8 (    remote destination )  )  ;  if  (    isv32 )   {  if  (    mode  =  =  raw )  baos . write (  data helper . getutf8 ( " protocol = 123 to   port = 5678" )  )  ;  else baos . write (  data helper . getutf8 ( " to   port = 5678" )  )  ;  baos . write (  data helper . getutf8 ( " send   tags = 19 tag   threshold = 13 expires = 33 send   leaseset = true" )  )  ;   }  baos . write (  ( byte ) '\n' )  ;  baos . write ( data 0 read )  ;  byte[] pkt = baos . to byte array (  )  ;   datagram packet p = new  datagram packet ( pkt pkt . length    dgsam )  ;     dg sock . send ( p )  ;  try  {   thread . sleep ( 25 )  ;   }  catch  (   interrupted exception ie )   {   }   }     total sent +  = read ;     context . stat manager (  )  . add rate data ( "send . "  +     connection id  +  " . total sent"    total sent 0 )  ;   }   }  catch  (  io exception ioe )   {     log . error ( " error sending" ioe )  ;  break ;   }   }  if  (    sam out  !  =  null )   {  if  (    isv3 )   {  try  {     sam out . close (  )  ;   }  catch  (  io exception ioe )   {     log . info ( " error closing" ioe )  ;   }   }  else  {  try  {  byte msg[] =  ( "stream close id = "  +     connection id  +  "\n" )  . get bytes ( "utf - 8" )  ;  synchronized  (    sam out )   {     sam out . write ( msg )  ;     sam out . flush (  )  ;   }   }  catch  (  io exception ioe )   {     log . info ( " error closing" ioe )  ;   }   }   }  else if  (    dg sock  !  =  null )   {     dg sock . close (  )  ;   }  closed (  )  ;  try  {   thread . sleep ( 10000 )  ;   }  catch  (   interrupted exception ie )   {   }  if  (    log . should log (  log . debug )  )     log . debug ( " runner exiting" )  ;  if  ( to send  !  =     total sent )     log . error ( " only sent "  +     total sent  +  " of " +  to send +  " bytes" )  ;  if  (    reader2  !  =  null )     reader2 . stop reading (  )  ;     reader . stop reading (  )  ;   }  
@ override protected void   (  http servlet request req  http servlet response resp )  throws  servlet exception  io exception  {  resp . set character encoding ( "utf - 8" )  ;  resp . set header ( "x -  content -  type -  options" "nosniff" )  ;  resp .
public   (  observable source < t >  source int count int skip  callable < u >  buffer supplier )  {  super ( source )  ;  this . count = count ;  this . skip = skip ;  this . buffer supplier = buffer supplier ;   }  
@ test public void   (  )  {   test observer <  integer >  to0 =  observer fusion . new test (  queue fuseable . sync )  ;   observable . range ( 1 5 )  . do after next ( after next )  . filter (  functions . always true (  )  )  . subscribe ( to0 )  ;   
public void   (  string info )  {  this . info = info ;  if  ( this . info  =  =  null )   {  this . info = "" ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  composite disposable cd = new  composite disposable (  )  ;   runnable run = new  runnable (  )  {  @ override public void run (  )  {  
public  byte matrix   (  )  {  return matrix ;   }  
@ override public void   (  object input in )  throws io exception   class not found exception  {  username =  externalizable util . get instance (  )  . read safeutf ( in )  ;  name =  externalizable util . get instance (  )  . read safeutf ( in )  ;  if
public void   (  request event request event )  {  try  {   request request = request event . get request (  )  ;   call id header call id header =  (  call id header ) request . get header (  call id header . name )  ;   string sip call id = call id header . get call id (  )  ;   sip listener sip listener = find sip listener ( request event )  ;  if  ( sip listener  !  =  null )   {  if  ( request . get method (  )  . equals (  request . invite )  )   {  duplicate invite ( request )  ;  return ;   }  sip listener . process request ( request event )  ;  return ;   }  else  {  if  ( request . get method (  )  . equals (  request . register )  )   {  handle register ( request request event )  ;   }  else if  ( request . get method (  )  . equals (  request . options )  )   {   response res = message factory . create response (  response . ok request )  ;  sip provider . send response ( res )  ;  return ;   }  else if  (  ! request . get method (  )  . equals (  request . invite )  )   {   logger . write file ( "sip listener could not be found for "  +  sip call id  +  " " +  request . get method (  )  +  " .   ignoring" )  ;  return ;   }   }  if  ( request . get method (  )  . equals (  request . invite )  )   {  if  (  sip incoming call agent . add sip call id ( sip call id )   =  =  false )   {   from header from header =  (  from header ) request . get header (  from header . name )  ;   to header to header =  (  to header ) request . get header (  to header . name )  ;   string from = from header . get address (  )  . to string (  )  ;   string to = to header . get address (  )  . to string (  )  ;   logger . write file ( " sip server: duplicate invite from "  +  from  +  " to " +  to )  ;  return ;   }   call participant cp = new  call participant (  )  ;   string s =  sip util . get call id from sdp ( request )  ;  if  ( s  !  =  null )   {  if  (  logger . log level  >  =   logger . log   moreinfo )   {   logger . println ( " using call id from sdp in invite: "  +  s )  ;   }  cp . set call id ( s )  ;   }  s =  sip util . get conference id from sdp ( request )  ;  if  ( s  !  =  null )   {   string[] tokens = s . split ( ":" )  ;  cp . set conference id ( tokens[0] . trim (  )  )  ;  if  ( tokens . length  >  1 )   {  cp . set media preference ( tokens[1] )  ;   }  if  ( tokens . length  >  2 )   {  cp . set conference display name ( tokens[2] )  ;   }   }  if  (  sip util . get user name from sdp ( request )   !  =  null )   {  cp . set name (  sip util . get user name from sdp ( request )  )  ;   }  else  {  cp . set name (  sip util . get from name ( request event )  )  ;   }  cp . set distributed bridge (  sip util . get distributed bridge from sdp ( request )  )  ;  cp . set phone number (  sip util . get from phone number ( request event )  )  ;  cp . set to phone number (  sip util . get to phone number ( request event )  )  ;  new  incoming call handler ( cp request event )  ;  return ;   }   }  catch  (   exception e )   {   logger . exception ( "process request" e )  ;  e . print stack trace (  )  ;   }   }  
private void   (  )  {  for  (   socket connection connection :  socket connection . get instances (  )  )   {  connection . check health (  )  ;   }   }  
@ override public void   ( t t )  {  if  ( source mode  =  =  none )   {  boolean b ;  try  {  b = filter . test ( t )  ;   }  catch  (   throwable e )   {  fail ( e )  ;  return ;   }  if  ( b )   {  actual . on next ( t )  ;   }   }  else  {  actual . o
@ override public void   (  class <  ?  extends  event listener >  a class )  {  proxy . add listener ( a class )  ;   }  
public void   (  )  {  setsid ( "" )  ;  set timeout ( 0 )  ;   }  
@ override public void   (  )  {  lists . add ( new  array list <  string >  ( list )  )  ;  list . clear (  )  ;   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public static void   (  )  {  content   uri =  uri . parse (  email content . content   uri  +  " / hostauth" )  ;   }  
@ test public void   (  )  {   single . just ( 1 )  . do after terminate ( after terminate )  . filter (  functions . always true (  )  )  . subscribe with ( to )  . assert result ( 1 )  ;  assert after terminate called once (  )  ;   }  
@ override public void   (  io session session  idle status status )  throws  exception  {  super . session idle ( session status )  ;  final boolean do ping =  jive globals . get boolean property (  connection settings .  client . keep   alive   ping tru
@ override public void   (  session data session data  element command )  {   element note = command . add element ( "note" )  ;   map <  string  list <  string >  >  data = session data . get data (  )  ;   string username ;  try  {  username = get ( dat
private static  string   (  string secret  string data )  {  return  message digest algorithm . h ( secret  +  ":"  +  data )  ;   }  
@ test public void   (  )  {   observable . just ( 1 )  . concat map completable (  functions . just function (  completable . error ( new  test exception (  )  )  )  )  . test (  )  . assert failure (  test exception . class )  ;   }  
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {   completable c = error . completable . retry ( 5 )  ;  c . blocking await (  )  ;   }  
public void   ( xmpp server listener listener )  {  listeners . add ( listener )  ;   }  
@ test public void   (  )  {  try  {   rx java plugins . set init io scheduler handler ( init replace with immediate )  ;   rx java plugins . init io scheduler ( unsafe default )  ;   }  finally  {   rx java plugins . reset (  )  ;   }  assert not same ( 
public  cache < k v >    (  )  {  return cache ;   }  
public  string   (  )  {  return treatment id ;   }  
@ override public void   (  disposable d )  {  this . d = d ;   (  (  queue disposable <  ?  >  ) d )  . request fusion (  queue fuseable . any )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   observable . from future ( null )  ;   }  
@ test public void   (  )  throws  file not found exception  {  final  file truth vcf path = new  file ( test   data   path . get absolute path (  )  normalize   no   calls   truth )  ;  final  file call vcf path = new  file ( test   data   path . get abs
public char[]   (  )  {  return  user credentials . password ;   }  
@ test ( timeout = 1000 )  public void   (  )  throws  exception  {   executor service executor scheduler =  executors . new scheduled thread pool ( 1 new  rx thread factory ( " test custom pool timed" )  )  ;  try  {  final  scheduler s =  schedulers . f
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   (  function <  ?  super t  ?  extends  completable source >  mapper boolean delay errors )  {   object helper . require non null ( mapper "mapper is null" 
public   (  )  {     context . clock (  )  . add update listener ( this )  ;   (  (  router clock )    context . clock (  )  )  . add shift listener ( this )  ;   }  
private static void   ( final  context c final long message id final  string ext final  string content )  throws io exception  {  final  file text file = get body file ( c message id ext )  ;  if  (  text utils . is empty ( content )  )   {  if  (  ! text file . delete (  )  )   {   log utils . v (  log utils . tag "did not delete text body for %d" message id )  ;   }   }  else  {  final  file writer w = new  file writer ( text file )  ;  try  {  w . write ( content )  ;   }  finally  {  w . close (  )  ;   }   }   }  
@ test public void   (  )  {   test observer <  integer >  to =  test observer . create (  )  ;  to . on subscribe (  disposables . empty (  )  )  ;  to . on error ( new  test exception ( " forced failure" )  )  ;  to . assert failure (  test exception . 
@ override public void   ( final  hash peer )  {  final  peer state ps =    peers by ident . get ( peer )  ;  if  ( ps  !  =  null && ps . get we relay to them as (  )   <  =  0 &&  ( ps . get they relay to us as (  )   <  =  0 || ps . get introducer time
private static int   (  collection <  router address >  addrs )  {  int rv = 0 ;  for  (   router address ra : addrs )   {   string style = ra . get transport style (  )  ;   string host = ra . get host (  )  ;  if  ( "ntcp" . equals ( style )  )   {  if  ( host  !  =  null )   {  if  ( host . contains ( ":" )  )  rv| = ntcp   v6 ;  else rv| = ntcp   v4 ;   }   }  else if  ( "ssu" . equals ( style )  )   {  if  ( host  =  =  null )   {  for  ( int i = 0 ;  i  <  2 ;  i +  +  )   {   string ihost = ra . get option ( ihost[i] )  ;  if  ( ihost  =  =  null )  break ;  if  ( ihost . contains ( ":" )  )  rv| = ssu   v6 ;  else rv| = ssu   v4 ;   }   }  else if  ( host . contains ( ":" )  )   {  rv| = ssu   v6 ;   }  else  {  rv| = ssu   v4 ;   }   }   }  return rv ;   }  
private static void   (  peer peer int piece )  {  send message ( peer type   request piece )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final t   ( t default value )  {   object helper . require non null ( default value "default value is null" )  ;   blocking multi observer < t >  observer = new  blocking multi
public static  < t u >  flowable subscriber < t >    (  subscriber <  ?  super u >  s  function <  ?  super t  ?  extends  publisher <  ?  extends u >  >  mapper boolean delay errors int max concurrency int buffer size )  {  return new  merge subscriber < t u >  ( s mapper delay errors max concurrency buffer size )  ;   }  
public long   (  )  {  return bookmarkid ;   }  
@ test public void   (  )  throws  exception  {  final  turn key locking thread threada = new  turn key locking thread ( lock key   a )  ;  final  turn key locking blocking thread threadb = new  turn key locking blocking thread ( lock key   b )  ;  assert
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
@ test public void   (  )  {   test observer <  boolean >  to = new  test observer <  boolean >  (  )  ;  final  illegal argument exception ex = new  illegal argument exception (  )  ;   observable . just ( " boo ! " )  . any ( new  predicate <  string > 
public  string   (  )  {  return element   name ;   }  
@ override public  iterator <  string >    (  string jid )  {   list <  string >  answer = new  array list <  >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get con
public boolean   (  )  {  return registration enabled &&  !  user manager . get user provider (  )  . is read only (  )  ;   }  
@ override public  optional <  handler >    (  class <  ?  >  sql object type  method method )  {  return get implementation ( sql object type method )  . map ( m  -  >   (  handler )  ( target args handle )   -  >  m . invoke ( null  stream . concat (  s
@ override public void   (  )  {  for  (   client session session : xmpp server . get instance (  )  . get session manager (  )  . get sessions (  )  )   {  if  (  ! session . is anonymous user (  )  )   {  try  {  write to database ( session . get userna
public void   ( int val )  {  lease time = val ;   }  
public void   (  user credentials default credentials )  {  this . default credentials = default credentials ;   }  
public static  byte[]   (  boolean value )  {  byte bytes[] = new byte[1] ;  if  ( value . boolean value (  )  )  bytes[0] = 1 ;  else bytes[0] = 0 ;  return bytes to array ( bytes )  ;   }  
public   ( long bookmarkid )  throws  not found exception  {  this . bookmarkid = bookmarkid ;  load from db (  )  ;  load permissions (  )  ;   }  
@ override public void   (  input stream in  writer str buf )  throws io exception  {  int buf[] = new int[3] ;  int out[] = new int[4] ;  int l = 0 ;  while  ( true )   {  int read = in . available (  )  ;  if  ( read  =  =  0 )  break ;  int i = 0 ;  bu
  (  observer < t >  observer )  {  this . observer = observer ;   }  
public static double   (  peer profile profile )  {  long val = 0 ;  if  ( profile . get is expandeddb (  )  )   {  val = profile . get db introduction (  )  . get rate ( 24 * 60 * 60* 1000l )  . get current event count (  )  ;  val +  = 2 * 4 * profile . get db introduction (  )  . get rate ( 6 * 60 * 60* 1000l )  . get last event count (  )  ;  val +  = 3 * 4 * profile . get db introduction (  )  . get rate ( 6 * 60 * 60* 1000l )  . get current event count (  )  ;  val +  = 4 * 24 * profile . get db introduction (  )  . get rate ( 60 * 60 * 1000l )  . get current event count (  )  ;  val /  = 10 ;   }  val +  = profile . get integration bonus (  )  ;  return val ;   }  
public  string   (  )  {  return    context . get property (  reseeder . prop   sproxy   password "" )  ;   }  
public void   (  )  {     buffer . clear (  )  ;     crit buffer . clear (  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . just ( 1 2 )  . subscribe ( ts )  ;  ts . assert values ( 1 2 )  ;  thrown . expect (  assertion error . class )  ;  ts . assert neve
@ test public void   (  )  throws  exception  {  final  collection <  string >  result =  encryption artifact factory . get supported cipher suites (  )  ;   assert . assert false ( result . is empty (  )  )  ;   }  
@ override public void   ( final  subscriber <  ?  super  string >  observer )  {  observer . on subscribe ( new  boolean subscription (  )  )  ;  final  null pointer exception npe = new  null pointer exception (  )  ;   system . out . println ( " test mu
public int   (  )  {  return max jitter buffer size ;   }  
public static  < t u >  function < t  observable source < u >  >    ( final  function <  ?  super t  ?  extends  iterable <  ?  extends u >  >  mapper )  {  return new  flat map into iterable < t u >  ( mapper )  ;   }  
@ check return value @ backpressure support (  backpressure kind . full )  @ scheduler support (  scheduler support . none )  public static  flowable <  long >    ( long start long count )  {  if  ( count  <  0 )   {  throw new  illegal argument exception
@ override public boolean   (  integer t1 )  {  return t1 % 2  =  =  0 ;   }  
  ( final  pre adapter detail metrics pre adapter metrics final  bait bias detail metrics bait bias metrics )  {  this . pre adapter metrics = pre adapter metrics ;  this . bait bias metrics = bait bias metrics ;   }  
public void   (  http servlet request wrapper request  http servlet response wrapper response )  {  try  {  if  ( response . get content type (  )   !  =  null )   {   input stream absolute input stream ;  if  ( response . get content type (  )  . equals ignore case (  media type . application   json   value )  )   {   string new xml =  upstream json to xml . convert ( response . get output stream as input stream (  )  )  ;  absolute input stream = new  byte array input stream ( new xml . get bytes (  standard charsets . utf   8 )  )  ;   }  else if  ( response . get content type (  )  . equals ignore case (  media type . application   xml   value )  )   {  absolute input stream = response . get output stream as input stream (  )  ;   }  else  {  log . error ( " upstream limits responded with a content type we cannot understand:  {  } " response . get content type (  )  )  ;  throw new  upstream exception ( " upstream limits responded with a content type we cannot understand: "  +  response . get content type (  )  )  ;   }   byte array output stream output stream = new  byte array output stream (  )  ;  final  media type media type = rate limiting service helper . query combined limits ( request original preferred accept absolute input stream output stream )  ;  response . set output ( new  byte array input stream ( output stream . to byte array (  )  )  )  ;  response . set content type ( media type . to string (  )  )  ;   }  else  {  log . warn ( "no data received from upstream limits  only sending regular rate limits ! " )  ;  no upstream response ( request response )  ;   }   }  catch  (   upstream exception ue )   {  log . error ( " failure when querying limits .   reason: "  +  ue . get message (  )  ue )  ;  response . set status ( sc   bad   gateway )  ;   }  catch  (   exception e )   {  log . error ( " failure when querying limits .   reason: "  +  e . get message (  )  e )  ;  response . set status ( sc   internal   server   error )  ;   }   }  
public int   (  )  {  return unknown datapoints ;   }  
@ override public boolean   (  object o )  {  if  ( this  =  =  o )   {  return true ;   }  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )   {  return false ;   }   configured rate limit wrapper that =  (  configured rate limit wrappe
public void   (  string s )  {     config . set inbound random key ( s )  ;   }  
@ nullable public static  function <  ?  super  scheduler  ?  extends  scheduler >    (  )  {  return on single handler ;   }  
void   ( jid room jid user  string nickname  date date )  {   conversation conversation = get room conversation ( room )  ;  if  ( conversation  !  =  null )   {  conversation . participant joined ( user nickname date . get time (  )  )  ;   }   }  
@ test public void   (  )  {  assert that ( helper . get global limit group (  )  . get limit (  )  . size (  )  equal to ( 1 )  )  ;  assert that ( helper . get global limit group (  )  . get limit (  )  . get ( 0 )  instance of (  configured rate limit 
public void   (  list <  string >  groups )  {  this . groups = groups ;   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( set   groups )  ;  if  ( groups  !  =  null )   {  pstmt . set string ( 1  string utils . join ( groups " " )  )  ;   }  else  {  pstmt . set null ( 1  types . varchar )  ;   }  pstmt . set long ( 2 registrationid )  ;  pstmt . set string ( 3 this . username )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public static v card manager   (  )  {  return instance ;   }  
@ test public void   (  )  {   flowable . range ( 0 2 )  . parallel ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  if  ( 1  /  v  <  0 )   {   system . out . println ( " shou
private void   (  )  {  stack . reset (  )  ;   }  
public double   (  )  {  return attenuation ;   }  
@ override public void   ( t value )  {  values . add ( value )  ;   }  
@ test public void   (  )  {   runtime exception exception = new  runtime exception ( "test" )  ;   single . error ( exception )  . flat map maybe ( new  function <  object  maybe source <  object >  >  (  )  {  @ override public  maybe source <  object >
public static  list <  string >    (  string parent  list <  string >  default values )  {  if  ( properties  =  =  null )   {  if  ( is setup mode (  )  )   {  return default values ;   }  properties =  jive properties . get instance (  )  ;   }  final  string legacy value =  jive globals . get property ( parent )  ;  final  sorted set <  string >  property names = new  tree set <  >  ( properties . get children names ( parent )  )  ;  if  ( property names . is empty (  )  )   {  if  ( legacy value  !  =  null )   {   log . info ( " retrieving a list from property ' {  } ' which is stored in a comma - separated format .   consider using child properties instead  via  jive globals . set property (   string value   list <  string >  values  ) " parent )  ;  return  arrays . as list ( legacy value . split ( "\\s* \\s*" )  )  ;   }  return default values ;   }  else if  ( legacy value  !  =  null )   {   log . warn ( " retrieving a list from property ' {  } ' which is stored using child properties  but also in a legacy format !   the data that is in the legacy format  ( the text value of property ' {  } ' )  is not returned by this call !   its child property values are used instead .   consider removing the text value of the parent property . " parent parent )  ;   }  final  list <  string >  values = new  array list <  >  (  )  ;  for  (   string property name : property names )   {  final  string value = get property ( property name )  ;  if  ( value  !  =  null &&  ! value . is empty (  )  )   {  values . add ( value )  ;   }   }  return values ;   }  
public boolean   (  )  {  return decoder . dtmf detected (  )  ;   }  
public   (  )  {  super ( " rayo: xep 0327  -   redirect" )  ;   }  
@ override public void   (  )  {   stream error error = new  stream error (  stream error .  condition . policy   violation )  ;  session . deliver raw text ( error . toxml (  )  )  ;  session . close (  )  ;   }  
public  client transaction   (  call participant cp  string sdp )  throws  parse exception   invalid argument exception   sip exception  {   sipuri from address = null ;   address from name address = null ;   from header from header = null ;   sipuri to address = null ;   address to name address = null ;   to header to header = null ;   sipuri requesturi = null ;   call id header call id header = null ;  c seq header c seq header = null ;   allow events header allow events header = null ;   via header via header = null ;   array list via headers = null ;   content type header content type header = null ;   request invite = null ;   string ob proxy = null ;   string from name = cp . get display name (  )  ;   string from number = cp . get display name (  )  ;   string to number = cp . get phone number (  )  ;   string transport = "udp" ;   logger . println ( "xxx from  =  "  +  from name  +  " " +  cp )  ;  int to sip port = 5060 ;   string proxy = cp . get sip proxy (  )  ;  if  ( proxy  =  =  null )   {  proxy =  sip server . get default sip proxy (  )  ;   }   string voip gateway = null ;  if  ( to number . index of ( "sip:" )   =  =  0 )   {   address address = null ;   sipuri sipuri = null ;   string host = null ;   string user = null ;  try  {  address = address factory . create address ( to number )  ;  sipuri =  (  sipuri ) address . geturi (  )  ;  host = sipuri . get host (  )  ;  user = sipuri . get user (  )  ;   }  catch  (   parse exception e )   {   logger . println ( "parse exception: "  +  to number  +  " sip uri " +  sipuri +  " host " +  host +  " user " +  user )  ;   }  if  (  logger . log level  >  =   logger . log   sip )   {   logger . println ( "address: "  +  address )  ;   logger . println ( "sipuri: "  +  sipuri )  ;   logger . println ( "host: "  +  host )  ;   logger . println ( "user: "  +  user )  ;   }  if  (  sip server . get send sip uri to proxy (  )   =  =  false && user  !  =  null )   {   inet address inet address ;  try  {  inet address =  inet address . get by name ( host )  ;  voip gateway = host ;  int port = sipuri . get port (  )  ;  if  ( port  >  0 )   {  to sip port = port ;   }  to number = user ;   logger . println ( " call "  +  cp  +  "  sending invite directly to " +  inet address +  ":" +  to sip port )  ;   }  catch  (   unknown host exception e )   {  voip gateway = proxy ;   logger . println ( " call "  +  cp  +  "  using proxy " +  proxy +  " for " +  to number )  ;  to number = to number . substring ( 4 )  ;   }   }  else  {  voip gateway = proxy ;   logger . println ( " call "  +  cp  +  "  using proxy " +  proxy +  " for " +  to number )  ;  to number = to number . substring ( 4 )  ;   }   }  else  {  transport =  system . get property ( "com . sun . voip . server . protocol" )  ;  if  ( to number . index of ( "tel:" )   =  =  0 )   {  to number = to number . substring ( 4 )  ;   }  voip gateway = proxy ;   logger . println ( " call "  +  cp  +  "  using proxy " +  proxy +  " for " +  to number )  ;   }  if  ( to number . index of ( "@" )   <  0 &&  call handler . enablepstn calls (  )   =  =  false )   {  throw new  sip exception ( "pstn calls are not allowed: "  +  cp )  ;   }   array list <  proxy credentials >  proxy credential list =  sip server . get proxy credentials (  )  ;  boolean gateway required = false ;  if  ( voip gateway  =  =  null )   {  if  ( proxy  =  =  null )   {  if  ( proxy credential list . size (  )   =  =  0 )   {   logger . println ( " call "  +  cp  +  " no voip gateway is available ! " )  ;  throw new  sip exception ( " no voip  gateway !  "  +  cp )  ;   }  else gateway required = true ;   }  else  {  voip gateway = proxy ;  gateway required = true ;   }   }  else  {  if  ( voip gateway . equals ( proxy )  )  gateway required = true ;   }  if  ( gateway required )   {   logger . println ( "xxxx gateway required" )  ;  if  ( proxy credential list . size (  )   !  =  0 )   {   logger . println ( "xxxx gateway required 1" )  ;  int voip index = 0 ;  for  ( int i = 0 ;  i  <  proxy credential list . size (  )  ;  i +  +  )   {   proxy credentials proxy credentials = proxy credential list . get ( i )  ;  if  ( voip gateway . equals ( proxy credentials . get name (  )  )  )   {  voip index = i ;   }   }   proxy credentials proxy credentials = proxy credential list . get ( voip index )  ;  voip gateway = proxy credentials . get host (  )  ;  ob proxy = proxy credentials . get proxy (  )  ;  from address = address factory . create sipuri ( from name voip gateway )  ;   }  else  {   logger . println ( "xxxx gateway required 2" )  ;   }   logger . println ( "xxxx gateway required 3" )  ;  to address = address factory . create sipuri ( to number voip gateway )  ;   }  else  {   logger . println ( "xxxx gateway required 4" )  ;   logger . println ( "from number "  +  from number )  ;  if  ( from number . starts with ( "sip:" )  )  from address =  (  sipuri ) address factory . create address ( from number )  . geturi (  )  ;  else from address = address factory . create sipuri ( from number our ip address )  ;  from address . set port ( our sip port )  ;  to address = address factory . create sipuri ( to number voip gateway )  ;   }   logger . println ( "xxxx gateway required 5" )  ;   logger . println ( "from "  +  from address )  ;   logger . println ( "to "  +  to address )  ;  from name address = address factory . create address ( from name from address )  ;  from header = header factory . create from header ( from name address new  integer (  ( int )  (  math . random (  )  * 10000 )  )  . to string (  )  )  ;   logger . println ( "xxxx gateway required 6" )  ;  if  (  bridge . get private host (  )  . starts with ( "127 . " )  && voip gateway . equals ( "127 . 0 . 0 . 1" )   =  =  false )   {  throw new  sip exception ( " the bridge's ip address is "  +   bridge . get private host (  )   +  " .   it is not possible to initiate a call to " +  voip gateway )  ;   }  if  (  bridge . get private host (  )  . starts with ( "127 . " )   =  =  false && voip gateway . starts with ( "127 . " )   =  =  true )   {  throw new  sip exception ( " the bridge's ip address must be "  +   bridge . get private host (  )   +  " in order to issue a call to " +  voip gateway )  ;   }   logger . write file ( " call "  +  cp  +  " voip gateway  /  proxy " +  voip gateway +  " port " +  to sip port )  ;  to name address = address factory . create address ( to number to address )  ;  to header = header factory . create to header ( to name address null )  ;  int ix = to number . index of ( "@" )  ;  if  ( ix  >  =  0 )   {  to number = to number . substring ( 0 ix )  ;   }   logger . println ( "xxxx gateway required 7" )  ;  requesturi = address factory . create sipuri ( to number voip gateway )  ;  requesturi . set port ( to sip port )  ;  requesturi . set transport param ( sip provider . get listening point ( transport )  . get transport (  )  )  ;  via header = header factory . create via header ( our ip address our sip port sip provider . get listening point ( transport )  . get transport (  )  null )  ;  via headers = new  array list (  )  ;  via headers . add ( via header )  ;  call id header = sip provider . get new call id (  )  ;  c seq header = header factory . createc seq header ( 1  request . invite )  ;   max forwards header max forwards = header factory . create max forwards header ( 70 )  ;  invite = message factory . create request ( requesturi  request . invite call id header c seq header from header to header via headers max forwards )  ;   logger . println ( "xxxx gateway required 10" )  ;  if  (  sdp manager . use telephone event (  )   =  =  true )   {  allow events header = header factory . create allow events header ( "telephone - event" )  ;  invite . add header ( allow events header )  ;   }   sipuri contacturi = null ;  if  ( from number . starts with ( "sip:" )  )  contacturi =  (  sipuri ) address factory . create address ( from number )  . geturi (  )  ;  else contacturi = address factory . create sipuri ( from number our public ip address )  ;   logger . println ( "xxxx gateway required 12" )  ;  contacturi . set port ( our public sip port )  ;   address contact address = address factory . create address ( contacturi )  ;  contact address . set display name ( from name )  ;   contact header contact header = header factory . create contact header ( contact address )  ;  invite . add header ( contact header )  ;   logger . println ( "xxxx gateway required 14" )  ;  if  ( ob proxy  !  =  null )   {  try  {   sipuri routeuri =  (  sipuri ) address factory . createuri ( "sip:"  +  ob proxy  +  " ; lr" )  ;   route header route header = header factory . create route header ( address factory . create address ( routeuri )  )  ;  invite . add header ( route header )  ;   }  catch  (   exception e )   {   logger . error ( " creating registration route error "  +  e )  ;   }   }   logger . println ( "xxxx gateway required 16" )  ;  if  ( cp . is auto answer (  )  )   {   logger . println ( " call "  +  cp  +  " alert - info added" )  ;  try  {  sip alert info alert info = new sip alert info (  )  ;  alert info . set name pair ( "info = alert - autoanswer" )  ;  invite . add header ( alert info )  ;   }  catch  (   exception e )   {   logger . error ( " creating alert info error "  +  e )  ;   }   }   logger . println ( "xxxx gateway required 18" )  ;  if  ( sdp  !  =  null )   {  content type header = header factory . create content type header ( "application" "sdp" )  ;  invite . set content ( sdp content type header )  ;   }   client transaction client transaction ;   logger . write file ( " invite\n"  +  invite )  ;  try  {  client transaction = sip provider . get new client transaction ( invite )  ;   }  catch  (   exception e )   {   logger . println ( " call "  +  cp  +  " send invite failed: " +  e . get message (  )  )  ;  return null ;   }   logger . println ( "xxxx gateway required 19" )  ;  client transaction . send request (  )  ;   logger . println ( "xxxx gateway required 20" )  ;  return client transaction ;   }  
@ override public  object   (  cluster task task byte[] nodeid )  {  throw new  illegal state exception ( " cluster service is not available" )  ;   }  
@ override public  command[]   (  )  {  return new  command[] { new  auth token and roles remover (  )  new  auth groups remover (  )  new  rate limits remover (  )  }  ;   }  
void   ( final int index final double value final int count )  throws io exception  {  assert index  +  count  <  =  length : " invalid robin index supplied: index = "  +  index  +  "  count = " +  count +  "  length = " +  length ;  write double ( index value count )  ;   }  
public jid   (  string roomname  string username )  {  if  (  jive globals . get boolean property ( "plugin . gateway . tweak . percenthack" false )  )   {  return new jid ( roomname . replace ( '@' '%' )  . replace ( " " "" )  this . jid . get domain (  )  username )  ;   }  else  {  return new jid ( jid . escape node ( roomname . replace ( " " "" )  )  this . jid . get domain (  )  username )  ;   }   }  
public  query   (  string sql )  {  return new  query ( this sql )  ;   }  
public long   (  )  {  return    clock skew ;   }  
@ test public void   (  )  throws  exception  {  final int sz = 256 ;   test input stream tis = new  test input stream ( sz )  ;   data helper . skip ( tis sz )  ;  try  {   data helper . skip ( tis 1 )  ;  fail (  )  ;   }  catch  (  io exception ioe )  
public  data structure   (  )  throws  data format exception  {   tunnel id id = new  tunnel id (  )  ;  id . set tunnel id ( 42 )  ;  return id ;   }  
void   (  string secret )  {  this . secret = secret ;   }  
@ override public boolean   (  string hostname  destination d  properties options )  {  if  (  !    is version4 )  return put if absent ( hostname d options )  ;   list <  properties >  stored options = new  array list <  properties >  ( 4 )  ;  synchroni
@ test public void   (  )  {   string test = uuid . randomuuid (  )  . to string (  )  ;   encryptor encryptor = new  blowfish (  )  ;   string b64 encrypted = encryptor . encrypt ( test )  ;  assert false ( test . equals ( b64 encrypted )  )  ;  assert e
@ test public void   (  )  {  int num =  ( int )  (  flowable . buffer size (  )  * 2 . 1 )  ;   atomic integer c = new  atomic integer (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  incrementing integers ( c )  .
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ override public  string   (  )  {   string column = get column ( key   column   tuple   index )  ;  if  ( column  =  =  null )   {  return this . registry . get (  map entry mappers . class )  . get key column (  )  ;   }  return column ;   }  
@ override public final void   (  )  {  s . cancel (  )  ;   }  
private static void   (  file log file )  {   buffered writer out = null ;  try  {  out = new  buffered writer ( new  file writer ( log file )  )  ;  out . write ( "" )  ;   }  catch  (  io exception ex )   {   log . warn ( " could not empty file "  +  log file . get name (  )  ex )  ;   }  finally  {  if  ( out  !  =  null )   {  try  {  out . close (  )  ;   }  catch  (  io exception ex )   {   log . warn ( " could not close file . " ex )  ;   }   }   }   }  
public byte[]   (  )  {  return five prime read order bytes ;   }  
public  string   (  )  {  return name ;   }  
public static final  string   (  color c )  {  int color = c . getrgb (  )  ;  color| = 0xff000000 ;   string s =  integer . to hex string ( color )  ;  return s . substring ( 2 )  ;   }  
@ override public void   (  )  {  d . dispose (  )  ;  d =  disposable helper . disposed ;  dispose resource after (  )  ;   }  
@ override public void   ( long n )  {  if  (  subscription helper . validate ( n )  )   {   backpressure helper . add ( this n )  ;   }   }  
int   (  )  {  return    rows ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
@ deprecated public void   ( int port )  {  set port (  connection type . connection   manager true port )  ;   }  
@ check return value @ non null public static  < t >  behavior subject < t >    ( t default value )  {  return new  behavior subject < t >  ( default value )  ;   }  
@ test public void   (  )  {  check backpressure support (  flowable . class )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  integer >  source =  publish subject . create (  )  ;   observable <  timed <  integer >  >  m = source . timestamp ( scheduler )  ;  m . subscribe 
  ( final boolean primary final boolean filtered final int mapq )  {  this . primary = primary ;  this . filtered = filtered ;  this . mapq = mapq ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   test observer <  integer >  to =  maybe . just ( 1 )  . delay subscription ( 100  time unit . milliseconds scheduler )  . test (  )  ;  to . assert empty (  )  ;  sche
public void   ( int family boolean pending )  {  pending snacs . set pending ( family pending )  ;   }  
@ deprecated @ override public void   ( boolean on )  {  throw new  unsupported operation exception (  )  ;   }  
private static final  string   (  string pattern int num )  {  char c[] = pattern . to char array (  )  ;   string builder buf = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  c . length ;  i +  +  )   {  if  (  ( c[i]  !  =  '#' )  &&  ( c[i]  !  =  '@' )  )  buf . append ( c[i] )  ;  else buf . append ( num )  ;   }  return buf . to string (  )  ;   }  
@ override public void   ( final  subscriber <  ?  super  long >  subscriber )  {  subscriber . on subscribe ( new  subscription (  )  {  final  atomic boolean completed = new  atomic boolean ( false )  ;  @ override public void request (  long n )  {  if
public long   (  )  {  return iq get . get (  )  ;   }  
  (  jdbi db  handle handle )  {  this . db = db ;  this . handle = handle ;   }  
@ override public boolean   ( int pos )  {  if  ( pos  >  =  get count (  )  || pos  <   - 1 )   {  return false ;   }  m position = pos ;  return true ;   }  
public void   (  timer task task )  {   task engine .  timer task wrapper task wrapper ;  synchronized  ( wrapped tasks )   {  task wrapper = wrapped tasks . remove ( task )  ;   }  if  ( task wrapper  !  =  null )   {  task wrapper . cancel (  )  ;  task . cancel (  )  ;   }   }  
public void   (  workgroup workgroup )  {  boolean added = false ;  boolean already joined = workgroups . contains ( workgroup )  ;  if  (  ! already joined )   {  added = workgroups . add ( workgroup )  ;   }  for  (   request queue request queue : workgroup . get request queues (  )  )   {  if  ( request queue . is member ( get agent (  )  )  )   {  if  ( added )   {  request queue . get agent session list (  )  . add agent session ( this )  ;   }  request queue . send status ( getjid (  )  )  ;  request queue . send detailed status ( getjid (  )  )  ;   }   }  update status ( workgroup )  ;  if  ( added )   {  workgroup . agent joined ( this )  ;  chat infos . put ( workgroup new  concurrent linked queue <  chat info >  (  )  )  ;   }   }  
private static  file   (  file conf dir byte[] ih )  {   string hex = i2p snark util . to hex ( ih )  ;   file subdir = new  secure directory ( conf dir subdir   prefix  +  b64 . char at (  ( ih[0]  >  >  2 )  & 0x3f )  )  ;  return new  file ( subdir hex  +  comment   file   suffix )  ;   }  
public static boolean   (  string st )  {  return st  =  =  null || st . length (  )   =  =  0 ;   }  
@ test public void   (  )  {  final  function <  integer  integer >  dbl = new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer t1 )  {  return t1 * 2 ;   }   }   ;   function <  observable <  integer >   observable <
@ test public void   (  )  {  final  test exception ex = new  test exception (  )  ;  final  test exception ex2 = new  test exception (  )  ;  for  ( int i = 0 ;  i  <   test helper . race   long   loops ;  i +  +  )   {   list <  throwable >  errors =  t
private   (  string service root href  string version id  string resource )  {  this . service root href = service root href ;  this . version id = version id ;  this . resource = resource ;   }  
@ override public  string value   (  patch patch )  {   string original value = value ;  value = value  +  patch . new from patch (  )  . get value (  )  ;  return new  string value ( original value  +  patch . new from patch (  )  . get value (  )  )  ; 
@ override public  collection <  string >    (  )  {  return  collections . unmodifiable collection ( ignore list )  ;   }  
public void   ( int v )  throws io exception  {  delegate . write byte ( v )  ;   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   subject <  integer >  ps =  publish subject .  <  integer > create (  )  ;   test observer <  observable <  integer >  >  to = ps . window ( 5  time unit . millisecond
public int   ( final  bait bias detail metrics o )  {  int retval =  double . compare ( qscore o . qscore )  ;  if  ( retval  !  =  0 )  return retval ;  retval = ref   base  -  o . ref   base ;  if  ( retval  !  =  0 )  return retval ;  retval = alt   base  -  o . alt   base ;  if  ( retval  !  =  0 )  return retval ;  retval = context . compare to ( o . context )  ;  return retval ;   }  
private static boolean   ( final  list < android . accounts .  account >  accounts final  string name final  string type )  {  for  (  final android . accounts .  account account : accounts )   {  if  ( account . name . equals ignore case ( name )  && account . type . equals ignore case ( type )  )   {  return true ;   }   }  return false ;   }  
@ override public void   (  observer <  ?  super  integer >  sub )  {   disposable d =  disposables . empty (  )  ;  sub . on subscribe ( d )  ;  for  ( int i = 1 ;   ! d . is disposed (  )  ;  i +  +  )   {  count . increment and get (  )  ;  sub . on ne
public void   (  )  {  throw new  unsupported operation exception (  )  ;   }  
@ nullable @ override public t   (  )  throws  exception  {  t v ;  try  {  v = qs . poll (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  try  {  on error . accept ( ex )  ;   }  catch  (   throwable exc )   {  throw ne
private  roster   (  string username )  throws  service exception  {  try  {  return roster manager . get roster ( username )  ;   }  catch  (   user not found exception e )   {  throw new  service exception ( " could not get user roster" username  exception type . user   not   found   exception  response .  status . not   found e )  ;   }   }  
private boolean   (  )  {  if  ( cp . get protocol (  )   !  =  null &&  ( " web rtc" . equals ( cp . get protocol (  )  )  || " rtmfp" . equals ( cp . get protocol (  )  )  || " speaker" . equals ( cp . get protocol (  )  )  )  )   {  return false ;   }  if  (  rtp socket . get rtp timeout (  )   =  =  0 )   {  return false ;   }   string phone number = cp . get phone number (  )  ;  if  ( phone number  !  =  null && phone number . index of ( "6666@" )   >  =  0 )   {  return false ;   }  if  ( cp . is distributed bridge (  )   =  =  true || phone number . index of ( "sip:" )   <  0 || phone number . index of ( "tel:" )   <  0 )   {  return false ;   }  long rtp elapsed ;  if  ( time current packet received  =  =  0 )   {  rtp elapsed = 0 ;   }  else  {  rtp elapsed =  (  system . current time millis (  )   -  time current packet received )   /  1000 ;   }  long rtcp elapsed = rtcp receiver . seconds since last report ( member . get rtcp address (  )  )  ;  if  ( rtcp elapsed  <   rtp socket . get rtp timeout (  )  || rtp elapsed  <   rtp socket . get rtp timeout (  )  )   {  return false ;   }   logger . println ( " call "  +  cp  +  " time since last rtcp report " +  rtcp elapsed +  " time since last rtp packet received " +  rtp elapsed )  ;   logger . println ( " call "  +  cp  +  ":  timeout  cancelling the call .  .  . " )  ;  call handler . cancel request ( "call timeout  no keepalive received" )  ;  call cancelled = true ;  return true ;   }  
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   observable . wrap ( new  observable source <  object >  (  )  {  @ override public void subscribe (   observer <  ?  super  object >  s )  { 
@ test public void   (  )  {   observable . range ( 1 10 )  . flat map completable ( new  function <  integer  completable source >  (  )  {  @ override public  completable source apply (   integer v )  throws  exception  {  return  completable . complete
@ test public void   (  )  {  assert equals (  - 1  string uri utilities . index of uri fragment ( " / versioned / v12 / requested / uri" " / v1" )  )  ;   }  
public void   ( int quota )  {   offline message strategy . quota = quota ;   jive globals . set property ( "xmpp . offline . quota"  integer . to string ( quota )  )  ;   }  
 genericgf poly   (  genericgf poly other )  {  if  (  ! field . equals ( other . field )  )   {  throw new  illegal argument exception ( " genericgf polys do not have same  genericgf field" )  ;   }  if  ( is zero (  )  )   {  return other ;   }  if  ( other . is zero (  )  )   {  return this ;   }  int[] smaller coefficients = this . coefficients ;  int[] larger coefficients = other . coefficients ;  if  ( smaller coefficients . length  >  larger coefficients . length )   {  int[] temp = smaller coefficients ;  smaller coefficients = larger coefficients ;  larger coefficients = temp ;   }  int[] sum diff = new int[larger coefficients . length] ;  int length diff = larger coefficients . length  -  smaller coefficients . length ;   system . arraycopy ( larger coefficients 0 sum diff 0 length diff )  ;  for  ( int i = length diff ;  i  <  larger coefficients . length ;  i +  +  )   {  sum diff[i] =  genericgf . add or subtract ( smaller coefficients[i  -  length diff] larger coefficients[i] )  ;   }  return new  genericgf poly ( field sum diff )  ;   }  
@ test public void   (  )  {   maybe . concat ( new  crashing mapped iterable <  maybe <  integer >  >  ( 100 100 1 new  function <  integer  maybe <  integer >  >  (  )  {  @ override public  maybe <  integer >  apply (   integer v )  throws  exception  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  disposable[] disposable =  { null }  ;   observable . from array (  observable . just ( 1 )   observable . just ( 2 )  )  . hide (  )  . concat map (  functions .  <  observable <  
public  simple date format   (  )  {  return    date format ;   }  
public  destination   (  )  {  return dummy   dest ;   }  
public void   (  )  throws  exception  {  if  ( server  !  =  null && server . is started (  )  )   {  server . stop (  )  ;   }   }  
@ test public void   (  )  throws  exception  {  final  collection <  string >  result =  encryption artifact factory . get supported protocols (  )  ;   assert . assert false ( result . is empty (  )  )  ;   }  
@ override public  string   (  string v )  {  return v ;   }  
private boolean   (  destination dest int from port int to port long timeout )  throws i2p exception  {  try  {  synchronized  ( simul lock )   {  while  ( simul pings  >  =  max   simul   pings )   {  simul lock . wait (  )  ;   }  simul pings +  +  ;  while  ( last ping time  +  ping   distance  >   system . current time millis (  )  )   {   thread . sleep ( ping   distance  /  2 )  ;   }  last ping time =  system . current time millis (  )  ;   }  boolean sent = sock mgr . ping ( dest from port to port timeout )  ;  synchronized  ( simul lock )   {  simul pings -  -  ;  simul lock . notify all (  )  ;   }  return sent ;   }  catch  (   interrupted exception ex )   {     log . error ( " interrupted" ex )  ;  return false ;   }   }  
public int   (  )  {  return executor . get core pool size (  )  ;   }  
@ override public boolean   (  object o )  {  if  ( this  =  =  o )  return true ;  if  ( o  =  =  null || get class (  )   !  =  o . get class (  )  )  return false ;   user user =  (  user ) o ;  return id  =  =  user . id &&  objects . equals ( name us
@ test public void   (  )  {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {   observable . wrap ( new  observable source <  object >  (  )  {  @ override public void subscribe (   observer <  ?  super  object >  s )  { 
  ( u b )  {  this . b = b ;   }  
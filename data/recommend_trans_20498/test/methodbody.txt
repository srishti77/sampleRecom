private static void   (  page context pc )  {  pc . get query cache (  )  . clear ( pc )  ;   }  
public final void   (  object key )  {  this . key = key ;   }  
public void   ( boolean thread )  throws  application exception  {  if  ( thread )  return ;   deprecated util . tag attribute ( page context " log" "thread" )  ;  throw new  application exception ( "attribute [thread] for tag [log] is deprecated  only the value true is allowed" )  ;   }  
@ override public void   ( int index  object element )  {  list . add ( index element )  ;   }  
public  string   (  )  throws  bytecode exception  {  return translate variable to string ( expr false )  ;   }  
private  string   (  )  throws  servlet exception  {  url res = new tp (  )  . get class (  )  . get resource ( " / core / core . rcs" )  ;  if  ( res  !  =  null )  return "rcs" ;  res = new tp (  )  . get class (  )  . get resource ( " / core / core . rc" )  ;  if  ( res  !  =  null )  return "rc" ;  throw new  servlet exception ( "missing core file" )  ;   }  
@ override public  object   (  page context pc  object[] args )  throws  page exception  {  return call ( pc  caster . to array ( args[0] )   caster . to double value ( args[ 1 ] )  )  ;   }  
public  string   (  )  {  if  ( case   lower  =  =     case )  return get string (  )  ;  return raw . to lower case (  )  ;   }  
public void   (  string displayname )  {  this . displayname = displayname ;   }  
public  generator adapter   (  )  {  return adapter ;   }  
@ override public void   ( int parameter index  reader reader long length )  throws sql exception  {  stat . set clob ( parameter index reader length )  ;   }  
private void   (  )  throws  page exception  {  try  {  page context . set variable ( get string ( "admin" action "return variable" )   caster . to array (  (  (  config server impl ) config )  . get installed patches (  )  )  )  ;   }  catch  (   exception e )   {  throw  caster . to page exception ( e )  ;   }   }  
public static boolean   (  page context pc  array array double index )  {  return array . get (  ( int ) index  null support helper . null (  )  )   !  =   null support helper . null (  )  ;   }  
private static boolean   (  class left  class right )  {  if  ( left  =  =  right )  return true ;  return left . equals ( right . get name (  )  )  ;   }  
void   (  )  throws io exception   page exception  {  page context . force write ( " < input" )  ;   iterator <  entry <  key  object >  >  it = attributes . entry iterator (  )  ;   entry <  key  object >  e ;  while  ( it . has next (  )  )   {  e = it . next (  )  ;  page context . force write ( " " )  ;  page context . force write ( e . get key (  )  . get string (  )  )  ;  page context . force write ( " = \"" )  ;  page context . force write ( enc (  caster . to string ( e . get value (  )  )  )  )  ;  page context . force write ( "\"" )  ;   }  if  ( passthrough  !  =  null )   {  page context . force write ( " " )  ;  page context . force write ( passthrough )  ;   }  page context . force write ( " > " )  ;   }  
@ override public boolean   (  )  {  return  system util . is windows (  )  ;   }  
private static  string   (  expression expr boolean raw if possible )  throws  bytecode exception  {  if  (  !  ( expr instanceof  variable )  )  throw new  bytecode exception ( "can't translate value to a string" expr . get start (  )  )  ;  return variable to string (  (  variable ) expr raw if possible )  ;   }  
public static void   (  page context pc  resource dir  string cache name )  throws io exception  {   cache cache =  util . get cache ( pc cache name  config impl . cache   default   template null )  ;  if  ( cache  !  =  null )   cache item cache .    flush all ( pc cache )  ;  else  cache itemfs .    flush all ( pc dir )  ;   }  
public int   (  string gateway id )  throws  page exception  {  return get gateway ( gateway id )  . get state (  )  ;   }  
private void   (  )  {  boolean set cookie = true ;   object o cfid = url scope (  )  . get (  key constants .    cfid null )  ;   object o cftoken = url scope (  )  . get (  key constants .    cftoken null )  ;  if  (  ( o cfid  =  =  null ||  !  decision . isgu id simple ( o cfid )  )  || o cftoken  =  =  null )   {  set cookie = false ;  o cfid = cookie scope (  )  . get (  key constants .    cfid null )  ;  o cftoken = cookie scope (  )  . get (  key constants .    cftoken null )  ;   }  if  ( o cfid  !  =  null &&  !  decision . isgu id simple ( o cfid )  )   {  o cfid = null ;   }  if  ( o cfid  =  =  null || o cftoken  =  =  null )   {  set cookie = true ;  cfid =  scope context . get newcf id (  )  ;  cftoken =  scope context . get newcf token (  )  ;   }  else  {  cfid =  caster . to string ( o cfid null )  ;  cftoken =  caster . to string ( o cftoken null )  ;   }  if  ( set cookie && application context . is set client cookies (  )  )  set client cookies (  )  ;   }  
@ override public  result set   (  string sql )  throws sql exception  {  return stat . execute query ( sql )  ;   }  
public static  object   (  object o  object default value )  {   string str = to string ( o null )  ;  if  ( str  =  =  null )  return default value ;  if  (  !  decision . isuu id ( str )  )  return default value ;  return str ;   }  
private static void   (  component cfc  property prop  document doc  struct meta  element el  session factory data data )  throws  page exception  {   string strategy = to string ( cfc prop meta "cacheuse" data )  ;  if  (  !  util . is empty ( strategy true )  )   {  strategy = strategy . trim (  )  . to lower case (  )  ;  if  ( "read - only" . equals ( strategy )  || "nonstrict - read - write" . equals ( strategy )  || "read - write" . equals ( strategy ) || "transactional" . equals ( strategy )  )   {   element cache = doc . create element ( "cache" )  ;   common util . set first ( el cache )  ;  el . append child ( cache )  ;  cache . set attribute ( "usage" strategy )  ;   string name = to string ( cfc prop meta "cache name" data )  ;  if  (  !  util . is empty ( name true )  )   {  cache . set attribute ( "region" name )  ;   }   }  else throw  exception util . create exception ( data cfc "invalid value ["  +  strategy  +  "] for attribute [cacheuse]  valid values are [read - only nonstrict - read - write read - write transactional]" null )  ;   }   }  
@ override public double   ( double default value )  {  return default value ;   }  
public void   (  colormap colormap )  {  this . colormap = colormap ;   }  
public  string   (  attribute attr  type type )  {  if  ( tag lib . is core (  )  )  return "set"  +   string util . uc first ( attr . get name (  )  )  ;   string setter = setters . get ( attr . get name (  )  )  ;  if  ( setter  !  =  null )  return setter ;  setter = "set"  +   string util . uc first ( attr . get name (  )  )  ;   class clazz ;  try  {  if  ( type  =  =  null )  type =  cast other . get type ( attr . get type (  )  )  ;  clazz =  class util . load class ( get tag class name (  )  )  ;  java . lang . reflect .  method m =  class util . get method ignore case ( clazz setter new  class[] {  class util . load class ( type . get class name (  )  )  }  )  ;  setter = m . get name (  )  ;   }  catch  (   exception e )   {  e . print stack trace (  )  ;   }  setters . put ( attr . get name (  )  setter )  ;  return setter ;   }  
public void   (  object oudf )  throws  page exception  {  this . onmissingtemplate =  caster . to function ( oudf )  ;   }  
private final boolean   (  )  {  if  ( jj   scan   token (  8  2  )  )  return true ;  return jj   la  !  =  0 || jj   scanpos  !  =  jj   lastpos  ?  false : false ;   }  
public void   ( boolean preloader )  {  this . preloader = preloader ;   }  
@ override public  string   (  )  throws  page exception  {  return  caster . to string ( cast to double value (  )  )  ;   }  
@ override public long   (  )  {  return timeout ;   }  
public  rectangle 2 d   (  buffered image src )  {   rectangle r = new  rectangle ( 0 0 src . get width (  )  src . get height (  )  )  ;  if  ( add margins )   {  float x offset = distance *  ( float )  math . cos ( angle )  ;  float y offset =  - distance *  ( float )  math . sin ( angle )  ;  r . width +  =  ( int )  (  math . abs ( x offset )   +   2  * radius )  ;  r . height +  =  ( int )  (  math . abs ( y offset )   +   2  * radius )  ;   }  return r ;   }  
public void   (  struct mappings )  throws  page exception  {  this . mappings =  app listener util . to mappings ( page context . get config (  )  mappings get source (  )  )  ;   }  
public  struct   (  )  {  return attributes scope ;   }  
private ftp client   (  )  throws io exception   page exception  {  required ( "remotefile" remotefile )  ;  required ( "localfile" localfile )  ;  ftp client client = get client (  )  ;   resource local =  resource util . to resource existing ( page context localfile )  ;   input stream is = null ;  try  {  is = io util . to buffered input stream ( local . get input stream (  )  )  ;  client . set file type ( get type ( local )  )  ;  client . store file ( remotefile is )  ;   }  finally  {  io util . closeel ( is )  ;   }  write cfftp ( client )  ;  return client ;   }  
public void   ( boolean use time )  throws  application exception  {  if  ( use time )  return ;   deprecated util . tag attribute ( page context " log" "time" )  ;  throw new  application exception ( "attribute [time] for tag [log] is deprecated  only the value true is allowed" )  ;   }  
public static boolean   (  object value boolean also booleans )  {  if  (  ! also booleans && value instanceof  boolean )  return false ;  double dbl =  caster . to double value ( value  double .  nan )  ;  if  (  !  decision . is valid ( dbl )  )  return false ;  int i =  ( int ) dbl ;  return i  =  =  dbl ;   }  
public void   ( double margintop )  {  get document (  )  . set margintop ( margintop )  ;   }  
private static  object   (  type mapping tm  time zone tz q name type  object value  class target class  set <  object >  done )  throws  page exception  {  if  ( done . contains ( value )  )   {  return null ;   }  done . add ( value )  ;  try  {  if  ( type  !  =  null )   {  for  ( int i = 0 ;  i  <   constants . uris   schema   xsd . length ;  i +  +  )   {  if  (  constants . uris   schema   xsd[i] . equals ( type . get namespaceuri (  )  )  )   {  return to axis typexsd ( tm tz type value target class done )  ;   }   }  if  ( type . get namespaceuri (  )  . index of ( "soap" )   !  =   -  1  )   {  return to axis type soap ( tm type value target class done )  ;   }  if  ( type . get local part (  )  . equals ( " array of   xsd   any type" )  )  return to array list ( tm value target class done )  ;   }  return    to axis type sub ( tm value target class done )  ;   }  finally  {  done . remove ( value )  ;   }   }  
public void   (  object value )  {  param . set value ( value )  ;   }  
@ override public  date   (  )  {  return new  date ( modifed )  ;   }  
public void   (  string value )  {  value = value . to lower case (  )  . trim (  )  ;  this . has body =  ! value . equals ( "empty" )  ;  this . is body req =  ! value . equals ( "free" )  ;  this . is tag dependent = value . equals ( "tagdependent" )  ;  body free = value . equals ( "free" )  ;   }  
@ override public  string   (  )  {  return  lazy converter . serialize ( this )  ;   }  
public static void   (  bytecode context bc  statement s  string id )  {  call    log ( bc start s . get start (  )  id )  ;   }  
@ override public void   (  body tag body tag int state )  {  if  ( body tag instanceof  try catch finally )   {   (  (  try catch finally ) body tag )  . do finally (  )  ;   }  if  ( state  !  =   tag . eval   body   include )  pop body (  )  ;   }  
@ override public  string   (  )  {  return "variables" ;   }  
public static asm property[]   (  property[] properties )  {  asm property[] asmp = new asm property[properties . length] ;  for  ( int i = 0 ;  i  <  asmp . length ;  i +  +  )   {  asmp[i] =  ( asm property ) properties[i] ;   }  return asmp ;   }  
private static void   (  config server impl config server  config impl config  document doc )  {  boolean has access =  config web util . has access ( config  security manager . type   cfx   setting )  ;   map <  string cfx tag class >  map =  map factory .  <  string cfx tag class > get concurrent map (  )  ;  if  ( config server  !  =  null )   {  try  {  if  ( config server . getcfx tag pool (  )   !  =  null )   {   map <  string cfx tag class >  classes = config server . getcfx tag pool (  )  . get classes (  )  ;   iterator <  entry <  string cfx tag class >  >  it = classes . entry set (  )  . iterator (  )  ;   entry <  string cfx tag class >  e ;  while  ( it . has next (  )  )   {  e = it . next (  )  ;  map . put ( e . get key (  )  e . get value (  )  . clone read only (  )  )  ;   }   }   }  catch  (   security exception e )   {   }   }  if  ( has access )   {  if  ( config server  =  =  null )   {   system . set property ( "cfx . bin . path" config . get config dir (  )  . get real resource ( "bin" )  . get absolute path (  )  )  ;   }   element cfx tags parent = get child by name ( doc . get document element (  )  "ext - tags" false true )  ;  if  ( cfx tags parent  =  =  null )  cfx tags parent = get child by name ( doc . get document element (  )  "cfx - tags" false true )  ;  if  ( cfx tags parent  =  =  null )  cfx tags parent = get child by name ( doc . get document element (  )  "ext - tags" )  ;  boolean old style = cfx tags parent . get node name (  )  . equals ( "cfx - tags" )  ;   element[] cfx tags = old style  ?  get children ( cfx tags parent "cfx - tag" )  : get children ( cfx tags parent "ext - tag" )  ;  for  ( int i = 0 ;  i  <  cfx tags . length ;  i +  +  )   {   string type = cfx tags[i] . get attribute ( "type" )  ;  if  ( type  !  =  null )   {  if  ( type . equals ignore case ( "java" )  )   {   string name = cfx tags[i] . get attribute ( "name" )  ;   string clazz = cfx tags[i] . get attribute ( "class" )  ;  if  (  !  string util . is empty ( name )  &&  !  string util . is empty ( clazz )  )   {  map . put ( name . to lower case (  )  new  javacfx tag class ( name clazz )  )  ;   }   }  else if  ( type . equals ignore case ( "cpp" )  )   {   string name = cfx tags[i] . get attribute ( "name" )  ;   string server library = cfx tags[i] . get attribute ( "server - library" )  ;   string procedure = cfx tags[i] . get attribute ( "procedure" )  ;  boolean keep alive =  caster . to boolean value ( cfx tags[i] . get attribute ( "keep - alive" )  false )  ;  if  (  !  string util . is empty ( name )  &&  !  string util . is empty ( server library )  &&  !  string util . is empty ( procedure )  )   {  map . put ( name . to lower case (  )  new cppcfx tag class ( name server library procedure keep alive )  )  ;   }   }   }   }   }  config . setcfx tag pool ( map )  ;   }  
public   (  string message )  {  super ( message )  ;   }  
public  big decimal   (  string column name )  throws sql exception  {  return rst . get big decimal ( column name )  ;   }  
public void   (  string preview )  {  this . preview = preview ;   }  
public  member   ( int access  key key boolean data member boolean super access )  {  return component . get member ( access key data member super access )  ;   }  
@ override public  object   (  page context pc )  throws  page exception  {  return get value ( pc )  ;   }  
public   (  connection proxy conn  callable statement prepare call  string sql )  {  super ( conn prepare call sql )  ;   }  
public boolean   (  )  {  return    current  >     to ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " low level" )  )  )   !  =  null )  set low level (  image filter util . to float value ( o " low level" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " high level" )  )  )   !  =  null )  set high level (  image filter util . to float value ( o " high level" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " low output level" )  )  )   !  =  null )  set low output level (  image filter util . to float value ( o " low output level" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " high output level" )  )  )   !  =  null )  set high output level (  image filter util . to float value ( o " high output level" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ low level   high level   low output level   high output level]" )  ;   }  return filter ( src dst )  ;   }  
public void   (  object input )  {  this . input = input ;   }  
public   (  string message )  {  super ( message )  ;   }  
public static  video executer   (  config config )  throws  class exception  {   class clazz = config . get video executer class (  )  ;  return  (  video executer )  class util . load instance ( clazz )  ;   }  
public  string   (  )  {  return " distort /  displace .  .  . " ;   }  
public void   ( boolean select )  {  this . select = select ;   }  
public  intervall monitor[]   (  )  {  return config server . get intervall monitors (  )  ;   }  
@ override public  collection   ( boolean deep copy )  {   struct sct = new  struct impl ( get type (  )  )  ;  copy ( this sct deep copy )  ;  return sct ;   }  
public void   (  string notsupported )  {  this . notsupported = notsupported ;   }  
public  string   (  )  {  return alias    ;   }  
@ override public void   ( int level )  {  this . log level = level ;   }  
@ override public int   (  )  throws  page exception  {  if  ( time  >  =  0 )   {   system util . sleep ( time )  ;   }  else throw new  expression exception ( "attribute interval must be greater or equal to 0  now ["  +   ( time )   +  "]" )  ;  return 
@ override public  object   (  page context pc )  throws  page exception  {  return  operator . imp ( left . get value ( pc )  right . get value ( pc )  )   ?   boolean . true :  boolean . false ;   }  
@ override public  time   (  )  {  return start time ;   }  
public void   (  element el  string key  string value )  {  if  ( value  !  =  null )  el . set attribute ( key value )  ;   }  
public void   ( float ray amount )  {  this . ray amount = ray amount ;   }  
public void   (  bytecode context bc )  {  adapter . load arg ( 0 )  ;  adapter . invoke virtual (  types . page   context undefined   scope )  ;  adapter . load local ( old check args  types . int   value )  ;  adapter . invoke interface (  types . undefined set   mode )  ;  adapter . pop (  )  ;  adapter . load arg (  1  )  ;  adapter . load arg ( 0 )  ;  adapter . load local ( old data )  ;  adapter . invoke virtual (  types . component   impl after   call )  ;   }  
@ override public void   (  string key long value )  {  add header ( key new  date time impl ( value false )  . cast to string (  )  )  ;   }  
private void   (  page context pc  component component  string path  result result boolean suppress content )  throws io exception   converter exception  {   string method = pc . get http servlet request (  )  . get method (  )  ;   string[] sub path = result . get path (  )  ;   struct c meta ;  try  {  c meta = component . get meta data ( pc )  ;   }  catch  (   page exception pe )   {  throw  exception util . toio exception ( pe )  ;   }   mime type[] c consumes = null ;   string str mime type =  caster . to string ( c meta . get (  key constants .    consumes null )  null )  ;  if  (  !  string util . is empty ( str mime type true )  )   {  c consumes =  mime type . get instances ( str mime type ' ' )  ;   }   mime type[] c produces = null ;  str mime type =  caster . to string ( c meta . get (  key constants .    produces null )  null )  ;  if  (  !  string util . is empty ( str mime type true )  )   {  c produces =  mime type . get instances ( str mime type ' ' )  ;   }   iterator <  entry <  key  object >  >  it = component . entry iterator (  )  ;   entry <  key  object >  e ;   object value ;  udf udf ;   struct meta ;  int status =  4 0 4  ;   mime type bestp  bestc ;  while  ( it . has next (  )  )   {  e = it . next (  )  ;  value = e . get value (  )  ;  if  ( value instanceof udf )   {  udf =  ( udf ) value ;  try  {  meta = udf . get meta data ( pc )  ;   string http method =  caster . to string ( meta . get (  key constants .    httpmethod null )  null )  ;  if  (  string util . is empty ( http method )  ||  ! http method . equals ignore case ( method )  )  continue ;   mime type[] consumes ;  str mime type =  caster . to string ( meta . get (  key constants .    consumes null )  null )  ;  if  (  !  string util . is empty ( str mime type true )  )   {  consumes =  mime type . get instances ( str mime type ' ' )  ;   }  else consumes = c consumes ;   mime type[] produces ;  str mime type =  caster . to string ( meta . get (  key constants .    produces null )  null )  ;  if  (  !  string util . is empty ( str mime type true )  )   {  produces =  mime type . get instances ( str mime type ' ' )  ;   }  else produces = c produces ;   string rest path =  caster . to string ( meta . get (  key constants .    rest path null )  null )  ;  if  (  string util . is empty ( rest path )  )   {  if  (  array util . is empty ( sub path )  )   {  bestc = best ( consumes result . get content type (  )  )  ;  bestp = best ( produces result . get accept (  )  )  ;  if  ( bestc  =  =  null )  status =  4 0 5  ;  else if  ( bestp  =  =  null )  status =  4 0 6  ;  else  {  status =  2 00 ;     call rest ( pc component udf path result . get variables (  )  result bestp produces suppress content e . get key (  )  )  ;  break ;   }   }   }  else  {   struct var = result . get variables (  )  ;  int index =  rest util . match path ( var  path . init ( rest path )  result . get path (  )  )  ;  if  ( index  >  =  0 && index  +   1   =  =  result . get path (  )  . length )   {  bestc = best ( consumes result . get content type (  )  )  ;  bestp = best ( produces result . get accept (  )  )  ;  if  ( bestc  =  =  null )  status =  4 0 5  ;  else if  ( bestp  =  =  null )  status =  4 0 6  ;  else  {  status =  2 00 ;     call rest ( pc component udf path var result bestp produces suppress content e . get key (  )  )  ;  break ;   }   }   }   }  catch  (   page exception pe )   {   }   }   }  if  ( status  =  =   4 0 4  )   rest util . set status ( pc  4 0 4  "no rest service for ["  +  path  +  "] found" )  ;  else if  ( status  =  =   4 0 5  )   rest util . set status ( pc  4 0 5  " unsupported  media  type" )  ;  else if  ( status  =  =   4 0 6  )   rest util . set status ( pc  4 0 6  " not  acceptable" )  ;   }  
public void   ( float distance )  {  this . distance = distance ;   }  
public float   (  )  {  return turbulence ;   }  
public  string   (  )  {  return " colors /  gain .  .  . " ;   }  
public static  class loader   (  config config  string[] jars  class loader parent )  throws io exception  {  return new  resource class loader ( download ( config jars )  parent )  ;   }  
private  type   (  bytecode context bc  member member int mode boolean last boolean do only scope )  throws  bytecode exception  {  if  ( member instanceof  data member )   {  return    write out one data member ( bc  (  data member ) member last do only scope )  ;   }  else if  ( member instanceof udf )   {  if  ( last )  throw new  bytecode exception ( "can't assign value to a user defined function" get start (  )  )  ;  return  variable .    write out firstudf ( bc  ( udf ) member variable . scope do only scope )  ;   }  else  {  if  ( last )  throw new  bytecode exception ( "can't assign value to a built in function" get start (  )  )  ;  return  variable .    write out firstbif ( bc  ( bif ) member mode last get start (  )  )  ;   }   }  
@ override public void   (  )  throws io exception  {  ts . flush (  )  ;   }  
public   (  output stream os )  {  this . os = os ;   }  
public static  string   ( int type  string default value )  {  if  (  config impl . cache   default   object  =  =  type )  return "object" ;  if  (  config impl . cache   default   query  =  =  type )  return "query" ;  if  (  config impl . cache   default   resource  =  =  type )  return "resource" ;  if  (  config impl . cache   default   template  =  =  type )  return "template" ;  if  (  config impl . cache   default   function  =  =  type )  return "function" ;  return default value ;   }  
@ override public boolean   (  string key )  {  return matcher . matches ( ignore case  ?  key . to lower case (  )  : key pattern )  ;   }  
@ override public int   (  )  {  return ct . content . size (  )   +  default   keys . length  +   ( ct . catch block  =  =  null  ?  0 :  1  )  ;   }  
public void   ( byte[] content )  {  this . content = content ;   }  
private final int   ( long l long l 1  long l 2  long l 3  )  {  if  (  (  ( l 1 & = l )  |  ( l 3 & = l 2  )  )   =  =  0l )  return jj start nfa   0 ( 0 l l 2  )  ;  try  {  cur char = input   stream . read char (  )  ;   }  catch  (  io exception ioexception )   {  jj stop string literal dfa   0 (  1  l 1  l 3  )  ;  return  2  ;   }  switch  ( cur char )   {  case  7 0: case  7  2 : case  7  4 : case  8 0: case  8  1 : case  9 0: case  9  1 : case  9  2 : case  9  3 : case  9  4 : case  9  5 : case  9  6 : case  1 0 2 : case  1 0 4 : case  1 0 6 : case  1  1  2 : case  1  1  3 : default : break ;  case  6  5 : case  9  7 : return jj move string literal dfa 3    0 ( l 1  0xe 1  8 000000000 8 000l l 3   4 l )  ;  case  6  6 : case  9  8 : return jj move string literal dfa 3    0 ( l 1  0l l 3   2 l )  ;  case  6  7 : case  9  9 : if  (  ( l 1  &  5  1  2 l )   !  =  0l )  return jj start nfa with states   0 (  2   9   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0x 8 00 1 000000l l 3  0l )  ;  case  6  8 : case  1 00: if  (  ( l 1  &  6  4 l )   !  =  0l )  return jj start nfa with states   0 (  2   6   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0x 1 00 8 0000000000l l 3   1  6 l )  ;  case  6  9 : case  1 0 1 : return jj move string literal dfa 3    0 ( l 1  0l l 3   2  5  6 l )  ;  case  7  1 : case  1 0 3 : if  (  ( l 1  &  1 0 2  4 l )   !  =  0l )  return jj start nfa with states   0 (  2   1 0  4  8  )  ;  break ;  case  7  3 : case  1 0 5 : return jj move string literal dfa 3    0 ( l 1  0x 6 000000 6 000000l l 3   2 0 5  6 l )  ;  case  7  5 : case  1 0 7 : return jj move string literal dfa 3    0 ( l 1  0x 4 000000000l l 3  0l )  ;  case  7  6 : case  1 0 8 : if  (  ( l 1  &  3  2 l )   !  =  0l )  return jj start nfa with states   0 (  2   5   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0xa0 4  8 00000 2 00000l l 3   3  2 l )  ;  case  7  7 : case  1 0 9 : if  (  ( l 3  &  1 l )   !  =  0l )  return jj start nfa with states   0 (  2   6  4   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0x 1 0000000 3 0000l l 3  0l )  ;  case  7  8 : case  1  1 0: if  (  ( l 1  & 0x 2 0000000000l )   !  =  0l )   {  jjmatched kind =  4  1  ;  jjmatched pos =  2  ;   }  return jj move string literal dfa 3    0 ( l 1  0x 4 00000 4  1 000l l 3  0l )  ;  case  7  9 : case  1  1  1 : return jj move string literal dfa 3    0 ( l 1  0x 6  8 00 2 000l l 3  0l )  ;  case  8  2 : case  1  1  4 : if  (  ( l 1  & 0x 1 0000000l )   !  =  0l )  return jj start nfa with states   0 (  2   2  8   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0l l 3   1  2  1  6 l )  ;  case  8  3 : case  1  1  5 : return jj move string literal dfa 3    0 ( l 1  0x 2 00c00000l l 3  0l )  ;  case  8  4 : case  1  1  6 : if  (  ( l 1  & 0x 2 00000000000l )   !  =  0l )  return jj start nfa with states   0 (  2   4  5   4  8  )  ;  if  (  ( l 1  & 0x 1 000000000000000l )   !  =  0l )  return jj start nfa with states   0 (  2   6 0  4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0x 1 0 1 c00 1 00 8 00l l 3   5  1  2 l )  ;  case  8  5 : case  1  1  7 : return jj move string literal dfa 3    0 ( l 1  0x 8 0000l l 3  0l )  ;  case  8  6 : case  1  1  8 : return jj move string literal dfa 3    0 ( l 1  0x 8 0000000l l 3  0l )  ;  case  8  7 : case  1  1  9 : if  (  ( l 1  & 0x 4 00000000000000l )   !  =  0l )  return jj start nfa with states   0 (  2   5  8   4  8  )  ;  return jj move string literal dfa 3    0 ( l 1  0x 4 00000000000l l 3  0l )  ;  case  8  8 : case  1  2 0: if  (  ( l 1  & 0x 1 0000000000l )   !  =  0l )  return jj start nfa with states   0 (  2   4 0  4  8  )  ;  break ;  case  8  9 : case  1  2  1 : if  (  ( l 1  &  1  2  8 l )   !  =  0l )  return jj start nfa with states   0 (  2   7   4  8  )  ;  break ;   }  return jj start nfa   0 (  1  l 1  l 3  )  ;   }  
@ override public boolean   (  )  {  return physical first ;   }  
public static  object   (  page context pc  string hql  object params boolean unique  struct query options )  throws  page exception  {  orm session session = orm util . get session ( pc )  ;  if  (  decision . is castable to array ( params )  )  return session . execute query ( pc hql  caster . to array ( params )  unique query options )  ;  else if  (  decision . is castable to struct ( params )  )  return session . execute query ( pc hql  caster . to struct ( params )  unique query options )  ;  else return session . execute query ( pc hql  (  array ) params unique query options )  ;   }  
public void   (  )  {  this . transport = new  simple targeted chain (  )  ;  this . transport . set option ( "qs . list" "org . apache . axis . transport . http . qs list handler" )  ;  this . transport . set option ( "qs . method" "org . apache . axis . transport . http . qs method handler" )  ;  this . transport . set option ( "qs . wsdl" "org . apache . axis . transport . http . qswsdl handler" )  ;   }  
@ override public int   (  string str )  throws  page exception  {  throw new  expression exception ( "can't compare  complex  object  type  array with a  string" )  ;   }  
public void   (  string header )  {  this . header = header ;   }  
public static  string   (  class .  .  .  clazz args )  {   string buffer sb = new  string buffer (  )  ;  for  ( int i = 0 ;  i  <  clazz args . length ;  i +  +  )   {  if  ( i  >  0 )  sb . append ( "  " )  ;  sb . append (  caster . to type name ( clazz args[i] )  )  ;   }  return sb . to string (  )  ;   }  
public static void   (  result set rs )  {  if  ( rs  !  =  null )   {  try  {  rs . close (  )  ;   }  catch  (   throwable t )   {   }   }   }  
public   (  page context pc  http servlet request req  string id  string key boolean use id  resource dir )  throws io exception  {  super ( pc req id key use id )  ;  directory = dir  !  =  null  ?  dir : get directory ( pc )  ;  name =  md 5  . get digest as string ( file name )   +  " . cache" ;  res = directory . get real resource ( name )  ;   }  
public int   (  )  {  return block size ;   }  
private static void   ( pdf file pdf int page number  resource destination  string format int scale boolean overwrite boolean good quality boolean transparent )  throws  page exception  io exception  {  pdf page page = pdf . get page ( page number )  ;  if  ( scale  <   1  )  throw new  expression exception ( "scale ["  +  scale  +  "] should be at least  1 " )  ;  int width =  ( int ) page . getb box (  )  . get width (  )  ;  int height =  ( int ) page . getb box (  )  . get height (  )  ;  if  ( scale  !  =   1 00 )   {  double s =  ( scale )   /   1 00d ;  width =  ( int )  (  ( width )  * s )  ;  height =  ( int )  (  ( height )  * s )  ;   }   image img = to image ( page width height transparent )  ;  img . write out ( destination format overwrite  1 f )  ;   }  
public   (  )  {  can filter index color model = true ;   }  
@ override public void   (  )  {  super . release (  )  ;  log = log   application ;  type = railo . commons . io . log .  log . level   info ;  file = null ;  application = false ;  charset = null ;   }  
@ override public java . util .  collection   (  )  {  try  {  return info (  )  . values (  )  ;   }  catch  (   expression exception e )   {  throw new  page runtime exception ( e )  ;   }   }  
private void   (  class clazz q name qname )  {   type mapping registry reg = axis server . get type mapping registry (  )  ;  org . apache . axis . encoding .  type mapping tm ;  tm = reg . get or make type mapping ( "http: /  / schemas . xmlsoap . org / soap / encoding / " )  ;   class c = tm . get class forq name ( qname )  ;  if  ( c  !  =  null && c  !  =  clazz )   {  tm . remove deserializer ( c qname )  ;  tm . remove serializer ( c qname )  ;   }   type mapping util . register bean type mapping ( tm clazz qname )  ;   }  
private  string   (  parser string raw  ref boolean has bracked )  throws sql parser exception  {  if  ( has bracked  !  =  null && raw . forward if current ( '[' )  )   {  has bracked . set value ( true )  ;  return identifier bracked ( raw )  ;   }  else if  (  !  ( raw . is current letter (  )  || raw . is current ( '*' )  || raw . is current ( ' ? ' ) || raw . is current ( '   ' )  )  )  return null ;  int start = raw . get pos (  )  ;  do  {  raw . next (  )  ;  if  (  !  ( raw . is current letter (  )  || raw . is current between ( '0' ' 9 ' )  || raw . is current ( '*' ) || raw . is current ( ' ? ' ) || raw . is current ( '   ' )  )  )   {  break ;   }   }  while  ( raw . is valid index (  )  )  ;   string str = raw . substring ( start raw . get pos (  )   -  start )  ;  raw . remove space (  )  ;  return str ;   }  
public static  class <  ?  >    (  class <  ?  >  clazz )  {   class <  ?  >  tmp ;  while  ( true )   {  tmp = clazz . get component type (  )  ;  if  ( tmp  =  =  null )  break ;  clazz = tmp ;   }  return clazz ;   }  
public int   (  )  {  return randomness ;   }  
public void   ( int radius )  {  this . h radius = this . v radius = radius ;   }  
public float   (  )  {  return distance ;   }  
public  string   (  )  {  return auth password ;   }  
public void   ( boolean bold )  {  this . bold = bold ;   }  
public void   ( boolean tls )  {  smtp . settls ( tls )  ;   }  
public int   (  )  {  return frame count ;   }  
private double   (  string str int default value )  {  try  {  return  double . parse double ( str )  ;   }  catch  (   throwable t )   {  return default value ;   }   }  
public void   (  string dn int modifytype  string str attributes  string delimiter  string separator )  throws  naming exception   page exception  {   dir context context = new  initial dir context ( env )  ;   string str arr attributes[] = to string attributes ( str attributes delimiter )  ;  int count = 0 ;  for  ( int i = 0 ;  i  <  str arr attributes . length ;  i +  +  )   {   string[] attributes values = get attributes values ( str arr attributes[i] separator )  ;  if  ( attributes values  =  =  null )  count +  +  ;  else count +  = attributes values . length ;   }   modification item mod items[] = new  modification item[count] ;   basic attribute basic attr = null ;  int k = 0 ;  for  ( int i = 0 ;  i  <  str arr attributes . length ;  i +  +  )   {   string attribute = str arr attributes[i] ;   string type = get attr value type ( attribute )  ;   string values[] = get attributes values ( attribute separator )  ;  if  ( modifytype  =  =   dir context . replace   attribute )   {  if  ( values  =  =  null )  basic attr = new  basic attribute ( type )  ;  else basic attr = new  basic attribute ( type values[0] )  ;  mod items[k] = new  modification item ( modifytype basic attr )  ;  k +  +  ;  if  ( values  !  =  null && values . length  >   1  )   {  for  ( int j =  1  ;  j  <  values . length ;  j +  +  )   {  basic attr = new  basic attribute ( type values[j] )  ;  mod items[k] = new  modification item (  dir context . add   attribute basic attr )  ;  k +  +  ;   }   }   }  else  {  for  ( int j = 0 ;  j  <  values . length ;  j +  +  )   {  if  ( type  !  =  null || modifytype  =  =   dir context . add   attribute )  basic attr = new  basic attribute ( type values[j] )  ;  else basic attr = new  basic attribute ( values[j] )  ;  mod items[k] = new  modification item ( modifytype basic attr )  ;  k +  +  ;   }   }   }  context . modify attributes ( dn mod items )  ;  context . close (  )  ;   }  
public  object   (  object default value )  {  return this touch ( default value )  ;   }  
@ override public boolean   (  )  throws  page exception  {  log (  )  ;  return  caster . to boolean value ( o )  ;   }  
public void   (  string proxy server )  {  this . proxy server = proxy server ;   }  
private void   (  string name cfml factory impl factory  list < ifd thread >  threads )  {   struct pcs = factory . get running page contexts (  )  ;   iterator <  entry <  key  object >  >  it = pcs . entry iterator (  )  ;   page context impl pc ;  while  ( it . has next (  )  )   {  pc =  (  page context impl ) it . next (  )  . get value (  )  ;  try  {  pc . get thread (  )  . wait (  )  ;   }  catch  (   interrupted exception e )   {  e . print stack trace (  )  ;   }  threads . add ( new fd thread impl ( this factory name pc )  )  ;   }   }  
public static  object   (  object o )  {  if  ( o  =  =  null )  return null ;  try  {  byte[] bv =  (  ( oracle . sql . opaque ) o )  . get bytes (  )  ;  return new  string ( bv "utf -  8 " )  ;   }  catch  (   exception e )   {   }  return o ;   }  
private void   (  )  throws  expression exception   page exception   converter exception  io exception   factory configuration error  {  if  ( action . equals ( "cfml 2 wddx" )  )   {  if  ( output  !  =  null )  page context . set variable ( output cfml 2 wddx ( input )  )  ;  else page context . force write ( cfml 2 wddx ( input )  )  ;   }  else if  ( action . equals ( "wddx 2 cfml" )  )   {  if  ( output  =  =  null )  throw new  application exception ( "at tag cfwddx the attribute output is required if you set action =  = wddx 2 cfml" )  ;  page context . set variable ( output wddx 2 cfml (  caster . to string ( input )  )  )  ;   }  else if  ( action . equals ( "cfml 2 js" )  )   {  if  ( output  !  =  null )  page context . set variable ( output cfml 2 js ( input )  )  ;  else page context . force write ( cfml 2 js ( input )  )  ;   }  else if  ( action . equals ( "wddx 2 js" )  )   {  if  ( output  !  =  null )  page context . set variable ( output wddx 2 js (  caster . to string ( input )  )  )  ;  else page context . force write ( wddx 2 js (  caster . to string ( input )  )  )  ;   }  else throw new  expression exception ( "invalid attribute action for tag cfwddx  attributes are [cfml 2 wddx  wddx 2 cfml cfml 2 js  wddx 2 js] . " )  ;   }  
private void   (  )  throws  page exception  {   server[] servers = config . get mail servers (  )  ;  railo . runtime . type .  query qry = new  query impl ( new  string[] { "hostname" "password" "username" "port" "authentication" "readonly" "tls" "ssl" }  servers . length "query" )  ;  for  ( int i = 0 ;  i  <  servers . length ;  i +  +  )   {   server s = servers[i] ;  int row = i  +   1  ;  qry . set at ( "hostname" row s . get host name (  )  )  ;  qry . set at ( "password" row s . is read only (  )   ?  "" : s . get password (  )  )  ;  qry . set at ( "username" row s . is read only (  )   ?  "" : s . get username (  )  )  ;  qry . set at ( "port" row  caster . to integer ( s . get port (  )  )  )  ;  qry . set at ( "readonly" row  caster . to boolean ( s . is read only (  )  )  )  ;  qry . set at ( "authentication" row  caster . to boolean ( s . has authentication (  )  )  )  ;  if  ( s instanceof  server impl )   {   server impl si =  (  server impl ) s ;  qry . set at ( "ssl" row  caster . to boolean ( si . isssl (  )  )  )  ;  qry . set at ( "tls" row  caster . to boolean ( si . istls (  )  )  )  ;   }   }  page context . set variable ( get string ( "admin" action "return variable" )  qry )  ;   }  
public void   (  string errorcode )  {  this . errorcode = errorcode ;   }  
@ override public  throwable   (  )  {  return root cause . get root cause (  )  ;   }  
private void   (  query qry  monitor[] monitors )  {   monitor m ;  int row ;  for  ( int i = 0 ;  i  <  monitors . length ;  i +  +  )   {  m = monitors[i] ;  row = qry . add row (  )  ;  qry . set atel (  key constants .    name row m . get name (  )  )  ;  qry . set atel (  key constants .    type row m . get type (  )   =  =   monitor . type   intervall  ?  "intervall" : "request" )  ;  qry . set atel ( log   enabled row m . is log enabled (  )  )  ;  qry . set atel ( class row m . get clazz (  )  . get name (  )  )  ;   }   }  
public void   ( double markersize )  throws  expression exception  {  if  ( markersize  <   1  )  throw new  expression exception ( "invalid value ["  +  markersize  +  "] for attribute markersize  value must be a positive integer greater than 0" )  ;  this . markersize =  ( int ) markersize ;   }  
public void   (  string proxyserver )  {  this . proxyserver = proxyserver ;   }  
@ override public  string   (  )  {  return "read" ;   }  
  ( x 5 0 9  trust manager tm )  {  this . tm = tm ;   }  
public void   ( int rays )  {  this . rays = rays ;   }  
public void   (  string str action )  throws  application exception  {  str action = str action . to lower case (  )  ;  if  ( str action . equals ( "move" )  || str action . equals ( "rename" )  )  action = action   move ;  else if  ( str action . equals ( "copy" )  )  action = action   copy ;  else if  ( str action . equals ( "delete" )  )  action = action   delete ;  else if  ( str action . equals ( "read" )  )  action = action   read ;  else if  ( str action . equals ( "readbinary" )  )  action = action   read   binary ;  else if  ( str action . equals ( "write" )  )  action = action   write ;  else if  ( str action . equals ( "append" )  )  action = action   append ;  else if  ( str action . equals ( "upload" )  )  action = action   upload ;  else if  ( str action . equals ( "uploadall" )  )  action = action   upload   all ;  else if  ( str action . equals ( "info" )  )  action = action   info ;  else if  ( str action . equals ( "touch" )  )  action = action   touch ;  else throw new  application exception ( "invalid value ["  +  str action  +  "] for attribute action" "values for attribute action are:info move rename copy delete read readbinary write append upload uploadall touch" )  ;   }  
@ override public boolean   (  string pathname )  throws io exception  {  if  (  string util . ends with ( pathname ' / ' )  && pathname . length (  )   !  =   1  )  pathname = pathname . substring ( 0 pathname . length (  )   -   1  )  ;  if  ( pathname 
private final boolean   (  )  {  if  ( jj   scan   token (  5  3  )  )  return true ;  return jj   la  !  =  0 || jj   scanpos  !  =  jj   lastpos  ?  false : false ;   }  
private static  http session   (  http servlet request req )  {  try  {  return req . get session (  )  ;   }  catch  (   throwable t )   {   }  return null ;   }  
public void   (  string proxypassword )  throws  application exception  {  try  {  smtp . get proxy data (  )  . set password ( proxypassword )  ;   }  catch  (   exception e )   {  throw new  application exception ( "attribute [proxypassword] of the tag [mail] is invalid" e . get message (  )  )  ;   }   }  
public   (  analyzer analyzer )  {  this . analyzer = analyzer ;   }  
public void   (  string align )  {  this . align = align ;   }  
public void   (  string result )  {  this . result = result ;   }  
public  access control policy   (  )  {  return acp ;   }  
private void   ( int rgb )  {  int red =  ( rgb  >  >   1  6  )  & 0xff ;  int green =  ( rgb  >  >   8  )  & 0xff ;  int blue = rgb & 0xff ;   oct tree node node = root ;  for  ( int level = 0 ;  level  <  =  max   level ;  level +  +  )   {   oct tree node child ;  int bit = 0x 8 0  >  >  level ;  int index = 0 ;  if  (  ( red & bit )   !  =  0 )  index +  =  4  ;  if  (  ( green & bit )   !  =  0 )  index +  =  2  ;  if  (  ( blue & bit )   !  =  0 )  index +  =  1  ;  child = node . leaf[index] ;  if  ( child  =  =  null )   {  node . children +  +  ;  child = new  oct tree node (  )  ;  child . parent = node ;  node . leaf[index] = child ;  node . is leaf = false ;  nodes +  +  ;  color list[level] . add element ( child )  ;  if  ( level  =  =  max   level )   {  child . is leaf = true ;  child . count =  1  ;  child . total red = red ;  child . total green = green ;  child . total blue = blue ;  child . level = level ;  colors +  +  ;  return ;   }  node = child ;   }  else if  ( child . is leaf )   {  child . count +  +  ;  child . total red +  = red ;  child . total green +  = green ;  child . total blue +  = blue ;  return ;   }  else node = child ;   }   system . out . println ( "insert color failed" )  ;   }  
public void   (  string value )  {  str return type = value ;   }  
public static int   (  string acl )  throws s 3  exception  {  acl = acl . to lower case (  )  . trim (  )  ;  if  ( "public - read" . equals ( acl )  )  return acl   public   read ;  if  ( "private" . equals ( acl )  )  return acl   private ;  if  ( "public - read - write" . equals ( acl )  )  return acl   public   read   write ;  if  ( "authenticated - read" . equals ( acl )  )  return acl   auth   read ;  if  ( "public   read" . equals ( acl )  )  return acl   public   read ;  if  ( "public   read   write" . equals ( acl )  )  return acl   public   read   write ;  if  ( "authenticated   read" . equals ( acl )  )  return acl   auth   read ;  if  ( "publicread" . equals ( acl )  )  return acl   public   read ;  if  ( "publicreadwrite" . equals ( acl )  )  return acl   public   read   write ;  if  ( "authenticatedread" . equals ( acl )  )  return acl   auth   read ;  throw new s 3  exception ( "invalid acl value  valid values are [public - read  private  public - read - write  authenticated - read]" )  ;   }  
public float   (  )  {  return wind speed ;   }  
public  enumeration   (  )  {  return new  enumeration wrapper ( parameters )  ;   }  
protected static void   (  query column impl column )  {  if  (  ( column . type  =  =   types . other )  &&  ! column . type checked )   {  column . type checked = true ;  if  ( column . size (  )   >  0 )   {  check other ( column column . data[0] )  ;  for  ( int i =  1  ;  i  <  column . size (  )  ;  i +  +  )   {  switch  ( column . type )   {  case  types . null: check other ( column column . data[i] )  ;  break ;  case  types . timestamp: check date ( column column . data[i] )  ;  break ;  case  types . boolean: check boolean ( column column . data[i] )  ;  break ;  case  types . double: check double ( column column . data[i] )  ;  break ;  case  types . varchar: check basic ( column column . data[i] )  ;  break ;  default : break ;   }   }   }   }   }  
public   (  component impl component  property prop )  throws  page exception  {  super ( component "set"  +   string util . uc first ( prop . get name (  )  )  new  function argument[] { new  function argument impl (  key impl . init ( prop . get name (  )  )  prop . get type (  )  cf types . to short strict ( prop . get type (  )  cf types . type   unknow )  true )  }  cf types . type   any "wddx" )  ;  this . prop = prop ;  this . prop name =  key impl . get instance ( prop . get name (  )  )  ;  this . validate =  caster . to string ( prop . get dynamic attributes (  )  . get (  key constants .    validate null )  null )  ;  if  (  !  string util . is empty ( validate true )  )   {  validate = validate . trim (  )  . to lower case (  )  ;   object o = prop . get dynamic attributes (  )  . get ( validate   params null )  ;  if  ( o  !  =  null )   {  if  (  decision . is struct ( o )  )  validate params =  caster . to struct ( o )  ;  else  {   string str =  caster . to string ( o )  ;  if  (  !  string util . is empty ( str true )  )   {  validate params = orm util . convert to simple map ( str )  ;  if  ( validate params  =  =  null )  throw new  expression exception ( "cannot parse string ["  +  str  +  "] as struct" )  ;   }   }   }   }   }  
@ override public  date   (  )  {  return new  date ( created )  ;   }  
private static void   (  )  {  ranges = new lcr[] { new lcr (  4 000000000000l  4  9  9  9  9  9  9  9  9  9  9  9  9 l  1  3  visa true )  new lcr (  3 0000000000000l  3 0 5  9  9  9  9  9  9  9  9  9  9  9 l  1  4  diners true )  new lcr (  3  6 000000000000l  3  6  9  9  9  9  9  9  9  9  9  9  9  9 l  1  4  diners true )  new lcr (  3  8 000000000000l  3  8  9  9  9  9  9  9  9  9  9  9  9  9 l  1  4  diners true )  new lcr (  1  8 0000000000000l  1  8 00 9  9  9  9  9  9  9  9  9  9  9 l  1  5  jcb true )  new lcr (  2 0 1  4 00000000000l  2 0 1  4  9  9  9  9  9  9  9  9  9  9  9 l  1  5  enroute false )  new lcr (  2  1  3  1 00000000000l  2  1  3  1  9  9  9  9  9  9  9  9  9  9  9 l  1  5  jcb true )  new lcr (  2  1  4  9 00000000000l  2  1  4  9  9  9  9  9  9  9  9  9  9  9  9 l  1  5  enroute false )  new lcr (  3  4 0000000000000l  3  4  9  9  9  9  9  9  9  9  9  9  9  9  9 l  1  5  amex true )  new lcr (  3  7 0000000000000l  3  7  9  9  9  9  9  9  9  9  9  9  9  9  9 l  1  5  amex true )  new lcr (  3 000000000000000l  3  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9 l  1  6  jcb true )  new lcr (  4 000000000000000l  4  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9 l  1  6  visa true )  new lcr (  5  1 00000000000000l  5  5  9  9  9  9  9  9  9  9  9  9  9  9  9  9 l  1  6  mastercard true )  new lcr (  6 0 1  1 000000000000l  6 0 1  1  9  9  9  9  9  9  9  9  9  9  9  9 l  1  6  discover true )  }  ;   }  
public static  object   (  )  {  return result thread local . get (  )  ;   }  
public  string   (  )  {  return id ;   }  
public int   (  )  {  return index ;   }  
@ override public  object   ( int key )  throws  expression exception  {  if  ( key  >  size || key  <   1  )  throw invalid position ( key )  ;   object obj = get ( key null )  ;  for  ( int i =  ( offset  +  key )   -   1  ;  i  <   ( offset  +  size ) 
public static  string   (  string str url  string default value )  {  try  {  return tourl ( str url  -  1  true )  . to external form (  )  ;   }  catch  (   malformedurl exception e )   {  return default value ;   }   }  
private  page   (  class clazz )  throws  security exception   illegal argument exception   instantiation exception   illegal access exception   invocation target exception  {  try  {   constructor c = clazz . get constructor ( new  class[] {  page source . class }  )  ;  return  (  page ) c . new instance ( new  object[] { this }  )  ;   }  catch  (   no such method exception e )   {   thread local page source . register ( this )  ;  try  {  return  (  page ) clazz . new instance (  )  ;   }  finally  {   thread local page source . release (  )  ;   }   }   }  
public void   (  )  {     series . clear (  )  ;  url = null ;  xoffset = 0 .  1  ;  yoffset = 0 .  1  ;  xaxistype = "category" ;  yaxistype = "category" ;  xaxistitle = "" ;  yaxistitle = "" ;  legend multi line = false ;  backgroundcolor =  color . white ;  databackgroundcolor =  color . white ;  foregroundcolor =  color . black ;  tipbgcolor =  color . white ;  chartheight =  2  4 0 ;  chartwidth =  3  2 0 ;  font = font   arial ;  fontstyle = 0 ;  fontsize =  1  1  ;  format = format   png ;  gridlines =  1 0 ;  label format =  label format util . label   format   number ;  markersize =  -  1  ;  name = null ;  pieslicestyle = pie   slice   style   sliced ;  scalefrom =  double .  nan ;  scaleto =  double .  nan ;  seriesplacement = series   placement   default ;  show 3 d = false ;  showborder = false ;  showlegend = true ;  showmarkers = true ;  showxgridlines = none ;  showygridlines = false ;  sortxaxis = false ;  showx label = true ;  showtooltip = true ;  style = null ;  title = "" ;  source = null ;  tipstyle = tip   style   mouseover ;   }  
public static  string   (  servlet context sc )  {  if  ( sc  =  =  null )  throw new  runtime exception ( "cannot determine webcontext root  because the  servlet context is null" )  ;   string root = sc . get real path ( " / " )  ;  if  ( root  =  =  null )  throw new  runtime exception ( "cannot determinae webcontext root  the  servlet context from class ["  +  sc . get class (  )  . get name (  )   +  "] is returning null for the method call sc . get real path ( \" / \" )   possibly due to configuration problem . " )  ;  return root ;   }  
public  type   (  bytecode context bc int mode )  throws  bytecode exception  {   generator adapter adapter = bc . get adapter (  )  ;   array visitor av = new  array visitor (  )  ;  av . visit begin ( adapter  types . string arr . length )  ;  for  ( int y = 0 ;  y  <  arr . length ;  y +  +  )   {  av . visit begin item ( adapter y )  ;  adapter . push ( arr[y] )  ;  av . visit end item ( bc . get adapter (  )  )  ;   }  av . visit end (  )  ;  return  types . string   array ;   }  
public static  node   (  page context pc  string strxml boolean case sensitive  string str validator )  throws  page exception  {  try  {   input source xml = xml util . to input source ( pc strxml . trim (  )  )  ;   input source validator =  string util . is empty ( str validator )   ?  null : xml util . to input source ( pc str validator . trim (  )  )  ;  return xml caster . toxml struct ( xml util . parse ( xml validator false )  case sensitive )  ;   }  catch  (   exception e )   {  throw  caster . to page exception ( e )  ;   }   }  
public static final  mail spool service   (  )  throws  service exception  {  throw missing service ( " mail spool service" )  ;   }  
public static boolean   (  prepared statement ps boolean default value )  {  try  {  return ps . is closed (  )  ;   }  catch  (   throwable t )   {  return default value ;   }   }  
public   (  persistent class mapping info )  {  this . entity name = mapping info . get entity name (  )  ;  is instance entity names . add ( entity name )  ;  if  ( mapping info . has subclasses (  )  )   {   iterator <  persistent class >  itr = mapping info . get subclass closure iterator (  )  ;  while  ( itr . has next (  )  )   {  final  persistent class subclass info = itr . next (  )  ;  is instance entity names . add ( subclass info . get entity name (  )  )  ;   }   }   }  
static void   (  string resource  resource file )  throws io exception  {   byte array output stream baos = new  byte array output stream (  )  ;  io util . copy ( new  info (  )  . get class (  )  . get resource as stream ( resource )  baos true false )  ;  byte[] barr = baos . to byte array (  )  ;  if  ( file . exists (  )  )   {  long trg size = file . length (  )  ;  long src size = barr . length ;  if  ( src size  =  =  trg size )  return ;   system out . print date (  system util . get print writer (  system util . out )  "update file:"  +  file )  ;   system out . print date (  system util . get print writer (  system util . out )  "  -  source:"  +  src size )  ;   system out . print date (  system util . get print writer (  system util . out )  "  -  target:"  +  trg size )  ;   }  else file . create new file (  )  ;  io util . copy ( new  byte array input stream ( barr )  file true )  ;   }  
public boolean   (  )  {  return full null support ;   }  
public void   ( int height )  {  this . height = height ;   }  
@ override public long   (  )  {  return positiv ( max )  ;   }  
public synchronized static  string   (  date date  time zone tz )  {  tz =  thread local page context . get time zone ( tz )  ;   string id = locale . hash code (  )   +  " - "  +  tz . getid (  )  ;   date format format =  (  date format ) map . get ( id )  ;  if  ( format  =  =  null )   {  format = new  simple date format ( "mmmm  dd yyyy hh:mm:ss z" locale )  ;  format . set time zone ( tz )  ;  map . put ( id format )  ;   }  return format . format ( date )  ;   }  
public void   (  string list )  {  attributes . setel ( "list" list )  ;   }  
public  dump data   (  page context page context int maxlevel  dump properties properties )  {  log (  )  ;  return dt . to dump data ( page context maxlevel properties )  ;   }  
public  proxy data   (  )  {  return proxy data ;   }  
private static int   (  query query  resource directory  resource name filter filter int count )  throws  page exception  {   string[] list = directory . list (  )  ;  if  ( list  =  =  null || list . length  =  =  0 )  return count ;  for  ( int i = 0 ;  i  <  list . length ;  i +  +  )   {  if  ( filter  =  =  null || filter . accept ( directory list[i] )  )   {  query . add row (  1  )  ;  count +  +  ;  query . set at (  key constants .    name count list[i] )  ;   }   }  return count ;   }  
public void   ( boolean playlist thumbnails )  {  this . playlist thumbnails = playlist thumbnails ;   }  
public void   (  string action )  throws  page exception  {  str action = action ;  action = action . to lower case (  )  . trim (  )  ;  if  ( action . equals ( "concat" )  )  this . action = action   concat ;  else if  ( action . equals ( "merge" )  )  this . action = action   concat ;  else if  ( action . equals ( "convert" )  )  this . action = action   convert ;  else if  ( action . equals ( "cut image" )  )  this . action = action   cut   image ;  else if  ( action . equals ( "cutimage" )  )  this . action = action   cut   image ;  else if  ( action . equals ( "cut   image" )  )  this . action = action   cut   image ;  else if  ( action . equals ( "cut - image" )  )  this . action = action   cut   image ;  else if  ( action . equals ( "info" )  )  this . action = action   info ;  else if  ( action . equals ( "install" )  )  this . action = action   install ;  else if  ( action . equals ( "uninstall" )  )  this . action = action   uninstall ;  else throw do throw ( "invalid value for attribute action for tag video ["  +  action  +  "]  " +  "valid actions are [concat  convert  cut image  info install uninstall]" )  ;   }  
public float   (  )  {  return opacity ;   }  
@ override public  object   (  key key )  {  return struct . removeel ( key )  ;   }  
public   (  string type )  {  starts with = "railo - storage:"  +  type  +  ":" ;   }  
@ override public void   ( long exe time )  {  if  ( exe time  >  =  0 )   {  if  ( count  =  =   1  || min  >  exe time )  min = exe time ;  if  ( max  <  exe time )  max = exe time ;  this . exe time +  = exe time ;   }   }  
@ override public  file   (  )  throws io exception  {  return new  file wrapper ( res . get canonical resource (  )  )  ;   }  
public  debug text fragment[]   (  )  {  return this . output log . get fragments (  )  ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " colormap" )  )  )   !  =  null )  set colormap (  image filter util . to colormap ( o " colormap" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " turbulence" )  )  )   !  =  null )  set turbulence (  image filter util . to float value ( o " turbulence" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " scaling" )  )  )   !  =  null )  set scaling (  image filter util . to float value ( o " scaling" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " use colormap" )  )  )   !  =  null )  set use colormap (  image filter util . to boolean value ( o " use colormap" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " use image colors" )  )  )   !  =  null )  set use image colors (  image filter util . to boolean value ( o " use image colors" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " seed" )  )  )   !  =  null )  set seed (  image filter util . to int value ( o " seed" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ colormap   turbulence   scaling   use colormap   use image colors   seed]" )  ;   }  return filter ( src dst )  ;   }  
private final int   ( int a int b int c int d int x int s int ac )  {  a +  = g ( b c d )   +  x  +  ac ;  a = rotate   left ( a s )  ;  a +  = b ;  return a ;   }  
@ override public  string   ( int type )  {  if  (  ! init default caches )   {  boolean has resource = false ;  if  ( default caches  =  =  null )  default caches = new  hash map <  integer  string >  (  )  ;   object o = get ( component  key constants .
@ override protected  class   (  string name )  throws  class not found exception  {   class clazz = find classel ( name )  ;  if  ( clazz  !  =  null )  return clazz ;  throw new  class not found exception ( "class "  +  name  +  " not found" )  ;   }  
private int   (  vector 3 f normal int[] in pixels int width int height )  {  if  ( environment map  !  =  null )   {  float x = 0 .  5 f *  (  1   +  normal . x )  ;  float y = 0 .  5 f *  (  1   +  normal . y )  ;  x =  image math . clamp ( x * env width 0 env width  -   1  )  ;  y =  image math . clamp ( y * env height 0 env height  -   1  )  ;  int ix =  ( int ) x ;  int iy =  ( int ) y ;  float x weight = x  -  ix ;  float y weight = y  -  iy ;  int i = env width * iy  +  ix ;  int dx = ix  =  =  env width  -   1   ?  0 :  1  ;  int dy = iy  =  =  env height  -   1   ?  0 : env width ;  return  image math . bilinear interpolate ( x weight y weight env pixels[i] env pixels[i  +  dx] env pixels[i  +  dy] env pixels[i  +  dx  +  dy] )  ;   }  return 0 ;   }  
public static long   (  string value long default value )  {  value = value . trim (  )  . to lower case (  )  ;  long factor = b ;   string num = value ;  if  ( value . ends with ( "kb" )  )   {  factor = kb ;  num = value . substring ( 0 value . length (  )   -   2  )  . trim (  )  ;   }  else if  ( value . ends with ( "k" )  )   {  factor = kb ;  num = value . substring ( 0 value . length (  )   -   1  )  . trim (  )  ;   }  else if  ( value . ends with ( "mb" )  )   {  factor = mb ;  num = value . substring ( 0 value . length (  )   -   2  )  . trim (  )  ;   }  else if  ( value . ends with ( "m" )  )   {  factor = mb ;  num = value . substring ( 0 value . length (  )   -   1  )  . trim (  )  ;   }  else if  ( value . ends with ( "gb" )  )   {  factor = gb ;  num = value . substring ( 0 value . length (  )   -   2  )  . trim (  )  ;   }  else if  ( value . ends with ( "g" )  )   {  factor = gb ;  num = value . substring ( 0 value . length (  )   -   1  )  . trim (  )  ;   }  else if  ( value . ends with ( "tb" )  )   {  factor = tb ;  num = value . substring ( 0 value . length (  )   -   2  )  . trim (  )  ;   }  else if  ( value . ends with ( "t" )  )   {  factor = tb ;  num = value . substring ( 0 value . length (  )   -   1  )  . trim (  )  ;   }  else if  ( value . ends with ( "b" )  )   {  factor = b ;  num = value . substring ( 0 value . length (  )   -   1  )  . trim (  )  ;   }  long tmp =  caster . to long value ( num  long . min   value )  ;  if  ( tmp  =  =   long . min   value )  return default value ;  return tmp * factor ;   }  
private void   (  )  throws io exception  {  provider . remove core ( parent name )  ;   }  
public  string   (  )  {  return " stylize /  crystallize .  .  . " ;   }  
private void   (  )  {  inside contents = true ;  content = new  content ( s 3  )  ;   }  
public double   ( double x )  {  if  ( x  <   -  3  . 0 )  return 0 . 0 ;  if  ( x  <  0 . 0 )  return sinc (  - x )  * sinc (  - x  /   3  . 0 )  ;  if  ( x  <   3  . 0 )  return sinc ( x )  * sinc ( x  /   3  . 0 )  ;  return 0 . 0 ;   }  
private static  stack trace element[]   (  throwable t boolean only withcml )  {   stack trace element[] st ;   throwable cause = t . get cause (  )  ;  if  ( cause  !  =  null )   {  st = get stack trace elements ( cause only withcml )  ;  if  ( st  !  =  null )  return st ;   }  st = t . get stack trace (  )  ;  if  (  ! only withcml || hascfm lin stacktrace ( st )  )   {  return st ;   }  return null ;   }  
private static  name   (  object value )  throws  page exception  {  if  ( value instanceof  name )  return  (  name ) value ;  return new  name (  caster . to string ( value )  )  ;   }  
public void   (  string onselect )  {  attributes . setel ( "onselect" onselect )  ;   }  
public static orm engine   (  page context pc )  throws  page exception  {   config impl config =  (  config impl ) pc . get config (  )  ;  return config . getorm engine ( pc )  ;   }  
public   (  storage scope impl other boolean deep copy )  {  this . sct =  (  struct )  duplicator . duplicate ( other . sct deep copy )  ;  this . timecreated = other . timecreated ;  this .    lastvisit = other .    lastvisit ;  this . hitcount = other . hitcount ;  this . isinit = other . isinit ;  this . lastvisit = other . lastvisit ;  this . str type = other . str type ;  this . type = other . type ;  this . time span = other . time span ;  id =  +  +    id ;   }  
@ override public  string   (  )  {  return res . to string (  )  ;   }  
@ override public  string   (  )  {  return left  +  " not "  +  right ;   }  
@ override public long   (  )  {  return res . length (  )  ;   }  
public void   ( boolean stoponerror )  {  this . stoponerror = stoponerror ;   }  
public void   (  string skin )  {  this . skin = skin ;   }  
private void   (  object username  object password )  {  if  ( username  =  =  null )  return ;  if  ( password  =  =  null )  password = "" ;   struct sct = new  struct impl (  )  ;  sct . setel (  key constants .    name username )  ;  sct . setel (  key constants .    password password )  ;  page context . undefined scope (  )  . setel ( cflogin sct )  ;   }  
@ ove ride public v r ( k key )  throws  page exception  {  v v = map . get ( key )  ;  if  ( v  =  =  null )  return null ;  if  ( v  =  =  null )  throw invalid key ( this key true )  ;  return v ;   }  
public void   (  object value )  {  this . value = value ;   }  
public void   ( int levels )  {  this . levels = levels ;   }  
public final  type   (  bytecode context bc int mode )  throws  bytecode exception  {   expression util . visit line ( bc get start (  )  )  ;   type type =    write out ( bc mode  boolean . true )  ;   expression util . visit line ( bc get end (  )  )  ;  return type ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst = null ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " radius" )  )  )   !  =  null )  set radius (  image filter util . to float value ( o " radius" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " angle" )  )  )   !  =  null )  set angle (  image filter util . to float value ( o " angle" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " spread angle" )  )  )   !  =  null )  set spread angle (  image filter util . to float value ( o " spread angle" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " centrex" )  )  )   !  =  null )  set centrex (  image filter util . to float value ( o " centrex" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " centrey" )  )  )   !  =  null )  set centrey (  image filter util . to float value ( o " centrey" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " height" )  )  )   !  =  null )  set height (  image filter util . to float value ( o " height" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " edge action" )  )  )   !  =  null )  set edge action (  image filter util . to string ( o " edge action" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " interpolation" )  )  )   !  =  null )  set interpolation (  image filter util . to string ( o " interpolation" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ radius   angle   spread angle   centrex   centrey   centre   height   edge action   interpolation]" )  ;   }  return filter ( src dst )  ;   }  
public void   ( boolean hidden )  {  this . hidden = hidden ;   }  
@ override public  string   (  string table name )  {  return translate ( table name )  ;   }  
public  variant   (  )  {  return parent ;   }  
public static  object   (  page context pc  object obj )  throws  page exception  {  if  ( obj instanceof  query )  return  caster . to double (  (  (  query ) obj )  . get recordcount (  )  )  ;  return pc . get collection ( obj  key constants .    recordcount )  ;   }  
public void   (  )  {  super . release (  )  ;  username = null ;  password = null ;  domain = null ;  result = "cfntauthenticate" ;  list groups = false ;  throw on error = false ;   }  
public  string   (  )  {  return password ;   }  
public  string   (  )  {  return on validate ;   }  
public static int   (  )  {  return full version ;   }  
public void   (  string sort control )  throws  page exception  {   string[] sort control arr =  array util . trim (  list util . to string array (  list util . list to array remove empty ( sort control ' ' )  )  )  ;  for  ( int i = 0 ;  i  <  sort control arr . length ;  i +  +  )   {   string scs = sort control arr[i] . trim (  )  . to lower case (  )  ;  if  ( scs . equals ( "asc" )  )  sort direction = ldap client . sort   direction   asc ;  else if  ( scs . equals ( "desc" )  )  sort direction = ldap client . sort   direction   desc ;  else if  ( scs . equals ( "case" )  )  sort type = ldap client . sort   type   case ;  else if  ( scs . equals ( "nocase" )  )  sort type = ldap client . sort   type   nocase ;  else throw new  application exception ( "invalid value for attribute sort control ["  +  sort control  +  "]  " +  "valid values are [asc desc case nocase]" )  ;   }   }  
public void   ( int[] src int[] dst float alpha )  {  int w = src . length ;  for  ( int i = 0 ;  i  <  w ;  i +  =  4  )   {  int sr = src[i] ;  int dir = dst[i] ;  int sg = src[i  +   1 ] ;  int dig = dst[i  +   1 ] ;  int sb = src[i  +   2 ] ;  int dib = dst[i  +   2 ] ;  int sa = src[i  +   3 ] ;  int dia = dst[i  +   3 ] ;  int dor  dog  dob ;  int t = dir * sr  +  0x 8 0 ;  dor =  (  ( t  >  >   8  )   +  t )   >  >   8  ;  t = dig * sg  +  0x 8 0 ;  dog =  (  ( t  >  >   8  )   +  t )   >  >   8  ;  t = dib * sb  +  0x 8 0 ;  dob =  (  ( t  >  >   8  )   +  t )   >  >   8  ;  float a = alpha * sa  /   2  5  5 f ;  float ac =  1   -  a ;  dst[i] =  ( int )  ( a * dor  +  ac * dir )  ;  dst[i  +   1 ] =  ( int )  ( a * dog  +  ac * dig )  ;  dst[i  +   2 ] =  ( int )  ( a * dob  +  ac * dib )  ;  dst[i  +   3 ] =  ( int )  ( sa * alpha  +  dia * ac )  ;   }   }  
public void   (  string name )  {  this . name = name ;   }  
private void   (  graphics 2 d graphics  dimension dimension  color oval color type )  {   point point = get random point ( dimension )  ;  double height = dimension . get height (  )  ;  double min oval = height *  .  1 0 ;  double max oval = height *  .  7  5  ;  graphics . set color ( oval color type )  ;  switch  ( rnd (  1   3  )  )   {  case  1 : graphics . set stroke ( get random stroke (  )  )  ;  graphics . draw oval (  ( int ) point . getx (  )   ( int ) point . gety (  )  rnd ( min oval max oval )  rnd ( min oval max oval )  )  ;  break ;  case  2 : case  3 : graphics . fill oval (  ( int ) point . getx (  )   ( int ) point . gety (  )  rnd ( min oval max oval )  rnd ( min oval max oval )  )  ;  break ;   }   }  
public static int   ( int a int b )  {  int n = a  /  b ;  a -  = n * b ;  if  ( a  <  0 )  return a  +  b ;  return a ;   }  
public  point 2 d   (  )  {  return new  point 2 d .  float ( centrex centrey )  ;   }  
@ override public  string[]   (  )  {  return query . get column names as string (  )  ;   }  
public static int   (  string list  string value char delimiter )  {  if  ( list  =  =  null )  return  -  1  ;  int len = list . length (  )  ;  if  ( len  =  =  0 )  return  -  1  ;  int last = 0 ;  int count = 0 ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  if  ( list . char at ( i )   =  =  delimiter )   {  if  ( last  <  i )   {  if  ( list . substring ( last i )  . equals ( value )  )  return count ;  count +  +  ;   }  last = i  +   1  ;   }   }  if  ( last  <  len )   {  if  ( list . substring ( last )  . equals ( value )  )  return count ;   }  return  -  1  ;   }  
public void   ( boolean showitemlabel )  {  this . showitemlabel = showitemlabel ;   }  
public void   (  object o roles )  throws  page exception  {  roles =  credential impl . to role ( o roles )  ;   }  
@ override public int   (  )  throws sql exception  {  return stat . get fetch size (  )  ;   }  
public void   (  object copy from )  throws  expression exception  {  this . copy from = copy from ;   }  
public   (  node parent boolean case sensitive )  {  this . owner = parent . get owner document (  )  ;  this . parent = parent ;  this . node map = parent . get attributes (  )  ;  this . case sensitive = case sensitive ;   }  
public   (  cache event listener listener )  {  this . listener = listener ;   }  
public static int   (  string list  string value  string delimiter )  {  if  (  string util . is empty ( value )  )  return  -  1  ;   array arr = list to array remove empty ( list delimiter )  ;  int count = 0 ;  int len = arr . size (  )  ;  for  ( int i =  1  ;  i  <  =  len ;  i +  +  )   {   string item = arr . get ( i "" )  . to string (  )  ;  if  (  string util . index of ignore case ( item value )   !  =   -  1  )  return count ;  count +  +  ;   }  return  -  1  ;   }  
public  collection .  key[]   (  )  {  return keys ( get access (  thread local page context . get (  )  )  )  ;   }  
private synchronized void   (  )  {  if  ( closer  =  =  null ||  ! closer . is alive (  )  )   {  closer = new ftp resource client closer ( this )  ;  closer . start (  )  ;   }   }  
@ override public  object   (  page context pc  object[] args )  throws  page exception  {  return call ( pc  caster . to array ( args[0] )  args[ 1 ] )  ;   }  
@ override public synchronized void   (  )  throws io exception  {  super . close (  )  ;  dir . get resource provider (  )  . unlock ( dir )  ;   }  
@ override public  string   (  page context pc  dump data data boolean expand )  {   string writer sw = new  string writer (  )  ;  try  {  write out ( pc data sw expand )  ;   }  catch  (  io exception e )   {  return "" ;   }  return sw . to string (  )
@ override public  iterator <  object >    (  )  {  return form . value iterator (  )  ;   }  
@ override public void   (  body content body content )  {  this . body content = body content ;   }  
public void   ( long pos )  throws io exception  {  throw new io exception ( "not supported" )  ;   }  
public final void   (  )  throws io exception  {  print buffer (  )  ;  super . flush (  )  ;   }  
public static  point   (  object value  string arg name )  throws  page exception  {  if  ( value instanceof  point )  return  (  point ) value ;   string str =  caster . to string ( value )  ;   struct sct =  caster . to struct ( value null )  ;  if  ( sct  !  =  null )   {  return new  point (  caster . to int value ( sct . get ( "x" )  )   caster . to int value ( sct . get ( "y" )  )  )  ;   }   string[] arr =  list util . list to string array ( str ' ' )  ;  if  ( arr . length  =  =   2  )   {  return new  point (  caster . to int value ( arr[0] )   caster . to int value ( arr[ 1 ] )  )  ;   }  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "use the following format [x y]" )  ;   }  
public char   ( int pos )  {  return text[pos] ;   }  
public void   (  string arg0 sqlxml arg 1  )  throws sql exception  {  rst . updatesqlxml ( arg0 arg 1  )  ;   }  
@ override public  object   (  page context pc  object[] args )  throws  page exception  {  return call ( pc  caster . to struct ( args[0] )   caster . to key ( args[ 1 ] )  )  ;   }  
public void   ( boolean multi part )  {  this . multi part = multi part ;   }  
public void   ( boolean throwonerror )  {  this . throwonerror = throwonerror ;   }  
@ override public  string   (  )  {  return "operation" ;   }  
public void   (  )  throws sql exception  {  rst . move to insert row (  )  ;   }  
@ override protected  class <  ?  >    (  string name )  throws  class not found exception  {   resource res = directory . get real resource ( name . replace ( ' . ' ' / ' )  . concat ( " . class" )  )  ;   byte array output stream baos = new  byte array 
@ override public  string   (  )  {  return rsp . get status line (  )  . get reason phrase (  )  ;   }  
@ override public boolean   (  )  {  return name  !  =  null ;   }  
public   (  )  {  super (  convolve filter . clamp   edges )  ;  set radius (  1 00 . 0f )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
private  string   (  )  {  return "" ;   }  
private  tag thread[]   (  )  {   tag thread[] threads = new  tag thread[this . threads . size (  ) ] ;   iterator it = this . threads . iterator (  )  ;  int count = 0 ;  while  ( it . has next (  )  )   {  threads[count +  + ] =  (  tag thread ) it . next (  )  ;   }  return threads ;   }  
public void   (  string textcolor )  throws  expression exception  {  column . set text color (  color caster . to color ( textcolor )  )  ;   }  
private static boolean   (  object left  object right )  {  if  ( left  =  =  null )  return right  =  =  null ;  return left . equals ( right )  ;   }  
static int   ( int a )  {  return a  <  0  ?  0 : a  >   2  5  5   ?   2  5  5  : a ;   }  
public   (  )  {  super (  convolve filter . zero   edges )  ;   }  
private static void   (  configuration configuration  datasource connection dc  session factory data data )  throws  page exception  sql exception  io exception  {  orm configuration orm conf = data . getorm configuration (  )  ;  if  ( orm configuration . dbcreate   none  =  =  orm conf . get db create (  )  )   {  return ;   }  else if  ( orm configuration . dbcreate   drop   create  =  =  orm conf . get db create (  )  )   {   schema export export = new  schema export ( configuration )  ;  export . set halt on error ( true )  ;  export . execute ( false true false false )  ;  print error ( data export . get exceptions (  )  false )  ;  executesql script ( orm conf dc )  ;   }  else if  ( orm configuration . dbcreate   update  =  =  orm conf . get db create (  )  )   {   schema update update = new  schema update ( configuration )  ;  update . set halt on error ( true )  ;  update . execute ( false true )  ;  print error ( data update . get exceptions (  )  false )  ;   }   }  
public void   ( float amount )  {  this . amount = amount ;   }  
private static void   (  query column impl column  object value )  {  if  ( value  =  =  null )  return ;  if  ( value instanceof  date || value instanceof  number )  return ;   string str =  caster . to string ( value null )  ;  if  ( str  !  =  null )   {  return ;   }  column . type =  types . other ;  return ;   }  
public void   ( float brightness )  {  this . brightness = brightness ;  initialized = false ;   }  
public static  array   (  page context pc  string package name )  throws  page exception  {   set <  string >  names ;  try  {  names =    call ( pc package name )  ;   }  catch  (  io exception e )   {  throw  caster . to page exception ( e )  ;   }   array arr = new  array impl (  )  ;   string name ;   iterator <  string >  it = names . iterator (  )  ;  while  ( it . has next (  )  )   {  name = it . next (  )  ;  if  (  string util . ends with ignore case ( name " . cfc" )  )   {  name = name . substring ( 0 name . length (  )   -   4  )  ;   }  arr . appendel ( name )  ;   }  return arr ;   }  
public   (  core core  datasource connection dc  string prefix  attr attr  input stream is  datasource resource provider drp boolean append )  {  this . core = core ;  this . dc = dc ;  this . prefix = prefix ;  this . attr = attr ;  this . is = is ;  this . drp = drp ;  this . append = append ;   }  
public void   (  string dbtype )  {  this . dbtype = dbtype ;   }  
public static uri   (  string str url int port )  throws uri syntax exception  {  uri uri = new uri ( str url )  ;   string host = uri . get host (  )  ;   string fragment = uri . get raw fragment (  )  ;   string path = uri . get raw path (  )  ;   string query = uri . get raw query (  )  ;   string scheme = uri . get scheme (  )  ;   string user info = uri . get raw user info (  )  ;  if  ( port  <  =  0 )  port = uri . get port (  )  ;  if  (  !  string util . is empty ( path )  )   {  int sq index = path . index of ( ' ; ' )  ;   string q = null ;  if  ( sq index  !  =   -  1  )   {  q = path . substring ( sq index  +   1  )  ;  path = path . substring ( 0 sq index )  ;   }   string builder res = new  string builder (  )  ;   string list list =  list util . to list trim ( path ' / ' )  ;   string str ;  while  ( list . has next (  )  )   {  str = list . next (  )  ;  if  (  string util . is empty ( str )  )  continue ;  res . append ( " / " )  ;  res . append ( escapeqs value ( str )  )  ;   }  if  (  string util . ends with ( path ' / ' )  )  res . append ( ' / ' )  ;  path = res . to string (  )  ;  if  ( sq index  !  =   -  1  )   {  path +  = decode query ( q ' ; ' )  ;   }   }  query = decode query ( query ' ? ' )  ;  if  (  !  string util . is empty ( fragment )  )   {  fragment = escapeqs value ( fragment )  ;   }  if  (  !  string util . is empty ( user info )  )   {  int index = user info . index of ( ':' )  ;  if  ( index  !  =   -  1  )   {  user info = escapeqs value ( user info . substring ( 0 index )  )   +  ":"  +  escapeqs value ( user info . substring ( index  +   1  )  )  ;   }  else user info = escapeqs value ( user info )  ;   }   string builder rtn = new  string builder (  )  ;  if  ( scheme  !  =  null )   {  rtn . append ( scheme )  ;  rtn . append ( ": /  / " )  ;   }  if  ( user info  !  =  null )   {  rtn . append ( user info )  ;  rtn . append ( "@" )  ;   }  if  ( host  !  =  null )   {  rtn . append ( host )  ;   }  if  ( port  >  0 )   {  rtn . append ( ":" )  ;  rtn . append ( port )  ;   }  if  ( path  !  =  null )   {  rtn . append ( path )  ;   }  if  ( query  !  =  null )   {  rtn . append ( query )  ;   }  if  ( fragment  !  =  null )   {  rtn . append ( "#" )  ;  rtn . append ( fragment )  ;   }  return new uri ( rtn . to string (  )  )  ;   }  
@ override public int   (  string str )  throws  page exception  {  return  operator . compare ( cast to string (  )  str )  ;   }  
private  object   (  page context pc sql sql  query query source int row  collection .  key key  object value )  throws  page exception  {  if  ( value instanceof  expression )  return execute exp ( pc sql query source  (  (  expression ) value )  row )  ;  return query source . get at ( key row null )  ;   }  
public boolean   (  )  throws sql exception  {  return rst . is last (  )  ;   }  
public static int   ( float t int a int b )  {  return  ( int )  ( a  +  t *  ( b  -  a )  )  ;   }  
public void   (  string title )  {  this . title = title ;   }  
private   (  file resource provider provider  file parent  string child )  {  super ( parent child )  ;  this . provider = provider ;   }  
public boolean   (  string class name )  {  return has resource ( class name . replace ( ' . ' ' / ' )  . concat ( " . class" )  )  ;   }  
public int   (  )  {  return num knots ;   }  
private  query   (  page context pc sql sql  query qr z query query int maxrows )  throws  page exception  {  int rec count = qr . get recordcount (  )  ;   vector v selects = query . get select (  )  ;  int sel count = v selects . size (  )  ;   map <  string  object >  selects =  map factory .  <  string  object > get concurrent map (  )  ;  boolean issms = false ;  for  ( int i = 0 ;  i  <  sel count ;  i +  +  )   {  z select item select =  ( z select item ) v selects . get ( i )  ;  if  ( select . is wildcard (  )  ||  ( issms = select . get column (  )  . equals ( sql prettyfier . placeholder   asterix )  )  )   {  if  (  ! issms &&  ! select . get column (  )  . equals ( "*" )  )  throw new  database exception ( "can't execute this type of query at the moment" null sql null )  ;   iterator <  key >  it = qr . key iterator (  )  ;   key k ;  while  ( it . has next (  )  )   {  k = it . next (  )  ;  selects . put ( k . get string (  )  k . get string (  )  )  ;   }  issms = false ;   }  else  {   string alias = select . get alias (  )  ;   string column = select . get column (  )  ;  if  ( alias  =  =  null )  alias = column ;  alias = alias . to lower case (  )  ;  selects . put ( alias select )  ;   }   }   string[] headers = selects . key set (  )  . to array ( new  string[selects . size (  ) ] )  ;   query impl rtn = new  query impl ( headers 0 "query" )  ;  rtn . set sql ( sql )  ;   vector orders = query . get order by (  )  ;  z exp where = query . get where (  )  ;  boolean has maxrow = maxrows  >   -  1  &&  ( orders  =  =  null || orders . size (  )   =  =  0 )  ;  for  ( int row =  1  ;  row  <  =  rec count ;  row +  +  )   {  sql . set position ( 0 )  ;  if  ( has maxrow && maxrows  <  =  rtn . get recordcount (  )  )  break ;  boolean use row = where  =  =  null ||  caster . to boolean value ( execute exp ( pc sql qr where row )  )  ;  if  ( use row )   {  rtn . add row (  1  )  ;  for  ( int cell = 0 ;  cell  <  headers . length ;  cell +  +  )   {   object value = selects . get ( headers[cell] )  ;  rtn . set at ( headers[cell] rtn . get recordcount (  )  get value ( pc sql qr row headers[cell] value )  )  ;   }   }   }  if  ( query . get group by (  )   !  =  null )  throw new  database exception ( "group by are not supported at the moment" null sql null )  ;  if  ( orders  !  =  null && orders . size (  )   >  0 )   {  int len = orders . size (  )  ;  for  ( int i = len  -   1  ;  i  >  =  0 ;  i -  -  )   {  z order by order =  ( z order by ) orders . get ( i )  ;  z constant name =  ( z constant ) order . get expression (  )  ;  rtn . sort ( name . get value (  )  . to lower case (  )  order . get asc order (  )   ?   query . order   asc :  query . order   desc )  ;   }  if  ( maxrows  >   -  1  )   {  rtn . cut rows to ( maxrows )  ;   }   }  if  ( query . is distinct (  )  )   {   string[] keys = rtn . get columns (  )  ;   query column[] columns = new  query column[keys . length] ;  for  ( int i = 0 ;  i  <  columns . length ;  i +  +  )   {  columns[i] = rtn . get column ( keys[i] )  ;   }  int i ;  outer: for  ( int row = rtn . get recordcount (  )  ;  row  >   1  ;  row -  -  )   {  for  ( i = 0 ;  i  <  columns . length ;  i +  +  )   {  if  (  !  operator . equals (  query util . get value ( columns[i] row )   query util . get value ( columns[i] row  -   1  )  true )  )  continue outer ;   }  rtn . remove row ( row )  ;   }   }  z expression set = query . get set (  )  ;  if  ( set  !  =  null )   {  z exp op = set . get operand ( 0 )  ;  if  ( op instanceof z query )  throw new  database exception ( "union is not supported at the moment" null sql null )  ;   }  return rtn ;   }  
public void   (  post load event event )  {  invoke (  common util . post   load event . get entity (  )  )  ;   }  
public static  page source   (  page source requested page  ref boolean iscfc )  {   page source res = requested page . get real page (  constants . app   cfc )  ;  if  ( res . exists (  )  )   {  iscfc . set value ( true )  ;  return res ;   }  res = requested page . get real page (  constants . app   cfm )  ;  if  ( res . exists (  )  )  return res ;  return null ;   }  
public static synchronized  string   (  )  {  counter +  +  ;  if  ( counter  <  0 )  counter =  1  ;  return  long . to string ( counter  character . max   radix )  ;   }  
public   (  search engine support search engine  string name  resource path  string language  date time last update  date time created )  {  this . search engine = search engine ;  this . name = name ;  this . path = path ;  this . language =  search util . translate language ( language )  ;  this . last update = last update ;  this . created = created ;  this . log = search engine . get logger (  )  ;   }  
public  interface impl[]   (  )  {  return interfaces ;   }  
public static  string   (  string ip range )  {  ip range = organizeip range ( ip range )  ;  try  {  return md 5  . get digest as string ( ip range )  ;   }  catch  (  io exception e )   {  return ip range ;   }   }  
private  string   (  )  {  return workbook . get sheet name ( 0 )  ;   }  
public float   (  )  {  return scale ;   }  
public void   ( int x )  {  this . x = x ;   }  
@ override public boolean   (  )  {  return  mode util . is readable ( get mode (  )  )  ;   }  
public int[]   (  )  {   array list lst = new  array list (  )  ;  int count = 0 ;  for  ( int i = offset ;  i  <  offset  +  size ;  i +  +  )   {  int o = arr[i] ;  count +  +  ;  if  ( o  !  =  null )  lst . add (  integer . value of ( count )  )  ;   }  int[] ints = new int[lst . size (  ) ] ;  for  ( int i = 0 ;  i  <  ints . length ;  i +  +  )   {  ints[i] =  (  (  integer ) lst . get ( i )  )  . int value (  )  ;   }  return ints ;   }  
@ override public void   (  throwable t )  {  handle page exception (  caster . to page exception ( t )  )  ;   }  
public  string   (  )  {  return "    get struct:"  +  sct . to string (  )  ;   }  
private  object   (  page context pc sql sql  query qr  operation 2  expression int row )  throws  page exception  {  boolean rtn =  caster . to boolean value ( execute exp ( pc sql qr expression . get left (  )  row )  )  ;  if  ( rtn )  return  boolean . true ;   boolean rtn 2  =  caster . to boolean ( execute exp ( pc sql qr expression . get right (  )  row )  )  ;  return rtn 2  ;   }  
public void   (  string file )  {  this . str file = file ;   }  
public void   (  composite composite )  {  this . composite = composite ;   }  
protected void   (  )  {  last dispose = dispose ;  last rect = new  rectangle ( ix iy iw ih )  ;  last image = image ;  last bg color = bg color ;  lct = null ;   }  
@ override public  object   (  key key  object value )  throws  expression exception  {  throw new  expression exception ( " unsupported  context for  local  scope" " can't invoke key "  +  key . get string (  )   +  "   local  scope can only invoked insi
public void   (  string message )  {  this . message = message ;   }  
public  map   (  )  {  return udfs ;   }  
@ override public boolean   (  )  {  return false ;   }  
public void   (  string path  access control policy acp )  {  acps . put ( to key ( path )  acp )  ;   }  
@ override public long   (  )  {  return exe ;   }  
public void   ( boolean custom tag deep search )  throws  security exception  {  check write access (  )  ;  if  (  !  config web util . has access ( config  security manager . type   custom   tag )  )  throw new  security exception ( "no access to update custom tag setting" )  ;   element element =    get root element ( "custom - tag" )  ;  element . set attribute ( "custom - tag - deep - search"  caster . to string ( custom tag deep search )  )  ;   }  
public   (  selects selects )  {  this . selects = selects ;   }  
public void   (  config config )  {   config impl ci =  (  config impl ) config ;   datasource connection dc = null ;   datasource connection pool pool = ci . get datasource connection pool (  )  ;   log log =  (  (  config impl ) config )  . get scope logger (  )  ;  try  {   page context pc =  thread local page context . get (  )  ;   data source ds ;  if  ( pc  !  =  null )  ds =  (  (  page context impl ) pc )  . get data source ( datasource name )  ;  else ds = config . get data source ( datasource name )  ;  dc = pool . get datasource connection ( null ds null null )  ;  sql executor executor = sql execution factory . get instance ( dc )  ;  executor . delete ( config cfid app name dc get type (  )  log )  ;   }  catch  (   throwable t )   {   scope context . error ( log t )  ;   }  finally  {  if  ( dc  !  =  null )  pool . release datasource connection ( dc )  ;   }   }  
public void   ( boolean tls )  {  smtp . settls ( tls )  ;   }  
private static void   (  struct web  struct server  config impl config )  throws  page exception  {   double struct sct = new  double struct (  )  ;  info mapping ( sct config )  ;  info scopes ( sct server config )  ;  info page context stack ( sct config . get factory (  )  )  ;  info query cache ( sct config . get factory (  )  )  ;  web . set ( config . get config dir (  )  . get path (  )  sct )  ;   }  
public  serializable   (  )  {  return value ;   }  
@ override public void   ( int offset int count  string arg )  throws dom exception  {  text . replace data ( offset count arg )  ;   }  
@ override public boolean   (  key key )  {  return contains (  thread local page context . get (  )  key )  ;   }  
public void   ( boolean xml conform )  {  this . xml conform = xml conform ;   }  
private  string   (  struct struct  map <  object  string >  done  string id )  throws  converter exception  {   string buffer sb = new  string buffer ( go in (  )   +  " < struct id = \""  +  id +  "\" > " )  ;   iterator <  key >  it = struct . key iterator (  )  ;  deep +  +  ;  while  ( it . has next (  )  )   {   key key = it . next (  )  ;   string value =    serialize ( struct . get ( key null )  done )  ;  sb . append ( go in (  )   +  " < entry name = \""  +  key . to string (  )  +  "\" type = \"" +  type +  "\" > " )  ;  sb . append ( value )  ;  sb . append ( go in (  )   +  " <  / entry > " )  ;   }  deep -  -  ;  sb . append ( go in (  )   +  " <  / struct > " )  ;  type = "struct" ;  return sb . to string (  )  ;   }  
public   ( boolean ignore remoting fetch )  {  this . ignore remoting fetch = ignore remoting fetch ;   }  
public float   (  )  {  return centrex ;   }  
@ override public  string   (  string default value )  {  if  ( value  =  =  null )  return super . cast to string ( default value )  ;  return  caster . to string ( value default value )  ;   }  
private static void   (  class vm class  object vm obj  string path )  throws  security exception   no such method exception   illegal argument exception   illegal access exception   invocation target exception  {   method load agent = vm class . get method ( "load agent" new  class[] {  string . class }  )  ;  load agent . invoke ( vm obj new  object[] { path }  )  ;   }  
private boolean   (  )  {  return  string util . is empty ( name )  ;   }  
@ override public  object   (  page context pc  object[] args )  throws  page exception  {  return call ( pc  (  object[] ) args[0] )  ;   }  
public static  struct   (  page context pc  string destination  string file field  string accept  string name conflict  string mode  string attributes  object acl )  throws  page exception  {   security manager security manager = pc . get config (  )  . get security manager (  )  ;  int nc =  file util . to name conflict ( name conflict )  ;  int m =  file tag . to mode ( mode )  ;  return  file tag . action upload ( pc security manager file field destination nc accept true m attributes acl null )  ;   }  
@ override public  boolean   (  boolean default value )  {   object value = get ( position default value )  ;  if  ( value  =  =  null )  return default value ;  return  caster . to boolean ( value default value )  ;   }  
@ override public  object   (  )  {  return null ;   }  
public void   ( float amount )  {  for  ( int i = 0 ;  i  <  num knots ;  i +  +  )   {  int rgb = y knots[i] ;  int r =  (  ( rgb  >  >   1  6  )  & 0xff )  ;  int g =  (  ( rgb  >  >   8  )  & 0xff )  ;  int b =  ( rgb & 0xff )  ;  r =  pixel utils . clamp (  ( int )  ( r  +  amount *  2  5  5  *  (  math . random (  )   -  0 .  5  )  )  )  ;  g =  pixel utils . clamp (  ( int )  ( g  +  amount *  2  5  5  *  (  math . random (  )   -  0 .  5  )  )  )  ;  b =  pixel utils . clamp (  ( int )  ( b  +  amount *  2  5  5  *  (  math . random (  )   -  0 .  5  )  )  )  ;  y knots[i] = 0xff000000 |  ( r  <  <   1  6  )  |  ( g  <  <   8  ) | b ;  knot types[i] = rgb | spline ;   }  sort knots (  )  ;  rebuild gradient (  )  ;   }  
public static  char sequence   (  object obj  char sequence default value )  {  if  ( obj instanceof  char sequence )  return  (  char sequence ) obj ;   string str =  caster . to string ( obj null )  ;  if  ( str  =  =  null )  return default value ;  return str ;   }  
@ override public boolean   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public void   ( double time )  {  this . time =  ( long ) time ;   }  
@ override public boolean   (  )  {  return  mode util . is writable ( get mode (  )  )  ;   }  
public void   ( int[] src int[] dst float alpha )  {  int w = src . length ;  for  ( int i = 0 ;  i  <  w ;  i +  =  4  )   {  int sr = src[i] ;  int dir = dst[i] ;  int sg = src[i  +   1 ] ;  int dig = dst[i  +   1 ] ;  int sb = src[i  +   2 ] ;  int dib = dst[i  +   2 ] ;  int sa = src[i  +   3 ] ;  int dia = dst[i  +   3 ] ;  int dor  dog  dob ;   color . rg btohsb ( sr sg sb shsb )  ;   color . rg btohsb ( dir dig dib dhsb )  ;  dhsb[ 1 ] = shsb[ 1 ] ;  int dorgb =  color . hs btorgb ( dhsb[0] dhsb[ 1 ] dhsb[ 2 ] )  ;  dor =  ( dorgb & 0xff0000 )   >  >   1  6  ;  dog =  ( dorgb & 0xff00 )   >  >   8  ;  dob =  ( dorgb & 0xff )  ;  float a = alpha * sa  /   2  5  5 f ;  float ac =  1   -  a ;  dst[i] =  ( int )  ( a * dor  +  ac * dir )  ;  dst[i  +   1 ] =  ( int )  ( a * dog  +  ac * dig )  ;  dst[i  +   2 ] =  ( int )  ( a * dob  +  ac * dib )  ;  dst[i  +   3 ] =  ( int )  ( sa * alpha  +  dia * ac )  ;   }   }  
@ override public  query impl   ( boolean deep copy )  {  return query . clone query ( deep copy )  ;   }  
private void   (  page context pc  set test  object object  string buffer sb boolean serialize query by columns  set <  object >  done )  throws  converter exception  {  if  ( object  =  =  null || object  =  =  null )   {  sb . append ( go in (  )  )  ;  sb . append ( "null" )  ;  return ;   }  if  ( object instanceof  string || object instanceof  string buffer )   {  sb . append ( go in (  )  )  ;  sb . append ( '"' )  ;  sb . append ( escape ( object . to string (  )  )  )  ;  sb . append ( '"' )  ;  return ;   }  if  ( object instanceof  character )   {  sb . append ( go in (  )  )  ;  sb . append ( '"' )  ;  sb . append ( escape (  string . value of (  (  (  character ) object )  . char value (  )  )  )  )  ;  sb . append ( '"' )  ;  return ;   }  if  ( object instanceof  number )   {  sb . append ( go in (  )  )  ;  sb . append (  caster . to string (  (  (  number ) object )  )  )  ;  return ;   }  if  ( object instanceof  boolean )   {  sb . append ( go in (  )  )  ;  sb . append (  caster . to string (  (  (  boolean ) object )  . boolean value (  )  )  )  ;  return ;   }  if  ( object instanceof  date time )   {     serialize date time (  (  date time ) object sb )  ;  return ;   }  if  ( object instanceof  date )   {     serialize date (  (  date ) object sb )  ;  return ;   }  if  ( object instanceof  node )   {     serializexml (  (  node ) object sb )  ;  return ;   }  if  ( object instanceof  time span )   {     serialize time span (  (  time span ) object sb )  ;  return ;   }  if  ( object instanceof  file )   {     serialize ( pc test  (  (  file ) object )  . get absolute path (  )  sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof  script convertable )   {  sb . append (  (  (  script convertable ) object )  . serialize (  )  )  ;  return ;   }   object raw =  lazy converter . to raw ( object )  ;  if  ( done . contains ( raw )  )   {  sb . append ( go in (  )  )  ;  sb . append ( "null" )  ;  return ;   }  done . add ( raw )  ;  try  {  if  ( object instanceof  component )   {     serialize component ( pc test  (  component ) object sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof udf )   {     serializeudf ( pc test  ( udf ) object sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof  struct )   {     serialize struct ( pc test  (  struct ) object sb serialize query by columns true done )  ;  return ;   }  if  ( object instanceof  map )   {     serialize map ( pc test  (  map ) object sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof  array )   {     serialize array ( pc test  (  array ) object sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof  list )   {     serialize list ( pc test  (  list ) object sb serialize query by columns done )  ;  return ;   }  if  ( object instanceof  query )   {     serialize query ( pc test  (  query ) object sb serialize query by columns done )  ;  return ;   }  if  (  decision . is native array ( object )  )   {  if  ( object instanceof char[] )     serialize ( pc test new  string (  ( char[] ) object )  sb serialize query by columns done )  ;  else  {     serialize array ( pc test  array util . to reference type ( object  array util . object   empty )  sb serialize query by columns done )  ;   }  return ;   }  if  ( object instanceof  object wrap )   {  try  {     serialize ( pc test  (  (  object wrap ) object )  . get embeded object (  )  sb serialize query by columns done )  ;   }  catch  (   page exception e )   {  if  ( object instanceof  java object )   {     serialize class ( pc test  (  (  java object ) object )  . get clazz (  )  null sb serialize query by columns done )  ;   }  else throw new  converter exception ( "can't serialize  object of type [ "  +   caster . to class name ( object )   +  " ]" )  ;   }  return ;   }     serialize class ( pc test object . get class (  )  object sb serialize query by columns done )  ;   }  finally  {  done . remove ( raw )  ;   }   }  
@ override public synchronized void   (  string name boolean throw when not exist )  throws io exception   schedule exception  {   schedule task task = get schedule task ( name )  ;  if  ( task  !  =  null )   {  execute ( task )  ;   }  else if  ( throw 
public static void   (  resource in  resource out )  throws io exception  {   input stream is = null ;   output stream os = null ;  try  {  is = to buffered input stream ( in . get input stream (  )  )  ;  os = to buffered output stream ( out . get output stream (  )  )  ;   }  catch  (  io exception ioe )   {  closeel ( os )  ;  closeel ( is )  ;  throw ioe ;   }  copy ( is os )  ;   }  
public void   (  string column name  array x )  throws sql exception  {  rst . update array ( column name x )  ;   }  
public int   (  )  {  return size ;   }  
private   (  entry before  body content impl body )  {  this . before = before ;  this . body = body ;   }  
@ override public int   (  string str )  throws  page exception  {  return  operator . compare ( cast to string (  )  str )  ;   }  
public void   ( double scale )  {  params . setel ( "scale"  caster . to string (  ( int ) scale )  )  ;   }  
public void   (  string style )  {  this . style = style ;   }  
public void   (  )  throws sql exception  {  rst . refresh row (  )  ;   }  
public float   (  )  {  return angle ;   }  
public float   (  )  {  return coefficients[0] ;   }  
private static boolean   (  flow control fc  string label )  {  if  (  string util . is empty ( label true )  )  return true ;   string fcl = fc . get label (  )  ;  if  (  string util . is empty ( fcl true )  )  return false ;  return label . trim (  )  . equals ignore case ( fcl . trim (  )  )  ;   }  
@ override public void   (  string parameter name  object x int target sql type int scale )  throws sql exception  {  stat . set object ( parameter name x target sql type scale )  ;   }  
@ override public  variables   (  )  {  return variables ;   }  
@ override public int   (  )  throws  page exception  {  throw new  tag not supported ( " ajax import" )  ;   }  
protected   (  document doc boolean case sensitive )  {  super ( doc case sensitive )  ;  this . doc = doc ;   }  
@ override public  enumeration   (  )  {  return null ;   }  
private void   (  bytecode context bc  condition visitor cv  tag tag )  throws  bytecode exception  {  cv . visit othervise before body (  )  ;  tag . get body (  )  . write out ( bc )  ;  cv . visit othervise after body (  )  ;   }  
public void   ( double startrow )  {  this . startrow =  ( int ) startrow ;  if  ( this . startrow  <  =  0 )  this . startrow =  1  ;   }  
@ override public  string   (  )  {  return "operation" ;   }  
public void   (  string prefix )  {  this . image prefix = prefix ;   }  
public  string   (  )  {  return name ;   }  
public synchronized int   ( boolean force )  {  int before = index . size (  )  ;  int flushcfm = 0 ;  while  ( cfms . size (  )   >   1  )   {  flush ( cfms . poll (  )  )  ;  flushcfm +  +  ;   }  if  ( force && flushcfm  <   2  && cfcs . size (  )   >   1  )   {  flush ( oldest ( cfcs )  )  ;  if  ( cfcs . size (  )   >   1  )  flush ( cfcs . poll (  )  )  ;   }  return before  -  index . size (  )  ;   }  
public  < t > t   (  string column label  class < t >  type )  throws sql exception  {  return  ( t )  query util . get object ( this column label type )  ;   }  
public void   (  string action )  {  this . action = action . trim (  )  . to lower case (  )  ;   }  
@ override public float   (  string column name )  throws sql exception  {   object obj = get object ( column name )  ;  if  ( obj  =  =  null )  return 0 ;  try  {  return  caster . to float value ( obj )  ;   }  catch  (   page exception e )   {  throw 
public static boolean   (  object obj )  {  if  ( obj instanceof udf )  return true ;  else if  ( obj instanceof  object wrap )   {  return is function (  (  (  object wrap ) obj )  . get embeded object ( null )  )  ;   }  return false ;   }  
public void   ( short status )  {  this . status = status ;   }  
public void   (  string uri  string name  string q name )  throws sax exception  {  if  ( inside grant )   {  if  ( q name . equals ( " grant" )  )  end grant (  )  ;  else if  ( q name . equals ( " grantee" )  )  inside grantee = false ;   }  else if  ( q name . equals ( " access control list" )  )  inside access control list = false ;  else if  ( q name . equals ( " owner" )  )  inside owners = false ;   }  
@ override public int   (  )  {  return eval   page ;   }  
private void   (  )  throws  page exception  {   mapping[] mappings = config . get custom tag mappings (  )  ;  railo . runtime . type .  query qry = new  query impl ( new  string[] { "archive" "strarchive" "physical" "strphysical" "virtual" "hidden" "physical first" "readonly" "inspect" }  mappings . length "query" )  ;  for  ( int i = 0 ;  i  <  mappings . length ;  i +  +  )   {   mapping impl m =  (  mapping impl ) mappings[i] ;  int row = i  +   1  ;  qry . set at ( "archive" row m . get archive (  )  )  ;  qry . set at ( "strarchive" row m . get str archive (  )  )  ;  qry . set at ( "physical" row m . get physical (  )  )  ;  qry . set at ( "strphysical" row m . get str physical (  )  )  ;  qry . set at ( "virtual" row m . get virtual (  )  )  ;  qry . set at ( "hidden" row  caster . to boolean ( m . is hidden (  )  )  )  ;  qry . set at ( "physical first" row  caster . to boolean ( m . is physical first (  )  )  )  ;  qry . set at ( "readonly" row  caster . to boolean ( m . is readonly (  )  )  )  ;  qry . set at ( "inspect" row  config web util . inspect template ( m . get inspect template raw (  )  "" )  )  ;   }  page context . set variable ( get string ( "admin" action "return variable" )  qry )  ;   }  
@ override public boolean   (  )  {  return false ;   }  
public void   (  http servlet servlet  http servlet request req  http servlet response rsp )  throws  servlet exception  io exception  {  engine . serviceamf ( servlet req rsp )  ;   }  
private  expression exception   ( int pos )  {  return new  expression exception ( " element at position ["  +  pos  +  "] doesn't exist in array" )  ;   }  
private static  string   (  string str  string charset boolean force )  {  str = str . trim (  )  ;  if  (  string util . starts with ( str '"' )  &&  string util . ends with ( str '"' )  )  str = str . substring (  1  str . length (  )   -   1  )  ;  return decode ( str charset force )  ;   }  
public static void   (  http servlet response rsp  string charset )  {  try  {   method set character encoding = rsp . get class (  )  . get method ( "set character encoding" new  class[0] )  ;  set character encoding . invoke ( rsp new  object[0] )  ;   }  catch  (   throwable t )   {   }   }  
public int   ( int x int y int rgb )  {  if  (  ( rgb & 0xff000000 )   !  =  0 )  return  ( rgb & 0xffffff )  | opacity 2  4  ;  return rgb ;   }  
@ override public  object   (  page context pc  key method name  object[] args )  throws  page exception  {   object obj = get ( method name null )  ;  if  ( obj instanceof udf plus )   {  return  (  ( udf plus ) obj )  . call ( pc method name args false 
@ override public int   (  )  throws  page exception  {  try  {     do end tag (  )  ;   }  catch  (   exception e )   {  throw  caster . to page exception ( e )  ;   }  return eval   page ;   }  
private static  memory usage   (  memory usage default value )  {  if  ( perm gen space bean  !  =  null )  return perm gen space bean . get usage (  )  ;   memory poolmx bean tmp = get perm gen space bean (  )  ;  if  ( tmp  !  =  null )  return tmp . get usage (  )  ;  return default value ;   }  
public static  string   (  config config )  {  boolean hascfc = false  hascfml = false ;   string[] extensions = config . get custom tag extensions (  )  ;  for  ( int i = 0 ;  i  <  extensions . length ;  i +  +  )   {  if  ( extensions[i] . equals ignore case ( config . getcfc extension (  )  )  )  hascfc = true ;  else hascfml = true ;   }   string buffer sb = new  string buffer (  )  ;  if  (  ! hascfc )  sb . append ( " component based  custom  tags are not enabled ; " )  ;  if  (  ! hascfml )  sb . append ( "cfml based  custom  tags are not enabled ; " )  ;  return sb . to string (  )  ;   }  
public  map <  string cfml factory >    (  )  {  return init contextes ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public int   (  )  {  return count ;   }  
public short   (  )  {  return status ;   }  
public static int   (  string[] arr  string value )  {  for  ( int i = 0 ;  i  <  arr . length ;  i +  +  )   {  if  ( arr[i] . equals ( value )  )  return i ;   }  return  -  1  ;   }  
@ override public sqlxml   (  string parameter name )  throws sql exception  {  return stat . getsqlxml ( parameter name )  ;   }  
@ override public boolean   (  )  throws sql exception  {  return res . row inserted (  )  ;   }  
private static  security manager impl   (  element el )  {   security manager impl sm = new  security manager impl (    attr ( el "setting"  security manager . value   yes )     attr ( el "file"  security manager . value   all )     attr ( el "direct   java   access"  security manager . value   yes )     attr ( el "mail"  security manager . value   yes )     attr ( el "datasource"  security manager . value   yes )     attr ( el "mapping"  security manager . value   yes )     attr ( el "remote"  security manager . value   yes )     attr ( el "custom   tag"  security manager . value   yes )     attr ( el "cfx   setting"  security manager . value   yes )     attr ( el "cfx   usage"  security manager . value   yes )     attr ( el "debugging"  security manager . value   yes )     attr ( el "search"  security manager . value   yes )     attr ( el "scheduled   task"  security manager . value   yes )     attr ( el "tag   execute"  security manager . value   yes )     attr ( el "tag   import"  security manager . value   yes )     attr ( el "tag   object"  security manager . value   yes )     attr ( el "tag   registry"  security manager . value   yes )     attr ( el "cache"  security manager . value   yes )     attr ( el "gateway"  security manager . value   yes )     attr ( el "orm"  security manager . value   yes )     attr 2  ( el "access   read"  security manager . access   protected )     attr 2  ( el "access   write"  security manager . access   protected )  )  ;  return sm ;   }  
@ override public  collection .  key[]   (  )  {  return  collection util . keys ( this )  ;   }  
private void   (  )  throws  security exception   page exception  {  config . getorm config (  )  ;  admin . resetorm setting (  )  ;  store (  )  ;  admin sync . broadcast ( attributes config )  ;   }  
public byte[]   (  string format boolean no meta )  throws  page exception  {   byte array output stream baos = new  byte array output stream (  )  ;  if  ( jai util . is supported write format ( format )  )   {  try  {  jai util . write ( get buffered image (  )  baos format )  ;   }  catch  (  io exception e )   {  throw  caster . to page exception ( e )  ;   }   }  else  {   image output stream ios = null ;  try  {  ios =  imageio . create image output stream ( baos )  ;     write out ( ios format  1  no meta )  ;   }  catch  (  io exception e )   {  throw  caster . to page exception ( e )  ;   }  finally  {  io util . closeel ( ios )  ;   }   }  return baos . to byte array (  )  ;   }  
public   (  iterator <  key >  keys  objects objs )  {  this . keys = keys ;  this . objs = objs ;   }  
public  string   (  )  {  return provider ;   }  
@ override public  boolean   (  boolean default value )  {  return default value ;   }  
public   (  resource filter[] filters )  {  this . filters = filters ;   }  
int   (  )  {   page context pc =  thread local page context . get (  )  ;  if  ( pc  =  =  null )   {  pc = cfml engine factory . get instance (  )  . get thread page context (  )  ;  if  ( pc  =  =  null )  throw new  runtime exception ( "cannot get pid for current thread" )  ;   }  return pc . get id (  )  ;   }  
@ override public url   (  )  {  return get config server impl (  )  . get update location (  )  ;   }  
public   (  component component )  {  super ( component  common util . pre   update false )  ;   }  
public void   ( double proxyport )  {  proxy . set port (  ( int ) proxyport )  ;   }  
public boolean   (  )  {  if  (  ! is valid index (  )  )  return false ;  return lc text[pos]  =  =  '"' || lc text[pos]  =  =  '\'' ;   }  
public void   (  )  {   system util . sleep (  2 000 )  ;   }  
@ override public void   ( int to )  throws  page exception  {  throw new  caster exception ( sct " array" )  ;   }  
public  expression   (  )  {  return exp ;   }  
@ override public  object   (  page context pc  key name  object[] args )  throws  page exception  {  return comp .    call ( pc get access (  )  name null args true )  ;   }  
public boolean   (  )  {  return premultiply alpha ;   }  
public long   (  )  {  return h 6  4  ;   }  
public void   (  string font color )  {  this . font color = font color ;   }  
@ override public boolean   (  key key )  {  return  reflector . has property ignore case ( jo . get clazz (  )  key . get string (  )  )  ;   }  
@ override public  object   (  collection .  key key )  throws  page exception  {  return component . remove ( key )  ;   }  
public boolean   (  )  {  return disk persistent ;   }  
private  ref   (  )  throws  page exception  {   ref ref = null ;  if  ( cfml . is current quoter (  )  )   {  return string (  )  ;   }  if  ( cfml . is current digit (  )  || cfml . is current ( ' . ' )  )   {  return number (  )  ;   }  if  (  ( ref = dynamic (  )  )   !  =  null )   {  mode = dynamic ;  return ref ;   }  if  (  ( ref = sharp (  )  )   !  =  null )   {  mode = dynamic ;  return ref ;   }  if  (  ( ref = json ( json   array '[' ']' )  )   !  =  null )   {  mode = dynamic ;  return ref ;   }  if  (  ( ref = json ( json   struct ' { ' ' } ' )  )   !  =  null )   {  mode = dynamic ;  return ref ;   }  if  ( cfml . is after last (  )  && cfml . to string (  )  . trim (  )  . length (  )   =  =  0 )  return new l string ( "" )  ;   string str = cfml . to string (  )  ;  int pos = cfml . get pos (  )  ;  if  ( str . length (  )   >   1 00 )   {  if  ( pos  <  =   1 0 )   {  str = str . substring ( 0  2 0 )   +  "  .  .  . " ;   }  else if  (  ( str . length (  )   -  pos )   <  =   1 0 )   {  str = " .  .  .  "  +  str . substring ( str . length (  )   -   2 0 str . length (  )  )  ;   }  else  {  str = " .  .  .  "  +  str . substring ( pos  -   1 0 pos  +   1 0 )   +  "  .  .  . " ;   }   }  throw new  interpreter exception ( " syntax  error   invalid  construct" "at position "  +   ( pos  +   1  )   +  " in [" +  str +  "]" )  ;   }  
@ override public  input stream   (  string column name )  throws sql exception  {   object obj = get object ( column name )  ;  if  ( obj  =  =  null )  return null ;  try  {  return  caster . to input stream ( obj  (  charset ) null )  ;   }  catch  (  
private static void   (  resource source  resource target )  throws io exception  {   resource tmp =  system util . get temp directory (  )  . get real resource (  system . current time millis (  )   +  " . tmp" )  ;  try  {  extractg zip ( source tmp )  ;  extract tar ( tmp target )  ;   }  finally  {  tmp . delete (  )  ;   }   }  
public void   (  string access key id )  {  this . access key id = access key id ;   }  
@ override public void   (  )  {  super . release (  )  ;  showerror = null ;  this . type = railo . runtime . exp .  abort . scope   request ;   }  
@ override public int   (  )  {  return eval   page ;   }  
public void   (  string griddataalign )  {  this . griddataalign = griddataalign ;   }  
public int   (  )  {  return properties . index ;   }  
private  session factory data   (  page context pc int init type )  throws  page exception  {   application context pro app context =  (  application context pro ) pc . get application context (  )  ;  if  (  ! app context . isorm enabled (  )  )  throw  exception util . create exception (  ( orm session ) null null "orm is not enabled" "" )  ;   data source ds = orm util . get data source ( pc )  ;  orm configuration orm conf = app context . getorm configuration (  )  ;   string key = hash ( orm conf ds )  ;   session factory data data = factories . get ( key )  ;  if  ( init type  =  =  init   all && data  !  =  null )   {  data . reset (  )  ;  data = null ;   }  if  ( data  =  =  null )   {  data = new  session factory data ( this orm conf ds )  ;  factories . put ( key data )  ;   }  try  {  if  ( init type  !  =  init   nothing )   {  synchronized  ( data )   {  if  ( orm conf . autogenmap (  )  )   {  data . tmp list =  hibernate session factory . load components ( pc this orm conf )  ;  data . cfcs . clear (  )  ;   }  else throw  exception util . create exception ( data null "orm setting autogenmap = false is not supported yet" null )  ;  if  (  !  array util . is empty ( data . tmp list )  )   {  data . get naming strategy (  )  ;   datasource connection dc =  common util . get datasource connection ( pc ds )  ;  try  {   iterator <  component >  it = data . tmp list . iterator (  )  ;  while  ( it . has next (  )  )   {  create mapping ( pc it . next (  )  dc orm conf data )  ;   }   }  finally  {   common util . release datasource connection ( pc dc )  ;   }  if  ( data . tmp list . size (  )   !  =  data . cfcs . size (  )  )   {   component cfc ;   string name  lc name ;   map <  string  string >  names = new  hash map <  string  string >  (  )  ;   iterator <  component >  it = data . tmp list . iterator (  )  ;  while  ( it . has next (  )  )   {  cfc = it . next (  )  ;  name =  hibernate caster . get entity name ( cfc )  ;  lc name = name . to lower case (  )  ;  if  ( names . contains key ( lc name )  )  throw  exception util . create exception ( data null " entity  name ["  +  name  +  "] is ambigous  [" +  names . get ( lc name )  +  "] and [" +  cfc . get page source (  )  . get display path (  )  +  "] use the same entity name . " "" )  ;  names . put ( lc name cfc . get page source (  )  . get display path (  )  )  ;   }   }   }   }   }   }  finally  {  data . tmp list = null ;   }  if  ( data . get configuration (  )   !  =  null )  return data ;   string mappings =  hibernate session factory . create mappings ( orm conf data )  ;   datasource connection dc =  common util . get datasource connection ( pc ds )  ;  try  {  data . set configuration ( mappings dc )  ;   }  catch  (   exception e )   {  throw  common util . to page exception ( e )  ;   }  finally  {   common util . release datasource connection ( pc dc )  ;   }  add event listeners ( pc data )  ;   entity tuplizer factory tuplizer factory = data . get configuration (  )  . get entity tuplizer factory (  )  ;  tuplizer factory . register default tuplizer class (  entity mode . map  abstract entity tuplizer impl . class )  ;  tuplizer factory . register default tuplizer class (  entity mode . pojo  abstract entity tuplizer impl . class )  ;  data . build session factory (  )  ;  return data ;   }  
@ override public void   (  )  throws sql exception  {  log (  )  ;  qry . refresh row (  )  ;   }  
public  string   (  )  {  return proxyserver ;   }  
private int   (  data source datasource )  {  return    get counter ( datasource )  . to int (  )  ;   }  
public void   ( boolean transparent )  {  this . transparent = transparent ;   }  
public boolean   (  collection <  ?  extends e >  coll )  {  synchronized  ( mutex )   {  return c . add all ( coll )  ;   }   }  
@ override public  string   (  )  {  return path ;   }  
@ override public int   (  )  {  return skip   body ;   }  
@ override public  ref   (  page context pc )  throws  page exception  {  return null ;   }  
public static  type   (  class metadata meta data  string name  type default value )  {  try  {  return meta data . get property type ( name )  ;   }  catch  (   hibernate exception he )   {  if  ( name . equals ignore case ( meta data . get identifier property name (  )  )  )  return meta data . get identifier type (  )  ;   string[] names = meta data . get property names (  )  ;  for  ( int i = 0 ;  i  <  names . length ;  i +  +  )   {  if  ( names[i] . equals ignore case ( name )  )  return meta data . get property type ( names[i] )  ;   }  return default value ;   }   }  
private void   (  struct cfhttp  throwable t )  {  cfhttp . setel ( charset "" )  ;  cfhttp . setel ( error   detail " unknown host: "  +  t . get message (  )  )  ;  cfhttp . setel ( file   content " connection  failure" )  ;  cfhttp . setel (  key constants .    header "" )  ;  cfhttp . setel (  key constants .    mimetype " unable to determine mime type of file . " )  ;  cfhttp . setel ( responseheader new  struct impl (  )  )  ;  cfhttp . setel ( statuscode " connection  failure .   status code unavailable . " )  ;  cfhttp . setel (  key constants .    text  boolean . true )  ;   }  
@ override public void   (  )  {   collection .  key[] keys = keys (  )  ;  for  ( int i = 0 ;  i  <  keys . length ;  i +  +  )   {  node map . remove named item ( keys[i] . get string (  )  )  ;   }   }  
@ override public void   (  string str )  throws io exception  {  writer . write ( str )  ;   }  
@ override public  object   (  collection .  key key )  {  if  ( check arguments && local . contains key ( key )  )  return local . removeel ( key )  ;  return variable . removeel ( key )  ;   }  
public static  document   (  string buffer content  reader reader )  {   document doc = new  document (  )  ;  html parser parser = new html parser (  )  ;  try  {   string str = io util . to string ( reader )  ;  if  ( content  !  =  null )  content . append ( str )  ;  doc . add (  field util .  un indexed ( "size"  caster . to string ( str . length (  )  )  )  )  ;   string reader sr = new  string reader ( str )  ;  parser . parse ( sr )  ;   }  catch  (   throwable t )   {  return doc ;   }  add content ( doc parser )  ;  return doc ;   }  
@ override public void   ( boolean orm enabled )  {  this . orm enabled = orm enabled ;   }  
@ override public boolean   (  )  {  return true ;   }  
public   (  collection coll  collection .  key[] keys )  {  this . coll = coll ;  this . keys = keys ;   }  
public static  string   (  )  {  return "0" ;   }  
@ override public char   ( int index )  {  return get lower string (  )  . char at ( index )  ;   }  
@ override public void   ( int row int col  string value )  throws  index out of bounds exception  {  disconnect cache (  )  ;  query . set data ( row col value )  ;   }  
@ override public void   (  )  throws sql exception  {  get connection (  )  . close (  )  ;   }  
private static  string   (  resource file )  {   string name = file . get name (  )  ;  int pos = name . last index of ( " . " )  ;  if  ( pos  =  =   -  1  )  return name ;  return name . substring ( 0 pos )  ;   }  
public void   (  string valuesdisplay )  {  this . valuesdisplay = valuesdisplay ;   }  
@ override public  object   (  key key )  {  return xml util . remove property ( node key case sensitive )  ;   }  
private final boolean   ( int i )  {  jj   la = i ;  jj   lastpos = jj   scanpos = token ;  boolean flag =  ! jj    3     1 0 (  )  ;  jj   save (  9  i )  ;  return flag ;   }  
private static void   (  config server config server  config impl config  document doc int mode )  {   element component = get child by name ( doc . get document element (  )  "component" )  ;  boolean has access =  config web util . has access ( config  security manager . type   setting )  ;  boolean has set = false ;  boolean hascs = config server  !  =  null ;  if  ( component  !  =  null && has access )   {   string strcdi = component . get attribute ( "component - default - import" )  ;  if  (  string util . is empty ( strcdi true )  && config server  !  =  null )   {  strcdi =  (  (  config server impl ) config server )  . get component default import (  )  . to string (  )  ;   }  if  (  !  string util . is empty ( strcdi true )  )  config . set component default import ( strcdi )  ;   string str base = component . get attribute ( "base" )  ;  if  (  string util . is empty ( str base true )  && config server  !  =  null )   {  str base = config server . get base component template (  )  ;   }  config . set base component template ( str base )  ;  if  ( mode  =  =   config impl . mode   strict )   {  config . set do component deep search ( false )  ;   }  else  {   string str deep search = component . get attribute ( "deep - search" )  ;  if  (  !  string util . is empty ( str deep search )  )   {  config . set do component deep search (  caster . to boolean value ( str deep search . trim (  )  false )  )  ;   }  else if  ( hascs )   {  config . set do component deep search (  (  (  config server impl ) config server )  . do component deep search (  )  )  ;   }   }   string str dump remplate = component . get attribute ( "dump - template" )  ;  if  (  ( str dump remplate  =  =  null || str dump remplate . trim (  )  . length (  )   =  =  0 )  && config server  !  =  null )   {  str dump remplate = config server . get component dump template (  )  ;   }  config . set component dump template ( str dump remplate )  ;  if  ( mode  =  =   config impl . mode   strict )   {  config . set component data member default access (  component . access   private )  ;   }  else  {   string str dmda = component . get attribute ( "data - member - default - access" )  ;  if  ( str dmda  !  =  null && str dmda . trim (  )  . length (  )   >  0 )   {  str dmda = str dmda . to lower case (  )  . trim (  )  ;  if  ( str dmda . equals ( "remote" )  )  config . set component data member default access (  component . access   remote )  ;  else if  ( str dmda . equals ( "public" )  )  config . set component data member default access (  component . access   public )  ;  else if  ( str dmda . equals ( "package" )  )  config . set component data member default access (  component . access   package )  ;  else if  ( str dmda . equals ( "private" )  )  config . set component data member default access (  component . access   private )  ;   }  else if  ( config server  !  =  null )   {  config . set component data member default access ( config server . get component data member default access (  )  )  ;   }   }  if  ( mode  =  =   config impl . mode   strict )   {  config . set trigger component data member ( true )  ;   }  else  {   boolean tp =  caster . to boolean ( component . get attribute ( "trigger - data - member" )  null )  ;  if  ( tp  !  =  null )  config . set trigger component data member ( tp . boolean value (  )  )  ;  else if  ( config server  !  =  null )   {  config . set trigger component data member ( config server . get trigger component data member (  )  )  ;   }   }  if  ( mode  =  =   config impl . mode   strict )   {  config . set component local search ( false )  ;   }  else  {   boolean ls =  caster . to boolean ( component . get attribute ( "local - search" )  null )  ;  if  ( ls  !  =  null )  config . set component local search ( ls . boolean value (  )  )  ;  else if  ( config server  !  =  null )   {  config . set component local search (  (  (  config server impl ) config server )  . get component local search (  )  )  ;   }   }   boolean ucp =  caster . to boolean ( component . get attribute ( "use - cache - path" )  null )  ;  if  ( ucp  !  =  null )  config . set use component path cache ( ucp . boolean value (  )  )  ;  else if  ( config server  !  =  null )   {  config . set use component path cache (  (  (  config server impl ) config server )  . use component path cache (  )  )  ;   }  if  ( mode  =  =   config impl . mode   strict )   {  config . set use component shadow ( false )  ;   }  else  {   boolean ucs =  caster . to boolean ( component . get attribute ( "use - shadow" )  null )  ;  if  ( ucs  !  =  null )  config . set use component shadow ( ucs . boolean value (  )  )  ;  else if  ( config server  !  =  null )   {  config . set use component shadow ( config server . use component shadow (  )  )  ;   }   }   }  else if  ( config server  !  =  null )   {  config . set base component template ( config server . get base component template (  )  )  ;  config . set component dump template ( config server . get component dump template (  )  )  ;  if  ( mode  =  =   config impl . mode   strict )   {  config . set component data member default access (  component . access   private )  ;  config . set trigger component data member ( true )  ;   }  else  {  config . set component data member default access ( config server . get component data member default access (  )  )  ;  config . set trigger component data member ( config server . get trigger component data member (  )  )  ;   }   }  if  ( mode  =  =   config impl . mode   strict )   {  config . set do component deep search ( false )  ;  config . set component data member default access (  component . access   private )  ;  config . set trigger component data member ( true )  ;  config . set component local search ( false )  ;  config . set use component shadow ( false )  ;   }   element[] c mappings = get children ( component "mapping" )  ;  has set = false ;   mapping[] mappings = null ;  if  ( has access && c mappings . length  >  0 )   {  mappings = new  mapping[c mappings . length] ;  for  ( int i = 0 ;  i  <  c mappings . length ;  i +  +  )   {   element c mapping = c mappings[i] ;   string physical = c mapping . get attribute ( "physical" )  ;   string archive = c mapping . get attribute ( "archive" )  ;  boolean readonly = to boolean ( c mapping . get attribute ( "readonly" )  false )  ;  boolean hidden = to boolean ( c mapping . get attribute ( "hidden" )  false )  ;  short insp temp = inspect template ( c mapping )  ;   string virtual =  config web admin . create virtual ( c mapping )  ;  int cl max el = to int ( c mapping . get attribute ( "classloader - max - elements" )   1 00 )  ;   string primary = c mapping . get attribute ( "primary" )  ;  boolean physical first = archive  =  =  null ||  ! primary . equals ignore case ( "archive" )  ;  has set = true ;  mappings[i] = new  mapping impl ( config virtual physical archive insp temp physical first hidden readonly true false true null cl max el )  ;   }  config . set component mappings ( mappings )  ;   }  if  ( hascs )   {   mapping[] originals =  (  (  config server impl ) config server )  . get component mappings (  )  ;   mapping[] clones = new  mapping[originals . length] ;   linked hash map map = new  linked hash map (  )  ;   mapping m ;  for  ( int i = 0 ;  i  <  clones . length ;  i +  +  )   {  m =  (  (  mapping impl ) originals[i] )  . clone read only ( config )  ;  map . put ( to key ( m )  m )  ;   }  if  ( mappings  !  =  null )   {  for  ( int i = 0 ;  i  <  mappings . length ;  i +  +  )   {  m = mappings[i] ;  map . put ( to key ( m )  m )  ;   }   }  if  ( originals . length  >  0 )   {  clones = new  mapping[map . size (  ) ] ;   iterator it = map . entry set (  )  . iterator (  )  ;   map .  entry entry ;  int index = 0 ;  while  ( it . has next (  )  )   {  entry =  (  entry ) it . next (  )  ;  clones[index +  + ] =  (  mapping ) entry . get value (  )  ;   }  has set = true ;  config . set component mappings ( clones )  ;   }   }  if  (  ! has set )   {   mapping impl m = new  mapping impl ( config " / default" " { railo - web }  / components / " null  config impl . inspect   undefined true false false true false true null )  ;  config . set component mappings ( new  mapping[] { m . clone read only ( config )  }  )  ;   }   }  
private void   (  object input stream stream )  throws io exception   class not found exception  {  stream . default read object (  )  ;  this . paint =  serial utilities . read paint ( stream )  ;   }  
public void   ( boolean noname )  {  this . noname = noname ;   }  
public  dimension   (  )  {  return new  dimension ( width height )  ;   }  
@ override public void   ( boolean bind )  {  this . bind = bind ;   }  
public void   (  )  throws  page exception  {  invoke ( pd 4 ml "adjust html width" )  ;   }  
@ override public int   (  )  throws  page exception  {  return eval   body   buffered ;   }  
public void   ( double offset )  {  this . offset = offset ;   }  
public void   (  string method )  throws  application exception  {  method = method . to lower case (  )  . trim (  )  ;  if  ( method . equals ( "post" )  )  this . method = method   post ;  else if  ( method . equals ( "get" )  )  this . method = method   get ;  else if  ( method . equals ( "head" )  )  this . method = method   head ;  else if  ( method . equals ( "delete" )  )  this . method = method   delete ;  else if  ( method . equals ( "put" )  )  this . method = method   put ;  else if  ( method . equals ( "trace" )  )  this . method = method   trace ;  else if  ( method . equals ( "options" )  )  this . method = method   options ;  else if  ( method . equals ( "patch" )  )  this . method = method   patch ;  else throw new  application exception ( "invalid method type ["  +   ( method . to upper case (  )  )   +  "]  valid types are post get head delete put trace options patch" )  ;   }  
public boolean   (  connection data data int full path hash  string path  string name long time )  {  try  {   attr attr = get attr ( data full path hash path name )  ;   datasource connection dc = get datasource connection ( data )  ;  try  {  get core ( data )  . set last modified ( dc data . get prefix (  )  attr time )  ;   }  finally  {  remove from cache ( data path name )  ;  release ( dc )  ;   }   }  catch  (   throwable t )   {  return false ;   }  return true ;   }  
@ override public  statement   (  )  throws sql exception  {  log (  )  ;  return qry . get statement (  )  ;   }  
public static  string   (  page context pc  string list  string delimiter boolean include empty fields )  {  return  list util . last ( list delimiter  ! include empty fields )  ;   }  
public void   (  string str scriptrotect )  {  this . scriptrotect = str scriptrotect ;   }  
public int   ( float v )  {  int n =  ( int )  ( v *  2  5  5  )  ;  if  ( n  <  0 )  n = 0 ;  else if  ( n  >   2  5  5  )  n =  2  5  5  ;  return map[n] ;   }  
public static  entity   ( byte[] barr  string content type )  {  if  ( use 4  )  return http engine 4  impl . get byte array entity ( barr content type )  ;  return http engine 3  impl . get byte array entity ( barr content type )  ;   }  
public void   ( int h radius )  {  this . h radius = h radius ;   }  
public  content type   (  )  {  return  resource util . get content type ( this )  ;   }  
public static float   ( float a float b )  {  return a  /   (  (  1  . 0f  /  b  -   2  )  *  (  1  . 0f  -  a )   +   1  )  ;   }  
public static  string   (  page context pc  string str url )  {   cookie[] cookies =  req rsp util . get cookies ( pc . get config (  )  pc . get http servlet request (  )  )  ;  if  (  ! pc . get application context (  )  . is set client cookies (  )  || cookies  =  =  null )   {  int indexq = str url . index of ( ' ? ' )  ;  int indexa = str url . index of ( '&' )  ;  int len = str url . length (  )  ;  if  ( indexq  =  =  len  -   1  || indexa  =  =  len  -   1  )  str url +  = pc . geturl token (  )  ;  else if  ( indexq  !  =   -  1  )  str url +  = "&"  +  pc . geturl token (  )  ;  else str url +  = " ? "  +  pc . geturl token (  )  ;   }  return str url ;   }  
public void   ( boolean enabled )  {  this . enabled = enabled ;   }  
@ override public  time span   (  )  {  if  (  ! init client timeout )   {   object o = get ( component client   timeout null )  ;  if  ( o  !  =  null )  client timeout =  caster . to timespan ( o client timeout )  ;  init client timeout = true ;   }  re
private void   ( z query query  set <  string >  tables names )  {   vector tables = query . get from (  )  ;   enumeration e = tables . elements (  )  ;  while  ( e . has more elements (  )  )   {  z from item from item =  ( z from item ) e . next element (  )  ;  tables names . add ( from item . get full name (  )  )  ;   }  z exp where = query . get where (  )  ;  if  ( where instanceof z expression )   {  parsez expression (  ( z expression ) where tables names )  ;   }  z expression set = query . get set (  )  ;  if  ( set  !  =  null )   {  is union = true ;  z exp op = set . get operand ( 0 )  ;  if  ( op instanceof z query )  get invoked tables (  ( z query ) op tables names )  ;   }   }  
@ override public  string   (  )  {  return pe . get error code (  )  ;   }  
@ override public void   (  cache entry entry )  {  call ( on   put entry )  ;   }  
public static  header   (  http response rsp  string name )  {  org . apache . http .  header header = rsp . get last header ( name )  ;  if  ( header  !  =  null )  return new  header wrap ( header )  ;  org . apache . http .  header[] headers = rsp . get all headers (  )  ;  for  ( int i = headers . length  -   1  ;  i  >  =  0 ;  i -  -  )   {  if  ( name . equals ignore case ( headers[i] . get name (  )  )  )   {  return new  header wrap ( headers[i] )  ;   }   }  return null ;   }  
public void   (  access control policy acp )  {  try  {  s 3  . set access control policy ( bucket name get object name (  )  acp )  ;   }  catch  (   exception e )   {  throw new  page runtime exception (  caster . to page exception ( e )  )  ;   }  finally  {  s 3  . release cache ( get inner path (  )  )  ;   }   }  
@ override public  dump data   (  page context page context int maxlevel  dump properties dp )  {  throw new  page runtime exception ( new  expression exception ( " unsupported  context for  local  scope" )  )  ;   }  
@ override public boolean   (  object obj )  {  return time zone . equals ( obj )  ;   }  
@ override public  object   (  key key  object value )  {  return value ;   }  
public  active lock   (  )  {  return active locks . pop (  )  ;   }  
private void   (  list urls cfml string cfml  tag tag url url )  {  char quote = 0 ;  boolean inside = false ;   string builder value = new  string builder (  )  ;  while  (  ! cfml . is after last (  )  )   {  if  ( inside )   {  if  ( quote  !  =  0 && cfml . forward if current ( quote )  )   {  inside = false ;  add ( urls url value . to string (  )  )  ;   }  else if  ( quote  =  =  0 &&  ( cfml . is current ( ' ' )  || cfml . is current ( " /  > " )  || cfml . is current ( ' > ' ) || cfml . is current ( '\t' ) || cfml . is current ( '\n' )  )  )   {  inside = false ;  try  {  urls . add ( new url ( url value . to string (  )  )  )  ;   }  catch  (   malformedurl exception e )   {   }  cfml . next (  )  ;   }  else  {  value . append ( cfml . get current (  )  )  ;  cfml . next (  )  ;   }   }  else if  ( cfml . forward if current ( ' > ' )  )   {  break ;   }  else  {  for  ( int i = 0 ;  i  <  tag . attributes . length ;  i +  +  )   {  if  ( cfml . forward if current ( tag . attributes[i] )  )   {  cfml . remove space (  )  ;  if  ( cfml . is current ( ' = ' )  )   {  inside = true ;  cfml . next (  )  ;  cfml . remove space (  )  ;  quote = cfml . get current (  )  ;  value = new  string builder (  )  ;  if  ( quote  !  =  '"' && quote  !  =  '\'' )  quote = 0 ;  else  {  cfml . next (  )  ;   }   }   }   }  if  (  ! inside )   {  cfml . next (  )  ;   }   }   }   }  
public void   ( boolean buffer output )  {  this . buffer output = buffer output ;   }  
public   ( boolean ignore fatal boolean ignore error boolean ignore warning )  {  this . ignore fatal = ignore fatal ;  this . ignore error = ignore error ;  this . ignore warning = ignore warning ;   }  
public  string   (  )  {  return name ;   }  
@ override public void   ( java . io .  object input in )  throws java . io . io exception   class not found exception  {  this . put all (  (  map ) in . read object (  )  )  ;   }  
private static void   (  file f )  {   file temp = new  file ( f . get path (  )  . to upper case (  )  )  ;  isfs case sensitive = temp . exists (  )   ?   boolean . false :  boolean . true ;  f . delete (  )  ;   }  
public  literal   (  literal literal )  {  list . add ( literal )  ;  return literal ;   }  
public static  resource   (  )  {  if  ( home file  !  =  null )  return home file ;   resource provider frp =  resources impl . get file resource provider (  )  ;   string home str =  system . get property ( "user . home" )  ;  if  ( home str  !  =  null )   {  home file = frp . get resource ( home str )  ;  home file =  resource util . get canonical resourceel ( home file )  ;   }  return home file ;   }  
@ override public  blob   (  string col name )  throws sql exception  {  log ( col name )  ;  return qry . get blob ( col name )  ;   }  
public void   (  string uri  string name  string q name  attributes atts )  {  inside = q name ;  if  ( q name . equals ( "tag" )  )  start tag (  )  ;  else if  ( q name . equals ( "attribute" )  )  start att (  )  ;  else if  ( q name . equals ( "script" )  )  start script (  )  ;   }  
public   (  string charset int size )  {  buffer = new byte[size] ;  this . charset = charset ;   }  
public static  class writer   (  )  {  return new  class writer (  class writer . compute   maxs |  class writer . compute   frames )  ;   }  
@ override public  iterator <  collection .  key >    (  )  {  return new  key iterator ( keys (  )  )  ;   }  
public static  pair <  string  object > []   (  pair <  string  object > [] items  string name  object value )  {  for  ( int i = 0 ;  i  <  items . length ;  i +  +  )   {  if  ( items[i] . get name (  )  . equals ignore case ( name )  )   {  items[i] = new  pair <  string  object >  ( name value )  ;  return items ;   }   }  return add ( items name value )  ;   }  
public void   (  string password )  {  this . password = password ;   }  
public railo . runtime . video .  range   (  )  {  return show ;   }  
public  string   (  )  {  return " transitions /  gradient  wipe .  .  . " ;   }  
public  string   (  )  {  return null ;   }  
@ override public int   (  )  {  return eval   page ;   }  
private void   (  statement stat int maxrow int fetchsize int timeout )  throws sql exception  {  if  ( maxrow  >   -  1  )  stat . set max rows ( maxrow )  ;  if  ( fetchsize  >  0 )  stat . set fetch size ( fetchsize )  ;  if  ( timeout  >  0 )  stat . set query timeout ( timeout )  ;   }  
private void   (  resource dir  string name )  throws io exception  {  if  ( dir . is directory (  )  )   {   resource[] children = dir . list resources ( new  my resource name filter ( name )  )  ;  for  ( int i = 0 ;  i  <  children . length ;  i +  +  )   {  children[i] . remove ( false )  ;   }   }   }  
private void   (  )  throws  page exception  {   schedule task[] tasks = scheduler . get all schedule tasks (  )  ;  final  string v = "varchar" ;   string[] cols = new  string[] { "task" "path" "file" "startdate" "starttime" "enddate" "endtime" "url" "port" "interval" "timeout" "username" "password" "proxyserver" "proxyport" "proxyuser" "proxypassword" "resolveurl" "publish" "valid" "paused" "auto delete" }  ;   string[] types = new  string[] { v v v "date" "other" "date" "other" v v v v v v v v v v v "boolean" v "boolean" "boolean" }  ;  railo . runtime . type .  query query = new  query impl ( cols types tasks . length "query" )  ;  try  {  for  ( int i = 0 ;  i  <  tasks . length ;  i +  +  )   {  int row = i  +   1  ;   schedule task task = tasks[i] ;  query . set at (  key constants .    task row task . get task (  )  )  ;  if  ( task . get resource (  )   !  =  null )   {  query . set at (  key constants .    path row task . get resource (  )  . get parent (  )  )  ;  query . set at (  key constants .    file row task . get resource (  )  . get name (  )  )  ;   }  query . set at ( "publish" row  caster . to boolean ( task . is publish (  )  )  )  ;  query . set at ( "startdate" row task . get start date (  )  )  ;  query . set at ( "starttime" row task . get start time (  )  )  ;  query . set at ( "enddate" row task . get end date (  )  )  ;  query . set at ( "endtime" row task . get end time (  )  )  ;  query . set at (  key constants .    url row print url ( task . get url (  )  )  )  ;  query . set at (  key constants .    port row  caster . to string ( http util . get port ( task . get url (  )  )  )  )  ;  query . set at ( "interval" row task . get string interval (  )  )  ;  query . set at ( "timeout" row  caster . to string ( task . get timeout (  )   /   1 000 )  )  ;  query . set at ( "valid" row  caster . to string ( task . is valid (  )  )  )  ;  if  ( task . has credentials (  )  )   {  query . set at ( "username" row task . get credentials (  )  . get username (  )  )  ;  query . set at ( "password" row task . get credentials (  )  . get password (  )  )  ;   }   proxy data pd = task . get proxy data (  )  ;  if  (  proxy data impl . is valid ( pd )  )   {  query . set at ( "proxyserver" row pd . get server (  )  )  ;  if  ( pd . get port (  )   >  0 )  query . set at ( "proxyport" row  caster . to string ( pd . get port (  )  )  )  ;  if  (  proxy data impl . has credentials ( pd )  )   {  query . set at ( "proxyuser" row pd . get username (  )  )  ;  query . set at ( "proxypassword" row pd . get password (  )  )  ;   }   }  query . set at ( "resolveurl" row  caster . to string ( task . is resolveurl (  )  )  )  ;  query . set at ( "paused" row  caster . to boolean ( task . is paused (  )  )  )  ;  query . set at ( "auto delete" row  caster . to boolean (  (  (  schedule task impl ) task )  . is auto delete (  )  )  )  ;   }  page context . set variable ( returnvariable query )  ;   }  catch  (   database exception e )   {   }   }  
@ override public  database meta data   (  )  throws sql exception  {  throw not supported (  )  ;   }  
public boolean   (  )  {  return keys . has next (  )  ;   }  
public void   ( double width )  {  this . width =  ( int ) width ;  if  ( this . width  <  0 )  this . width =  -  1  ;   }  
public  rendering hints   (  )  {  return null ;   }  
public int   (  )  {  return interval ;   }  
@ override public boolean   (  )  {  return  mode util . is writable ( get mode (  )  )  ;   }  
@ override public synchronized boolean   (  string token  string key )  {  if  ( tokens  =  =  null )  return false ;   string    token = tokens . get ( key )  ;  return    token  !  =  null &&    token . equals ignore case ( token )  ;   }  
public static  object   (  page context pc  string type  string line color 1   string line color 2  )  throws  page exception  {  type = type . to lower case (  )  . trim (  )  ;  if  ( "grayscale" . equals ( type )  )  return new  grayscale colormap (  )  ;  else if  ( "spectrum" . equals ( type )  )  return new  spectrum colormap (  )  ;  else if  ( "linear" . equals ( type )  )   {  boolean is empty 1  =  string util . is empty ( line color 1  )  ;  boolean is empty 2  =  string util . is empty ( line color 2  )  ;  if  ( is empty 1  && is empty 2  )  return new  linear colormap (  )  ;  else if  (  ! is empty 1  &&  ! is empty 2  )   {   color color 1  =  color caster . to color ( line color 1  )  ;   color color 2  =  color caster . to color ( line color 2  )  ;  return new  linear colormap ( color 1  . getrgb (  )  color 2  . getrgb (  )  )  ;   }  else throw new  function exception ( pc " image filter color map"  2  "line color 1 " "when you define linecolor 1  you have to define linecolor 2  as well" )  ;   }  else throw new  function exception ( pc " image filter color map"  1  "type" "invalid type defintion  valid types are [grayscale spectrum linear]" )  ;   }  
private void   (  )  throws  search exception   page exception  {  required ( "collection" action "collection" collection )  ;  get collection (  )  . repair (  )  ;   }  
public void   (  string str type )  throws  application exception  {  str type = str type . to lower case (  )  . trim (  )  ;  if  ( "comment" . equals ( str type )  )  type = type   comment ;  else if  ( "debug" . equals ( str type )  )  type = type   debug ;  else if  ( "inline" . equals ( str type )  )  type = type   inline ;  else if  ( "outline" . equals ( str type )  )  type = type   outline ;  else throw new  application exception ( "invalid value ["  +  str type  +  "] for attribute [type]  valid values are [comment debug inline outline]" )  ;   }  
public boolean   (  )  {  return curr . next  !  =  null ;   }  
@ override public int   (  string str )  throws  page exception  {  return form . compare to ( str )  ;   }  
@ override public boolean   (  key key )  {  return get ( key null )   !  =  null ;   }  
public  string   (  )  {  if  ( this . type  =  =  null )   {  try  {   string method name = "set"  +   ( name . length (  )   >  0  ?  ""  +   character . to upper case ( name . char at ( 0 )  )  : "" )   +   ( name . length (  )   >   1   ?  name . substring (  1  )  : "" )  ;   class clazz =  class util . load class ( tag . get tag class name (  )   (  class ) null )  ;  if  ( clazz  !  =  null )   {   method[] methods = clazz . get methods (  )  ;  for  ( int i = 0 ;  i  <  methods . length ;  i +  +  )   {   method method = methods[i] ;  if  ( method . get name (  )  . equals ignore case ( method name )  )   {   class[] types = method . get parameter types (  )  ;  if  ( types . length  =  =   1  )   {   class type = types[0] ;  if  ( type  =  =   string . class )  this . type = "string" ;  else if  ( type  =  =  double . class )  this . type = "number" ;  else if  ( type  =  =   date . class )  this . type = "datetime" ;  else this . type = type . get name (  )  ;   }   }   }   }   }  catch  (   throwable t )   {  return "string" ;   }   }  return this . type ;   }  
public void   (  string scheme )  {  this . scheme = scheme ;   }  
@ override public  savepoint   (  string name )  throws sql exception  {  throw not supported (  )  ;   }  
public  double   (  object left  object right )  throws  page exception  {  return  caster . to double (  strict math . pow (  caster . to double value ( left )   caster . to double value ( right )  )  )  ;   }  
public void   (  string high light color )  {  this . high light color = high light color ;   }  
public static boolean   (  statement stat  string label )  {  return get ancestor breakfc statement ( stat null label )   !  =  null ;   }  
@ override public  string   (  )  {  return null ;   }  
public void   ( boolean overflow to disk )  {  this . overflow to disk = overflow to disk ;   }  
public void   (  string exception )  {  error page . set type as string ( exception . to lower case (  )  . trim (  )  )  ;   }  
public static asm class   (  extendable class loader pcl  resource class root  class clazz )  throws io exception   instantiation exception   illegal access exception   illegal argument exception   security exception   invocation target exception   no such method exception  {   type type =  type . get type ( clazz )  ;   field[] fields = clazz . get fields (  )  ;  for  ( int i = 0 ;  i  <  fields . length ;  i +  +  )   {  if  (  modifier . is private ( fields[i] . get modifiers (  )  )  )  continue ;  create field ( type fields[i] )  ;   }   method[] methods = clazz . get methods (  )  ;   map <  string asm method >  amethods = new  hash map <  string asm method >  (  )  ;  for  ( int i = 0 ;  i  <  methods . length ;  i +  +  )   {  if  (  modifier . is private ( methods[i] . get modifiers (  )  )  )  continue ;  amethods . put ( methods[i] . get name (  )  get method ( pcl class root type clazz methods[i] )  )  ;   }  return new asm class ( clazz . get name (  )  amethods )  ;   }  
@ override public void   (  storage scope engine engine  storage scope cleaner cleaner  string app name  string cfid )  {  cfml factory impl factory = engine . get factory (  )  ;   application listener listener = factory . get config (  )  . get applicat
public  list <  object >    ( int from index int to index )  {   array list <  object >  list = new  array list <  object >  (  )  ;  for  ( int i = from index ;  i  <  to index ;  i +  +  )   {  list . add ( data[i] )  ;   }  return list ;   }  
public void   (  string secure json prefix )  {  this . secure json prefix = secure json prefix ;   }  
public void   ( int sides )  {  this . sides = sides ;   }  
@ override public  boolean   (  boolean default value )  {  return form . cast to boolean ( default value )  ;   }  
@ override public void   (  object o )  throws io exception   page exception  {  if  ( o instanceof  date ||  decision . is date ( o false )  )   {  writer . write (  caster . to string ( o )  )  ;   }  else  {  writer . write ( psq  ?   caster . to strin
public void   (  string name space seperator )  {  this . name space seperator = name space seperator ;   }  
public static void   (  document doc  string summary boolean index )  {  if  (  !  string util . is empty ( summary )  )  doc . add ( index  ?   text ( "summary" summary )  :  un indexed ( "summary" summary )  )  ;   }  
@ override public boolean   (  )  {  return  ( arr . length )   >  pos ;   }  
public  expression   (  )  {  return left ;   }  
final int   ( int ni )  {  return  ( m   block[ni] =  ( rol ( m   block[ni]  2  4  )  & 0xff00ff00 )  |  ( rol ( m   block[ni]  8  )  & 0x00ff00ff )  )  ;   }  
public void   (  bytecode context bc )  {   generator adapter adapter = bc . get adapter (  )  ;   label l 1  = new  label (  )  ;  adapter . visit jump insn ( operation l 1  )  ;  adapter . visit insn (  opcodes . iconst   0 )  ;   label l 2  = new  label (  )  ;  adapter . visit jump insn (  opcodes . goto l 2  )  ;  adapter . visit label ( l 1  )  ;  adapter . visit insn (  opcodes . iconst    1  )  ;  adapter . visit label ( l 2  )  ;   }  
public static short   (  string type boolean also alias short default value )  {  type = type . to lower case (  )  . trim (  )  ;  if  ( type . length (  )   >   2  )   {  char first = type . char at ( 0 )  ;  switch  ( first )   {  case 'a': if  ( type . equals ( "any" )  )  return type   any ;  if  ( type . equals ( "array" )  )  return type   array ;  break ;  case 'b': if  ( type . equals ( "boolean" )  ||  ( also alias && type . equals ( "bool" )  )  )  return type   boolean ;  if  ( type . equals ( "binary" )  )  return type   binary ;  if  ( also alias && type . equals ( "bigint" )  )  return type   numeric ;  if  ( "base 6  4 " . equals ( type )  )  return type   string ;  break ;  case 'c': if  ( also alias && "char" . equals ( type )  )  return type   string ;  break ;  case 'd': if  ( also alias && "double" . equals ( type )  )  return type   numeric ;  if  ( also alias && "decimal" . equals ( type )  )  return type   string ;  if  ( type . equals ( "date" )  || type . equals ( "datetime" )  )  return type   datetime ;  break ;  case 'e': if  ( "eurodate" . equals ( type )  )  return type   datetime ;  break ;  case 'f': if  ( also alias && "float" . equals ( type )  )  return type   numeric ;  if  ( "function" . equals ( type )  )  return type   function ;  break ;  case 'g': if  ( "guid" . equals ( type )  )  return type   guid ;  break ;  case 'i': if  ( also alias &&  ( "int" . equals ( type )  || "integer" . equals ( type )  )  )  return type   numeric ;  break ;  case 'l': if  ( also alias && "long" . equals ( type )  )  return type   numeric ;  break ;  case 'n': if  ( type . equals ( "numeric" )  )  return type   numeric ;  else if  ( type . equals ( "number" )  )  return type   numeric ;  if  ( also alias )   {  if  ( type . equals ( "node" )  )  return type   xml ;  else if  ( type . equals ( "nvarchar" )  )  return type   string ;  else if  ( type . equals ( "nchar" )  )  return type   string ;   }  break ;  case 'o': if  ( type . equals ( "object" )  )  return type   any ;  if  ( also alias && type . equals ( "other" )  )  return type   any ;  break ;  case 'q': if  ( type . equals ( "query" )  )  return type   query ;  if  ( type . equals ( "querycolumn" )  )  return type   query   column ;  break ;  case 's': if  ( type . equals ( "string" )  )  return type   string ;  else if  ( type . equals ( "struct" )  )  return type   struct ;  if  ( also alias && "short" . equals ( type )  )  return type   numeric ;  break ;  case 't': if  ( type . equals ( "timespan" )  )  return type   timespan ;  if  ( type . equals ( "time" )  )  return type   datetime ;  if  ( also alias && type . equals ( "timestamp" )  )  return type   datetime ;  if  ( also alias && type . equals ( "text" )  )  return type   string ;  break ;  case 'u': if  ( type . equals ( "uuid" )  )  return type   uuid ;  if  ( also alias && "usdate" . equals ( type )  )  return type   datetime ;  if  ( also alias && "udf" . equals ( type )  )  return type   function ;  break ;  case 'v': if  ( type . equals ( "variablename" )  )  return type   variable   name ;  if  ( also alias && type . equals ( "variable   name" )  )  return type   variable   name ;  if  ( type . equals ( "variablestring" )  )  return type   variable   string ;  if  ( also alias && type . equals ( "variable   string" )  )  return type   variable   string ;  if  ( type . equals ( "void" )  )  return type   void ;  if  ( also alias && type . equals ( "varchar" )  )  return type   string ;  break ;  case 'x': if  ( type . equals ( "xml" )  )  return type   xml ;  break ;   }   }  return default value ;   }  
@ override public final long   (  )  throws io exception  {   header ct = get last header ignore case ( " content -  length" )  ;  if  ( ct  !  =  null )  return  caster . to long value ( ct . get value (  )   -  1  )  ;   input stream is = null ;  long l
public void   (  string str )  throws io exception  {  buffer . append ( str )  ;     check (  )  ;   }  
private static  string   ( char[] carr )  {   string buffer sb = new  string buffer (  )  ;  char c ;  for  ( int i = 0 ;  i  <  carr . length ;  i +  +  )   {  c = carr[i] ;  if  (  !  character . is whitespace ( c )  && c  !  =  ' + ' )  sb . append ( carr[i] )  ;   }  return sb . to string (  )  ;   }  
@ override public  string   (  )  {  return label ;   }  
@ override public double   ( double default value )  {  return to double value (  )  ;   }  
@ override public int   (  string str )  throws  page exception  {  throw new  expression exception ( "can't compare  complex  object  type  struct with a  string" )  ;   }  
public static void   (  string agent args  instrumentation inst )  {  if  ( inst  !  =  null )  instrumentation = inst ;   }  
public   ( float distance float angle float rotation float zoom )  {  this . distance = distance ;  this . angle = angle ;  this . rotation = rotation ;  this . zoom = zoom ;   }  
public boolean   (  )  {  return pos  =  =  lc text . length  -   1  ;   }  
public  integer   (  )  {  return  integer . value of ( value )  ;   }  
public   (  expression expr )  {  super ( expr . get start (  )  expr . get end (  )  )  ;  this . expr = expr ;   }  
public static  string   ( int storage  string default value )  {  switch  ( storage )   {  case storage   eu: return "eu" ;  case storage   us: return "us" ;  case storage   us   west: return "us - west" ;   }  return default value ;   }  
public   (  input source entity res )  {  this . entity res = entity res ;   }  
@ override public void   (  )  {  exception = null ;  undefined scope (  )  . removeel (  key constants .    cfcatch )  ;   }  
@ override public void   (  )  {  charset = null ;  action = action   read ;  column map = null ;  enclosure dir = null ;  ignore enclosure error = false ;  name = null ;  output file = null ;  overwrite = false ;  overwrite enclosure = false ;  propertie
public void   ( double framerate )  {  this . framerate = framerate ;   }  
@ override public  object   (  page context pc )  throws  page exception  {  return get left ( pc )  . subtract ( get right ( pc )  )  . to string (  )  ;   }  
public void   ( int y )  {  this . y = y ;   }  
public   (  source source  struct variables  string[] path  struct matrix int format boolean has format extension  list <  mime type >  accept  mime type content type )  {  this . source = source ;  this . variables = variables ;  this . path = path ;  this . format = format ;  this . matrix = matrix ;  this . has format extension = has format extension ;  this . accept = accept ;  this . content type = content type ;   }  
@ override public int   (  )  throws io exception  {  return is . available (  )  ;   }  
public static  string   (  object obj )  {  return caster (  )  . to type name ( obj )  ;   }  
@ override public  attr   (  string namespaceuri  string qualified name )  throws dom exception  {  return doc . create attributens ( namespaceuri qualified name )  ;   }  
public   (  string text )  {  init ( text )  ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " radius" )  )  )   !  =  null )  set radius (  image filter util . to float value ( o " radius" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " angle" )  )  )   !  =  null )  set angle (  image filter util . to float value ( o " angle" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " transition" )  )  )   !  =  null )  set transition (  image filter util . to float value ( o " transition" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " edge action" )  )  )   !  =  null )  set edge action (  image filter util . to string ( o " edge action" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " interpolation" )  )  )   !  =  null )  set interpolation (  image filter util . to string ( o " interpolation" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ radius   angle   transition   edge action   interpolation]" )  ;   }  return filter ( src dst )  ;   }  
public void   (  string codec )  {  this . audio codec = codec ;   }  
@ override public  label   (  )  {  return begin ;   }  
private  string   (  string signature )  {  return    fix ( signature )  ;   }  
@ override public void   (  string column name  date x )  throws sql exception  {  log ( column name )  ;  qry . update date ( column name x )  ;   }  
protected void   (  )  throws io exception  {  if  ( out  =  =  null )   {  out = get output stream ( false )  ;   }   }  
public void   (  string str server )  throws  page exception  {  smtp . set host ( str server )  ;   }  
  (  datasource resource provider provider  connection data data  string path )  {  this . provider = provider ;  this . data = data ;  if  ( " / " . equals ( path )  )   {  this . parent = null ;  this . name = "" ;   }  else  {   string[] pn =  resource util . translate path name ( path )  ;  this . parent = pn[0] ;  this . name = pn[ 1 ] ;   }   }  
@ override public  object   (  page context pc  object value )  throws  page exception  {  disconnect cache (  )  ;  return column . set ( pc value )  ;   }  
public static  page   (  page context pc  interface impl interf boolean ignore cache )  throws  page exception  {   page page = get page ( pc interf . get page source (  )  )  ;  if  ( ignore cache )  return page ;  if  ( page . meta data  !  =  null && page . meta data . get (  )   !  =  null )   {  if  ( has changed ( pc  (  (  meta data soft reference ) page . meta data )  . creation time interf )  )  page . meta data = null ;   }  return page ;   }  
public static boolean   (  page context pc  object object )  {  return  decision . is struct ( object )  ;   }  
@ override public  string   (  string column label )  throws sql exception  {  return res . getn string ( to index ( column label )  )  ;   }  
public void   (  string user agent )  {  get document (  )  . set user agent ( user agent )  ;   }  
public void   (  string password )  {  this . password = password ;   }  
public void   ( int port )  {  this . port = port ;   }  
public void   (  string query )  {  this . query = query ;   }  
public  expr boolean   (  )  {  return pass by reference ;   }  
public  string   (  )  {  return author ;   }  
public  list   (  string html url url )  {   array list urls = new  array list (  )  ;  cfml string cfml = new cfml string ( html "utf -  8 " )  ;  while  (  ! cfml . is after last (  )  )   {  if  ( cfml . forward if current ( ' < ' )  )   {  for  ( int i = 0 ;  i  <  tags . length ;  i +  +  )   {  if  ( cfml . forward if current ( tags[i] . tag  +  " " )  )   {  get single url ( urls cfml tags[i] url )  ;   }   }   }  else  {  cfml . next (  )  ;   }   }  return urls ;   }  
@ override public  string   (  )  {  return "name:"  +  name  +  " ; type:" +  type +  " ; " ;   }  
@ override public  string[]   (  )  {   string[]    columns = new  string[column names . length] ;  for  ( int i = 0 ;  i  <  column names . length ;  i +  +  )   {     columns[i] = column names[i] . get string (  )  ;   }  return    columns ;   }  
@ override public  object   (  page context pc  object[] args )  throws  page exception  {  return call ( pc  caster . to array ( args[0] )  args[ 1 ] )  ;   }  
@ override public  boolean   (  )  {  return properties . secure json ;   }  
public static  mime type[]   (  string str mime types char delimiter )  {  if  (  string util . is empty ( str mime types true )  )  return new  mime type[0] ;   string[] arr =  list util . trim items (  list util . list to string array ( str mime types delimiter )  )  ;   mime type[] mtes = new  mime type[arr . length] ;  for  ( int i = 0 ;  i  <  arr . length ;  i +  +  )   {  mtes[i] = get instance ( arr[i] )  ;   }  return mtes ;   }  
public void   (  )  {  this . operation = gt ;   }  
public static  document   (  node node )  {  if  ( node instanceof  document )  return  (  document ) node ;  return node . get owner document (  )  ;   }  
@ override public void   ( boolean value )  throws io exception  {  set attribute ( attribute   hidden value )  ;   }  
public void   (  string value )  {  this . value = value ;   }  
@ override public  struct   (  page context pc  error page ep )  {   struct eb = super . get error block ( pc ep )  ;  eb . setel (  key constants .    type get custom type as string (  )  )  ;  return eb ;   }  
public void   (  thread thread )  {  this . thread = thread ;   }  
public void   (  string log file  string level )  throws  page exception  {  check write access (  )  ;  boolean has access =  config web util . has access ( config  security manager . type   mail )  ;  if  (  ! has access )  throw new  security exception ( "no access to update mail server settings" )  ;   config web util . get file ( config config . get root directory (  )  log file  file util . type   file )  ;   element mail =    get root element ( "mail" )  ;  mail . set attribute ( "log" log file )  ;  mail . set attribute ( "log - level" level )  ;   }  
public void   (  string type )  {  this . type = type . to lower case (  )  . trim (  )  ;   }  
public static  mapping[]   (  config web cw  object o )  throws  page exception  {   array array ;  if  ( o instanceof  string )   {  array =  list util . list to array remove empty (  caster . to string ( o )  ' ' )  ;   }  else if  ( o instanceof  struct )   {  array = new  array impl (  )  ;   struct sct =  (  struct ) o ;   iterator <  object >  it = sct . value iterator (  )  ;  while  ( it . has next (  )  )   {  array . append ( it . next (  )  )  ;   }   }  else  {  array =  caster . to array ( o )  ;   }   mapping impl[] mappings = new  mapping impl[array . size (  ) ] ;   config web impl config =  (  config web impl ) cw ;  for  ( int i = 0 ;  i  <  mappings . length ;  i +  +  )   {  mappings[i] =  (  mapping impl ) config . create custom tag app mappings ( " / "  +  i  caster . to string ( array . gete ( i  +   1  )  )  . trim (  )  )  ;   }  return mappings ;   }  
@ override public  object   (  page context pc )  throws  page exception  {  double r =  caster . to double value ( right . get value ( pc )  )  ;  if  ( r  =  =  0d )  throw new  arithmetic exception ( " division by zero is not possible" )  ;  return new
@ override public short   (  )  {  return type ;   }  
private void   (  )  throws  page exception  {   string session type = config . get session type (  )   =  =   config . session   type   j 2 ee  ?  "j 2 ee" : "cfml" ;   string local mode =  app listener util . to local mode ( config . get local mode (  )  "classic" )  ;   struct sct = new  struct impl (  )  ;  page context . set variable ( get string ( "admin" action "return variable" )  sct )  ;  sct . set ( "allow implicid query call"  caster . to boolean ( config . allow implicid query call (  )  )  )  ;  sct . set ( "merge form and url"  caster . to boolean ( config . merge form andurl (  )  )  )  ;  sct . set ( "sessiontype" session type )  ;  sct . set ( "localmode" local mode )  ;  sct . set ( "session management"  caster . to boolean ( config . is session management (  )  )  )  ;  sct . set ( "client management"  caster . to boolean ( config . is client management (  )  )  )  ;  sct . set ( "domain cookies"  caster . to boolean ( config . is domain cookies (  )  )  )  ;  sct . set ( "client cookies"  caster . to boolean ( config . is client cookies (  )  )  )  ;  sct . set ( "client storage" config . get client storage (  )  )  ;  sct . set ( "session storage" config . get session storage (  )  )  ;   time span ts = config . get session timeout (  )  ;  sct . set ( "session timeout" ts )  ;  sct . set ( "session timeout   day"  caster . to integer ( ts . get day (  )  )  )  ;  sct . set ( "session timeout   hour"  caster . to integer ( ts . get hour (  )  )  )  ;  sct . set ( "session timeout   minute"  caster . to integer ( ts . get minute (  )  )  )  ;  sct . set ( "session timeout   second"  caster . to integer ( ts . get second (  )  )  )  ;  ts = config . get application timeout (  )  ;  sct . set ( "application timeout" ts )  ;  sct . set ( "application timeout   day"  caster . to integer ( ts . get day (  )  )  )  ;  sct . set ( "application timeout   hour"  caster . to integer ( ts . get hour (  )  )  )  ;  sct . set ( "application timeout   minute"  caster . to integer ( ts . get minute (  )  )  )  ;  sct . set ( "application timeout   second"  caster . to integer ( ts . get second (  )  )  )  ;  ts = config . get client timeout (  )  ;  sct . set ( "client timeout" ts )  ;  sct . set ( "client timeout   day"  caster . to integer ( ts . get day (  )  )  )  ;  sct . set ( "client timeout   hour"  caster . to integer ( ts . get hour (  )  )  )  ;  sct . set ( "client timeout   minute"  caster . to integer ( ts . get minute (  )  )  )  ;  sct . set ( "client timeout   second"  caster . to integer ( ts . get second (  )  )  )  ;  if  ( config . get scope cascading type (  )   =  =   config . scope   strict )  sct . set ( "scope cascading type" "strict" )  ;  else if  ( config . get scope cascading type (  )   =  =   config . scope   small )  sct . set ( "scope cascading type" "small" )  ;  else if  ( config . get scope cascading type (  )   =  =   config . scope   standard )  sct . set ( "scope cascading type" "standard" )  ;   }  
public  stack <  on finally >    (  )  {  return tcf ;   }  
public static void   (  resource res boolean force )  {  try  {  res . create directory ( force )  ;   }  catch  (  io exception e )   {   }   }  
@ override public  node   (  node arg )  throws dom exception  {  return node map . set named item ( arg )  ;   }  
@ override public  dump data   (  page context page context int maxlevel  dump properties dp )  {  return udf util . to dump data ( page context maxlevel dp this false )  ;   }  
public void   ( double port )  {  this . port =  ( int ) port ;   }  
@ override public void   ( boolean script base )  {  this . script base = script base ;   }  
public void   (  string scope )  throws  application exception  {  scope = scope . to lower case (  )  . trim (  )  ;  if  ( scope . equals ( "server" )  )  this . scope = scope   server ;  else if  ( scope . equals ( "application" )  )  this . scope = scope   application ;  else if  ( scope . equals ( "session" )  )  this . scope = scope   session ;  else if  ( scope . equals ( "request" )  )  this . scope = scope   request ;  else throw new  application exception ( "invalid value ["  +  scope  +  "] for attribute [scope] from tag [lock]" "valid values are [server application session]" )  ;   }  
public static boolean   (  )  {  return is windows ;   }  
public   ( xml multi element struct struct )  {  this . struct = struct ;   }  
public  member   (  )  {  if  ( members . is empty (  )  )  return null ;  return members . get ( members . size (  )   -   1  )  ;   }  
@ override public  object   (  )  {  return o ;   }  
public void   ( int maxrows )  {  this . maxrows = maxrows ;   }  
public  object   (  object coll  collection .  key key  object value )  throws  page exception  {  return variable util . set ( this coll key value )  ;   }  
public int   (  )  {  return 0 ;   }  
public final void   (  )  throws  parse exception  {  switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  1  5 : case  2  7 : case  3  4 : case  4  4 : case  4  8 : case  5  6 : case  7 0: case  7  1 : switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  1  5 : jj   consume   token (  1  5  )  ;  break ;  case  7  1 : jj   consume   token (  7  1  )  ;  break ;  case  7 0: jj   consume   token (  7 0 )  ;  break ;  case  3  4 : jj   consume   token (  3  4  )  ;  break ;  case  4  8 : jj   consume   token (  4  8  )  ;  break ;  case  4  4 : jj   consume   token (  4  4  )  ;  break ;  case  5  6 : jj   consume   token (  5  6  )  ;  break ;  case  2  7 : jj   consume   token (  2  7  )  ;  break ;  default : jj   la 1 [0] = jj   gen ;  jj   consume   token (  -  1  )  ;  throw new  parse exception (  )  ;   }  switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  8  8 : jj   consume   token (  8  8  )  ;  jj   consume   token (  7  6  )  ;  switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  8  9 : jj   consume   token (  8  9  )  ;  jj   consume   token (  7  6  )  ;  break ;  default : jj   la 1 [ 1 ] = jj   gen ;  break ;   }  jj   consume   token (  9 0 )  ;  break ;  default : jj   la 1 [ 2 ] = jj   gen ;  break ;   }  break ;  case  2 0: jj   consume   token (  2 0 )  ;  break ;  case  1  2 : jj   consume   token (  1  2  )  ;  break ;  case  1  3 : jj   consume   token (  1  3  )  ;  break ;  default : jj   la 1 [ 3 ] = jj   gen ;  jj   consume   token (  -  1  )  ;  throw new  parse exception (  )  ;   }   }  
@ override public void   (  )  {  super . release (  )  ;   }  
public  string   (  )  {  return to string (  )  ;   }  
@ override public  object   (  page context pc  key property name  object value )  {  return component . setel ( property name value )  ;   }  
@ override public boolean   (  )  {  return get ram resource (  )  . is writeable (  )  ;   }  
@ override public int   ( int default value )  {  if  ( properties . return format  <  0 )  return default value ;  return properties . return format ;   }  
public boolean   (  )  {  return true ;   }  
protected  deserializer   (  string mechanism type )  {  if  ( java type  =  =  null || xml type  =  =  null )   {  return super . get general purpose ( mechanism type )  ;   }  if  ( deser class  =  =   enum deserializer . class )   {  return super . get general purpose ( mechanism type )  ;   }  return new  bean deserializer ( java type xml type type desc property map )  ;   }  
@ override public  header   (  string name )  {  org . apache . http .  header header = rsp . get last header ( name )  ;  if  ( header  !  =  null )  return new  header wrap ( header )  ;  return null ;   }  
public static void   (  resource src  resource filter filter boolean delete directories )  {  if  ( src . is directory (  )  )   {   resource[] files = filter  =  =  null  ?  src . list resources (  )  : src . list resources ( filter )  ;  for  ( int i = 0 ;  i  <  files . length ;  i +  +  )   {     delete content ( files[i] filter true )  ;  if  ( delete directories )   {  try  {  src . remove ( false )  ;   }  catch  (  io exception e )   {   }   }   }   }  else if  ( src . is file (  )  )   {  src . delete (  )  ;   }   }  
public boolean   (  string s )  {  if  ( s  !  =  null )  return search table    . contains key ( s )  ;  return false ;   }  
public  object   (  )  {  return value ;   }  
private static void   (  resource archive )  {   resource dir = archive . get parent resource (  )  . get real resource ( "failed - to - deploy" )  ;   resource dst = dir . get real resource ( archive . get name (  )  )  ;  dir . mkdirs (  )  ;  try  {  if  ( dst . exists (  )  )  dst . remove ( true )  ;   resource util . move to ( archive dst true )  ;   }  catch  (   throwable t )   {   }   }  
@ override public  string   (  )  {  return "operation" ;   }  
private  value string   (  parser string raw )  throws sql parser exception  {  if  (  ! raw . is current ( '\'' )  )  return null ;   string buffer str = new  string buffer (  )  ;  while  ( raw . has next (  )  )   {  raw . next (  )  ;  if  ( raw . is current ( '\'' )  )   {  if  ( raw . is next ( '\'' )  )   {  raw . next (  )  ;  str . append ( '\'' )  ;   }  else  {  break ;   }   }  else  {  str . append ( raw . get current (  )  )  ;   }   }  if  (  ! raw . forward if current ( '\'' )  )  throw new sql parser exception ( " invalid  syntax  closing ['] not found" )  ;  raw . remove space (  )  ;  return new  value string ( str . to string (  )  )  ;   }  
@ override public  object   (  page context pc  key method name  object[] args )  throws  page exception  {  return  member util . call ( pc this method name args cf types . type   array "array" )  ;   }  
@ override public int   (  )  {  throw new  page runtime exception ( new  caster exception ( sct " array" )  )  ;   }  
public void   (  string item column )  {  this . item column = item column ;   }  
public  string   (  )  {  return name ;   }  
@ override public boolean   ( int index java . util .  collection c )  {  return list . add all ( index c )  ;   }  
@ override public void   (  )  {  commited = true ;   }  
private void   (  string scheme  string clazz  string arguments )  throws  security exception  {  check write access (  )  ;   element resources =    get root element ( "resources" )  ;   element[] rp elements =  config web factory . get children ( resources "resource - provider" )  ;   string s ;  if  ( rp elements  !  =  null )   {  for  ( int i = 0 ;  i  <  rp elements . length ;  i +  +  )   {  s = rp elements[i] . get attribute ( "scheme" )  ;  if  (  !  string util . is empty ( s )  && s . equals ignore case ( scheme )  )   {  rp elements[i] . set attribute ( "class" clazz )  ;  rp elements[i] . set attribute ( "scheme" scheme )  ;  rp elements[i] . set attribute ( "arguments" arguments )  ;  return ;   }   }   }   element el = doc . create element ( "resource - provider" )  ;  resources . append child ( xml caster . to raw node ( el )  )  ;  el . set attribute ( "class" clazz )  ;  el . set attribute ( "scheme" scheme )  ;  el . set attribute ( "arguments" arguments )  ;   }  
public static void   (  bytecode context stat constr  bytecode context constr  list <  lit string >  keys  list <  statement >  statements  bytecode context bc )  throws  bytecode exception  {   iterator <  statement >  it = statements . iterator (  )  ;  while  ( it . has next (  )  )   {   statement s = it . next (  )  ;  s . write out ( bc )  ;   }   }  
@ override public  object   (  page context pc  collection .  key property name  object value )  throws  page exception  {  return component . set ( property name value )  ;   }  
public int   (  )  {  return h radius ;   }  
private void   ( boolean error )  {  if  (  ! is gateway context (  )  && config . is monitoring enabled (  )  )   {   request monitor[] monitors = config . get request monitors (  )  ;  if  ( monitors  !  =  null )  for  ( int i = 0 ;  i  <  monitors . length ;  i +  +  )   {  if  ( monitors[i] . is log enabled (  )  )   {  try  {  monitors[i] . log ( this error )  ;   }  catch  (   throwable e )   {   }   }   }   }   }  
@ override public long   (  )  {  return lastvisit ;   }  
@ override public boolean   (  )  {  return server  !  =  null ;   }  
@ override public void   (  )  {  list . clear (  )  ;   }  
private static  resource   (  page context pc )  throws io exception  {   resource dir = pc . get config (  )  . get cache dir (  )  ;  if  (  ! dir . exists (  )  )  dir . create directory ( true )  ;  return dir ;   }  
public double   (  )  {  return framerate ;   }  
public boolean   (  collection c )  {   iterator it = c . iterator (  )  ;  boolean rtn = false ;  while  ( it . has next (  )  )   {  if  ( remove ( it . next (  )  )  )  rtn = true ;   }  return rtn ;   }  
public float   (  )  {  return haziness ;   }  
public static void   (  config config )  {  synchronized  ( config )   {   resource dir = get deploy directory ( config )  ;  int ma =  info . get major version (  )  ;  int mi =  info . get minor version (  )  ;  if  (  ! dir . exists (  )  )   {  if  ( ma  >   4  || ma  =  =   4  && mi  >   1  )   {  dir . mkdirs (  )  ;   }  return ;   }   resource[] children = dir . list resources ( all   ext )  ;   resource child ;   string ext ;  for  ( int i = 0 ;  i  <  children . length ;  i +  +  )   {  child = children[i] ;  try  {  ext =  resource util . get extension ( child null )  ;  if  ( "ra" . equals ignore case ( ext )  || "ras" . equals ignore case ( ext )  )   {  deploy archive ( config child )  ;   }  else if  ( "re" . equals ignore case ( ext )  )  deploy extension ( config child )  ;   }  catch  (   zip exception e )   {   system out . print date ( config . get err writer (  )   exception util . get stacktrace ( e true )  )  ;   }  catch  (  io exception e )   {   system out . print date ( config . get err writer (  )   exception util . get stacktrace ( e true )  )  ;   }   }   }   }  
@ override public void   (  config config  string cache name  struct arguments )  {  this . class loader = config . get class loader (  )  ;  this . cache name = cache name ;  set class loader (  )  ;   resource hash dir = config . get config dir (  )  . 
@ override public boolean   (  )  {  try  {  provider . lock ( this )  ;  return super . mkdir (  )  ;   }  catch  (  io exception e )   {  return false ;   }  finally  {  provider . unlock ( this )  ;   }   }  
public void   (  string align )  {  this . align = align ;   }  
@ override public void   ( boolean trigger component data member )  {  init trigger component data member = true ;  this . trigger component data member = trigger component data member ;   }  
public   (  pattern pattern  list <  string >  variables )  {  this . pattern = pattern ;  this . variables = variables ;   }  
@ override public synchronized void   (  spooler task task )  {  add +  +  ;  task . set next execution (  system . current time millis (  )  )  ;  task . set id ( create id ( task )  )  ;  store ( task )  ;  start (  )  ;   }  
public int   (  )  {  return current tag ;   }  
public void   (  tag tag  tag lib tag lib tag )  throws  evaluator exception  {   string ns = lib tag . get tag lib (  )  . get name space and separator (  )  ;   string name = ns  +  "catch" ;  if  ( get ancestor catch ( lib tag . get tag lib (  )  tag )   =  =  null )  throw new  evaluator exception ( " wrong  context  tag "  +  lib tag . get full name (  )   +  " must be inside a " +  name +  " tag" )  ;   }  
private void   (  string language )  throws  search exception  {  if  ( language  !  =  null &&  ! language . trim (  )  . equals ignore case ( get language (  )  )  )   {  throw new  search exception ( "collection  language and  index  language must be of same type  but collection language is of type ["  +  get language (  )   +  "] and index language is of type [" +  language +  "]" )  ;   }   }  
public  object   (  object key  object value )  {  process queue (  )  ;  return hash . put ( key new  soft value ( value queue key )  )  ;   }  
public  string   (  )  {  return " mask" ;   }  
@ override public double   ( double default value )  {  return  caster . to double value ( key default value )  ;   }  
@ override public  string buffer   (  )  {  return null ;   }  
public float   (  )  {  return centrex ;   }  
private static  string   (  page context pc  object o  string mask  locale locale  time zone tz )  throws  page exception  {  if  ( o instanceof  string &&  string util . is empty (  (  string ) o true )  )  return "" ;  return new railo . runtime . format .  time format ( locale )  . format ( to timels ( locale tz o )  mask tz )  ;   }  
public  object   (  )  {  return e . next element (  )  ;   }  
public static  object   (  page context pc  object left  object right )  throws  page exception  {  return  operator . concat (  caster . to char sequence ( left )   caster . to char sequence ( right )  )  ;   }  
public  struct   (  )  {  return pe . get addional (  )  ;   }  
public boolean   (  )  {  return pass by reference ;   }  
public void   ( int x int y int width int height boolean filled )  throws  expression exception  {  if  ( filled )  get graphics (  )  . fill rect ( x y width  +   1  height  +   1  )  ;  else get graphics (  )  . draw rect ( x y width height )  ;   }  
private  output stream   ( boolean allow compression )  throws io exception  {  if  ( allow compression )   {   string encodings =  req rsp util . get header ( request " accept -  encoding" "" )  ;  if  ( encodings . index of ( "gzip" )   !  =   -  1  )   {  boolean inline =  http servlet response wrap . get (  )  ;  if  (  ! inline )   {   servlet output stream os = response . get output stream (  )  ;  response . set header ( " content -  encoding" "gzip" )  ;  return new gzip output stream ( os )  ;   }   }   }  return response . get output stream (  )  ;   }  
public void   ( byte dest[] )  {   blowfish . long to byte array ( m   lcbciv dest 0 )  ;   }  
public  string   (  )  {  return pattern ;   }  
@ override public  iterator <  entry <  key  object >  >    (  )  {  return new  objects entry iterator ( key iterator (  )  this )  ;   }  
public static int   ( int min int max )  {  return min  +   ( int )  (  math . random (  )  *  (  ( max  -  min )   +   1  )  )  ;   }  
@ override public long   (  )  {  return ts . length (  )  ;   }  
private void   (  config web config )  {  check size ( config config . get temp directory (  )   1 0 2  4  *  1 0 2  4  *  1 0 2  4  null )  ;   }  
@ override public  resource   (  )  {  return get parent datasource resource (  )  ;   }  
@ override public int   (  string column name )  throws sql exception  {  return query . get int ( column name )  ;   }  
@ override public void   (  )  {  super . release (  )  ;  name = null ;  password = null ;  roles = null ;   }  
public static double   (  page context pc  date time date  string str timezone )  throws  expression exception  {  return    call ( pc date str timezone  =  =  null  ?  pc . get time zone (  )  :  time zone util . to time zone ( str timezone )  )  ;   }  
public boolean   (  )  {  return invert ;   }  
private static int   ( long l val )  {  return  ( int ) l val ;   }  
public synchronized  string   (  string str )  {  if  ( offset  +  size  +   1   >  arr . length )  enlarge capacity ( size  +   1  )  ;  arr[offset  +  size] = str ;  size +  +  ;  return str ;   }  
public void   (  tag tag )  throws  evaluator exception  {   body body = tag . get body (  )  ;  int catch count = 0 ;  int no catch count = 0 ;  int finally count = 0 ;  if  ( body  !  =  null )   {   list stats = body . get statements (  )  ;   iterator it = stats . iterator (  )  ;   statement stat ;   tag t ;   string name ;  while  ( it . has next (  )  )   {  stat =  (  statement ) it . next (  )  ;  if  ( stat instanceof  tag )   {  t =  (  tag ) stat ;  name = t . get tag lib tag (  )  . get name (  )  ;  if  ( name . equals ( "finally" )  )   {  finally count +  +  ;  no catch count +  +  ;   }  else if  ( name . equals ( "catch" )  )  catch count +  +  ;  else no catch count +  +  ;   }  else no catch count +  +  ;   }   }  if  ( catch count  =  =  0 && finally count  =  =  0 )  throw new  evaluator exception ( " wrong  context  tag cftry must have at least one tag cfcatch inside or a cffinally tag . " )  ;  if  ( finally count  >   1  )  throw new  evaluator exception ( " wrong  context  tag cftry can have only one tag cffinally inside . " )  ;  if  ( no catch count  =  =  0 )   {  asm util . remove ( tag )  ;   }   }  
public int   (  string coulmn name )  {  return rst . get column index ( coulmn name )  ;   }  
@ override public long   (  )  {  if  ( this . res  !  =  null )   {  return this . res . length (  )  ;   }  return 0 ;   }  
@ override public boolean   (  )  {  return exists (  )  ;   }  
public  string   (  string namespaceuri )  {  return null ;   }  
@ override public  function argument[]   (  )  {  return arguments ;   }  
public void   (  output stream os  string format float quality boolean close stream )  throws io exception   expression exception  {   image output stream ios =  imageio . create image output stream ( os )  ;  try  {     write out ( ios format quality )  ;   }  finally  {  io util . closeel ( ios )  ;   }   }  
@ override public  string   (  )  {  return pe . get custom type as string (  )  ;   }  
private final boolean   ( int i )  {  jj   la = i ;  jj   lastpos = jj   scanpos = token ;  boolean flag =  ! jj    3     3  (  )  ;  jj   save (  2  i )  ;  return flag ;   }  
@ override public  boolean   (  boolean default value )  {  return default value ;   }  
@ override public  collection   ( boolean deep copy )  {  return  (  collection )  duplicator . duplicate ( coll deep copy )  ;   }  
public void   (  string type )  throws  application exception  {  if  ( type  =  =  null )  return ;  type = type . to lower case (  )  . trim (  )  ;  if  ( type . equals ( "simple" )  )  this . type =  search collection . search   type   simple ;  else if  ( type . equals ( "explicit" )  )  this . type =  search collection . search   type   explicit ;  else throw new  application exception ( "attribute type of tag search has an invalid value  valid values are [simple explicit] now is ["  +  type  +  "]" )  ;   }  
@ override public void   (  )  {  super . release (  )  ;  password = "" ;  orderby = "" ;  report = "" ;  username = "" ;  formula = "" ;  template = "" ;  format = "" ;  name = "" ;  filename = "" ;  query = "" ;  overwrite = false ;  encryption = "" ; 
public float   (  )  {  return turbulence ;   }  
public void   ( int startrow )  {  this . startrow = startrow ;   }  
public static  array   (  page context pc  query qry )  {  return new  array impl ( qry . get column names as string (  )  )  ;   }  
@ override public  string   (  )  {  return header . get name (  )  ;   }  
private static  string   (  array array  set <  object >  done )  {   string buffer sb = new  string buffer ( "[" )  ;  int len = array . size (  )  ;  for  ( int i =  1  ;  i  <  =  len ;  i +  +  )   {  if  ( i  >   1  )  sb . append ( "  " )  ;  sb . append ( serialize ( array . get ( i null )  done )  )  ;   }  return sb . append ( "]" )  . to string (  )  ;   }  
@ override public  < t > t   (  class < t >  iface )  throws sql exception  {  log (  )  ;  return qry . unwrap ( iface )  ;   }  
@ override public  string   (  )  {   resource db = config (  )  . get config dir (  )  . get real resource ( "db" )  ;  if  (  ! db . exists (  )  )  db . create new file (  )  ;  return db . get path (  )  ;   }  
public static  string   ( int length )  {  if  ( length  <   1  )  return "" ;   secure random sr = new  secure random (  )  ;   string builder sb = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  length ;  i +  +  )   {  int rnd =  ( int )  ( sr . next double (  )  *  ( chars . length  -   1  )  )  ;  sb . append ( chars[rnd] )  ;   }  return sb . to string (  )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
public void   ( boolean colheaderitalic )  {  this . colheaderitalic = colheaderitalic ;   }  
public  string   (  )  {  return mime type ;   }  
@ override public  string   (  )  {  return "name:"  +  name  +  " ; creation:" +  creation +  " ; owner display name:" +  owner display name +  " ; owner id key:" +  owner id key ;   }  
@ override public  date time   (  date time default value )  {   object value = get ( query . get currentrow (  thread local page context . get (  )  . get id (  )  )   null support helper . null (  )  )  ;  if  ( value  =  =   null support helper . null 
@ override public void   ( int parameter index sqlxml xml object )  throws sql exception  {  stat . setsqlxml ( parameter index xml object )  ;   }  
public static void   (  body content bc )  {  if  ( bc  !  =  null )   {  try  {  bc . flush (  )  ;   }  catch  (  io exception e )   {   }   }   }  
@ override public boolean   (  )  {  try  {  provider . lock ( this )  ;  return super . delete (  )  ;   }  catch  (  io exception e )   {  return false ;   }  finally  {  provider . unlock ( this )  ;   }   }  
protected  string   (  )  {  if  (  string util . is empty ( top . properties . call path )  )  return get name (  )  ;  try  {  return " ( "  +   list util . array to list (  list util . list to array trim ( top . properties . call path . replace ( ' / ' ' . ' )  . replace ( '\\' ' . ' )  " . " )  " . " )   +  " ) " ;   }  catch  (   page exception e )   {  return top . properties . call path ;   }   }  
private static double   (  page context pc  date time date  time zone tz )  {  return  date time util . get instance (  )  . get day of week (  locale . us tz date )  ;   }  
private  object   (  page context pc sql sql  query qr z expression expression int row )  throws  page exception  {  return  ( execute compare ( pc sql qr expression row )   !  =  0 )   ?   boolean . true :  boolean . false ;   }  
public static  struct   (  page context pc )  throws  page exception  {   struct sct = new  struct impl (  )  ;   struct web = new  struct impl (  )  ;   struct server = new  struct impl (  )  ;   config web config = pc . get config (  )  ;  web . set ( security   key  (  (  config impl ) config )  . get security key (  )  )  ;  web . set (  key constants .    id config . get id (  )  )  ;  sct . set (  key constants .    web web )  ;  if  ( config instanceof  config web impl )   {   config web impl cwi =  (  config web impl ) config ;  server . set ( security   key cwi . get server security key (  )  )  ;  server . set (  key constants .    id cwi . get server id (  )  )  ;  server . set ( id   pro cwi . get server id pro (  )  )  ;  sct . set (  key constants .    server server )  ;   }  sct . set (  key constants .    request  caster . to string ( pc . get id (  )  )  )  ;  return sct ;   }  
public static double   (  page context pc  array array )  throws  page exception  {  return  array util . max ( array )  ;   }  
public   (  position start  position end )  {  super ( start end )  ;   }  
public  object   (  string key )  throws io exception  {  return cache . get value ( key )  ;   }  
@ override public  resource   (  string realpath )  {  realpath =  resource util . merge ( get inner path (  )  realpath )  ;  if  ( realpath . starts with ( " .  .  / " )  )  return null ;  return new  datasource resource ( provider data realpath )  ;   
public void   ( byte num )  {  byte   | =  ( num &  7  )  ;   }  
protected final  string   ( int month )  {  if  ( get locale (  )  . equals (  locale . us )  )   {  switch  ( month )   {  case  1 : return " january" ;  case  2 : return " february" ;  case  3 : return " march" ;  case  4 : return " april" ;  case  5 : return " may" ;  case  6 : return " june" ;  case  7 : return " july" ;  case  8 : return " august" ;  case  9 : return " september" ;  case  1 0: return " october" ;  case  1  1 : return " november" ;  case  1  2 : return " december" ;  default : return null ;   }   }  return new  date format symbols ( locale )  . get months (  ) [month  -   1 ] ;   }  
public  attributed string   (  pie dataset dataset  comparable key )  {  return null ;   }  
public void   (  string str returntype )  throws  application exception  {  if  (  string util . is empty ( str returntype )  )  return ;  str returntype = str returntype . to lower case (  )  . trim (  )  ;  if  ( str returntype . equals ( "query" )  )  returntype = return   type   query ;  else if  ( str returntype . equals ( "array   of   entity" )  || str returntype . equals ( "array - of - entity" )  || str returntype . equals ( "array   of   entities" ) || str returntype . equals ( "array - of - entities" ) || str returntype . equals ( "arrayofentities" ) || str returntype . equals ( "arrayofentities" )  )  returntype = return   type   array   of   entity ;  else throw new  application exception ( "attribute returntype of tag query has an invalid value" "valid values are [query array - of - entity] but value is now ["  +  str returntype  +  "]" )  ;   }  
private static void   (  connection conn  string name )  throws sql exception  {  name = name . replace ( ' . ' '   ' )  ;   statement stat = conn . create statement (  )  ;  stat . execute ( "drop table "  +  name )  ;  db util . commitel ( conn )  ;   }  
public void   ( boolean use alpha )  {  this . use alpha = use alpha ;   }  
public  rectangle 2 d   (  buffered image src )  {  return new  rectangle ( 0 0 src . get width (  )  src . get height (  )  )  ;   }  
@ override public void   (  )  {  map . clear (  )  ;   }  
private final boolean   (  )  {  if  ( jj    3 r    1  1  9  (  )  )  return true ;  if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;  do  {   token token 1  = jj   scanpos ;  if  ( jj    3 r    1  2 0 (  )  )   {  jj   scanpos = token 1  ;  break ;   }  if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;   }  while  ( true )  ;  return false ;   }  
private void   (  string value )  {  if  ( inside function )   {  if  ( inside attribute )   {  if  ( inside . equals ( "type" )  )  arg . set type ( value )  ;  else if  ( inside . equals ( "name" )  )  arg . set name ( value )  ;  else if  ( inside . equals ( "default" )  )  arg . set default value ( value )  ;  else if  ( inside . equals ( "default - value" )  )  arg . set default value ( value )  ;  else if  ( inside . equals ( "status" )  )  arg . set status (  tag lib factory . to status ( value )  )  ;  else if  ( inside . equals ( "description" )  )  arg . set description ( value )  ;  else if  ( inside . equals ( "alias" )  )  arg . set alias ( value )  ;  else if  ( inside . equals ( "required" )  )   {  arg . set required ( value )  ;  if  ( arg . is required (  )  )  function . set arg min ( function . get arg min (  )   +   1  )  ;   }   }  else if  ( inside return )   {  if  ( inside . equals ( "type" )  )  function . set return ( value )  ;   }  else  {  if  ( inside . equals ( "name" )  )  function . set name ( value )  ;  else if  ( inside . equals ( "class" )  )  function . set cls ( value )  ;  else if  ( inside . equals ( "tte - class" )  )  function . set tte class ( value )  ;  else if  ( inside . equals ( "description" )  )  function . set description ( value )  ;  else if  ( inside . equals ( "member - name" )  )  function . set member name ( value )  ;  else if  ( inside . equals ( "member - chaining" )  )  function . set member chaining (  caster . to boolean value ( value false )  )  ;  else if  ( inside . equals ( "status" )  )  function . set status (  tag lib factory . to status ( value )  )  ;  else if  ( inside . equals ( "argument - type" )  )  function . set arg type ( value . equals ignore case ( "dynamic" )   ?   function lib function . arg   dynamic :  function lib function . arg   fix )  ;  else if  ( inside . equals ( "argument - min" )  )  function . set arg min (  integer . parse int ( value )  )  ;  else if  ( inside . equals ( "argument - max" )  )  function . set arg max (  integer . parse int ( value )  )  ;   }   }  else  {  if  ( inside . equals ( "flib - version" )  )  lib . set version ( value )  ;  else if  ( inside . equals ( "short - name" )  )  lib . set short name ( value )  ;  else if  ( inside . equals ( "uri" )  )   {  try  {  lib . set uri ( value )  ;   }  catch  (  uri syntax exception e )   {   }   }  else if  ( inside . equals ( "display - name" )  )  lib . set display name ( value )  ;  else if  ( inside . equals ( "description" )  )  lib . set description ( value )  ;   }   }  
public void   (  function 2 d basis )  {  this . basis = basis ;   }  
@ override public boolean   (  resource res )  {  if  ( res . is directory (  )  )  return allow dir ;  if  ( res . exists (  )  )   {   string name = res . get name (  )  ;  for  ( int i = 0 ;  i  <  extensions . length ;  i +  +  )   {  if  ( ignore cas
@ override public void   ( char[] ch int start int length )  throws sax exception  {  bodies . peek (  )  . append ( ch start length )  ;   }  
private boolean   (  tag data data  tag lib tag tag lib tag  tag tag )  throws  template exception  {  if  ( tag lib tag . has tte class (  )  )   {  try  {   tag lib lib = tag lib tag . get evaluator (  )  . execute ( data . config tag tag lib tag data . flibs data )  ;  if  ( lib  !  =  null )   {  for  ( int i = 0 ;  i  <  data . tlibs[tag   lib   page] . length ;  i +  +  )   {  if  ( data . tlibs[tag   lib   page][i] . get name space and separator (  )  . equals ignore case ( lib . get name space and separator (  )  )  )   {  boolean ext is custom = data . tlibs[tag   lib   page][i] instanceof  custom tag lib ;  boolean new is custom = lib instanceof  custom tag lib ;  if  ( ext is custom )   {   (  (  custom tag lib ) data . tlibs[tag   lib   page][i] )  . append ( lib )  ;  return true ;   }  else if  ( new is custom )   {   (  (  custom tag lib ) lib )  . append ( data . tlibs[tag   lib   page][i] )  ;  data . tlibs[tag   lib   page][i] = lib ;  return true ;   }   }   }   tag lib[] new tlibs = new  tag lib[data . tlibs[tag   lib   page] . length  +   1 ] ;  for  ( int i = 0 ;  i  <  data . tlibs[tag   lib   page] . length ;  i +  +  )   {  new tlibs[i] = data . tlibs[tag   lib   page][i] ;   }  new tlibs[data . tlibs[tag   lib   page] . length] = lib ;  data . tlibs[tag   lib   page] = new tlibs ;   }   }  catch  (   evaluator exception e )   {  throw new  template exception ( data . cfml e )  ;   }   }  return true ;   }  
public boolean   (  object obj )  {  if  (  !  ( obj instanceof xml node struct )  )  return super . equals ( obj )  ;  xml node struct other =  (  ( xml node struct ) obj )  ;  return other . case sensitive = case sensitive && other . node . equals ( node )  ;   }  
public void   (  bytecode context bc )  throws  bytecode exception  {  if  (    finally  !  =  null )   {   expression util . visit line ( bc    finally . get start (  )  )  ;     finally . get body (  )  . write out ( bc )  ;   }   }  
@ override public void   (  string str locale )  throws  expression exception  {  set locale (  caster . to locale ( str locale )  )  ;   }  
private cfml factory impl[]   ( cfml factory impl[] factories  map contextes )  {  if  ( factories  =  =  null || factories . length  !  =  contextes . size (  )  )  factories =  ( cfml factory impl[] ) contextes . values (  )  . to array ( new cfml factory impl[contextes . size (  ) ] )  ;  return factories ;   }  
public static  charset   (  string charset  charset default value )  {  if  (  string util . is empty ( charset )  )  return default value ;  try  {  return  charset . for name ( charset )  ;   }  catch  (   throwable t )   {  return default value ;   }   }  
@ override public boolean   (  key other )  {  if  ( this  =  =  other )  return true ;  if  ( other instanceof  key impl )   {  return h 6  4   =  =   (  (  key impl ) other )  . h 6  4  ;   }  return uc key . equals ignore case ( other . get lower strin
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " levels" )  )  )   !  =  null )  set levels (  image filter util . to float value ( o " levels" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " contour color" )  )  )   !  =  null )  set contour color (  image filter util . to colorrgb ( o " contour color" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " offset" )  )  )   !  =  null )  set offset (  image filter util . to float value ( o " offset" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " scale" )  )  )   !  =  null )  set scale (  image filter util . to float value ( o " scale" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ levels   contour color   offset   scale]" )  ;   }  return filter ( src dst )  ;   }  
public static float   ( float a float b float x )  {  if  ( x  <  a )  return 0 ;  if  ( x  >  =  b )  return  1  ;  x =  ( x  -  a )   /   ( b  -  a )  ;  return x * x *  (  3   -   2  * x )  ;   }  
protected static  struct   (  page context pc  string cache name  string app name  string str type  log log )  throws  page exception  {   cache cache = get cache ( pc . get config (  )  cache name )  ;   string key = get key ( pc . getcfid (  )  app name str type )  ;   struct s =  (  struct ) cache . get value ( key null )  ;  if  ( s  !  =  null )   scope context . info ( log "load existing data from cache ["  +  cache name  +  "] to create " +  str type +  " scope for " +  pc . get application context (  )  . get name (  )  +  " / " +  pc . getcfid (  )  )  ;  else  scope context . info ( log "create new "  +  str type  +  " scope for " +  pc . get application context (  )  . get name (  )  +  " / " +  pc . getcfid (  )  +  " in cache [" +  cache name +  "]" )  ;  return s ;   }  
public   (  position start  position end )  {  super ( start end )  ;   }  
@ override public  object   (  key key  object value )  throws  page exception  {  log ( key . get string (  )  value )  ;  return coll . set ( key value )  ;   }  
public  string   ( int start int count )  {  return  string . value of ( text start count )  ;   }  
@ override public  string   (  string left  string right )  {  return left . concat ( right )  ;   }  
public void   ( boolean set client cookies )  {  this . set client cookies = set client cookies ;   }  
@ override public void   ( javax . servlet . jsp .  page context page context )  {  this . page context =  (  page context ) page context ;   }  
private static  string   (  page context pc int value )  throws  function exception  {  if  ( value  =  =  0 )  throw new  function exception ( pc "number format"  1  "number" "a roman value can't be 0" )  ;  if  ( value  <  0 )  throw new  function exception ( pc "number format"  1  "number" "a roman value can't be less than 0" )  ;  if  ( value  >   3  9  9  9  )  throw new  function exception ( pc "number format"  1  "number" "a roman value can't be greater than  3  9  9  9 " )  ;   string buffer roman = new  string buffer (  )  ;  while  ( value  /   1 000  >  =   1  )   {  roman . append ( 'm' )  ;  value = value  -   1 000 ;   }  if  ( value  /   9 00  >  =   1  )   {  roman . append ( "cm" )  ;  value = value  -   9 00 ;   }  if  ( value  /   5 00  >  =   1  )   {  roman . append ( "d" )  ;  value = value  -   5 00 ;   }  if  ( value  /   4 00  >  =   1  )   {  roman . append ( "cd" )  ;  value = value  -   4 00 ;   }  while  ( value  /   1 00  >  =   1  )   {  roman . append ( "c" )  ;  value = value  -   1 00 ;   }  if  ( value  /   9 0  >  =   1  )   {  roman . append ( "xc" )  ;  value = value  -   9 0 ;   }  if  ( value  /   5 0  >  =   1  )   {  roman . append ( "l" )  ;  value = value  -   5 0 ;   }  if  ( value  /   4 0  >  =   1  )   {  roman . append ( "xl" )  ;  value = value  -   4 0 ;   }  while  ( value  /   1 0  >  =   1  )   {  roman . append ( "x" )  ;  value = value  -   1 0 ;   }  if  ( value  /   9   >  =   1  )   {  roman . append ( "ix" )  ;  value = value  -   9  ;   }  if  ( value  /   5   >  =   1  )   {  roman . append ( "v" )  ;  value = value  -   5  ;   }  if  ( value  /   4   >  =   1  )   {  roman . append ( "iv" )  ;  value = value  -   4  ;   }  while  ( value  >  =   1  )   {  roman . append ( "i" )  ;  value = value  -   1  ;   }  return roman . to string (  )  ;   }  
public void   (  string custom 2  )  {  this . custom 2  = custom 2  ;   }  
@ override public sql   (  )  {  return qry . get sql (  )  ;   }  
public boolean   (  )  {  return  ( get last access (  )   +  get time span (  )  )   <   system . current time millis (  )  ;   }  
public void   ( short attribute boolean value )  throws io exception  {   string attr = null ;  if  ( attribute  =  =  attribute   archive )  attr = "a" ;  else if  ( attribute  =  =  attribute   hidden )  attr = "h" ;  else if  ( attribute  =  =  attribute   system )  attr = "s" ;  if  (  !  system util . is windows (  )  )  return ;  provider . lock ( this )  ;  try  {   runtime . get runtime (  )  . exec ( "attrib "  +  attr  +   ( value  ?  " + " : " - " )  +  " " +  get absolute path (  )  )  ;   }  finally  {  provider . unlock ( this )  ;   }   }  
@ override public  method   (  )  {  return null ;   }  
private final void   ( int output[] byte input[] int off int len )  {  int i = 0 ;  for  ( int j = 0 ;  j  <  len ;  j +  =  4  )   {  output[i] = input[off  +  j] & 0xff |  ( input[off  +  j  +   1 ] & 0xff )   <  <   8  |  ( input[off  +  j  +   2 ] & 0xff )   <  <   1  6  |  ( input[off  +  j  +   3 ] & 0xff )   <  <   2  4  ;  i +  +  ;   }   }  
@ override public  string   (  )  {  return null ;   }  
public long   (  )  {  if  ( last update  =  =  0 )   {  long temp ;  for  ( int i = 0 ;  i  <  interfaces . length ;  i +  +  )   {  temp =  component util . get compile time ( null interfaces[i] . get page source (  )  0 )  ;  if  ( temp  >  last update )  last update = temp ;   }   }  return last update ;   }  
public  map <  string  proc meta collection >    (  )  {  if  ( procedure column cache  =  =  null )  procedure column cache = new  reference map (  )  ;  return procedure column cache ;   }  
private static void   (  config server impl config server  config impl config )  throws io exception  {   resource lib = config . get config dir (  )  . get real resource ( "lib" )  ;  lib . mkdir (  )  ;   resource classes = config . get config dir (  )  . get real resource ( "classes" )  ;  classes . mkdir (  )  ;   resource[] libs = lib . list resources (  extension resource filter . extension   jar   no   dir )  ;  if  (  !  resource util . is empty directory ( classes  extension resource filter . extension   class   dir )  )   {  if  (  array util . is empty ( libs )  )   {  libs = new  resource[] { classes }  ;   }  else  {   resource[] tmp = new  resource[libs . length  +   1 ] ;  for  ( int i = 0 ;  i  <  libs . length ;  i +  +  )   {  tmp[i] = libs[i] ;   }  tmp[libs . length] = classes ;  libs = tmp ;   }   }  if  ( config server  !  =  null )   {   resource class loader rcl = config server . get resource class loader (  )  ;  libs =  resource util . merge ( libs rcl . get resources (  )  )  ;   }   class loader parent = new  class loader helper (  )  . get class (  )  . get class loader (  )  ;  config . set resource class loader ( new  resource class loader ( libs parent )  )  ;   }  
void   (  )  {  pos +  +  ;   }  
public static  page   (  page context pc  page source ps boolean force reload )  throws  page exception  {  if  ( pc . get config (  )  . debug (  )  )   {   debug entry template debug entry = pc . get debugger (  )  . get entry ( pc ps )  ;  pc . add page source ( ps true )  ;  int curr time = pc . get execution time (  )  ;  long exe time = 0 ;  long time =  system . current time millis (  )  ;  try  {  debug entry . update file load time (  ( int )  (  system . current time millis (  )   -  time )  )  ;  exe time =  system . current time millis (  )  ;  return  (  (  page source impl ) ps )  . load page ( pc force reload )  ;   }  finally  {  int diff =  (  ( int )  (  system . current time millis (  )   -  exe time )   -   ( pc . get execution time (  )   -  curr time )  )  ;  pc . set execution time ( pc . get execution time (  )   +   ( int )  (  system . current time millis (  )   -  time )  )  ;  debug entry . update exe time ( diff )  ;  pc . remove last page source ( true )  ;   }   }  pc . add page source ( ps true )  ;  try  {  return  (  (  page source impl ) ps )  . load page ( pc force reload )  ;   }  finally  {  pc . remove last page source ( true )  ;   }   }  
@ override public void   (  resource res )  throws io exception  {  provider . lock ( res )  ;   }  
public int   ( float x float y )  {  int srcx =  ( int )  math . floor ( x )  ;  int srcy =  ( int )  math . floor ( y )  ;  float x weight = x  -  srcx ;  float y weight = y  -  srcy ;  int nw  ne  sw  se ;  if  ( srcx  >  =  0 && srcx  <  width  -   1  && srcy  >  =  0 && srcy  <  height  -   1  )   {  int i = width * srcy  +  srcx ;  nw = in pixels[i] ;  ne = in pixels[i  +   1 ] ;  sw = in pixels[i  +  width] ;  se = in pixels[i  +  width  +   1 ] ;   }  else  {  nw = get pixel ( in pixels srcx srcy width height )  ;  ne = get pixel ( in pixels srcx  +   1  srcy width height )  ;  sw = get pixel ( in pixels srcx srcy  +   1  width height )  ;  se = get pixel ( in pixels srcx  +   1  srcy  +   1  width height )  ;   }  return  image math . bilinear interpolate ( x weight y weight nw ne sw se )  ;   }  
public static  double   (  object left  object right )  throws  page exception  {  double r =  caster . to double value ( right )  ;  if  ( r  =  =  0d )  throw new  arithmetic exception ( " division by zero is not possible" )  ;  return  caster . to double (  caster . to double value ( left )   /  r )  ;   }  
public  string   (  )  {  return column ;   }  
protected   ( int buffer size boolean auto flush )  {  super ( buffer size auto flush )  ;   }  
public  method   (  )  {  return method ;   }  
private   (  iterator <  collection .  key >  it )  {  this . it = it ;   }  
@ override public boolean   (  )  {  return reload on change ;   }  
@ override public void   (  )  throws io exception  {   page context pc = pc (  )  ;  if  ( pc  !  =  null )  pc . get query cache (  )  . clear unused ( pc )  ;   }  
public  collection   (  )  {  return coll ;   }  
public  expression   (  )  {  return right ;   }  
@ override public void   (  )  {  locks . clean (  )  ;   }  
@ override public  date   (  string column name )  throws sql exception  {  return query . get date ( column name )  ;   }  
@ override public void   (  string applicationtoken  string cookiedomain int idletimeout )  {  this . applicationtoken = applicationtoken ;  this . cookiedomain = cookiedomain ;  this . idletimeout = idletimeout ;   }  
public  label   (  )  {  return end ;   }  
public static  string   (  page context pc  object name double x double y double width double height boolean filled )  throws  page exception  {  if  ( name instanceof  string )  name = pc . get variable (  caster . to string ( name )  )  ;   image img =  image . to image ( name )  ;  if  ( width  <  0 )  throw new  function exception ( pc " image draw rect"  3  "width" "width must contain a none negative value" )  ;  if  ( height  <  0 )  throw new  function exception ( pc " image draw rect"  4  "height" "width must contain a none negative value" )  ;  img . draw rect (  ( int ) x  ( int ) y  ( int ) width  ( int ) height filled )  ;  return null ;   }  
public  document   (  string content )  throws sax exception  io exception  {  dom parser parser = new dom parser (  )  ;   input source source = new  input source ( content )  ;  parser . parse ( source )  ;  return parser . get document (  )  ;   }  
@ override public  map <  string cfx tag class >    (  )  {  return classes ;   }  
private final boolean   (  )  {  if  ( jj   scan   token (  4  5  )  )  return true ;  return jj   la  !  =  0 || jj   scanpos  !  =  jj   lastpos  ?  false : false ;   }  
public  decision   (  )  {  return engine . get decision util (  )  ;   }  
public  string   (  )  {  return err ;   }  
private final boolean   (  )  {   token token 1  = jj   scanpos ;  if  ( jj    3 r    2  4  (  )  )   {  jj   scanpos = token 1  ;  if  ( jj    3 r    2  5  (  )  )   {  jj   scanpos = token 1  ;  if  ( jj    3 r    2  6  (  )  )  return true ;  if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;   }  else if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;   }  else if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;  return false ;   }  
public boolean   (  )  {  return required ;   }  
public boolean   (  object o )  {  if  (  !  ( o instanceof  map .  entry )  )  return false ;   map .  entry <  ?   ?  >  e =  (  map .  entry <  ?   ?  >  ) o ;  return  concurrent hash map pro . this . remove ( e )  ;   }  
@ override public  string   (  string table name )  {  return table name ;   }  
@ override public  struct   (  page context pc  error page ep )  {  return root cause . get error block ( pc ep )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ override public orm transaction   ( boolean auto manage )  {  return new  hibernateorm transaction ( session (  )  auto manage )  ;   }  
@ override public  string   (  )  {  return string data ;   }  
public void   (  string label )  {  this . label = label ;   }  
private  object   (  page context pc sql sql  query qr  operation 2  expression int row )  throws  page exception  {  return  caster . to double (  caster . to double value ( execute exp ( pc sql qr expression . get left (  )  row )  )  %  caster . to double value ( execute exp ( pc sql qr expression . get right (  )  row )  )  )  ;   }  
private void   (  )  throws  page exception  {   string message = "missing attribute for tag schedule with action update" ;   string detail = "required attributes are [start date  start time  url  interval  operation]" ;   resource file = null ;  if  (  !  string util . is empty ( str file )  &&  !  string util . is empty ( str path )  )   {  file =  resource util . to resource not existing ( page context str path )  ;  file = file . get real resource ( str file )  ;   }  else if  (  !  string util . is empty ( str file )  )   {  file =  resource util . to resource not existing ( page context str file )  ;   }  else if  (  !  string util . is empty ( str path )  )   {  file =  resource util . to resource not existing ( page context str path )  ;   }  if  ( file  !  =  null )  page context . get config (  )  . get security manager (  )  . check file location ( page context . get config (  )  file server password )  ;  if  ( startdate  =  =  null || starttime  =  =  null || url  =  =  null || interval  =  =  null )  throw new  application exception ( message detail )  ;  if  ( requesttimeout  <  0 )  requesttimeout = page context . get request timeout (  )  ;   credentials cr = null ;  if  ( username  !  =  null )  cr =  credentials impl . to credentials ( username password )  ;  try  {   schedule task st = new  schedule task impl ( task file startdate starttime enddate endtime url port interval requesttimeout cr  proxy data impl . get instance ( proxyserver proxyport proxyuser proxypassword )  resolveurl publish hidden readonly paused auto delete )  ;  scheduler . add schedule task ( st true )  ;   }  catch  (   exception e )   {  throw  caster . to page exception ( e )  ;   }   }  
public static  tag lib tag   ( cfml string cfml  string name )  throws  template exception  {   tag lib tl ;  try  {  tl =  tag lib factory . load from system (  )  ;  return tl . get tag ( name )  ;   }  catch  (   tag lib exception e )   {  throw new  template exception ( cfml e )  ;   }   }  
public static  string   ( short type )  {  if  ( type  =  =   search index . type   custom )  return "custom" ;  else if  ( type  =  =   search index . type   file )  return "file" ;  else if  ( type  =  =   search index . type   path )  return "path" ;  else if  ( type  =  =   search index . type   url )  return "url" ;  else return "custom" ;   }  
public void   ( float randomness )  {  this . randomness = randomness ;   }  
public  set   (  string realpath )  {  return null ;   }  
public void   (  http servlet servlet  http servlet request req  http servlet response rsp )  throws  servlet exception  io exception  {  req = new http servlet request wrap ( req )  ;  cfml factory factory = getcfml factory ( servlet . get servlet context (  )  servlet . get servlet config (  )  req )  ;   config web config = factory . get config (  )  ;   page source ps = config . get page source existing ( null null req . get servlet path (  )  false true true false )  ;  if  ( ps  =  =  null )   {  rsp . send error (  4 0 4  )  ;   }  else  {   resource res = ps . get resource (  )  ;  if  ( res  =  =  null )   {  rsp . send error (  4 0 4  )  ;   }  else  {   req rsp util . set content length ( rsp res . length (  )  )  ;   string mt = servlet . get servlet context (  )  . get mime type ( req . get servlet path (  )  )  ;  if  (  !  string util . is empty ( mt )  )  rsp . set content type ( mt )  ;  io util . copy ( res rsp . get output stream (  )  true )  ;   }   }   }  
@ override public void   (  page context pc )  throws  page exception  {  session (  )  . close (  )  ;   common util . release datasource connection ( pc dc )  ;  dc = null ;   }  
@ override public void   (  resource dest )  throws io exception  {  res . move to ( dest )  ;   }  
public void   (  string column name  ref x )  throws sql exception  {  rst . update ref ( column name x )  ;   }  
private static  header[]   (  map <  string  string >  headers )  {  if  (  collection util . is empty ( headers )  )  return null ;   header[] rtn = new  header[headers . size (  ) ] ;   iterator <  entry <  string  string >  >  it = headers . entry set (  )  . iterator (  )  ;   entry <  string  string >  e ;  int index = 0 ;  while  ( it . has next (  )  )   {  e = it . next (  )  ;  rtn[index +  + ] = new  header impl ( e . get key (  )  e . get value (  )  )  ;   }  return rtn ;   }  
void   (  )  {  if  ( char buffer  !  =  char   empty )   {  try  {  char b = char buffer ;  char buffer = char   empty ;  super . print ( b )  ;   }  catch  (  io exception e )   {   }   }   }  
public static  entity   (  temporary stream ts  string content type )  {  if  ( use 4  )  return http engine 4  impl . get temporary stream entity ( ts content type )  ;  return http engine 3  impl . get temporary stream entity ( ts content type )  ;   }  
@ override public long   (  )  {  return get content length (  )  ;   }  
public void   (  page context pc )  throws io exception  {  long start =  system . current time millis (  )  ;  while  ( true )   {  synchronized  ( token )   {  if  ( list . size (  )   <  max )   {  list . add ( pc )  ;  return ;   }   }  if  ( timeout  >  0 )   system util . wait ( token timeout )  ;  else  system util . wait ( token )  ;  if  ( timeout  >  0 &&  (  system . current time millis (  )   -  start )   >  =  timeout )  throw new io exception ( "timeout  ( "  +   (  system . current time millis (  )   -  start )   +  " )  [" +  timeout +  "] is occured  server is busy handling requests" )  ;   }   }  
public  string   (  )  {  return cf types . to string ( get member type (  )  "any" )  ;   }  
public static  string   (  locale locale double number )  {   number format nf =  number format . get currency instance ( locale )  ;   currency currency = nf . get currency (  )  ;   string str =  string util . replace ( nf . format ( number )  nf . get currency (  )  . get symbol ( locale )  "" false )  . trim (  )  ;  return currency . get currency code (  )   +  " "  +  str ;   }  
public void   (  string lang )  {  attributes . setel ( "lang" lang )  ;   }  
@ override public int   (  )  throws sql exception  {  log (  )  ;  return qry . get holdability (  )  ;   }  
@ override public void   (  )  {  super . release (  )  ;  input = new  input bean (  )  ;  attributes . clear (  )  ;  passthrough = null ;  daynames = daynames   default ;  monthnames = monthnames   default ;  enabled = true ;  visible = true ;  label =
public   ( boolean dynamic type  string name  expression value  string type )  {  this . dynamic type = dynamic type ;  this . name = name ;  this . value = value ;  this . type = type ;   }  
private int   ( int x int y int[] pixels int stride )  {  return pixels[y * stride  +  x] ;   }  
protected   (  storage scope memory other boolean deep copy )  {  super ( other deep copy )  ;   }  
@ override public synchronized  object   (  )  {  return duplicate ( true )  ;   }  
private static int   (  string s bin hex byte data[] int n src pos int n dst pos int n num of bytes )  {  int n str len = s bin hex . length (  )  ;  int n avail bytes = n str len  -  n src pos  >  >   1  ;  if  ( n avail bytes  <  n num of bytes )  n num of bytes = n avail bytes ;  int n output capacity = data . length  -  n dst pos ;  if  ( n num of bytes  >  n output capacity )  n num of bytes = n output capacity ;  int n result = 0 ;  for  ( int ni = 0 ;  ni  <  n num of bytes ;  ni +  +  )   {  byte b act byte = 0 ;  boolean bl convertok = true ;  for  ( int nj = 0 ;  nj  <   2  ;  nj +  +  )   {  b act byte <  <  =  4  ;  char c act char = s bin hex . char at ( n src pos +  +  )  ;  if  ( c act char  >  =  'a' && c act char  <  =  'f' )   {  b act byte| =  ( byte )  ( c act char  -   9  7  )   +   1 0 ;  continue ;   }  if  ( c act char  >  =  '0' && c act char  <  =  ' 9 ' )  b act byte| =  ( byte )  ( c act char  -   4  8  )  ;  else bl convertok = false ;   }  if  ( bl convertok )   {  data[n dst pos +  + ] = b act byte ;  n result +  +  ;   }   }  return n result ;   }  
public short   (  )  {  return type ;   }  
@ override public boolean   (  collection <  ?  >  c )  {  throw new  unsupported operation exception (  )  ;   }  
public void   (  string street )  {  this . street = street ;   }  
@ override public void   (  throwable t )  throws  throwable  {  if  ( source . iscfc (  )  )   {   string source = is end tag  ?  "end" : "body" ;  is end tag = false ;     docfc catch ( t source )  ;   }  else super . do catch ( t )  ;   }  
private float   (  string label  string str dimension float original dimension )  throws  page exception  {  if  (  string util . is empty ( str dimension true )  )  return  -  1  ;  str dimension = str dimension . trim (  )  ;  if  (  string util . ends with ( str dimension '%' )  )   {  float p =  caster . to float value ( str dimension . substring ( 0  ( str dimension . length (  )   -   1  )  )  )   /   1 00 . 0f ;  return original dimension * p ;   }  float dimension =  caster . to float value ( str dimension )  ;  if  ( dimension  <  =  0f )  throw new  expression exception ( label  +  " has to be a none negative number" )  ;  return dimension ;   }  
public void   (  string storage )  throws  page exception  {  try  {  this . storage = s 3  . to int storage ( storage )  ;   }  catch  (  s 3  exception e )   {  throw  caster . to page exception ( e )  ;   }   }  
protected  string   (  )  {  return default password ;   }  
public final  integer   (  )  {  return disk spool buffer sizemb ;   }  
public   ( ifd stack frame frame  string name  collection coll  key[] keys )  {  this . name = name ;  this . coll = coll ;  this . keys = keys ;  children = new  array list (  )  ;  int interval = interval ;  while  ( interval * interval  <  keys . length )  interval* = interval ;  if  ( keys . length  >  interval )   {  fd collection node ;  int len = keys . length ;  int max ;  for  ( int i = 0 ;  i  <  len ;  i +  = interval )   {  max =  ( i  +   ( interval )  )   <  len  ?   ( interval )  : len  -  i ;   key[] skeys = new  key[max] ;  for  ( int y = 0 ;  y  <  max ;  y +  +  )   {  skeys[y] = keys[i  +  y] ;   }  node = new fd collection ( frame " rows" coll skeys )  ;  children . add ( new fd variable ( frame node . get name (  )  node )  )  ;   }   }  else  {  fd collection node node ;  for  ( int i = 0 ;  i  <  keys . length ;  i +  +  )   {  node = new fd collection node ( frame coll keys[i] )  ;  children . add ( new fd variable ( frame node . get name (  )  node )  )  ;   }   }   }  
@ override public void   (  )  {  super . release (  )  ;  suppresswhitespace = null ;   }  
@ override public void   (  string orm datasource )  {  this . orm datasource = orm datasource ;   }  
public void   ( boolean readonly )  {  this . readonly = readonly ;   }  
public float   (  )  {  return centrey ;   }  
public static void   (  )  {  result thread local . set ( null )  ;   }  
private static  tag lib   (  string key )  {  return hash lib . get ( key )  ;   }  
@ override public  object   (  key key  object value )  {  return jo . setel (  thread local page context . get (  )  key value )  ;   }  
@ override public boolean   (  )  {  return size (  )   =  =  0 ;   }  
private   (  input stream in )  {  this . in = in ;  this . state = new int[ 4 ] ;  this . buffer = new byte[ 6  4 ] ;  this . count = 0 ;  state[0] = 0x 6  7  4  5  2  3 0 1  ;  state[ 1 ] = 0xefcdab 8  9  ;  state[ 2 ] = 0x 9  8 badcfe ;  state[ 3 ] = 0x 1 0 3  2  5  4  7  6  ;   }  
public void   ( boolean ssl )  {  smtp . setssl ( ssl )  ;   }  
private void   ( int[] map int[] pixels int width int height int max )  {  if  ( max  =  =  0 )  max =  1  ;  for  ( int y = 0 ;  y  <  height ;  y +  +  )   {  for  ( int x = 0 ;  x  <  width ;  x +  +  )   {  int offset = x  +  y * width ;  int m = map[offset] ;  float v = 0 ;  int sa = 0  sr = 0  sg = 0  sb = 0 ;  if  ( m  =  =  0 )   {  sa = sr = sg = sb = 0 ;  sa =  ( pixels[offset]  >  >   2  4  )  & 0xff ;   }  else  {  v =  image math . clamp ( factor * m  /  max 0  1  )  ;  switch  ( type )   {  case circle   up: v =  (  image math . circle up ( v )  )  ;  break ;  case circle   down: v =  (  image math . circle down ( v )  )  ;  break ;  case smooth: v =  (  image math . smooth step ( 0  1  v )  )  ;  break ;   }  if  ( colormap  =  =  null )   {  sr = sg = sb =  ( int )  ( v *  2  5  5  )  ;   }  else  {  int c =  ( colormap . get color ( v )  )  ;  sr =  ( c  >  >   1  6  )  & 0xff ;  sg =  ( c  >  >   8  )  & 0xff ;  sb =  ( c )  & 0xff ;   }  sa = use alpha  ?   ( pixels[offset]  >  >   2  4  )  & 0xff :  pixel utils . brightness ( pixels[offset] )  ;  if  ( invert )   {  sr =  2  5  5   -  sr ;  sg =  2  5  5   -  sg ;  sb =  2  5  5   -  sb ;   }   }  if  ( merge )   {  int transp =  2  5  5  ;  int col = pixels[offset] ;  int a =  ( col & 0xff000000 )   >  >   2  4  ;  int r =  ( col & 0xff0000 )   >  >   1  6  ;  int g =  ( col & 0xff00 )   >  >   8  ;  int b =  ( col & 0xff )  ;  r =  (  ( sr * r  /  transp )  )  ;  g =  (  ( sg * g  /  transp )  )  ;  b =  (  ( sb * b  /  transp )  )  ;  if  ( r  <  0 )  r = 0 ;  if  ( r  >   2  5  5  )  r =  2  5  5  ;  if  ( g  <  0 )  g = 0 ;  if  ( g  >   2  5  5  )  g =  2  5  5  ;  if  ( b  <  0 )  b = 0 ;  if  ( b  >   2  5  5  )  b =  2  5  5  ;  pixels[offset] =  ( a  <  <   2  4  )  |  ( r  <  <   1  6  )  |  ( g  <  <   8  ) | b ;   }  else  {  pixels[offset] =  ( sa  <  <   2  4  )  |  ( sr  <  <   1  6  )  |  ( sg  <  <   8  ) | sb ;   }   }   }   }  
@ override public  set   (  )  {  return get component (  )  . entry set (  )  ;   }  
@ override public void   (  page context pc )  {  this . pc = pc ;   }  
public  string   (  )  throws dom exception  {  try  {   method m = node . get class (  )  . get method ( "get text content" new  class[] {  }  )  ;  return  caster . to string ( m . invoke ( node  array util . object   empty )  )  ;   }  catch  (   exception e )   {  throw new  page runtime exception (  caster . to page exception ( e )  )  ;   }   }  
@ override public void   (  )  {  isolation =  connection . transaction   none ;  action = action   none ;  inner tag = false ;  super . release (  )  ;  ignore = false ;   }  
public void   (  simple char stream simplecharstream int i )  {   re init ( simplecharstream )  ;   switch to ( i )  ;   }  
public static double   ( double left double right )  {  return left % right ;   }  
public  double   (  object left  object right )  throws  page exception  {  return  caster . to double (  caster . to double value ( left )  *  caster . to double value ( right )  )  ;   }  
public final z insert   (  )  throws  parse exception  {  jj   consume   token (  3  3  )  ;  jj   consume   token (  3  6  )  ;   string s =  table reference (  )  ;  z insert zinsert = new z insert ( s )  ;  switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  8  8 : jj   consume   token (  8  8  )  ;   string s 1  =  table column (  )  ;   vector vector = new  vector (  )  ;  vector . add element ( s 1  )  ;  label0: do switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  default : jj   la 1 [ 2  1 ] = jj   gen ;  break label0 ;  case  8  9 : jj   consume   token (  8  9  )  ;   string s 2  =  table column (  )  ;  vector . add element ( s 2  )  ;  break ;   }  while  ( true )  ;  jj   consume   token (  9 0 )  ;  zinsert . add columns ( vector )  ;  break ;  default : jj   la 1 [ 2  2 ] = jj   gen ;  break ;   }  switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  case  6  9 : jj   consume   token (  6  9  )  ;  jj   consume   token (  8  8  )  ;   vector vector 1  = sql expression list (  )  ;  jj   consume   token (  9 0 )  ;  z expression zexpression = new z expression ( " " )  ;  zexpression . set operands ( vector 1  )  ;  zinsert . add value spec ( zexpression )  ;  break ;  case  5  9 : z query zquery =  select statement (  )  ;  zinsert . add value spec ( zquery )  ;  break ;  default : jj   la 1 [ 2  3 ] = jj   gen ;  jj   consume   token (  -  1  )  ;  throw new  parse exception (  )  ;   }  jj   consume   token (  9  1  )  ;  return zinsert ;   }  
@ override public final  content type   (  )  {   header header = get last header ignore case ( " content -  type" )  ;  if  ( header  =  =  null )  return null ;   string[] mime charset = http util . split mime type and charset ( header . get value (  ) 
public static  string   (  string realpath )  {  int q index = realpath . index of ( ' ? ' )  ;  if  ( q index  =  =   -  1  )  return realpath ;   string file = realpath . substring ( 0 q index )  ;   string query = realpath . substring ( q index  +   1  )  ;  int s index = query . index of ( '#' )  ;   string anker = null ;  if  ( s index  !  =   -  1  )   {  anker = query . substring ( s index  +   1  )  ;  query = query . substring ( 0 s index )  ;   }   string builder res = new  string builder ( file )  ;  if  (  !  string util . is empty ( query )  )   {   string list list =  list util . to list ( query '&' )  ;   string str ;  int index ;  char del = ' ? ' ;  while  ( list . has next (  )  )   {  res . append ( del )  ;  del = '&' ;  str = list . next (  )  ;  index = str . index of ( ' = ' )  ;  if  ( index  =  =   -  1  )  res . append ( escapeqs value ( str )  )  ;  else  {  res . append ( escapeqs value ( str . substring ( 0 index )  )  )  ;  res . append ( ' = ' )  ;  res . append ( escapeqs value ( str . substring ( index  +   1  )  )  )  ;   }   }   }  if  ( anker  !  =  null )   {  res . append ( '#' )  ;  res . append ( escapeqs value ( anker )  )  ;   }  return res . to string (  )  ;   }  
private  string   (  array array  map <  object  string >  done  string id )  throws  converter exception  {  return    serialize list ( array . to list (  )  done id )  ;   }  
@ override public  string   (  string default value )  {  try  {  return  caster . to string ( get embeded object (  )  default value )  ;   }  catch  (   page exception e )   {  return default value ;   }   }  
public void   ( float edge thickness )  {  this . edge thickness = edge thickness ;   }  
public static  array   (  config config  stack trace element[] traces )  {   array tag context = new  array impl (  )  ;     get tag context ( config tag context traces new  linked list <  page source >  (  )  )  ;  return tag context ;   }  
public static  string   (  page context pc  object name  array xcoords  array ycoords boolean is polygon boolean filled )  throws  page exception  {  if  ( name instanceof  string )  name = pc . get variable (  caster . to string ( name )  )  ;   image img =  image . to image ( name )  ;  if  ( xcoords . size (  )   !  =  ycoords . size (  )  )  throw new  expression exception ( "xcoords and ycoords has not the same size" )  ;  img . draw lines ( to int array ( xcoords )  to int array ( ycoords )  is polygon filled )  ;  return null ;   }  
@ override public  boolean   (  boolean default value )  {  return default value ;   }  
private  dump data   (  page context page context int maxlevel  dump properties dp )  throws rpc exception  {   dump table functions = new  dump table ( "webservice" "#ccccff" "#cccc00" "#000000" )  ;  functions . set title ( " web  service  ( wsdl /  soap ) " )  ;  if  ( dp . get metainfo (  )  )  functions . set comment ( wsdl url )  ;  javax . wsdl .  service service = getwsdl service (  )  ;   port port = getwsdl port ( service )  ;   binding binding = port . get binding (  )  ;   symbol table symbol table = parser . get symbol table (  )  ;   binding entry b entry = symbol table . get binding entry ( binding . getq name (  )  )  ;   iterator itr = b entry . get parameters (  )  . key set (  )  . iterator (  )  ;   operation tmp op = null ;  while  ( itr . has next (  )  )   {  tmp op =  (  operation ) itr . next (  )  ;   element el = tmp op . get documentation element (  )  ;   string buffer doc = new  string buffer (  )  ;  if  ( el  !  =  null )   {   node list children = xml util . get child nodes ( el  node . text   node )  ;  int len = children . get length (  )  ;   text text ;  for  ( int i = 0 ;  i  <  len ;  i +  +  )   {  text =  (  text ) children . item ( i )  ;  doc . append ( text . get data (  )  )  ;   }   }  functions . append row (  1  new  simple dump data ( tmp op . get name (  )  )     tohtml operation ( doc . to string (  )   (  parameters ) b entry . get parameters (  )  . get ( tmp op )  )  )  ;   }  return functions ;   }  
public void   (  class clazz  string arguments )  throws  page exception  {  check write access (  )  ;   security manager sm = config . get security manager (  )  ;  short access = sm . get access (  security manager . type   file )  ;  boolean has access = access  =  =   security manager . value   yes ;   string class name = clazz . get name (  )  ;  if  (  ! has access )  throw new  security exception ( "no access to update resources" )  ;   element parent =    get root element ( "resources" )  ;   element[] children =  config web factory . get children ( parent "default - resource - provider" )  ;  for  ( int i = 0 ;  i  <  children . length ;  i +  +  )   {   element el = children[i] ;  el . set attribute ( "arguments" arguments )  ;  return ;   }   element el = doc . create element ( "default - resource - provider" )  ;  parent . append child ( el )  ;  el . set attribute ( "arguments" arguments )  ;  el . set attribute ( "class" class name )  ;   }  
public int   (  )  {  return    from ;   }  
private void   (  )  throws  page exception  {   string classname = get string ( "admin" action "class" )  ;   class clazz = null ;  try  {  clazz =  class util . load class ( config . get class loader (  )  classname )  ;   }  catch  (   class exception e )   {  throw  caster . to page exception ( e )  ;   }   string scheme = get string ( "admin" action "scheme" )  ;   struct sct arguments = get struct ( "arguments" null )  ;  if  ( sct arguments  !  =  null )   {  admin . update resource provider ( scheme clazz sct arguments )  ;   }  else  {   string str arguments = get string ( "admin" action "arguments" )  ;  admin . update resource provider ( scheme clazz str arguments )  ;   }  store (  )  ;  admin sync . broadcast ( attributes config )  ;   }  
public static  string   (  page context pc )  throws  page exception  {  orm util . get session ( pc )  . close ( pc )  ;  return null ;   }  
public void   ( float bump softness )  {  this . bump softness = bump softness ;   }  
public boolean   (  )  {  return nowait    ;   }  
public static  object   (  page context pc byte[] data int format  charset charset  object default value )  {  switch  ( format )   {  case udf . return   format   json: try  {  return new json expression interpreter (  )  . interpret ( pc to string ( data charset )  )  ;   }  catch  (   page exception pe )   {   }  break ;  case udf . return   format   serialize: try  {  return new cfml expression interpreter (  )  . interpret ( pc to string ( data charset )  )  ;   }  catch  (  page exception pe )   {   }  break ;  case udf . return   format   wddx: try  {  wddx converter converter = new wddx converter ( pc . get time zone (  )  false true )  ;  converter . set time zone ( pc . get time zone (  )  )  ;  return converter . deserialize ( to string ( data charset )  false )  ;   }  catch  (  exception pe )   {   }  break ;  case udf . return   format   xml: try  {   input source xml = xml util . to input source ( pc to string ( data charset )  )  ;   input source validator = null ;  return xml caster . toxml struct ( xml util . parse ( xml validator false )  true )  ;   }  catch  (  exception pe )   {   }  break ;  case udf plus . return   format   java: try  {  return  java converter . deserialize ( new  byte array input stream ( data )  )  ;   }  catch  (  exception pe )   {   }  break ;   }  return default value ;   }  
public static  object   (  page context pc  string wsdl url  string username  string password  proxy data proxy )  throws  page exception  {  return new rpc client ( wsdl url username password proxy )  ;   }  
private static  set <  string >    (  page context pc  string package name )  throws io exception   application exception  {   page context impl pci =  (  page context impl ) pc ;   config web impl config =  (  config web impl ) pc . get config (  )  ;   set <  string >  rtn = null ;  boolean search local = config . get component local search (  )  ;  boolean search root = config . get component root search (  )  ;   string path =  string util . replace ( package name " . "  file . separator false )  ;  if  ( search local )   {   page source ps = pci . get relative page source existing ( path )  ;  if  ( ps  !  =  null )   {   mapping mapping = ps . get mapping (  )  ;   string    path = ps . get realpath (  )  ;     path =  list util . trim (    path "\\ / " )  ;   string[] list =    list mapping ( pc mapping    path )  ;  if  (  !  array util . is empty ( list )  )  rtn = add ( rtn list )  ;   }   }  if  ( search root )   {   string virtual = " / "  +   string util . replace ( package name " . " " / " false )  ;   mapping[] mappings = config . get mappings (  )  ;   mapping mapping ;   string    path ;   string[] list ;  for  ( int i = 0 ;  i  <  mappings . length ;  i +  +  )   {  mapping = mappings[i] ;  if  (  string util . starts with ignore case ( virtual mapping . get virtual (  )  )  )   {     path =  list util . trim ( virtual . substring ( mapping . get virtual (  )  . length (  )  )  "\\ / " )  . trim (  )  ;     path =  string util . replace (    path " / "  file . separator false )  ;  list =    list mapping ( pc mapping    path )  ;  if  (  !  array util . is empty ( list )  )  rtn = add ( rtn list )  ;   }   }   }   mapping[] mappings = config . get component mappings (  )  ;   mapping mapping ;   string[] list ;  for  ( int i = 0 ;  i  <  mappings . length ;  i +  +  )   {  mapping = mappings[i] ;  list =    list mapping ( pc mapping path )  ;  if  (  !  array util . is empty ( list )  )  rtn = add ( rtn list )  ;   }  if  ( rtn  =  =  null )  throw new  application exception ( "no package with name ["  +  package name  +  "] found" )  ;  return rtn ;   }  
private  string   (  date time date time )  {  return go in (  )   +  json date format . format ( date time null )  ;   }  
public static  tag   (  statement stat )  throws  bytecode exception  {   statement parent = stat ;  while  ( true )   {  parent = parent . get parent (  )  ;  if  ( parent  =  =  null )   {  throw new  bytecode exception ( "missing parent  statement of  statement" stat . get start (  )  )  ;   }  if  ( parent instanceof  tag component )  return  (  tag ) parent ;   }   }  
public void   (  )  {   system . out . println ( " server sent "  +  tm . chain . length  +  " certificate ( s ) :" )  ;  for  ( int i = 0 ;  i  <  tm . chain . length ;  i +  +  )   {  x 5 0 9  certificate cert = tm . chain[i] ;   system . out . println ( " "  +   ( i  +   1  )   +  "  subject " +  cert . get subjectdn (  )  )  ;   system . out . println ( "  issuer "  +  cert . get issuerdn (  )  )  ;   system . out . println (  )  ;   }   }  
private  object   (  object value )  throws  page exception  {  if  ( maxlength  !  =   -  1  )   {   string str =  caster . to string ( value )  ;  if  ( str . length (  )   >  maxlength )  throw new  database exception ( "value ["  +  value  +  "] is to large  defined maxlength is [" +   caster . to string ( maxlength )  +  "] but length of value is [" +  str . length (  )  +  "]" null null null )  ;   }  return value ;   }  
@ override public  cookie[]   (  )  {  return null ;   }  
static void   (  page context pc  page source requested page  page source application  request listener rl )  throws  page exception  {  if  ( application  !  =  null )  pc . do include ( new  page source[] { application }  false )  ;  if  ( rl  !  =  null )   {  requested page = rl . execute ( pc requested page )  ;  if  ( requested page  =  =  null )  return ;   }  try  {  pc . do include ( new  page source[] { requested page }  false )  ;   }  catch  (   missing include exception mie )   {   application context ac = pc . get application context (  )  ;  boolean rethrow = true ;  if  ( ac instanceof  classic application context )   {   classic application context cfc =  (  classic application context ) ac ;  udf udf = cfc . get on missing template (  )  ;  if  ( udf  !  =  null )   {   string target page = requested page . get full realpath (  )  ;  rethrow =  (  !  caster . to boolean value ( udf . call ( pc new  object[] { target page }  true )  true )  )  ;   }   }  if  ( rethrow )  throw mie ;   }  if  ( application  !  =  null )   {   page source on req end = application . get real page ( " on request end . cfm" )  ;  if  ( on req end . exists (  )  )  pc . do include ( new  page source[] { on req end }  false )  ;   }   }  
private  font   (  list fonts int font size int shear int index )  {   affine transform trans 1  = get random transformation ( shear shear )  ;   affine transform trans 2  = get random transformation ( shear shear )  ;   font font =  (  font ) fonts . get ( index % fonts . size (  )  )  ;  font = font . derive font (  ( float ) font size )  . derive font ( trans 1  )  . derive font ( trans 2  )  ;  return font ;   }  
private static void   (  class vm class  object vm obj )  throws  security exception   no such method exception   illegal argument exception   illegal access exception   invocation target exception  {   method detach = vm class . get method ( "detach" new  class[] {  }  )  ;  detach . invoke ( vm obj new  object[] {  }  )  ;   }  
private static void   (  http method http method  string charset )  {  if  ( charset  !  =  null )  http method . add request header ( " content - type" "text / html ;  charset = "  +  charset )  ;   }  
void   (  )  {  try  {  process =  command . create process ( command true )  ;   command result result =  command . execute ( process )  ;   string rst = result . get output (  )  ;  finished = true ;  if  (  ! aborted )   {  if  ( outputfile  =  =  null && variable  =  =  null )  pc . write ( rst )  ;  else  {  if  ( outputfile  !  =  null )  io util . write ( outputfile rst  system util . get charset (  )  false )  ;  if  ( variable  !  =  null )  pc . set variable ( variable rst )  ;   }  if  ( error file  !  =  null )  io util . write ( error file result . get error (  )   system util . get charset (  )  false )  ;  if  ( error variable  !  =  null )  pc . set variable ( error variable result . get error (  )  )  ;   }   }  catch  (   exception ioe )   {  exception = ioe ;   }  finally  {  synchronized  ( monitor )   {  monitor . notify (  )  ;   }   }   }  
public   (  string message  string detail )  {  super ( message detail )  ;   }  
@ override public void   ( int size )  {  this . buffer size = size ;   }  
@ override public boolean   (  resource dest )  {  return res . rename to ( dest )  ;   }  
public   (  position start  position end )  {  super ( start end )  ;   }  
public void   (  string id )  {  this . id = id ;   }  
@ override public boolean   (  )  {  return pc  !  =  null ;   }  
public static void   (  )  {  complete +  +  ;   }  
public void   (  class writer class writer )  {  this . class writer = class writer ;   }  
@ override public  node   (  object o )  throws  page exception  {  return  caster . to node ( o )  ;   }  
@ override public boolean   (  object value )  {  return super . contains value ( value )  ;   }  
@ override public void   (  message context msg context )  throws  axis fault  {  try  {  setup service ( msg context )  ;   }  catch  (   exception e )   {  throw  axis fault . make fault ( e )  ;   }   }  
public   ( smtp client client )  {  this ( execution   plans client )  ;   }  
public  jsp writer   (  )  {  return body content stack . get base (  )  ;   }  
private void   (  object output stream stream )  throws io exception  {  stream . default write object (  )  ;   serial utilities . write paint ( this . paint stream )  ;   }  
public static boolean   (  node node )  {  if  ( node instanceof xml struct )  return  (  ( xml struct ) node )  . is case sensitive (  )  ;  return true ;   }  
private  object   (  page context pc sql sql  query qr z expression expression int row )  throws  page exception  {  return new  double (  caster . to double value ( execute exp ( pc sql qr expression . get operand ( 0 )  row )  )   -   caster . to double value ( execute exp ( pc sql qr expression . get operand (  1  )  row )  )  )  ;   }  
public static double   (  array array )  throws  expression exception  {  if  ( array . get dimension (  )   >   1  )  throw new  expression exception ( "can only get sum / avg from  1  dimensional arrays" )  ;  double rtn = 0 ;  int len = array . size (  )  ;  for  ( int i =  1  ;  i  <  =  len ;  i +  +  )   {  rtn +  =    to double value ( array i )  ;   }  return rtn ;   }  
void   ( byte r[][] byte g[][] byte b[][] )  throws awt exception  {  pixels    = new byte[width    * height   ] ;  colors    = new byte[ 2  5  6  *  3 ] ;  int colornum = 0 ;  for  ( int x = 0 ;  x  <  width    ;   +  + x )   {  for  ( int y = 0 ;  y  <  height    ;   +  + y )   {  int search ;  for  ( search = 0 ;  search  <  colornum ;   +  + search )  if  ( colors   [search *  3 ]  =  =  r[x][y] && colors   [search *  3   +   1 ]  =  =  g[x][y] && colors   [search *  3   +   2 ]  =  =  b[x][y] )  break ;  if  ( search  >   2  5  5  )  throw new awt exception ( " too many colors . " )  ;  pixels   [y * width     +  x] =  ( byte ) search ;  if  ( search  =  =  colornum )   {  colors   [search *  3 ] = r[x][y] ;  colors   [search *  3   +   1 ] = g[x][y] ;  colors   [search *  3   +   2 ] = b[x][y] ;   +  + colornum ;   }   }   }  num colors    =  1   <  <   bit utils .  bits needed ( colornum )  ;  byte copy[] = new byte[num colors    *  3 ] ;   system . arraycopy ( colors    0 copy 0 num colors    *  3  )  ;  colors    = copy ;   }  
private void   (  page context pc  set test  list list  string buffer sb boolean serialize query by columns  set <  object >  done )  throws  converter exception  {  sb . append ( go in (  )  )  ;  sb . append ( "[" )  ;  boolean do it = false ;   list iterator it = list . list iterator (  )  ;  while  ( it . has next (  )  )   {  if  ( do it )  sb . append ( ' ' )  ;  do it = true ;     serialize ( pc test it . next (  )  sb serialize query by columns done )  ;   }  sb . append ( ']' )  ;   }  
public void   (  )  throws io exception  {  int num bytes = index     +   ( bits left     =  =   8   ?  0 :  1  )  ;  if  ( num bytes  >  0 )   {  output    . write ( num bytes )  ;  output    . write ( buffer    0 num bytes )  ;  buffer   [0] = 0 ;  index    = 0 ;  bits left    =  8  ;   }   }  
public void   (  mapping[] mappings )  {  if  ( mappings . length  >  0 )  this . mappings = mappings ;   }  
public  string   (  string file )  {  throw not supported ( "get mime type (  string file ) " )  ;   }  
@ override public  object   (  key key  object default value )  {   object res = super . get ( key default value )  ;  if  ( res instanceof  cluster entry )  return  (  (  cluster entry ) res )  . get value (  )  ;  return res ;   }  
public static boolean   (  page context pc  string string  string str locale )  {  try  {  ls parse currency . to double value (  locale factory . get locale ( str locale )  string false )  ;  return true ;   }  catch  (   throwable t )   {  return false ;   }   }  
@ override public  boolean   (  boolean default value )  {  return default value ;   }  
public void   (  number max query count )  {  this . max query count = max query count ;   }  
public void   ( double proxy port )  {  this . proxy port =  ( int ) proxy port ;   }  
public boolean   (  )  {  return local url ;   }  
public boolean   (  string str )  {  int c = pos ;  if  ( forward if current ( str )  )   {  if  (  ! is current between ( 'a' 'z' )  &&  ! is current between ( '0' ' 9 ' )  &&  ! is current ( '   ' )  )  return true ;   }  pos = c ;  return false ;   }  
private int   ( int[] v )  {  int minindex = 0  maxindex = 0  min =  integer . max   value  max =  integer . min   value ;  for  ( int i = 0 ;  i  <   9  ;  i +  +  )   {  if  ( i  !  =   4  )   {  if  ( v[i]  <  min )   {  min = v[i] ;  minindex = i ;   }  if  ( v[i]  >  max )   {  max = v[i] ;  maxindex = i ;   }   }   }  if  ( v[ 4 ]  <  min )  return v[minindex] ;  if  ( v[ 4 ]  >  max )  return v[maxindex] ;  return v[ 4 ] ;   }  
public boolean   (  string first  string second  string third  string forth )  {  int start = pos ;  if  (  ! forward if current ( first )  )  return false ;  if  (  ! remove space (  )  )   {  pos = start ;  return false ;   }  if  (  ! forward if current ( second )  )   {  pos = start ;  return false ;   }  if  (  ! remove space (  )  )   {  pos = start ;  return false ;   }  if  (  ! forward if current ( third )  )   {  pos = start ;  return false ;   }  if  (  ! remove space (  )  )   {  pos = start ;  return false ;   }  boolean rtn = forward if current ( forth )  ;  if  (  ! rtn )  pos = start ;  return rtn ;   }  
@ override public void   (  string detail )  {  root cause . set detail ( detail )  ;   }  
public  string   (  )  {  return " blur /  detect  edges" ;   }  
@ override public boolean   (  )  {  return config server . get full null support (  )  ;   }  
public   (  tuple 3 f t )  {  this . x = t . x ;  this . y = t . y ;  this . z = t . z ;   }  
private static  string   ( sql item item )  throws  page exception  {   string str =  string util . replace (  caster . to string ( item . get value (  )  )  "'" "''" false )  ;  return "'"  +  str  +  "'" ;   }  
@ override public  string   (  )  {  return node . get prefix (  )  ;   }  
@ override public void   ( boolean also remove children )  throws io exception  {  if  ( also remove children && is directory (  )  )   {   resource[] children = list resources (  )  ;  for  ( int i = 0 ;  i  <  children . length ;  i +  +  )   {  childre
public float   (  )  {  return density ;   }  
public  string   (  )  {  return template ;   }  
@ override public  comment   (  string data )  {  return doc . create comment ( data )  ;   }  
public static  string   (  page context pc )  throws  page exception  {   (  (  page context impl ) pc )  . invalidate user scopes ( true true )  ;  return null ;   }  
private int   (  string column name )  throws sql exception  {   simple query column col = columns . get ( column name . to lower case (  )  )  ;  if  ( col  =  =  null )  throw new sql exception ( " there is no column with name ["  +  column name  +  "]  available columns are [" +  get columnlist (  )  +  "]" )  ;  return col . get index (  )  ;   }  
@ override public  object   (  key key  object default value )  {  log ( key . get string (  )  )  ;  return coll . get ( key default value )  ;   }  
public void   ( boolean gridlines )  {  this . gridlines = gridlines ;   }  
public void   (  string onvalidate )  {  input . set on validate ( onvalidate )  ;   }  
@ override public sqlxml   (  string arg0 )  throws sql exception  {  log ( arg0 )  ;  return qry . getsqlxml ( arg0 )  ;   }  
public   ( float alpha )  {  super ( alpha )  ;   }  
@ override public boolean   (  )  {  return query . is empty (  )  ;   }  
public  map .  entry < k v >    (  )  {  return next entry (  )  ;   }  
public void   (  string wave type )  throws  expression exception  {   string str = wave type . trim (  )  . to upper case (  )  ;  if  ( "sine" . equals ( str )  )  this . wave type = sine ;  else if  ( "sawtooth" . equals ( str )  )  this . wave type = sawtooth ;  else if  ( "triangle" . equals ( str )  )  this . wave type = triangle ;  else if  ( "noise" . equals ( str )  )  this . wave type = noise ;  else throw new  expression exception ( "invalid value ["  +  wave type  +  "] for wave type  valid values are [sine sawtooth triangle noise]" )  ;   }  
public   (  object return value )  {  this . return value = return value ;   }  
public  string   (  )  {  return " binary /  outline .  .  . " ;   }  
public static final  client scope service   (  )  throws  service exception  {  throw missing service ( " client scope service" )  ;   }  
public boolean   (  )  {  return required ;   }  
public void   (  binary function black function )  {  this . black function = black function ;   }  
public void   ( boolean appendkey )  {  this . appendkey = appendkey ;   }  
@ override public int   (  )  throws  page exception  {  if  ( do caching && body  !  =  null )   {  try  {  write cache resource ( cache item body )  ;  page context . write ( body )  ;   }  catch  (  io exception e )   {  throw  caster . to page excepti
public  string   (  )  {  return from  +  " - "  +  to ;   }  
public  type   (  bytecode context bc int mode )  throws  bytecode exception  {   generator adapter adapter = bc . get adapter (  )  ;   label yes = new  label (  )  ;   label end = new  label (  )  ;   list <  member >  members = left . get members (  )  ;   iterator <  member >  it = members . iterator (  )  ;   list <  data member >  list = new  array list <  data member >  (  )  ;  while  ( it . has next (  )  )   {  list . add (  (  data member ) it . next (  )  )  ;   }   data member[] arr = list . to array ( new  data member[members . size (  ) ] )  ;   expression util . visit line ( bc left . get start (  )  )  ;  adapter . load arg ( 0 )  ;  adapter . push (  ( double ) left . get scope (  )  )  ;  boolean all literal = true ;  for  ( int i = 0 ;  i  <  arr . length ;  i +  +  )   {  if  (  !  ( arr[i] . get name (  )  instanceof  literal )  )  all literal = false ;   }   array visitor av = new  array visitor (  )  ;  if  (  ! all literal )   {  av . visit begin ( adapter  types . string arr . length )  ;  for  ( int i = 0 ;  i  <  arr . length ;  i +  +  )   {  av . visit begin item ( adapter i )  ;  arr[i] . get name (  )  . write out ( bc mode   ref )  ;  av . visit end item ( adapter )  ;   }   }  else  {  av . visit begin ( adapter  types . collection   key arr . length )  ;  for  ( int i = 0 ;  i  <  arr . length ;  i +  +  )   {  av . visit begin item ( adapter i )  ;   variable . register key ( bc arr[i] . get name (  )  )  ;  av . visit end item ( adapter )  ;   }   }  av . visit end (  )  ;  adapter . invoke static ( elvis all literal  ?  invoke   key : invoke   str )  ;   expression util . visit line ( bc left . get end (  )  )  ;  adapter . visit jump insn (  opcodes . ifeq yes )  ;   expression util . visit line ( bc left . get start (  )  )  ;  left . write out ( bc mode   ref )  ;   expression util . visit line ( bc left . get end (  )  )  ;  adapter . visit jump insn (  opcodes . goto end )  ;   expression util . visit line ( bc right . get start (  )  )  ;  adapter . visit label ( yes )  ;  right . write out ( bc mode   ref )  ;   expression util . visit line ( bc right . get end (  )  )  ;  adapter . visit label ( end )  ;  return  types . object ;   }  
public static void   (  kernel kernel int[] in pixels int[] out pixels int width int height boolean alpha int edge action )  {  if  ( kernel . get height (  )   =  =   1  )  convolveh ( kernel in pixels out pixels width height alpha edge action )  ;  else if  ( kernel . get width (  )   =  =   1  )  convolvev ( kernel in pixels out pixels width height alpha edge action )  ;  else convolvehv ( kernel in pixels out pixels width height alpha edge action )  ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " gain" )  )  )   !  =  null )  set gain (  image filter util . to float value ( o " gain" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " bias" )  )  )   !  =  null )  set bias (  image filter util . to float value ( o " bias" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " dimensions" )  )  )   !  =  null )   {  int[] dim =  image filter util . to dimensions ( o " dimensions" )  ;  set dimensions ( dim[0] dim[ 1 ] )  ;   }  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ gain   bias   dimensions]" )  ;   }  return filter ( src dst )  ;   }  
public void   (  )  {  if  ( size (  )   >  0 )   {  arr = new int[cap] ;  size = 0 ;  off count =  1  ;  offset = 0 ;   }   }  
public   (  )  {  super ( scope   request )  ;   }  
public int   (  )  {  return eval   body   include ;   }  
public void   (  string img open custom )  {  this . img open custom = img open custom ;   }  
private  ref   (  )  throws  page exception  {  if  ( cfml . is valid index (  )  )   {  if  ( cfml . is current ( ' ! ' )  &&  ! cfml . is current ( " !  = " )  )   {  cfml . next (  )  ;  cfml . remove space (  )  ;  return new  not ( decsion op (  )  )  ;   }  else if  ( cfml . forward if current and no word after ( "not" )  )   {  cfml . remove space (  )  ;  return new  not ( decsion op (  )  )  ;   }   }  return decsion op (  )  ;   }  
public void   (  proxy data proxy data )  {  this . proxy data = proxy data ;   }  
@ override public void   (  page context pc )  throws  page exception  {   string str remote persis id =  caster . to string ( getur lor form ( pc remote   persistent   id null )  null )  ;  if  (  !  string util . is empty ( str remote persis id true )  
public void   ( boolean b )  throws  page exception  {  invoke ( pd 4 ml "enable table breaks" b )  ;   }  
public void   ( int position )  {  this . position = position ;   }  
public void   (  )  throws io exception  {  enclosing writer . close (  )  ;   }  
@ override protected  ref   (  )  throws  page exception  {  char quoter = cfml . get current lower (  )  ;  l string buffer str = new l string buffer (  )  ;  while  ( cfml . has next (  )  )   {  cfml . next (  )  ;  if  ( cfml . is current ( '\\' )  ) 
private final  object   (  function argument arg  object value int index )  throws  page exception  {  if  (  decision . is castable to ( arg . get type (  )  arg . get type as string (  )  value )  )  return value ;  throw new udf caster exception ( this arg value index )  ;   }  
@ override public void   (  string catalog )  throws sql exception  {  conn . set catalog ( catalog )  ;   }  
public static boolean   (  )  {   message context context =  message context . get current context (  )  ;  return context  !  =  null &&  ! context . is client (  )  ;   }  
@ override public void   (  page context pc  object source  output stream os )  throws  converter exception  io exception  {  try  {   image img =  image . create image ( pc source false true true format )  ;  img . write out ( os format  1  false )  ;   
public  string   (  )  {  return " stylize /  flush  3 d .  .  . " ;   }  
@ override public n clob   (  )  throws sql exception  {  return conn . createn clob (  )  ;   }  
@ override public int   (  )  {  return xml util . child nodes length ( parent  node . element   node case sensitive filter )  ;   }  
@ override public void   (  page context pc )  {  if  ( http session  !  =  null )   {  try  {   object key ;   enumeration e = http session . get attribute names (  )  ;  while  ( e . has more elements (  )  )   {  key = e . next element (  )  ;  if  ( k
@ override public boolean   (  )  {  return true ;   }  
public void   (  string server )  {  this . server = server ;   }  
public void   (  string str type )  throws  application exception  {  str type =  string util . to lower case ( str type . trim (  )  )  ;  if  ( "pagebreak" . equals ( str type )  )  type = type   page   break ;  else if  ( "header" . equals ( str type )  )  type = type   header ;  else if  ( "footer" . equals ( str type )  )  type = type   footer ;  else if  ( "bookmark" . equals ( str type )  )  type = type   bookmark ;  else throw new  application exception ( "invalid type ["  +  str type  +  "]  valid types are [pagebreak header footer bookmark]" )  ;   }  
@ override public boolean   (  )  {  return script protected  =  =   script protected . yes ;   }  
public static double   (  page context pc  date time date  string str timezone )  throws  expression exception  {  return    call ( pc date str timezone  =  =  null  ?  pc . get time zone (  )  :  time zone util . to time zone ( str timezone )  )  ;   }  
public   (  spooler engine impl engine  spooler task task )  {  this . engine = engine ;  this . task = task ;   }  
public void   (  function lib function function )  {  function . set function lib ( this )  ;  functions . put ( function . get name (  )  function )  ;   }  
private void   (  )  throws  page exception  {     do verify mail server ( get string ( "admin" action "hostname" )  get int ( "admin" action "port" )  get string ( "admin" action "mailusername" )  get string ( "admin" action "mailpassword" )  )  ;   }  
public static boolean   (  string str )  {  return isu sor euro date euro ( str true )  ;   }  
@ override public  date time   (  object o  time zone tz )  throws  page exception  {  return  caster . to date ( o tz )  ;   }  
public float   (  )  {  return ring amount ;   }  
private static void   (  config server impl config server  config impl config  document doc )  {  boolean has access =  config web util . has access ( config  security manager . type   setting )  ;   element setting = has access  ?  get child by name ( doc . get document element (  )  "setting" )  : null ;  boolean hascs = config server  !  =  null ;   string str = null ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "suppress - content" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  config . set suppress content ( to boolean ( str false )  )  ;   }  else if  ( hascs )  config . set suppress content ( config server . is suppress content (  )  )  ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "cfml - writer" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  if  ( "white - space" . equals ignore case ( str )  )  config . setcfml writer type (  config impl . cfml   writer   ws )  ;  else if  ( "white - space - pref" . equals ignore case ( str )  )  config . setcfml writer type (  config impl . cfml   writer   ws   pref )  ;  else if  ( "regular" . equals ignore case ( str )  )  config . setcfml writer type (  config impl . cfml   writer   refular )  ;   }  else if  ( hascs )  config . setcfml writer type ( config server . getcfml writer type (  )  )  ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "show - version" )  ;  if  (  string util . is empty ( str )  )  str = setting . get attribute ( "showversion" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  config . set show version ( to boolean ( str true )  )  ;   }  else if  ( hascs )  config . set show version ( config server . is show version (  )  )  ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "close - connection" )  ;  if  (  string util . is empty ( str )  )  str = setting . get attribute ( "closeconnection" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  config . set close connection ( to boolean ( str false )  )  ;   }  else if  ( hascs )  config . set close connection ( config server . close connection (  )  )  ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "content - length" )  ;  if  (  string util . is empty ( str )  )  str = setting . get attribute ( "contentlength" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  config . set content length ( to boolean ( str true )  )  ;   }  else if  ( hascs )  config . set content length ( config server . content length (  )  )  ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "buffer - output" )  ;  if  (  string util . is empty ( str )  )  str = setting . get attribute ( "bufferoutput" )  ;   }   boolean b =  caster . to boolean ( str null )  ;  if  ( b  !  =  null && has access )   {  config . set buffer output ( b . boolean value (  )  )  ;   }  else if  ( hascs )  config . set buffer output ( config server . get buffer output (  )  )  ;  str = null ;  if  ( setting  !  =  null )   {  str = setting . get attribute ( "allow - compression" )  ;  if  (  string util . is empty ( str )  )  str = setting . get attribute ( "allowcompression" )  ;   }  if  (  !  string util . is empty ( str )  && has access )   {  config . set allow compression ( to boolean ( str true )  )  ;   }  else if  ( hascs )  config . set allow compression ( config server . allow compression (  )  )  ;   }  
public void   ( float a )  {  this . a = a ;   }  
@ override public boolean   (  )  {  return false ;   }  
@ override public  statement   ( int result set type int result set concurrency int result set holdability )  throws sql exception  {  throw not supported (  )  ;   }  
private  string   (  resource[] reses )  {  if  ( reses  =  =  null )  return "" ;   string builder sb = new  string builder (  )  ;  for  ( int i = 0 ;  i  <  reses . length ;  i +  +  )   {  sb . append ( to str ( reses[i] )  )  ;   }  return sb . to string (  )  ;   }  
public final z exp   (  )  throws  parse exception  {  z expression zexpression = null ;  boolean flag = true ;  z exp zexp = sql unary logical expression (  )  ;  label0: do switch  ( jj   ntk  !  =   -  1   ?  jj   ntk : jj   ntk (  )  )   {  default : jj   la 1 [ 6  4 ] = jj   gen ;  break label0 ;  case  6 : jj   consume   token (  6  )  ;  z exp zexp 1  = sql unary logical expression (  )  ;  if  ( flag )  zexpression = new z expression ( "and" zexp )  ;  flag = false ;  zexpression . add operand ( zexp 1  )  ;  break ;   }  while  ( true )  ;  return  (  ( flag  ?  zexp : zexpression )  )  ;   }  
public  warp grid   (  )  {  return source grid ;   }  
@ override public boolean   (  )  {  return name  !  =  null ;   }  
@ override public  object   (  page context pc  collection .  key method name  object[] arguments )  throws  page exception  {  return query . call ( pc method name arguments )  ;   }  
private void   (  map <  collection .  key udf >  interfacesud fs )  {  this . interfacesud fs = interfacesud fs ;   }  
public static void   ( final  tag group tag  bytecode context bc )  throws  bytecode exception  {  final  generator adapter adapter = bc . get adapter (  )  ;  tag . set number iterator ( adapter . new local ( number   iterator )  )  ;  boolean is output = tag . get type (  )   =  =   tag group . tag   output ;   parse body visitor pbv = is output  ?  new  parse body visitor (  )  : null ;  if  ( is output )  pbv . visit begin ( bc )  ;  tag . set query ( adapter . new local (  types . query )  )  ;  adapter . load arg ( 0 )  ;   expression val = tag . get attribute ( "query" )  . get value (  )  ;  val . write out ( bc  expression . mode   ref )  ;  if  ( val instanceof  lit string )  adapter . invoke virtual (  types . page   context  tag loop . get   query   string )  ;  else adapter . invoke virtual (  types . page   context  tag loop . get   query   obj )  ;  adapter . store local ( tag . get query (  )  )  ;  tag . setpid ( adapter . new local (  types . int   value )  )  ;  adapter . load arg ( 0 )  ;  adapter . invoke virtual (  types . page   context  tag loop . get   id )  ;  adapter . store local ( tag . getpid (  )  )  ;  final int start at = adapter . new local (  types . int   value )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . load local ( tag . getpid (  )  )  ;  adapter . invoke interface (  types . query  tag loop . get   currentrow    1  )  ;  adapter . store local ( start at )  ;   decision int visitor div = new  decision int visitor (  )  ;  div . visit begin (  )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . invoke interface (  types . query get   recordcount )  ;  div . visitgt (  )  ;  adapter . push ( 0 )  ;  div . visit end ( bc )  ;   label if rec count = new  label (  )  ;  adapter . ifz cmp (  opcodes . ifeq if rec count )  ;  int from = adapter . new local (  types . int   value )  ;   attribute attr start row = tag . get attribute ( "startrow" )  ;  if  ( attr start row  !  =  null )   {   cast int . to expr int ( attr start row . get value (  )  )  . write out ( bc  expression . mode   value )  ;  adapter . push (  1  )  ;  adapter . invoke static (  types . number   range range )  ;   }  else  {  adapter . push (  1  )  ;   }  adapter . store local ( from )  ;  adapter . load local ( from )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . invoke interface (  types . query get   recordcount )  ;   attribute attr max row = tag . get attribute ( "maxrows" )  ;   attribute attr end row = tag . get attribute ( "endrow" )  ;  if  ( attr max row  !  =  null )   {   cast int . to expr int ( attr max row . get value (  )  )  . write out ( bc  expression . mode   value )  ;  adapter . invoke static ( number   iterator load   max )  ;   }  else if  ( attr end row  !  =  null )   {   cast int . to expr int ( attr end row . get value (  )  )  . write out ( bc  expression . mode   value )  ;  adapter . invoke static ( number   iterator load   end )  ;   }  else  {  adapter . invoke static ( number   iterator load    2  )  ;   }  adapter . store local ( tag . get number iterator (  )  )  ;   attribute attr group = tag . get attribute ( "group" )  ;   attribute attr groupcs = tag . get attribute ( "groupcasesensitive" )  ;  tag . set group ( adapter . new local (  types . string )  )  ;  final int group case sensitive = adapter . new local (  types . boolean   value )  ;  if  ( attr group  !  =  null )   {  attr group . get value (  )  . write out ( bc  expression . mode   ref )  ;  adapter . store local ( tag . get group (  )  )  ;  if  ( attr groupcs  !  =  null )  attr groupcs . get value (  )  . write out ( bc  expression . mode   value )  ;  else adapter . push ( false )  ;  adapter . store local ( group case sensitive )  ;   }  adapter . load arg ( 0 )  ;  adapter . invoke virtual (  types . page   context us )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . invoke interface ( undefined add   query )  ;  final int current = adapter . new local (  types . int   value )  ;  adapter . load local ( from )  ;  adapter . push (  1  )  ;  adapter . visit insn (  opcodes . isub )  ;  adapter . store local ( current )  ;   try finally visitor tfv = new  try finally visitor ( new  on finally (  )  {  public void write out (   bytecode context bc )  {  adapter . load local ( tag . get query (  )  )  ;  adapter . load local ( start at )  ;  adapter . load local ( tag . getpid (  )  )  ;  adapter . invoke interface (  types . query  tag loop . go )  ;  adapter . pop (  )  ;  adapter . load arg ( 0 )  ;  adapter . invoke virtual (  types . page   context us )  ;  adapter . invoke interface ( undefined remove   query )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . invoke static ( number   iterator realease )  ;   }   }   null )  ;  tfv . visit try begin ( bc )  ;   while visitor wv = new  while visitor (  )  ;  if  ( tag instanceof  tag loop )   (  (  tag loop ) tag )  . set loop visitor ( wv )  ;  wv . visit before expression ( bc )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . load local ( current )  ;  adapter . push (  1  )  ;  adapter . visit insn (  opcodes . iadd )  ;  adapter . invoke virtual ( number   iterator is   valid    1  )  ;  wv . visit after expression before body ( bc )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . invoke virtual ( number   iterator current )  ;  adapter . load local ( tag . getpid (  )  )  ;  adapter . invoke interface (  types . query  tag loop . go )  ;   not visitor . visit not ( bc )  ;   label    if = new  label (  )  ;  adapter . ifz cmp (  opcodes . ifeq    if )  ;  wv . visit break ( bc )  ;  adapter . visit label (    if )  ;  if  ( attr group  !  =  null )   {  int old ni = adapter . new local ( number   iterator )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . store local ( old ni )  ;  adapter . load arg ( 0 )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . load local ( tag . get query (  )  )  ;  adapter . load local ( tag . get group (  )  )  ;  adapter . load local ( group case sensitive )  ;  adapter . invoke static ( number   iterator load    5  )  ;  adapter . store local ( tag . get number iterator (  )  )  ;  adapter . load local ( old ni )  ;  adapter . invoke virtual ( number   iterator current )  ;  adapter . store local ( current )  ;  tag . get body (  )  . write out ( bc )  ;  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . invoke static ( number   iterator realease )  ;  adapter . load local ( old ni )  ;  adapter . store local ( tag . get number iterator (  )  )  ;   }  else  {  adapter . load local ( tag . get number iterator (  )  )  ;  adapter . invoke virtual ( number   iterator current )  ;  adapter . store local ( current )  ;  tag . get body (  )  . write out ( bc )  ;   }  wv . visit after body ( bc tag . get end (  )  )  ;  tfv . visit try end ( bc )  ;  adapter . visit label ( if rec count )  ;  if  ( is output )  pbv . visit end ( bc )  ;   }  
public void   ( boolean http only )  {  this . http only = http only ;   }  
@ override public int   (  string str )  throws  page exception  {  return sct . compare to ( str )  ;   }  
@ override public void   (  config server config server  string name boolean log enabled )  {  this . config server = config server ;  this . name = name ;  this . log enabled = log enabled ;   }  
public static boolean   (  page context pc  object object )  {  if  ( object instanceof  object wrap )   {  return call ( pc  (  (  object wrap ) object )  . get embeded object ( null )  )  ;   }  return  decision . is user defined function ( object )  &&  !  decision . is closure ( object )  ;   }  
public void   (  object obj )  {  log ( new  date (  )   +  " "  +  obj )  ;   }  
@ override public  reader   (  string column name )  throws sql exception  {   string str = get string ( column name )  ;  if  ( str  =  =  null )  return null ;  return new  string reader ( str )  ;   }  
public   (  string version )  {  this . version = version ;   }  
private static  string   ( int code )  {   string message = codes . get (  string . value of ( code )  )  ;  if  ( message  =  =  null )  message = "smtp  code "  +  code ;  else message = code  +  "  -  "  +  message ;  return message ;   }  
private int   (  )  throws  naming exception   page exception  io exception   class exception  {  ldap client client = new ldap client ( server port return as binary )  ;  if  ( secure level  !  =  ldap client . secure   none )  client . set secure level ( secure level )  ;  if  ( username  !  =  null )  client . set credential ( username password )  ;  if  ( referral  >  0 )  client . set referral ( referral )  ;  if  ( action . equals ( "add" )  )   {  required ( "ldap" action "attributes" attributes )  ;  required ( "ldap" action "dn" dn )  ;  client . add ( dn attributes delimiter separator )  ;   }  else if  ( action . equals ( "delete" )  )   {  required ( "ldap" action "dn" dn )  ;  client . delete ( dn )  ;   }  else if  ( action . equals ( "modifydn" )  )   {  required ( "ldap" action "attributes" attributes )  ;  required ( "ldap" action "dn" dn )  ;  client . modifydn ( dn attributes )  ;   }  else if  ( action . equals ( "modify" )  )   {  required ( "ldap" action "attributes" attributes )  ;  required ( "ldap" action "dn" dn )  ;  client . modify ( dn modify type attributes delimiter separator )  ;   }  else if  ( action . equals ( "query" )  )   {  required ( "ldap" action "start" start )  ;  required ( "ldap" action "attributes" attributes )  ;  required ( "ldap" action "name" name )  ;   query qry = client . query ( attributes scope startrow maxrows timeout sort sort type sort direction start separator filter )  ;  page context . set variable ( name qry )  ;   }  else throw new  application exception ( "invalid value for attribute action ["  +  action  +  "]  valid values are [add delete modifydn modify query]" )  ;  return skip   body ;   }  
@ override public  catch block   (  config config )  {   catch block sct = super . get catch block ( config )  ;   string mapping = "" ;  if  (  string util . starts with ( page source . get realpath (  )  ' / ' )  )   {  mapping = page source . get mappi
public boolean   (  )  {  return size (  )   =  =  0 ;   }  
public   (  position start  position end )  {  super ( start end )  ;  set has flow controller ( true )  ;   }  
@ override public void   (  )  throws sql exception  {  query . move to current row (  )  ;   }  
public void   (  string id )  {  this . id = id ;   }  
@ override public int   (  )  {  return keys (  )  . length ;   }  
@ override public void   (  map <  string  class <  ?  >  >  map )  throws sql exception  {  conn . set type map ( map )  ;   }  
public   (  string text  font font  paint paint  composite composite  affine transform transform )  {  this . text = text ;  this . font = font ;  this . composite = composite ;  this . paint = paint ;  this . transform = transform ;   }  
public static  string   (  page context pc  string old path  string new path boolean create path )  throws  page exception  {   resource dir =  resource util . to resource not existing ( pc old path pc . get config (  )  . allow real path (  )  )  ;   directory . action rename ( pc dir new path null create path s 3  constants . acl   public   read s 3  constants . storage   unknow )  ;  return null ;   }  
public java . util .  collection   (  )  {  return map . values (  )  ;   }  
public void   ( int right border )  {  this . right border = right border ;   }  
@ override public  token stream   (  string field name  reader reader )  {  return analyzer . token stream ( field name reader )  ;   }  
@ override public void   ( boolean value )  throws io exception  {  set attribute ( attribute   archive value )  ;   }  
public int   (  )  {  return intog ;   }  
public  object   (  page context pc  collection .  key key  struct args )  throws  page exception  {   member m = component . get member ( access key false false )  ;  if  ( m  !  =  null )   {  if  ( m instanceof udf plus )  return  (  ( udf plus ) m )  . call with named values ( pc key args false )  ;  throw  component util . not function ( component key m . get value (  )  access )  ;   }  throw  component util . not function ( component key null access )  ;   }  
private void   (  )  throws  page exception  {  if  (  !  ( config instanceof  config server impl )  )  throw new  application exception ( "invalid context for this action" )  ;   config server impl cs =  (  config server impl ) config ;   string type = get string ( "admin" action "monitor type" )  ;   string name = get string ( "admin" action "name" )  ;  type = type . trim (  )  ;   monitor m ;  if  ( "request" . equals ignore case ( type )  )  m = cs . get request monitor ( name )  ;  else m = cs . get intervall monitor ( name )  ;   struct sct = new  struct impl (  )  ;  sct . setel (  key constants .    name m . get name (  )  )  ;  sct . setel (  key constants .    type m . get type (  )   =  =   monitor . type   intervall  ?  "intervall" : "request" )  ;  sct . setel ( log   enabled m . is log enabled (  )  )  ;  sct . setel ( class m . get clazz (  )  . get name (  )  )  ;  page context . set variable ( get string ( "admin" action "return variable" )  sct )  ;   }  
private void   (  data source datasource )  {     get counter ( datasource )  . minus (  1  )  ;   }  
@ override public  object   (  page context pc )  throws  page exception  {  return  operator . compare ( left . get value ( pc )  right . get value ( pc )  )   >  =  0  ?   boolean . true :  boolean . false ;   }  
@ override public void   (  resource res )  {  lock . unlock ( res )  ;   }  
public  body   (  )  {  return super . get body (  )  ;   }  
public void   (  font font )  {  this . font = font ;   }  
private void   (  collection .  key src  collection .  key trg )  {  int index = get index from key ( src )  ;  if  ( index  !  =   -  1  )   {  column names[index] = trg ;  columns[index] . set key ( trg )  ;   }   }  
@ override public boolean   (  )  {  return provider . is attributes supported (  )  ;   }  
public static boolean   (  class src  string trg )  {  if  ( src . is array (  )  )   {  return is instane of ignore case ( src . get component type (  )  trg )  ;   }  if  ( src . get name (  )  . equals ignore case ( trg )  )  return true ;  if  (    check interfaces ( src trg )  )   {  return true ;   }  src = src . get superclass (  )  ;  if  ( src  !  =  null )  return is instane of ignore case ( src trg )  ;  return false ;   }  
public  buffered image   (  buffered image src  struct parameters )  throws  page exception  {   buffered image dst =  image util . create buffered image ( src )  ;   object o ;  if  (  ( o = parameters . removeel (  key impl . init ( " iterations" )  )  )   !  =  null )  set iterations (  image filter util . to int value ( o " iterations" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " colormap" )  )  )   !  =  null )  set colormap (  image filter util . to colormap ( o " colormap" )  )  ;  if  (  ( o = parameters . removeel (  key impl . init ( " new color" )  )  )   !  =  null )  set new color (  image filter util . to colorrgb ( o " new color" )  )  ;  if  ( parameters . size (  )   >  0 )   {  throw new  function exception (  thread local page context . get (  )  " image filter"  3  "parameters" "the parameter"  +   ( parameters . size (  )   >   1   ?  "s" : "" )   +  " [" +   collection util . get key list ( parameters "  " )  +  "] " +   ( parameters . size (  )   >   1   ?  "are" : "is" )  +  " not allowed  only the following parameters are supported [ iterations   colormap   new color   black function]" )  ;   }  return filter ( src dst )  ;   }  
public void   ( boolean recurse )  {  this . recurse = recurse ;   }  
public boolean   (  )  {  return select ;   }  
protected  expression exception   (  string key )  {  return new  expression exception ( "key ["  +  key  +  "] doesn't exist in struct" )  ;   }  
public void   ( long size )  {  this . size = size ;   }  
private final boolean   (  )  {  if  ( jj    3 r    7  8  (  )  )  return true ;  if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;  do  {   token token 1  = jj   scanpos ;  if  ( jj    3 r    7  9  (  )  )   {  jj   scanpos = token 1  ;  break ;   }  if  ( jj   la  =  =  0 && jj   scanpos  =  =  jj   lastpos )  return false ;   }  while  ( true )  ;  return false ;   }  
public void   (  string sub )  {  if  ( table  =  =  null )   {  table = column ;  column = sub ;   }  else column =  ( column  +  " . "  +  sub )  ;   }  
private void   (  query cookies  string raw )  {   string[] arr =  list util . trim items (  list util . trim (  list util . list to string array ( raw ' ; ' )  )  )  ;  if  ( arr . length  =  =  0 )  return ;  int row = cookies . add row (  )  ;   string item ;  int index ;  if  ( arr . length  >  0 )   {  item = arr[0] ;  index = item . index of ( ' = ' )  ;  if  ( index  =  =   -  1  )  cookies . set atel (  key constants .    name row dec ( item )  )  ;  else  {  cookies . set atel (  key constants .    name row dec ( item . substring ( 0 index )  )  )  ;  cookies . set atel (  key constants .    value row dec ( item . substring ( index  +   1  )  )  )  ;   }   }   string n  v ;  cookies . set atel ( "secure" row  boolean . false )  ;  cookies . set atel ( "http only" row  boolean . false )  ;  for  ( int i =  1  ;  i  <  arr . length ;  i +  +  )   {  item = arr[i] ;  index = item . index of ( ' = ' )  ;  if  ( index  =  =   -  1  )  cookies . set atel ( dec ( item )  row  boolean . true )  ;  else  {  n = dec ( item . substring ( 0 index )  )  ;  v = dec ( item . substring ( index  +   1  )  )  ;  if  ( n . equals ignore case ( "expires" )  )   {   date time d =  caster . to date ( v false null null )  ;  if  ( d  !  =  null )   {  cookies . set atel ( n row d )  ;  continue ;   }   }  cookies . set atel ( n row v )  ;   }   }   }  
public void   ( long bitrate tolerance )  {  this . video bitrate tolerance = bitrate tolerance ;   }  
@ override public  iterator <  string >    (  )  {  return null ;   }  
protected void   ( int x int y float[] out )  {  float dx = x  -  icentrex ;  float dy = y  -  icentrey ;  float theta =  ( float )  math . atan 2  (  - dy  - dx )   +  angle ;  float r =  ( float )  math . sqrt ( dx * dx  +  dy * dy )  ;  theta =  image math . mod ( theta  2  *  ( float )  math . pi )  ;  out[0] = i width * theta  /   ( spread angle  +  0 . 0000 1 f )  ;  out[ 1 ] = i height *  (  1   -   ( r  -  radius )   /   ( height  +  0 . 0000 1 f )  )  ;   }  
public  string   (  )  {  return host ;   }  
@ override public int   (  )  throws  page exception  {  try  {  page context . forward ( template )  ;   }  catch  (   exception e )   {  throw  caster . to page exception ( e )  ;   }  return skip   body ;   }  
 string   (  )  {  return secret access key ;   }  
private static  object   (  query column impl column  object value )  {  if  (  decision . is castable to binary ( value false )  )  return value ;  reset type ( column )  ;  return value ;   }  
private static void   (  page context pc udf udf  object[] args  executor service es  list <  future <  string >  >  futures )  throws  page exception  {  if  ( es  =  =  null )   {  udf . call ( pc args true )  ;  return ;   }  futures . add ( es . submit ( new udf caller ( pc udf args true )  )  )  ;   }  
private amf message   (  http servlet servlet  http servlet request req  http servlet response rsp amf message message )  {  amf message response message = new amf message (  )  ;  for  (  iterator bodies = message . get bodies (  )  ;  bodies . has next (  )  ;   )   {  amf body request body =  ( amf body ) bodies . next (  )  ;   object service result = invoke body ( servlet req rsp request body )  ;   string target = get target ( request body service result )  ;  amf body response body = new amf body ( target "null" service result )  ;  response message . add body ( response body )  ;   }  return response message ;   }  
public  point 2 d   (  point 2 d src pt  point 2 d dst pt )  {  if  ( dst pt  =  =  null )  dst pt = new  point 2 d .  double (  )  ;  dst pt . set location ( src pt . getx (  )  src pt . gety (  )  )  ;  return dst pt ;   }  
public   (  component impl component  property prop )  {  super ( component "has"  +   string util . uc first (  property factory . get singular name ( prop )  )  get function argument ( prop )  cf types . type   boolean "wddx" )  ;  this . prop = prop ;  this . prop name =  key impl . get instance ( prop . get name (  )  )  ;   }  
private  tag lib   (  config config  resource file tag lib  string name space  string name space separator cfml string cfml )  throws  template exception  {   string ext =  resource util . get extension ( file tag lib null )  ;  if  ( "jar" . equals ignore case ( ext )  )   {   resource new file tag lib =  resource util . change extension ( file tag lib "tld" )  ;  if  ( new file tag lib . exists (  )  )  file tag lib = new file tag lib ;  else  {   resource tmp = gettld from jar as file ( config file tag lib )  ;  if  ( tmp  !  =  null )  file tag lib = tmp ;   }   }  try  {   tag lib taglib =  tag lib factory . load from file ( file tag lib )  ;  taglib . set name space ( name space )  ;  taglib . set name space seperator ( name space separator )  ;  return taglib ;   }  catch  (   tag lib exception e )   {  throw new  template exception ( cfml e . get message (  )  )  ;   }   }  
protected  entry < k v >    (  )  {  if  ( mod count  !  =  expected mod count )  throw new  concurrent modification exception (  )  ;  if  ( next key  =  =  null &&  ! has next (  )  )  throw new  no such element exception (  )  ;  last returned = entry ;  entry = entry . next ;  current key = next key ;  next key = null ;  return last returned ;   }  
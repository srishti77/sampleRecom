override public object ( key key comma object value ) throws  page exception { return  set el ( key comma value ) ; }
public ( context context ) {  m context = context ; reset ( ) ; }
override public  iq handler info ( ) { return info ; }
public void ( final  h account account ) { this . account = account ; }
public string ( ) { return this .  user phone .  get text ( ) ; }
private void (  job conf job comma  file system  file system comma int  num mappers comma int  num reducers comma int  num lines comma boolean  is uber ) throws exception {  file system . delete ( output comma true ) ; job .  set job name (  " test " ) ;  job client client = new  job client ( job ) ;  running job  submitted job = null ;  file input format .  set input paths ( job comma  input dir ) ;  file output format .  set output path ( job comma output ) ; job . set (  " mapreduce . output . textoutputformat . separator " comma  " " ) ; job .  set input format (  text input format . class ) ; job .  set map output key class ( text . class ) ; job .  set map output value class ( text . class ) ; job .  set output key class ( text . class ) ; job .  set output value class ( text . class ) ; job .  set mapper class (  my mapper . class ) ; job .  set partitioner class (  my partitioner . class ) ; job .  set output format (  text output format . class ) ; job .  set num reduce tasks (  num reducers ) ; job .  set int (  " mapreduce . map . maxattempts " comma 1 ) ; job .  set int (  " mapreduce . reduce . maxattempts " comma 1 ) ; job .  set int (  " mapred . test . num lines " comma  num lines ) ; if (  is uber ) { job .  set boolean (  " mapreduce . job . ubertask . enable " comma true ) ; } job .  set boolean (  mr job config .  mr encrypted intermediate data comma true ) ; try {  submitted job = client .  submit job ( job ) ; try { if ( ! client .  monitor and print job ( job comma  submitted job ) ) { throw new  io exception (  " job failed !" ) ; } } catch (  interrupted exception ie ) { thread .  current thread ( ) . interrupt ( ) ; } } catch (  io exception ioe ) { system . err . println (  " job failed with : " + ioe ) ; } finally {  verify output (  submitted job comma  file system comma  num mappers comma  num lines ) ; } }
private void ( account account comma boolean incoming ) { controller .  handle authentication failure ( account comma incoming ) ; }
public  step data interface ( ) { return  step data interface ; }
protected void ( repository rep comma  object id  id transformation comma  object id  id step comma int i comma string  file name ) throws  kettle exception { rep .  save step attribute (  id transformation comma  id step comma i comma  " file name " comma  file name ) ; }
private static void ( string pid comma boolean  is process group comma long  sleeptime before sigkill comma boolean  in background ) { if (  in background ) {  sig kill thread  sig kill thread = new  sig kill thread ( pid comma  is process group comma  sleeptime before sigkill ) ;  sig kill thread .  set daemon ( true ) ;  sig kill thread . start ( ) ; } else {  sig kill in current thread ( pid comma  is process group comma  sleeptime before sigkill ) ; } }
override public void ( view view ) { if ( view instanceof  merge view ) this . view = (  merge view ) view ; }
public int ( int channel ) { return  max value [ channel ] ; }
boolean (  media router .  route info route ) { return  m volume control enabled && route .  get volume handling ( ) ==  media router .  route info .  playback volume variable ; }
override public void (  data input in ) throws  io exception {  e tag = in .  read utf ( ) ; }
public boolean ( ) { return  prevent default ; }
test public void ( ) { iterator <  tree range > ranges ; ranges = mts . invalids ( ) ;  assert equals ( new range < > ( tok ( - 1 ) comma tok ( - 1 ) ) comma ranges . next ( ) ) ;  assert false ( ranges .  has next ( ) ) ; mts . split ( tok ( 4 ) ) ; mts . split ( tok ( 2 ) ) ; mts . split ( tok ( 6 ) ) ; mts . split ( tok ( 3 ) ) ; mts . split ( tok ( 5 ) ) ; ranges = mts . invalids ( ) ;  assert equals ( new range < > ( tok ( 6 ) comma tok ( - 1 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( - 1 ) comma tok ( 2 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( 2 ) comma tok ( 3 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( 3 ) comma tok ( 4 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( 4 ) comma tok ( 5 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( 5 ) comma tok ( 6 ) ) comma ranges . next ( ) ) ;  assert equals ( new range < > ( tok ( 6 ) comma tok ( - 1 ) ) comma ranges . next ( ) ) ;  assert false ( ranges .  has next ( ) ) ; }
test public void ( ) { when (  submission context .  get keep containers across application attempts ( ) ) .  then return ( true ) ; when ( application .  get max app attempts ( ) ) .  then return ( 2 ) ; when ( application .  get num failed app attempts ( ) ) .  then return ( 1 ) ; container  am container =  allocate application attempt ( ) ;  launch application attempt (  am container ) ;  run application attempt (  am container comma  " host " comma 8042 comma  " oldtrackingurl " comma false ) ;  container status cs1 =  container status .  new instance (  am container .  get id ( ) comma  container state . complete comma  " some error " comma 123 ) ;  application attempt id  app attempt id =  application attempt .  get app attempt id ( ) ;  node id  any node id =  node id .  new instance (  " host " comma 1234 ) ;  application attempt . handle ( new  rm app attempt container finished event (  app attempt id comma cs1 comma  any node id ) ) ;  assert equals (  yarn application attempt state . running comma  application attempt .  create application attempt state ( ) ) ;  send attempt update saved event (  application attempt ) ;  assert equals (  rm app attempt state . failed comma  application attempt .  get app attempt state ( ) ) ;  assert true (  transfer state from previous attempt ) ;  verify application attempt finished (  rm app attempt state . failed ) ;  assert equals ( 0 comma  application attempt .  get just finished containers ( ) . size ( ) ) ;  container status cs2 =  container status .  new instance (  container id .  new container id (  app attempt id comma 2 ) comma  container state . complete comma "" comma 0 ) ;  application attempt . handle ( new  rm app attempt container finished event (  app attempt id comma cs2 comma  any node id ) ) ;  assert equals ( 1 comma  application attempt .  get just finished containers ( ) . size ( ) ) ; boolean found = false ; for (  container status  container status :  application attempt .  get just finished containers ( ) ) { if ( cs2 .  get container id ( ) . equals (  container status .  get container id ( ) ) ) { found = true ; } }  assert true ( found ) ; }
public  message resources (  page context  page context comma string bundle comma boolean  check page scope ) throws  jsp exception {  message resources resources = null ; if ( bundle == null ) { bundle = globals .  messages key ; } if (  check page scope ) { resources = (  message resources )  page context .  get attribute ( bundle comma  page context .  page scope ) ; } if ( resources == null ) { resources = (  message resources )  page context .  get attribute ( bundle comma  page context .  request scope ) ; } if ( resources == null ) {  module config  module config =  get module config (  page context ) ; resources = (  message resources )  page context .  get attribute ( bundle +  module config .  get prefix ( ) comma  page context .  application scope ) ; } if ( resources == null ) { resources = (  message resources )  page context .  get attribute ( bundle comma  page context .  application scope ) ; } if ( resources == null ) {  jsp exception e = new  jsp exception ( messages .  get message (  " message . bundle " comma bundle ) ) ;  save exception (  page context comma e ) ; throw e ; } return resources ; }
public void ( list <  value meta interface >  rule result columns ) { this .  rule result columns =  rule result columns ; }
public void ( string state ) { this . state = state ; }
test public void (  test context  context vertx ) {  context vertx .  assert not null ( new object ( ) ) ; }
override public  dlna thumbnail input stream ( ) throws  io exception { file  cached thumbnail = null ; file  thumb folder = null ; boolean  alternative check = false ; while (  cached thumbnail == null ) { if (  thumb folder == null ) {  thumb folder = file .  get parent file ( ) ; }  cached thumbnail =  file util .  replace extension (  thumb folder comma file comma  " jpg " comma true comma true ) ; if (  cached thumbnail == null ) {  cached thumbnail =  file util .  replace extension (  thumb folder comma file comma  " png " comma true comma true ) ; } if (  cached thumbnail == null ) {  cached thumbnail =  file util .  get file name with added extension (  thumb folder comma file comma  ". cover . jpg " ) ; } if (  cached thumbnail == null ) {  cached thumbnail =  file util .  get file name with added extension (  thumb folder comma file comma  ". cover . png " ) ; } if (  alternative check ) { break ; } if (  string utils .  is not blank ( configuration .  get alternate thumb folder ( ) ) ) {  thumb folder = new file ( configuration .  get alternate thumb folder ( ) ) ; if ( !  thumb folder .  is directory ( ) ) {  thumb folder = null ; break ; } }  alternative check = true ; } if (  cached thumbnail != null ) { return  dlna thumbnail input stream .  to thumbnail input stream ( new  file input stream (  cached thumbnail ) ) ; } else if (  get media ( ) != null &&  get media ( ) .  get thumb ( ) != null ) { return  get media ( ) .  get thumbnail input stream ( ) ; } else { return  get generic thumbnail input stream ( null ) ; } }
public  eviction configuration builder (  eviction thread policy policy ) { attributes . attribute (  thread policy ) . set ( policy ) ; return this ; }
public void ( string text ) {  f doc = text .  to lower case ( ) ;  f pos = 0 ;  f end =  f doc . length ( ) - 1 ; }
private list <  row meta and data > ( ) { list <  row meta and data > list = new  array list <  row meta and data > ( ) ;  row meta interface rm =  create reducer row meta interface ( ) ; object [ ] r1 = new object [ ] {  " a " comma long .  value of ( 100 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; r1 = new object [ ] {  " a " comma long .  value of ( 200 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; r1 = new object [ ] {  " b " comma long .  value of ( 300 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; r1 = new object [ ] {  " c " comma long .  value of ( 400 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; r1 = new object [ ] {  " c " comma long .  value of ( 500 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; r1 = new object [ ] {  " d " comma long .  value of ( 600 ) } ; list . add ( new  row meta and data ( rm comma r1 ) ) ; return list ; }
private  category dataset ( ) { final  default category dataset dataset = new  default category dataset ( ) ; iterator <  chart series bean > it =  series . iterator ( ) ; iterator itt ; list datas ;  chart series bean csb ;  chart data bean cdb ; int count = 0 ; smallest = double .  max value ; biggest = double .  min value ; string label ; boolean  has labels = false ; while ( it .  has next ( ) ) { count ++ ; csb = it . next ( ) ; label = csb .  get series label ( ) ; if (  string util .  is empty ( label ) ) label = "" + count ; else  has labels = true ; datas = csb .  get datas ( ) ; if ( sortxaxis ) collections . sort ( datas ) ; itt = datas . iterator ( ) ; while ( itt .  has next ( ) ) { cdb = (  chart data bean ) itt . next ( ) ; if ( smallest > cdb .  get value ( ) ) smallest = cdb .  get value ( ) ; if ( biggest < cdb .  get value ( ) ) biggest = cdb .  get value ( ) ; dataset .  add value ( cdb .  get value ( ) comma label comma cdb .  get item as string ( ) ) ; } } if ( !  has labels ) showlegend = false ; return dataset ; }
public (  web dav store  n store comma string name ) { super ( ) ; store =  n store ; this .  m name = name ;  build folder url ( ) ; }
public void ( date released ) { this . released = released ; }
protected  char sequence ( final  web socket settings  web socket settings ) { return  web socket settings .  get filter prefix ( ) ; }
public ( string name ) { this . name = name ; }
test public void ( ) {  network offering offering = mock (  network offering . class ) ; when ( offering .  get id ( ) ) .  then return (  42 l ) ; when ( offering .  get traffic type ( ) ) .  then return (  traffic type . guest ) ; when ( offering .  get guest type ( ) ) .  then return (  guest type . isolated ) ;  physical network vo physnet = mock (  physical network vo . class ) ; when ( physnet .  get isolation methods ( ) ) .  then return ( arrays .  as list ( new string [ ] {  " vxlan " } ) ) ; when ( physnet .  get id ( ) ) .  then return (  42 l ) ;  assert true ( guru .  can handle ( offering comma  network type . advanced comma physnet ) == true ) ; when ( offering .  get traffic type ( ) ) .  then return (  traffic type . management ) ;  assert false ( guru .  can handle ( offering comma  network type . advanced comma physnet ) == true ) ; when ( offering .  get traffic type ( ) ) .  then return (  traffic type . guest ) ; when ( offering .  get guest type ( ) ) .  then return (  guest type . shared ) ;  assert false ( guru .  can handle ( offering comma  network type . advanced comma physnet ) == true ) ; when ( offering .  get guest type ( ) ) .  then return (  guest type . isolated ) ;  assert false ( guru .  can handle ( offering comma  network type . basic comma physnet ) == true ) ; when ( physnet .  get isolation methods ( ) ) .  then return ( arrays .  as list ( new string [ ] {  " vlan " } ) ) ;  assert false ( guru .  can handle ( offering comma  network type . advanced comma physnet ) == true ) ; }
public void ( boolean value ) {  isset bitfield =  encoding utils .  set bit (  isset bitfield comma  timestamp isset id comma value ) ; }
public boolean ( ) { return  add time ; }
private static boolean (  modifiers tree modifiers ) { return  modifiers utils .  has modifier ( modifiers comma modifier . public ) ; }
private string ( integer nanos ) { string nan = nanoseconds . format ( nanos ) ; return nan . substring ( 0 comma  end nanosecond pattern position -  start nanosecond pattern position + 1 ) ; }
before public void ( ) {  file util .  fully delete (  test dir ) ;  test dir . mkdirs ( ) ; conf = new configuration ( ) ; conf .  set boolean (  jh admin config .  mr hs recovery enable comma true ) ; conf .  set class (  jh admin config .  mr hs state store comma  history server file system state store service . class comma  history server state store service . class ) ; conf . set (  jh admin config .  mr hs fs state store uri comma  test dir .  get absolute file ( ) .  to uri ( ) .  to string ( ) ) ; }
protected int ( ) {  io util .  assert input is valid ( input ) ;  io util .  assert file is writable ( output ) ; final  sam reader in =  sam reader factory .  make default ( ) .  reference sequence (  reference sequence ) . open (  sam input resource . of ( input ) ) ; final  sam read group record rg = new  sam read group record ( rgid ) ; rg .  set library ( rglb ) ; rg .  set platform ( rgpl ) ; rg .  set sample ( rgsm ) ; rg .  set platform unit ( rgpu ) ; if ( rgcn != null ) rg .  set sequencing center ( rgcn ) ; if ( rgds != null ) rg .  set description ( rgds ) ; if ( rgdt != null ) rg .  set run date ( rgdt ) ; if ( rgpi != null ) rg .  set predicted median insert size ( rgpi ) ; if ( rgpg != null ) rg .  set program group ( rgpg ) ; if ( rgpm != null ) rg .  set platform model ( rgpm ) ; if ( rgks != null ) rg .  set key sequence ( rgks ) ; if ( rgfo != null ) rg .  set flow order ( rgfo ) ; log . info ( string . format (  " created read - group id =% s pl =% s lb =% s sm =% s % n " comma rg .  get id ( ) comma rg .  get platform ( ) comma rg .  get library ( ) comma rg .  get sample ( ) ) ) ; final  sam file header  in header = in .  get file header ( ) ; final  sam file header  out header =  in header . clone ( ) ;  out header .  set read groups ( collections .  singleton list ( rg ) ) ; if (  sort order != null )  out header .  set sort order (  sort order ) ; final  sam file writer  out writer = new  sam file writer factory ( ) .  make sam or bam writer (  out header comma  out header .  get sort order ( ) ==  in header .  get sort order ( ) comma output ) ; final  progress logger progress = new  progress logger ( log ) ; for ( final  sam record read : in ) { read .  set attribute (  sam tag . rg . name ( ) comma rgid ) ;  out writer .  add alignment ( read ) ; progress . record ( read ) ; }  closer util . close ( in ) ;  out writer . close ( ) ; return 0 ; }
override public void ( list <  scheduling request >  scheduling requests ) { if (  scheduling requests == null ) { builder .  clear scheduling requests ( ) ; return ; }  init scheduling requests ( ) ; this .  scheduling requests . clear ( ) ; this .  scheduling requests .  add all (  scheduling requests ) ; }
override public byte [ ] ( ) { return  get key ( ) .  get routing key ( ) ; }
public void (  count down latch  done signal ) { this .  done signal =  done signal ; }
override public boolean ( int direction ) { if (  m adapter == null ) { return false ; } final int width =  get client width ( ) ; final int  scroll x =  get scroll x ( ) ; if ( direction < 0 ) { return (  scroll x > ( int ) ( width *  m first offset ) ) ; } else if ( direction > 0 ) { return (  scroll x < ( int ) ( width *  m last offset ) ) ; } else { return false ; } }
test public void ( ) { maybe . just ( 1 ) .  delay subscription ( 100 comma  time unit . milliseconds ) . test ( ) .  await done ( 5 comma  time unit . seconds ) .  assert result ( 1 ) ; }
override public  byte buf ( int index comma int value ) {  check index0 ( index comma 4 ) ; unwrap ( ) .  set int ( idx ( index ) comma value ) ; return this ; }
private void ( java . io .  object output stream s ) throws java . io .  io exception { s .  default write object ( ) ; for ( node < e > p = first ( ) ; p != null ; p = succ ( p ) ) { e item = p . item ; if ( item != null ) s .  write object ( item ) ; } s .  write object ( null ) ; }
public  transport flags ( string  site name ) { this .  site name =  site name ; return this ; }
public ( string password ) {  message digest digest = null ; try { digest =  message digest .  get instance (  " sha1 " ) ; digest . update ( password .  get bytes (  charset util . utf8 ) ) ; } catch ( exception e ) {  exception handler .  print stack trace ( e ) ; }  m bfish = new  blowfish cbc ( digest . digest ( ) comma  0 l ) ; digest . reset ( ) ; }
public  annotated type < x > ( ) { map < constructor < ? > comma map < integer comma  annotation store >>  constructor parameter annnotations = new  hash map < constructor < ? > comma map < integer comma  annotation store >> ( ) ; map < constructor < ? > comma  annotation store >  constructor annotations = new  hash map < constructor < ? > comma  annotation store > ( ) ; map < method comma map < integer comma  annotation store >>  method parameter annnotations = new  hash map < method comma map < integer comma  annotation store >> ( ) ; map < method comma  annotation store >  method annotations = new  hash map < method comma  annotation store > ( ) ; map < field comma  annotation store >  field annotations = new  hash map < field comma  annotation store > ( ) ; for ( entry < field comma  annotation builder > field : fields .  entry set ( ) ) {  field annotations . put ( field .  get key ( ) comma field .  get value ( ) . create ( ) ) ; } for ( entry < method comma  annotation builder > method : methods .  entry set ( ) ) {  method annotations . put ( method .  get key ( ) comma method .  get value ( ) . create ( ) ) ; } for ( entry < method comma map < integer comma  annotation builder >> parameters :  method parameters .  entry set ( ) ) { map < integer comma  annotation store >  parameter annotations = new  hash map < integer comma  annotation store > ( ) ;  method parameter annnotations . put ( parameters .  get key ( ) comma  parameter annotations ) ; for ( entry < integer comma  annotation builder > parameter : parameters .  get value ( ) .  entry set ( ) ) {  parameter annotations . put ( parameter .  get key ( ) comma parameter .  get value ( ) . create ( ) ) ; } } for ( entry < constructor < ? > comma  annotation builder > constructor : constructors .  entry set ( ) ) {  constructor annotations . put ( constructor .  get key ( ) comma constructor .  get value ( ) . create ( ) ) ; } for ( entry < constructor < ? > comma map < integer comma  annotation builder >> parameters :  constructor parameters .  entry set ( ) ) { map < integer comma  annotation store >  parameter annotations = new  hash map < integer comma  annotation store > ( ) ;  constructor parameter annnotations . put ( parameters .  get key ( ) comma  parameter annotations ) ; for ( entry < integer comma  annotation builder > parameter : parameters .  get value ( ) .  entry set ( ) ) {  parameter annotations . put ( parameter .  get key ( ) comma parameter .  get value ( ) . create ( ) ) ; } } return new  annotated type impl < x > (  java class comma  type annotations . create ( ) comma  field annotations comma  method annotations comma  method parameter annnotations comma  constructor annotations comma  constructor parameter annnotations comma  field types comma  method parameter types comma  constructor parameter types ) ; }
public boolean ( ) { return true ; }
public final void ( final string  cache key ) { this .  cache key =  cache key ; }
protected void ( ) { long  start time = system .  current time millis ( ) ; log . warn (  " starting init () phase " ) ; keys . clear ( ) ; for ( int i = 0 ; i <  max overall keys ; i ++ ) { object key ; do { key = generator .  create random key ( ) ; } while ( keys . contains ( key ) ) ; if ( i % 10 == 0 ) { log . trace (  " generated " + i +  " keys " ) ; } keys . add ( key ) ; } system . gc ( ) ; long duration = system .  current time millis ( ) -  start time ; log . warn (  " finished init () phase . " +  print duration ( duration ) ) ; }
private void ( ) throws  file not found exception { string  doc name =  " string resource en us . xml " ; file file = new file (  test dir comma "/" +  doc name ) ; resource doc = reader .  extract template ( file comma  locale id .  en us comma  doc name comma  validation type . xsd .  to string ( ) ) ; doc .  set name (  generated doc name ) ;  xliff writer . write ( new file (  generate dir ) comma doc comma  " en - us " ) ; }
public boolean ( ) { return  lease freed ; }
test public void ( ) throws  io exception {  write file ( fc comma file1 comma  file len ) ;  write file ( fc comma file2 comma  file len ) ;  write file ( fc comma file3 comma  file len ) ; path dir4 = new path (  test dir comma  " dir4 " ) ; path dir5 = new path ( dir4 comma  " dir5 " ) ; path file4 = new path ( dir4 comma  " file4 " ) ; fc .  create symlink ( dir1 comma dir5 comma true ) ; fc .  create symlink ( file1 comma file4 comma true ) ;  remote iterator <  located file status > itor = fc . util ( ) .  list files ( dir4 comma true ) ;  located file status stat = itor . next ( ) ;  assert true ( stat .  is file ( ) ) ;  assert equals ( fc .  make qualified ( file2 ) comma stat .  get path ( ) ) ; stat = itor . next ( ) ;  assert true ( stat .  is file ( ) ) ;  assert equals ( fc .  make qualified ( file3 ) comma stat .  get path ( ) ) ; stat = itor . next ( ) ;  assert true ( stat .  is file ( ) ) ;  assert equals ( fc .  make qualified ( file1 ) comma stat .  get path ( ) ) ;  assert false ( itor .  has next ( ) ) ; itor = fc . util ( ) .  list files ( dir4 comma false ) ; stat = itor . next ( ) ;  assert true ( stat .  is file ( ) ) ;  assert equals ( fc .  make qualified ( file1 ) comma stat .  get path ( ) ) ;  assert false ( itor .  has next ( ) ) ; }
public (  observable source < t > source comma predicate < ? super t > predicate ) { super ( source ) ; this . predicate = predicate ; }
(  cyclic barrier barrier comma  remote cache < integer comma string > remote comma double  get ratio ) { this . barrier = barrier ; this . remote = remote ; this .  get ratio =  get ratio ; }
protected final void ( v value ) { result = value ; }
private  d tree [ ] ( frame fr comma int mtrys comma float  sample rate comma random rand comma int tid ) { final  d tree [ ] ktrees = new  d tree [  nclass ] ;  d histogram hcs [ ] [ ] [ ] = new  d histogram [  nclass ] [ 1 ] [  ncols ] ; int  adj nbins = math . max ( ( 1 << ( 10 - 0 ) ) comma nbins ) ; long rseed = rand .  next long ( ) ; for ( int k = 0 ; k <  nclass ; k ++ ) { assert (  distribution != null && classification ) || (  distribution == null && ! classification ) ; if (  distribution == null ||  distribution [ k ] != 0 ) { ktrees [ k ] = new  drf tree ( fr comma  ncols comma ( char ) nbins comma ( char )  nclass comma  min rows comma mtrys comma rseed ) ; boolean  is binom = classification ; new  drf undecided node ( ktrees [ k ] comma - 1 comma  d histogram .  initial hist ( fr comma  ncols comma  adj nbins comma hcs [ k ] [ 0 ] comma  min rows comma  do grpsplit comma  is binom ) ) ; } } timer  t 1 = new timer ( ) ; sample ss [ ] = new sample [  nclass ] ; for ( int k = 0 ; k <  nclass ; k ++ ) if ( ktrees [ k ] != null ) ss [ k ] = new sample ( (  drf tree ) ktrees [ k ] comma  sample rate ) . dfork ( 0 comma new frame (  vec nids ( fr comma k ) comma  vec resp ( fr comma k ) ) comma  build tree one node ) ; for ( int k = 0 ; k <  nclass ; k ++ ) if ( ss [ k ] != null ) ss [ k ] .  get result ( ) ; log . debug ( sys . drf comma  " sampling took : + " +  t 1 ) ; int [ ] leafs = new int [  nclass ] ; timer  t 2 = new timer ( ) ; int depth = 0 ; for ( ; depth <  max depth ; depth ++ ) { if ( ! job .  is running ( self ( ) ) ) return null ; hcs =  build layer ( fr comma ktrees comma leafs comma hcs comma true comma  build tree one node ) ; if ( hcs == null ) break ; } log . debug ( sys . drf comma  " tree build took : " +  t 2 ) ; timer  t 3 = new timer ( ) ; for ( int k = 0 ; k <  nclass ; k ++ ) {  d tree tree = ktrees [ k ] ; if ( tree == null ) continue ; int leaf = leafs [ k ] = tree . len ( ) ; for ( int nid = 0 ; nid < leaf ; nid ++ ) { if ( tree . node ( nid ) instanceof  decided node ) {  decided node dn = tree . decided ( nid ) ; for ( int i = 0 ; i < dn .  nids . length ; i ++ ) { int cnid = dn .  nids [ i ] ; if ( cnid == - 1 || tree . node ( cnid ) instanceof  undecided node || ( tree . node ( cnid ) instanceof  decided node && ( (  decided node ) tree . node ( cnid ) ) .  split . col ( ) == - 1 ) ) {  leaf node ln = new  drf leaf node ( tree comma nid ) ; ln .  pred = dn . pred ( i ) ; dn .  nids [ i ] = ln . nid ( ) ; } } if ( nid == 0 && dn .  split . col ( ) == - 1 ) new  drf leaf node ( tree comma - 1 comma 0 ) ; } } } log . debug ( sys . drf comma  " nodes propagation : " +  t 3 ) ; timer  t 4 = new timer ( ) ;  collect preds cp = new  collect preds ( ktrees comma leafs ) .  do all ( fr comma  build tree one node ) ; if ( importance ) { if ( classification )  as votes (  tree measures on oob ) . append ( cp .  right votes comma cp .  all rows ) ; else  as sse (  tree measures on oob ) . append ( cp . sse comma cp .  all rows ) ; } log . debug ( sys . drf comma  " collect preds done : " +  t 4 ) ; for ( int i = 0 ; i < ktrees . length ; i ++ ) if ( ktrees [ i ] != null ) ktrees [ i ] . leaves = ktrees [ i ] . len ( ) - leafs [ i ] ; return ktrees ; }
override public void ( ) { super .  on resume ( ) ;  m collected events . add ( new pair < > (  owner callback comma lifecycle . event .  on resume ) ) ; }
( int start comma int end ) { super ( start comma end ) ; }
public ( final  http request expected ) { this . expected = expected ; }
public (  observable source < t > source comma predicate < ? super t > predicate ) { super ( source ) ; this . predicate = predicate ; }
bean public  event dao ( ) { return mockito . mock (  event dao . class ) ; }
private static  comments counter ( file  base dir comma string filename ) {  comments counter counter = new  comments counter ( ) ; try { int  line number = 1 ; for ( string line : files .  read lines ( new file (  base dir comma filename ) comma  standard charsets .  utf 8 ) ) { int  comment count =  string utils .  count matches ( line comma  " comment " ) ; for ( int i = 0 ; i <  comment count ; i ++ ) { counter .  commented lines . add (  line number ) ; } counter .  number comments +=  comment count ; int  fixme count =  string utils .  count matches ( line comma  " fixme " ) ; for ( int i = 0 ; i <  fixme count ; i ++ ) { counter .  cases not covered lines . add (  line number ) ; } counter .  number fixme +=  fixme count ;  line number ++ ; } } catch (  io exception e ) { fail . fail ( e .  get message ( ) ) ; } return counter ; }
protected string ( ) { return this .  xcontext provider . get ( ) .  get user ( ) ; }
override public boolean ( ) { return  column conditions .  is empty ( ) &&  static conditions .  is empty ( ) ; }
override public void ( string property comma map < string comma object > params ) { if ( property .  equals ignore case (  http bind enabled ) ) {  do enable http bind ( boolean .  value of ( params . get (  " value " ) .  to string ( ) ) ) ; } else if ( property .  equals ignore case (  http bind port ) ) { try { integer .  value of ( params . get (  " value " ) .  to string ( ) ) ; } catch (  number format exception ne ) {  jive globals .  delete property (  http bind port ) ; return ; }  restart server ( ) ; } else if ( property .  equals ignore case (  http bind secure port ) ) { try { integer .  value of ( params . get (  " value " ) .  to string ( ) ) ; } catch (  number format exception ne ) {  jive globals .  delete property (  http bind secure port ) ; return ; }  restart server ( ) ; } else if (  http bind auth per clientcert policy .  equals ignore case ( property ) ) {  restart server ( ) ; } }
public subject ( ) throws  login exception { return authenticate (  unprivileged role comma  unprivileged passwd ) ; }
public void ( ) {  restart server option . click ( ) ;  update button . click ( ) ; }
override public void ( ) { get . cancel ( core .  client context ) ; }
private void ( string site ) { map all = new  hash map ( ) ; string key = key ( site ) ; string val = val ( site ) ; for ( int i = 0 ; i < 10 ; i ++ ) { all . put ( key + i comma val + i ) ; } cache ( site comma 0 ) .  put all ( all ) ; for ( int i = 0 ; i < 10 ; i ++ ) {  assert equals ( backup ( site ) . get ( key + i ) comma val + i ) ; } }
override public void ( ) { ( (  web render ) renderer ) . push (  " control " comma  " stop " ) ; }
public void ( float s ) { this . salary = s ; }
private void ( final  recurrence id  recurrence id comma final  resource skyline  resource skyline ) throws  skyline store exception { final list <  resource skyline >  resource skylines = new  array list < > ( ) ;  resource skylines . add (  resource skyline ) ;  skyline store .  add history (  recurrence id comma  resource skylines ) ; final list <  resource skyline >  resource skylines get =  skyline store .  get history (  recurrence id ) . get (  recurrence id ) ; assert .  assert true (  resource skylines get . contains (  resource skyline ) ) ; }
suppress warnings (  " unchecked " ) test public void ( ) {  test subscriber < integer > ts = flowable . range ( 0 comma 2 ) . parallel ( 1 ) . filter ( new predicate < integer > ( ) { override public boolean test ( integer v ) throws exception { return 1 / v > 0 ; } } comma new  bi function < long comma throwable comma  parallel failure handling > ( ) { override public  parallel failure handling apply ( long n comma throwable e ) throws exception { throw new  test exception ( ) ; } } ) . sequential ( ) . test ( ) .  assert failure (  composite exception . class ) ;  test helper .  assert composite exceptions ( ts comma  arithmetic exception . class comma  test exception . class ) ; }
long ( ) { return system .  current time millis ( ) -  created time ; }
static string ( configuration c ) {  byte array output stream buffer = new  byte array output stream ( ) ; try {  print writer pw = new  print writer ( buffer comma false ) ;  properties configuration tmp = new  properties configuration ( ) ; tmp . copy ( c ) ; tmp . write ( pw ) ; return buffer .  to string (  " utf - 8 " ) ; } catch ( exception e ) { throw new  metrics config exception ( e ) ; } }
override  web result (  http servlet request request comma  http servlet response response comma boolean  use xml ) throws  kettle exception comma  io exception {  file object  temp file =  kettle vfs .  create temp file (  " export " comma  ". zip " comma system .  get property (  " java . io . tmpdir " ) ) ;  output stream out =  kettle vfs .  get output stream (  temp file comma false ) ;  io utils . copy ( request .  get input stream ( ) comma out ) ; out . flush ( ) ;  io utils .  close quietly ( out ) ; string  archive url =  temp file .  get name ( ) .  to string ( ) ; string load = request .  get parameter (  parameter load ) ; if ( ! utils .  is empty ( load ) ) { string  file url =  message format . format (  zip cont comma  archive url comma load ) ; boolean  is job =  type job .  equals ignore case ( request .  get parameter (  parameter type ) ) ; string  result id ; if (  is job ) { node node =  get config node from zip (  archive url comma job .  configuration in export filename comma  job execution configuration .  xml tag ) ;  job execution configuration  job execution configuration = new  job execution configuration ( node ) ;  job meta  job meta = new  job meta (  file url comma  job execution configuration .  get repository ( ) ) ;  job configuration  job configuration = new  job configuration (  job meta comma  job execution configuration ) ; job job =  create job (  job configuration ) ;  result id = job .  get container object id ( ) ; } else { node node =  get config node from zip (  archive url comma trans .  configuration in export filename comma  trans execution configuration .  xml tag ) ;  trans execution configuration  trans execution configuration = new  trans execution configuration ( node ) ;  trans meta  trans meta = new  trans meta (  file url comma  trans execution configuration .  get repository ( ) ) ;  trans configuration  trans configuration = new  trans configuration (  trans meta comma  trans execution configuration ) ; trans trans =  create trans (  trans configuration ) ;  result id = trans .  get container object id ( ) ; } return new  web result (  web result .  string ok comma  file url comma  result id ) ; } return null ; }
test public void ( ) { operation < string > nextval =  expression utils . operation ( string . class comma  sql ops . nextval comma  constant impl . create (  " myseq " ) ) ;  assert equals (  " nextval (' myseq ')" comma new  sql serializer ( new configuration (  sql templates . default ) ) . handle ( nextval ) .  to string ( ) ) ; }
override public void ( throwable t ) { log ( level . warn comma  exception message comma t ) ; }
public void ( long  latency nanos ) { lookup . add (  latency nanos ) ; }
private void (  fs data output stream out comma byte [ ] buffer comma int length ) throws  io exception { int  total byte written = 0 ; int  remain to write = length ; while (  remain to write > 0 ) { int  to write this round =  remain to write > buffer . length ? buffer . length :  remain to write ; out . write ( buffer comma 0 comma  to write this round ) ;  total byte written +=  to write this round ;  remain to write -=  to write this round ; } if (  total byte written != length ) { throw new  io exception (  " write data : failure in write . attempt to write " + length +  " ; written =" +  total byte written ) ; } }
override public int ( ) { return objects .  hash code ( elements comma exceptional ) ; }
override public scope ( ) { return  config key . scope . zone ; }
public boolean ( ) { return false ; }
test public void ( ) { final int [ ] count = { 0 } ; single . never ( ) .  do on dispose ( new action ( ) { override public void run ( ) throws exception { count [ 0 ] ++ ; } } ) . test ( true ) ;  assert equals ( 1 comma count [ 0 ] ) ; }
public static class < ? > [ ] ( object ... objects ) { final class < ? > [ ]  class array = new class < ? > [ objects . length ] ; for ( int i = 0 ; i < objects . length ; i ++ ) {  class array [ i ] = objects [ i ] != null ? objects [ i ] .  get class ( ) : null ; } return  class array ; }
test public void ( ) { customer c = alias ( customer . class comma  " customer " ) ;  time expression < time > cases = $ ( c .  get annual spending ( ) ) . when (  1000 l ) . then ( new time ( 0 ) ) . otherwise ( new time ( 0 ) ) ;  assert not null ( cases ) ; }
public list <  h role assignment rule > ( ) { return  role assignment rule dao .  find all ( ) ; }
private string ( string  src ova file name ) { file file = new file (  src ova file name ) ; assert (  storage != null ) ; string [ ] files =  storage .  list files ( file .  get parent ( ) ) ; if ( files != null ) { for ( string  file name : files ) { if (  file name .  to lower case ( ) .  ends with (  ". ovf " ) ) { file  ovf file = new file (  file name ) ; return file .  get parent ( ) + file . separator +  ovf file .  get name ( ) ; } } } return null ; }
private list < requirement > (  sorted map < string comma requirement >  requirements by path comma map < requirement comma string >  requirement paths ) { list < requirement >  requirements tree = lists .  new array list ( ) ; for ( requirement requirement :  requirements by path . values ( ) ) { if (  is root (  requirement paths . get ( requirement ) ) ) { list < requirement > children =  find direct children for ( requirement comma  requirements by path comma  requirement paths ) ;  requirements tree . add ( requirement .  with children ( children ) ) ; } } return  requirements tree ; }
override public long (  storage pool vo pool ) {  data store provider  store provider =  data store provider mgr .  get data store provider ( pool .  get storage provider name ( ) ) ;  data store driver  store driver =  store provider .  get data store driver ( ) ; if (  store driver instanceof  primary data store driver ) {  primary data store driver  primary store driver = (  primary data store driver )  store driver ; return  primary store driver .  get used iops ( pool ) ; } throw new  cloud runtime exception (  " storage driver in capacity manager impl . get used iops ( storage pool vo ) is not a primary data store driver ." ) ; }
public  database meta ( ) { return  database meta ; }
override public  input stream ( ) {  data input buffer in = new  data input buffer ( ) ; in . reset ( out .  get data ( ) comma 0 comma out .  get length ( ) ) ; return in ; }
test public void ( ) throws  interrupted exception comma  execution exception comma  timeout exception {  test response compression (  small uri comma  small bytes num comma  " x - snappy - framed ; q = 1 comma bzip2 ; q = 0 . 75 comma gzip ; q = 0 . 5 comma defalte ; q = 0 " comma new  snappy compressor (  executor ) ) ; }
static long (  data input plus in ) throws  io exception { long position = in .  read unsigned v int ( ) ; int size = ( int ) in .  read unsigned v int ( ) ; if ( size > 0 ) in .  skip bytes fully ( size ) ; return position ; }
override public void ( ) { if ( size ( ) > 0 ) { arr = new object [ cap ] ; size = 0 ;  off count = 1 ; offset = 0 ; } }
public supplier < ? extends header > ( ) { return  m perf header :: new ; }
private float ( float x comma float y comma int  cube x comma int  cube y comma point [ ] results ) { random .  set seed ( 571 *  cube x + 23 *  cube y ) ; int  num points = 3 + random .  next int ( ) % 4 ;  num points = 4 ; for ( int i = 0 ; i <  num points ; i ++ ) { float px = random .  next float ( ) ; float py = random .  next float ( ) ; float dx = math . abs ( x - px ) ; float dy = math . abs ( y - py ) ; float d ; if (  distance power ==  1 . 0f ) d = dx + dy ; else if (  distance power ==  2 . 0f ) d = ( float ) math . sqrt ( dx * dx + dy * dy ) ; else d = ( float ) math . pow ( math . pow ( dx comma  distance power ) + math . pow ( dy comma  distance power ) comma 1 /  distance power ) ; for ( int j = 0 ; j < results . length ; j ++ ) { if ( results [ j ] . distance == double .  positive infinity ) { point last = results [ j ] ; last . distance = d ; last . x = px ; last . y = py ; results [ j ] = last ; break ; } else if ( d < results [ j ] . distance ) { point last = results [ results . length - 1 ] ; for ( int k = results . length - 1 ; k > j ; k -- ) results [ k ] = results [ k - 1 ] ; last . distance = d ; last . x = px ; last . y = py ; results [ j ] = last ; break ; } } } return results [ 1 ] . distance ; }
override public  column counter ( ) { return new  column counter ( 0 ) ; }
public void ( final  auth scheme  auth scheme ) { args .  not null (  auth scheme comma  " auth scheme " ) ; this .  auth scheme =  auth scheme ; this .  auth options = null ; }
( int  response op code ) { this ( 0 comma  response op code comma  enum set .  none of (  op reqs . class ) comma  decoder requirements . header ) ; }
public void ( list <  database impact > impact comma  trans meta  trans meta comma  step meta  step meta comma  row meta interface prev comma string [ ] input comma string [ ] output comma  row meta interface info comma repository repository comma  i meta store  meta store ) throws  kettle step exception { if ( prev != null ) { for ( int i = 0 ; i <  key lookup . length ; i ++ ) {  value meta interface v = prev .  search value meta (  key stream [ i ] ) ;  database impact ii = new  database impact (  database impact .  type impact delete comma  trans meta .  get name ( ) comma  step meta .  get name ( ) comma  database meta .  get database name ( ) comma  table name comma  key lookup [ i ] comma  key stream [ i ] comma v != null ? v .  get origin ( ) : "?" comma "" comma  " type = " + v .  to string meta ( ) ) ; impact . add ( ii ) ; } } }
test public void ( ) throws exception { job job = job .  get instance ( new configuration (  default conf ) ) ; path file = new path (  work dir comma  " test . txt " ) ; int seed = new random ( ) .  next int ( ) ; log . info (  " seed = " + seed ) ; random random = new random ( seed ) ;  local fs . delete (  work dir comma true ) ;  file input format .  set input paths ( job comma  work dir ) ; final int  max length = 10000 ; for ( int length = 0 ; length <  max length ; length += random .  next int (  max length / 10 ) + 1 ) { log . debug (  " creating ; entries = " + length ) ; writer writer = new  output stream writer (  local fs . create ( file ) ) ; try { for ( int i = 0 ; i < length ; i ++ ) { writer . write ( integer .  to string ( i * 2 ) ) ; writer . write (  " " ) ; writer . write ( integer .  to string ( i ) ) ; writer . write (  " " ) ; } } finally { writer . close ( ) ; }  key value text input format format = new  key value text input format ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { int  num splits = random .  next int (  max length / 20 ) + 1 ; log . debug (  " splitting : requesting = " +  num splits ) ; list <  input split > splits = format .  get splits ( job ) ; log . debug (  " splitting : got = " + splits . size ( ) ) ;  bit set bits = new  bit set ( length ) ; for ( int j = 0 ; j < splits . size ( ) ; j ++ ) { log . debug (  " split [" + j +  "]= " + splits . get ( j ) ) ;  task attempt context context =  map reduce test util .  create dummy map task attempt context ( job .  get configuration ( ) ) ;  record reader < text comma text > reader = format .  create record reader ( splits . get ( j ) comma context ) ; class < ? > clazz = reader .  get class ( ) ;  assert equals (  " reader class is key value line record reader ." comma  key value line record reader . class comma clazz ) ;  map context < text comma text comma text comma text > mcontext = new  map context impl < text comma text comma text comma text > ( job .  get configuration ( ) comma context .  get task attempt id ( ) comma reader comma null comma null comma  map reduce test util .  create dummy reporter ( ) comma splits . get ( j ) ) ; reader . initialize ( splits . get ( j ) comma mcontext ) ; text key = null ; text value = null ; try { int count = 0 ; while ( reader .  next key value ( ) ) { key = reader .  get current key ( ) ; clazz = key .  get class ( ) ;  assert equals (  " key class is text ." comma text . class comma clazz ) ; value = reader .  get current value ( ) ; clazz = value .  get class ( ) ;  assert equals (  " value class is text ." comma text . class comma clazz ) ; final int k = integer .  parse int ( key .  to string ( ) ) ; final int v = integer .  parse int ( value .  to string ( ) ) ;  assert equals (  " bad key " comma 0 comma k % 2 ) ;  assert equals (  " mismatched key / value " comma k / 2 comma v ) ; log . debug (  " read " + v ) ;  assert false (  " key in multiple partitions ." comma bits . get ( v ) ) ; bits . set ( v ) ; count ++ ; } log . debug (  " splits [" + j + "]=" + splits . get ( j ) +  " count =" + count ) ; } finally { reader . close ( ) ; } }  assert equals (  " some keys in no partition ." comma length comma bits . cardinality ( ) ) ; } } }
public (  quota credits vo result comma string  updated by ) { super ( ) ; if ( result != null ) {  set credits ( result .  get credit ( ) ) ;  set updated by (  updated by ) ;  set updated on ( new date ( ) ) ; } }
public ( long in comma long out comma long dropped comma long  in flight ) { this . in = in ; this . out = out ; this . dropped = dropped ; this .  in flight =  in flight ; }
public void ( string  constant value expression ) { this .  constant value expression =  constant value expression ; }
public void ( string name ) {  base cmd cmd = new  create project cmd ( ) ;  base cmd proxy =  component context . inject ( cmd ) ; account system =  account mgr .  get system account ( ) ;  management server mock .  set parameter ( proxy comma  " account name " comma  base cmd .  command type . string comma system .  get account name ( ) ) ;  management server mock .  set parameter ( proxy comma  " domain id " comma  base cmd .  command type . long comma domain .  root domain ) ;  management server mock .  set parameter ( proxy comma  " name " comma  base cmd .  command type . string comma name ) ;  management server mock .  set parameter ( proxy comma  " display text " comma  base cmd .  command type . string comma name ) ; try { ( (  create project cmd ) proxy ) . create ( ) ; ( (  create project cmd ) proxy ) . execute ( ) ; } catch ( exception e ) {  s logger . debug (  " create project cmd exception : " + e ) ; e .  print stack trace ( ) ; fail (  " create project cmd failed " ) ; }  domain vo domain =  domain dao .  find by id ( domain .  root domain ) ; try { net . juniper . contrail . api . types . domain  vnc domain = ( net . juniper . contrail . api . types . domain )  api .  find by id ( net . juniper . contrail . api . types . domain . class comma domain .  get uuid ( ) ) ; if (  api .  find by name ( net . juniper . contrail . api . types . project . class comma  vnc domain comma name ) == null ) { fail (  " create project failed in vnc " ) ; } } catch ( exception e ) { e .  print stack trace ( ) ; fail (  " exception while creating a project in vnc " ) ; } }
public void ( boolean  is dir ) { this .  is dir =  is dir ; }
public boolean ( path p ) throws  io exception { try { return fs .  get file status ( p ) .  is directory ( ) ; } catch (  file not found exception e ) { return false ; } }
test public void ( ) {  column metadata m = cfm2 .  get column ( new  column identifier (  " m " comma false ) ) ; int now1 =  fb utilities .  now in seconds ( ) ; long ts1 = now1 *  1000000 l ; cell r1m1 =  buffer cell . live ( m comma ts1 comma bb ( 1 ) comma  cell path . create ( bb ( 1 ) ) ) ; cell r1m2 =  buffer cell . live ( m comma ts1 comma bb ( 2 ) comma  cell path . create ( bb ( 2 ) ) ) ; list < cell > cells1 = lists .  new array list ( r1m1 comma r1m2 ) ; int now2 = now1 + 1 ; long ts2 = now2 *  1000000 l ; cell r2m2 =  buffer cell . live ( m comma ts2 comma bb ( 1 ) comma  cell path . create ( bb ( 2 ) ) ) ; cell r2m3 =  buffer cell . live ( m comma ts2 comma bb ( 2 ) comma  cell path . create ( bb ( 3 ) ) ) ; cell r2m4 =  buffer cell . live ( m comma ts2 comma bb ( 3 ) comma  cell path . create ( bb ( 4 ) ) ) ; list < cell > cells2 = lists .  new array list ( r2m2 comma r2m3 comma r2m4 ) ;  row builder builder = new  row builder ( ) ; cells .  reconcile complex ( m comma cells1 . iterator ( ) comma cells2 . iterator ( ) comma  deletion time . live comma builder comma now2 + 1 ) ; assert .  assert equals ( lists .  new array list ( r1m1 comma r2m2 comma r2m3 comma r2m4 ) comma builder . cells ) ; }
test public void ( ) throws exception { try { this . mocker .  get component under test ( ) . convert ( address [ ] . class comma  " invalid (" ) ; fail (  " should have thrown an exception here " ) ; } catch (  conversion exception expected ) {  assert equals (  " failed to convert [ invalid (] to an array of [ javax . mail . address ]" comma expected .  get message ( ) ) ; } }
public (  workspace id  workspace id comma string  workspace name comma string  locale name ) { this .  workspace id =  workspace id ; this .  workspace name =  workspace name ; this .  locale name =  locale name ; }
public static synchronized  step meta ( string name comma  plugin registry  plugin registry ) {  dummy trans meta  dummy trans meta = new  dummy trans meta ( ) ; string  dummy pid =  plugin registry .  get plugin id (  step plugin type . class comma  dummy trans meta ) ;  step meta  dummy step = new  step meta (  dummy pid comma name comma  dummy trans meta ) ; return  dummy step ; }
byte buf holder copy ( ) ;
test public void ( ) { coalesce < string > c = new coalesce < string > ( ) . add (  " xxx " ) ;  assert equals (  " coalesce ( xxx )" comma c .  to string ( ) ) ; }
override public void ( final observer < ? super string > observer ) { observer .  on subscribe ( disposables . empty ( ) ) ; t = new thread ( new runnable ( ) { override public void run ( ) { try { thread . sleep ( 100 ) ; } catch (  interrupted exception e ) { observer .  on error ( e ) ; } observer .  on next (  " hello " ) ; observer .  on complete ( ) ; } } ) ; t . start ( ) ; }
public type (  bytecode context bc comma int mode ) throws  bytecode exception { closure .  write out ( bc ) ; return types .  udf impl ; }
public void ( int startrow ) { this . startrow = startrow ; }
override spliterator <  cache entry < k comma v >> ( ) throws  unsupported operation exception ;
public void ( ) { elements  link elements =  get elements (  " a " ) ; for ( string  href value :  get attribute values (  link elements comma  " href " ) ) {  assert false ( type . error comma  " rpd1s3 . javascript " comma  href value .  starts with (  " javascript :" ) ) ; } list < string >  forbidden attributes = arrays .  as list (  attr blur comma  attr change comma  attr click comma  attr focus comma  attr load comma  attr mouseover comma  attr select comma  attr select comma  attr unload ) ; for ( element  link element :  link elements ) { if ( !  list utils . intersection (  get attribute names (  link element ) comma  forbidden attributes ) .  is empty ( ) ) {  assert false ( type . error comma  " rpd1s3 . inline event handlers " comma  get attribute value (  link element comma  attr href ) . equals ( "" ) ||  get attribute value (  link element comma  attr href ) . equals ( "#" ) ) ; } }  validate rpd1s3 about forms ( ) ; }
public void (  pgp message builder  pgp message builder comma  compose crypto status  crypto status ) {  pgp message builder .  set to (  get to addresses ( ) ) ;  pgp message builder .  set cc (  get cc addresses ( ) ) ;  pgp message builder .  set bcc (  get bcc addresses ( ) ) ;  pgp message builder .  set open pgp api (  open pgp api manager .  get open pgp api ( ) ) ;  pgp message builder .  set crypto status (  crypto status ) ; }
public void (  non null  account with data set  account with data set ) { if (  account with data set == null ) { throw new  illegal argument exception (  " argument should not be null " ) ; }  m default account =  account with data set ;  m preferences . edit ( ) .  put string (  m default account key comma  account with data set . stringify ( ) ) . commit ( ) ; }
override public string ( ) { return  " file " ; }
public (  i log data  delegate data ) { this .  delegate data =  delegate data ; }
public  component tag ( ) { return  open tag ; }
override public void ( string  column label comma reader reader ) throws  sql exception { rs .  update n clob (  column label comma reader ) ; }
public void ( date  start date ) {  set date value ( property .  start date .  to string ( ) comma  start date ) ; }
public optional < t > ( ) { return optional .  of nullable ( value ) ; }
public string (  document reference  document reference comma string  parameter name comma string  default value ) {  x wiki document  configuration document =  get configuration document (  document reference ) ; if (  configuration document != null && !  configuration document .  is new ( ) &&  configuration document .  get x object (  ratings manager .  ratings config classreference ) != null ) { try {  base property prop = (  base property )  configuration document .  get x object (  ratings manager .  ratings config classreference ) . get (  parameter name ) ; string  prop value = ( prop == null ) ?  default value : prop .  get value ( ) .  to string ( ) ; return (  prop value . equals ( "" ) ?  default value :  prop value ) ; } catch (  x wiki exception e ) { logger . error (  " failed to retrieve the property for the configuration document [{}]." comma  configuration document comma e ) ; return null ; } } return  default value ; }
test public void ( ) throws exception { file  conf dir =  get test dir ( ) ; configuration conf =  create base kms conf (  conf dir ) ; conf .  set int (  common configuration keys public .  kms client timeout seconds comma 1 ) ;  write conf (  conf dir comma conf ) ;  server socket sock ; int port ; try { sock = new  server socket ( 0 comma 50 comma  inet address .  get by name (  " localhost " ) ) ; port = sock .  get local port ( ) ; } catch ( exception e ) { return ; } url url = new url (  " http :// localhost :" + port +  "/ kms " ) ; uri uri =  create kms uri ( url ) ; boolean  caught timeout = false ; try {  key provider kp =  create provider ( uri comma conf ) ; kp .  get keys ( ) ; } catch (  socket timeout exception e ) {  caught timeout = true ; } catch (  io exception e ) { assert .  assert true (  " caught unexpected exception " + e .  to string ( ) comma false ) ; }  caught timeout = false ; try {  key provider kp =  create provider ( uri comma conf ) ;  key provider crypto extension .  create key provider crypto extension ( kp ) .  generate encrypted key (  " a " ) ; } catch (  socket timeout exception e ) {  caught timeout = true ; } catch (  io exception e ) { assert .  assert true (  " caught unexpected exception " + e .  to string ( ) comma false ) ; }  caught timeout = false ; try {  key provider kp =  create provider ( uri comma conf ) ;  key provider crypto extension .  create key provider crypto extension ( kp ) .  decrypt encrypted key ( new  kms client provider .  kms encrypted key version (  " a " comma  " a " comma new byte [ ] { 1 comma 2 } comma  " eek " comma new byte [ ] { 1 comma 2 } ) ) ; } catch (  socket timeout exception e ) {  caught timeout = true ; } catch (  io exception e ) { assert .  assert true (  " caught unexpected exception " + e .  to string ( ) comma false ) ; } assert .  assert true (  caught timeout ) ; sock . close ( ) ; }
private  buffered image (  buffered image image comma int width comma int height ) { int type = image .  get type ( ) == 0 ?  buffered image .  type int argb : image .  get type ( ) ;  buffered image  resized image = new  buffered image ( width comma height comma type ) ;  graphics2 d g =  resized image .  create graphics ( ) ; g .  set composite (  alpha composite . src ) ; g .  set rendering hint (  rendering hints .  key interpolation comma  rendering hints .  value interpolation bilinear ) ; g .  set rendering hint (  rendering hints .  key rendering comma  rendering hints .  value render quality ) ; g .  set rendering hint (  rendering hints .  key antialiasing comma  rendering hints .  value antialias on ) ; g .  draw image ( image comma 0 comma 0 comma width comma height comma null ) ; g . dispose ( ) ; return  resized image ; }
override public int ( ) { return context .  get major version ( ) ; }
private int [ ] ( ) {  mix descriptor  conference mix descriptor = (  mix descriptor )  mix descriptors . get ( 0 ) ; int [ ]  conference mix contribution =  conference mix descriptor .  get mix data source ( ) .  get current contribution ( ) ; if (  conference mix contribution == null ) { return null ; } int [ ]  out data = new int [  conference samples per packet ] ;  mix descriptor  member mix descriptor = (  mix descriptor )  mix descriptors . get ( 1 ) ; int [ ]  member contribution =  member mix descriptor .  get mix data source ( ) .  get current contribution ( ) ; if (  member contribution == null ) { if (  out data . length <=  conference mix contribution . length ) system . arraycopy (  conference mix contribution comma 0 comma  out data comma 0 comma  out data . length ) ; else system . arraycopy (  conference mix contribution comma 0 comma  out data comma 0 comma  conference mix contribution . length ) ; if ( logger .  log level == - 39 ) {  check data (  out data comma  use fast mix ) ; }  audio conversion . clip (  out data ) ; return  out data ; }  whisper group .  mix data (  conference mix contribution comma  member contribution comma  out data ) ; if ( logger .  log level == - 39 ) {  check data (  out data comma  use fast mix ) ; }  audio conversion . clip (  out data ) ; return  out data ; }
override public string ( ) { final  string builder sb = new  string builder (  " staging committer {" ) ; sb . append ( super .  to string ( ) ) ; sb . append (  " comma conflict resolution =" ) . append (  conflict resolution ) ; if (  wrapped committer != null ) { sb . append (  " comma wrapped committer =" ) . append (  wrapped committer ) ; } sb . append ( '}' ) ; return sb .  to string ( ) ; }
protected file ( string filename comma string ... data ) throws  io exception { file  test data file = new file (  temporary directory comma filename ) ;  test data file .  set executable ( true ) ;  test data file .  set readable ( true ) ;  test data file .  set writable ( true ) ;  buffered writer out = new  buffered writer ( new  file writer (  test data file ) ) ; for ( string row : data ) { out . write ( row ) ; out .  new line ( ) ; } out . close ( ) ; return  test data file ; }
override public map < string comma object > ( ) { return null ; }
override public long ( ) { return starttime ; }
test public void ( ) { string data =  " 1 comma 0 comma 0 " +  " 0 comma 1 comma 0 " +  " 0 comma 0 comma 1 " ; frame fr = null ; try { key k =  f vec test .  make byte vec (  " yada " comma data ) ; fr =  parse dataset2 . parse ( key . make ( ) comma new key [ ] { k } ) ; for ( boolean normalize : new boolean [ ] { false comma true } ) { for ( initialization init : new initialization [ ] { initialization . none comma initialization .  plus plus comma initialization . furthest } ) {  k means2 parms = new  k means2 ( ) ; parms . source = fr ; parms . k = 3 ; parms . normalize = normalize ; parms .  max iter = 100 ; parms . initialization = init ; parms . seed = 0 ; parms . invoke ( ) ;  k means2 model kmm = ukv . get ( parms . dest ( ) ) ; assert .  assert true ( kmm . centers [ 0 ] [ 0 ] + kmm . centers [ 0 ] [ 1 ] + kmm . centers [ 0 ] [ 2 ] == 1 ) ; assert .  assert true ( kmm . centers [ 1 ] [ 0 ] + kmm . centers [ 1 ] [ 1 ] + kmm . centers [ 1 ] [ 2 ] == 1 ) ; assert .  assert true ( kmm . centers [ 2 ] [ 0 ] + kmm . centers [ 2 ] [ 1 ] + kmm . centers [ 2 ] [ 2 ] == 1 ) ; assert .  assert true ( kmm . centers [ 0 ] [ 0 ] + kmm . centers [ 1 ] [ 0 ] + kmm . centers [ 2 ] [ 0 ] == 1 ) ; assert .  assert true ( kmm . centers [ 0 ] [ 0 ] + kmm . centers [ 1 ] [ 0 ] + kmm . centers [ 2 ] [ 0 ] == 1 ) ; assert .  assert true ( kmm . centers [ 0 ] [ 0 ] + kmm . centers [ 1 ] [ 0 ] + kmm . centers [ 2 ] [ 0 ] == 1 ) ;  test html ( kmm ) ; kmm . delete ( ) ; } } } finally { if ( fr != null ) fr . delete ( ) ; } }
private < t > list < t > ( list < t > list comma list < t >  other list ) { list < t > result = new  array list < t > ( list ) ; result .  remove all (  other list ) ; return collections .  unmodifiable list ( result ) ; }
override public integer ( ) { return  rate mbps ; }
public long ( ) { return  project id ; }
public void ( ) {  stats map . clear ( ) ; }
override public void ( string bpid comma  scan info info ) throws  io exception { throw new  unsupported operation exception ( ) ; }
public  skip span < k comma v > ( ) { for ( int i = ( levels . length - 1 ) ; i >= 0 ; i -- ) { if ( levels [ i ] != null ) { return levels [ i ] .  get end ( ) ; } } return bottom .  get end ( ) ; }
test public void ( ) throws  io exception { file f = new file (  test edit log .  test dir +  "/ readfromstream " ) ;  nn storage storage =  setup edits ( collections . < uri >  singleton list ( f .  to uri ( ) ) comma 10 comma new  abort spec ( 10 comma 0 ) ) ;  storage directory sd = storage .  dir iterator (  name node dir type . edits ) . next ( ) ;  file journal manager jm = new  file journal manager ( conf comma sd comma storage ) ; long  expected total txn count =  txns per roll * 10 +  txns per fail ;  assert equals (  expected total txn count comma  get number of transactions ( jm comma 1 comma true comma false ) ) ; long  skipped txns = ( 3 *  txns per roll ) ; long  starting tx id =  skipped txns + 1 ; long  num loadable =  get number of transactions ( jm comma  starting tx id comma true comma false ) ;  assert equals (  expected total txn count -  skipped txns comma  num loadable ) ; }
public ( comparator < ? super s > comparator ) { this . comparator = comparator ; }
public long ( string [ ]  key tokens ) { byte [ ] digest =  get md5 digest (  key tokens ) ; return ( (  0xff l & digest [ 8 ] ) << 56 ) | ( (  0xff l & digest [ 9 ] ) << 48 ) | ( (  0xff l & digest [ 10 ] ) << 40 ) | ( (  0xff l & digest [ 11 ] ) << 32 ) | ( (  0xff l & digest [ 12 ] ) << 24 ) | ( (  0xff l & digest [ 13 ] ) << 16 ) | ( (  0xff l & digest [ 14 ] ) << 8 ) | (  0xff l & digest [ 15 ] ) ; }
test public void ( ) { distribution dist =  option distribution . get (  " gaussian (- 1000 ..- 10 )" ) . get ( ) ;  assert true ( dist instanceof  distribution bound apache ) ;  assert equals ( - 1000 comma dist .  min value ( ) ) ;  assert equals ( - 10 comma dist .  max value ( ) ) ;  assert equals ( - 504 comma dist . average ( ) ) ;  assert equals ( - 1000 comma dist .  inverse cum prob ( 0d ) ) ;  assert equals ( - 10 comma dist .  inverse cum prob ( 1d ) ) ; }
override public boolean ( object o ) { if ( this == o ) return true ; if ( o == null ||  get class ( ) != o .  get class ( ) ) return false ;  thread pool configuration builder that = (  thread pool configuration builder ) o ; if (  thread pool factory != null ? !  thread pool factory . equals ( that .  thread pool factory ) : that .  thread pool factory != null ) return false ; if (  thread factory != null ? !  thread factory . equals ( that .  thread factory ) : that .  thread factory != null ) return false ; return true ; }
public string ( string self comma string  pre key comma string  post key comma string  value separator comma string  post values comma pattern regex ) { matcher matcher = regex . matcher ( self +  " end marker " ) ; if ( matcher . find ( ) ) { matcher . reset ( ) ; map < string comma list < string >>  saved tags = new  hash map < string comma list < string >> ( ) ;  string buffer sb = new  string buffer ( ) ; while ( matcher . find ( ) ) { string tagname = matcher . group ( 1 ) ; if ( !  " interface " . equals ( tagname ) ) { string content =  encode special symbols ( matcher . group ( 2 ) ) ; if (  " see " . equals ( tagname ) ||  " link " . equals ( tagname ) ) { content =  get doc url ( content ) ; } else if (  " param " . equals ( tagname ) ) { int index = content .  index of (  " " ) ; if ( index >= 0 ) { content =  "< code >" + content . substring ( 0 comma index ) +  "</ code > - " + content . substring ( index ) ; } } if (  tag text .  contains key ( tagname ) ) { string text =  tag text . get ( tagname ) ; list < string > contents =  saved tags . get ( text ) ; if ( contents == null ) { contents = new  array list < string > ( ) ;  saved tags . put ( text comma contents ) ; } contents . add ( content ) ; matcher .  append replacement ( sb comma "" ) ; } else { matcher .  append replacement ( sb comma  pre key + tagname +  post key + content +  post values ) ; } } } matcher .  append tail ( sb ) ; sb = new  string buffer ( sb . substring ( 0 comma sb . length ( ) - 10 ) ) ; for ( map . entry < string comma list < string >> e :  saved tags .  entry set ( ) ) { sb . append (  pre key ) ; sb . append ( e .  get key ( ) ) ; sb . append (  post key ) ; sb . append (  default groovy methods . join ( e .  get value ( ) comma  value separator ) ) ; sb . append (  post values ) ; } return sb .  to string ( ) ; } else { return self ; } }
override public void respond ( final  i request cycle  request cycle ) { string encoding =  get encoding (  request cycle ) ; final  web response response = (  web response )  request cycle .  get response ( ) ; response .  set content type (  content type +  "; charset =" + encoding ) ; try { byte [ ] bytes = string .  get bytes ( encoding ) ; response .  set content length ( bytes . length ) ; response . write ( bytes ) ; } catch (  io exception e ) { throw new  runtime exception (  " unable to render string : " + e .  get message ( ) comma e ) ; } }
public job ( repository repository comma  repository meta  repository meta comma final string  dir name comma final string  job name comma final string  list jobs comma final string  list dirs ) throws exception { if ( repository != null &&  repository meta != null ) {  log debug (  " kitchen . log . alocate & connect rep " ) ;  repository directory interface directory = repository .  load repository directory tree ( ) ; if ( repository .  get meta store ( ) != null &&  get meta store ( ) != null ) {  get meta store ( ) .  add meta store ( repository .  get meta store ( ) ) ; } if ( ! utils .  is empty (  dir name ) ) { directory = directory .  find directory (  dir name ) ; } if ( directory != null ) {  log debug (  " kitchen . log . check user pass " ) ; if ( ! utils .  is empty (  job name ) ) {  log debug (  " kitchen . log . loading job info " ) ;  block and throw (  get kettle init ( ) ) ;  job meta  job meta = repository .  load job (  job name comma directory comma null comma null ) ;  log debug (  " kitchen . log . allocate job " ) ; return new job ( repository comma  job meta ) ; } else if (  is enabled (  list jobs ) ) {  print repository stored jobs ( repository comma directory ) ; } else if (  is enabled (  list dirs ) ) {  print repository directories ( repository comma directory ) ; } } else { system . out . println (  base messages .  get string (  get pkg clazz ( ) comma  " kitchen . error . can not find supplied directory " comma  dir name + "" ) ) ;  repository meta = null ; } } else { system . out . println (  base messages .  get string (  get pkg clazz ( ) comma  " kitchen . error . no rep provided " ) ) ; } return null ; }
override public boolean ( ) { return false ; }
test public void ( ) {  queue worker qw = new  queue worker (  publish processor . <  scheduled action > create ( ) comma schedulers . single ( ) .  create worker ( ) ) ;  assert false ( qw .  is disposed ( ) ) ; qw . dispose ( ) ;  assert true ( qw .  is disposed ( ) ) ; qw . dispose ( ) ;  assert true ( qw .  is disposed ( ) ) ; }
public void ( list <  check result interface > remarks comma  job meta  job meta comma  variable space space comma repository repository comma  i meta store  meta store ) {  job entry validator utils .  and validator ( ) . validate ( this comma  " server name " comma remarks comma  and validator .  put validators (  job entry validator utils .  not blank validator ( ) ) ) ;  job entry validator utils .  and validator ( ) . validate ( this comma  " target directory " comma remarks comma  and validator .  put validators (  job entry validator utils .  not blank validator ( ) comma  job entry validator utils .  file exists validator ( ) ) ) ;  job entry validator utils .  and validator ( ) . validate ( this comma  " user name " comma remarks comma  and validator .  put validators (  job entry validator utils .  not blank validator ( ) ) ) ;  job entry validator utils .  and validator ( ) . validate ( this comma  " password " comma remarks comma  and validator .  put validators (  job entry validator utils .  not null validator ( ) ) ) ; }
test public void ( ) throws exception {  embedded channel channel = new  embedded channel ( new  http response encoder ( ) ) ; for ( int code = 100 ; code < 200 ; code ++ ) {  http response status status =  http response status .  value of ( code ) ;  assert empty response ( channel comma status comma null comma false ) ; }  assert false ( channel . finish ( ) ) ; }
public void ( int from comma int to ) {  m items . add ( to comma  m items . remove ( from ) ) ;  m adapter helper .  add update op ( new  adapter helper .  update op (  adapter helper .  update op . move comma from comma to comma null ) ) ; }
static int ( final int x comma final int y comma final int z ) { return ( ( x & y ) | ( ~ x & z ) ) ; }
before class public static void ( ) { assume .  assume true (  open ssl .  is available ( ) ) ; }
test public void ( ) { observable .  from publisher ( flowable . just ( 1 ) ) . test ( ) .  assert result ( 1 ) ; }
public string [ ] ( ) throws  kettle database exception {  array list < string >  catalog list = new  array list < string > ( ) ;  result set  catalog result set = null ; try {  catalog result set =  get database meta data ( ) .  get catalogs ( ) ; while (  catalog result set != null &&  catalog result set . next ( ) ) {  catalog list . add (  catalog result set .  get string ( 1 ) ) ; } } catch (  sql exception e ) { throw new  kettle database exception (  " error getting catalogs !" comma e ) ; } finally { try { if (  catalog result set != null ) {  catalog result set . close ( ) ; } } catch (  sql exception e ) { throw new  kettle database exception (  " error closing resultset after getting catalogs !" comma e ) ; } } if ( log .  is detailed ( ) ) { log .  log detailed (  " read :" +  catalog list . size ( ) +  " catalogs from db meta - data ." ) ; } return  catalog list .  to array ( new string [  catalog list . size ( ) ] ) ; }
override public int ( map < string comma object > map1 comma map < string comma object > map2 ) { return collator . compare ( map1 . get (  " title " ) comma map2 . get (  " title " ) ) ; }
override public boolean ( ) { return true ; }
public  step interface (  step meta  step meta comma  step data interface  step data interface comma int cnr comma  trans meta  trans meta comma trans trans ) { return new  db proc (  step meta comma  step data interface comma cnr comma  trans meta comma trans ) ; }
public  media library ( ) { return  media library ; }
override public object ( message msg ) throws exception {  received anything . set ( true ) ;  count down and join ( ) ; return  " ok " ; }
string ( list <  application information >  apps info ) {  string builder ret = new  string builder ( ) ; int limit =  terminal height - 9 ; list < string > columns = new  array list < > ( ) ; for ( int i = 0 ; i < limit ; ++ i ) { ret . append (  clear line ) ; if ( i <  apps info . size ( ) ) {  application information  app info =  apps info . get ( i ) ; columns . clear ( ) ; for (  enum map . entry < columns comma  column information > entry :  column information enum map .  entry set ( ) ) { if ( entry .  get value ( ) . display ) { string value = "" ; if (  app info .  display strings map .  contains key ( entry .  get key ( ) ) ) { value =  app info .  display strings map . get ( entry .  get key ( ) ) ; } columns . add ( string . format ( entry .  get value ( ) . format comma value ) ) ; } } ret . append (  limit line length ( (  string utils . join ( columns .  to array ( ) comma  " " ) + system .  line separator ( ) ) comma  terminal width comma true ) ) ; } else { ret . append ( system .  line separator ( ) ) ; } } return ret .  to string ( ) ; }
override protected void ( ) { super . deallocate ( ) ; content . release ( ) ; }
test public void ( ) throws exception { final path sdir1 = new path (  "/ dir1 " ) ; final path sdir2 = new path (  "/ dir2 " ) ; final path sdir3 = new path (  "/ dir3 " ) ; hdfs . mkdirs ( sdir1 ) ; hdfs . mkdirs ( sdir2 ) ; hdfs . mkdirs ( sdir3 ) ; final path foo = new path ( sdir1 comma  " foo " ) ; final path bar = new path ( foo comma  " bar " ) ;  dfs test util .  create file ( hdfs comma bar comma blocksize comma repl comma seed ) ; final path foo2 = new path ( sdir2 comma  " foo2 " ) ; hdfs . mkdirs ( foo2 ) ;  snapshot test helper .  create snapshot ( hdfs comma sdir1 comma  " s1 " ) ;  snapshot test helper .  create snapshot ( hdfs comma sdir2 comma  " s2 " ) ; final path foo3 = new path ( sdir3 comma  " foo3 " ) ; hdfs . rename ( foo2 comma foo3 ) ;  i node  foo3 node = fsdir .  get i node4 write ( foo3 .  to string ( ) ) ;  assert true (  foo3 node .  is reference ( ) ) ;  i node directory dir3 = fsdir .  get i node4 write ( sdir3 .  to string ( ) ) .  as directory ( ) ;  i node directory  mock dir3 = spy ( dir3 ) ;  do return ( false ) . when (  mock dir3 ) .  add child ( (  i node ) mockito .  is null ( ) comma  any boolean ( ) comma mockito .  any int ( ) ) ; mockito . when (  mock dir3 .  add child ( (  i node ) mockito .  is not null ( ) comma  any boolean ( ) comma mockito .  any int ( ) ) ) .  then return ( false ) .  then call real method ( ) ;  i node directory root = fsdir .  get i node4 write ( "/" ) .  as directory ( ) ; root .  replace child ( dir3 comma  mock dir3 comma fsdir .  get i node map ( ) ) ;  foo3 node .  set parent (  mock dir3 ) ; try { hdfs . rename ( foo comma foo3 comma rename . overwrite ) ; fail (  " the rename from " + foo +  " to " + foo3 +  " should fail " ) ; } catch (  io exception e ) {  generic test utils .  assert exception contains (  " rename from " + foo +  " to " + foo3 +  " failed ." comma e ) ; } final  i node  foo3 node undo = fsdir .  get i node4 write ( foo3 .  to string ( ) ) ;  assert same (  foo3 node comma  foo3 node undo ) ;  i node reference .  with count  foo3 wc = (  with count )  foo3 node .  as reference ( ) .  get referred i node ( ) ;  assert equals ( 2 comma  foo3 wc .  get reference count ( ) ) ;  assert same (  foo3 node comma  foo3 wc .  get parent reference ( ) ) ; }
public synchronized string ( ) { return  scheduling info ; }
public  inet socket address ( ) { return  member sender .  get send address ( ) ; }
override public boolean ( ) { return true ; }
override public org . apache . hadoop . mapreduce . counter ( ) { return  real counter ; }
private long (  recycler view .  view holder vh ) { if ( vh instanceof  test view holder ) { return ( (  test view holder ) vh ) .  m bound item .  m id ; } else if ( vh instanceof  base wrap content with aspect ratio test .  wrap content view holder ) {  base wrap content with aspect ratio test .  wrap content view holder casted = (  base wrap content with aspect ratio test .  wrap content view holder ) vh ; return casted .  m view .  m behavior .  get id ( ) ; } else { throw new  illegal argument exception (  " i don ' t support any vh " ) ; } }
private static string ( string text ) { string property = text . substring ( text .  index of (  pom property prefix ) +  pom property prefix . length ( ) ) ; return property . substring ( 0 comma property .  index of (  pom property suffix ) ) ; }
public string ( ) { return server ; }
test public void ( ) throws exception { final  http host target = start ( ) ; final byte [ ] b1 = new byte [ 1024 ] ; final random rnd = new random ( system .  current time millis ( ) ) ; rnd .  next bytes ( b1 ) ; final int  req count = 20 ; final queue < future < message <  http response comma byte [ ] >>> queue = new  linked list < > ( ) ; for ( int i = 0 ; i <  req count ; i ++ ) { final future < message <  http response comma byte [ ] >> future = httpclient . execute (  async request builder . post ( target comma  "/ echo /" ) .  set entity ( b1 comma  content type .  application octet stream ) . build ( ) comma new  basic response consumer < > ( new  basic async entity consumer ( ) ) comma  http client context . create ( ) comma null ) ; queue . add ( future ) ; } while ( ! queue .  is empty ( ) ) { final future < message <  http response comma byte [ ] >> future = queue . remove ( ) ; final message <  http response comma byte [ ] >  response message = future . get ( ) ; assert .  assert that (  response message comma  core matchers .  not null value ( ) ) ; final  http response response =  response message .  get head ( ) ; assert .  assert that ( response .  get code ( ) comma  core matchers .  equal to ( 200 ) ) ; final byte [ ] b2 =  response message .  get body ( ) ; assert .  assert that ( b1 comma  core matchers .  equal to ( b2 ) ) ; } }
private void (  segmented file . builder ibuilder comma  segmented file . builder dbuilder comma  index summary summary ) { file  summaries file = new file ( descriptor .  filename for ( component . summary ) ) ; if (  summaries file . exists ( ) )  file utils .  delete with confirm (  summaries file ) ;  data output stream and channel  o stream = null ; try {  o stream = new  data output stream and channel ( new  file output stream (  summaries file ) ) ;  index summary . serializer . serialize ( summary comma  o stream comma descriptor . version .  has sampling level ) ;  byte buffer util .  write with length ( first .  get key ( ) comma  o stream ) ;  byte buffer util .  write with length ( last .  get key ( ) comma  o stream ) ; ibuilder .  serialize bounds (  o stream ) ; dbuilder .  serialize bounds (  o stream ) ; } catch (  io exception e ) { logger . debug (  " cannot save ss table summary : " comma e ) ; if (  summaries file . exists ( ) )  file utils .  delete with confirm (  summaries file ) ; } finally {  file utils .  close quietly (  o stream ) ; } }
test public void ( ) { string  doc string =  pdl parse utils .  strip margin (  " * the quick " +  " * brown fox " ) ;  assert equals (  doc string comma  " the quick " +  " brown fox " ) ; }
public t (  float range ( from =  0 . 0 comma  from inclusive = false ) float  minimum visible change ) { if (  minimum visible change <= 0 ) { throw new  illegal argument exception (  " minimum visible change must be positive ." ) ; }  m min visible change =  minimum visible change ;  set value threshold (  minimum visible change *  threshold multiplier ) ; return ( t ) this ; }
public string ( ) {  string builder retval = new  string builder ( ) ; retval . append (  " " ) . append (  xml handler .  open tag (  xml tag ) ) . append ( const . cr ) ; retval . append (  " " ) . append (  xml handler .  add tag value (  " connection " comma  connection name ) ) ; retval . append (  " " ) . append (  xml handler .  add tag value (  " schema " comma  schema name ) ) ; retval . append (  " " ) . append (  xml handler .  add tag value (  " table " comma  table name ) ) ; retval . append (  " " ) . append (  xml handler .  add tag value (  " timeout days " comma  timeout in days ) ) ; retval . append ( super .  get fields xml ( ) ) ; retval . append (  " " ) . append (  xml handler .  close tag (  xml tag ) ) . append ( const . cr ) ; return retval .  to string ( ) ; }
default < c extends  jdbi config < c >> c ( class < c >  config class ) { return  get config ( ) . get (  config class ) ; }
public void ( string description ) { this . description = description ; }
deprecated public static statement ( expression  field expr comma expression expression ) { return  general utils .  safe expression (  field expr comma expression ) ; }
injection ( name =  " send false step " ) public void ( string  false stepname ) {  get step io meta ( ) .  get target streams ( ) . get ( 1 ) .  set subject (  false stepname ) ; }
protected void ( final string  key name ) throws exception {  dfs admin .  get key provider ( ) .  roll new version (  key name ) ;  dfs admin .  get key provider ( ) . flush ( ) ; }
public void (  shell event e ) { if ( ! cancel ( ) ) { e . doit = false ; } }
private list <  token range > ( string keyspace comma boolean  include only local dc comma boolean  with port ) throws  invalid request exception { if ( ! schema . instance .  get keyspaces ( ) . contains ( keyspace ) ) throw new  invalid request exception (  " no such keyspace : " + keyspace ) ; if ( keyspace == null || keyspace . open ( keyspace ) .  get replication strategy ( ) instanceof  local strategy ) throw new  invalid request exception (  " there is no ring for the keyspace : " + keyspace ) ; list <  token range > ranges = new  array list < > ( ) ; token .  token factory tf =  get token factory ( ) ; map < range < token > comma list <  inet address and port >>  range to address map =  include only local dc ?  get range to address map in local dc ( keyspace ) :  get range to address map ( keyspace ) ; for ( map . entry < range < token > comma list <  inet address and port >> entry :  range to address map .  entry set ( ) ) ranges . add (  token range . create ( tf comma entry .  get key ( ) comma entry .  get value ( ) comma  with port ) ) ; return ranges ; }
override public final object ( config config ) throws  page exception { try {  rpc client rpc =  get rpc client ( client ) ; return rpc .  call with named values ( config comma  get method name ( ) comma  get arguments ( ) ) ; } catch ( throwable t ) { throw caster .  to page exception ( t ) ; } }
override public iterator < entry < string comma object >> ( ) { return  entry iterator ( ) ; }
private static  application protocol config ( ) { return new  application protocol config (  application protocol config . protocol . alpn comma  application protocol config .  selector failure behavior .  no advertise comma  application protocol config .  selected listener failure behavior . accept comma  " myprotocol " ) ; }
( byte version comma long  message id comma string  cache name comma short  client intel comma int  topology id comma int scope comma iterator < byte [ ] > iterator ) { super ( version comma  message id comma  cache name comma  client intel comma  hot rod operation .  bulk get keys comma  operation status . success comma  topology id ) ; this . scope = scope ; this . iterator = iterator ; }
public ( final interpreter interpreter comma final  data map program comma final  data complex data ) { this ( new  filo scheduler ( ) comma interpreter comma program comma data ) ; }
public map < string comma  gym equipment > ( ) { return  equipments inverse ; }
public void ( ) {  clear slugs ( ) ; identity .  check permission (  get instance ( ) comma  " insert " ) ; }
test public void ( ) { filter .  get config ( ) .  set protocol header (  " x - forwarded - proto " ) ;  http servlet request resp = filter .  get wrapper ( request ) ;  assert equals (  " 127 . 0 . 0 . 1 " comma resp .  get remote addr ( ) ) ;  assert equals ( null comma resp .  get header (  " x - forwarded - for " ) ) ;  assert equals ( null comma resp .  get header (  " x - forwarded - by " ) ) ;  assert equals ( null comma resp .  get header (  " x - forwarded - proto " ) ) ;  assert equals (  " http " comma resp .  get scheme ( ) ) ;  assert false ( resp .  is secure ( ) ) ;  assert equals ( 80 comma resp .  get server port ( ) ) ; }
override public  byte buf ( int index comma long value ) { throw new  index out of bounds exception ( ) ; }
public void (  file message header header comma throwable e ) { logger . warn (  "[ stream #{}] retrying for following error " comma  plan id ( ) comma e ) ; retries ++ ; if ( retries >  database descriptor .  get max streaming retries ( ) )  on error ( new  io exception (  " too many retries for " + header comma e ) ) ; else handler .  send message ( new  retry message ( header .  cf id comma header .  sequence number ) ) ; }
public void ( string  volume name ) { this .  volume name =  volume name ; }
public void ( string  stored key ) { this .  stored key =  stored key ; }
override  suppress warnings (  " unchecked " ) protected void (  list view l comma view v comma int position comma long id ) { map < string comma object > map = ( map < string comma object > ) l .  get item at position ( position ) ; intent intent = ( intent ) map . get (  " intent " ) ;  start activity ( intent ) ; }
override protected boolean ( ) { return false ; }
public final boolean ( ) { return  is level ( warning ) ; }
public string ( ) { return  home phone ; }
override public void ( ) { if (  is showing ( ) ) { return ; } for (  menu builder menu :  m pending menus ) {  show menu ( menu ) ; }  m pending menus . clear ( ) ;  m shown anchor view =  m anchor view ; if (  m shown anchor view != null ) { final boolean  add global listener =  m tree observer == null ;  m tree observer =  m shown anchor view .  get view tree observer ( ) ; if (  add global listener ) {  m tree observer .  add on global layout listener (  m global layout listener ) ; }  m shown anchor view .  add on attach state change listener (  m attach state change listener ) ; } }
public static string ( map < byte comma  abstract type < ? >> aliases ) {  string builder sb = new  string builder ( ) ; sb . append ( '(' ) ; iterator < map . entry < byte comma  abstract type < ? >>> iter = aliases .  entry set ( ) . iterator ( ) ; if ( iter .  has next ( ) ) { map . entry < byte comma  abstract type < ? >> entry = iter . next ( ) ; sb . append ( ( char ) ( byte ) entry .  get key ( ) ) . append ( "=>" ) . append ( entry .  get value ( ) ) ; } while ( iter .  has next ( ) ) { map . entry < byte comma  abstract type < ? >> entry = iter . next ( ) ; sb . append ( ) . append ( ( char ) ( byte ) entry .  get key ( ) ) . append ( "=>" ) . append ( entry .  get value ( ) ) ; } sb . append ( ')' ) ; return sb .  to string ( ) ; }
override before public void ( ) throws exception {  kettle environment . init ( ) ; }
public list < cell > (  byte buffer  row key comma  column identifier  cql3 column name ) { if (  prefetched lists == null ) return collections .  empty list ( ) ;  cql3 row row =  prefetched lists . get (  row key ) ; return row == null ? collections . < cell >  empty list ( ) : row .  get multi cell column (  cql3 column name ) ; }
public void ( string text ) {  filter text box .  set text ( text ) ; }
override public boolean ( ) { return  m threshold <= 0 || super .  enough to filter ( ) ; }
override protected void (  configuration builder builder ) { builder . memory ( ) .  storage type (  storage type .  off heap ) ; }
private void (  hdfs configuration conf comma int  name service id count ) {  string builder  ns list = new  string builder ( ) ; for ( int i = 0 ; i <  name service id count ; i ++ ) { if (  ns list . length ( ) > 0 ) {  ns list . append (  " comma " ) ; }  ns list . append (  get name service id ( i ) ) ; } conf . set (  dfs nameservices comma  ns list .  to string ( ) ) ; }
public void ( ) { set < hash >  to expire =  select keys to expire ( ) ;  log . info (  " leases to expire : " +  to expire ) ; for ( hash key :  to expire ) {  facade . fail ( key ) ; } requeue (  rerun delay ms ) ; }
public boolean ( ) { check ( ) ; return state ==  monitoring state .  in progress ; }
public string ( ) { boolean  is file = util .  is flag set ( flags comma file ) ;  string builder sb = new  string builder ( ) ; sb . append (  get type ( ) ) ; if (  is file ) sb . append (  " comma len =" + util .  print bytes ( length ) +  " comma chunk size =" +  chunk size ) ; sb . append (  " comma mod time =" + new date (  modification time ) ) ; return sb .  to string ( ) ; }
test public void ( ) throws  json exception comma exception {  web resource r = resource ( ) ;  client response response = r . path (  " ws " ) . path (  " v1 " ) . path (  " cluster " ) . accept (  media type .  application json ) . get (  client response . class ) ;  assert equals (  media type .  application json +  "; " +  jetty utils .  utf 8 comma response .  get type ( ) .  to string ( ) ) ;  json object json = response .  get entity (  json object . class ) ;  verify cluster info ( json ) ; }
override protected void ( void ... params ) { trace .  begin section (  " sort recent loader results " ) ; collections . sort (  all interactions comma new comparator <  contact interaction > ( ) { override public int compare (  contact interaction a comma  contact interaction b ) { if ( a == null && b == null ) { return 0 ; } if ( a == null ) { return 1 ; } if ( b == null ) { return - 1 ; } if ( a .  get interaction date ( ) > b .  get interaction date ( ) ) { return - 1 ; } if ( a .  get interaction date ( ) == b .  get interaction date ( ) ) { return 0 ; } return 1 ; } } ) ; trace .  end section ( ) ; trace .  begin section (  " contact interactions to entries " ) ; for ( entry  contact interaction :  contact interactions to entries (  all interactions ) ) { list < entry >  entry list wrapper = new  array list < > ( 1 ) ;  entry list wrapper . add (  contact interaction ) ;  interactions wrapper . add (  entry list wrapper ) ; } trace .  end section ( ) ; return null ; }
public  gossiper m bean ( ) { return  goss proxy ; }
test public void ( ) {  assert split ( tok (  " b " ) comma tok (  " a " ) comma 16 ) ;  assert split ( tok (  " bbb " ) comma tok (  " a " ) comma 16 ) ; }
public list < string > ( ) { if ( authors == null ) { authors = new  array list < string > ( ) ; if ( !  is composite ( ) ) { authors . add (  get author ( ) ) ; } else { for (  activity event event :  activity events ) { string  prefixed author = event .  get wiki ( ) +  watch list store .  wiki space sep + event .  get user ( ) ; if ( ! authors . contains (  prefixed author ) ) { authors . add (  prefixed author ) ; } } } } return authors ; }
private static  method visitor (  class writer cw comma string name comma int  argument count comma final string  super class comma  cached method  cached method comma string  receiver type comma string  parameter description comma boolean  use array ) {  method visitor mv = cw .  visit method ( opcodes .  acc public comma  " call " + name comma  "( l " +  receiver type + ";" +  parameter description +  ") ljava / lang / object ;" comma null comma null ) ; mv .  visit code ( ) ; final label  try start = new label ( ) ; mv .  visit label (  try start ) ; for ( int i = 0 ; i <  argument count ; ++ i ) mv .  visit var insn ( opcodes . aload comma i ) ; mv .  visit method insn ( opcodes . invokevirtual comma  super class comma  " check call " comma  "( ljava / lang / object ;" +  parameter description +  ") z " comma false ) ; label l0 = new label ( ) ; mv .  visit jump insn ( opcodes . ifeq comma l0 ) ; class  call class =  cached method .  get declaring class ( ) .  get the class ( ) ; boolean  use interface =  call class .  is interface ( ) ; string type =  bytecode helper .  get class internal name (  call class .  get name ( ) ) ; string descriptor =  bytecode helper .  get method descriptor (  cached method .  get return type ( ) comma  cached method .  get native parameter types ( ) ) ; int  invoke method code = opcodes . invokevirtual ; if (  cached method .  is static ( ) ) {  invoke method code = opcodes . invokestatic ; } else { mv .  visit var insn ( opcodes . aload comma 1 ) ;  bytecode helper .  do cast ( mv comma  call class ) ; if (  use interface )  invoke method code = opcodes . invokeinterface ; } method method =  cached method .  set accessible ( ) ; class < ? > [ ] parameters = method .  get parameter types ( ) ; int size = parameters . length ; for ( int i = 0 ; i < size ; i ++ ) { if (  use array ) { mv .  visit var insn ( opcodes . aload comma 2 ) ;  bytecode helper .  push constant ( mv comma i ) ; mv .  visit insn ( opcodes . aaload ) ; } else { mv .  visit var insn ( opcodes . aload comma i + 2 ) ; }  bytecode helper .  do cast ( mv comma parameters [ i ] ) ; } mv .  visit method insn (  invoke method code comma type comma  cached method .  get name ( ) comma descriptor comma  invoke method code == opcodes . invokeinterface ) ;  bytecode helper . box ( mv comma  cached method .  get return type ( ) ) ; if (  cached method .  get return type ( ) == void . class ) { mv .  visit insn ( opcodes .  aconst null ) ; } mv .  visit insn ( opcodes . areturn ) ; mv .  visit label ( l0 ) ; for ( int i = 0 ; i <  argument count ; ++ i ) mv .  visit var insn ( opcodes . aload comma i ) ; if ( !  use array ) { mv .  visit method insn ( opcodes . invokestatic comma  " org / codehaus / groovy / runtime / array util " comma  " create array " comma "(" +  parameter description +  ")[ ljava / lang / object ;" comma false ) ; } mv .  visit method insn ( opcodes . invokestatic comma  " org / codehaus / groovy / runtime / callsite / call site array " comma  " default call " + name comma  "( lorg / codehaus / groovy / runtime / callsite / call site ; l " +  receiver type +  ";[ ljava / lang / object ;) ljava / lang / object ;" comma false ) ; mv .  visit insn ( opcodes . areturn ) ; final label  try end = new label ( ) ; mv .  visit label (  try end ) ; final label  catch start = new label ( ) ; mv .  visit label (  catch start ) ; mv .  visit method insn ( opcodes . invokestatic comma  " org / codehaus / groovy / runtime / script bytecode adapter " comma  " unwrap " comma  "( lgroovy / lang / groovy runtime exception ;) ljava / lang / throwable ;" comma false ) ; mv .  visit insn ( opcodes . athrow ) ; mv .  visit try catch block (  try start comma  try end comma  catch start comma gre ) ; mv .  visit maxs ( 0 comma 0 ) ; mv .  visit end ( ) ; return mv ; }
test public void ( ) {  byte buffer bb =  byte buffer util . bytes ( s ) ;  byte buffer clone1 =  byte buffer util . clone ( bb ) ; assert bb != clone1 ; assert bb . equals ( clone1 ) ; assert bb . array ( ) != clone1 . array ( ) ; bb =  from string with position ( s comma 10 comma false ) ;  byte buffer clone2 =  byte buffer util . clone ( bb ) ; assert bb != clone2 ; assert bb . equals ( clone2 ) ; assert clone1 . equals ( clone2 ) ; assert bb . array ( ) != clone2 . array ( ) ; bb =  from string with position ( s comma 10 comma true ) ;  byte buffer clone3 =  byte buffer util . clone ( bb ) ; assert bb != clone3 ; assert bb . equals ( clone3 ) ; assert clone1 . equals ( clone3 ) ; }
override public long ( ) { return  pool id ; }
override public string ( ) { return name ; }
after public void ( ) {  m waiting data loader .  get loader latch ( ) .  count down ( ) ;  m waiting data loader .  get test latch ( ) .  count down ( ) ; }
override protected void ( boolean changed comma int left comma int top comma int right comma int bottom ) { super .  on layout ( changed comma left comma top comma right comma bottom ) ; if (  m last insets != null ) { final int  inset top =  m last insets .  get system window inset top ( ) ; for ( int i = 0 comma z =  get child count ( ) ; i < z ; i ++ ) { final view child =  get child at ( i ) ; if ( !  view compat .  get fits system windows ( child ) ) { if ( child .  get top ( ) <  inset top ) {  view compat .  offset top and bottom ( child comma  inset top ) ; } } } } if (  m collapsing title enabled &&  m dummy view != null ) {  m draw collapsing title =  view compat .  is attached to window (  m dummy view ) &&  m dummy view .  get visibility ( ) == visible ; if (  m draw collapsing title ) { final boolean  is rtl =  view compat .  get layout direction ( this ) ==  view compat .  layout direction rtl ; final int  max offset =  get max offset for pin child (  m toolbar direct child != null ?  m toolbar direct child :  m toolbar ) ;  view group utils .  get descendant rect ( this comma  m dummy view comma  m tmp rect ) ;  m collapsing text helper .  set collapsed bounds (  m tmp rect . left + (  is rtl ?  m toolbar .  get title margin end ( ) :  m toolbar .  get title margin start ( ) ) comma  m tmp rect . top +  max offset +  m toolbar .  get title margin top ( ) comma  m tmp rect . right + (  is rtl ?  m toolbar .  get title margin start ( ) :  m toolbar .  get title margin end ( ) ) comma  m tmp rect . bottom +  max offset -  m toolbar .  get title margin bottom ( ) ) ;  m collapsing text helper .  set expanded bounds (  is rtl ?  m expanded margin end :  m expanded margin start comma  m tmp rect . top +  m expanded margin top comma right - left - (  is rtl ?  m expanded margin start :  m expanded margin end ) comma bottom - top -  m expanded margin bottom ) ;  m collapsing text helper . recalculate ( ) ; } } for ( int i = 0 comma z =  get child count ( ) ; i < z ; i ++ ) {  get view offset helper (  get child at ( i ) ) .  on view layout ( ) ; } if (  m toolbar != null ) { if (  m collapsing title enabled &&  text utils .  is empty (  m collapsing text helper .  get text ( ) ) ) {  m collapsing text helper .  set text (  m toolbar .  get title ( ) ) ; } if (  m toolbar direct child == null ||  m toolbar direct child == this ) {  set minimum height (  get height with margins (  m toolbar ) ) ; } else {  set minimum height (  get height with margins (  m toolbar direct child ) ) ; } }  update scrim visibility ( ) ; }
public long ( ) { long current = meter . count ( ) ; long difference = current - reported ; this . reported = current ; return difference ; }
public void ( long interval ) { this . interval = interval ; }
override public string ( ) { return uuid ; }
override public string ( ) { return  class name ; }
override public v ( k key ) throws  page exception { v v = map . get ( key ) ; if ( v == null ) return null ; if ( v == null ) throw  invalid key ( this comma key comma false ) ; return v ; }
override public string ( ) { return  marshal to string .  to string ( this ) ; }
private void ( ) {  buckets lock .  read lock ( ) . lock ( ) ; }
public ( final string  index name comma final string  file name comma final int  affinity segment id ) { if (  file name == null ) throw new  illegal argument exception (  " filename must not be null " ) ; this .  index name =  index name ; this .  file name =  file name ; this .  affinity segment id =  affinity segment id ; this .  hash code =  generated hash code ( ) ; }
get path (  "/ domain /{ domain id }" ) produces ( {  media type .  application json +  "; " +  jetty utils .  utf 8 } ) public  timeline domain ( context  http servlet request req comma context  http servlet response res comma  path param (  " domain id " ) string  domain id ) { init ( res ) ;  domain id =  parse str (  domain id ) ; if (  domain id == null ||  domain id . length ( ) == 0 ) { throw new  bad request exception (  " domain id is not specified ." ) ; }  timeline domain domain = null ; try { domain =  timeline data manager .  get domain (  parse str (  domain id ) comma  get user ( req ) ) ; } catch ( exception e ) { log . error (  " error getting domain " comma e ) ; throw new  web application exception ( e comma response . status .  internal server error ) ; } if ( domain == null ) { throw new  not found exception (  " timeline domain [" +  domain id +  "] is not found " ) ; } return domain ; }
override public synchronized void (  application id  remove app id ) throws exception {  remove app (  remove app id .  to string ( ) ) ; }
get path (  "/ proj /{ project slug }/ iter /{ iteration slug }/ doc /{ doc id :.+}" )  type hint (  copy trans status . class )  status codes ( {  response code ( code = 200 comma condition =  " a translation copy process was found comma and its " +  " status will be returned in the body of the response " ) comma  response code ( code = 500 comma condition =  " if there is an unexpected error in the server while performing this operation " ) } ) public  copy trans status (  path param (  " project slug " ) string  project slug comma  path param (  " iteration slug " ) string  iteration slug comma  path param (  " doc id " ) string  doc id ) ;
override public  step interface (  step meta  step meta comma  step data interface  step data interface comma int cnr comma  trans meta  trans meta comma trans trans ) { return new ssh (  step meta comma  step data interface comma cnr comma  trans meta comma trans ) ; }
override public string ( ) { return delegate .  get style ( ) ; }
public static  search response ( list <  imap response > responses ) { list < long > numbers = new  array list < > ( ) ; for (  imap response response : responses ) {  parse single line ( response comma numbers ) ; } return new  search response ( numbers ) ; }
public  long stats ( ) { return  call time stats ; }
override public  get edit log manifest response proto ( string jid comma string  name service id comma long  since tx id comma boolean  in progress ok ) throws  io exception { try {  get edit log manifest request proto . builder req ; req =  get edit log manifest request proto .  new builder ( ) .  set jid (  convert journal id ( jid ) ) .  set since tx id (  since tx id ) .  set in progress ok (  in progress ok ) ; if (  name service id != null ) { req .  set name service id (  name service id ) ; } return  rpc proxy .  get edit log manifest (  null controller comma req . build ( ) ) ; } catch (  service exception e ) { throw  protobuf helper .  get remote exception ( e ) ; } }
test cache permission (  authorization permission . none ) public void (  secure cache < string comma string > cache ) { cache .  get value wrapper ( ) ; }
test public void ( ) {  column family store cfs =  mock schema .  new cfs ( ) ; view  initial view =  fake view ( 1 comma 0 comma cfs ) ; view cur =  initial view ; memtable memtable1 =  initial view .  get current memtable ( ) ; memtable memtable2 =  mock schema . memtable ( cfs ) ; cur = view .  switch memtable ( memtable2 ) . apply ( cur ) ; assert .  assert equals ( 2 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( memtable1 comma cur .  live memtables . get ( 0 ) ) ; assert .  assert equals ( memtable2 comma cur .  get current memtable ( ) ) ; memtable memtable3 =  mock schema . memtable ( cfs ) ; cur = view .  switch memtable ( memtable3 ) . apply ( cur ) ; assert .  assert equals ( 3 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( 0 comma cur .  flushing memtables . size ( ) ) ; assert .  assert equals ( memtable1 comma cur .  live memtables . get ( 0 ) ) ; assert .  assert equals ( memtable2 comma cur .  live memtables . get ( 1 ) ) ; assert .  assert equals ( memtable3 comma cur .  get current memtable ( ) ) ;  test failure ( view .  replace flushed ( memtable2 comma null ) comma cur ) ; cur = view .  mark flushing ( memtable2 ) . apply ( cur ) ; assert .  assert true ( cur .  flushing memtables . contains ( memtable2 ) ) ; assert .  assert equals ( 2 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( 1 comma cur .  flushing memtables . size ( ) ) ; assert .  assert equals ( memtable2 comma cur .  flushing memtables . get ( 0 ) ) ; assert .  assert equals ( memtable1 comma cur .  live memtables . get ( 0 ) ) ; assert .  assert equals ( memtable3 comma cur .  get current memtable ( ) ) ; cur = view .  mark flushing ( memtable1 ) . apply ( cur ) ; assert .  assert equals ( 1 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( 2 comma cur .  flushing memtables . size ( ) ) ; assert .  assert equals ( memtable1 comma cur .  flushing memtables . get ( 0 ) ) ; assert .  assert equals ( memtable2 comma cur .  flushing memtables . get ( 1 ) ) ; assert .  assert equals ( memtable3 comma cur .  get current memtable ( ) ) ; cur = view .  replace flushed ( memtable2 comma null ) . apply ( cur ) ; assert .  assert equals ( 1 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( 1 comma cur .  flushing memtables . size ( ) ) ; assert .  assert equals ( memtable1 comma cur .  flushing memtables . get ( 0 ) ) ; assert .  assert equals ( memtable3 comma cur .  get current memtable ( ) ) ;  ss table reader sstable =  mock schema . sstable ( 1 comma cfs ) ; cur = view .  replace flushed ( memtable1 comma singleton ( sstable ) ) . apply ( cur ) ; assert .  assert equals ( 0 comma cur .  flushing memtables . size ( ) ) ; assert .  assert equals ( 1 comma cur .  live memtables . size ( ) ) ; assert .  assert equals ( memtable3 comma cur .  get current memtable ( ) ) ; assert .  assert equals ( 1 comma cur . sstables . size ( ) ) ; assert .  assert equals ( sstable comma cur .  sstables map . get ( sstable ) ) ; }
public uri ( ) { return this . uri ; }
override public object (  invocation context ctx comma visitor visitor ) throws throwable { return visitor .  visit commit command ( (  tx invocation context ) ctx comma this ) ; }
test  run as client public void ( ) throws exception { final account account = new account (  " testtesting . com " comma  " test account " comma  " testuser " comma  " eyox7xb nq09 mk if ry h + rjg ==" ) ; account .  set enabled ( false ) ; new  resource request (  get rest endpoint url (  "/ accounts / u / testuser " ) comma  " put " ) { override protected invocation . builder  prepare request (  resteasy web target  web target ) { return  web target . request ( ) ; } override public void invoke ( invocation . builder builder ) { entity < string > entity = entity . entity (  json marshal ( account ) comma  media types .  application zanata account json ) ; response response = builder .  build put ( entity ) . invoke ( ) ;  on response ( response ) ; } override protected void  on response ( response response ) {  assert that ( response .  get status ( ) ) .  is equal to ( status . unauthorized .  get status code ( ) ) ; } } . run ( ) ; }
override public void ( object object ) { try { notify . accept ( object ) ; } catch ( exception e ) { throw new  runtime exception ( e ) ; } }
after method void ( ) throws exception {  release all ( lock ) ; lock = null ; }
public synchronized float ( ) { return  setup progress ; }
public void ( ) { final list list = range .  sub list ( 0 comma 0 ) ;  assert true (  " list not empty " comma list .  is empty ( ) ) ; try { range .  sub list ( 0 comma 1 ) ; fail (  " got sub list in an empty range " ) ; } catch (  index out of bounds exception e ) {  assert true (  " expected exception thrown " comma true ) ; } }
override public string ( ) { return  schema to json encoder .  schema to json ( this comma  json builder . pretty . spaces ) ; }
override public int ( ) { return  exit code ; }
public list < address > ( final collection < collection < address >> subviews ) { membership coords = new membership ( ) ; subviews . stream ( ) . filter ( subview -> ! subview .  is empty ( ) ) .  for each ( subview -> coords . add ( subview . iterator ( ) . next ( ) ) ) ; coords . sort ( ) ; membership  new mbrs = new membership ( ) . add ( coords .  element at ( 0 ) ) ; subviews .  for each (  new mbrs :: add ) ; return  new mbrs .  get members ( ) ; }
hints writer ( ) { return  hints writer ; }
public  contextual reference < t > destroy (  creational context < t > ctx ) { if ( this . instance == null ) { throw new  illegal state exception (  " trying to call destroy () before create () was called " ) ; } if ( disposed ) { throw new  illegal state exception (  " trying to call destroy () on already disposed instance " ) ; } this . disposed = true ; bean . destroy ( instance comma ctx ) ; return this ; }
public static void ( long delta ) {  outgoing counter .  get and add ( delta ) ; }
deprecated public void ( int port ) {  set port (  connection type .  socket c2 s comma false comma port ) ; }
test public void ( ) throws throwable {  create table (  " create table % s ( k int comma v int comma primary key ( k comma v ))" ) ; execute (  " begin batch " +  " insert into % 1$s ( k comma v ) values ( 0 comma 0 ) if not exists ; " +  " insert into % 1$s ( k comma v ) values ( 0 comma 1 ) if not exists ; " +  " apply batch " ) ;  assert invalid (  " begin batch " +  " insert into % 1$s ( k comma v ) values ( 0 comma 2 ) if not exists using timestamp 1 ; " +  " insert into % 1$s ( k comma v ) values ( 0 comma 3 ) if not exists ; " +  " apply batch " ) ;  assert invalid (  " begin batch " +  " using timestamp 1 insert into % 1$s ( k comma v ) values ( 0 comma 4 ) if not exists ; " +  " insert into % 1$s ( k comma v ) values ( 0 comma 1 ) if not exists ; " +  " apply batch " ) ; execute (  " insert into % s ( k comma v ) values ( 1 comma 0 ) if not exists " ) ;  assert invalid (  " insert into % s ( k comma v ) values ( 1 comma 1 ) if not exists using timestamp 5 " ) ;  create table (  " create table % s ( k int primary key comma c counter )" ) ; execute (  " update % s set c = c + 1 where k = 0 " ) ;  assert invalid (  " update % s using timestamp 10 set c = c + 1 where k = 0 " ) ; execute (  " begin counter batch " +  " update % 1$s set c = c + 1 where k = 0 ; " +  " update % 1$s set c = c + 1 where k = 0 ; " +  " apply batch " ) ;  assert invalid (  " begin counter batch " +  " update % 1$s using timestamp 3 set c = c + 1 where k = 0 ; " +  " update % 1$s set c = c + 1 where k = 0 ; " +  " apply batch " ) ;  assert invalid (  " begin counter batch " +  " using timestamp 3 update % 1$s set c = c + 1 where k = 0 ; " +  " update % 1$s set c = c + 1 where k = 0 ; " +  " apply batch " ) ; }
public ( reader reader comma  source buffer  source buffer ) { this . reader = reader ; this .  source buffer =  source buffer ; this . lexer = new  dummy lexer ( ) ; }
override public boolean ( boolean v ) throws  kettle value exception { return v .  boolean value ( ) ; }
protected ( ) { this .  street number = 0 ; this .  street name = null ; this .  city name = null ; this .  country name = null ; this .  zip code = null ; this . inhabitants = new  hash set < person > ( ) ; this . id = 0 ; this . version = 0 ; }
test public void ( ) {  test data template util .  field info  field info =  test data template util .  field info ( new  array test ( ) comma  " record array " ) ;  suppress warnings (  " unchecked " ) class <  record bar array >  template class = ( class <  record bar array > )  field info .  get field class ( ) ;  array data schema schema = (  array data schema )  field info .  get field ( ) .  get type ( ) ; list <  record bar > input = new  array list <  record bar > ( ) ; for ( int i = 0 ; i < 5 ; ++ i ) { input . add ( new  record bar ( ) ) ; input . get ( i ) .  set location (  " input " + i ) ; } list <  record bar > adds = new  array list <  record bar > ( ) ; for ( int i = 0 ; i < 5 ; ++ i ) { adds . add ( new  record bar ( ) ) ; input . get ( i ) .  set location (  " add " + i ) ; }  test array template .  test array (  template class comma schema comma input comma adds ) ; }
public string ( ) { return  web url ; }
override public void ( path src ) throws  io exception {  check path is slash ( src ) ; throw  read only mount table (  " unset storage policy " comma src ) ; }
private  ftp client ( ) throws  page exception comma  io exception { required (  " name " comma name ) ; required (  " directory " comma directory ) ;  ftp client client =  get client ( ) ;  ftp file [ ] files = client .  list files ( directory ) ; if ( files == null ) files = new  ftp file [ 0 ] ; string [ ] cols = new string [ ] {  " attributes " comma  " isdirectory " comma  " lastmodified " comma  " length " comma  " mode " comma  " name " comma  " path " comma  " url " comma  " type " comma  " raw " } ; string [ ] types = new string [ ] {  " varchar " comma  " boolean " comma  " date " comma  " double " comma  " varchar " comma  " varchar " comma  " varchar " comma  " varchar " comma  " varchar " comma  " varchar " } ; railo . runtime . type . query query = new  query impl ( cols comma types comma 0 comma  " query " ) ; if ( directory . length ( ) == 0 ) directory = "/" ; else if ( directory .  starts with ( "./" ) ) directory = directory . substring ( 1 ) ; else if ( directory .  char at ( 0 ) != '/' ) directory = '/' + directory ; if ( directory .  char at ( directory . length ( ) - 1 ) != '/' ) directory = directory + '/' ;  page context .  set variable ( name comma query ) ; int row = 0 ; for ( int i = 0 ; i < files . length ; i ++ ) {  ftp file file = files [ i ] ; if ( file .  get name ( ) . equals ( "." ) || file .  get name ( ) . equals ( ".." ) ) continue ; query .  add row ( ) ; row ++ ; query .  set at (  " attributes " comma row comma "" ) ; query .  set at (  " isdirectory " comma row comma caster .  to boolean ( file .  is directory ( ) ) ) ; query .  set at (  " lastmodified " comma row comma new  date time impl ( file .  get timestamp ( ) ) ) ; query .  set at (  " length " comma row comma caster .  to double ( file .  get size ( ) ) ) ; query .  set at (  " mode " comma row comma  ftp constant .  get permission as integer ( file ) ) ; query .  set at (  " type " comma row comma  ftp constant .  get type as string ( file .  get type ( ) ) ) ; query .  set at (  " raw " comma row comma file .  get raw listing ( ) ) ; query .  set at (  " name " comma row comma file .  get name ( ) ) ; query .  set at (  " path " comma row comma directory + file .  get name ( ) ) ; query .  set at (  " url " comma row comma  " ftp ://" + client .  get remote address ( ) .  get host name ( ) + "" + directory + file .  get name ( ) ) ; }  write cfftp ( client ) ; return client ; }
public void ( string [ ]  default package ) {  m default packages =  default package ; }
public resource ( string name ) { resource f = directory .  get real resource ( name ) ; if ( f != null && f . exists ( ) && f .  is file ( ) ) return f ; return null ; }
private void ( ) {  entries = new  album entry [ ] { new  album entry ( ) .  set add time ( 1 ) comma new  album entry ( ) .  set add time ( 2 ) comma new  album entry ( ) .  set add time ( 3 ) comma new  album entry ( ) .  set add time ( 4 ) comma new  album entry ( ) .  set add time ( 5 ) } ;  keys = new  compound key [ ] { new  compound key ( ) . append (  " photo id " comma  1 l ) . append (  " album id " comma  1 l ) comma new  compound key ( ) . append (  " photo id " comma  2 l ) . append (  " album id " comma  1 l ) comma new  compound key ( ) . append (  " photo id " comma  3 l ) . append (  " album id " comma  1 l ) comma new  compound key ( ) . append (  " photo id " comma  1 l ) . append (  " album id " comma  2 l ) comma new  compound key ( ) . append (  " photo id " comma  4 l ) . append (  " album id " comma  2 l ) } ; for ( int i = 0 ; i <  entries . length ; i ++ ) { final  update response  u resp =  entry res . update (  keys [ i ] comma  entries [ i ] ) ; assert .  assert equals (  u resp .  get status ( ) comma  http status .  s 204 no content ) ; } }
test public void ( ) throws exception { this .  xclass document .  get x class ( ) .  add text field (  " property " comma  " property " comma 30 ) ;  save x class document ( ) ; this .  xobject document .  set string value ( this .  xclass document .  get document reference ( ) comma  " property " comma  " 42 " ) ; this . oldcore .  get spy x wiki ( ) .  save document ( this .  xobject document comma this . oldcore .  get x wiki context ( ) ) ; this .  xclass document .  get x class ( ) .  remove field (  " property " ) ; this .  xclass document .  get x class ( ) .  add number field (  " property " comma  " property " comma 30 comma  " integer " ) ;  save x class document ( ) ; this .  xobject document = this . oldcore .  get spy x wiki ( ) .  get document ( this .  xobject document .  get document reference ( ) comma this . oldcore .  get x wiki context ( ) ) ;  assert equals ( 42 comma ( (  base property ) this .  xobject document .  get x object ( this .  xclass document .  get document reference ( ) ) . get (  " property " ) ) .  get value ( ) ) ; }
public int ( ) { return  expected transfers out ; }
public static string (  page context pc comma object name comma double x1 comma double y1 comma double ctrlx1 comma double ctrly1 comma double ctrlx2 comma double ctrly2 comma double x2 comma double y2 ) throws  page exception { if ( name instanceof string ) name = pc .  get variable ( caster .  to string ( name ) ) ; image img = image .  to image ( name ) ; img .  draw cubic curve ( ctrlx1 comma ctrly1 comma ctrlx2 comma ctrly2 comma x1 comma y1 comma x2 comma y2 ) ; return null ; }
public ( address  last response comma  rpc manager  real one ) { super (  real one ) ; this .  last response =  last response ; }
override public  http servlet response ( ) { return this . response ; }
private string ( ) throws throwable { return  create function (  " int comma int " comma  " create function % s ( a int comma b int ) " +  " called on null input " +  " returns int " +  " language java " +  " as ' return integer . value of ( ( a != null ? a . int value () : 0 ) + b . int value ());'" ) ; }
public int ( ) { return  m directory export support ; }
public static < k comma v >  configuration adapter < k comma v > ( ) { return new  configuration adapter < k comma v > ( new  mutable configuration < k comma v > ( ) ) ; }
public  data input buffer ( ) throws  io exception { return  raw iter .  get value ( ) ; }
override public list <  ldap trust map vo > ( long  domain id ) { final  search criteria <  ldap trust map vo > sc =  domain id search . create ( ) ; sc .  set parameters (  " domain id " comma  domain id ) ; return search ( sc comma null ) ; }
public string ( node n ) { if ( !  is ancestor ( n ) ) { throw new  illegal argument exception ( this +  " is not an ancestor of " + n ) ; } string name = n .  get network location ( ) . substring (  get path ( this ) . length ( ) ) ; if ( name .  char at ( 0 ) ==  path separator ) { name = name . substring ( 1 ) ; } int index = name .  index of (  path separator ) ; if ( index != - 1 ) name = name . substring ( 0 comma index ) ; return name ; }
public int ( object o1 comma object o2 ) { if ( o1 instanceof  cached method ) return ( (  cached method ) o1 ) .  compare to ( o2 ) ; else if ( o2 instanceof  cached method ) return - ( (  cached method ) o2 ) .  compare to ( o1 ) ; else throw new  class cast exception (  " one of the two comparables must be a cached method " ) ; }
override public void ( string title ) {  get caption ( ) .  set text ( title ) ; }
override public boolean ( collection < ? > c ) { return  map .  entry set ( ) .  retain all (  unwrap collection ( c ) ) ; }
override public void (  channel handler context ctx ) throws exception { ctx . flush ( ) ; }
override public void ( boolean  is debit ) { this .  is debit =  is debit ; }
test public void ( ) throws exception { final file  output file = file .  create temp file (  " gather bam files test . sam file ." comma  bam file io utils .  bam file extension ) ;  output file .  delete on exit ( ) ; final list < string > args = new  array list < string > ( ) ; for ( final file  split bam :  split bams ) { args . add (  " input =" +  split bam .  get absolute path ( ) ) ; } args . add (  " output =" +  output file ) ;  run picard command line ( args ) ; final  compare sa ms  compare sa ms = new  compare sa ms ( ) ;  compare sa ms .  sam files = arrays .  as list (  orig bam comma  output file ) ;  compare sa ms .  do work ( ) ; assert .  assert true (  compare sa ms .  are equal ( ) ) ; }
public long ( ) { return  actual end ; }
public final static int ( string str comma string chars ) { return  find of ( str comma chars comma 0 comma ( str . length ( ) - 1 ) comma 1 comma true ) ; }
(  file object  write to ) throws  kettle exception { this .  write to =  write to ; this . delegate = new  export st file writer (  write to ) ; }
public static string ( string str comma charset charset ) throws  no such algorithm exception { return hash ( str comma  algorithm sha comma  encoding hex comma charset ) ; }
override public void (  channel future future ) throws exception { if ( ! future .  is success ( ) ) {  close input ( (  chunked input < ? > )  pending message ) ;  current write . fail ( future . cause ( ) ) ; } else {  current write . progress ( chunks . progress ( ) comma chunks . length ( ) ) ; if ( channel .  is writable ( ) ) {  resume transfer ( ) ; } } }
public void ( int  max wait ms ) { return ; }
public long ( ) { return timer .  get count ( ) ; }
private override public synchronized byte [ ] (  client to am token identifier identifier ) { return  create password ( identifier .  get bytes ( ) comma  get master key ( identifier .  get application attempt id ( ) ) ) ; }
( ) { this (  kerberos config . default comma  system default dns resolver . instance ) ; }
override public string [ ] ( ) { return new string [ ] {  " all " comma  " and " comma  " any " comma  " array " comma  " as " comma  " asc " comma  " assert rows modified " comma  " at " comma  " between " comma  " collate " comma  " contains " comma  " create " comma  " cross " comma  " cube " comma  " current " comma  " default " comma  " define " comma  " desc " comma  " distinct " comma  " else " comma  " end " comma  " enum " comma  " escape " comma  " except " comma  " exclude " comma  " exists " comma  " extract " comma  " false " comma  " fetch " comma  " following " comma  " for " comma  " from " comma  " full " comma  " group " comma  " grouping " comma  " groups " comma  " hash " comma  " having " comma  " if " comma  " ignore " comma  " in " comma  " inner " comma  " intersect " comma  " interval " comma  " into " comma  " is " comma  " join " comma  " lateral " comma  " left " comma  " like " comma  " limit " comma  " lookup " comma  " merge " comma  " natural " comma  " new " comma  " no " comma  " not " comma  " null " comma  " nulls " comma  " of " comma  " on " comma  " or " comma  " order " comma  " outer " comma  " over " comma  " partition " comma  " preceding " comma  " proto " comma  " range " comma  " recursive " comma  " respect " comma  " right " comma  " rollup " comma  " rows " comma  " select " comma  " set " comma  " some " comma  " struct " comma  " tablesample " comma  " then " comma  " to " comma  " treat " comma  " true " comma  " unbounded " comma  " union " comma  " unnest " comma  " using " comma  " when " comma  " where " comma  " window " comma  " with " comma  " within " comma  " by " comma  " case " comma  " cast " } ; }
float ( ) { return  m arrow width ; }
private static boolean (  syntax token  first token comma  syntax token  second token ) { return  first token . line ( ) ==  second token . line ( ) &&  first token . column ( ) +  first token . text ( ) . length ( ) ==  second token . column ( ) ; }
public static string ( string key comma  http exchange t ) { if ( pms .  get configuration ( ) .  use web lang ( ) ) { string lang =  get first supported language ( t ) ; if ( ! lang .  is empty ( ) ) { return messages .  get string ( key comma locale .  for language tag ( lang ) ) ; } } return messages .  get string ( key ) ; }
override protected void ( bundle  saved instance state ) { super .  on create (  saved instance state ) ;  m root =  find view by id ( r . id . container ) ;  m photo =  find view by id ( r . id . photo ) ; final view .  on click listener listener = new view .  on click listener ( ) { override public void  on click ( view v ) {  transition manager .  begin delayed transition (  m root comma transition ) ; switch ( v .  get id ( ) ) { case r . id .  fit xy :  m photo .  set scale type (  image view .  scale type .  fit xy ) ; break ; case r . id . center :  m photo .  set scale type (  image view .  scale type . center ) ; break ; case r . id .  center crop :  m photo .  set scale type (  image view .  scale type .  center crop ) ; break ; case r . id .  fit start :  m photo .  set scale type (  image view .  scale type .  fit start ) ; break ; case r . id .  fit end :  m photo .  set scale type (  image view .  scale type .  fit end ) ; break ; case r . id . matrix :  m photo .  set scale type (  image view .  scale type . matrix ) ; final matrix matrix = new matrix ( ) ; matrix .  set rotate (  45 . f ) ; matrix .  post translate ( 200 comma 10 ) ;  m photo .  set image matrix ( matrix ) ; break ; } } } ;  find view by id ( r . id .  fit xy ) .  set on click listener ( listener ) ;  find view by id ( r . id . center ) .  set on click listener ( listener ) ;  find view by id ( r . id .  center crop ) .  set on click listener ( listener ) ;  find view by id ( r . id .  fit start ) .  set on click listener ( listener ) ;  find view by id ( r . id .  fit end ) .  set on click listener ( listener ) ;  find view by id ( r . id . matrix ) .  set on click listener ( listener ) ; }
override public int ( ) { return  query definition .  get hs query ( ) .  query result size ( ) ; }
override public void ( list <  updated container > containers ) { for (  updated container container : containers ) { log . info (  " container {} updated comma update type ={} comma resource ={} comma " +  " exec type ={}" comma container .  get container ( ) .  get id ( ) comma container .  get update type ( ) .  to string ( ) comma container .  get container ( ) .  get resource ( ) .  to string ( ) comma container .  get container ( ) .  get execution type ( ) ) ;  nm client async .  update container resource async ( container .  get container ( ) ) ; } }
override protected string ( ) { return  " put " ; }
private boolean ( object key ) { return  clustering dependent logic .  get cache topology ( ) .  get distribution ( key ) .  is primary ( ) ; }
override public boolean ( ) { return finished ; }
public void (  db unit provider .  data set operation operation ) {  db unit provider .  add before test operation ( operation ) ; }
public void ( string tag ) { writer . println ( indent + "<" + tag + ">" ) ;  open tags . push ( tag ) ; indent . append (  indent str ) ; }
public string ( ) { return  http resource .  get default mime type ( type ) ; }
public long ( ) { return  m player adapter .  get current position ( ) ; }
override public  blob properties ( ) { return properties ; }
test public void ( ) { final int [ ] count = { 0 } ; flowable . range ( 1 comma 5 ) . parallel ( 2 ) .  do on complete ( new action ( ) { override public void run ( ) throws exception { count [ 0 ] ++ ; } } ) . sequential ( ) . test ( ) .  assert result ( 1 comma 2 comma 3 comma 4 comma 5 ) ;  assert equals ( 2 comma count [ 0 ] ) ; }
override public  task execution mode ( ) { return  task execution mode .  all nodes ; }
private int deduplicate ( t [ ] items ) { if ( items . length == 0 ) { throw new  illegal argument exception (  " input array must be non - empty " ) ; } int  range start = 0 ; int  range end = 1 ; for ( int i = 1 ; i < items . length ; ++ i ) { t  current item = items [ i ] ; int compare =  m callback . compare ( items [  range start ] comma  current item ) ; if ( compare > 0 ) { throw new  illegal argument exception (  " input must be sorted in ascending order ." ) ; } if ( compare == 0 ) { final int  same item pos =  find same item (  current item comma items comma  range start comma  range end ) ; if (  same item pos !=  invalid position ) { items [  same item pos ] =  current item ; } else { if (  range end != i ) { items [  range end ] =  current item ; }  range end ++ ; } } else { if (  range end != i ) { items [  range end ] =  current item ; }  range start =  range end ++ ; } } return  range end ; }
private final map . entry <  data schema comma schema > ( object value comma  union data schema  union data schema comma schema  avro schema ) { int index =  generic data .  resolve union (  avro schema comma value ) ; schema  member avro schema =  avro schema .  get types ( ) . get ( index ) ; string key ; switch (  member avro schema .  get type ( ) ) { case enum : case fixed : case record : key =  member avro schema .  get full name ( ) ; break ; default : key =  member avro schema .  get type ( ) .  to string ( ) .  to lower case ( ) ; }  data schema  member data schema =  union data schema .  get type by member key ( key ) ; if (  member data schema == null ) { for (  union data schema . member member :  union data schema .  get members ( ) ) {  avro override  avro override =  get avro override ( member .  get type ( ) ) ; if (  avro override != null ) { if (  avro override .  get avro schema full name ( ) . equals ( key ) ) {  member data schema = member .  get type ( ) ; break ; } } } } if (  member data schema == null ) {  append message (  " cannot find % 1$s in union % 2$s for value % 3$s " comma key comma  union data schema comma value ) ; return null ; } return new  abstract map .  simple entry <  data schema comma schema > (  member data schema comma  member avro schema ) ; }
test public void ( ) {  m menu inflater . inflate ( r . menu . shortcut comma  m menu ) ;  support menu item  m menu item ;  m menu item = (  support menu item )  m menu .  find item ( r . id .  no modifiers ) ;  assert equals (  ' a ' comma  m menu item .  get alphabetic shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on comma  m menu item .  get alphabetic modifiers ( ) ) ;  assert equals (  ' 1 ' comma  m menu item .  get numeric shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on comma  m menu item .  get numeric modifiers ( ) ) ;  m menu item = (  support menu item )  m menu .  find item ( r . id .  default modifiers ) ;  assert equals (  ' b ' comma  m menu item .  get alphabetic shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on comma  m menu item .  get alphabetic modifiers ( ) ) ;  assert equals (  ' 2 ' comma  m menu item .  get numeric shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on comma  m menu item .  get numeric modifiers ( ) ) ;  m menu item = (  support menu item )  m menu .  find item ( r . id .  single modifier ) ;  assert equals (  ' c ' comma  m menu item .  get alphabetic shortcut ( ) ) ;  assert equals (  key event .  meta shift on comma  m menu item .  get alphabetic modifiers ( ) ) ;  assert equals (  ' 3 ' comma  m menu item .  get numeric shortcut ( ) ) ;  assert equals (  key event .  meta shift on comma  m menu item .  get numeric modifiers ( ) ) ;  m menu item = (  support menu item )  m menu .  find item ( r . id .  multiple modifiers ) ;  assert equals (  ' d ' comma  m menu item .  get alphabetic shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on |  key event .  meta shift on comma  m menu item .  get alphabetic modifiers ( ) ) ;  assert equals (  ' 4 ' comma  m menu item .  get numeric shortcut ( ) ) ;  assert equals (  key event .  meta ctrl on |  key event .  meta shift on comma  m menu item .  get numeric modifiers ( ) ) ; }
void ( ) { lock . lock ( ) ; try { if (  base disposable ==  current base ) { if ( source instanceof disposable ) { ( ( disposable ) source ) . dispose ( ) ; }  base disposable . dispose ( ) ;  base disposable = new  composite disposable ( ) ;  subscription count . set ( 0 ) ; } } finally { lock . unlock ( ) ; } }
private  abstract replication strategy ( string  keyspace name comma  token metadata tmd ) {  ks meta data ksmd = schema . instance .  get ks meta data (  keyspace name ) ; return  abstract replication strategy .  create replication strategy (  keyspace name comma ksmd .  strategy class comma tmd comma new  simple snitch ( ) comma ksmd .  strategy options ) ; }
public composite ( ) { return this . slices [ 0 ] . start ; }
private  trans meta ( ) throws  kettle exception {  trans meta  trans meta = new  trans meta ( ) ;  trans meta .  set name ( uuid .  random uuid ( ) .  to string ( ) ) ;  trans meta .  set filename ( uuid .  random uuid ( ) .  to string ( ) ) ;  repository directory  repository directory = mock (  repository directory . class ) ;  do call real method ( ) . when (  repository directory ) .  set name (  any string ( ) ) ;  do call real method ( ) . when (  repository directory ) .  get name ( ) ;  trans meta .  set repository directory (  repository directory ) ;  init shared objects (  trans meta comma  shared objects file ) ; when ( spoon .  get active meta ( ) ) .  then return (  trans meta ) ; return  trans meta ; }
public  get all command test ( boolean enabled ) { compatibility = enabled ; return this ; }
override public int ( ) {  check readable bytes ( 2 ) ; return buffer .  read unsigned short ( ) ; }
override public  get container report response proto (  rpc controller controller comma  get container report request proto proto ) throws  service exception {  get container report request pb impl request = new  get container report request pb impl ( proto ) ; try {  get container report response response = real .  get container report ( request ) ; return ( (  get container report response pb impl ) response ) .  get proto ( ) ; } catch (  yarn exception e ) { throw new  service exception ( e ) ; } catch (  io exception e ) { throw new  service exception ( e ) ; } }
public string ( ) { return  " data directory {" +  " location =" + location + '}' ; }
public string ( ) { return filename ; }
public void (  split file fetcher segment storage seg comma int  block num ) { segments [ counter ] = seg ;  block numbers [ counter ] =  block num ; counter ++ ; }
public ( ) { super ( ) ; }
protected void (  byte buffer buf ) { for ( int i = 0 ; buf .  remainder length ( ) > 0 && i < tags . length ; i ++ ) {  ber type  type and flags =  read ber type ( buf ) ; if ( ! tags [ i ] .  is type valid (  type and flags ) ) { if ( ! tags [ i ] . optional ) { throw new  runtime exception ( "[" + this +  "] error : required tag is missed : " + tags [ i ] +  ". unexected tag type : " +  type and flags +  ". data : " + buf + "." ) ; } else { for ( ; i < tags . length ; i ++ ) { if ( tags [ i ] .  is type valid (  type and flags ) ) { break ; } } if ( i >= tags . length || ! tags [ i ] .  is type valid (  type and flags ) ) { throw new  runtime exception ( "[" + this +  "] error : no more tags to read or skip comma but some data still left in buffer . unexected tag type : " +  type and flags +  ". data : " + buf + "." ) ; } } } tags [ i ] .  read tag ( buf comma  type and flags ) ; } }
private ( string  attribute name comma  model type type comma boolean  allow null ) { this ( new  simple attribute definition builder (  attribute name comma type comma  allow null ) .  set storage runtime ( ) . build ( ) comma true ) ; }
public void ( string name comma object value ) { if ( attributes == null ) { attributes = new  hash map ( ) ; } attributes . put ( name comma value ) ; }
public (  abstract locus iterator < t comma  abstract locus info < t >> iterator comma  reference sequence file walker  ref walker comma  abstract wgs metrics collector < t > collector comma  progress logger progress ) { this . iterator = iterator ; this . collector = collector ; this .  ref walker =  ref walker ; this . progress = progress ; }
public static  semi ordered shutdown hook ( ) { return singleton ; }
test public void ( ) {  publish processor < integer > source =  publish processor . create ( ) ;  publish processor < integer > start =  publish processor . create ( ) ; final  publish processor < integer > end =  publish processor . create ( ) ;  test subscriber < integer > ts = source . window ( start comma new function < integer comma flowable < integer >> ( ) { override public flowable < integer > apply ( integer v ) throws exception { return end ; } } ) .  flat map ( functions . < flowable < integer >> identity ( ) ) . test ( ) ; start .  on next ( 1 ) ; end .  on error ( new  test exception ( ) ) ; ts .  assert failure (  test exception . class ) ;  assert false (  " source has observers !" comma source .  has subscribers ( ) ) ;  assert false (  " start has observers !" comma start .  has subscribers ( ) ) ;  assert false (  " end has observers !" comma end .  has subscribers ( ) ) ; }
override public list < expression < ? >> ( ) { return expr .  get args ( ) ; }
public  cst node ( int index ) {  cst node element = null ; if ( index < size ( ) ) { element = (  cst node ) elements . get ( index ) ; } return element ; }
public static string (  value meta interface  meta a comma object  data a ) { if (  data a == null ) { return null ; } return ( new metaphone ( ) ) . metaphone (  data a .  to string ( ) ) ; }
public  active query [ ] ( ) { return  active queries .  to array ( new  active query [  active queries . size ( ) ] ) ; }
public  call site (  call site site comma  meta class impl  meta class comma  meta method  meta method comma class [ ] params comma object receiver comma object [ ] args ) { if ( ! ( args [ 0 ] instanceof integer ) ) return  pojo meta method site .  create non aware call site ( site comma  meta class comma  meta method comma params comma args ) ; else return new  my pojo meta method site ( site comma  meta class comma  meta method comma params ) ; }
public int ( ) { return value ; }
override public  entity reference ( ) { return this .  model context .  get current entity reference ( ) ; }
public ( command cmd comma string details ) { super ( cmd comma false comma details ) ; }
private void (  array list < pair < attribute comma object >> params comma condition condition comma object [ ] objs ) { if ( condition . op == op . sc ) { assert ( objs != null && objs . length > 0 ) :  " where ' s your search criteria object ? " + condition . name ; params .  add all ( ( (  search criteria < ? > ) objs [ 0 ] ) .  get values ( ) ) ; return ; } if ( objs != null && objs . length > 0 ) { for ( object obj : objs ) { if ( ( condition . op != op . eq && condition . op != op . neq ) || ( obj != null ) ) { params . add ( new pair < attribute comma object > ( condition . attr comma obj ) ) ; } } } }
override public boolean ( string  app name comma string id comma boolean  is replication ) { return  internal cancel (  app name comma id comma  is replication ) ; }
public string ( ) { return  reply name ; }
override public void (  http servlet request request comma  http servlet response response ) throws  servlet exception comma  io exception {  called times ++ ; throw new  io exception (  " i am failing !" ) ; }
public list < integer > ( ) { return  m codepoints ; }
public ( ) { objects . put (  key value filter as predicate . class comma  key value filter predicate ) ; objects . put (  converter as cache entry function . class comma  converter function ) ; objects . put (  filter converter as cache entry function . class comma  filter converter function ) ; }
protected range ( int from comma int to ) { return new  object range (  big integer .  value of ( from ) comma  big integer .  value of ( to ) ) ; }
override public void (  operation context  op context comma  self renewing lease lease ) throws  storage exception {  backing store . delete (  convert uri to decoded string ( uri ) ) ; }
public final  z exp ( ) throws  parse exception {  z expression zexpression = null ; boolean flag = true ;  z exp zexp =  sql unary expression ( ) ; label0 : do switch (  jj ntk != - 1 ?  jj ntk :  jj ntk ( ) ) { default :  jj la1 [ 88 ] =  jj gen ; break label0 ; case 108 : token token1 =  jj consume token ( 108 ) ;  z exp zexp1 =  sql unary expression ( ) ; if ( flag ) zexpression = new  z expression ( token1 .  to string ( ) comma zexp ) ; flag = false ; zexpression .  add operand ( zexp1 ) ; break ; } while ( true ) ; return ( ( flag ? zexp : zexpression ) ) ; }
public token <  block token identifier > [ ] ( ) { return  block tokens ; }
public void ( string value ) { this .  value type = value ; }
public void  set owner ( string src comma string username comma string groupname ) throws  io exception {  check open ( ) ; try (  trace scope ignored =  new path trace scope (  " set owner " comma src ) ) { namenode .  set owner ( src comma username comma groupname ) ; } catch (  remote exception re ) { throw re .  unwrap remote exception (  access control exception . class comma  file not found exception . class comma  safe mode exception . class comma  unresolved path exception . class comma  snapshot access control exception . class ) ; } }
private byte [ ] [ ] ( ) throws  io exception {  raf lock lock = parent .  lock underlying ( ) ; try { byte [ ] [ ] data = new byte [  data block count ] [ ] ; for ( int i = 0 ; i <  data block count ; i ++ ) { data [ i ] = segments [ i ] .  read data block (  block numbers [ i ] ) ; if (  debug encode ) {  client chk key = segments [ i ] .  encode block ( data [ i ] ) .  get client key ( ) ; segments [ i ] .  set key (  block numbers [ i ] comma key ) ; } } return data ; } finally { lock . unlock ( ) ; } }
test public void ( ) throws  execution exception comma  timeout exception comma  interrupted exception comma  io exception {  start server ( ) ; try {  zkfs load balancer balancer =  get balancer ( ) ;  future callback < none > callback = new  future callback < none > ( ) ; balancer . start ( callback ) ; callback . get ( 5 comma  time unit . seconds ) ; } finally {  stop server ( ) ; } }
override public boolean ( object obj ) { if ( ! ( obj instanceof  foo generic writable ) ) return false ; return get ( ) . equals ( ( (  foo generic writable ) obj ) . get ( ) ) ; }
override public  internal cache entry <  wrapped bytes comma  wrapped bytes > ( object k ) { return  peek or get ( k comma true ) ; }
override public  compatibility mode configuration ( ) { return new  compatibility mode configuration ( attributes . protect ( ) ) ; }
test public void ( ) throws exception {  do test (  utf16 le comma  utf16 le comma  test data ) ; }
override protected final void  internal on model changed ( ) {  visit children ( new  i visitor < component comma void > ( ) { override public void component ( final component component comma final  i visit < void > visit ) { if ( component .  same innermost model ( page . this ) ) { component .  model changed ( ) ; } } } ) ; }
public void ( ) throws exception { collection < string >  k values =  mutimap cache . get (  " k " ) . join ( ) ;  assert equals ( 0 comma  k values . size ( ) ) ; }
void ( string service comma string operation comma  backup requests strategy stats provider  stats provider ) ;
public void ( view view ) { system . out . println (  "** " + view ) ; final list < address > mbrs = view .  get members ( ) ; members . clear ( ) ; members .  add all ( mbrs ) ;  receive log interval =  num msgs * mbrs . size ( ) / 10 ;  received msgs .  key set ( ) .  retain all ( mbrs ) ; for ( address member : mbrs )  received msgs .  put if absent ( member comma new stats ( ) ) ; results .  retain all ( mbrs ) ; if (  result collector != null && ! mbrs . contains (  result collector ) )  result collector = null ; }
public boolean ( ) { return  is pentium mmx compatible ; }
override protected class <  job entry mysql bulk load > ( ) { return  job entry mysql bulk load . class ; }
private static file ( string  discovery url ) throws  io exception { if (  discovery url == null ) { throw new  illegal argument exception (  " null value not allowed for parameter discovery url " ) ; } file  local file = file .  create temp file (  " discovery - data -" comma  ". json " ) ; url url = new url (  discovery url ) ; system . out . println (  " downloading registration data from " + url +  " to " +  local file ) ;  http url connection  hurl conn = (  http url connection ) url .  open connection ( ) ;  hurl conn .  set do output ( true ) ;  hurl conn .  set request property (  " accept " comma  " application / json " ) ;  hurl conn . connect ( ) ; try (  input stream is =  hurl conn .  get input stream ( ) ) { java . nio . file . files . copy ( is comma  local file .  to path ( ) comma  standard copy option .  replace existing ) ; } return  local file ; }
public synchronized void ( boolean  reply after quote ) { this .  reply after quote =  reply after quote ; }
test public void ( ) throws exception { final  uuid object uo = h . attach (  uuid object . class ) ;  assert that ( uo .  get uuids ( ) ) .  is empty ( ) ; uuid u = uuid .  random uuid ( ) ; uo . insert ( u ) ;  assert that ( uo .  get uuids ( ) ) .  contains only ( u ) ; uo . insert ( u ) ;  assert that ( uo .  get uuids ( ) ) .  contains only ( u ) ; uuid u1 = uuid .  random uuid ( ) ; uo . insert ( u1 ) ;  assert that ( uo .  get uuids ( ) ) .  contains only ( u comma u1 ) ; }
private static string ( string key comma string [ ] pattern comma string [ ] value ) { return  node l10n .  get base ( ) .  get string (  " dropped old peers user alert ." + key comma pattern comma value ) ; }
private void ( file directory comma long id comma session session ) throws  parser configuration exception comma  sax exception comma  io exception { this . logger . info (  " storing attachment metadata [{}] in the database " comma directory ) ; file  document directory = directory .  get parent file ( ) .  get parent file ( ) .  get parent file ( ) ;  document reference  document reference =  get document reference (  document directory ) ; if (  get x wiki context ( ) .  get wiki reference ( ) . equals (  document reference .  get wiki reference ( ) ) ) { file file = new file ( directory comma  "~ deleted attach metadata . xml " ) ;  document builder factory  db factory =  document builder factory .  new instance ( ) ;  document builder  d builder =  db factory .  new document builder ( ) ; document doc =  d builder . parse ( file ) ; string filename =  get element text ( doc comma  " filename " comma null ) ; string deleter =  get element text ( doc comma  " deleter " comma null ) ; date  delete date = new date ( long .  value of (  get element text ( doc comma  " datedeleted " comma null ) ) ) ; long  doc id = new  x wiki document (  document reference ) .  get id ( ) ; query  select query = session .  create query (  " select id from deleted attachment where doc id =? and filename =? and date =?" ) ;  select query .  set long ( 0 comma  doc id ) ;  select query .  set string ( 1 comma filename ) ;  select query .  set timestamp ( 2 comma new java . sql . timestamp (  delete date .  get time ( ) ) ) ; long  database id = ( long )  select query .  unique result ( ) ; if (  database id == null ) {  select query .  set timestamp ( 2 comma new java . sql . timestamp (  delete date .  to instant ( ) .  get epoch second ( ) * 1000 ) ) ;  database id = ( long )  select query .  unique result ( ) ; }  deleted attachment  db attachment ; if (  database id != null ) {  db attachment = new  deleted attachment (  doc id comma this . serializer . serialize (  document reference ) comma filename comma  file system store utils . hint comma deleter comma  delete date comma null comma  database id ) ; session . update (  db attachment ) ; } else {  db attachment = new  deleted attachment (  doc id comma this . serializer . serialize (  document reference ) comma filename comma  file system store utils . hint comma deleter comma  delete date comma null ) ;  database id = ( long ) session . save (  db attachment ) ; } file  new directory = new file ( directory .  get parent file ( ) comma encode (  db attachment .  get filename ( ) +  "- id " +  database id ) ) ;  file utils .  move directory ( directory comma  new directory ) ; } }
public static double bandwidth (  nano timer timer comma long bytes ) { return bytes *  1 . 0e9 / timer . duration ( ) ; }
override public long ( ) { return actual .  max idle ( ) ; }
public string ( ) { return description ; }
public static  client chk block ( byte [ ] data comma int  data length comma  message digest md256 comma byte [ ]  enc key comma boolean  as metadata comma short  compression algorithm comma byte  crypto algorithm comma int  block hash algorithm ) throws  chk encode exception { if (  crypto algorithm != key .  algo aes ctr 256 sha256 ) throw new  illegal argument exception (  " unsupported crypto algorithm " +  crypto algorithm ) ; try { mac hmac = mac .  get instance (  " hmac sha256 " comma  hmac provider ) ; hmac . init ( new  secret key spec (  enc key comma  " hmac sha256 " ) ) ; byte [ ]  tmp len = new byte [ ] { ( byte ) (  data length >> 8 ) comma ( byte ) (  data length & 0xff ) } ; hmac . update ( data ) ; hmac . update (  tmp len ) ; byte [ ] hash = hmac .  do final ( ) ; byte [ ] header = new byte [ hash . length + 2 + 2 ] ; if (  block hash algorithm == 0 )  crypto algorithm =  key block .  hash sha256 ; if (  block hash algorithm !=  key block .  hash sha256 ) throw new  illegal argument exception (  " unsupported block hash algorithm " +  crypto algorithm ) ; header [ 0 ] = ( byte ) (  block hash algorithm >> 8 ) ; header [ 1 ] = ( byte ) (  block hash algorithm & 0xff ) ; rijndael aes ; try { aes = new rijndael ( 256 comma 128 ) ; } catch (  unsupported cipher exception e ) { throw new error ( e ) ; } aes . initialize (  enc key ) ;  ctr block cipher ctr = new  ctr block cipher ( aes ) ; ctr . init ( hash comma 0 comma 16 ) ; system . arraycopy ( hash comma 0 comma header comma 2 comma hash . length ) ; byte [ ] cdata = new byte [ data . length ] ; ctr .  process bytes ( data comma 0 comma data . length comma cdata comma 0 ) ; ctr .  process bytes (  tmp len comma 0 comma 2 comma header comma hash . length + 2 ) ; md256 . update ( header ) ; byte [ ]  final hash = md256 . digest ( cdata ) ; sha256 .  return message digest ( md256 ) ;  client chk  final key = new  client chk (  final hash comma  enc key comma  as metadata comma  crypto algorithm comma  compression algorithm ) ; try { return new  client chk block ( cdata comma header comma  final key comma false ) ; } catch (  chk verify exception e3 ) { throw new error ( e3 ) ; } } catch (  general security exception e ) { throw new  chk encode exception (  " problem with jca comma should be impossible !" comma e ) ; } }
public  content provider operation ( ) { return  m operation ; }
public void (  new class tree tree ) { for (  method matcher matcher : matches .  key set ( ) ) { if ( matcher . matches ( tree ) ) {  count match ( matcher ) ; } } }
override public boolean ( ) { return true ; }
override public boolean ( long time comma  time unit unit ) throws  interrupted exception { if ( lock .  try lock ( time comma unit ) ) {  start lock timing ( ) ; return true ; } return false ; }
test public void ( ) { final byte [ ] bytes = new byte [ 1000 ] ; for ( int i = 0 ; i < 1000 ; i ++ ) { bytes [ i ] = ( byte ) i ; }  byte string bs =  byte string . copy ( bytes ) ;  byte string slice = bs . slice ( 10 comma 900 ) ; string  slice to string = slice .  to string ( ) ; string  expected to string =  byte string . copy ( arrays .  copy of range ( bytes comma 10 comma 910 ) ) .  to string ( ) ; assert .  assert equals (  slice to string comma  expected to string ) ; }
private  application feature ( class < ? >  user story class ) { if (  get feature class (  user story class ) != null ) { return  application feature . from (  get feature class (  user story class ) ) ; } return null ; }
private static long ( int idx comma  mapped buffer file ) { return file . position ( ) + ( idx * ( 2 *  long bytes ) ) ; }
private void ( ) throws  io exception { boolean  invalid configuration = false ; if (  node labels script path == null ||  node labels script path . trim ( ) .  is empty ( ) ) {  invalid configuration = true ; } else { file f = new file (  node labels script path ) ;  invalid configuration = ! f . exists ( ) || !  file util .  can execute ( f ) ; } if (  invalid configuration ) { throw new  io exception (  " distributed node labels provider script "" +  node labels script path +  "" is not configured properly . please check whether the script " +  " path exists comma owner and the access rights are suitable for nm " +  " process to execute it " ) ; } }
test public void ( ) {  io scheduler ios = (  io scheduler ) schedulers . io ( ) ; int c = ios . size ( ) ; for ( int i = 0 ; i < 200 ; i ++ ) {  test simple async ( ) ; int c1 = ios . size ( ) ; if ( c + 60 < c1 ) { throw new  assertion error (  " worker leak : " + c +  " - " + c1 ) ; } } }
private static byte [ ] ( file file ) throws exception {  file input stream in = new  file input stream ( file ) ; try {  byte array output stream baos = new  byte array output stream ( ) ; try { byte [ ] buf = new byte [ 1024 ] ; int len ; while ( ( len = in . read ( buf ) ) != - 1 ) { baos . write ( buf comma 0 comma len ) ; } } finally { baos . close ( ) ; } return baos .  to byte array ( ) ; } finally { in . close ( ) ; } }
private void ( ) {  inside attribute = true ; arg = new  function lib function arg ( ) ; }
before public void ( ) { setup ( new  memory group by meta ( ) ) ; }
public static  byte buf ( int  initial capacity comma int  max capacity ) { return alloc .  direct buffer (  initial capacity comma  max capacity ) ; }
before public void ( ) throws  no such field exception {  mockito annotations .  init mocks ( this ) ; field =  some page object . class .  get field (  " some field " ) ;  step event bus .  get event bus ( ) . clear ( ) ; when ( driver .  find element ( by . id (  " some id " ) ) ) .  then return (  web element ) ; when ( driver .  find elements ( by . id (  " some id " ) ) ) .  then return (  immutable list . of (  web element ) ) ; }
override public void (  byte string  part data ) {  write handle . write (  part data ) ; if (  write handle . remaining ( ) > 0 ) {  single part mime reader .  request part data ( ) ; } }
public void ( ) { throw new  unsupported operation exception ( ) ; }
protected object ( object arguments ) { return  invoker helper .  invoke method (  get owner ( ) comma method comma arguments ) ; }
public void ( string  file name comma string  style sheet name ) throws  io exception {  file output stream fos = new  file output stream (  file name ) ;  output stream writer osw =  is valid ( encoding ) ? new  output stream writer ( fos comma encoding ) : new  output stream writer ( fos ) ;  print writer writer = new  print writer ( osw ) ; try { writer . println (  "<! doctype html public "-// w3 c // dtd xhtml 1 . 0 transitional // en " " +  " " http :// www . w3 . org / tr / xhtml1 / dtd / xhtml1 - transitional . dtd ">" ) ; writer . println (  "< html xmlns =" http :// www . w3 . org / 1999 / xhtml " xml : lang =" en " lang =" en ">" ) ; writer . println (  "< head >" ) ; if (  is valid (  meta description ) ) writer . println (  "< meta name =" description " content ="" +  meta description +  "" />" ) ; if (  meta keywords != null && !  meta keywords .  is empty ( ) ) {  string builder sb = new  string builder ( ) ; sb . append (  "< meta name =" keywords " content ="" ) ; for ( string keyword :  meta keywords ) sb . append ( keyword ) . append (  " comma " ) ; sb . append (  "" />" ) ; } writer . println (  "< title >" ) ; writer . println ( title ) ; writer . println (  "</ title >" ) ; writer . println (  "< link rel =" stylesheet " href ="" +  style sheet name +  "" type =" text / css "/>" ) ; writer . println (  "</ head >" ) ; writer . println (  "< body >" ) ; if (  is valid ( header ) ) { writer . println ( header ) ; writer . println (  "< hr />" ) ; } writer . println (  generate contents ( ) ) ; if (  is valid ( bottom ) ) { writer . println (  "< hr />" ) ; writer . println ( bottom ) ; } if (  is valid ( footer ) ) writer . println ( footer ) ; writer . println (  "</ body >" ) ; writer . println (  "</ html >" ) ; } finally { writer . close ( ) ; osw . close ( ) ; fos . close ( ) ; } }
test public void ( ) { flowable < string > observable = flowable . just (  " one " comma  " two " comma  " three " ) ; subscriber < string > observer =  test helper .  mock subscriber ( ) ; observable . subscribe ( observer ) ; verify ( observer comma times ( 1 ) ) .  on next (  " one " ) ; verify ( observer comma times ( 1 ) ) .  on next (  " two " ) ; verify ( observer comma times ( 1 ) ) .  on next (  " three " ) ; verify ( observer comma never ( ) ) .  on error ( any ( throwable . class ) ) ; verify ( observer comma times ( 1 ) ) .  on complete ( ) ; }
public void ( string key ) { db . remove ( key ) ; }
override protected void ( bootstrap bootstrap comma  byte buf allocator allocator ) { bootstrap . option (  channel option . allocator comma allocator ) ; }
override public map < service comma map < capability comma string >> ( ) { return capabilities ; }
static private void ( string path ) throws exception {  file output stream fos = new  file output stream ( path ) ; fos . write ( 101 ) ; fos . close ( ) ; }
protected void (  async context context comma string content ) throws  io exception { final string  remote address =  get remote address ( context ) ; document document ; try { document =  get packet reader ( ) . read ( new  string reader ( content ) comma  " utf - 8 " ) ; } catch ( exception ex ) { log . warn (  " error parsing request data from [" +  remote address + "]" comma ex ) ;  send legacy error ( context comma  bosh binding error .  bad request ) ; return ; } if ( document == null ) { log . info (  " the result of parsing request data from [" +  remote address +  "] was a null - object ." ) ;  send legacy error ( context comma  bosh binding error .  bad request ) ; return ; } final element node = document .  get root element ( ) ; if ( node == null || !  " body " . equals ( node .  get name ( ) ) ) { log . info (  " root element ' body ' is missing from parsed request data from [" +  remote address + "]" ) ;  send legacy error ( context comma  bosh binding error .  bad request ) ; return ; } final long rid =  get long attribute ( node .  attribute value (  " rid " ) comma - 1 ) ; if ( rid <= 0 ) { log . info (  " root element ' body ' does not contain a valid rid attribute value in parsed request data from [" +  remote address + "]" ) ;  send legacy error ( context comma  bosh binding error .  bad request comma  " body - element is missing a rid ( request id ) value comma or the provided value is a non - positive integer ." ) ; return ; } final string sid = node .  attribute value (  " sid " ) ; if ( sid == null ) { if ( node . elements ( ) . size ( ) > 0 ) { log . info (  " root element ' body ' does not contain a sid attribute value in parsed request data from [" +  remote address + "]" ) ;  send legacy error ( context comma  bosh binding error .  bad request ) ; return ; }  create new session ( context comma node ) ; } else {  handle session request ( sid comma context comma node ) ; } }
string ( ) { return  string value ; }
override public long ( timer  read latency ) { return 0 ; }
private void (  ui object tab ) { tab .  add style name (  " bg -- low " ) ; tab .  remove style name (  " bg -- lowest " ) ; }
auto closeable before (  document reference  author reference ) ;
override public void ( int isolation ) { this .  auto commit = false ; this . isolation = isolation ; }
public boolean ( final  thucydides system property property ) { string value = system .  get property ( property .  get property name ( ) ) ; return (  string utils .  is empty ( value ) ) ; }
public  jdbi factory bean ( boolean  auto install plugins ) { this .  auto install plugins =  auto install plugins ; return this ; }
public void ( ) { final  account type  account type =  get account type ( ) ; final  account type manager  account types =  get account types (  account type ) ; final  data kind  kind phone =  account type .  get kind for mimetype ( phone .  content item type ) ; final  edit type  type home =  raw contact modifier .  get type (  kind phone comma phone .  type home ) ; final  content values first = new  content values ( ) ; first . put ( data .  id comma  test id ) ; first . put ( data . mimetype comma phone .  content item type ) ; first . put (  kind phone .  type column comma  type home .  raw value ) ; first . put ( phone . number comma  test phone ) ; final  raw contact delta state =  get raw contact (  test id comma first ) ; final  raw contact delta list set = new  raw contact delta list ( ) ; set . add ( state ) ; final  array list <  cpo wrapper > diff = lists .  new array list ( ) ; state .  build diff wrapper ( diff ) ;  assert equals (  " unexpected operations " comma 0 comma diff . size ( ) ) ; final  values delta child = state .  get entry (  test id ) ; child . put ( phone . number comma "" ) ; diff . clear ( ) ; state .  build diff wrapper ( diff ) ;  assert equals (  " unexpected operations " comma 3 comma diff . size ( ) ) ; { final  cpo wrapper  cpo wrapper = diff . get ( 0 ) ; final  content provider operation oper =  cpo wrapper .  get operation ( ) ;  assert true (  " expected aggregation mode change " comma  compat utils .  is update compat (  cpo wrapper ) ) ;  assert equals (  " incorrect target " comma  raw contacts .  content uri comma oper .  get uri ( ) ) ; } { final  cpo wrapper  cpo wrapper = diff . get ( 1 ) ; final  content provider operation oper =  cpo wrapper .  get operation ( ) ;  assert true (  " incorrect type " comma  compat utils .  is update compat (  cpo wrapper ) ) ;  assert equals (  " incorrect target " comma data .  content uri comma oper .  get uri ( ) ) ; } { final  cpo wrapper  cpo wrapper = diff . get ( 2 ) ; final  content provider operation oper =  cpo wrapper .  get operation ( ) ;  assert true (  " expected aggregation mode change " comma  compat utils .  is update compat (  cpo wrapper ) ) ;  assert equals (  " incorrect target " comma  raw contacts .  content uri comma oper .  get uri ( ) ) ; }  raw contact modifier .  trim empty ( set comma  account types ) ; diff . clear ( ) ; state .  build diff wrapper ( diff ) ;  assert equals (  " unexpected operations " comma 1 comma diff . size ( ) ) ; { final  cpo wrapper  cpo wrapper = diff . get ( 0 ) ; final  content provider operation oper =  cpo wrapper .  get operation ( ) ;  assert true (  " incorrect type " comma  compat utils .  is delete compat (  cpo wrapper ) ) ;  assert equals (  " incorrect target " comma  raw contacts .  content uri comma oper .  get uri ( ) ) ; } }
suppress warnings (  " unchecked " ) private void ( final  object input stream in ) throws  io exception comma  class not found exception { in .  default read object ( ) ; try { this . charset = charset .  for name ( in .  read utf ( ) ) ; } catch ( final  unsupported charset exception ex ) { this . charset =  standard charsets .  us ascii ; } }
public void ( descriptor descriptor comma int  new level ) throws  io exception { logger . trace (  " mutating {} to level {}" comma descriptor .  filename for ( component . stats ) comma  new level ) ; map <  metadata type comma  metadata component >  current components = deserialize ( descriptor comma  enum set .  all of (  metadata type . class ) ) ;  stats metadata stats = (  stats metadata )  current components . remove (  metadata type . stats ) ;  current components . put (  metadata type . stats comma stats .  mutate level (  new level ) ) ;  rewrite ss table metadata ( descriptor comma  current components ) ; }
public  container id ( ) { return this .  container id ; }
public void ( ) throws exception {  cache manager .  get cache (  cache name ) ;  object name name =  get query stats object name (  jmx domain comma  cache name ) ; try {  assert true ( server .  is registered ( name ) ) ; if ( ! ( boolean ) server .  get attribute ( name comma  " statistics enabled " ) ) { server .  set attribute ( name comma new attribute (  " statistics enabled " comma true ) ) ; } cache cache =  cache manager .  get cache (  cache name ) ;  search manager  search manager = search .  get search manager ( cache ) ;  assert true (  search manager .  get statistics ( ) .  is statistics enabled ( ) ) ; for ( int i = 0 ; i <  number of entries ; i ++ ) { person person = new person ( ) ; person .  set name (  " key " + i ) ; person .  set age ( i ) ; person .  set blurb (  " value " + i ) ; person .  set non searchable field (  " i : " + i ) ; cache . put (  " key " + i comma person ) ; }  assert true (  search manager .  get statistics ( ) .  is statistics enabled ( ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " search query execution count " ) ) ;  query parser  query parser =  create query parser (  " blurb " ) ; query  lucene query =  query parser . parse (  " value " ) ;  cache query < ? >  cache query =  search manager .  get query (  lucene query ) ; list < ? > found =  cache query . list ( ) ;  assert equals (  1 l comma server .  get attribute ( name comma  " search query execution count " ) ) ;  assert equals (  number of entries comma found . size ( ) ) ;  assert equals (  number of entries comma server . invoke ( name comma  " get number of indexed entities " comma new object [ ] { person . class .  get canonical name ( ) } comma new string [ ] { string . class .  get canonical name ( ) } ) ) ;  assert equals ( 1 comma  search manager .  get statistics ( ) .  indexed entities count ( ) . size ( ) ) ;  another grass eater  another grass eater = new  another grass eater (  " another grass - eater " comma  " eats grass " ) ; cache . put (  " key101 " comma  another grass eater ) ;  cache query =  search manager .  get query (  lucene query ) ; found =  cache query . list ( ) ;  assert equals (  number of entries comma found . size ( ) ) ;  assert equals ( 1 comma server . invoke ( name comma  " get number of indexed entities " comma new object [ ] {  another grass eater . class .  get canonical name ( ) } comma new string [ ] { string . class .  get canonical name ( ) } ) ) ; set < string >  class names = ( set < string > ) server .  get attribute ( name comma  " indexed class names " ) ;  assert equals ( 2 comma  class names . size ( ) ) ;  assert true (  " the set should contain the person class name ." comma  class names . contains ( person . class .  get canonical name ( ) ) ) ;  assert true (  " the set should contain the another grass eater class name ." comma  class names . contains (  another grass eater . class .  get canonical name ( ) ) ) ;  assert equals ( 2 comma  search manager .  get statistics ( ) .  indexed entities count ( ) . size ( ) ) ;  assert true (  " the query execution total time should be > 0 ." comma ( long ) server .  get attribute ( name comma  " search query total time " ) > 0 ) ;  assert equals (  2 l comma server .  get attribute ( name comma  " search query execution count " ) ) ;  assert equals (  " blurb : value " comma server .  get attribute ( name comma  " search query execution max time query string " ) ) ;  assert true ( ( long ) server .  get attribute ( name comma  " search query execution max time " ) > 0 ) ;  assert true ( ( long ) server .  get attribute ( name comma  " search query execution avg time " ) > 0 ) ; server . invoke ( name comma  " clear " comma new object [ ] { } comma new string [ ] { } ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " search query execution count " ) ) ;  assert equals ( "" comma server .  get attribute ( name comma  " search query execution max time query string " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " search query execution max time " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " search query execution avg time " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " objects loaded count " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " object loading total time " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " object loading execution max time " ) ) ;  assert equals (  0 l comma server .  get attribute ( name comma  " object loading execution avg time " ) ) ; } finally { server .  set attribute ( name comma new attribute (  " statistics enabled " comma false ) ) ; } }
public void (  job meta  parent job meta ) { this .  parent job meta =  parent job meta ; }
override public object ( ) {  item bridge adapter .  view holder ibvh = (  item bridge adapter .  view holder )  m grid view .  find view holder for adapter position (  get selected position ( ) ) ; if ( ibvh == null ) { return null ; } return ibvh .  get item ( ) ; }
protected void (  http servlet request request comma  action messages messages ) { if ( messages == null ) { return ; }  action messages  request messages = (  action messages ) request .  get attribute ( globals .  message key ) ; if (  request messages == null ) {  request messages = new  action messages ( ) ; }  request messages . add ( messages ) ; if (  request messages .  is empty ( ) ) { request .  remove attribute ( globals .  message key ) ; return ; } request .  set attribute ( globals .  message key comma  request messages ) ; }
static map < string comma knucleotide > ( map < string comma knucleotide > map1 comma map < string comma knucleotide > map2 ) { for ( map . entry < string comma knucleotide > entry : map2 .  entry set ( ) ) { knucleotide sum = ( knucleotide ) map1 . get ( entry .  get key ( ) ) ; if ( sum != null ) sum . count += entry .  get value ( ) . count ; else map1 . put ( entry .  get key ( ) comma entry .  get value ( ) ) ; } return map1 ; }
private boolean (  applyable night mode final int mode ) { final resources res =  m context .  get resources ( ) ; final configuration conf = res .  get configuration ( ) ; final int  current night mode = conf .  ui mode & configuration .  ui mode night mask ; final int  new night mode = ( mode ==  mode night yes ) ? configuration .  ui mode night yes : configuration .  ui mode night no ; if (  current night mode !=  new night mode ) { if (  should recreate on night mode change ( ) ) { if ( debug ) { log . d ( tag comma  " apply night mode () | night mode changed comma recreating activity " ) ; } final activity activity = ( activity )  m context ; activity . recreate ( ) ; } else { if ( debug ) { log . d ( tag comma  " apply night mode () | night mode changed comma updating configuration " ) ; } final configuration config = new configuration ( conf ) ; final  display metrics metrics = res .  get display metrics ( ) ; config .  ui mode =  new night mode | ( config .  ui mode & ~ configuration .  ui mode night mask ) ; res .  update configuration ( config comma metrics ) ; if ( ! ( build . version .  sdk int >= 26 ) ) {  resources flusher . flush ( res ) ; } } return true ; } else { if ( debug ) { log . d ( tag comma  " apply night mode () | skipping . night mode has not changed : " + mode ) ; } } return false ; }
(  completable observer co ) { this . co = co ; }
public synchronized void ( ) { if ( this . thread == null ) { initialize ( new  x wiki initializer request ( ) ) ; this . thread = new thread ( this ) ; this . thread .  set daemon ( true ) ; this . thread .  set name (  " x wiki initialization " ) ; this . thread . start ( ) ; } }
void ( boolean condition ) { if ( boolean . true . equals ( condition ) ) { } else if ( condition == null ) { } else if ( boolean . false . equals ( condition ) ) { } }
test public void ( ) { iterable < integer > it = flowable . range ( 1 comma 300 ) .  blocking iterable ( ) ; for ( int i = 0 ; i < 5 ; i ++ ) { flowable < integer > f = flowable . just ( it comma it ) .  flat map iterable ( functions . < iterable < integer >> identity ( ) ) ; for ( int j = 0 ; j < i ; j ++ ) { f = f . share ( ) ; } f . count ( ) . test ( ) .  with tag (  " share : " + i ) .  assert result (  600 l ) ; } }
public float ( ) { return  b tolerance ; }
public void ( ) { string  previous url =  get driver ( ) .  get current url ( ) ;  goto page (  get current wiki ( ) comma  " register " comma  " register " ) ;  recache secret token when on register page ( ) ;  get driver ( ) . get (  previous url ) ; }
public (  pms configuration configuration ) { if ( configuration != null ) { waitbeforestart = configuration .  get video transcode start delay ( ) * 1000 ; } else { waitbeforestart = 6000 ; }  from frame = - 1 ;  to frame = - 1 ;  secondread minsize = 1000000 ; if ( configuration != null ) {  min file size = configuration .  get min stream buffer ( ) ;  min buffer size = configuration .  get min memory buffer size ( ) ;  max buffer size = configuration .  get max memory buffer size ( ) ; } if (  max buffer size < 100 ) {  max buffer size = 100 ; } timeseek = 0 ; env = null ; }
protected static list < file > ( final file  base fastq ) { final list < file > files = new  array list < file > ( ) ; files . add (  base fastq ) ;  fastq extensions  fastq extensions = null ; string suffix = null ; for ( final  fastq extensions ext :  fastq extensions . values ( ) ) { suffix =  " 001 " + ext .  get extension ( ) ; if (  base fastq .  get absolute path ( ) .  ends with ( suffix ) ) {  fastq extensions = ext ; break ; } } if ( null ==  fastq extensions ) { throw new  picard exception ( string . format (  " could not parse the fastq extension ( expected ' 001 ' + '% s '): % s " comma  fastq extensions . values ( ) .  to string ( ) comma  base fastq ) ) ; } for ( int idx = 2 ; true ; idx ++ ) { string fastq =  base fastq .  get absolute path ( ) ; fastq = string . format (  "% s % 03d % s " comma fastq . substring ( 0 comma fastq . length ( ) - suffix . length ( ) ) comma idx comma  fastq extensions .  get extension ( ) ) ; try {  io util .  assert file is readable ( new file ( fastq ) ) ; } catch ( final  sam exception e ) { break ; } files . add ( new file ( fastq ) ) ; } return files ; }
public static object ( resource res ) throws  io exception comma  class not found exception { return deserialize ( res .  get input stream ( ) ) ; }
public static void (  view group .  margin layout params lp comma int  layout direction ) { if (  sdk int >= 17 ) { lp .  set layout direction (  layout direction ) ; } }
override public void ( string filename ) throws  io exception {  file stream  output streams =  get stream ( filename ) ; if ( (  output streams != null ) && (  output streams .  is open ( ) ) ) {  output streams . flush ( ) ;  output streams . close ( ) ;  num open files -- ; } }
private void ( ) throws  page exception { string id =  get string (  " admin " comma action comma  " id " ) ; map entries = ( (  config web impl ) config ) .  get gateway engine ( ) .  get entries ( ) ; iterator it = entries .  key set ( ) . iterator ( ) ;  gateway entry ge ; struct sct ; while ( it .  has next ( ) ) { string key = ( string ) it . next ( ) ; if ( key .  equals ignore case ( id ) ) { ge = (  gateway entry ) entries . get ( key ) ; sct = new  struct impl ( ) ; sct .  set el (  " id " comma ge .  get id ( ) ) ; sct .  set el (  " class " comma ge .  get class name ( ) ) ; sct .  set el (  " listener cfc path " comma ge .  get listener cfc path ( ) ) ; sct .  set el (  " cfc path " comma ge .  get cfc path ( ) ) ; sct .  set el (  " startup mode " comma  gateway entry impl .  to startup ( ge .  get startup mode ( ) comma  " automatic " ) ) ; sct .  set el (  " custom " comma ge .  get custom ( ) ) ; sct .  set el (  " read only " comma caster .  to boolean ( ge .  is read only ( ) ) ) ; sct .  set el (  " state " comma  gateway engine impl .  to string state (  gateway util .  get state ( ge ) comma  " failed " ) ) ;  page context .  set variable (  get string (  " admin " comma action comma  " return variable " ) comma sct ) ; return ; } } throw new  application exception (  " there is no gateway entry with id [" + id + "]" ) ; }
public static byte [ ] ( string value ) { final byte [ ]  machine id ; final char separator ; switch ( value . length ( ) ) { case 17 : separator = value .  char at ( 2 ) ;  validate mac separator ( separator ) ;  machine id = new byte [  eui48 mac address length ] ; break ; case 23 : separator = value .  char at ( 2 ) ;  validate mac separator ( separator ) ;  machine id = new byte [  eui64 mac address length ] ; break ; default : throw new  illegal argument exception (  " value is not supported [ mac - 48 comma eui - 48 comma eui - 64 ]" ) ; } final int end =  machine id . length - 1 ; int j = 0 ; for ( int i = 0 ; i < end ; ++ i comma j += 3 ) { final int  s index = j + 2 ;  machine id [ i ] =  string util .  decode hex byte ( value comma j ) ; if ( value .  char at (  s index ) != separator ) { throw new  illegal argument exception (  " expected separator '" + separator +  " but got '" + value .  char at (  s index ) +  "' at index : " +  s index ) ; } }  machine id [ end ] =  string util .  decode hex byte ( value comma j ) ; return  machine id ; }
boolean ( ) { return  one phase commit ; }
override public void ( int value ) throws  character coding exception {  buffer . put (  pson int ) ;  buffer .  put int ( value ) ; }
rpc .  rpc call ( rpc .  rpc call rpc ) { final rpc .  rpc call x =  work .  put if absent ( rpc .  tsknum comma rpc ) ; if ( x != null ) return x ; if ( rpc .  tsknum >  removed task ids . get ( ) ) return null ;  work . remove ( rpc .  tsknum ) ; return  removed task ; }
public static  byte buffer (  byte buffer buffer comma int length ) {  byte array output stream  byte out = new  byte array output stream ( length ) ; byte [ ] array ; if ( buffer .  has array ( ) ) { array = buffer . array ( ) ; } else { array = new byte [ buffer . capacity ( ) ] ; buffer . get ( array ) ; } try {  gzip output stream out = new  gzip output stream (  byte out comma length ) ; out . write ( array ) ; out . finish ( ) ; out . close ( ) ; } catch (  io exception e ) {  s logger . error (  " fail to compress the request !" comma e ) ; } return  byte buffer . wrap (  byte out .  to byte array ( ) ) ; }
public long ( ) { return  start time ; }
protected  configuration builder ( ) {  configuration builder c = new  configuration builder ( ) ; c . clustering ( ) .  cache mode (  cache mode .  dist sync ) ; c . transaction ( ) .  transaction mode (  transaction mode .  non transactional ) ; return c ; }
after class public static void ( ) { if ( cluster != null ) { cluster . shutdown ( ) ; } }
public ( final  ssl context sslcontext ) { this ( sslcontext comma  get default hostname verifier ( ) ) ; }
test public void ( ) throws  io exception {  column family store cfs = keyspace . open (  " keyspace3 " ) .  get column family store (  " indexed1 " ) ; mutation rm ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . add (  " indexed1 " comma cellname (  " birthdate " ) comma  byte buffer util . bytes (  1 l ) comma 0 ) ; rm . apply ( ) ;  index expression expr = new  index expression (  byte buffer util . bytes (  " birthdate " ) comma operator . eq comma  byte buffer util . bytes (  1 l ) ) ; list <  index expression > clause = arrays .  as list ( expr ) ;  i disk atom filter filter = new  identity query filter ( ) ; range <  row position > range = util . range ( "" comma "" ) ; list < row > rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows . size ( ) == 1 :  string utils . join ( rows comma  " comma " ) ; string key =  byte buffer util . string ( rows . get ( 0 ) . key .  get key ( ) ) ; assert  " k1 " . equals ( key ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . delete (  " indexed1 " comma cellname (  " birthdate " ) comma 1 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows .  is empty ( ) ; cell deletion = rm .  get column families ( ) . iterator ( ) . next ( ) . iterator ( ) . next ( ) ;  byte buffer  deletion long =  byte buffer util . bytes ( ( long )  byte buffer util .  to int ( deletion . value ( ) ) ) ;  index expression expr0 = new  index expression (  byte buffer util . bytes (  " birthdate " ) comma operator . eq comma  deletion long ) ; list <  index expression > clause0 = arrays .  as list ( expr0 ) ; rows = cfs . search ( range comma clause0 comma filter comma 100 ) ; assert rows .  is empty ( ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . add (  " indexed1 " comma cellname (  " birthdate " ) comma  byte buffer util . bytes (  1 l ) comma 2 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows . size ( ) == 1 :  string utils . join ( rows comma  " comma " ) ; key =  byte buffer util . string ( rows . get ( 0 ) . key .  get key ( ) ) ; assert  " k1 " . equals ( key ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . delete (  " indexed1 " comma 1 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows . size ( ) == 1 :  string utils . join ( rows comma  " comma " ) ; key =  byte buffer util . string ( rows . get ( 0 ) . key .  get key ( ) ) ; assert  " k1 " . equals ( key ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . delete (  " indexed1 " comma cellname (  " birthdate " ) comma 1 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows . size ( ) == 1 :  string utils . join ( rows comma  " comma " ) ; key =  byte buffer util . string ( rows . get ( 0 ) . key .  get key ( ) ) ; assert  " k1 " . equals ( key ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . delete (  " indexed1 " comma 3 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows .  is empty ( ) :  string utils . join ( rows comma  " comma " ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . add (  " indexed1 " comma cellname (  " birthdate " ) comma  byte buffer util . bytes (  1 l ) comma 3 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows .  is empty ( ) :  string utils . join ( rows comma  " comma " ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . add (  " indexed1 " comma cellname (  " birthdate " ) comma  byte buffer util . bytes (  1 l ) comma 1 ) ; rm . delete (  " indexed1 " comma 2 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows .  is empty ( ) :  string utils . join ( rows comma  " comma " ) ; rm = new mutation (  " keyspace3 " comma  byte buffer util . bytes (  " k1 " ) ) ; rm . delete (  " indexed1 " comma 3 ) ; rm . add (  " indexed1 " comma cellname (  " birthdate " ) comma  byte buffer util . bytes (  1 l ) comma 4 ) ; rm . apply ( ) ; rows = cfs . search ( range comma clause comma filter comma 100 ) ; assert rows . size ( ) == 1 :  string utils . join ( rows comma  " comma " ) ; key =  byte buffer util . string ( rows . get ( 0 ) . key .  get key ( ) ) ; assert  " k1 " . equals ( key ) ; }
test ( expected =  null pointer exception . class ) public void ( ) { completable .  from runnable ( null ) ; }
suppress warnings ( {  " unchecked " } ) override public rb ( string key comma object value ) { return ( rb ) super .  add param ( key comma value ) ; }
public string ( ) { return  " blur / median " ; }
public ( float alpha comma  color model  src color model comma  color model  dst color model ) { super ( alpha comma  src color model comma  dst color model ) ; }
public  key partitioner ( ) { return  key partitioner ; }
public static void ( string msg comma  confusion matrix a comma  confusion matrix b ) { assert .  assert equals ( msg +  " - confusion matrix should be of the same size " comma a .  arr . length comma b .  arr . length ) ; for ( int i = 0 ; i < a .  arr . length ; i ++ ) { assert .  assert array equals ( msg comma a .  arr [ i ] comma b .  arr [ i ] ) ; } }
private  hypervisor type ( long  host id ) {  host vo host =  host dao .  find by id (  host id ) ; if ( host != null ) return host .  get hypervisor type ( ) ; return  hypervisor type . none ; }
override public void (  step meta interface  some meta ) { if (  some meta instanceof  ldif input meta ) { ( (  ldif input meta )  some meta ) . allocate ( 5 comma 5 ) ; } }
override public void ( boolean  gathering metrics ) { this .  gathering metrics =  gathering metrics ; }
private  edit text preference ( ) { return (  edit text preference )  get preference ( ) ; }
test public void ( ) {  maybe subject . create ( ) . subscribe ( new  maybe observer < object > ( ) { override public void  on subscribe ( disposable d ) {  assert false ( d .  is disposed ( ) ) ; d . dispose ( ) ; d . dispose ( ) ;  assert true ( d .  is disposed ( ) ) ; } override public void  on success ( object value ) { } override public void  on error ( throwable e ) { } override public void  on complete ( ) { } } ) ; }
override public list < terminal > (  query options options ) { int size = terms . size ( ) ; list < terminal > terminals = new  array list < > ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { term term = terms . get ( i ) ; terminals . add ( term . bind ( options ) ) ; } return terminals ; }
override public void (  channel handler context ctx comma object evt ) { this . evt = evt ; }
private static  array list < object > (  type mapping tm comma object value comma class  target class comma set < object > done ) throws  page exception { array arr = caster .  to array ( value ) ;  array list < object > al = new  array list < object > ( ) ; int len = arr . size ( ) ; object o ; for ( int i = 0 ; i < len ; i ++ ) { o = arr . get ( i + 1 comma null ) ; al . add ( i comma  to axis type ( tm comma null comma null comma o comma  target class comma done ) ) ; } return al ; }
override public boolean ( ) { if (  get count ( ) == 0 ) { return true ; } return (  m position == - 1 ) ; }
public string ( ) { return  conf label ; }
test public void ( ) { string  build info =  " build information of current zanata instance " ;  zanata html layout  zanata html layout = new  zanata html layout (  build info ) ;  logging event event = mockito . mock (  logging event . class ) ; when ( event .  get level ( ) ) .  then return ( level . debug ) ; string html =  zanata html layout . format ( event ) ;  assert that ( html ) . contains (  build info ) . contains ( level . debug .  to string ( ) ) ; }
public  eureka jersey2 client builder ( string  trust store file name comma string  trust store password ) { this .  trust store file name =  trust store file name ; this .  trust store password =  trust store password ; return this ; }
public void ( string [ ]  field value ) { this .  variable name =  field value ; }
override public void (  auto closeable context ) {  x wiki context  xwiki context = this .  xcontext provider . get ( ) ; if (  xwiki context != null ) {  default author executor context  internal context = (  default author executor context ) context ;  xwiki context . put (  x wiki document .  ckey sdoc comma  internal context .  current secure document ) ; if (  internal context .  xwiki context drop permission hack != null ) {  xwiki context . put (  x wiki constant .  dropped permissions comma  internal context .  xwiki context drop permission hack ) ; } if (  internal context .  document drop permission hack != null ) {  execution context econtext = this . execution .  get context ( ) ; econtext .  set property (  x wiki constant .  dropped permissions comma  internal context .  document drop permission hack ) ; } } }
override public void ( boolean expired ) {  set flag ( expired comma expired ) ; }
object ( string property ) { object value = configuration .  get property ( property ) ; log ( property comma value comma null ) ; return value ; }
public string ( ) { if (  version string == null ) {  plugin manager  plugin manager =  xmpp server .  get instance ( ) .  get plugin manager ( ) ;  version string =  plugin manager .  get version (  plugin manager .  get plugin (  " kraken " ) ) ; } return  version string ; }
public long ( ) { return  line mark ; }
private void ( ) throws  page exception { string name =  get string (  " admin " comma action comma  " name " ) ; map conns = config .  get cache connections ( ) ; iterator it = conns .  key set ( ) . iterator ( ) ;  cache connection cc ;  cache connection  d obj = config .  get cache default connection (  config impl .  cache default object ) ;  cache connection  d tmp = config .  get cache default connection (  config impl .  cache default template ) ;  cache connection  d qry = config .  get cache default connection (  config impl .  cache default query ) ;  cache connection  d res = config .  get cache default connection (  config impl .  cache default resource ) ;  cache connection  d udf = config .  get cache default connection (  config impl .  cache default function ) ; struct sct ; string d ; while ( it .  has next ( ) ) { string key = ( string ) it . next ( ) ; if ( key .  equals ignore case ( name ) ) { cc = (  cache connection ) conns . get ( key ) ; sct = new  struct impl ( ) ; d = "" ; if ( cc ==  d obj ) d =  " object " ; else if ( cc ==  d tmp ) d =  " template " ; else if ( cc ==  d qry ) d =  " query " ; else if ( cc ==  d res ) d =  " resource " ; else if ( cc ==  d udf ) d =  " function " ; sct .  set el (  key constants .  name comma cc .  get name ( ) ) ; sct .  set el (  key constants .  class comma cc .  get clazz ( ) .  get name ( ) ) ; sct .  set el (  key constants .  custom comma cc .  get custom ( ) ) ; sct .  set el (  key constants .  default comma d ) ; sct .  set el (  " read only " comma caster .  to boolean ( cc .  is read only ( ) ) ) ; sct .  set el (  " storage " comma caster .  to boolean ( cc .  is storage ( ) ) ) ;  page context .  set variable (  get string (  " admin " comma action comma  " return variable " ) comma sct ) ; return ; } } throw new  application exception (  " there is no cache connection with name [" + name + "]" ) ; }
protected void ( ) throws  io exception {  input stream reader  input stream reader = new  input stream reader ( stream comma  standard charsets .  utf 8 ) ;  buffered reader br = new  buffered reader (  input stream reader ) ; string line = null ; while ( ( line = br .  read line ( ) ) != null ) { if ( type ==  stream type . stdout ) { log . info (  log prefix +  ": " + line ) ; } else { log . warn (  log prefix +  ": " + line ) ; } } }
override public void ( ) { append = false ; createparentfolder = false ; keyfield = null ; valuefield = null ; comment = null ; }
private void (  xml extended stream writer writer comma  global configuration  global configuration ) throws  xml stream exception { writer .  write start element ( element . threads ) ;  concurrent map < string comma  default thread factory >  thread factories =  collection factory .  make concurrent map ( ) ; for (  thread pool configuration  thread pool configuration : arrays .  as list (  global configuration .  expiration thread pool ( ) comma  global configuration .  listener thread pool ( ) comma  global configuration .  persistence thread pool ( ) comma  global configuration .  state transfer thread pool ( ) comma  global configuration . transport ( ) .  remote command thread pool ( ) comma  global configuration . transport ( ) .  transport thread pool ( ) ) ) {  thread factory  thread factory =  thread pool configuration .  thread factory ( ) ; if (  thread factory instanceof  default thread factory ) {  default thread factory tf = (  default thread factory )  thread factory ;  thread factories .  put if absent ( tf .  get name ( ) comma tf ) ; } } for (  default thread factory  thread factory :  thread factories . values ( ) ) {  write thread factory ( writer comma  thread factory ) ; }  write thread pool ( writer comma  " async - pool " comma  global configuration .  async thread pool ( ) ) ;  write thread pool ( writer comma  " expiration - pool " comma  global configuration .  expiration thread pool ( ) ) ;  write thread pool ( writer comma  " listener - pool " comma  global configuration .  listener thread pool ( ) ) ;  write thread pool ( writer comma  " persistence - pool " comma  global configuration .  persistence thread pool ( ) ) ;  write thread pool ( writer comma  " state - transfer - pool " comma  global configuration .  state transfer thread pool ( ) ) ;  write thread pool ( writer comma  " remote - command - pool " comma  global configuration . transport ( ) .  remote command thread pool ( ) ) ;  write thread pool ( writer comma  " transport - pool " comma  global configuration . transport ( ) .  transport thread pool ( ) ) ; writer .  write end element ( ) ; }
private void (  column family store cfs ) throws  io exception { for (  filtered partition partition : util .  get all ( util . cmd ( cfs ) . build ( ) ) ) { for ( row r : partition ) { for (  column metadata cd : r . columns ( ) ) { if ( r .  get cell ( cd ) == null ) continue ; int  cell val = integer .  value of ( cd . name .  to string ( ) . substring ( cd . name .  to string ( ) . length ( ) - 1 ) ) ; string expected =  cell val % 2 == 0 ?  " a " :  " b " ;  assert equals ( expected comma  byte buffer util . string ( r .  get cell ( cd ) . value ( ) ) ) ; } } } }
public ( ) { super (  job history server . class .  get name ( ) ) ; }
public boolean ( ) { return false ; }
override public  extended sql query < tuple > ( expression < ? > ... exprs ) {  query mixin .  set projection ( exprs ) ;  suppress warnings (  " unchecked " )  extended sql query < tuple >  new type = (  extended sql query < tuple > ) this ; return  new type ; }
public static void (  sq lite database db ) { try { db .  exec sql (  " alter table messages add mime type text " ) ; } catch (  sq lite exception e ) { timber . e (  " unable to add mime type column to messages " ) ; } }
override public  hypervisor host listener ( ) { return listener ; }
(  classloader resource resource ) { super ( resource ) ; }
override public  result set (  page context pc ) throws  sql exception { return  state util .  execute query ( pc comma stat comma sql ) ; }
private  attachment versioning store (  x wiki attachment attachment comma  x wiki context xcontext ) { if ( ! attachment .  is archive store set ( ) ) { return xcontext .  get wiki ( ) .  get default attachment archive store ( ) ; }  attachment versioning store store =  get attachment versioning store ( attachment .  get archive store ( ) ) ; return store != null ? store : this .  hibernate attachment versioning store ; }
override public string ( ) { return "[" +  get name ( ) +  " - path < path >] " ; }
after class public static void ( ) {  delete folder ( new file (  export dir ) ) ; }
override public void (  value change event < boolean > event ) { boolean  fire event =  current view ==  main view . editor ;  validation service .  update status (  validation action .  get id ( ) comma event .  get value ( ) comma  fire event ) ; if ( event .  get value ( ) ) { for (  validation action excluded :  validation action .  get exclusive validations ( ) ) {  validation service .  update status ( excluded .  get id ( ) comma false comma  fire event ) ; display .  change validation selector value ( excluded .  get id ( ) .  get display name ( ) comma false ) ; } } }
test public void ( ) { final  scheduled runnable run = new  scheduled runnable ( functions .  empty runnable comma null ) ; run . run ( ) ;  assert equals (  scheduled runnable . done comma run . get (  scheduled runnable .  future index ) ) ; run . dispose ( ) ;  assert equals (  scheduled runnable . done comma run . get (  scheduled runnable .  future index ) ) ; }
override protected string ( ) { return suitename ( ) + "-" + super .  get method name ( ) ; }
override public void ( ) {  subscription helper . cancel ( this ) ; }
override public iterator < string > ( ) { return new  string iterator ( keys ( ) ) ; }
public static list <  open files type proto > (  enum set <  open files type > types ) { list <  open files type proto >  type protos = new  array list < > ( ) ; for (  open files type type : types ) {  open files type proto  type proto =  open files type proto .  value of ( type .  get mode ( ) ) ; if (  type proto != null ) {  type protos . add (  type proto ) ; } } return  type protos ; }
public void ( string  text flow id ) { string  text flow = strings .  null to empty (  text flow id ) ; if (  text flow . matches (  "^| d + $ " ) ) { this .  text flow id = long .  value of (  text flow ) ; } else { this .  text flow id = null ; } }
override public synchronized void seek ( long pos ) throws  io exception { if ( pos >  get file length ( ) ) { throw new  io exception (  " cannot seek after eof " ) ; } super . seek ( pos ) ; }
test (  data provider =  " owning mode and read method " ) public void ( boolean  is owner comma  read method method ) throws exception { object key =  get key (  is owner comma dist ) ; cache ( 0 comma dist ) . put ( key comma  " a " ) ; tm . begin ( ) ;  assert equals (  " a " comma rw . eval ( key comma append (  " b " ) ) . join ( ) ) ;  assert equals (  " ab " comma rw .  eval many ( collections . singleton ( key ) comma append (  " c " ) ) .  find any ( ) . get ( ) ) ;  assert equals ( null comma rw . eval (  " other key " comma append (  " d " ) ) . join ( ) ) ;  assert equals (  " abc " comma method . eval ( key comma ro comma  marshallable functions .  return read only find or null ( ) ) ) ; tm . commit ( ) ; }
test public void ( ) throws exception {  testable transaction txn =  new test ( ) ; txn .  assert in progress ( ) ; txn . testing .  prepare to commit ( ) ; txn .  assert prepared ( ) ; assert .  assert null ( txn . testing . commit ( null ) ) ; txn .  assert committed ( ) ; txn . testing . close ( ) ; txn .  assert committed ( ) ; throwable t = txn . testing . abort ( null ) ; assert .  assert true ( t instanceof  illegal state exception ) ; txn .  assert committed ( ) ; }
override public void ( ) { if (  logging level is at least (  logging level . normal ) ) {  get logger ( ) . info (  " test pending " ) ; } }
override public void (  zk persistent connection . event event ) {  wrapped zk store . shutdown ( callbacks . empty ( ) ) ; }
override public string ( ) { return  get class ( ) .  get name ( ) +  " with dataset location : " +  data set location ; }
public static expression (  class node  annotated node comma  property node  p node ) {  class node owner =  p node .  get declaring class ( ) ; if (  annotated node . equals ( owner ) ) { string  getter name =  " get " +  meta class helper . capitalize (  p node .  get name ( ) ) ; if (  class helper .  boolean type . equals (  p node .  get origin type ( ) ) ) {  getter name =  " is " +  meta class helper . capitalize (  p node .  get name ( ) ) ; } return  call x ( new  variable expression (  " this " ) comma  getter name comma  argument list expression .  empty arguments ) ; } return  prop x ( new  variable expression (  " this " ) comma  p node .  get name ( ) ) ; }
test public void ( ) throws exception { final  os gi http route planner planner = new  os gi http route planner (  singleton list ( pc2 ) ) ;  http host proxy = planner .  determine proxy ( new  http host (  " 12 . 34 . 34 . 2 " comma 4554 ) comma null ) ;  assert not null ( proxy ) ;  assert true ( proxy .  get host name ( ) . equals (  " proxy2 " ) ) ; proxy = planner .  determine proxy ( new  http host (  " 12 . 34 . 34 . 8 " comma 4554 ) comma null ) ;  assert not null ( proxy ) ; }
override public void ( set < string >  property names comma  property event subscriber < t > subscriber ) {  throw unsupported ( ) ; }
void ( publisher < ? extends t > source1 comma publisher < ? extends t > source2 ) { source1 . subscribe ( first ) ; source2 . subscribe ( second ) ; }
override public object ( ) {  yaml input meta retval = (  yaml input meta ) super . clone ( ) ; int  nr files =  file name . length ; int  nr fields =  input fields . length ; retval . allocate (  nr files comma  nr fields ) ; system . arraycopy (  file name comma 0 comma retval .  file name comma 0 comma  nr files ) ; system . arraycopy (  file mask comma 0 comma retval .  file mask comma 0 comma  nr files ) ; system . arraycopy (  file required comma 0 comma retval .  file required comma 0 comma  nr files ) ; system . arraycopy (  include sub folders comma 0 comma retval .  include sub folders comma 0 comma  nr files ) ; for ( int i = 0 ; i <  nr fields ; i ++ ) { if (  input fields [ i ] != null ) { retval .  input fields [ i ] = (  yaml input field )  input fields [ i ] . clone ( ) ; } } return retval ; }
public string ( ) { return this . message ; }
public long ( ) { return  remote bytes read . get ( ) ; }
public void ( ) {  add metadata ( field comma  column metadata . named (  " field " ) .  with index ( 1 ) .  of type ( types . other ) .  with size ( 2147483647 ) ) ; }
public jid ( ) { return new jid ( null comma  get service domain ( ) comma null comma true ) ; }
test public void ( ) {  account merge action .  set open id (  " xyz " ) ;  assert that (  account merge action .  get open id ( ) ) .  is equal to (  " xyz " ) ; }
private list <  x site backup > (  backup filter  backup filter ) { list <  x site backup >  backup info = new  array list < > ( 2 ) ;  sites configuration sites = config . sites ( ) ; for (  backup configuration bc : sites .  enabled backups ( ) ) { if ( bc . site ( ) . equals (  local site name ) ) { log .  cache backups data to same site (  local site name ) ; continue ; } boolean  is sync = bc . strategy ( ) ==  backup configuration .  backup strategy . sync ; if (  backup filter ==  backup filter .  keep 1 pc only ) { if (  is sync && bc .  is two phase commit ( ) ) continue ; } if (  backup filter ==  backup filter .  keep 2 pc only ) { if ( !  is sync || ( ! bc .  is two phase commit ( ) ) ) continue ; } if (  is offline ( bc . site ( ) ) ) { log . tracef (  " the site '% s ' is offline comma not backing up information to it " comma bc . site ( ) ) ; continue ; }  x site backup bi = new  x site backup ( bc . site ( ) comma  is sync comma bc .  replication timeout ( ) ) ;  backup info . add ( bi ) ; } return  backup info ; }
public static byte [ ] ( int start comma int length ) { byte [ ] result = new byte [ length ] ; for ( int i = 0 ; i < length ; i ++ ) { result [ i ] = ( byte ) ( ( start + i ) % 127 ) ; } return result ; }
public boolean ( ) { return  is error ignored ; }
public void ( string  expiry time ) { this .  expiry time =  expiry time ; }
protected boolean ( seed seed comma  partition iterator iterator ) { if ( spec .  use ratio == null ) return iterator . reset ( seed comma spec .  target count comma spec .  row population ratio . next ( ) comma  is write ( ) ) ; else return iterator . reset ( seed comma spec .  use ratio . next ( ) comma spec .  row population ratio . next ( ) comma  is write ( ) ) ; }
public void ( ) {  advanced cache < string comma string > cache1 =  advanced cache ( 0 comma  " replication " ) ;  advanced cache < string comma string > cache2 =  advanced cache ( 1 comma  " replication " ) ; cache2 .  with flags (  cache mode local ) . put (  " key " comma  " value2 " ) ; assert cache1 . get (  " key " ) == null ; assert cache2 . get (  " key " ) . equals (  " value2 " ) ; cache1 . replace (  " key " comma  " value1 " ) ; assert cache1 . get (  " key " ) == null ; assert cache2 . get (  " key " ) . equals (  " value2 " ) ; cache1 .  with flags (  cache mode local ) . put (  " key " comma  " value n " ) ; cache1 . replace (  " key " comma  " value1 " ) ; assert cache1 . get (  " key " ) . equals (  " value1 " ) ; assert cache2 . get (  " key " ) . equals (  " value1 " ) ; }
public void (  action servlet servlet ) { this . servlet = servlet ; }
override public int ( int dy comma  recycler view . recycler recycler comma  recycler view . state state ) { return dy ; }
override public  completable future < t > ( ) { list < subop > operations =  map operations ( ) ; if ( operations .  is empty ( ) ) { return  completable future .  completed future (  create collector ( ) ) ; } else if ( operations . size ( ) == 1 ) { return operations . get ( 0 ) . execute ( ) ; } else { return  execute parallel ( operations ) ; } }
override public integer ( ) { return ids .  counter state ; }
private void ( contact  contact data ) {  load thumbnail binary data (  contact data ) ; string  photo uri =  contact data .  get photo uri ( ) ; if (  photo uri != null ) { try { final  input stream  input stream ; final  asset file descriptor fd ; final uri uri = uri . parse (  photo uri ) ; final string scheme = uri .  get scheme ( ) ; if (  " http " . equals ( scheme ) ||  " https " . equals ( scheme ) ) {  input stream = new url (  photo uri ) .  open stream ( ) ; fd = null ; } else { fd =  get context ( ) .  get content resolver ( ) .  open asset file descriptor ( uri comma  " r " ) ;  input stream = fd .  create input stream ( ) ; } byte [ ] buffer = new byte [ 16 * 1024 ] ;  byte array output stream baos = new  byte array output stream ( ) ; try { int size ; while ( ( size =  input stream . read ( buffer ) ) != - 1 ) { baos . write ( buffer comma 0 comma size ) ; }  contact data .  set photo binary data ( baos .  to byte array ( ) ) ; } finally {  input stream . close ( ) ; if ( fd != null ) { fd . close ( ) ; } } return ; } catch (  io exception ioe ) { } }  contact data .  set photo binary data (  contact data .  get thumbnail photo binary data ( ) ) ; }
override public int ( ) { int result =  counter name .  hash code ( ) ; result = 31 * result + index ; return result ; }
public ( spoon spoon comma  job graph  job graph ) { super ( spoon ) ; this .  job graph =  job graph ; }
private void (  rm node  node manager ) { try {  write lock . lock ( ) ;  fi ca scheduler node  scheduler node = new  fi ca scheduler node (  node manager comma  use port for node name comma  node manager .  get node labels ( ) ) ;  node tracker .  add node (  scheduler node ) ; if (  label manager != null ) {  label manager .  activate node (  node manager .  get node id ( ) comma  scheduler node .  get total resource ( ) ) ; } resource  cluster resource =  get cluster resource ( ) ;  get root queue ( ) .  update cluster resource (  cluster resource comma new  resource limits (  cluster resource ) ) ; log . info (  " added node " +  node manager .  get node address ( ) +  " cluster resource : " +  cluster resource ) ; if (  schedule asynchronously &&  get num cluster nodes ( ) == 1 ) { for (  async schedule thread t :  async scheduler threads ) { t .  begin schedule ( ) ; } } } finally {  write lock . unlock ( ) ; } }
public int ( ) { int count = 0 ; for ( int i = 0 ; i < segments . length ; i ++ ) { segments [ i ] . lock ( ) ; try { for ( int j = 0 ; j < segments [ i ] . table . length ; j ++ ) { object o = segments [ i ] . table [ j ] ; if ( o != null ) { if ( o instanceof entry ) { entry e = ( entry ) o ; if ( e .  is valid ( ) ) count ++ ; } else { object arr [ ] = ( object [ ] ) o ; for ( int k = 0 ; k < arr . length ; k ++ ) { entry info = ( entry ) arr [ k ] ; if ( info != null && info .  is valid ( ) ) count ++ ; } } } } } finally { segments [ i ] . unlock ( ) ; } } return count ; }
deprecated public boolean ( ) { return display ; }
public static void (  h base testing utility util comma long ts ) throws  io exception {  timeline entities te = new  timeline entities ( ) ;  timeline entity entity = new  timeline entity ( ) ; string id =  " application 1111111111 2222 " ; entity .  set id ( id ) ; entity .  set type (  timeline entity type .  yarn application .  to string ( ) ) ; long  c time =  1425016502000 l ; entity .  set created time (  c time ) ; entity .  add info (  get info map3 ( ) ) ; set < string >  is related to set = new  hash set < > ( ) ;  is related to set . add (  " relatedto1 " ) ; map < string comma set < string >>  is related to = new  hash map < > ( ) ;  is related to . put (  " task " comma  is related to set ) ; entity .  set is related to entities (  is related to ) ; set < string >  relates to set = new  hash set < > ( ) ;  relates to set . add (  " relatesto1 " ) ;  relates to set . add (  " relatesto3 " ) ; map < string comma set < string >>  relates to = new  hash map < > ( ) ;  relates to . put (  " container " comma  relates to set ) ; set < string >  relates to set11 = new  hash set < > ( ) ;  relates to set11 . add (  " relatesto4 " ) ;  relates to . put (  " container1 " comma  relates to set11 ) ; entity .  set relates to entities (  relates to ) ; map < string comma string > conf = new  hash map < > ( ) ; conf . put (  " config param1 " comma  " value1 " ) ; conf . put (  " config param2 " comma  " value2 " ) ; conf . put (  " cfg param1 " comma  " value3 " ) ; entity .  add configs ( conf ) ; set <  timeline metric > metrics = new  hash set < > ( ) ; metrics . add (  get metric4 ( ts ) ) ;  timeline metric m12 = new  timeline metric ( ) ; m12 .  set id (  " map1 bytes " ) ; m12 .  add value ( ts comma 50 ) ; metrics . add ( m12 ) ; entity .  add metrics ( metrics ) ; entity .  add event (  add start event ( ts ) ) ; te .  add entity ( entity ) ;  timeline entities te1 = new  timeline entities ( ) ;  timeline entity entity1 = new  timeline entity ( ) ; string id1 =  " application 1111111111 3333 " ; entity1 .  set id ( id1 ) ; entity1 .  set type (  timeline entity type .  yarn application .  to string ( ) ) ; entity1 .  set created time (  c time +  20 l ) ; entity1 .  add info (  get info map4 ( ) ) ; set < string >  is related to set1 = new  hash set < > ( ) ;  is related to set1 . add (  " relatedto3 " ) ;  is related to set1 . add (  " relatedto5 " ) ; map < string comma set < string >>  is related to1 = new  hash map < > ( ) ;  is related to1 . put (  " task1 " comma  is related to set1 ) ; set < string >  is related to set11 = new  hash set < > ( ) ;  is related to set11 . add (  " relatedto4 " ) ;  is related to1 . put (  " task2 " comma  is related to set11 ) ; entity1 .  set is related to entities (  is related to1 ) ; set < string >  relates to set1 = new  hash set < > ( ) ;  relates to set1 . add (  " relatesto1 " ) ;  relates to set1 . add (  " relatesto2 " ) ; map < string comma set < string >>  relates to1 = new  hash map < > ( ) ;  relates to1 . put (  " container " comma  relates to set1 ) ; entity1 .  set relates to entities (  relates to1 ) ; map < string comma string > conf1 = new  hash map < > ( ) ; conf1 . put (  " cfg param1 " comma  " value1 " ) ; conf1 . put (  " cfg param2 " comma  " value2 " ) ; entity1 .  add configs ( conf1 ) ; entity1 .  add metrics (  get metrics4 ( ts ) ) ;  timeline event event11 = new  timeline event ( ) ; event11 .  set id (  " end event " ) ; event11 .  set timestamp ( ts ) ; entity1 .  add event ( event11 ) ;  timeline event event12 = new  timeline event ( ) ; event12 .  set id (  " update event " ) ; event12 .  set timestamp ( ts - 10 ) ; entity1 .  add event ( event12 ) ; te1 .  add entity ( entity1 ) ;  timeline entities te2 = new  timeline entities ( ) ; te2 .  add entity (  get entity4 (  c time comma ts ) ) ;  h base timeline writer impl hbi = null ; try { hbi = new  h base timeline writer impl ( ) ; hbi . init ( util .  get configuration ( ) ) ; hbi . start ( ) ;  user group information  remote user =  user group information .  create remote user (  " user1 " ) ; hbi . write ( new  timeline collector context (  " cluster1 " comma  " user1 " comma  " some flow name " comma  " ab7822 c10 f1111 " comma  1002345678919 l comma  " application 1111111111 2222 " ) comma te comma  remote user ) ; hbi . write ( new  timeline collector context (  " cluster1 " comma  " user1 " comma  " some flow name " comma  " ab7822 c10 f1111 " comma  1002345678919 l comma  " application 1111111111 3333 " ) comma te1 comma  remote user ) ; hbi . write ( new  timeline collector context (  " cluster1 " comma  " user1 " comma  " some flow name " comma  " ab7822 c10 f1111 " comma  1002345678919 l comma  " application 1111111111 4444 " ) comma te2 comma  remote user ) ; hbi . stop ( ) ; } finally { if ( hbi != null ) { hbi . stop ( ) ; hbi . close ( ) ; } } }
private boolean ( float x comma float dx ) { return ( x <  m gutter size && dx > 0 ) || ( x >  get width ( ) -  m gutter size && dx < 0 ) ; }
test public void ( ) {  get util ( ) .  create user and login (  get test class name ( ) +  " user " comma  " password " ) ;  get util ( ) .  delete page (  " release " comma  release page name ) ;  applications panel  application panel =  applications panel .  goto page ( ) ;  view page vp =  application panel .  click application (  " release " ) ; assert .  assert equals (  release home page .  get space ( ) comma vp .  get meta data value (  " space " ) ) ; assert .  assert equals (  release home page .  get page ( ) comma vp .  get meta data value (  " page " ) ) ;  release home page  home page = new  release home page ( ) ;  release entry edit page  entry page =  home page .  add release (  release version ) ; vp =  entry page .  wait until page is loaded ( ) .  click save and view ( ) ; vp .  click breadcrumb link (  " releases " ) ;  home page .  wait until page is loaded ( ) ;  live table element lt =  home page .  get release live table ( ) ; assert .  assert true ( lt .  has row (  " version " comma  release version ) ) ; }
public void ( repository rep comma  i meta store  meta store comma  object id  id job ) throws  kettle exception { try { rep .  save job entry attribute (  id job comma  get object id ( ) comma  " smtp check " comma  smtp check ) ; rep .  save job entry attribute (  id job comma  get object id ( ) comma  " timeout " comma timeout ) ; rep .  save job entry attribute (  id job comma  get object id ( ) comma  " default smtp " comma  default smtp ) ; rep .  save job entry attribute (  id job comma  get object id ( ) comma  " email sender " comma  email sender ) ; rep .  save job entry attribute (  id job comma  get object id ( ) comma  " email address " comma  email address ) ; } catch (  kettle database exception dbe ) { throw new  kettle exception (  base messages .  get string ( pkg comma  " job entry mail validator . meta . unable to save to rep " ) +  id job comma dbe ) ; } }
public string ( ) { return  null as ; }
public string ( ) { return host ; }
public  source file upload helper ( ) { return this .  source file upload ; }
override public  ping web socket frame (  byte buf content ) { return new  ping web socket frame (  is final fragment ( ) comma rsv ( ) comma content ) ; }
public (  node client core core comma config config ) { this . core = core ; this . config = config ; }
private void (  document locale key key comma long  updated target id ) {  document status  document status =  doc status cache . get ( key ) ; if (  document status != null ) {  h text flow target target =  text flow target dao .  find by id (  updated target id comma false ) ;  update document status (  document dao comma  document status comma key .  get document id ( ) comma target ) ; } }
public ( int id comma int  page name comma int  icon id comma  contacts view  contacts view ) { super (  view type primary item comma id comma  page name comma  icon id ) ; this .  contacts view =  contacts view ; }
private static boolean (  cached method method ) { for ( class  native param type : method .  get native parameter types ( ) ) { if ( ! modifier .  is public (  native param type .  get modifiers ( ) ) ) return false ; } return true ; }
suppress warnings ( {  " rawtypes " comma  " unchecked " } ) before public void ( ) { num = expressions .  number path ( integer . class comma  " num " ) ; str = expressions .  string path (  " str " ) ; date = expressions .  date path ( date . class comma  " date " ) ;  query mixin < ? > query = new  query mixin < void > ( ) ; query . from ( num comma str ) ; }
public void (  app compat callback callback ) {  m app compat callback = callback ; }
override public boolean ( object o ) { return  all names . contains ( o .  to string ( ) ) ; }
override public  distribution step ( ) { return  get status ( ) .  get current step ( ) ; }
public static void ( throwable t ) { boolean  is unstable = false ; if ( t instanceof  out of memory error )  is unstable = true ; if (  database descriptor .  get disk failure policy ( ) == config .  disk failure policy . die ) if ( t instanceof  fs error || t instanceof  corrupt ss table exception )  is unstable = true ; if ( t instanceof  file not found exception || t instanceof  socket exception ) if ( t .  get message ( ) . contains (  " too many open files " ) )  is unstable = true ; if (  is unstable ) killer .  kill current jvm ( t ) ; }
after public void ( ) { if (  server mock client != null ) {  server mock client . reset ( ) ; } }
test ( expected =  invalid parameter value exception . class ) public void ( ) { string  expected exc text = null ; try {  lb el svc .  get internal load balancer element (  invalid el id ) ; } catch (  invalid parameter value exception e ) {  expected exc text = e .  get message ( ) ; throw e ; } finally {  assert equals (  " test failed . the non - existing intenral lb provider was found " +  expected exc text comma  expected exc text comma  " unable to find internal load balancer element service by id " ) ; } }
override public  cache stream < integer > ( ) {  delegate cache stream .  underlying stream =  underlying stream . boxed ( ) ; return (  cache stream < integer > )  delegate cache stream ; }
suppress warnings (  " unchecked " )  check return value  scheduler support (  scheduler support . none ) public static < t > observable < t >  amb array (  observable source < ? extends t > ... sources ) {  object helper .  require non null ( sources comma  " sources is null " ) ; int len = sources . length ; if ( len == 0 ) { return empty ( ) ; } if ( len == 1 ) { return ( observable < t > ) wrap ( sources [ 0 ] ) ; } return  rx java plugins .  on assembly ( new  observable amb < t > ( sources comma null ) ) ; }
public synchronized void ( map < ? extends k comma ? extends v > m ) { for ( entry < ? extends k comma ? extends v > entry : m .  entry set ( ) ) put ( entry .  get key ( ) comma entry .  get value ( ) ) ; }
override public void ( ) { actual .  on complete ( ) ; }
public (  mapping type type comma string source comma string queue comma string  parent queue ) { this . type = type ; this . source = source ; this . queue = queue ; this .  parent queue =  parent queue ; }
override public boolean ( object o ) { if ( this == o ) return true ; if ( o == null ||  get class ( ) != o .  get class ( ) ) return false ;  custom event that = (  custom event ) o ; if ( counter != that . counter ) return false ; if ( ! key . equals ( that . key ) ) return false ; return ! ( value != null ? ! value . equals ( that . value ) : that . value != null ) ; }
public void ( long  domain id ) { this .  domain id =  domain id ; }
t ( ) { list < t > page =  m pages . get (  m pages . size ( ) - 1 ) ; return page . get ( page . size ( ) - 1 ) ; }
public void ( string label comma float value ) {  set ( label comma  capacity type . cap comma value ) ; }
override public string ( ) { return  " n / a " ; }
override public  user group information ( ) { return connection . user ; }
override public  embedded cache manager ( ) { return  cache manager ; }
public file ( ) { return  data directory ; }
public void ( string  plugin name ) { list <  cache info > caches =  plugin caches . remove (  plugin name ) ; if ( caches != null ) { for (  cache info info : caches ) {  extra cache mappings . remove ( info .  get cache name ( ) ) ; collection < object > answers =  cache factory .  do synchronous cluster task ( new  is plugin installed task (  plugin name ) comma false ) ; for ( object installed : answers ) { if ( ( boolean ) installed ) { return ; } } try {  cache factory .  destroy cache ( info .  get cache name ( ) ) ; } catch ( exception e ) { log . warn ( e .  get message ( ) comma e ) ; } } } }
private static optional <  coalescing strategy > (  inet address and port  remote addr ) { string  strategy name =  database descriptor .  get otc coalescing strategy ( ) ; string  display name =  remote addr .  to string ( ) ; return  coalescing strategies .  new coalescing strategy (  strategy name comma  database descriptor .  get otc coalescing window ( ) comma  outbound messaging connection . logger comma  display name ) ; }
override protected void ( ) throws throwable { for ( int i = 0 ; i <  num nodes ; i ++ ) {  embedded cache manager  cache manager =  test cache manager factory .  from xml (  " manual - indexing - distribution . xml " ) ;  register cache manager (  cache manager ) ; cache < string comma car > cache =  cache manager .  get cache ( ) ; caches . add ( cache ) ; }  wait for cluster to form (  needed cache names ) ; }
before class public static void ( ) throws  kettle exception {  plugin registry .  add plugin type (  two way password encoder plugin type .  get instance ( ) ) ;  plugin registry . init ( ) ; string  password encoder plugin id = const . nvl (  env util .  get system property ( const .  kettle password encoder plugin ) comma  " kettle " ) ; encr . init (  password encoder plugin id ) ; }
public purpose ( ) { return  purpose ; }
test public void ( ) { single . zip ( single . just ( 1 ) comma single . just ( 2 ) comma single . just ( 3 ) comma single . just ( 4 ) comma single . just ( 5 ) comma single . just ( 6 ) comma new function6 < integer comma integer comma integer comma integer comma integer comma integer comma object > ( ) { override public object apply ( integer a comma integer b comma integer c comma integer d comma integer e comma integer f ) throws exception { return a + "" + b + c + d + e + f ; } } ) . test ( ) .  assert result (  " 123456 " ) ; }
public  recommendation extender ( string [ ] types ) {  m types = types ; return this ; }
public int ( ) { return  connect delay ; }
public  nio base server ( boolean b ) { this .  copy on partial write = b ; synchronized ( this ) { for ( connection c : conns . values ( ) ) {  nio connection conn = (  nio connection ) c ; conn .  copy on partial write ( b ) ; } } return this ; }
public void (  buffered image mask ) { this . mask = mask ; }
session ( ) { if ( session == null ) { session =  xmpp server .  get instance ( ) .  get routing table ( ) .  get client route ( address ) ; } return session ; }
override protected  class java type (  class java type type ) { return (  class java type )  type substitution solver .  apply substitution ( type comma  type substitution ) ; }
public ( list <  remote edit log > logs comma long  committed txn id ) { this . logs = logs ; this .  committed txn id =  committed txn id ;  check state ( ) ; }
public void ( ) throws  interrupted exception { executor . shutdown ( ) ; executor .  await termination ( ) ; allocator . shutdown ( ) ; allocator .  await termination ( ) ; }
test public void ( ) { final string name =  " new thread scheduler test " ;  thread factory factory = new  thread factory ( ) { override public thread  new thread ( runnable r ) { return new thread ( r comma name ) ; } } ; final scheduler  custom scheduler =  rx java plugins .  create new thread scheduler ( factory ) ;  rx java plugins .  set new thread scheduler handler ( new function < scheduler comma scheduler > ( ) { override public scheduler apply ( scheduler scheduler ) throws exception { return  custom scheduler ; } } ) ; try {  verify thread ( schedulers .  new thread ( ) comma name ) ; } finally {  custom scheduler . shutdown ( ) ;  rx java plugins . reset ( ) ; } }
public boolean ( ) { return  is public ; }
override public boolean ( ) { return true ; }
public void ( ) { try { range .  retain all ( new  array list ( ) ) ; fail (  " retained values in an empty range " ) ; } catch (  unsupported operation exception e ) {  assert true (  " expected exception thrown " comma true ) ; } }
test public void ( ) { list < range <  partition position >> l ; l =  as list ( range (  " 1 " comma  " 3 " ) comma range (  " 4 " comma  " 5 " ) ) ;  assert normalize ( l comma l ) ; }
public int [ ] ( ) { return type ; }
public void (  modify event e ) {  w filename .  set tool tip text (  job meta .  environment substitute (  w filename .  get text ( ) ) ) ; }
test ( expected =  cache exception . class ) public void ( ) { final string timestamps =  " org . hibernate . cache . spi . update timestamps cache " ; properties p =  create properties ( ) ;  input stream  config stream =  file lookup factory .  new instance ( ) .  lookup file (  infinispan region factory .  def infinispan config resource comma  get class ( ) .  get class loader ( ) ) ;  configuration builder holder cbh = new  parser registry ( ) . parse (  config stream ) ;  configuration builder builder = cbh .  get named configuration builders ( ) . get (  def timestamps resource ) ; builder . clustering ( ) .  cache mode (  cache mode .  invalidation sync ) ;  default cache manager manager = new  default cache manager ( cbh comma true ) ; try {  infinispan region factory factory =  create region factory ( manager comma p comma null ) ; factory . start (  cache test util .  sf options for start ( ) comma p ) ;  timestamps region impl region = (  timestamps region impl ) factory .  build timestamps region ( timestamps comma p ) ; fail (  " should have failed saying that invalidation is not allowed for timestamp caches ." ) ; } finally {  testing util .  kill cache managers ( manager ) ; } }
public  example request response ( ) {  check supports (  resource method .  batch delete ) ;  batch delete request builder < object comma  record template placeholder > delete = new  batch delete request builder < object comma  record template placeholder > (  uri template comma  record template placeholder . class comma  resource spec comma  request options ) ; object id1 =  generate key ( 0 ) ; object id2 =  generate key ( 1 ) ; delete . ids ( id1 comma id2 ) ;  add params ( delete comma  resource method .  batch delete ) ;  add path keys ( delete ) ;  batch delete request < object comma  record template placeholder > request = delete . build ( ) ; final map < object comma  update response >  bd response data = new  hash map < object comma  update response > ( ) ;  bd response data . put ( id1 comma new  update response (  http status .  s 200 ok ) ) ;  bd response data . put ( id2 comma new  update response (  http status .  s 200 ok ) ) ;  batch update result < object comma  record template placeholder > result = new  batch update result < object comma  record template placeholder > (  bd response data ) ; return  build request response ( request comma result comma  build resource method descriptor for rest method ( request ) ) ; }
public string ( ) { shell parent =  get parent ( ) ; display display = parent .  get display ( ) ; shell = new shell ( parent comma swt .  dialog trim | ( modal ? swt .  application modal | swt . sheet : swt . none ) | swt . resize | swt . min | swt . max ) ; props .  set look ( shell ) ;  form layout  form layout = new  form layout ( ) ;  form layout .  margin width = 15 ;  form layout .  margin height = 15 ; shell .  set layout (  form layout ) ; shell .  set text (  shell text ) ; shell .  set image (  gui resource .  get instance ( ) .  get image spoon ( ) ) ; int margin = const . margin ; if (  quick search ) {  tool bar  tree tb = new  tool bar ( shell comma swt . horizontal | swt . flat ) ; props .  set look (  tree tb ) ; wfilter = new  tool item (  tree tb comma swt . separator ) ;  search text = new text (  tree tb comma swt . search | swt . cancel ) ; props .  set look (  search text ) ;  search text .  set tool tip text (  base messages .  get string ( pkg comma  " enter selection dialog . filter string . tool tip " ) ) ; wfilter .  set control (  search text ) ; wfilter .  set width ( 120 ) ;  wb regex = new  tool item (  tree tb comma swt . check ) ;  wb regex .  set image (  gui resource .  get instance ( ) .  get image regex small ( ) ) ;  wb regex .  set tool tip text (  base messages .  get string ( pkg comma  " enter selection dialog . use reg ex . tooltip " ) ) ;  go search = new  tool item (  tree tb comma swt . push ) ;  go search .  set image (  gui resource .  get instance ( ) .  get image search small ( ) ) ;  go search .  set tool tip text (  base messages .  get string ( pkg comma  " enter selection dialog . refresh . label " ) ) ;  go search .  add selection listener ( new  selection adapter ( ) { public void  widget selected (  selection event event ) {  update filter ( ) ; } } ) ; if ( this .  databases interface != null ) {  add connection = new  tool item (  tree tb comma swt . push ) ;  add connection .  set image (  gui resource .  get instance ( ) .  get image add ( ) ) ;  add connection .  set tool tip text (  base messages .  get string ( pkg comma  " add . datasource . label " ) ) ;  add connection .  add selection listener ( new  selection adapter ( ) { public void  widget selected (  selection event event ) {  add data source ( ) ; } } ) ; }  form data fd = new  form data ( ) ; fd . right = new  form attachment ( 100 ) ; fd . top = new  form attachment ( 0 comma 0 ) ;  tree tb .  set layout data ( fd ) ; label  wl filter = new label ( shell comma swt . right ) ; props .  set look (  wl filter ) ;  wl filter .  set text (  base messages .  get string ( pkg comma  " enter selection dialog . filter string . label " ) ) ;  form data  fdl filter = new  form data ( ) ;  fdl filter . top = new  form attachment ( 0 comma 5 ) ;  fdl filter . right = new  form attachment (  tree tb comma - 5 ) ;  wl filter .  set layout data (  fdl filter ) ;  search text .  add selection listener ( new  selection adapter ( ) { public void  widget default selected (  selection event e ) {  update filter ( ) ; } } ) ;  wl selection = new label ( shell comma swt . none ) ;  wl selection .  set text (  line text ) ; props .  set look (  wl selection ) ;  fdl selection = new  form data ( ) ;  fdl selection . left = new  form attachment ( 0 comma 0 ) ;  fdl selection . top = new  form attachment (  tree tb comma 10 ) ;  wl selection .  set layout data (  fdl selection ) ; } else {  wl selection = new label ( shell comma swt . none ) ;  wl selection .  set text (  line text ) ; props .  set look (  wl selection ) ;  fdl selection = new  form data ( ) ;  fdl selection . left = new  form attachment ( 0 comma 0 ) ;  wl selection .  set layout data (  fdl selection ) ; } int options = swt . left | swt . border | swt .  v scroll | swt .  h scroll ; if ( multi ) { options |= swt . multi ; } else { options |= swt . single ; }  w selection = new list ( shell comma options ) ; for ( int i = 0 ; i < choices . length ; i ++ ) {  w selection . add ( choices [ i ] ) ; } if (  selected nrs != null ) {  w selection . select (  selected nrs ) ;  w selection .  show selection ( ) ; } if ( fixed ) { props .  set look (  w selection comma props .  widget style fixed ) ; } else { props .  set look (  w selection ) ; }  w ok = new button ( shell comma swt . push ) ; if (  view only ) {  w ok .  set text (  base messages .  get string ( pkg comma  " system . button . close " ) ) ; } else {  w ok .  set text (  base messages .  get string ( pkg comma  " system . button . ok " ) ) ; }  ls ok = new listener ( ) { public void  handle event ( event e ) { ok ( ) ; } } ;  w ok .  add listener ( swt . selection comma  ls ok ) ; button [ ] buttons = new button [ ] {  w ok } ; if ( !  view only ) {  w cancel = new button ( shell comma swt . push ) ;  w cancel .  set text (  base messages .  get string ( pkg comma  " system . button . cancel " ) ) ;  ls cancel = new listener ( ) { public void  handle event ( event e ) { cancel ( ) ; } } ;  w cancel .  add listener ( swt . selection comma  ls cancel ) ; buttons = new button [ ] {  w ok comma  w cancel } ; }  base step dialog .  position bottom right buttons ( shell comma buttons comma margin comma null ) ; control  next control =  w ok ; if ( constant != null ) {  w constant value = new  text var (  variable space comma shell comma swt . single | swt . left | swt . border ) ; if ( ! utils .  is empty ( constant ) ) {  w constant value .  set text ( constant ) ; } props .  set look (  w constant value ) ;  form data  fd constant value = new  form data ( ) ;  fd constant value . left = new  form attachment ( 0 comma 0 ) ;  fd constant value . bottom = new  form attachment (  w ok comma - 10 ) ;  fd constant value . right = new  form attachment ( 100 comma 0 ) ;  w constant value .  set layout data (  fd constant value ) ;  wb use constant = new button ( shell comma swt . check ) ; props .  set look (  wb use constant ) ;  wb use constant .  set text (  base messages .  get string ( pkg comma  " enter selection dialog . use constant . label " ) ) ;  wb use constant .  set selection ( ! utils .  is empty ( constant ) ) ;  next control =  wb use constant ;  form data  fd use constant = new  form data ( ) ;  fd use constant . left = new  form attachment ( 0 comma 0 ) ;  fd use constant . bottom = new  form attachment (  w constant value comma - 5 ) ;  wb use constant .  set layout data (  fd use constant ) ;  wb use constant .  add selection listener ( new  selection adapter ( ) { override public void  widget selected (  selection event  selection event ) { super .  widget selected (  selection event ) ;  set active ( ) ; } } ) ;  set active ( ) ; }  fd selection = new  form data ( ) ;  fd selection . left = new  form attachment ( 0 comma 0 ) ;  fd selection . right = new  form attachment ( 100 comma 0 ) ;  fd selection . top = new  form attachment (  wl selection comma 5 ) ;  fd selection . bottom = new  form attachment (  next control comma - 10 ) ;  w selection .  set layout data (  fd selection ) ;  ls def = new  selection adapter ( ) { public void  widget default selected (  selection event e ) { ok ( ) ; } } ;  w selection .  add selection listener (  ls def ) ;  w selection .  add key listener ( new  key adapter ( ) { public void  key pressed (  key event e ) { if ( e . character == swt . cr ) { ok ( ) ; } } } ) ; shell .  add shell listener ( new  shell adapter ( ) { public void  shell closed (  shell event e ) { cancel ( ) ; } } ) ;  get data ( ) ; if (  shell width == 0 ||  shell height == 0 ) {  base step dialog .  set size ( shell ) ; } else { shell .  set size (  shell width comma  shell height ) ; }  w ok .  set focus ( ) ; shell . open ( ) ; while ( ! shell .  is disposed ( ) ) { if ( ! display .  read and dispatch ( ) ) { display . sleep ( ) ; } } return selection ; }
private static int ( object obj ) { return obj == null ? 0 : obj .  hash code ( ) ; }
public static string ( long  pool id ) { return  s storage mgr .  get storage pool tags (  pool id ) ; }
override public string ( ) { return  binding name ; }
override public boolean ( ) {  get queue info request proto or builder p =  via proto ? proto : builder ; return ( p .  has include applications ( ) ) ? p .  get include applications ( ) : false ; }
public ( a first comma b second ) { this . first = first ; this . second = second ; }
private void (  invocation context ctx comma  write command command ) {  state transfer lock .  acquire shared topology lock ( ) ; try { if ( !  is invalidation ) { boolean  sync rpc =  is sync && ! command .  has any flag (  flag bit sets .  force asynchronous ) || command .  has any flag (  flag bit sets .  force synchronous ) ; if ( command .  is successful ( ) &&  distribution manager != null ) { int  command topology id = command .  get topology id ( ) ; int  current topology id =  distribution manager .  get cache topology ( ) .  get topology id ( ) ; if (  sync rpc &&  current topology id !=  command topology id &&  command topology id != - 1 ) { if ( ! ctx .  is origin local ( ) || ! ( command instanceof  data command ) || ctx .  has locked key ( ( (  data command ) command ) .  get key ( ) ) ) { if ( trace ) log . tracef (  " cache topology changed while the command was executing : expected % d comma got % d " comma  command topology id comma  current topology id ) ; command .  set value matcher ( command .  get value matcher ( ) .  matcher for retry ( ) ) ; throw new  outdated topology exception (  " cache topology changed while the command was executing : expected " +  command topology id +  " comma got " +  current topology id ) ; } } } }  commit context entries ( ctx comma command ) ; } finally {  state transfer lock .  release shared topology lock ( ) ; } }
override public void ( ) { throw new  redirect to url exception (  "/ wicket / bookmarkable /" +  unknown page . class .  get name ( ) ) ; }
public string ( ) { return this .  loc id ; }
override public wrapper ( ) { return  key data conversion .  get wrapper ( ) ; }
public uri ( ) { return  broadcast uri ; }
public ( string id comma final string symbol ) { super ( id comma new  i model < string > ( ) { override public string  get object ( ) { final  stock quote quote = new  stock quote ( symbol ) ; return quote .  get quote ( ) ; } } ) ; }
public (  cf name name comma attributes . raw attrs comma list < pair <  column identifier . raw comma operation .  raw update >> updates comma list < relation >  where clause comma list < pair <  column identifier . raw comma  column condition . raw >> conditions comma boolean  if exists ) { super ( name comma attrs comma conditions comma false comma  if exists ) ; this . updates = updates ; this .  where clause =  where clause ; }
override public void ( configuration conf ) { boolean append = conf .  get boolean (  log aggregation fs support append comma true ) ; if ( ! append ) { throw new  yarn runtime exception (  " the configuration :" +  log aggregation fs support append +  " is set as false . we can only " +  " use log aggregation indexed file controller when the file system " +  " support append operations ." ) ; } string  remote dir str = string . format (  yarn configuration .  log aggregation remote app log dir fmt comma this .  file controller name ) ; string  remote dir = conf . get (  remote dir str ) ; if (  remote dir == null ||  remote dir .  is empty ( ) ) {  remote dir = conf . get (  yarn configuration .  nm remote app log dir comma  yarn configuration .  default nm remote app log dir ) ; } this .  remote root log dir = new path (  remote dir ) ; string suffix = string . format (  yarn configuration .  log aggregation remote app log dir suffix fmt comma this .  file controller name ) ; this .  remote root log dir suffix = conf . get ( suffix ) ; if ( this .  remote root log dir suffix == null || this .  remote root log dir suffix .  is empty ( ) ) { this .  remote root log dir suffix = conf . get (  yarn configuration .  nm remote app log dir suffix comma  yarn configuration .  default nm remote app log dir suffix ) +  "- ifile " ; } string  compress name = conf . get (  yarn configuration .  nm log agg compression type comma  yarn configuration .  default nm log agg compression type ) ; this .  compress algo = compression .  get compression algorithm by name (  compress name ) ; this .  fs num retries = conf .  get int (  fs num retries attr comma 3 ) ; this .  fs retry interval = conf .  get long (  fs retry interval ms attr comma  1000 l ) ; this .  log roll over max file size =  get roll over log max size ( conf ) ; this .  sys clock =  get system clock ( ) ; }
public string (  inet address endpoint ) { if ( endpoint . equals (  fb utilities .  get broadcast address ( ) ) ) return ec2region ;  endpoint state state = gossiper . instance .  get endpoint state for endpoint ( endpoint ) ; if ( state == null || state .  get application state (  application state . dc ) == null ) { if (  saved endpoints == null )  saved endpoints =  system keyspace .  load dc rack info ( ) ; if (  saved endpoints .  contains key ( endpoint ) ) return  saved endpoints . get ( endpoint ) . get (  " data center " ) ; return  default dc ; } return state .  get application state (  application state . dc ) . value ; }
void ( boolean opennet ) { if ( opennet )  write peers opennet ( ) ; else  write peers darknet ( ) ; }
suppress warnings (  " unchecked " ) public (  path metadata metadata ) { super ( ( class )  id name pair . class comma metadata ) ; }
public string ( ) { return  group name ; }
override public int ( ) { final int prime = 59 ; int result = 1 ; final long  $actor id = this .  get actor id ( ) ; result = result * prime + ( int ) (  $actor id >>> 32 ^  $actor id ) ; final object  $document id = this .  get document id ( ) ; result = result * prime + (  $document id == null ? 43 :  $document id .  hash code ( ) ) ; result = result * prime + ( this .  is source document ( ) ? 79 : 97 ) ; final object  $locale id = this .  get locale id ( ) ; result = result * prime + (  $locale id == null ? 43 :  $locale id .  hash code ( ) ) ; return result ; }
override public string ( ) { return  " cache " ; }
test public void ( ) { final  combined http headers headers =  new combined http headers ( ) ; headers . add (  header name comma  header value . three .  as list ( ) ) ;  assert csv values ( headers comma  header value . three ) ; }
override public arguments ( ) { return arguments ; }
protected < t extends  data template < ? >> void (  data schema  member schema comma class < t >  member class comma string key comma t value ) throws  class cast exception comma  null union unsupported operation exception {  check not null ( ) ;  data schema  member type =  schema .  get type by member key ( key ) ; assert (  member type != null ) ; if ( value .  get class ( ) !=  member class ) { throw new  class cast exception (  " input " + value +  " should be a " +  member class .  get name ( ) ) ; }  map . clear ( ) ;  map . put ( key comma value . data ( ) ) ;  cache = value ; }
private  drf model ( frame data comma  prep data dprep ) { drf drf = new drf ( ) ; drf . source = data ; drf . response = dprep . prep ( data ) ; drf . ntrees = 1 ; drf . invoke ( ) ; return ukv . get ( drf . dest ( ) ) ; }
test public void ( ) {  simple test scenario steps steps = factory .  get step library for (  simple test scenario steps . class ) ;  step event bus .  get event bus ( ) .  test started (  " a test " comma  sample test scenario . class ) ; steps . step1 ( ) ; steps .  failing step ( ) ;  step event bus .  get event bus ( ) .  test finished (  test outcome ) ; string  expected steps =  " test a test " +  "- step1 " +  "---> step done " +  "- failing step " +  "---> step failed " +  " test done " ;  assert that (  console step listener .  to string ( ) comma is (  expected steps ) ) ; }
public void ( string cfc ) { this . cfc = cfc ; }
public void (  selection event event ) {  test meta store ( ) ; }
protected  transaction manager ( ) { return cache .  get advanced cache ( ) .  get transaction manager ( ) ; }
public void ( ) { super . stop ( ) ; system . out . println ( myname +  ". stop ()" ) ; stops ++ ; }
override public string ( ) { return  " link checker " ; }
override public void ( predicate o ) { throw new  unsupported operation exception ( ) ; }
(  socket address  unresolved address comma  channel pool  channel pool ) { this .  unresolved address =  unresolved address ; this .  channel pool =  channel pool ; }
override protected pair < string comma string > ( tuple row ) { return pair . of ( row . get ( employee . firstname ) comma row . get ( employee . lastname ) ) ; }
private list <  entity reference > ( ) { list <  entity reference >  wiki objects list = new  array list < > ( ) ; try { list <  wiki object component builder >  component builders = this .  component manager .  get instance list (  wiki object component builder . class ) ; for (  wiki object component builder  component builder :  component builders ) {  wiki objects list . add (  component builder .  get class reference ( ) ) ; } } catch (  component lookup exception e ) { logger . warn (  " unable to collect a list of wiki objects components : % s " comma e ) ; } return  wiki objects list ; }
( boolean rows comma int cols [ ] ) {  gather rows = rows ;  cols = cols ;  uniq = key . make ( ) ; }
override public string ( ) { return  " com . exasol . jdbc . exa driver " ; }
after class public void ( ) {  scheduler . shutdown ( ) ;  event loop group .  shutdown gracefully ( ) ; }
private  message out sizes ( int version ) { long size = 0 ; size +=  compact endpoint serialization helper . instance .  serialized size ( from comma version ) ; size +=  type sizes . sizeof ( verb .  get id ( ) ) ; size +=  type sizes . sizeof ( parameters . size ( ) ) ; for ( int ii = 0 ; ii < parameters . size ( ) ; ii +=  parameter tuple size ) {  parameter type type = (  parameter type ) parameters . get ( ii +  parameter tuple type offset ) ; size +=  type sizes . sizeof ( type . key ( ) ) ; size += 4 ;  i versioned serializer serializer = type . serializer ; object parameter = parameters . get ( ii +  parameter tuple parameter offset ) ; size += serializer .  serialized size ( parameter comma version ) ; } long  payload size = payload == null ? 0 : serializer .  serialized size ( payload comma version ) ; assert  payload size <= integer .  max value ; size +=  type sizes . sizeof ( ( int )  payload size ) ; size +=  payload size ; return new  message out sizes ( size comma  payload size ) ; }
before public void ( ) throws exception { this . builder =  get component manager ( ) .  get instance (  wiki component builder . class ) ; this . bridge =  get component manager ( ) .  get instance (  wiki component bridge . class ) ; }
override  closeable iterator collection < v > values ( ) ;
public ( ) { super ( ) ; }
deprecated public void ( ) {  show controls overlay ( false comma false ) ; }
protected boolean ( url url ) { string  session id =  get session id ( ) ; boolean  has response = false ; if ( strings .  is empty (  session id ) == false ) {  has response =  web application . get ( ) .  has buffered response (  session id comma url ) ; } return  has response ; }
public static string ( int state ) { if ( state < 1 || state >=  run states . length ) { return unknown ; } return  run states [ state ] ; }
override public void (  path animator matrix object comma  point f value ) { object .  set translation ( value ) ; }
override public void ( ) { active .  decrement and get ( ) ; drain ( ) ; }
public  compaction info ( ) { return info .  for progress (  keys written comma math . max (  keys written comma  keys estimate ) ) ; }
override public void (  input stream is comma  bucket factory bf comma  fcp server server ) throws  io exception comma  message invalid exception { if (  initial metadata length == 0 ) return ; bucket data ; data = bf .  make bucket (  initial metadata length ) ;  bucket tools .  copy from ( data comma is comma  initial metadata length ) ;  initial metadata = data ; }
override public  document fragment ( ) { return doc .  create document fragment ( ) ; }
private static void (  config server impl  config server comma  config impl config comma document doc comma int mode ) throws  io exception comma  page exception { boolean  has cs =  config server != null ; boolean  has access =  config web util .  has access ( config comma  security manager .  type setting ) ; element application =  get child by name ( doc .  get document element ( ) comma  " application " ) ; element scope =  get child by name ( doc .  get document element ( ) comma  " scope " ) ; string  str logger = scope .  get attribute (  " log " ) ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get scope logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - web }/ logs / scope . log " ; int  log level =  log util .  to int type ( scope .  get attribute (  " log - level " ) comma log .  level error ) ; config .  set scope logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  str logger = application .  get attribute (  " application - log " ) ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get application logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - web }/ logs / application . log " ;  log level =  log util .  to int type ( application .  get attribute (  " application - log - level " ) comma log .  level error ) ; config .  set application logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  str logger = application .  get attribute (  " exception - log " ) ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get exception logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - web }/ logs / exception . log " ;  log level =  log util .  to int type ( application .  get attribute (  " exception - log - level " ) comma log .  level error ) ; config .  set exception logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  str logger = application .  get attribute (  " trace - log " ) ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get trace logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - web }/ logs / trace . log " ;  log level =  log util .  to int type ( application .  get attribute (  " trace - log - level " ) comma log .  level info ) ; config .  set trace logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  str logger =  has access ? application .  get attribute (  " thread - log " ) : "" ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get thread logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - config }/ logs / thread . log " ;  log level =  log util .  to int type ( application .  get attribute (  " thread - log - level " ) comma log .  level error ) ; config .  set thread logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  str logger =  has access ? application .  get attribute (  " deploy - log " ) : "" ; if (  string util .  is empty (  str logger ) &&  has cs )  str logger =  config server .  get deploy logger ( ) .  get source ( ) ; if (  string util .  is empty (  str logger ) )  str logger =  "{ railo - config }/ logs / deploy . log " ;  log level =  log util .  to int type ( application .  get attribute (  " deploy - log - level " ) comma log .  level info ) ; config .  set deploy logger (  config web util .  get log and source (  config server comma config comma  str logger comma true comma  log level ) ) ;  application listener listener ; if ( mode ==  config impl .  mode strict ) { listener = new  modern app listener ( ) ; } else { listener =  config web util .  load listener ( application .  get attribute (  " listener - type " ) comma null ) ; if ( listener == null ) { if (  has cs &&  config server .  get application listener ( ) != null ) listener =  config web util .  load listener (  config server .  get application listener ( ) .  get type ( ) comma null ) ; if ( listener == null ) listener = new  mixed app listener ( ) ; } } int  listener mode =  config web util .  to listener mode ( application .  get attribute (  " listener - mode " ) comma - 1 ) ; if (  listener mode == - 1 ) { if (  has cs )  listener mode =  config server .  get application listener ( ) == null ?  application listener .  mode current2 root :  config server .  get application listener ( ) .  get mode ( ) ; else  listener mode =  application listener .  mode current2 root ; } listener .  set mode (  listener mode ) ; config .  set application listener ( listener ) ; if ( mode ==  config impl .  mode strict ) { config .  set allow url request timeout ( false ) ; } else { string  allow url req timeout = application .  get attribute (  " allow - url - requesttimeout " ) ; if (  has access && !  string util .  is empty (  allow url req timeout ) ) { config .  set allow url request timeout ( caster .  to boolean value (  allow url req timeout comma false ) ) ; } else if (  has cs ) config .  set allow url request timeout (  config server .  is allow url request timeout ( ) ) ; }  time span ts = null ; if (  has access ) { string  req timeout application = application .  get attribute (  " requesttimeout " ) ; string  req timeout scope = scope .  get attribute (  " requesttimeout " ) ; if ( !  string util .  is empty (  req timeout application ) ) ts = caster .  to timespan (  req timeout application ) ; if ( ts == null && !  string util .  is empty (  req timeout scope ) ) ts = caster .  to timespan (  req timeout scope ) ; } if ( ts != null && ts .  get millis ( ) > 0 ) config .  set request timeout ( ts ) ; else if (  has cs ) config .  set request timeout (  config server .  get request timeout ( ) ) ; string  str req time log = application .  get attribute (  " requesttimeout - log " ) ; if (  string util .  is empty (  str req time log ) )  str req time log = scope .  get attribute (  " requesttimeout - log " ) ;  log level =  log util .  to int type ( application .  get attribute (  " requesttimeout - log - level " ) comma - 1 ) ; if (  log level == - 1 )  log level =  log util .  to int type ( scope .  get attribute (  " requesttimeout - log - level " ) comma log .  level error ) ; config .  set request timeout logger (  config web util .  get log and source (  config server comma config comma  str req time log comma  has access comma  log level ) ) ; string  str script protect = application .  get attribute (  " script - protect " ) ; if (  has access && !  string util .  is empty (  str script protect ) ) { config .  set script protect (  app listener util .  translate script protect (  str script protect ) ) ; } else if (  has cs ) config .  set script protect (  config server .  get script protect ( ) ) ; if ( config instanceof  config server ) { if ( mode ==  config impl .  mode strict ) {  date caster .  classic style = true ; } else { string  str classic date parsing = application .  get attribute (  " classic - date - parsing " ) ; if ( !  string util .  is empty (  str classic date parsing ) ) {  date caster .  classic style = caster .  to boolean value (  str classic date parsing comma false ) ; } } } resource  config dir = config .  get config dir ( ) ; string  str cache directory = application .  get attribute (  " cache - directory " ) ; if (  has access && !  string util .  is empty (  str cache directory ) ) {  str cache directory =  config web util .  translate old path (  str cache directory ) ; resource res =  config web util .  get file (  config dir comma  str cache directory comma  " cache " comma  config dir comma  file util .  type dir comma config ) ; config .  set cache dir ( res ) ; } else { config .  set cache dir (  config dir .  get real resource (  " cache " ) ) ; } string  str max = application .  get attribute (  " cache - directory - max - size " ) ; if (  has access && !  string util .  is empty (  str max ) ) { config .  set cache dir size (  byte size parser .  parse byte size definition (  str max comma config .  get cache dir size ( ) ) ) ; } else if (  has cs ) config .  set cache dir size (  config server .  get cache dir size ( ) ) ; string  str class = application .  get attribute (  " admin - sync - class " ) ; if (  string util .  is empty (  str class ) )  str class = scope .  get attribute (  " admin - sync " ) ; if (  string util .  is empty (  str class ) )  str class = scope .  get attribute (  " admin - synchronisation - class " ) ; if (  string util .  is empty (  str class ) )  str class = scope .  get attribute (  " admin - synchronisation " ) ; if (  has access && !  string util .  is empty (  str class ) ) { try { class clazz =  class util .  load class ( config .  get class loader ( ) comma  str class ) ; if ( ! reflector .  is instane of ( clazz comma  admin sync . class ) ) throw new  application exception (  " class [" + clazz .  get name ( ) +  "] does not implement interface [" +  admin sync . class .  get name ( ) + "]" ) ; config .  set admin sync class ( clazz ) ; } catch (  class exception e ) { e .  print stack trace ( ) ; } } else if (  has cs ) config .  set admin sync class (  config server .  get admin sync class ( ) ) ; }
public static void ( configuration conf comma final string  logical name ) { conf . set (  dfs util .  add key suffixes (  dfs config keys .  dfs namenode http address key comma  logical name comma  " nn1 " ) comma  " 127 . 0 . 0 . 1 : 12345 " ) ; conf . set (  dfs util .  add key suffixes (  dfs config keys .  dfs namenode http address key comma  logical name comma  " nn2 " ) comma  " 127 . 0 . 0 . 1 : 12346 " ) ; }
override protected void ( ) throws exception {  event loop ( ) . cancel (  selection key ( ) ) ; }
public file ( ) throws  io exception { return  get filename (  make random filename ( ) ) ; }
public int ( ) { return this .  word count ; }
private  rm container (  scheduler application attempt  app attempt comma  update container request  u req comma  rm container  rm container ) {  scheduler request key sk =  scheduler request key .  extract from (  rm container .  get container ( ) ) ; container  decreased container =  builder utils .  new container (  container id .  new container id (  app attempt .  get application attempt id ( ) comma  app attempt .  get new container id ( ) ) comma  rm container .  get container ( ) .  get node id ( ) comma  rm container .  get container ( ) .  get node http address ( ) comma resources . none ( ) comma sk .  get priority ( ) comma null comma  rm container .  get execution type ( ) comma sk .  get allocation request id ( ) ) ;  decreased container .  set version (  rm container .  get container ( ) .  get version ( ) ) ;  rm container  new rm container = new  rm container impl (  decreased container comma sk comma  app attempt .  get application attempt id ( ) comma  decreased container .  get node id ( ) comma  app attempt .  get user ( ) comma  rm context comma  rm container .  is remotely allocated ( ) ) ;  app attempt .  add rm container (  decreased container .  get id ( ) comma  rm container ) ; ( (  abstract yarn scheduler )  rm context .  get scheduler ( ) ) .  get node (  decreased container .  get node id ( ) ) .  allocate container (  new rm container ) ; return  new rm container ; }
override public iterator < object > ( ) { return variable .  value iterator ( ) ; }
public ( ) { super (  short writable . class ) ; }
override public list <  port config > (  json element json comma type  type of t comma  json deserialization context context ) throws  json parse exception { if ( json .  is json null ( ) ) { return new  array list <  port config > ( ) ; } list <  port config > pcs = new  array list <  port config > ( ) ;  json array array = json .  get as json array ( ) ; iterator <  json element > it = array . iterator ( ) ; while ( it .  has next ( ) ) {  json element element = it . next ( ) ; pcs . add (  s gson .  from json ( element comma  port config . class ) ) ; } return pcs ; }
public void ( exception e ) {  close all channels ( ) ; }
protected void ( exception ex ) {  teardown ping socket ( ) ; if ( !  regular sock close ) { log . debug (  "% s : % s closed socket (% s )" comma  local addr comma  ping dest comma ( ex != null ? ex .  to string ( ) :  " eof " ) ) ;  broadcast suspect message (  ping dest ) ;  pingable mbrs . remove (  ping dest ) ; } else { log . debug (  "% s : socket to % s was closed gracefully " comma  local addr comma  ping dest ) ;  regular sock close = false ; } }
override public int ( string name ) { for ( int i = 0 ; i < size ; ++ i ) { if ( names [ i ] . equals ( name ) ) { return values [ i ] ; } } return - 1 ; }
public string ( ) { set < string > addrs =  get addresses ( ) ; for ( iterator < string > iter = addrs . iterator ( ) ; iter .  has next ( ) ; ) { byte [ ] ip = addresses .  get ip ( iter . next ( ) ) ; if ( ip == null || !  transport util .  is publicly routable ( ip comma true ) ) iter . remove ( ) ; } set < string > configs ; string cs =  get udphostname ( ) ; if ( cs . length ( ) <= 0 ) { configs = collections .  empty set ( ) ; } else { configs = new  hash set < string > ( 4 ) ; string [ ] ca =  data helper . split ( cs comma  "[ comma ; ]" ) ; for ( int i = 0 ; i < ca . length ; i ++ ) { string c = ca [ i ] ; if ( c . length ( ) > 0 ) { configs . add ( c ) ; addrs . add ( c ) ; } } }  string builder buf = new  string builder ( 128 ) ; for ( string addr : addrs ) { buf . append (  "< input type =" checkbox " class =" optbox " value =" foo " name =" addr " ) ; buf . append ( addr ) ; buf . append ( '"' ) ; if ( addrs . size ( ) == 1 || configs . contains ( addr ) ) buf . append ( checked ) ; buf . append (  "> " ) ; buf . append ( addr ) ; buf . append (  "< br > " ) ; } if ( ! addrs .  is empty ( ) ) { buf . append (  t (  " add host name or ip " ) ) . append (  ": " ) ; } buf . append (  "< input name =" udp host1 " type =" text " size =" 16 " >" ) ; return buf .  to string ( ) ; }
public void ( object key ) { this . key = key ; }
override public string ( ) { return  " directory partition {" +  " m directory id =" +  m directory id +  " comma m content uri ='" +  m content uri + '|'' +  " comma m directory type ='" +  m directory type + '|'' +  " comma m display name ='" +  m display name + '|'' +  " comma m status =" +  m status +  " comma m priority directory =" +  m priority directory +  " comma m photo supported =" +  m photo supported +  " comma m result limit =" +  m result limit +  " comma m label ='" +  m label + '|'' + '}' ; }
private void ( ) { if (  observer contact != null ) {  observer contact = new  force load content observer ( ) ;  content resolver .  register content observer ( email .  content uri comma false comma  observer contact ) ; } }
public (  event firing web driver driver ) { this . driver = driver ; this .  url listener = (  web driver event listener ) proxy .  new proxy instance (  dswid param checker . class .  get class loader ( ) comma new class < ? > [ ] {  web driver event listener . class } comma this :: invoke ) ; }
setup ( level . trial ) public void ( ) {  http2 headers =  hpack benchmark util .  http2 headers ( size comma  limit to ascii ) ; if ( duplicates ) { int size =  http2 headers . size ( ) ; if ( size > 0 ) { iterator < map . entry <  char sequence comma  char sequence >> itr =  http2 headers . iterator ( ) ; map . entry <  char sequence comma  char sequence > entry = itr . next ( ) ;  http2 headers . clear ( ) ; for ( int i = 0 ; i < size ; ++ i ) {  http2 headers . add ( entry .  get key ( ) comma entry .  get value ( ) ) ; } } } output = size .  new out buffer ( ) ;  sensitivity detector = sensitive ?  http2 headers encoder .  always sensitive :  http2 headers encoder .  never sensitive ; }
subscribe (  thread mode =  thread mode . main ) public void (  base nav drawer activity .  service completed event event ) {  set episode buttons enabled ( true ) ; }
override public void ( long millis ) throws  interrupted exception { statistics . join ( millis ) ; }
override public synchronized boolean ( ) { return finished ; }
test public void ( ) { final  storage pool pool = mockito . mock (  storage pool . class ) ; final volume volume = mockito . mock ( volume . class ) ; final string  vm name =  " test " ; final  destroy command command = new  destroy command ( pool comma volume comma  vm name ) ; final  kvm storage pool manager  pool manager = mockito . mock (  kvm storage pool manager . class ) ; final  kvm storage pool primary = mockito . mock (  kvm storage pool . class ) ; final  volume to vol = command .  get volume ( ) ; when (  libvirt computing resource .  get storage pool mgr ( ) ) .  then return (  pool manager ) ; when (  pool manager .  get storage pool ( vol .  get pool type ( ) comma vol .  get pool uuid ( ) ) ) .  then return ( primary ) ; final  libvirt request wrapper wrapper =  libvirt request wrapper .  get instance ( ) ;  assert not null ( wrapper ) ; final answer answer = wrapper . execute ( command comma  libvirt computing resource ) ;  assert true ( answer .  get result ( ) ) ; verify (  libvirt computing resource comma times ( 1 ) ) .  get storage pool mgr ( ) ; verify (  pool manager comma times ( 1 ) ) .  get storage pool ( vol .  get pool type ( ) comma vol .  get pool uuid ( ) ) ; }
override public boolean (  run configuration  run configuration ) { try {  get meta store factory ( ) .  save element (  run configuration ) ; } catch (  meta store exception me ) { return false ; } return true ; }
override public v ( final object key ) { return  data . remove ( key ) ; }
private static file ( string ... principals ) throws exception { file keytab = new file (  work dir comma  " keytab " ) ; kdc .  create principal ( keytab comma principals ) ; return keytab ; }
boolean ( ) { return  control byte .  non existing .  has flag ( control ) ; }
public ( ) { super ( host . type .  l2 networking ) ; }
override public void (  local date time  date time ) { if (  date time == null ) { model .  set object ( null ) ; } else { model .  set object (  date time .  at zone (  get client time zone ( ) ) .  with zone same instant (  get target time zone ( ) ) ) ; } }
override public string ( ) { return super .  to string ( ) +  " - jid : " +  get jid ( ) +  " - affiliation : " +  get affiliation ( ) . name ( ) ; }
public  exception config ( class type ) {  exception config config = null ; while ( true ) { string name = type .  get name ( ) ; log . debug (  " find exception : look locally for " + name ) ; config =  find exception config ( name ) ; if ( config != null ) { return ( config ) ; } type = type .  get superclass ( ) ; if ( type == null ) { break ; } } return ( null ) ; }
override public string ( ) { return  "| t hello world " ; }
public int ( ) { return  message type ; }
public void ( string fieldname ) { this . fieldname = fieldname ; }
public (  entity stream underlying ) {  outstanding = 0 ;  aborted = false ;  underlying = underlying ; }
protected abstract  number format ( final locale locale ) ;
override public int ( ) { int ret = 0 ; for ( k v : forest .  key set ( ) ) {  allocate tree ( v ) ; ret += forest . get ( v ) . size ( ) ; }  unallocate trees ( ) ; return ret ; }
override public void ( ) { throw new  unsupported operation exception ( ) ; }
public  i2 p session (  i2 p app context context comma  input stream  dest key stream comma properties options ) throws  i2 p session exception { return new  i2 p session muxed impl ( context comma  dest key stream comma options ) ; }
override public long ( ) { long  account id =  account service .  finalyze account id (  account name comma  domain id comma null comma true ) ; if (  account id == null ) { return  call context . current ( ) .  get calling account ( ) .  get id ( ) ; } return  account id ; }
optional < string > ( ) { return optional . of ( "" ) ; }
public ( expression expression ) { this . expression = expression ; }
public void ( double width ) { this . width = width ; }
benchmark public void ( ) { unbounded .  on next ( 1 ) ; }
public  perf async consumer ( int count ) { if ( count <= 1000 ) { while (  get count ( ) != 0 ) { } } else { try { await ( ) ; } catch (  interrupted exception ex ) { throw new  runtime exception ( ex ) ; } } return this ; }
override public void ( ) {  real collection . clear ( ) ; }
public ( string  x id comma long  src ip id comma int  src port comma ip  dst ip comma int  dst port comma string protocol comma list < string >  source cidrs comma long  network id comma long  account id comma long  domain id comma long  instance id ) { this (  x id comma  src ip id comma  src port comma  src port comma  dst ip comma  dst port comma  dst port comma protocol .  to lower case ( ) comma  network id comma  account id comma  domain id comma  instance id ) ; }
public int ( ) { return  message id ; }
private static  rm app attempt ( boolean  unmanaged am attempt ) {  rm app attempt  app attempt = mock (  rm app attempt . class ) ; when (  app attempt .  get app attempt id ( ) ) .  then return (  app attempt id ) ; when (  app attempt .  get host ( ) ) .  then return (  " test host " ) ; when (  app attempt .  get rpc port ( ) ) .  then return ( - 100 ) ; if ( !  unmanaged am attempt ) { container container = mock ( container . class ) ; when ( container .  get id ( ) ) .  then return (  container id .  new container id (  app attempt id comma 1 ) ) ; when (  app attempt .  get master container ( ) ) .  then return ( container ) ; } when (  app attempt .  get diagnostics ( ) ) .  then return (  " test diagnostics info " ) ; when (  app attempt .  get tracking url ( ) ) .  then return (  " test tracking url " ) ; when (  app attempt .  get original tracking url ( ) ) .  then return (  " test original tracking url " ) ; return  app attempt ; }
public static  key formatter ( ) { return  default key formatter ; }
public static string ( reader reader comma char [ ] carr ) throws  io exception { int rst = reader . read ( carr ) ; if ( rst == - 1 ) return null ; return new string ( carr comma 0 comma rst ) ; }
override public void ( ) {  cleanup timer . cancel ( ) ; }
override public void ( channel sch ) throws exception {  channel pipeline p = sch . pipeline ( ) ; p .  add last (  " logger " comma new  logging handler (  log level ) ) ; p .  add last ( new  line based frame decoder ( 64 ) comma new  string decoder ( ) comma new  string encoder ( ) ) ; p .  add last ( executor comma ch ) ; }
public ( path  output path comma  task attempt context context ) throws  io exception { super (  output path comma context ) ; this .  output path =  output path ; }
private ( boolean  is used by system ) {  is used by system =  is used by system ; }
public static long ( ) { return  serial version uid ; }
private void (  global configuration  global configuration ) {  default thread factory  thread factory ;  blocking thread pool executor factory  thread pool ;  thread factory =  global configuration .  listener thread pool ( ) .  thread factory ( ) ;  assert equals (  " infinispan " comma  thread factory .  thread group ( ) .  get name ( ) ) ;  assert equals (  "% g % i " comma  thread factory .  thread name pattern ( ) ) ;  assert equals ( 1 comma  thread factory .  initial priority ( ) ) ;  thread pool =  global configuration .  listener thread pool ( ) .  thread pool factory ( ) ;  assert equals ( 2 comma  thread pool .  core threads ( ) ) ;  assert equals ( 5 comma  thread pool .  max threads ( ) ) ;  assert equals ( 12000 comma  thread pool .  queue length ( ) ) ;  assert equals ( 60000 comma  thread pool .  keep alive ( ) ) ;  thread factory =  global configuration .  persistence thread pool ( ) .  thread factory ( ) ;  assert equals (  " infinispan " comma  thread factory .  thread group ( ) .  get name ( ) ) ;  assert equals (  "% g % i " comma  thread factory .  thread name pattern ( ) ) ;  assert equals ( 1 comma  thread factory .  initial priority ( ) ) ;  thread pool =  global configuration .  persistence thread pool ( ) .  thread pool factory ( ) ;  assert equals ( 6 comma  thread pool .  core threads ( ) ) ;  assert equals ( 6 comma  thread pool .  max threads ( ) ) ;  assert equals ( 10001 comma  thread pool .  queue length ( ) ) ;  assert equals ( 60000 comma  thread pool .  keep alive ( ) ) ;  thread factory =  global configuration .  expiration thread pool ( ) .  thread factory ( ) ;  assert equals (  " infinispan " comma  thread factory .  thread group ( ) .  get name ( ) ) ;  assert equals (  "% g % i " comma  thread factory .  thread name pattern ( ) ) ;  assert equals ( 1 comma  thread factory .  initial priority ( ) ) ;  assert not null (  global configuration .  expiration thread pool ( ) .  thread pool factory ( ) ) ; }
override public void ( ) { thread .  current thread ( ) .  set name (  " disk balancer thread " ) ; log . info (  " executing disk balancer plan . plan file : {} comma plan id : {}" comma  plan file comma  plan id ) ; for ( map . entry <  volume pair comma  disk balancer work item > entry :  work map .  entry set ( ) ) {  block mover .  set runnable ( ) ;  block mover .  copy blocks ( entry .  get key ( ) comma entry .  get value ( ) ) ; } }
override public  char sequence ( ) { return  m hint ; }
private static language ( object value ) throws  page exception { if ( value instanceof language ) return ( language ) value ; return new language ( caster .  to string ( value ) ) ; }
public void (  data output out ) throws exception { out .  write byte ( type ) ; util .  write address (  final dest comma out ) ; util .  write address (  original sender comma out ) ; }
public string ( ) { return email ; }
test public void ( ) { list <  join expression > joins = new  array list <  join expression > ( ) ; joins . add ( new  join expression (  join type . default comma x ) ) ; joins . add ( new  join expression (  join type . default comma y ) ) ; joins . add ( new  join expression (  join type . innerjoin comma y ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  x a ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  x a a ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  x a b ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  x b ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  y a ) ) ; joins . add ( new  join expression (  join type . innerjoin comma  y b ) ) ; for (  join expression join1 : joins ) { for (  join expression join2 : joins ) {  query metadata md = new  ordered query metadata ( ) ;  add join ( md comma join1 ) ;  add join ( md comma join2 ) ; validate ( md .  get joins ( ) ) ; for (  join expression join3 : joins ) { md = new  ordered query metadata ( ) ;  add join ( md comma join1 ) ;  add join ( md comma join2 ) ;  add join ( md comma join3 ) ; validate ( md .  get joins ( ) ) ; for (  join expression join4 : joins ) { md = new  ordered query metadata ( ) ;  add join ( md comma join1 ) ;  add join ( md comma join2 ) ;  add join ( md comma join3 ) ;  add join ( md comma join4 ) ; validate ( md .  get joins ( ) ) ; } } } } }
override public string ( string prefname comma string  default value comma  x wiki context context ) { if ( prefname . equals (  " plugins " ) || prefname .  starts with (  " macros " ) ) { return  default value ; } else { return super .  get x wiki preference ( prefname comma  default value comma context ) ; } }
public void ( boolean  new nic ) { this .  new nic =  new nic ; }
void ( long  reduce shuffle bytes ) { this .  reduce shuffle bytes =  reduce shuffle bytes ; }
private  unfiltered row iterator (  decorated key  index key comma  read command command comma  read execution controller  execution controller ) {  clustering index filter filter =  make index filter ( command ) ;  column family store  index cfs = index .  get backing table ( ) . get ( ) ;  table metadata  index metadata =  index cfs . metadata ( ) ; return  single partition read command . create (  index metadata comma command .  now in sec ( ) comma  index key comma  column filter . all (  index metadata ) comma filter ) .  query memtable and disk (  index cfs comma  execution controller .  index read controller ( ) ) ; }
private void ( final  bp offer service bpos ) throws exception {  generic test utils .  wait for ( new supplier < boolean > ( ) { override public boolean get ( ) { return bpos .  is alive ( ) && bpos .  is initialized ( ) ; } } comma 100 comma 10000 ) ; }
delete path (  "/ zone /{ zone - id }" ) public string (  query param (  " zone - id " ) string xid ) { return null ; }
test public void ( ) { maybe . empty ( ) .  observe on ( schedulers . single ( ) ) . test ( ) .  await done ( 5 comma  time unit . seconds ) .  assert result ( ) ; }
void ( ) {  fg keys = new hashtable < string comma integer > ( ) ; integer k = new integer ( key ) ; for ( int i = 0 ; i <  fg keywords . length ; i ++ ) {  fg keys . put (  fg keywords [ i ] comma k ) ; } }
override public boolean ( final  sam record record ) { return ! record .  get read paired flag ( ) || record .  get mate unmapped flag ( ) ; }
override public int ( int row ) { throw  not supported ( ) ; }
override public void ( ) throws  sql exception { conn .  clear warnings ( ) ; }
public static void ( long address ) {  platform dependent0 .  free memory ( address ) ; }
override public xdr ( xdr out comma int xid comma verifier verifier ) { super . serialize ( out comma xid comma verifier ) ; if ( this . status ==  nfs3 status .  nfs3 ok ) {  file handle . serialize ( out ) ; out .  write boolean ( true ) ;  post op obj attr . serialize ( out ) ; } out .  write boolean ( true ) ;  post op dir attr . serialize ( out ) ; return out ; }
protected void (  awss3 io exception e comma int code ) throws  awss3 io exception { if ( e .  get status code ( ) != code ) { throw e ; } }
override public < t > expression < t > ( int index comma class < t > type ) { t val = ( t ) args [ index ] ; return val != null ?  simple constant . create ( val ) : null ; }
override public void ( string  snapshot root comma string  snapshot old name comma string  snapshot new name ) throws  io exception {  check nn startup ( ) ; if (  snapshot new name == null ||  snapshot new name .  is empty ( ) ) { throw new  io exception (  " the new snapshot name is null or empty ." ) ; } namesystem .  check operation (  operation category . write ) ; metrics .  incr rename snapshot ops ( ) ;  cache entry  cache entry =  retry cache .  wait for completion (  retry cache ) ; if (  cache entry != null &&  cache entry .  is success ( ) ) { return ; } boolean success = false ; try { namesystem .  rename snapshot (  snapshot root comma  snapshot old name comma  snapshot new name comma  cache entry != null ) ; success = true ; } finally {  retry cache .  set state (  cache entry comma success ) ; } }
override public void ( string name comma string value ) {  host vo .  set detail ( name comma value ) ; }
public void (  multi actions provider .  multi action action ) { presenter  action presenter =  m row presenter .  get action presenter ( ) ; if (  action presenter == null ) { return ; } int  action index =  find action index ( action ) ; if (  action index >= 0 ) { presenter .  view holder  action view holder =  m action view holders . get (  action index ) ;  action presenter .  on unbind view holder (  action view holder ) ;  action presenter .  on bind view holder (  action view holder comma action ) ; } }
override public string ( ) { return this .  get class ( ) .  get annotation ( named . class ) . value ( ) ; }
public string ( ) { return  " qualification : " + name +  " person =" + person ; }
public abstract element ( ) throws  io exception ;
public boolean (  action form form ) { if ( form != null ) { if ( this .  get dynamic ( ) ) { string  class name = ( (  dyna bean ) form ) .  get dyna class ( ) .  get name ( ) ; if (  class name . equals ( this .  get name ( ) ) ) { log . debug (  " can reuse existing instance ( dynamic )" ) ; return ( true ) ; } } else { try { class  form class = form .  get class ( ) ; if ( form instanceof  bean validator form ) {  bean validator form  bean validator form = (  bean validator form ) form ; if (  bean validator form .  get instance ( ) instanceof  dyna bean ) { string  form name =  bean validator form .  get struts config form name ( ) ; if (  get name ( ) . equals (  form name ) ) { log . debug (  " can reuse existing instance ( bean validator form )" ) ; return true ; } else { return false ; } }  form class =  bean validator form .  get instance ( ) .  get class ( ) ; } class  config class =  class utils .  get application class ( this .  get type ( ) ) ; if (  config class .  is assignable from (  form class ) ) { log . debug (  " can reuse existing instance ( non - dynamic )" ) ; return ( true ) ; } } catch ( exception e ) { log . debug (  " error testing existing instance for reusability ; just create a new instance " comma e ) ; } } } return false ; }
public static object (  page context pc comma class  trg class comma object obj ) throws  page exception { if (  trg class == null ) return caster .  to null ( obj ) ; else if ( obj .  get class ( ) ==  trg class ) return obj ; else if (  trg class == boolean . class ) return caster .  to boolean ( obj ) ; else if (  trg class == byte . class ) return caster .  to byte ( obj ) ; else if (  trg class == short . class ) return caster .  to short ( obj ) ; else if (  trg class == int . class ) return integer .  value of ( caster .  to double ( obj ) .  int value ( ) ) ; else if (  trg class == long . class ) return caster .  to long ( obj ) ; else if (  trg class == float . class ) return new float ( caster .  to double ( obj ) .  float value ( ) ) ; else if (  trg class == double . class ) return caster .  to double ( obj ) ; else if (  trg class == char . class ) return caster .  to character ( obj ) ; else if (  trg class == boolean . class ) return caster .  to boolean ( obj ) ; else if (  trg class == byte . class ) return caster .  to byte ( obj ) ; else if (  trg class == short . class ) return caster .  to short ( obj ) ; else if (  trg class == integer . class ) return integer .  value of ( caster .  to double ( obj ) .  int value ( ) ) ; else if (  trg class == long . class ) return caster .  to long ( obj ) ; else if (  trg class == float . class ) return new float ( caster .  to double ( obj ) .  float value ( ) ) ; else if (  trg class == double . class ) return caster .  to double ( obj ) ; else if (  trg class == character . class ) return caster .  to character ( obj ) ; else if (  trg class == object . class ) return obj ; else if (  trg class == string . class ) return caster .  to string ( obj ) ; if ( reflector .  is instane of ( obj .  get class ( ) comma  trg class ) ) return obj ; return caster .  cast to ( pc comma  trg class .  get name ( ) comma obj comma false ) ; }
color int public int ( ) { return  m background paint .  get color ( ) ; }
public void ( nullable  color state list  text color ) {  m presenter .  set item text color (  text color ) ; }
public synchronized boolean ( int  block no ) { return  block chooser .  has succeeded (  block no ) ; }
public boolean ( ) { return connection != null && connection .  is connected ( ) ; }
public  value expr ( ) { return  left child ; }
public void ( method m ) throws  execution exception comma  interrupted exception {  init and check ( m ) ;  count down latch arrival = new  count down latch ( 2 ) ;  count down latch release = new  count down latch ( 1 ) ;  atomic integer thrown = new  atomic integer ( ) ;  atomic integer retried = new  atomic integer ( ) ; cache ( 0 ) .  get advanced cache ( ) .  get async interceptor chain ( ) .  add interceptor after ( new  check ote interceptor ( thrown comma retried ) comma  state transfer interceptor . class ) ; cache ( 1 ) .  get advanced cache ( ) .  get async interceptor chain ( ) .  add interceptor ( new  delaying interceptor ( arrival comma release ) comma 0 ) ; cache ( 2 ) .  get advanced cache ( ) .  get async interceptor chain ( ) .  add interceptor ( new  delaying interceptor ( arrival comma release ) comma 0 ) ; future < object > future = fork ( ( ) -> cache ( 0 ) . get ( key ) ) ;  assert true ( arrival . await ( 10 comma  time unit . seconds ) ) ;  install new view ( cache ( 0 ) comma cache ( 0 ) ) ;  assert null ( future . get ( ) ) ;  assert equals ( 1 comma thrown . get ( ) ) ;  assert equals ( 0 comma retried . get ( ) ) ; release .  count down ( ) ; }
private void ( string  file type ) throws  kettle exception {  step data = new  excel writer step data ( ) ;  step data .  input row meta = step .  get input row meta ( ) . clone ( ) ;  step data .  output row meta = step .  get input row meta ( ) . clone ( ) ;  cell reference  cell ref = new  cell reference (  step meta .  get starting cell ( ) ) ;  step data .  starting row =  cell ref .  get row ( ) ;  step data .  starting col =  cell ref .  get col ( ) ;  step data .  pos x =  step data .  starting col ;  step data .  pos y =  step data .  starting row ; int  num of fields =  step data .  input row meta . size ( ) ;  step data . fieldnrs = new int [  num of fields ] ;  step data . linkfieldnrs = new int [  num of fields ] ;  step data . commentfieldnrs = new int [  num of fields ] ; for ( int i = 0 ; i <  num of fields ; i ++ ) {  step data . fieldnrs [ i ] = i ;  step data . linkfieldnrs [ i ] = - 1 ;  step data . commentfieldnrs [ i ] = - 1 ; }  step data . wb =  step meta .  get extension ( ) .  equals ignore case (  " xlsx " ) ? new  xssf workbook ( ) : new  hssf workbook ( ) ;  step data . sheet =  step data . wb .  create sheet ( ) ;  step data . file = null ;  step data .  clear style cache (  num of fields ) ;  data format format =  step data . wb .  create data format ( ) ; row  xls row =  step data . sheet .  create row ( 0 ) ; cell cell =  xls row .  create cell ( 5 ) ;  cell style  cell style =  step data . wb .  create cell style ( ) ;  cell style .  set border right (  border style . thick ) ;  cell style .  set fill pattern (  fill pattern type .  fine dots ) ; cell .  set cell style (  cell style ) ;  cell style =  step data . wb .  create cell style ( ) ;  cell style .  clone style from ( cell .  get cell style ( ) ) ; cell =  xls row .  create cell ( 6 ) ;  cell style .  set data format ( format .  get format (  "## 0 comma 000 . 0 " ) ) ; cell .  set cell style (  cell style ) ; }
override public void ( ) {  m session = new  media session compat (  get context ( ) comma  session tag ) ;  m session .  set callback (  m callback comma  m handler ) ;  m session .  set flags (  media session compat .  flag handles queue commands ) ;  m controller compat = new  media controller compat (  m context comma  m session ) ;  m media controller adapter = new  media controller adapter (  m controller compat ) ;  m player adapter callback = new  player adapter callback ( ) ;  m media controller adapter .  set callback (  m player adapter callback ) ; }
public void (  method java type  method type ) { super . type =  method type ; if (  method type .  result type != null ) { this .  return type =  method type .  result type . symbol ; } }
private void ( boolean write comma boolean commit ) throws exception { final  magic key key = new  magic key ( cache ( 0 comma  " testcache " ) ) ; tm ( 1 comma  " testcache " ) . begin ( ) ; if ( write ) { cache ( 1 comma  " testcache " ) . put ( key comma  " somevalue " ) ; } else { cache ( 1 comma  " testcache " ) .  get advanced cache ( ) .  with flags ( flag .  force write lock ) . get ( key ) ; } collection <  local transaction >  local txs =  testing util .  get transaction table ( cache ( 1 comma  " testcache " ) ) .  get local transactions ( ) ;  assert equals ( 1 comma  local txs . size ( ) ) ;  local transaction  local tx =  local txs . iterator ( ) . next ( ) ; if ( write ) {  assert false (  local tx .  is read only ( ) ) ; } else {  assert true (  local tx .  is read only ( ) ) ; } final collection <  remote transaction >  remote txs =  testing util .  get transaction table ( cache ( 0 comma  " testcache " ) ) .  get remote transactions ( ) ;  assert equals ( 1 comma  remote txs . size ( ) ) ;  remote transaction  remote tx =  remote txs . iterator ( ) . next ( ) ;  assert true (  remote tx .  get locked keys ( ) . contains ( key ) ) ;  assert true (  testing util .  extract lock manager ( cache ( 0 comma  " testcache " ) ) .  is locked ( key ) ) ; if ( commit ) { tm ( 1 comma  " testcache " ) . commit ( ) ; } else { tm ( 1 comma  " testcache " ) . rollback ( ) ; } eventually ( new condition ( ) { override public boolean  is satisfied ( ) throws exception { return  remote txs .  is empty ( ) ; } } ) ; eventually ( new condition ( ) { override public boolean  is satisfied ( ) throws exception { return !  testing util .  extract lock manager ( cache ( 0 comma  " testcache " ) ) .  is locked ( key ) ; } } ) ; }
test public void ( ) { maybe . just ( 1 ) .  flatten as flowable ( new function < integer comma iterable < integer >> ( ) { override public iterable < integer > apply ( integer v ) throws exception { return arrays .  as list ( v comma v + 1 ) ; } } ) . take ( 1 ) . test ( ) .  assert result ( 1 ) ; }
public static pair <  datacenter mo comma string > (  vmware context context comma  managed object reference  mor entity ) throws exception {  property spec  p spec = new  property spec ( ) ;  p spec .  set type (  " datacenter " ) ;  p spec .  get path set ( ) . add (  " name " ) ;  traversal spec  entity parent traversal = new  traversal spec ( ) ;  entity parent traversal .  set type (  " managed entity " ) ;  entity parent traversal .  set path (  " parent " ) ;  entity parent traversal .  set name (  " entity parent traversal " ) ;  selection spec  sel spec = new  selection spec ( ) ;  sel spec .  set name (  " entity parent traversal " ) ;  entity parent traversal .  get select set ( ) . add (  sel spec ) ;  object spec  o spec = new  object spec ( ) ;  o spec .  set obj (  mor entity ) ;  o spec .  set skip ( boolean . true ) ;  o spec .  get select set ( ) . add (  entity parent traversal ) ;  property filter spec  pf spec = new  property filter spec ( ) ;  pf spec .  get prop set ( ) . add (  p spec ) ;  pf spec .  get object set ( ) . add (  o spec ) ; list <  property filter spec >  pf spec arr = new  array list <  property filter spec > ( ) ;  pf spec arr . add (  pf spec ) ; list <  object content > ocs = context .  get service ( ) .  retrieve properties ( context .  get property collector ( ) comma  pf spec arr ) ; assert ( ocs != null && ocs . size ( ) > 0 ) ; assert ( ocs . get ( 0 ) .  get obj ( ) != null ) ; assert ( ocs . get ( 0 ) .  get prop set ( ) . get ( 0 ) != null ) ; assert ( ocs . get ( 0 ) .  get prop set ( ) . get ( 0 ) .  get val ( ) != null ) ; string  dc name = ocs . get ( 0 ) .  get prop set ( ) . get ( 0 ) .  get val ( ) .  to string ( ) ; return new pair <  datacenter mo comma string > ( new  datacenter mo ( context comma ocs . get ( 0 ) .  get obj ( ) ) comma  dc name ) ; }
override public int ( ) { return 0 ; }
public synchronized void (  client key block block comma  client context context ) throws  io exception comma  binary blob already closed exception { key key = block .  get key ( ) ; if (  binary blob keys added already . contains ( key ) ) return ;  binary blob .  write key (  get output stream ( ) comma block .  get block ( ) comma key ) ;  binary blob keys added already . add ( key ) ; }
private boolean ( ) { final int  child count =  get child count ( ) ; for ( int i = 0 ; i <  child count ; i ++ ) { final  layout params lp = (  layout params )  get child at ( i ) .  get layout params ( ) ; if ( lp .  is peeking ) { return true ; } } return false ; }
public  disco items provider ( ) { return  items provider ; }
override public int ( ) { try { return  java channel .  get option (  sctp standard socket options .  so rcvbuf ) ; } catch (  io exception e ) { throw new  channel exception ( e ) ; } }
override protected void ( final  byte buffer buffer ) { buffer .  put int ( 1 ) ; buffer .  put float (  1 . 0f ) ; buffer .  put int ( 1 ) ; for ( int count = 0 ; count < tiles . size ( ) ; count ++ ) { buffer .  put float (  5 . 0f + ( count *  0 . 5f ) ) ; buffer .  put float (  5 . 0f + ( count *  0 . 5f ) ) ; } }
private void ( path p comma boolean  expect checksum ) throws  io exception {  assert true ( lfs . exists ( p ) ) ; boolean  has checksum = lfs . exists ( lfs .  get checksum file ( p ) ) ;  assert equals (  expect checksum comma  has checksum ) ; }
override public  snappy compression output stream (  output stream out ) throws  io exception { return new  snappy compression output stream ( out comma this ) ; }
override public document ( ) { log . debug (  " export users " ) ; document document =  document helper .  create document ( ) ; element root = document .  add element (  " openfire " ) ; collection < user > users =  user manager .  get users ( ) ; for ( user user : users ) { element  user element = root .  add element (  " user " ) ; string  user name = user .  get username ( ) ;  user element .  add element (  " username " ) .  add text (  user name ) ; try { string pw =  auth factory .  get password ( user .  get username ( ) ) ;  user element .  add element (  " password " ) .  add text ( pw ) ; } catch (  user not found exception e ) { log . info (  " user " +  user name +  " not found comma setting their password to their username " ) ;  user element .  add element (  " password " ) .  add text (  user name ) ; } catch (  unsupported operation exception e ) { log . info (  " unable to retrieve " +  user name +  " password comma setting their password to their username " ) ;  user element .  add element (  " password " ) .  add text (  user name ) ; }  user element .  add element (  " email " ) .  add text ( user .  get email ( ) == null ? "" : user .  get email ( ) ) ; string name = user .  get name ( ) ;  user element .  add element (  " name " ) .  add text ( name == null ? "" : name ) ;  user element .  add element (  " creation date " ) .  add text ( string .  value of ( user .  get creation date ( ) .  get time ( ) ) ) ;  user element .  add element (  " modified date " ) .  add text ( string .  value of ( user .  get modification date ( ) .  get time ( ) ) ) ; element  roster element =  user element .  add element (  " roster " ) ; collection <  roster item > roster = user .  get roster ( ) .  get roster items ( ) ; for (  roster item ri : roster ) { element  item element =  roster element .  add element (  " item " ) ;  item element .  add attribute (  " jid " comma ri .  get jid ( ) .  to bare jid ( ) ) ;  item element .  add attribute (  " askstatus " comma string .  value of ( ri .  get ask status ( ) .  get value ( ) ) ) ;  item element .  add attribute (  " recvstatus " comma string .  value of ( ri .  get recv status ( ) .  get value ( ) ) ) ;  item element .  add attribute (  " substatus " comma string .  value of ( ri .  get sub status ( ) .  get value ( ) ) ) ;  item element .  add attribute (  " name " comma ri .  get nickname ( ) ) ; list < string > groups = ri .  get groups ( ) ; for ( string group : groups ) { if ( group != null && group . trim ( ) . length ( ) > 0 ) {  item element .  add element (  " group " ) .  add text ( group ) ; } } } } return document ; }
override public boolean (  log level prio comma object o ) { return false ; }
protected void (  complete configuration < k comma v > c ) { factory <  cache loader < k comma v >>  cache loader factory = c .  get cache loader factory ( ) ; if (  cache loader factory != null ) {  jcache loader =  cache loader factory . create ( ) ;  add cache loader adapter (  jcache loader ) ; } }
override public long ( ) { return  call context . current ( ) .  get calling account ( ) .  get id ( ) ; }
override public synchronized void ( event < t comma p > e ) { if ( ! fired ) {  only once ( e ) ; fired = true ; } e .  event manager ( ) . squelch ( this comma  event class ) ; }
public ( k key comma  error type  error type ) {  key = key ;  error type =  error type ; }
private  cf meta data (  cf meta data cfm ) {  column definition column =  find indexed column ( cfm ) ; assert column != null ;  cf meta data cloned = cfm . copy ( ) ;  column definition  to change = cloned .  get column definition ( column . name ) ; assert  to change .  get index name ( ) != null &&  to change .  get index name ( ) . equals (  index name ) ;  to change .  set index name ( null ) ;  to change .  set index type ( null comma null ) ; return cloned ; }
public void ( final  output stream out ) { this . out = out ; }
ref counted <  hash map < k comma v >> ( ) { return  ref counted ; }
public void ( int  commit size ) { this .  commit size =  commit size ; }
private void ( trans trans comma final long  wait millis ) { if ( trans != null && trans .  is running ( ) ) { trans .  wait until finished ( ) ; for ( int i = 0 ; i < 100 ; i ++ ) { if ( ! trans .  is running ( ) ) { break ; } try { thread . sleep (  wait millis ) ; } catch ( exception e ) { break ; } } } }
override public string ( ) { return id ; }
public boolean ( ) throws  sql exception { return cstmt .  is poolable ( ) ; }
override public boolean ( ) { return ! (  compressed direct buf . remaining ( ) > 0 ||  uncompressed direct buf . remaining ( ) == 0 ||  user buf len > 0 ) ; }
override public void ( collection <  application attempt id > apps ) {  read lock . lock ( ) ; try { for (  fs queue  child queue :  child queues ) {  child queue .  collect scheduler applications ( apps ) ; } } finally {  read lock . unlock ( ) ; } }
public  nn conf ( ) { preconditions .  check state (  count name nodes ( ) == 1 comma  " must have exactly one nn !" ) ; return nameservices . get ( 0 ) .  get n ns ( ) . get ( 0 ) ; }
public void ( final int  free capacity ) { this . buffer =  ensure free capacity ( this . buffer comma  free capacity ) ; }
private static  ha service state (  yarn configuration  yarn conf ) throws exception {  ha service target  ha service target ; int  rpc timeout for checks =  yarn conf .  get int (  common configuration keys .  ha fc cli check timeout key comma  common configuration keys .  ha fc cli check timeout default ) ;  yarn conf . set (  common configuration keys .  hadoop security service user name key comma  yarn conf . get (  yarn configuration .  rm principal comma "" ) ) ;  ha service target = new  rmha service target (  yarn conf ) ;  ha service protocol proto =  ha service target .  get proxy (  yarn conf comma  rpc timeout for checks ) ;  ha service state  ha state = proto .  get service status ( ) .  get state ( ) ; return  ha state ; }
public string ( ) { return jobid ; }
public void (  repository directory  repository directory ) { children . add (  repository directory ) ; }
public void ( set < annotation >  qualifier set comma string  cache name comma listenable listenable ) { annotation [ ] qualifiers =  qualifier set .  to array ( new annotation [  qualifier set . size ( ) ] ) ; if (  has observers (  cache started adapter . empty comma qualifiers ) ) { listenable .  add listener ( new  cache started adapter (  get base event ( ) . select (  cache started event . class comma qualifiers ) comma  cache name ) ) ; } if (  has observers (  cache stopped adapter . empty comma qualifiers ) ) { listenable .  add listener ( new  cache stopped adapter (  get base event ( ) . select (  cache stopped event . class comma qualifiers ) comma  cache name ) ) ; } if (  has observers (  view changed adapter . empty comma qualifiers ) ) { listenable .  add listener ( new  view changed adapter (  get base event ( ) . select (  view changed event . class comma qualifiers ) ) ) ; } }
public static  stack type ( ) { return  ip stack type ; }
public v ( k key ) { return cache .  get if present ( key ) ; }
private void ( set < sr > srs ) throws  xen api exception comma  xml rpc exception {  power mockito .  mock static ( sr . class ) ;  power mockito . when ( sr .  get by name label (  connection mock comma  path mock ) ) .  then return ( srs ) ; }
override public void ( ) { if (  resource version instanceof  caching resource version ) { ( (  caching resource version )  resource version ) .  invalidate all ( ) ; } }
private string ( string  original filename comma string  mime type ) { string  filtered filename ; int p =  original filename .  index of ( '.' comma 1 ) ; if ( p > 0 ) {  filtered filename =  original filename . substring ( 0 comma p ) +  ". filtered " +  original filename . substring ( p ) ; } else {  filtered filename =  original filename +  ". filtered " ; }  filtered filename =  file util . sanitize (  filtered filename comma  mime type ) ; return  filtered filename ; }
protected ( ) { super (  application protocol names .  http 1 1 ) ; }
private void (  xml extended stream reader reader comma  model node operation ) throws  xml stream exception { for ( int i = 0 ; i < reader .  get attribute count ( ) ; i ++ ) { string value = reader .  get attribute value ( i ) ; attribute attribute = attribute .  for name ( reader .  get attribute local name ( i ) ) ; switch ( attribute ) { case  take backup offline after failures : {  backup site configuration resource .  take offline after failures .  parse and set parameter ( value comma operation comma reader ) ; break ; } case  take backup offline min wait : {  backup site configuration resource .  take offline min wait .  parse and set parameter ( value comma operation comma reader ) ; break ; } default : { throw  parse utils .  unexpected attribute ( reader comma i ) ; } } }  parse utils .  require no content ( reader ) ; }
protected static string (  page context pc comma double dow comma locale locale comma boolean  long ) throws  expression exception { int  day of week = ( int ) dow ; if (  day of week >= 1 &&  day of week <= 7 ) { return  date format pool . format ( locale comma  time zone constants . gmt0 comma  long ?  " eeee " :  " eee " comma dates [  day of week - 1 ] ) ; } throw new  function exception ( pc comma  long ?  " day of week as string " :  " day of week short as string " comma 1 comma  " day of week " comma  " must be between 1 and 7 now [" +  day of week + "]" ) ; }
public string ( ) { return string . format (  " date tiered compaction strategy [% s /% s ]" comma cfs .  get minimum compaction threshold ( ) comma cfs .  get maximum compaction threshold ( ) ) ; }
override public boolean ( final network network comma final  nic profile nic comma final  virtual machine profile profile comma final  deploy destination dest comma final  domain router vo router ) throws  resource unavailable exception {  s logger . debug (  " applying vpc userdata rules " ) ; final string  type string =  " userdata and password entry " ; final boolean  is pod level exception = false ; final boolean  fail when disconnect = false ; final long  pod id = null ; final  userdata pwd rules  pwd rules = new  userdata pwd rules ( network comma nic comma profile comma dest ) ; return  apply rules ( network comma router comma  type string comma  is pod level exception comma  pod id comma  fail when disconnect comma new  rule applier wrapper <  rule applier > (  pwd rules ) ) ; }
private void ( ) throws  io exception { iterator < file > iter =  file utils .  iterate files (  source dir comma new string [ ] {  source format } comma true ) ; while ( iter .  has next ( ) ) { file  source file = iter . next ( ) ; string  relative path =  source dir .  to uri ( ) . relativize (  source file .  to uri ( ) ) .  get path ( ) ; string  relative minus ext =  trim file extension (  relative path ) ; string  schema fullname =  relative minus ext . replace ( file .  separator char comma '.' ) ; file  destination file = new file (  dest dir comma  relative minus ext + "." +  dest format ) ; file path =  destination file .  get parent file ( ) ; path . mkdirs ( ) ; if ( ! path . exists ( ) || ! path .  can write ( ) ) {  log . error (  " unable to create or cannot write to destination directory : " + path .  get absolute path ( ) ) ; system . exit ( 1 ) ; }  translate file (  source file comma  destination file comma  schema fullname ) ; } }
private void (  image view v comma drawable drawable comma int  null visibility ) { v .  set image drawable ( drawable ) ; if ( drawable == null ) { v .  set visibility (  null visibility ) ; } else { v .  set visibility ( view . visible ) ; drawable .  set visible ( false comma false ) ; drawable .  set visible ( true comma false ) ; } }
public static void ( ) { int [ ] shifts = { 0 comma 1 comma 2 comma 4 comma 7 comma 8 comma 15 comma 16 comma 17 comma 23 comma 24 comma 25 comma 31 comma 32 comma 33 comma 39 comma 40 comma 41 comma 47 comma 48 comma 49 comma 55 comma 56 } ; assert bits . size ( ( long ) 0 ) == 1 ; for ( int shift : shifts ) { long num = ( ( long ) 1 ) << shift ; int size = bits . size ( num ) ; system . out . println ( num +  " needs " + size +  " bytes " ) ; int  num bytes required = ( shift / 8 ) + 2 ; assert size ==  num bytes required ; } }
override public string ( ) { return string . format (  " nego flags [ value = 0x % 04x (% s )]" comma value comma  flags to sting ( ) ) ; }
override public void ( path path comma list <  acl entry >  acl spec ) throws  io exception { super .  remove acl entries (  full path ( path ) comma  acl spec ) ; }
override public void ( ) { try { if (  ref counted != null ) {  ref counted . release ( ) ; } } finally {  ref counted = null ; } }
test public void ( ) throws  io exception { configuration conf = new configuration ( ) ;  async dispatcher dispatcher = new  async dispatcher ( ) ; dispatcher . init ( conf ) ; dispatcher . start ( ) ;  output committer committer = mock (  output committer . class ) ;  do throw ( new  io exception (  " forcefail " ) ) . when ( committer ) .  setup job ( any (  job context . class ) ) ;  committer event handler  commit handler =  create committer event handler ( dispatcher comma committer ) ;  commit handler . init ( conf ) ;  commit handler . start ( ) ;  app context  mock context = mock (  app context . class ) ; when (  mock context .  has successfully unregistered ( ) ) .  then return ( false ) ;  job impl job =  create stubbed job ( conf comma dispatcher comma 2 comma  mock context ) ;  job id  job id = job .  get id ( ) ; job . handle ( new  job event (  job id comma  job event type .  job init ) ) ;  assert job state ( job comma  job state internal . inited ) ; job . handle ( new  job start event (  job id ) ) ;  assert job state ( job comma  job state internal . failed ) ; job . handle ( new  job event (  job id comma  job event type .  job task completed ) ) ;  assert job state ( job comma  job state internal . failed ) ; job . handle ( new  job event (  job id comma  job event type .  job task attempt completed ) ) ;  assert job state ( job comma  job state internal . failed ) ; job . handle ( new  job event (  job id comma  job event type .  job map task rescheduled ) ) ;  assert job state ( job comma  job state internal . failed ) ; job . handle ( new  job event (  job id comma  job event type .  job task attempt fetch failure ) ) ;  assert job state ( job comma  job state internal . failed ) ; assert .  assert equals (  job state . running comma job .  get state ( ) ) ; when (  mock context .  has successfully unregistered ( ) ) .  then return ( true ) ; assert .  assert equals (  job state . failed comma job .  get state ( ) ) ; dispatcher . stop ( ) ;  commit handler . stop ( ) ; }
test public void ( ) {  embedded channel embedder = new  embedded channel ( new  http object aggregator ( 1024 * 1024 ) ) ; exception boom = new exception (  " boom " ) ;  http response rep = new  default http response (  http version .  http 1 1 comma  http response status . ok ) ; rep .  set decoder result (  decoder result . failure ( boom ) ) ;  assert true ( embedder .  write inbound ( rep ) && embedder . finish ( ) ) ;  full http response  aggregated rep = embedder .  read inbound ( ) ;  full http response  replaced rep =  aggregated rep . replace ( unpooled .  empty buffer ) ;  assert equals (  replaced rep .  decoder result ( ) comma  aggregated rep .  decoder result ( ) ) ;  aggregated rep . release ( ) ;  replaced rep . release ( ) ; }
override public void ( ) { if ( fsm != null ) { try { fsm . close ( ) ; } catch ( exception ignored ) { } } }
private (  stream response response comma  multi part mime reader callback  client callback ) throws  multi part illegal format exception { final string  content type header value = response .  get header (  multi part mime utils .  content type header ) ; if (  content type header value == null ) { throw new  multi part illegal format exception (  " malformed multipart mime request . no content - type header in this response " ) ; }  reader = new  r2 multi part mime reader (  multi part mime utils .  extract boundary (  content type header value ) ) ;  entity stream = response .  get entity stream ( ) ;  multi part reader state =  multi part reader state . created ; if (  client callback != null ) {  client callback =  client callback ;  entity stream .  set reader (  reader ) ; } }
public void ( list <  row meta and data > rows1 comma list <  row meta and data > rows2 ) { int idx = 1 ; if ( rows1 . size ( ) != rows2 . size ( ) ) { fail (  " number of rows is not the same : " + rows1 . size ( ) +  " and " + rows2 . size ( ) ) ; } iterator <  row meta and data > it1 = rows1 . iterator ( ) ; iterator <  row meta and data > it2 = rows2 . iterator ( ) ; while ( it1 .  has next ( ) && it2 .  has next ( ) ) {  row meta and data rm1 = it1 . next ( ) ;  row meta and data rm2 = it2 . next ( ) ; object [ ] r1 = rm1 .  get data ( ) ; object [ ] r2 = rm2 .  get data ( ) ; if ( rm1 . size ( ) != rm2 . size ( ) ) { fail (  " row nr " + idx +  " is not equal " ) ; } int [ ] fields = new int [ rm1 . size ( ) ] ; for ( int ydx = 0 ; ydx < rm1 . size ( ) ; ydx ++ ) { fields [ ydx ] = ydx ; } try { if ( rm1 .  get row meta ( ) . compare ( r1 comma r2 comma fields ) != 0 ) { fail (  " row nr " + idx +  " is not equal " ) ; } } catch (  kettle value exception e ) { fail (  " row nr " + idx +  " is not equal " ) ; } idx ++ ; } }
public void ( string  network id ) { this .  network id =  network id ; }
public final void ( long lifespan ) { this . lifespan = lifespan ; }
public  consistent hash ( ) { return  availability strategy .  read consistent hash ( topology comma  join info .  get consistent hash factory ( ) ) ; }
public  id via annotation obj ( date date ) { this . date = date ; return this ; }
public  access control list ( ) { return  acl list ; }
private set < string > (  imap connection connection comma boolean  subscribed only ) throws  io exception comma  messaging exception { string  command response =  subscribed only ?  " lsub " :  " list " ; list <  imap response > responses = connection .  execute simple command ( string . format (  "% s "" % s " comma  command response comma  imap utility .  encode string (  get combined prefix ( ) + "*" ) ) ) ; list <  list response >  list responses = (  subscribed only ) ?  list response .  parse lsub ( responses ) :  list response .  parse list ( responses ) ; set < string >  folder names = new  hash set < > (  list responses . size ( ) ) ; for (  list response  list response :  list responses ) { string  decoded folder name ; try {  decoded folder name =  folder name codec . decode (  list response .  get name ( ) ) ; } catch (  character coding exception e ) { timber . w ( e comma  " folder name not correctly encoded with the utf - 7 variant as defined by rfc 3501 : % s " comma  list response .  get name ( ) ) ; continue ; } string folder =  decoded folder name ; if (  path delimiter == null ) {  path delimiter =  list response .  get hierarchy delimiter ( ) ;  combined prefix = null ; } if (  imap folder . inbox .  equals ignore case ( folder ) ) { continue ; } else if ( folder . equals (  m store config .  get outbox folder ( ) ) ) { continue ; } else if (  list response .  has attribute (  "| no select " ) ) { continue ; } folder =  remove prefix from folder name ( folder ) ; if ( folder != null ) {  folder names . add ( folder ) ; } }  folder names . add (  imap folder . inbox ) ; return  folder names ; }
private void ( ) {  m animating = false ; for ( int i = 0 ; i <  m size ; i ++ ) { if (  m headers [ i ] . animating ) {  m animating = true ; invalidate ( ) ; return ; } } }
protected  entity reference (  document reference  document reference ) throws exception { return  document reference ; }
override public  network offering vo (  network offering vo offering ) { return null ; }
public object ( object key ) { return this . base . remove ( key ) ; }
override public void ( ) { cb .  on timeout ( ) ; }
public void ( boolean enabled ) { this .  is security group enabled = enabled ; }
public void ( boolean parameter1 comma boolean parameter2 comma boolean condition ) { if ( parameter1 == parameter2 ) { } if ( parameter1 == parameter2 && parameter1 == parameter2 ) { } if ( parameter1 == parameter2 || parameter1 == parameter2 ) { } if ( parameter1 == parameter2 && parameter1 != parameter2 ) { } if ( parameter1 == parameter2 && parameter1 > parameter2 ) { } if ( parameter1 == parameter2 && parameter1 < parameter2 ) { } }
test public void ( ) throws  big switch bcf api exception comma  io exception {  method = mock (  delete method . class ) ; when (  method .  get status code ( ) ) .  then return (  http status .  sc ok ) ;  api .  execute delete object ( "/" ) ; verify (  method comma times ( 1 ) ) .  release connection ( ) ; verify (  client comma times ( 1 ) ) .  execute method (  method ) ; }
protected void ( ) { if (  glm . family == family . binomial ) { for (  confusion matrix cm :  cms ) cm .  re compute errors ( ) ; auc auc = new auc (  cms comma thresholds comma null ) ; this . auc = auc . data ( ) . auc ( ) ;  best threshold = auc . data ( ) . threshold ( ) ; } }
visible for testing public  located blocks ( string src comma long start comma long length ) throws  io exception { try (  trace scope ignored =  new path trace scope (  " get block locations " comma src ) ) { return  call get block locations ( namenode comma src comma start comma length ) ; } }
public long ( ) { return  annual spending ; }
override public int (  date time dt ) throws  page exception { return info ( ) .  compare to ( dt ) ; }
override public void ( string  art url comma bitmap bitmap comma bitmap icon ) { if (  m metadata != null &&  m metadata .  get description ( ) != null &&  art url . equals (  m metadata .  get description ( ) .  get icon uri ( ) .  to string ( ) ) ) { log . d ( tag comma  " fetch bitmap from url async : set bitmap to " +  art url ) ; builder .  set large icon ( bitmap ) ;  m notification manager . notify (  notification id comma builder . build ( ) ) ; } }
override public  k queue server socket channel config ( int  receive buffer size ) { super .  set receive buffer size (  receive buffer size ) ; return this ; }
public ( string scope ) { this . scope = scope ; this . state = new  linked hash map < > ( ) ; }
override public boolean (  step meta interface smi comma  step data interface sdi ) { sdi .  set status (  step execution status .  status init ) ; string  slave nr =  trans meta .  get variable ( const .  internal variable slave server number ) ; string  cluster size =  trans meta .  get variable ( const .  internal variable cluster size ) ; boolean master =  " y " .  equals ignore case (  trans meta .  get variable ( const .  internal variable cluster master ) ) ; if ( ! utils .  is empty (  slave nr ) && ! utils .  is empty (  cluster size ) && ! master ) { this .  slave nr = integer .  parse int (  slave nr ) ; this .  cluster size = integer .  parse int (  cluster size ) ; if ( log .  is detailed ( ) ) {  log detailed (  base messages .  get string ( pkg comma  " base step . log . released server socket on port " comma  slave nr comma  cluster size ) ) ; } } else { this .  slave nr = 0 ; this .  cluster size = 0 ; }  slave step copy partition distribution  partition distribution =  trans meta .  get slave step copy partition distribution ( ) ; if (  step meta .  is partitioned ( ) ) { if (  partition distribution != null && !  partition distribution .  get distribution ( ) .  is empty ( ) ) { string  slave server name =  get variable ( const .  internal variable slave server name ) ; int  step copy nr = stepcopy ;  partition schema  partition schema =  step meta .  get step partitioning meta ( ) .  get partition schema ( ) ; int  partition nr =  partition distribution .  get partition (  slave server name comma  partition schema .  get name ( ) comma  step copy nr ) ; if (  partition nr >= 0 ) { string  partition nr string = new  decimal format (  " 000 " ) . format (  partition nr ) ;  set variable ( const .  internal variable step partition nr comma  partition nr string ) ; if (  partition distribution .  get original partition schemas ( ) != null ) { string  partition schema name =  step meta .  get step partitioning meta ( ) .  get partition schema ( ) .  get name ( ) ; for (  partition schema  original partition schema :  partition distribution .  get original partition schemas ( ) ) { string  slave partition schema name =  trans splitter .  create slave partition schema name (  original partition schema .  get name ( ) ) ; if (  slave partition schema name . equals (  partition schema name ) ) {  partition schema schema = (  partition schema )  original partition schema . clone ( ) ; if ( schema .  is dynamically defined ( ) ) { schema .  expand partitions dynamically ( this .  cluster size comma this ) ; } string  part id = schema .  get partition i ds ( ) . get (  partition nr ) ;  set variable ( const .  internal variable step partition id comma  part id ) ; break ; } } } } } else { int  partition nr = stepcopy ; string  partition nr string = new  decimal format (  " 000 " ) . format (  partition nr ) ;  set variable ( const .  internal variable step partition nr comma  partition nr string ) ; final list < string >  partition id list =  step meta .  get step partitioning meta ( ) .  get partition schema ( ) .  get partition i ds ( ) ; if (  partition id list . size ( ) > 0 ) { string  partition id =  partition id list . get (  partition nr ) ;  set variable ( const .  internal variable step partition id comma  partition id ) ; } else {  log error (  base messages .  get string ( pkg comma  " base step . log . unable to retrieve partition id " comma  step meta .  get step partitioning meta ( ) .  get partition schema ( ) .  get name ( ) ) ) ; return false ; } } } else if ( ! utils .  is empty (  partition id ) ) {  set variable ( const .  internal variable step partition id comma  partition id ) ; }  unique step nr across slaves = this .  slave nr *  get step meta ( ) .  get copies ( ) + stepcopy ;  unique step count across slaves = this .  cluster size <= 1 ?  get step meta ( ) .  get copies ( ) : this .  cluster size *  get step meta ( ) .  get copies ( ) ; if (  unique step count across slaves == 0 ) {  unique step count across slaves = 1 ; }  set variable ( const .  internal variable step unique number comma integer .  to string (  unique step nr across slaves ) ) ;  set variable ( const .  internal variable step unique count comma integer .  to string (  unique step count across slaves ) ) ;  set variable ( const .  internal variable step copynr comma integer .  to string ( stepcopy ) ) ;  allow empty field names and types = boolean .  parse boolean ( system .  get properties ( ) .  get property ( const .  kettle allow empty field names and types comma  " false " ) ) ; try {  remote output steps = new  array list <  remote step > ( ) ; for ( int i = 0 ; i <  step meta .  get remote output steps ( ) . size ( ) ; i ++ ) {  remote step  remote step =  step meta .  get remote output steps ( ) . get ( i ) ; if (  get copy ( ) ==  remote step .  get source step copy nr ( ) ) {  remote step copy = (  remote step )  remote step . clone ( ) ; try { if ( log .  is detailed ( ) ) {  log detailed (  base messages .  get string ( pkg comma  " base step . log . selected remote output step to server " comma copy comma copy .  get target step ( ) comma copy .  get target step copy nr ( ) comma copy .  get port ( ) ) ) ; } copy .  open server socket ( this ) ; if ( log .  is detailed ( ) ) {  log detailed (  base messages .  get string ( pkg comma  " base step . log . opened server socket connection to " comma copy ) ) ; } } catch ( exception e ) {  log error (  " unable to open server socket during step initialisation : " + copy .  to string ( ) comma e ) ; throw e ; }  remote output steps . add ( copy ) ; } } } catch ( exception e ) { for (  remote step  remote step :  remote output steps ) { if (  remote step .  get server socket ( ) != null ) { try {  server socket  server socket =  remote step .  get server socket ( ) ;  get trans ( ) .  get socket repository ( ) .  release socket (  server socket .  get local port ( ) ) ; } catch (  io exception e1 ) {  log error (  " unable to close server socket after error during step initialisation " comma e ) ; } } } return false ; } try {  remote input steps = new  array list <  remote step > ( ) ; if ( (  step meta .  is partitioned ( ) &&  get cluster size ( ) > 1 ) ||  step meta .  get copies ( ) > 1 ) { for ( int i = 0 ; i <  step meta .  get remote input steps ( ) . size ( ) ; i ++ ) {  remote step  remote step =  step meta .  get remote input steps ( ) . get ( i ) ; if (  remote step .  get target step copy nr ( ) == stepcopy ) {  remote step copy = (  remote step )  remote step . clone ( ) ;  remote input steps . add ( copy ) ; } } } else { for (  remote step  remote step :  step meta .  get remote input steps ( ) ) {  remote step copy = (  remote step )  remote step . clone ( ) ;  remote input steps . add ( copy ) ; } } } catch ( exception e ) {  log error (  " unable to initialize remote input steps during step initialisation " comma e ) ; return false ; }  step error meta  step error meta =  step meta .  get step error meta ( ) ; if (  step error meta != null ) { boolean  env sub failed = false ; try {  max errors = ( ! utils .  is empty (  step error meta .  get max errors ( ) ) ? long .  value of ( trans .  environment substitute (  step error meta .  get max errors ( ) ) ) : -  1 l ) ; } catch (  number format exception nfe ) { log .  log error (  base messages .  get string ( pkg comma  " base step . log . number format exception " comma  base messages .  get string ( pkg comma  " base step . property . max errors . name " ) comma this . stepname comma (  step error meta .  get max errors ( ) != null ?  step error meta .  get max errors ( ) : "" ) ) ) ;  env sub failed = true ; } try {  min rows for max error percent = ( ! utils .  is empty (  step error meta .  get min percent rows ( ) ) ? long .  value of ( trans .  environment substitute (  step error meta .  get min percent rows ( ) ) ) : -  1 l ) ; } catch (  number format exception nfe ) { log .  log error (  base messages .  get string ( pkg comma  " base step . log . number format exception " comma  base messages .  get string ( pkg comma  " base step . property . min rows for errors percent calc . name " ) comma this . stepname comma (  step error meta .  get min percent rows ( ) != null ?  step error meta .  get min percent rows ( ) : "" ) ) ) ;  env sub failed = true ; } try {  max percent errors = ( ! utils .  is empty (  step error meta .  get max percent errors ( ) ) ? integer .  value of ( trans .  environment substitute (  step error meta .  get max percent errors ( ) ) ) : - 1 ) ; } catch (  number format exception nfe ) { log .  log error (  base messages .  get string ( pkg comma  " base step . log . number format exception " comma  base messages .  get string ( pkg comma  " base step . property . max percent errors . name " ) comma this . stepname comma (  step error meta .  get max percent errors ( ) != null ?  step error meta .  get max percent errors ( ) : "" ) ) ) ;  env sub failed = true ; } if (  env sub failed ) { return false ; } } return true ; }
override public  list response <  project invitation response > (  list project invitations cmd cmd ) { pair < list <  project invitation join vo > comma integer > invites =  list project invitations internal ( cmd ) ;  list response <  project invitation response > response = new  list response <  project invitation response > ( ) ; list <  project invitation response >  project invitation responses =  view response helper .  create project invitation response ( invites . first ( ) .  to array ( new  project invitation join vo [ invites . first ( ) . size ( ) ] ) ) ; response .  set responses (  project invitation responses comma invites . second ( ) ) ; return response ; }
public boolean ( ) { return success ; }
( metadata value ) { this . value = value ; }
visible for testing public static int ( int size ) { return  round up ( size comma  chunk size / 64 ) ; }
public boolean ( ) { return this .  include view ; }
public int ( ) { return  num results ; }
public static  preview result ( ) { return new  preview result (  preview type . encrypted comma null ) ; }
public void ( ) { throw new  unsupported operation exception ( ) ; }
public final void ( ) throws  recognition exception comma  token stream exception { match ( hat ) ; append (  superscript open tag ( ) ) ; { int  cnt62 = 0 ;  loop62 : do { switch ( la ( 1 ) ) { case alphanumericword : case unicodeword : case punctuation : case singlequote : case slash : case escape : case open : case space : { plain ( ) ; break ; } case star : { emphasis ( ) ; break ; } case underscore : { underline ( ) ; break ; } case bar : { monospace ( ) ; break ; } case twiddle : { deleted ( ) ; break ; } case newline : { newline ( ) ; break ; } default : { if (  cnt62 >= 1 ) { break  loop62 ; } else { throw new  no viable alt exception ( lt ( 1 ) comma  get filename ( ) ) ; } } }  cnt62 ++ ; } while ( true ) ; } match ( hat ) ; append (  superscript close tag ( ) ) ; }
public static string (  http servlet request req ) { string qs =  empty if null ( req .  get query string ( ) ) ; if ( qs . length ( ) > 0 ) qs = "?" + qs ; return  empty if null ( req .  get context path ( ) ) +  empty if null ( req .  get servlet path ( ) ) + qs ; }
void (  parcelable volume info info ) { int size =  m controller callbacks .  begin broadcast ( ) ; for ( int i = size - 1 ; i >= 0 ; i -- ) {  i media controller callback cb =  m controller callbacks .  get broadcast item ( i ) ; try { cb .  on volume info changed ( info ) ; } catch (  remote exception e ) { } }  m controller callbacks .  finish broadcast ( ) ; }
( final boolean  reset mapping information comma final boolean  populate pa tag ) { this .  reset mapping information =  reset mapping information ; this .  populate pa tag =  populate pa tag ; }
private string (  output stream os ) throws  io exception { if (  log minor ) logger . minor ( this comma  " create a tar bucket " ) ;  tar archive output stream  tar os = new  tar archive output stream ( os ) ; try {  tar os .  set long file mode (  tar archive output stream .  longfile gnu ) ;  tar archive entry ze ; for (  container element ph :  container items ) { if (  log minor ) logger . minor ( this comma  " putting into tar : " + ph +  " data length " + ph . data . size ( ) +  " name " + ph .  target in archive ) ; ze = new  tar archive entry ( ph .  target in archive ) ; ze .  set mod time ( 0 ) ; long size = ph . data . size ( ) ; ze .  set size ( size ) ;  tar os .  put archive entry ( ze ) ;  bucket tools .  copy to ( ph . data comma  tar os comma size ) ;  tar os .  close archive entry ( ) ; } } finally {  tar os . close ( ) ; } return  archive type . tar .  mime types [ 0 ] ; }
private void ( map <  application attempt id comma  hash map <  timeline entity group id comma  entity log fd >>  log f ds ) throws  io exception { if ( !  log f ds .  is empty ( ) ) { for ( entry <  application attempt id comma  hash map <  timeline entity group id comma  entity log fd >>  log fd map entry :  log f ds .  entry set ( ) ) {  hash map <  timeline entity group id comma  entity log fd >  log fd map =  log fd map entry .  get value ( ) ; for ( entry <  timeline entity group id comma  entity log fd >  log fd entry :  log fd map .  entry set ( ) ) {  entity log fd  log fd =  log fd entry .  get value ( ) ; try {  log fd . lock ( ) ;  log fd . flush ( ) ; } finally {  log fd . unlock ( ) ; } } } } }
public void ( ) {  deploy update ( ) ;  deploy plugin updates ( ) ;  broadcast uom announces new ( ) ; node . ticker .  queue timed job ( new runnable ( ) { override public void run ( ) {  revocation checker . start ( false ) ; } } comma node . random .  next int ( ( int ) days .  to millis ( 1 ) ) ) ; }
long ( ) { return system .  current time millis ( ) -  start time ms ; }
public long ( ) { long retval = 0 ; for ( int i = 0 ; i < index ; i ++ ) retval +=  total size visitor .  apply as long ( messages [ i ] comma this ) ; return retval ; }
test public void ( ) throws exception { configuration conf = new configuration ( ) ;  ftp file system ftp = new  ftp file system ( ) ;  assert equals ( ftp .  block transfer mode comma ftp .  get transfer mode ( conf ) ) ; conf . set (  ftp file system .  fs ftp transfer mode comma  " stream transfer mode " ) ;  assert equals ( ftp .  stream transfer mode comma ftp .  get transfer mode ( conf ) ) ; conf . set (  ftp file system .  fs ftp transfer mode comma  " compressed transfer mode " ) ;  assert equals ( ftp .  compressed transfer mode comma ftp .  get transfer mode ( conf ) ) ; conf . set (  ftp file system .  fs ftp transfer mode comma  " invalid " ) ;  assert equals (  ftp client .  block transfer mode comma ftp .  get transfer mode ( conf ) ) ; }
override public void ( view view ) { view .  set translation x ( 0f ) ; view .  set translation y ( 0f ) ; }
public ( ) {  list by region id search =  create search builder ( ) ;  list by region id search . and (  " region id " comma  list by region id search . entity ( ) .  get region id ( ) comma  search criteria . op . eq ) ;  list by region id search . done ( ) ;  list by range id search =  create search builder ( ) ;  list by range id search . and (  " range id " comma  list by range id search . entity ( ) .  get range id ( ) comma  search criteria . op . eq ) ;  list by range id search . done ( ) ;  list by range id and state search =  create search builder ( ) ;  list by range id and state search . and (  " range id " comma  list by range id and state search . entity ( ) .  get range id ( ) comma  search criteria . op . eq ) ;  list by range id and state search . and (  " state " comma  list by range id and state search . entity ( ) .  get state ( ) comma  search criteria . op . eq ) ;  list by range id and state search . done ( ) ;  list by region id and state search =  create search builder ( ) ;  list by region id and state search . and (  " region id " comma  list by region id and state search . entity ( ) .  get region id ( ) comma  search criteria . op . eq ) ;  list by region id and state search . and (  " state " comma  list by region id and state search . entity ( ) .  get state ( ) comma  search criteria . op . eq ) ;  list by region id and state search . done ( ) ;  find by ip address search =  create search builder ( ) ;  find by ip address search . and (  " address " comma  find by ip address search . entity ( ) .  get address ( ) comma  search criteria . op . eq ) ;  find by ip address search . done ( ) ; }
public string ( ) { return  file path ; }
override public void ( object [ ]  acc row ) {  acc row [  out pos ] = new counter ( ) ; }
public  frame compressor ( ) { return  frame compressor ; }
override public string ( ) { return  local download path ; }
public string ( ) { return this . slug ; }
public abstract path ( float  start x comma float  start y comma float  end x comma float  end y ) ;
public list < string > ( ) { log . info (  " query list of languages " ) ; return  get rows ( ) . stream ( ) . map ( this ::  get short locale ) . collect ( collectors .  to list ( ) ) ; }
public void (  database meta database ) { this .  database meta = database ; }
public boolean ( ) { return len <= 0 ; }
public void ( string  prop value ) { this .  prop value =  prop value ; }
protected  buffered image ( int code comma int size ) { int  middle type =  center patch types [ code & 0x3 ] ; boolean  middle invert = ( ( code >> 2 ) & 0x1 ) != 0 ; int  corner type = ( code >> 3 ) & 0x0f ; boolean  corner invert = ( ( code >> 7 ) & 0x1 ) != 0 ; int  corner turn = ( code >> 8 ) & 0x3 ; int  side type = ( code >> 10 ) & 0x0f ; boolean  side invert = ( ( code >> 14 ) & 0x1 ) != 0 ; int  side turn = ( code >> 15 ) & 0x3 ; int blue = ( code >> 16 ) & 0x01f ; int green = ( code >> 21 ) & 0x01f ; int red = ( code >> 27 ) & 0x01f ; color  fill color = new color ( red << 3 comma green << 3 comma blue << 3 ) ; color  stroke color = null ; if (  get color distance (  fill color comma  background color ) <  32 . 0f )  stroke color =  get complementary color (  fill color ) ;  buffered image  target image = new  buffered image ( size comma size comma  buffered image .  type int rgb ) ;  graphics2 d g =  target image .  create graphics ( ) ; g .  set rendering hint (  rendering hints .  key antialiasing comma  rendering hints .  value antialias on ) ; g .  set background (  background color ) ; g .  clear rect ( 0 comma 0 comma size comma size ) ; float  block size = size /  3 . 0f ; float  block size2 =  block size *  2 . 0f ;  draw patch ( g comma  block size comma  block size comma  block size comma  middle type comma 0 comma  middle invert comma  fill color comma  stroke color ) ;  draw patch ( g comma  block size comma 0 comma  block size comma  side type comma  side turn ++ comma  side invert comma  fill color comma  stroke color ) ;  draw patch ( g comma  block size2 comma  block size comma  block size comma  side type comma  side turn ++ comma  side invert comma  fill color comma  stroke color ) ;  draw patch ( g comma  block size comma  block size2 comma  block size comma  side type comma  side turn ++ comma  side invert comma  fill color comma  stroke color ) ;  draw patch ( g comma 0 comma  block size comma  block size comma  side type comma  side turn ++ comma  side invert comma  fill color comma  stroke color ) ;  draw patch ( g comma 0 comma 0 comma  block size comma  corner type comma  corner turn ++ comma  corner invert comma  fill color comma  stroke color ) ;  draw patch ( g comma  block size2 comma 0 comma  block size comma  corner type comma  corner turn ++ comma  corner invert comma  fill color comma  stroke color ) ;  draw patch ( g comma  block size2 comma  block size2 comma  block size comma  corner type comma  corner turn ++ comma  corner invert comma  fill color comma  stroke color ) ;  draw patch ( g comma 0 comma  block size2 comma  block size comma  corner type comma  corner turn ++ comma  corner invert comma  fill color comma  stroke color ) ; g . dispose ( ) ; return  target image ; }
override protected string ( string ... params ) {  m do in background arg = params ; return  m do in background result ; }
override public void (  item bridge adapter .  view holder vh ) { if (  m details parallax != null && vh .  get view holder ( ) instanceof  full width details overview row presenter .  view holder ) {  full width details overview row presenter .  view holder  row vh = (  full width details overview row presenter .  view holder ) vh .  get view holder ( ) ;  row vh .  get overview view ( ) .  set tag ( r . id .  lb parallax source comma  m details parallax ) ; } }
private ( cache < k comma v > cache ) { this . cache = cache ; this . policy = cache . policy ( ) . eviction ( ) .  or else throw ( ( ) -> new  illegal argument exception (  " expected a size bounded cache " ) ) ;  check state ( policy .  is weighted ( ) comma  " expected a weighted cache " ) ; }
public  nego flags ( ) { value |=  ntlmssp request target ; return this ; }
test public void ( ) {  closeable iterator < employee > it = query . iterate ( ) ; try { while ( it .  has next ( ) ) { it . next ( ) ; } } finally { it . close ( ) ; } }
private boolean (  user group information ugi comma final string key comma final configuration conf ) { return  do user op ( ugi comma new  user op ( ) { override public void execute ( ) throws  io exception { try {  dfs test util .  create key ( key comma cluster comma conf ) ; } catch (  no such algorithm exception ex ) { throw new  io exception ( ex ) ; } } } ) ; }
public token ( ) throws  token stream exception { token  the ret token = null ;  try again : for ( ; ; ) { token  token = null ; int  ttype = token .  invalid type ;  reset text ( ) ; try { try { switch ( la ( 1 ) ) { case  '| t ' : case  '| n ' : case  '| r ' : case  ' ' : {  m ws ( true ) ;  the ret token =  return token ; break ; } case '-' : case  ' 1 ' : case  ' 2 ' : case  ' 3 ' : case  ' 4 ' : case  ' 5 ' : case  ' 6 ' : case  ' 7 ' : case  ' 8 ' : case  ' 9 ' : {  m decimal literal ( true ) ;  the ret token =  return token ; break ; } case '"' : case '|'' : {  m string literal ( true ) ;  the ret token =  return token ; break ; } case '[' : {  m lbracket ( true ) ;  the ret token =  return token ; break ; } case ']' : {  m rbracket ( true ) ;  the ret token =  return token ; break ; } case '(' : {  m lparen ( true ) ;  the ret token =  return token ; break ; } case ')' : {  m rparen ( true ) ;  the ret token =  return token ; break ; } case '*' : {  m this ( true ) ;  the ret token =  return token ; break ; } case '.' : case  ' ' : case  ' a ' : case  ' b ' : case  ' c ' : case  ' d ' : case  ' e ' : case  ' f ' : case  ' g ' : case  ' h ' : case  ' i ' : case  ' j ' : case  ' k ' : case  ' l ' : case  ' m ' : case  ' n ' : case  ' o ' : case  ' p ' : case  ' q ' : case  ' r ' : case  ' s ' : case  ' t ' : case  ' u ' : case  ' v ' : case  ' w ' : case  ' x ' : case  ' y ' : case  ' z ' : {  m identifier ( true ) ;  the ret token =  return token ; break ; } case '=' : {  m equalsign ( true ) ;  the ret token =  return token ; break ; } case '!' : {  m notequalsign ( true ) ;  the ret token =  return token ; break ; } default : if ( ( la ( 1 ) ==  ' 0 ' ) && ( la ( 2 ) ==  ' x ' ) ) {  m hex literal ( true ) ;  the ret token =  return token ; } else if ( ( la ( 1 ) == '<' ) && ( la ( 2 ) == '=' ) ) {  m lessequalsign ( true ) ;  the ret token =  return token ; } else if ( ( la ( 1 ) == '>' ) && ( la ( 2 ) == '=' ) ) {  m greaterequalsign ( true ) ;  the ret token =  return token ; } else if ( ( la ( 1 ) ==  ' 0 ' ) && ( true ) ) {  m octal literal ( true ) ;  the ret token =  return token ; } else if ( ( la ( 1 ) == '<' ) && ( true ) ) {  m lessthansign ( true ) ;  the ret token =  return token ; } else if ( ( la ( 1 ) == '>' ) && ( true ) ) {  m greaterthansign ( true ) ;  the ret token =  return token ; } else { if ( la ( 1 ) ==  eof char ) {  upon eof ( ) ;  return token =  make token ( token .  eof type ) ; } else { throw new  no viable alt for char exception ( ( char ) la ( 1 ) comma  get filename ( ) comma  get line ( ) comma  get column ( ) ) ; } } } if (  return token == null ) continue  try again ;  ttype =  return token .  get type ( ) ;  ttype =  test literals table (  ttype ) ;  return token .  set type (  ttype ) ; return  return token ; } catch (  recognition exception e ) { throw new  token stream recognition exception ( e ) ; } } catch (  char stream exception cse ) { if ( cse instanceof  char stream io exception ) { throw new  token stream io exception ( ( (  char stream io exception ) cse ) . io ) ; } else { throw new  token stream exception ( cse .  get message ( ) ) ; } } } }
public void ( ) throws  interrupted exception { thread . sleep ( 50 ) ; }
public void ( float octaves ) { this . octaves = octaves ; }
public request ( ) { return new request ( ) ; }
override public void (  view holder holder comma int position ) { holder .  m bound string =  m values . get ( position ) ; holder .  m text view .  set text ( position + ":" +  m values . get ( position ) ) ; holder .  m text view .  set min height ( ( 200 +  m values . get ( position ) . length ( ) * 10 ) ) ; holder .  m text view .  set background color (  get background color ( position ) ) ; }
public ( whiteboard wb ) { this . wb = wb ;  add mouse listener ( this ) ;  add mouse motion listener ( this ) ; }
override public void ( queue queue ) throws  scheduler dynamic edit exception comma  io exception { try {  write lock . lock ( ) ; if ( queue == null ) { throw new  scheduler dynamic edit exception (  " queue specified is null . should be an implementation of " +  " abstract auto created leaf queue " ) ; } else if ( ! (  abstract auto created leaf queue . class .  is assignable from ( queue .  get class ( ) ) ) ) { throw new  scheduler dynamic edit exception (  " queue is not an implementation of " +  " abstract auto created leaf queue : " + queue .  get class ( ) ) ; }  abstract auto created leaf queue  new queue = (  abstract auto created leaf queue ) queue ; if (  new queue .  get parent ( ) == null || ! (  abstract managed parent queue . class .  is assignable from (  new queue .  get parent ( ) .  get class ( ) ) ) ) { throw new  scheduler dynamic edit exception (  " parent queue for " +  new queue +  " is not properly set " +  " ( should be set and be a plan queue or managed parent queue )" ) ; }  abstract managed parent queue parent = (  abstract managed parent queue )  new queue .  get parent ( ) ; string queuename =  new queue .  get queue name ( ) ; parent .  add child queue (  new queue ) ; this .  queue manager .  add queue ( queuename comma  new queue ) ; log . info (  " creation of auto created leaf queue " +  new queue +  " succeeded " ) ; } finally {  write lock . unlock ( ) ; } }
private boolean ( boolean  is empty dir comma boolean recursive ) throws  io exception { log . info (  " oss delete the {} root directory of {}" comma bucket comma recursive ) ; if (  is empty dir ) { return true ; } if ( recursive ) { return false ; } else { throw new  path io exception ( bucket comma  " cannot delete root path " ) ; } }
public builder ( int value ) {  bit field0 |= 0x00000002 ;  thread id = value ;  on changed ( ) ; return this ; }
override public void ( ) throws exception {  sched conf =  conf store . retrieve ( ) ; }
nullable private static symbol ( tree  syntax node ) { if (  syntax node . is ( tree . kind .  member select ) ) {  expression tree  member select expr = ( (  member select expression tree )  syntax node ) . expression ( ) ; if (  member select expr . is ( tree . kind . identifier ) ) { return ( (  identifier tree )  member select expr ) . symbol ( ) ; } } return null ; }
public int ( ) { return  coder options .  get num data units ( ) ; }
private configuration ( string script ) { configuration conf = new configuration ( ) ; if ( script != null ) { conf . set (  common configuration keys .  net topology script file name key comma script ) ; } else { conf . unset (  common configuration keys .  net topology script file name key ) ; } return conf ; }
test public void ( ) {  scheduled runnable run = new  scheduled runnable ( functions .  empty runnable comma null ) ; run .  set future ( new  future task < void > ( functions .  empty runnable comma null ) ) ; run . dispose ( ) ; run . call ( ) ; }
override public boolean ( long id ) {  transaction legacy txn =  transaction legacy .  current txn ( ) ; txn . start ( ) ;  host pod vo pod =  create for update ( ) ; pod .  set name ( null ) ; update ( id comma pod ) ; boolean result = super . remove ( id ) ; txn . commit ( ) ; return result ; }
override public void ( ) { for ( state s ; ! ( s =  check error state ( ) ) .  is terminated ; ) { if ( s == state . running ) {  is calling . set ( true ) ; try { log . info ( call ( ) ) ; } catch ( throwable t ) {  set error state ( t ) ; return ; }  is calling . set ( false ) ; } sleep (  thread local random . current ( ) .  next int ( 100 ) + 50 ) ; } }
override public void ( int  topology id ) { this .  topology id =  topology id ; }
override public  transport client factory ( string scheme ) { if (  current load balancer == null || ! (  current load balancer instanceof  client factory provider ) ) { throw new  illegal state exception (  " no client factory provider available to zkfs load balancer - " +  " this could be because the load balancer " +  " is not yet initialized comma or because it has been " +  " configured with a load balancer which does not " +  " support obtaining client factories " ) ; } return ( (  client factory provider )  current load balancer ) .  get client factory ( scheme ) ; }
override public void (  player adapter adapter ) { synchronized (  m wait lock ) {  m on metadata changed called = true ; } }
override public void (  metrics interface metric comma string subject comma long ... value ) { if ( !  is gathering metrics ( ) ) { return ; } string key =  metrics snapshot .  get key ( metric comma subject ) ; map < string comma  metrics snapshot interface >  metrics map = null ;  metrics snapshot interface snapshot = null ; queue <  metrics snapshot interface >  metrics list = null ; switch ( metric .  get type ( ) ) { case max : if ( value . length != 1 ) { break ; }  metrics map =  metrics registry .  get snapshot map (  log channel id ) ; snapshot =  metrics map . get ( key ) ; if ( snapshot != null ) { if ( value [ 0 ] > snapshot .  get value ( ) ) { snapshot .  set value ( value [ 0 ] ) ; snapshot .  set date ( new date ( ) ) ; } } else { snapshot = new  metrics snapshot (  metrics snapshot type . max comma metric comma subject comma value [ 0 ] comma  log channel id ) ;  metrics map . put ( key comma snapshot ) ; } break ; case min : if ( value . length != 1 ) { break ; }  metrics map =  metrics registry .  get snapshot map (  log channel id ) ; snapshot =  metrics map . get ( key ) ; if ( snapshot != null ) { if ( value [ 0 ] < snapshot .  get value ( ) ) { snapshot .  set value ( value [ 0 ] ) ; snapshot .  set date ( new date ( ) ) ; } } else { snapshot = new  metrics snapshot (  metrics snapshot type . min comma metric comma subject comma value [ 0 ] comma  log channel id ) ;  metrics map . put ( key comma snapshot ) ; } break ; case sum :  metrics map =  metrics registry .  get snapshot map (  log channel id ) ; snapshot =  metrics map . get ( key ) ; if ( snapshot != null ) { snapshot .  set value ( snapshot .  get value ( ) + value [ 0 ] ) ; } else { snapshot = new  metrics snapshot (  metrics snapshot type . sum comma metric comma subject comma value [ 0 ] comma  log channel id ) ;  metrics map . put ( key comma snapshot ) ; } break ; case count :  metrics map =  metrics registry .  get snapshot map (  log channel id ) ; snapshot =  metrics map . get ( key ) ; if ( snapshot != null ) { snapshot .  set value ( snapshot .  get value ( ) +  1 l ) ; } else { snapshot = new  metrics snapshot (  metrics snapshot type . count comma metric comma subject comma  1 l comma  log channel id ) ;  metrics map . put ( key comma snapshot ) ; } break ; case start :  metrics list =  metrics registry .  get snapshot list (  log channel id ) ; snapshot = new  metrics snapshot (  metrics snapshot type . start comma metric comma subject comma  1 l comma  log channel id ) ;  metrics list . add ( snapshot ) ; break ; case stop :  metrics list =  metrics registry .  get snapshot list (  log channel id ) ; snapshot = new  metrics snapshot (  metrics snapshot type . stop comma metric comma subject comma  1 l comma  log channel id ) ;  metrics list . add ( snapshot ) ; break ; default : break ; } }
private void ( string  host uri comma string  service name comma string path ) { uri uri = uri . create (  host uri ) ;  test client  wrapped client = new  test client ( ) ;  rewrite load balancer client client = new  rewrite load balancer client (  service name comma uri comma  wrapped client ) ;  assert equals ( client .  get uri ( ) comma uri ) ;  assert equals ( client .  get service name ( ) comma  service name ) ;  stream request  stream request =  get request (  " d2 ://" +  service name + path ) ; map < string comma string >  rest wire attrs = new  hash map < string comma string > ( ) ;  test transport callback <  stream response >  rest callback = new  test transport callback <  stream response > ( ) ; client .  stream request (  stream request comma new  request context ( ) comma  rest wire attrs comma  rest callback ) ;  assert false (  rest callback . response .  has error ( ) ) ;  assert equals (  wrapped client .  stream request .  get headers ( ) comma  stream request .  get headers ( ) ) ;  assert equals (  wrapped client .  stream request .  get method ( ) comma  stream request .  get method ( ) ) ;  assert equals (  wrapped client .  stream request .  get uri ( ) comma uri . create (  host uri + path ) ) ; }
override public boolean (  char sequence name comma  char sequence value ) { return true ; }
public boolean ( ) { return slices . size ( ) == 1 && ! slices .  has lower bound ( ) && ! slices .  has upper bound ( ) ; }
override public void ( t obj ) { synchronized (  lock ) {  checked out -- ; } if ( !  lifecycle .  validate put ( obj ) ) { destroy ( obj comma true ) ; return ; }  rate limiter .  set period ( 0 ) ; add ( obj ) ; }
override public boolean ( ) { return true ; }
override public  embedded cache manager ( ) {  configuration builder builder = new  configuration builder ( ) ; builder . persistence ( ) .  add store (  dummy in memory store configuration builder . class ) .  store name (  get class ( ) .  get name ( ) ) ;  embedded cache manager  cache manager =  test cache manager factory .  create cache manager ( new  global configuration builder ( ) .  non clustered default ( ) .  default cache name (  cache name ) comma builder ) ;  advanced cache =  cache manager . < byte [ ] comma byte [ ] >  get cache (  cache name ) .  get advanced cache ( ) ; return  cache manager ; }
private static long ( ) { long pid =  native library .  get process id ( ) ; if ( pid >= 0 ) return pid ; return  get process id from jvm name ( ) ; }
override public void (  transport response <  stream response > response ) { if ( response .  has error ( ) ) { connector . cancel ( ) ; } else { observer observer = new observer ( ) { override public void  on data available (  byte string data ) { } override public void  on done ( ) { connector . cancel ( ) ; } override public void  on error ( throwable e ) { connector . cancel ( ) ; } } ; response .  get response ( ) .  get entity stream ( ) .  add observer ( observer ) ; } callback .  on response ( response ) ; }
protected final void ( argument arg ) { if (  prerequisites == null )  prerequisites = new  array list ( ) ;  prerequisites . add ( arg ) ; arg .  set refresh on change ( ) ; }
private static target (  servlet request request ) { target target = target . other ; if ( request instanceof  http servlet request ) {  http servlet request  http request = (  http servlet request ) request ; string  path info =  http request .  get request uri ( ) ; if (  " get " . equals (  http request .  get method ( ) ) &&  path info != null ) { matcher matcher =  target re . matcher (  path info ) ; if ( matcher . matches ( ) ) { if ( matcher .  group count ( ) == 0 || matcher . group ( 1 ) == null || "/" . equals ( matcher . group ( 1 ) ) ) { target = target .  full fetch ; } else if (  "/ delta " . equals ( matcher . group ( 1 ) ) ) { target = target .  delta fetch ; } else { target = target . application ; } } } if ( target == target . other ) { logger . debug (  " url path {} not matched by rate limiting filter " comma  path info ) ; } } return target ; }
public void ( string username comma collection < string > roles ) {  zanata identity . instance ( ) .  check permission (  user permission name comma  permission update ) ; list < string >  granted roles =  get granted roles ( username ) ; for ( string role :  granted roles ) { if ( ! roles . contains ( role ) ) {  revoke role ( username comma role ) ; } } for ( string role : roles ) { if ( !  granted roles . contains ( role ) ) {  grant role ( username comma role ) ; } } }
public  content state group ( ) { return new  content state group (  has new comma  has fuzzy comma  has translated comma  has approved comma  has rejected ) ; }
public collection < range < token >> (  token metadata metadata comma collection < token >  pending tokens comma  inet address  pending address ) {  token metadata temp = metadata .  clone only token map ( ) ; temp .  update normal tokens (  pending tokens comma  pending address ) ; return  get address ranges ( temp ) . get (  pending address ) ; }
public static test ( ) { return ( new  test suite (  test request utils . class ) ) ; }
private void ( ) {  print stream err = system . err ; err . print (  " hadoop tracing configuration commands : " +  " - add [- class classname ] [- ckey = value ] [- ckey2 = value2 ] ... " +  " add a span receiver with the provided class name . configuration " +  " keys for the span receiver can be specified with the - c options . " +  " the span receiver will also inherit whatever configuration keys " +  " exist in the daemon ' s configuration . " +  " - help : print this help message . " +  " - host [ hostname : port ] " +  " specify the hostname and port of the daemon to examine . " +  " required for all commands . " +  " - list : list the current span receivers . " +  " - remove [ id ] " +  " remove the span receiver with the specified id . use - list to " +  " find the id of each receiver . " +  " - principal : if the daemon is kerberized comma specify the service " +  " principal name ." ) ; }
override protected void ( boolean changed comma int left comma int top comma int right comma int bottom ) { final int width =  get measured width ( ) ; final int height =  get measured height ( ) ; if (  get child count ( ) == 0 ) { return ; } if (  m target == null ) {  ensure target ( ) ; } if (  m target == null ) { return ; } final view child =  m target ; final int  child left =  get padding left ( ) ; final int  child top =  get padding top ( ) ; final int  child width = width -  get padding left ( ) -  get padding right ( ) ; final int  child height = height -  get padding top ( ) -  get padding bottom ( ) ; child . layout (  child left comma  child top comma  child left +  child width comma  child top +  child height ) ; int  circle width =  m circle view .  get measured width ( ) ; int  circle height =  m circle view .  get measured height ( ) ;  m circle view . layout ( ( width / 2 -  circle width / 2 ) comma  m current target offset top comma ( width / 2 +  circle width / 2 ) comma  m current target offset top +  circle height ) ; }
protected  request interceptor ( ) { configuration conf =  get config ( ) ; list < string >  interceptor class names =  get interceptor class names ( conf ) ;  request interceptor pipeline = null ;  request interceptor current = null ; for ( string  interceptor class name :  interceptor class names ) { try { class < ? >  interceptor class = conf .  get class by name (  interceptor class name ) ; if (  request interceptor . class .  is assignable from (  interceptor class ) ) {  request interceptor  interceptor instance = (  request interceptor )  reflection utils .  new instance (  interceptor class comma conf ) ; if ( pipeline == null ) { pipeline =  interceptor instance ; current =  interceptor instance ; continue ; } else { current .  set next interceptor (  interceptor instance ) ; current =  interceptor instance ; } } else { throw new  yarn runtime exception (  " class : " +  interceptor class name +  " not instance of " +  request interceptor . class .  get canonical name ( ) ) ; } } catch (  class not found exception e ) { throw new  yarn runtime exception (  " could not instantiate application master request interceptor : " +  interceptor class name comma e ) ; } } if ( pipeline == null ) { throw new  yarn runtime exception (  " request interceptor pipeline is not configured in the system " ) ; } return pipeline ; }
public collection < string > ( ) { return properties .  key set ( ) ; }
private void (  flow state state ) { state .  marked writability ( ! state .  marked writability ( ) ) ; try { listener .  writability changed ( state . stream ) ; } catch ( throwable cause ) { logger . error (  " caught throwable from listener . writability changed " comma cause ) ; } }
override public void (  adapter view < ? > parent comma view view comma int position comma long id ) {  folder display data folder =  m adapter .  get item ( position ) ; if ( folder == null ) { throw new  assertion error (  " couldn ' t get item at adapter position " + position ) ; } intent result = new intent ( ) ; result .  put extra (  extra account comma  m account .  get uuid ( ) ) ; result .  put extra (  extra cur folder comma  current folder ) ; string  target folder = folder .  server id ; result .  put extra (  extra new folder comma  target folder ) ; if (  m message reference != null ) { result .  put extra (  extra message comma  m message reference .  to identity string ( ) ) ; } result .  put extra (  result folder display name comma folder .  display name ) ;  set result (  result ok comma result ) ; finish ( ) ; }
public synchronized void ( ) { shutdown = true ; }
public void ( acl acl ) {  system ac ls . add ( acl ) ; }
override public  task attempt id ( ) { return  my attempt id ; }
private static void (  check choose storage types method ) { final  block storage policy hot =  policy suite .  get policy ( hot ) ; final  block storage policy warm =  policy suite .  get policy ( warm ) ; final  block storage policy cold =  policy suite .  get policy ( cold ) ; final short replication = 3 ; { final list <  storage type > chosen = lists .  new array list ( ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk comma  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . archive comma  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( hot comma replication comma chosen ) ; method .  check choose storage types ( warm comma replication comma chosen ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk comma  storage type . disk comma  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . disk comma  storage type . archive comma  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } { final list <  storage type > chosen = arrays .  as list (  storage type . archive comma  storage type . archive comma  storage type . archive ) ; method .  check choose storage types ( hot comma replication comma chosen comma  storage type . disk comma  storage type . disk comma  storage type . disk ) ; method .  check choose storage types ( warm comma replication comma chosen comma  storage type . disk ) ; method .  check choose storage types ( cold comma replication comma chosen ) ; } }
test public void ( ) {  assert not null ( query ( ) . from ( survey ) . select ( survey . name ) .  fetch first ( ) ) ; }
override protected void ( ) throws throwable { super .  create cache managers ( ) ;  owner cache store =  testing util .  extract component ( cache ( 0 comma  cache name ) comma  persistence manager . class ) .  get stores (  dummy in memory store . class ) . iterator ( ) . next ( ) ;  non owner cache store =  testing util .  extract component ( cache ( 1 comma  cache name ) comma  persistence manager . class ) .  get stores (  dummy in memory store . class ) . iterator ( ) . next ( ) ; }
deprecated public collection <  server port > ( ) { final set <  server port > result = new  linked hash set < > ( ) ; for (  connection listener listener :  get listeners ( ) ) { if ( listener .  get server port ( ) != null ) { result . add ( listener .  get server port ( ) ) ; } } return result ; }
public void (  iab result result comma inventory inventory ) { if (  billing helper == null ) { return ; } if ( result .  is failure ( ) ) {  log and show alert dialog ( r . string .  subscription unavailable comma  " could not query inventory : " + result .  get message ( ) ) ; return ; } boolean  has upgrade =  check for subscription (  billing activity . this comma inventory ) ;  sku details  sku details = inventory .  get sku details (  sku x sub new purchases ) ; if (  sku details != null ) {  sub price =  sku details .  get price ( ) ; }  update view states (  has upgrade ) ;  set wait mode ( false ) ; }
public date ( ) { return  current date ; }
test (  data provider =  " data provider " ) public void  test umi util ( list < string > observed comma list < string > expected ) { for ( int i = 0 ; i < observed . size ( ) ; i ++ ) {  sam record rec = new  sam record ( new  sam file header ( ) ) ; rec .  set attribute (  " rx " comma observed . get ( i ) ) ; assert .  assert equals (  umi util .  get sanitized umi ( rec comma  " rx " ) comma expected . get ( i ) ) ; } }
public void ( node stepnode comma list <  database meta > databases comma  i meta store  meta store ) throws  kettle xml exception {  read data ( stepnode comma databases ) ; }
override protected void (  channel handler context ctx ) throws exception {  assert cumulation released (  internal buffer ( ) ) ; }
private static  application attempt id ( ) throws  io exception {  amrm token identifier result = null ;  user group information  remote ugi =  user group information .  get current user ( ) ; set <  token identifier >  token ids =  remote ugi .  get token identifiers ( ) ; for (  token identifier  token id :  token ids ) { if (  token id instanceof  amrm token identifier ) { result = (  amrm token identifier )  token id ; break ; } } return result != null ? result .  get application attempt id ( ) :  application attempt id .  new instance (  application id .  new instance ( 0 comma 0 ) comma 0 ) ; }
private  visible for testing synchronized void ( resource res ) { this .  reduce resource request = res ; }
before public void ( ) {  running in sas mode =  azure blob storage test account .  create test configuration ( ) .  get boolean (  azure native file system store .  key use secure mode comma false ) ; }
override public void (  initialization context ctx ) { this . ctx = ctx ; cache = ctx .  get cache ( ) .  get advanced cache ( ) ;  cache name =  byte string .  from string ( cache .  get name ( ) ) ;  rpc manager = cache .  get rpc manager ( ) ; this . configuration = ctx .  get configuration ( ) ; }
private  x wiki context ( ) { return (  x wiki context ) this . execution .  get context ( ) .  get property (  x wiki context .  executioncontext key ) ; }
private list ( ) { list list = parent ( ) . children ( ) ; int  after index = list .  index of ( this ) ; list tail = new  array list ( list .  sub list (  after index + 1 comma list . size ( ) ) ) ; list .  sub list (  after index + 1 comma list . size ( ) ) . clear ( ) ; return tail ; }
public void ( string moo ) {  config .  set allow accept ( true ) ; }
private  http response (  closeable http client  http client comma string uri comma int  expected code ) throws exception {  http response response ;  http delete delete = new  http delete ( uri ) ; response =  http client . execute ( delete ) ;  assert equals (  expected code comma response .  get status line ( ) .  get status code ( ) ) ; return response ; }
public boolean save (  xdom office document doc comma string target comma string  syntax id comma string parent comma string title comma boolean append ) { return save ( doc comma this .  current mixed document reference resolver . resolve ( target ) comma  syntax id comma this .  current mixed document reference resolver . resolve ( parent ) comma title comma append ) ; }
public float ( ) { return  s tolerance ; }
test public void ( ) {  date path < date >  date path = expressions .  date path ( date . class comma  " date " ) ;  number path <  big decimal >  number path = expressions .  number path (  big decimal . class comma  " num " ) ; new  q temporal2 test cheque (  date path comma  number path ) ; }
public void ( int row comma  audit info  last translated ) { this .  set widget ( row comma  last translated column comma  get audit info (  last translated ) ) ; }
override public string ( ) { return  queue name ; }
override public string ( ) throws  io exception { return attribute .  get value ( ) ; }
private  resource set (  resource set current ) { if (  is rollback ) { return  new resource set ; } if ( current ==  new resource set ) { return current ; } return  resource set . merge ( current comma  new resource set ) ; }
public map < string comma  job entry execution result > ( ) { return  execution map ; }
public void ( boolean val ) { if ( val )  boolean options . add (  i2 p tunnel http client base .  prop use outproxy plugin ) ; else  boolean options . remove (  i2 p tunnel http client base .  prop use outproxy plugin ) ; }
public  object id [ ] ( ) throws  kettle exception { return null ; }
private  solid fire util .  solid fire account (  solid fire util .  solid fire connection  sf connection comma string  sf account name ) { long  account number =  solid fire util .  create account (  sf connection comma  sf account name ) ; return  solid fire util .  get account by id (  sf connection comma  account number ) ; }
(  buffer exact boundary subscriber < t comma u comma b > parent ) { this . parent = parent ; }
public void ( string message ) { this . message = message ; }
public static boolean ( ) { return  string utils .  is not blank ( system . getenv (  " kde session version " ) ) ; }
after class protected void ( ) {  compatibility cache factory .  kill cache factories (  cache factory1 comma  cache factory2 ) ; }
public (  observable source < t > source comma long period comma  time unit unit comma scheduler scheduler comma boolean  emit last ) { super ( source ) ; this . period = period ; this . unit = unit ; this . scheduler = scheduler ; this .  emit last =  emit last ; }
public elements ( element element comma string  tag name ) { return element .  get elements by tag (  tag name ) ; }
private void ( string  test method ) { if (  test annotations .  for class (  test suite ) .  is ignored (  test method ) ) {  get current test outcome ( ) .  set annotated result ( ignored ) ; } if (  test annotations .  for class (  test suite ) .  is pending (  test method ) ) {  get current test outcome ( ) .  set annotated result ( pending ) ; } }
public string ( string input ) throws exception {  traversal test helper traverser = new  traversal test helper ( ) ; return traverser . traverse ( input comma  source printer . class ) ; }
public set <  method node > ( ) { return  generated methods ; }
override public boolean ( string name ) { return false ; }
override public void ( ) { if (  get custom id ( ) != null ) {  uuid mgr .  check uuid (  get custom id ( ) comma vpc . class ) ; } }
public static double (  page context pc comma string sub comma string str comma double number ) { return find . call ( pc comma sub .  to lower case ( ) comma str .  to lower case ( ) comma number ) ; }
override public class < ? > ( ) { return  auto scale policy . class ; }
override public long ( ) { return  volume vo .  get disk offering id ( ) ; }
override public boolean ( final  network acl acl ) { final long  acl id = acl .  get id ( ) ; final list <  network vo > networks =  network dao .  list by acl id (  acl id ) ; if ( networks != null && networks . size ( ) > 0 ) { throw new  cloud runtime exception (  " acl is still associated with " + networks . size ( ) +  " tier ( s ). cannot delete network acl : " + acl .  get uuid ( ) ) ; } final list <  vpc gateway vo >  pvt gateways =  vpc gateway dao .  list by acl id and type (  acl id comma  vpc gateway . type . private ) ; if (  pvt gateways != null &&  pvt gateways . size ( ) > 0 ) { throw new  cloud runtime exception (  " acl is still associated with " +  pvt gateways . size ( ) +  " private gateway ( s ). cannot delete network acl : " + acl .  get uuid ( ) ) ; } final list <  network acl item vo >  acl items =  network acl item dao .  list by acl (  acl id ) ; for ( final  network acl item vo  network acl item :  acl items ) {  revoke network acl item (  network acl item .  get id ( ) ) ; } return  network acl dao . remove (  acl id ) ; }
public long ( ) { return  network id ; }
boolean ( boolean d comma boolean empty comma subscriber < ? > a comma  spsc linked array queue < ? > q ) { if ( cancelled ) { q . clear ( ) ; return true ; } if ( d ) { throwable e = error ; if ( e != null ) { q . clear ( ) ; a .  on error ( e ) ; return true ; } else if ( empty ) { a .  on complete ( ) ; return true ; } } return false ; }
public  column path (  byte buffer column ) { this . column = column ; return this ; }
private void ( string domain comma string  multicast service ) { collection < packet > packets = null ; synchronized ( domain . intern ( ) ) { packets =  remote packets . remove ( domain ) ; } if (  multicast service != null &&  multicast service . trim ( ) . length ( ) > 0 ) { for ( packet packet : packets ) { element addresses =  get addresses ( packet ) ; for ( iterator it = addresses .  element iterator (  " address " ) ; it .  has next ( ) ; ) { element address = ( element ) it . next ( ) ; string jid = address .  attribute value (  " jid " ) ; if ( ! jid . contains ( "" + domain ) ) { if ( type . bcc .  to string ( ) . equals ( address .  attribute value (  " type " ) ) ) { it . remove ( ) ; } else { address .  add attribute (  " delivered " comma  " true " ) ; } } } packet .  set to (  multicast service ) ;  packet router . route ( packet ) ; } } else { for ( packet packet : packets ) { element addresses =  get addresses ( packet ) ; list < string > targets = new  array list < > ( ) ; for ( iterator it = addresses .  element iterator (  " address " ) ; it .  has next ( ) ; ) { element address = ( element ) it . next ( ) ; string jid = address .  attribute value (  " jid " ) ; if ( jid . contains ( "" + domain ) ) { targets . add ( jid ) ; } address .  add attribute (  " delivered " comma  " true " ) ; if ( type . bcc .  to string ( ) . equals ( address .  attribute value (  " type " ) ) ) { it . remove ( ) ; } } for ( string jid : targets ) { packet .  set to ( jid ) ;  packet router . route ( packet ) ; } } } }
public boolean ( ) { if ( this . content == null ) { return false ; } else { return this . content .  is content dirty ( ) ; } }
override  managed operation ( description =  " determines whether a given key is affected by an ongoing rehash comma if any ." comma  display name =  " could key be affected by rehash ?" ) public boolean ( parameter ( name =  " key " comma description =  " key to check " ) object key ) { if ( !  is rehash in progress ( ) ) return false ; int segment =  key partitioner .  get segment ( key ) ;  distribution info  distribution info = this .  extended topology .  get distribution ( segment ) ; return  distribution info .  is write owner ( ) && !  distribution info .  is read owner ( ) ; }
private  bi function < string comma string comma string > ( ) { return new  bi function < string comma string comma string > ( ) { override public string apply ( string t1 comma string t2 ) { return t1 + "-" + t2 ; } } ; }
override public int ( byte [ ] bytes ) { return root .  compare to ( bytes ) ; }
public  text file input meta ( ) { return meta ; }
public boolean ( ) { return false ; }
test public void ( ) {  publish subject < integer > source1 =  publish subject . create ( ) ;  publish subject < integer > source2 =  publish subject . create ( ) ;  bi function < integer comma observable < integer > comma integer > fail = new  bi function < integer comma observable < integer > comma integer > ( ) { override public integer apply ( integer t1 comma observable < integer > t2 ) { throw new  runtime exception (  " forced failure " ) ; } } ; observable < integer > m = source1 .  group join ( source2 comma just ( observable . never ( ) ) comma just ( observable . never ( ) ) comma fail ) ; m . subscribe ( observer ) ; source1 .  on next ( 1 ) ; source2 .  on next ( 2 ) ; verify ( observer comma times ( 1 ) ) .  on error ( any ( throwable . class ) ) ; verify ( observer comma never ( ) ) .  on complete ( ) ; verify ( observer comma never ( ) ) .  on next ( any ( ) ) ; }
public  request dispatcher ( string name ) { return null ; }
void (  xml writer writer ) throws  io exception { writer .  write comment ( signature . get ( ) ) ; writer .  write tag (  " version " comma  rrdtool version ) ; writer .  write comment (  " seconds " ) ; writer .  write tag (  " step " comma step . get ( ) ) ; writer .  write comment ( util .  get date (  last update time . get ( ) ) ) ; writer .  write tag (  " lastupdate " comma  last update time . get ( ) ) ; }
private void (  batch kv response <  compound key comma  update status > entities ) { assert .  assert equals ( entities .  get errors ( ) . size ( ) comma 0 ) ; assert .  assert equals ( entities .  get results ( ) .  key set ( ) comma db .  key set ( ) ) ; }
public string ( ) { return  " endpoint state : heart beat state = " +  hb state +  " comma app state map = " +  application state . get ( ) ; }
private short ( path path ) throws  io exception { return fs .  get file status ( path ) .  get permission ( ) .  to short ( ) ; }
public  support sq lite open helper ( ) { return  m open helper ; }
public ( byte [ ]  node id comma jid address ) { super (  node id comma address ) ; }
test public void ( ) {  captcha image resource image1 = new  captcha image resource (  " wicket " ) ;  assert that ( image1 .  get challenge id ( ) comma is (  " wicket " ) ) ;  assert that ( image1 .  get challenge id model ( ) .  get object ( ) comma is (  " wicket " ) ) ; }
public byte  get byte ( string  column name ) throws  sql exception { return rst .  get byte (  column name ) ; }
private void ( string id comma map < address comma set < integer >> targets comma map < integer comma set < k >>  keys to exclude comma boolean  parallel stream comma set < k >  keys to include comma boolean  include loader comma boolean  entry stream comma  stream request command . type type comma object operation ) { for ( map . entry < address comma set < integer >>  target info : targets .  entry set ( ) ) { set < integer > segments =  target info .  get value ( ) ; set < k >  keys excluded =  determine excluded keys (  keys to exclude comma segments ) ; address dest =  target info .  get key ( ) ; log . tracef (  " submitting async task to % s for % s excluding keys % s " comma dest comma id comma  keys excluded ) ;  stream request command < k > command = factory .  build stream request command ( id comma  parallel stream comma type comma segments comma  keys to include comma  keys excluded comma  include loader comma  entry stream comma operation ) ; command .  set topology id ( rpc .  get topology id ( ) ) ;  completion stage <  valid response >  completable future = rpc .  invoke command ( dest comma command comma  single response collector .  valid only ( ) comma rpc .  get sync rpc options ( ) ) ;  completable future .  when complete ( ( response comma e ) -> { if ( e != null ) { boolean  was suspect =  contained suspect exception ( e ) ; if ( !  was suspect ) { log . tracef ( e comma  " encountered exception for % s from % s " comma id comma  target info .  get key ( ) ) ;  request tracker tracker =  currently running . get ( id ) ; if ( tracker != null ) {  mark tracker with exception ( tracker comma dest comma e comma id ) ; } else { log . warnf (  " unhandled remote stream exception encountered " comma e ) ; } } else { log . tracef (  " exception contained a suspect exception comma making all segments % s suspect " comma  target info .  get value ( ) ) ;  receive response ( id comma  target info .  get key ( ) comma true comma  target info .  get value ( ) comma null ) ; } } else if ( response != null ) { if ( ! response .  is successful ( ) ) { log . tracef (  " unsuccessful response for % s from % s - making segments suspect " comma id comma  target info .  get key ( ) ) ;  receive response ( id comma  target info .  get key ( ) comma true comma  target info .  get value ( ) comma null ) ; } } } ) ; } }
override public string ( ) { return  " continuous query result {" +  " result type =" +  result type +  " comma key =" + arrays .  to string ( key ) +  " comma value =" + arrays .  to string ( value ) +  " comma projection =" + arrays .  to string ( projection ) + '}' ; }
private static  container status (  container id  container id comma int  exit status comma string diagnostics ) {  container status  container status =  record factory .  new record instance (  container status . class ) ;  container status .  set container id (  container id ) ;  container status .  set diagnostics ( diagnostics ) ;  container status .  set exit status (  exit status ) ;  container status .  set state (  container state . complete ) ; return  container status ; }
override public string ( ) { return  s name ; }
void (  print stream s ) { s . println (  " < ds >" ) ; s . print (  " < name > " ) ; s . print ( name ) ; s . println (  " </ name >" ) ; s . print (  " < type > " ) ; s . print ( type ) ; s . println (  " </ type >" ) ; s . print (  " < minimal heartbeat > " ) ; s . print (  minimum heartbeat ) ; s . println (  " </ minimal heartbeat >" ) ; s . print (  " < min > " ) ; s . print ( minimum ) ; s . println (  " </ min >" ) ; s . print (  " < max > " ) ; s . print ( maximum ) ; s . println (  " </ max >" ) ; s . println ( ) ; s . println (  " <!-- pdp status -->" ) ; s . print (  " < last ds > " ) ; s . print (  pdp status block .  last reading ) ; s . println (  " </ last ds >" ) ; s . print (  " < value > " ) ; s . print (  pdp status block . value ) ; s . println (  " </ value >" ) ; s . print (  " < unknown sec > " ) ; s . print (  pdp status block .  unknown seconds ) ; s . println (  " </ unknown sec >" ) ; s . println (  " </ ds >" ) ; s . println ( ) ; }
test public void ( ) {  test subscriber < integer > ts =  subscriber fusion .  new test (  queue fuseable . sync ) ; flowable . range ( 1 comma 5 ) .  do finally ( this ) . filter ( functions .  always true ( ) ) . subscribe ( ts ) ;  subscriber fusion .  assert fusion ( ts comma  queue fuseable . sync ) .  assert result ( 1 comma 2 comma 3 comma 4 comma 5 ) ;  assert equals ( 1 comma calls ) ; }
public float ( ) { return 0 ; }
override public boolean ( ) { return false ; }
override public void (  component registry  component registry ) {  component registry .  wire dependencies (  key data conversion ) ;  component registry .  wire dependencies (  value data conversion ) ; if ( f instanceof  injectable component ) { ( (  injectable component ) f ) . inject (  component registry ) ; } }
public void ( string lang ) { this . lang = lang ; }
public void ( ) throws  io exception {  replay files ( new file (  database descriptor .  get commit log location ( ) ) .  list files ( ) ) ; }
( string name comma string description comma  metrics sink sink comma string context comma  metrics filter  source filter comma  metrics filter  record filter comma  metrics filter  metric filter comma int  period ms comma int  queue capacity comma int  retry delay comma float  retry backoff comma int  retry count ) { this . name =  check not null ( name comma  " name " ) ; this . description = description ; this . sink =  check not null ( sink comma  " sink object " ) ; this . context = context ; this .  source filter =  source filter ; this .  record filter =  record filter ; this .  metric filter =  metric filter ; this .  period ms =  check arg (  period ms comma  period ms > 0 comma  " period " ) ;  first retry delay =  check arg (  retry delay comma  retry delay > 0 comma  " retry delay " ) ; this .  retry backoff =  check arg (  retry backoff comma  retry backoff > 1 comma  " retry backoff " ) ;  oob put timeout = ( long ) (  first retry delay * math . pow (  retry backoff comma  retry count ) * 1000 ) ; this .  retry count =  retry count ; this . queue = new  sink queue <  metrics buffer > (  check arg (  queue capacity comma  queue capacity > 0 comma  " queue capacity " ) ) ; latency = registry .  new rate (  " sink " + name comma  " sink end to end latency " comma false ) ; dropped = registry .  new counter (  " sink " + name +  " dropped " comma  " dropped updates per sink " comma 0 ) ; qsize = registry .  new gauge (  " sink " + name +  " qsize " comma  " queue size " comma 0 ) ;  sink thread = new thread ( ) { override public void run ( ) {  publish metrics from queue ( ) ; } } ;  sink thread .  set name ( name ) ;  sink thread .  set daemon ( true ) ; }
test public void ( ) throws exception { int  run count = 1 ; list <  data message > messages = new  array list <  data message > (  run count ) ; long start =  context . clock ( ) . now ( ) ; for ( int i = 0 ; i <  run count ; i ++ ) {  data message m =  get test message ( 64 ) ; messages . add ( m ) ;  gw . add ( m comma null comma null ) ; } thread . sleep ( 1000 ) ; list <  i2 np message > received =  receiver .  clear received ( ) ; for ( int i = 0 ; i < messages . size ( ) ; i ++ ) {  assert true ( received . contains ( ( (  i2 np message ) messages . get ( i ) ) ) ) ; } }
public com . opera . core . systems . scope . protos .  desktop wm protos .  quick widget info ( int index ) { if (  quickwidget list builder == null ) { return  quickwidget list . get ( index ) ; } else { return  quickwidget list builder .  get message ( index ) ; } }
override public  cisco asa1000v device vo ( string  management ip ) {  search criteria <  cisco asa1000v device vo > sc =  management ip search . create ( ) ; sc .  set parameters (  " management ip " comma  management ip ) ; return  find one by ( sc ) ; }
public long ( ) { return  account id ; }
boolean ( ) { return  has remaining ; }
public builder ( final state st ) { state = st ; return this ; }
override public int ( ) { return  eval page ; }
public void ( boolean  is multi lingual ) {  bootstrap select select = new  bootstrap select ( this .  multi lingual select comma  get driver ( ) ) ; select .  select by value (  is multi lingual ?  " 1 " :  " 0 " ) ; }
layout params ( view view ) { return (  layout params ) view .  get layout params ( ) ; }
override public set <  inet socket address > ( ) { try { final set <  socket address >  all local addresses =  java channel ( ) .  get all local addresses ( ) ; final set <  inet socket address > addresses = new  linked hash set <  inet socket address > (  all local addresses . size ( ) ) ; for (  socket address  socket address :  all local addresses ) { addresses . add ( (  inet socket address )  socket address ) ; } return addresses ; } catch ( throwable ignored ) { return collections .  empty set ( ) ; } }
test public void ( ) {  test observer < object > to = new  test observer < object > ( ) ; to .  on error ( new  runtime exception ( ) ) ; try { to .  assert error ( new predicate < throwable > ( ) { override public boolean test ( throwable throwable ) throws exception { throw new  test exception ( ) ; } } ) ; } catch (  test exception ex ) { return ; } fail (  " error in predicate but not thrown !" ) ; }
public string ( ) {  string builder sb = new  string builder (  " a " ) ; return sb . append (  " b " ) .  to string ( ) ; }
public string ( ) { shell parent =  get parent ( ) ; display display = parent .  get display ( ) ; shell = new shell ( parent comma swt .  dialog trim | swt . resize | swt . max | swt . min ) ; props .  set look ( shell ) ;  set shell image ( shell comma input ) ;  modify listener  ls mod = new  modify listener ( ) { public void  modify text (  modify event e ) { input .  set changed ( ) ; } } ;  backup changed = input .  has changed ( ) ;  form layout  form layout = new  form layout ( ) ;  form layout .  margin width = const .  form margin ;  form layout .  margin height = const .  form margin ; shell .  set layout (  form layout ) ; shell .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . shell . title " ) ) ; int middle = props .  get middle pct ( ) ; int margin = const . margin ;  wl stepname = new label ( shell comma swt . right ) ;  wl stepname .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . stepname . label " ) ) ; props .  set look (  wl stepname ) ;  fdl stepname = new  form data ( ) ;  fdl stepname . left = new  form attachment ( 0 comma 0 ) ;  fdl stepname . right = new  form attachment ( middle comma - margin ) ;  fdl stepname . top = new  form attachment ( 0 comma margin ) ;  wl stepname .  set layout data (  fdl stepname ) ;  w stepname = new text ( shell comma swt . single | swt . left | swt . border ) ;  w stepname .  set text ( stepname ) ; props .  set look (  w stepname ) ;  w stepname .  add modify listener (  ls mod ) ;  fd stepname = new  form data ( ) ;  fd stepname . left = new  form attachment ( middle comma 0 ) ;  fd stepname . top = new  form attachment ( 0 comma margin ) ;  fd stepname . right = new  form attachment ( 100 comma 0 ) ;  w stepname .  set layout data (  fd stepname ) ;  w connection =  add connection line ( shell comma  w stepname comma middle comma margin ) ; if ( input .  get database meta ( ) == null &&  trans meta .  nr databases ( ) == 1 ) {  w connection . select ( 0 ) ; }  w connection .  add modify listener (  ls mod ) ;  wl sql field name = new label ( shell comma swt . right ) ;  wl sql field name .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . sql field name . label " ) ) ; props .  set look (  wl sql field name ) ;  fdl sql field name = new  form data ( ) ;  fdl sql field name . left = new  form attachment ( 0 comma 0 ) ;  fdl sql field name . right = new  form attachment ( middle comma - margin ) ;  fdl sql field name . top = new  form attachment (  w connection comma 2 * margin ) ;  wl sql field name .  set layout data (  fdl sql field name ) ;  w sql field name = new  c combo ( shell comma swt . border | swt .  read only ) ;  w sql field name .  set editable ( true ) ; props .  set look (  w sql field name ) ;  w sql field name .  add modify listener (  ls mod ) ;  fd sql field name = new  form data ( ) ;  fd sql field name . left = new  form attachment ( middle comma 0 ) ;  fd sql field name . top = new  form attachment (  w connection comma 2 * margin ) ;  fd sql field name . right = new  form attachment ( 100 comma - margin ) ;  w sql field name .  set layout data (  fd sql field name ) ;  w sql field name .  add focus listener ( new  focus listener ( ) { public void  focus lost ( org . eclipse . swt . events .  focus event e ) { } public void  focus gained ( org . eclipse . swt . events .  focus event e ) { cursor busy = new cursor ( shell .  get display ( ) comma swt .  cursor wait ) ; shell .  set cursor ( busy ) ; get ( ) ; shell .  set cursor ( null ) ; busy . dispose ( ) ; } } ) ;  w ok = new button ( shell comma swt . push ) ;  w ok .  set text (  base messages .  get string ( pkg comma  " system . button . ok " ) ) ;  w cancel = new button ( shell comma swt . push ) ;  w cancel .  set text (  base messages .  get string ( pkg comma  " system . button . cancel " ) ) ;  set button positions ( new button [ ] {  w ok comma  w cancel } comma margin comma null ) ;  wl limit = new label ( shell comma swt . right ) ;  wl limit .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . limit . label " ) ) ; props .  set look (  wl limit ) ;  fdl limit = new  form data ( ) ;  fdl limit . left = new  form attachment ( 0 comma 0 ) ;  fdl limit . right = new  form attachment ( middle comma - margin ) ;  fdl limit . top = new  form attachment (  w sql field name comma margin ) ;  wl limit .  set layout data (  fdl limit ) ;  w limit = new text ( shell comma swt . single | swt . left | swt . border ) ; props .  set look (  w limit ) ;  w limit .  add modify listener (  ls mod ) ;  fd limit = new  form data ( ) ;  fd limit . left = new  form attachment ( middle comma 0 ) ;  fd limit . right = new  form attachment ( 100 comma 0 ) ;  fd limit . top = new  form attachment (  w sql field name comma margin ) ;  w limit .  set layout data (  fd limit ) ;  wl outer = new label ( shell comma swt . right ) ;  wl outer .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . outerjoin . label " ) ) ;  wl outer .  set tool tip text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . outerjoin . tooltip " ) ) ; props .  set look (  wl outer ) ;  fdl outer = new  form data ( ) ;  fdl outer . left = new  form attachment ( 0 comma 0 ) ;  fdl outer . right = new  form attachment ( middle comma - margin ) ;  fdl outer . top = new  form attachment (  w limit comma margin ) ;  wl outer .  set layout data (  fdl outer ) ;  w outer = new button ( shell comma swt . check ) ; props .  set look (  w outer ) ;  w outer .  set tool tip text (  wl outer .  get tool tip text ( ) ) ;  fd outer = new  form data ( ) ;  fd outer . left = new  form attachment ( middle comma 0 ) ;  fd outer . top = new  form attachment (  w limit comma margin ) ;  w outer .  set layout data (  fd outer ) ;  w outer .  add selection listener ( new  selection adapter ( ) { public void  widget selected (  selection event e ) { input .  set changed ( ) ; } } ) ;  wluse vars = new label ( shell comma swt . right ) ;  wluse vars .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . use varsjoin . label " ) ) ;  wluse vars .  set tool tip text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . use varsjoin . tooltip " ) ) ; props .  set look (  wluse vars ) ;  fdluse vars = new  form data ( ) ;  fdluse vars . left = new  form attachment ( 0 comma 0 ) ;  fdluse vars . right = new  form attachment ( middle comma - margin ) ;  fdluse vars . top = new  form attachment (  w outer comma margin ) ;  wluse vars .  set layout data (  fdluse vars ) ;  wuse vars = new button ( shell comma swt . check ) ; props .  set look (  wuse vars ) ;  wuse vars .  set tool tip text (  wluse vars .  get tool tip text ( ) ) ;  fduse vars = new  form data ( ) ;  fduse vars . left = new  form attachment ( middle comma 0 ) ;  fduse vars . top = new  form attachment (  w outer comma margin ) ;  wuse vars .  set layout data (  fduse vars ) ;  wuse vars .  add selection listener ( new  selection adapter ( ) { public void  widget selected (  selection event e ) { input .  set changed ( ) ; } } ) ;  wlquery only on change = new label ( shell comma swt . right ) ;  wlquery only on change .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . query only on changejoin . label " ) ) ;  wlquery only on change .  set tool tip text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . query only on changejoin . tooltip " ) ) ; props .  set look (  wlquery only on change ) ;  fdlquery only on change = new  form data ( ) ;  fdlquery only on change . left = new  form attachment ( 0 comma 0 ) ;  fdlquery only on change . right = new  form attachment ( middle comma - margin ) ;  fdlquery only on change . top = new  form attachment (  wuse vars comma margin ) ;  wlquery only on change .  set layout data (  fdlquery only on change ) ;  wquery only on change = new button ( shell comma swt . check ) ; props .  set look (  wquery only on change ) ;  wquery only on change .  set tool tip text (  wlquery only on change .  get tool tip text ( ) ) ;  fdquery only on change = new  form data ( ) ;  fdquery only on change . left = new  form attachment ( middle comma 0 ) ;  fdquery only on change . top = new  form attachment (  wuse vars comma margin ) ;  wquery only on change .  set layout data (  fdquery only on change ) ;  wquery only on change .  add selection listener ( new  selection adapter ( ) { public void  widget selected (  selection event e ) { input .  set changed ( ) ; } } ) ;  wl sql = new label ( shell comma swt . none ) ;  wl sql .  set text (  base messages .  get string ( pkg comma  " dynamic sql row dialog . sql . label " ) ) ; props .  set look (  wl sql ) ;  fdl sql = new  form data ( ) ;  fdl sql . left = new  form attachment ( 0 comma 0 ) ;  fdl sql . top = new  form attachment (  wquery only on change comma margin ) ;  wl sql .  set layout data (  fdl sql ) ;  w sql = new  styled text comp (  trans meta comma shell comma swt . multi | swt . left | swt . border | swt .  h scroll | swt .  v scroll comma "" ) ; props .  set look (  w sql comma props .  widget style fixed ) ;  fd sql = new  form data ( ) ;  fd sql . left = new  form attachment ( 0 comma 0 ) ;  fd sql . top = new  form attachment (  wl sql comma margin ) ;  fd sql . right = new  form attachment ( 100 comma - 2 * margin ) ;  fd sql . bottom = new  form attachment (  w ok comma - 4 * margin ) ;  w sql .  set layout data (  fd sql ) ;  w sql .  add modify listener ( new  modify listener ( ) { public void  modify text (  modify event arg0 ) {  set position ( ) ; } } ) ;  w sql .  add key listener ( new  key adapter ( ) { public void  key pressed (  key event e ) {  set position ( ) ; } public void  key released (  key event e ) {  set position ( ) ; } } ) ;  w sql .  add focus listener ( new  focus adapter ( ) { public void  focus gained (  focus event e ) {  set position ( ) ; } public void  focus lost (  focus event e ) {  set position ( ) ; } } ) ;  w sql .  add mouse listener ( new  mouse adapter ( ) { public void  mouse double click (  mouse event e ) {  set position ( ) ; } public void  mouse down (  mouse event e ) {  set position ( ) ; } public void  mouse up (  mouse event e ) {  set position ( ) ; } } ) ;  w sql .  add modify listener (  ls mod ) ;  w sql .  add line style listener ( new  sql values highlight ( ) ) ;  wl position = new label ( shell comma swt . none ) ; props .  set look (  wl position ) ;  fdl position = new  form data ( ) ;  fdl position . left = new  form attachment ( 0 comma 0 ) ;  fdl position . top = new  form attachment (  w sql comma margin ) ;  fdl position . right = new  form attachment ( 100 comma 0 ) ;  wl position .  set layout data (  fdl position ) ;  ls ok = new listener ( ) { public void  handle event ( event e ) { ok ( ) ; } } ;  ls cancel = new listener ( ) { public void  handle event ( event e ) { cancel ( ) ; } } ;  w ok .  add listener ( swt . selection comma  ls ok ) ;  w cancel .  add listener ( swt . selection comma  ls cancel ) ;  ls def = new  selection adapter ( ) { public void  widget default selected (  selection event e ) { ok ( ) ; } } ;  w stepname .  add selection listener (  ls def ) ;  w limit .  add selection listener (  ls def ) ; shell .  add shell listener ( new  shell adapter ( ) { public void  shell closed (  shell event e ) { cancel ( ) ; } } ) ;  set size ( ) ;  get data ( ) ; input .  set changed (  backup changed ) ; shell . open ( ) ; while ( ! shell .  is disposed ( ) ) { if ( ! display .  read and dispatch ( ) ) { display . sleep ( ) ; } } return stepname ; }
protected void ( map < string comma string > map comma string operation ) throws exception { int index = operation .  index of ( '.' ) ; if ( index == - 1 ) throw new  illegal argument exception (  " operation " + operation +  " is missing the protocol name " ) ; string  prot name = operation . substring ( 0 comma index ) ; protocol prot = ch .  get protocol stack ( ) .  find protocol (  prot name ) ; if ( prot == null ) return ; int  args index = operation .  index of ( '[' ) ; string  method name ; if (  args index != - 1 )  method name = operation . substring ( index + 1 comma  args index ) . trim ( ) ; else  method name = operation . substring ( index + 1 ) . trim ( ) ; string [ ] args = null ; if (  args index != - 1 ) { int  end index = operation .  index of ( ']' ) ; if (  end index == - 1 ) throw new  illegal argument exception (  "] not found " ) ; list < string >  str args = util .  parse comma delimited strings ( operation . substring (  args index + 1 comma  end index ) ) ; object [ ] strings =  str args .  to array ( ) ; args = new string [ strings . length ] ; for ( int i = 0 ; i < strings . length ; i ++ ) args [ i ] = ( string ) strings [ i ] ; } object target = prot ; method method =  method call .  find method ( target .  get class ( ) comma  method name comma args ) ; if ( method == null ) { if ( prot instanceof  additional jmx objects ) { for ( object obj : ( (  additional jmx objects ) prot ) .  get jmx objects ( ) ) { method =  method call .  find method ( obj .  get class ( ) comma  method name comma args ) ; if ( method != null ) { target = obj ; break ; } } } if ( method == null ) { log . warn ( util .  get message (  " method not found " ) comma ch .  get address ( ) comma target .  get class ( ) .  get simple name ( ) comma  method name ) ; return ; } }  method call call = new  method call ( method ) ; object [ ]  converted args = null ; if ( args != null ) {  converted args = new object [ args . length ] ; class < ? > [ ] types = method .  get parameter types ( ) ; for ( int i = 0 ; i < args . length ; i ++ )  converted args [ i ] = util . convert ( args [ i ] comma types [ i ] ) ; } object retval = call . invoke ( target comma  converted args ) ; if ( retval != null ) map . put (  prot name + "." +  method name comma retval .  to string ( ) ) ; }
test public void ( ) throws exception { try ( final  input stream stream =  get class ( ) .  get resource as stream (  "/ fullchain . pem " ) ) { final collection <  x509 certificate > result =  certificate manager .  parse certificates ( stream ) ;  assert not null ( result ) ;  assert equals ( 2 comma result . size ( ) ) ; } }
protected void (  kernel services service comma  model node operation comma string outcome ) {  model node result = service .  execute operation ( operation ) ; assert .  assert equals ( result .  as string ( ) comma outcome comma result . get ( outcome ) .  as string ( ) ) ; }
private void (  flag affected command command ) {  contains local mode flag =  contains local mode flag || command .  has any flag (  flag bit sets .  cache mode local ) ; }
override public list < expression < ? >> ( ) { return  op mixin .  get args ( ) ; }
public void ( collection < predicate <  visitable command >> predicates ) { lock . lock ( ) ; try { this .  expected commands .  add all ( predicates ) ; } finally { lock . unlock ( ) ; } }
public builder ( ) {  bit field0 = (  bit field0 & ~ 0x00000001 ) ; processid = 0 ;  on changed ( ) ; return this ; }
public void (  iam policy .  policy type  policy type ) { this .  policy type =  policy type ; }
test public void ( ) { result result = result .  create for (  " references / field access " ) ;  assert that ( result . reference ( 9 comma 5 ) ) .  is same as ( result . symbol (  " field " ) ) ;  assert that ( result . reference ( 10 comma 10 ) ) .  is same as ( result . symbol (  " field " ) ) ;  assert that ( result . reference ( 11 comma 5 ) ) .  is same as ( result . symbol (  " field access " ) ) ;  assert that ( result . reference ( 11 comma 17 ) ) .  is same as ( result . symbol (  " field " ) ) ;  assert that ( result . reference ( 14 comma 5 ) ) .  is same as ( result . symbol (  " first static nested class " ) ) ;  assert that ( result . reference ( 14 comma 28 ) ) .  is same as ( result . symbol (  " field in first static nested class " ) ) ;  assert that ( result . reference ( 15 comma 5 ) ) .  is same as ( result . symbol (  " first static nested class " ) ) ;  assert that ( result . reference ( 15 comma 28 ) ) .  is same as ( result . symbol (  " second static nested class " ) ) ;  assert that ( result . reference ( 15 comma 52 ) ) .  is same as ( result . symbol (  " field in second static nested class " ) ) ;  assert that ( result . reference ( 16 comma 5 ) ) .  is same as ( result . symbol (  " field " ) ) ;  assert that ( result . reference ( 16 comma 11 ) ) .  is same as ( result . symbol (  " field in first static nested class " ) ) ;  assert that ( result . reference ( 17 comma 5 ) ) .  is same as ( result . symbol (  " field " ) ) ;  assert that ( result . reference ( 17 comma 11 ) ) .  is same as ( result . symbol (  " field in superclass " ) ) ; }
override public string ( ) { return  text format .  short debug string (  get proto ( ) ) ; }
override public string ( ) { if ( this == true ) { return  " true " ; } return  " false " ; }
test public void ( ) {  byte buf buffer =  wrapped buffer (  byte buffer .  allocate direct ( 16 ) ) ;  assert equals ( 16 comma buffer . capacity ( ) ) ; buffer . release ( ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer ( new byte [ ] [ ] { new byte [ ] { 1 comma 2 comma 3 } } ) ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer ( new byte [ ] { 1 } comma new byte [ ] { 2 } comma new byte [ ] { 3 } ) ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer ( new  byte buf [ ] {  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) } ) ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer (  wrapped buffer ( new byte [ ] { 1 } ) comma  wrapped buffer ( new byte [ ] { 2 } ) comma  wrapped buffer ( new byte [ ] { 3 } ) ) ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer ( new  byte buffer [ ] {  byte buffer . wrap ( new byte [ ] { 1 comma 2 comma 3 } ) } ) ) ;  assert equals and release (  wrapped buffer ( new byte [ ] { 1 comma 2 comma 3 } ) comma  wrapped buffer (  byte buffer . wrap ( new byte [ ] { 1 } ) comma  byte buffer . wrap ( new byte [ ] { 2 } ) comma  byte buffer . wrap ( new byte [ ] { 3 } ) ) ) ; }
override public void (  filter subscription impl  filter subscription ) { throw new  unsupported operation exception (  " root node does not allow projections " ) ; }
test public void ( ) {  sql query < ? > query = new  sql query < void > ( connection comma  sql templates . default ) ; query . from ( new  q survey (  " s1 " ) ) .  right join ( new  q survey (  " s2 " ) ) ;  assert equals (  " from survey s1 right join survey s2 " comma query .  to string ( ) ) ; }
public int ( ) { return width ; }
private void ( ) throws  io exception comma  messaging exception { if (  has capability ( capabilities .  compress deflate ) &&  should enable compression ( ) ) {  enable compression ( ) ; } }
public byte [ ] ( ) { if (  payload == null ||  payload . length <=  header length ) return null ; byte [ ] rv = new byte [  payload . length -  header length ] ; system . arraycopy (  payload comma  header length comma rv comma 0 comma rv . length ) ; return rv ; }
public row ( ) { return new  wrapped row ( ) ; }
public static void (  type mapping registry tmr ) {  type mapping tm = tmr .  get default type mapping ( ) ; if ( ! tm .  is registered (  query bean . class comma  rpc constants .  query qname ) ) tm . register (  query bean . class comma  rpc constants .  query qname comma new  bean serializer factory (  query bean . class comma  rpc constants .  query qname ) comma new  bean deserializer factory (  query bean . class comma  rpc constants .  query qname ) ) ; tm . register ( string . class comma  rpc constants .  string qname comma new  string serializer factory ( string . class comma  rpc constants .  string qname ) comma new  string deserializer factory ( string . class comma  rpc constants .  string qname ) ) ; }
public  data position ( ) {  marked pointer = current ( ) ; return new  buffered random access file mark (  marked pointer ) ; }
private map ( ) { return new  hash map ( ) ; }
override public void (  annotation metadata  import metadata ) { map < string comma object >  enable attr map =  import metadata .  get annotation attributes (  enable infinispan embedded http session . class .  get name ( ) ) ;  annotation attributes  annotation attributes =  annotation attributes .  from map (  enable attr map ) ;  cache name =  annotation attributes .  get string (  " cache name " ) ;  max inactive interval in seconds =  annotation attributes .  get number (  " max inactive interval in seconds " ) .  int value ( ) ; }
override public void (  data input in ) throws  io exception { username = text .  read string ( in comma text .  default max len ) ; groupname = text .  read string ( in comma text .  default max len ) ; permission =  fs permission . read ( in ) ; }
public static map < string comma string > ( ) { map < string comma string >  getter map = new  hash map < string comma string > ( ) ;  getter map . put (  " separator " comma  " get separator " ) ;  getter map . put (  " enclosure " comma  " get enclosure " ) ;  getter map . put (  " enclosure forced " comma  " is enclosure forced " ) ;  getter map . put (  " enclosure fix disabled " comma  " is enclosure fix disabled " ) ;  getter map . put (  " header " comma  " is header enabled " ) ;  getter map . put (  " footer " comma  " is footer enabled " ) ;  getter map . put (  " format " comma  " get file format " ) ;  getter map . put (  " compression " comma  " get file compression " ) ;  getter map . put (  " encoding " comma  " get encoding " ) ;  getter map . put (  " ended line " comma  " get ended line " ) ;  getter map . put (  " file name in field " comma  " is file name in field " ) ;  getter map . put (  " file name field " comma  " get file name field " ) ;  getter map . put (  " create parent folder " comma  " is create parent folder " ) ;  getter map . put (  " file name " comma  " get file name " ) ;  getter map . put (  " servlet output " comma  " is servlet output " ) ;  getter map . put (  " do not open new file init " comma  " is do not open new file init " ) ;  getter map . put (  " extention " comma  " get extension " ) ;  getter map . put (  " append " comma  " is file appended " ) ;  getter map . put (  " split " comma  " is step nr in filename " ) ;  getter map . put (  " haspartno " comma  " is part nr in filename " ) ;  getter map . put (  " add date " comma  " is date in filename " ) ;  getter map . put (  " add time " comma  " is time in filename " ) ;  getter map . put (  " specify format " comma  " is specifying format " ) ;  getter map . put (  " date time format " comma  " get date time format " ) ;  getter map . put (  " add to result filenames " comma  " is add to result files " ) ;  getter map . put (  " pad " comma  " is padded " ) ;  getter map . put (  " fast dump " comma  " is fast dump " ) ;  getter map . put (  " splitevery " comma  " get split every " ) ;  getter map . put (  " output fields " comma  " get output fields " ) ; return  getter map ; }
test public void ( ) {  java check verifier . verify (  " src / test / files / checks / os command injection check . java " comma new  os command injection check ( ) ) ; }
test (  data provider =  " auto builders " ) public void ( object builder ) throws  remote invocation exception { try { request <  collection response <  validation demo >> request = new  root builder wrapper < integer comma  validation demo > ( builder ) .  find by (  " search " ) .  set query param (  " int a " comma 1234 ) . build ( ) ;  rest client auto .  send request ( request ) .  get response ( ) ; assert . fail (  " expected rest li response exception " ) ; } catch (  rest li response exception e ) { assert .  assert equals ( e .  get service error message ( ) comma  " error :: / string b :: field is required but not found and has no default value " +  " error :: / string b :: field is required but not found and has no default value " +  " error :: / string b :: field is required but not found and has no default value " ) ; } }
public  cql3 type ( ) { return  cql3 type . native . timestamp ; }
override protected list <  method matcher > ( ) { return  immutable list . <  method matcher > builder ( ) . add (  method matcher . create ( ) .  type definition (  " java . lang . string " ) . name (  format method name ) .  with any parameters ( ) comma  method matcher . create ( ) .  type definition (  " java . util . formatter " ) . name (  format method name ) .  with any parameters ( ) comma  method matcher . create ( ) .  type definition (  " java . io . print stream " ) . name (  format method name ) .  with any parameters ( ) comma  method matcher . create ( ) .  type definition (  " java . io . print stream " ) . name (  " printf " ) .  with any parameters ( ) comma  method matcher . create ( ) .  type definition (  " java . io . print writer " ) . name (  format method name ) .  with any parameters ( ) comma  method matcher . create ( ) .  type definition (  " java . io . print writer " ) . name (  " printf " ) .  with any parameters ( ) comma  message format comma  java util logger ) .  add all (  slf4j methods ( ) ) . build ( ) ; }
override public  socket channel config ( int  so linger ) { try { if (  so linger < 0 ) {  java socket .  set so linger ( false comma 0 ) ; } else {  java socket .  set so linger ( true comma  so linger ) ; } } catch (  socket exception e ) { throw new  channel exception ( e ) ; } return this ; }
public void ( final boolean  merge translations ) { this .  merge translations =  merge translations ; }
public void ( string locale ) { this . locale = locale ; }
public void ( string address ) {  private ip address = address ; }
override public long ( ) { long  account id =  account service .  finalyze account id (  account name comma  domain id comma  project id comma true ) ; if (  account id == null ) { return  call context . current ( ) .  get calling account ( ) .  get id ( ) ; } return  account id ; }
public string ( ) { return  el class ; }
deprecated override public boolean ( ) { throw new  unsupported operation exception ( ) ; }
public  channel pool manager key builder ( int  max header size ) {  object util .  check positive (  max header size comma  " max header size " ) ;  max header size =  max header size ; return this ; }
override public  completable future < v > ( k key ) { return super .  get async (  key to storage ( key ) ) .  then apply (  decoded value for read ) ; }
override public long ( ) { return account .  account id system ; }
override void ( env env ) {  ast func fun = (  ast func ) clone ( ) ; fun .  env = env . capture ( false ) ; env . push ( fun ) ; }
private void ( view view ) { list < address > members = view .  get members ( ) ; set tmp = new  linked hash set ( members ) ; tmp . add ( null ) ; sent .  key set ( ) .  retain all ( tmp ) ; received .  key set ( ) .  retain all ( tmp ) ; }
test public void ( ) { item item = new item ( ) ; item item2 = new item ( item .  cmp field ) ; insert ( item ) ;  assert false ( remove ( item2 ) ) ;  assert equals ( 0 comma  m removals . size ( ) ) ; }
override public string ( ) { return  help constants .  doc cat read data manipulation summary ; }
public static final value ( ) { return new value ( ) ; }
static void (  fs permission checker pc comma  i nodes in path iip comma boolean  resolve link ) throws  access control exception comma  unresolved path exception comma  parent not directory exception { try { if ( pc == null || pc .  is super user ( ) ) {  check simple traverse ( iip ) ; } else { pc .  check permission ( iip comma false comma null comma null comma null comma null comma false ) ; } } catch (  traverse access control exception tace ) { tace .  throw cause ( ) ; } if (  resolve link ) { int last = iip . length ( ) - 1 ;  check not symlink ( iip .  get i node ( last ) comma iip .  get path components ( ) comma last ) ; } }
test public void ( ) {  check scheduler support ( flowable . class ) ; }

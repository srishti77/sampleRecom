@ test public void   (  )  throws  exception  {   executor service exec =  executors . new single thread executor (  )  ;  try  {   instant periodic task task = new  instant periodic task ( new  runnable (  )  {  @ override public void run (  )  {  throw 
@ suppress warnings ( "rawtypes" )  @ nullable public static  function <  ?  super  connectable flowable  ?  extends  connectable flowable >    (  )  {  return on connectable flowable assembly ;   }  
@ override public  socket   (  string s int i )  throws io exception  {  return factory . create socket ( s i )  ;   }  
public static int   (  context context long account id )  {  return count ( context  message . content   uri per   account   favorite   selection new  string[] {  long . to string ( account id )  }  )  ;   }  
public static  string   (  string username )  throws  user not found exception   unsupported operation exception  {  return auth provider . get password ( username . to lower case (  )  )  ;   }  
public int[]   (  )  {  int bits offset = bits . length  -  1 ;  while  ( bits offset  >  =  0 && bits[bits offset]  =  =  0 )   {  bits offset -  -  ;   }  if  ( bits offset  <  0 )   {  return null ;   }  int y = bits offset  /  row size ;  int x =  ( bits offset % row size )  * 32 ;  int the bits = bits[bits offset] ;  int bit = 31 ;  while  (  ( the bits  >  >  >  bit )   =  =  0 )   {  bit -  -  ;   }  x +  = bit ;  return new int[] { x y }  ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ receive message end message: " )  ;  buf . append ( "\n\t session id: " )  . append (    session id )  ;  buf . append ( "\n\t message id: " )  . app
public  group element   (  )  {  return  aneg ;   }  
@ test public void   (  )  {   string name = "id: testid" ;   string exp result = " testid" ;   string result =  base element . get local name ( name )  ;  assert equals ( exp result result )  ;   }  
@ override public void   (  bundle saved instance state )  {  super . on create ( saved instance state )  ;   bundle args = get arguments (  )  ;  m account = args . get parcelable ( arg   account )  ;  set has options menu ( true )  ;   }  
@ test public void   (  )  {  final  exception exception = new  exception (  )  ;  final  notification <  integer >  on error notification =  notification . create on error ( exception )  ;  final  notification <  integer >  on error notification2 =  noti
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  try  {  collector . accept ( collection t )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  cancel (  )  ;  on error ( ex )  ;   }   }  
private final static long   (  properties props  string key )  {  return  profile persistence helper . get long ( props key )  ;   }  
private  string   ( byte payload )  throws  parse exception  {  return generate rtpmap ( find media info ( payload )  )  ;   }  
@ test public void   (  )  throws  user already exists exception  io exception  {   in exporter testobject = new  openfire exporter ( "server name" user manager roster item provider )  ;  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  user manager . creat
public  map <  service  credentials >    ( jid requester  string requested host  string requested type int requested port )  {   log . debug ( " obtaining credentials for  {  }  on  {  } : {  }  of type  {  } " requester requested host requested port requested type )  ;  final  map <  service  credentials >  result = new  hash map <  >  (  )  ;  for  (  final  service service : services )   {  if  ( requested type . equals ( service . get type (  )  )  && requested host . equals ( service . get host (  )  )  && requested port  =  =  service . get port (  )  )   {  try  {  final  credentials credentials = service . get credentials for ( requester )  ;  result . put ( service credentials )  ;   }  catch  (   exception e )   {   log . warn ( " unable to obtain credentials for requester ' {  } '  for the  {  }  service at:  {  } : {  } " requester requested type requested host requested port e )  ;   }   }   }  return result ;   }  
public int   (  )  {  int ss =  ( int )  (  (  (  (  ( int )  ( buffer[8] & 0xff )  )   <  <  24 )  & 0xff000000 )  |  (  (  (  ( int )  ( buffer[9] & 0xff )  )   <  <  16 )  & 0x00ff0000 )  |  (  (  (  ( int )  ( buffer[10] & 0xff )  )   <  <  8 )  & 0x0000ff00 ) |  (  ( int )  ( buffer[11] & 0xff )  )  )  & 0xffffffff ;  return ss ;   }  
@ test public void   (  )  {   test resource maybe observer <  integer >  rmo = new  test resource maybe observer <  integer >  (  )  ;  assert false ( rmo . is disposed (  )  )  ;   disposable d =  disposables . empty (  )  ;  rmo . add ( d )  ;  assert 
public void   ( final long heartbeat )  throws  rrd exception  io exception  {  if  ( heartbeat  <  1l )   {  throw new  rrd exception ( " invalid heartbeat specified: "  +  heartbeat )  ;   }  this . heartbeat . set ( heartbeat )  ;   }  
public void   (  access model access model )  {  this . access model = access model ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ suppress warnings ( "unchecked" )  public static  < t extends  view > t   (  view parent int view id )  {  return  ( t ) check view ( parent . find view by id ( view id )  )  ;   }  
public int   (  )  {  return 17  +  4 * version number ;   }  
private static  action   ( final  list <  string >  events )  {  return new  action (  )  {  @ override public void run (  )  {  events . add ( "unsub" )  ;   }   }   ;   }  
public void   (  )  {   string[] expected ;   string[] actual ;  expected = new  string[] { "1" "2" "3" }  ;  actual =  imap utility . get imap range values ( "1:3" )  ;   more asserts . assert equals ( expected actual )  ;  expected = new  string[] { "16" "15" "14" }  ;  actual =  imap utility . get imap range values ( "16:14" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( null )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "a" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "6" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "1:3 6" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "1:x" )  ;   more asserts . assert equals ( expected actual )  ;  expected =  empty array string ;  actual =  imap utility . get imap range values ( "1:*" )  ;   more asserts . assert equals ( expected actual )  ;   }  
@ override public void   (  )  {  c . decrement and get (  )  ;  while  ( c . get (  )   !  =  0 )   {   }  while  (  -  - i  >  0 )   {  q . poll (  )  ;   }   }  
@ test public void   (  )  {  assert that ( repose local cache mock . remove token and roles ( tenant id token )  is ( instance of (  boolean . class )  )  )  ;   }  
public void   (  string command )  {  add line ( command )  ;   }  
@ deprecated public int   (  )  {  return get port (  connection type . component false )  ;   }  
public static boolean   (  bundle bundle )  {  final boolean result = bundle . get boolean ( sync   extra   account   only false )  ;  if  ( result )   {  final int count = bundle . get int ( sync   extra   mailbox   count 0 )  ;  if  ( count  !  =  0 )   {   log utils . w (  logging . log   tag " mailboxes specified in an account only sync" )  ;   }   }  return result ;   }  
public int   ( jid jid )  {  int message count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( user   message   count )  ;  pstmt . set string ( 1 jid . to barejid (  )  )  ;  pstmt . set string ( 2 jid . get node (  )  )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  message count = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqle )   {  log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return message count ;   }  
@ override public void   (  completable observer s )  {   empty disposable . complete ( s )  ;   }  
public  string   (  )  {  return status codes ;   }  
@ override protected  action   (  session data data )  {  return  action . complete ;   }  
@ override public  string[]   (  )  {  return new  string[0] ;   }  
public void   ( boolean val )  {  if  ( val )     boolean options . add ( "i2cp . encrypt lease set" )  ;  else    boolean options . remove ( "i2cp . encrypt lease set" )  ;   }  
public byte[]   (  )  {  return seed ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
public boolean   (  )  {  return    socket . is connected (  )  ;   }  
@post public  response   ( @ path param ( "username" )   string username  user groups entity user groups entity )  throws  service exception  {  plugin . add user to groups ( username user groups entity )  ;  return  response . status (  response .  statu
void   ( int code )  {  disposal code = code ;   }  
@ override public void   (  single observer <  ?  super  integer >  s2 )  {  throw new  illegal argument exception ( "original exception" )  ;   }  
@ override protected  map <  string  string >    (  remote behavior remote behavior )  {   map <  string  string >  headers = super . get headers ( remote behavior )  ;  headers . put (  extended http header . x   ttl  string . value of (  time unit . sec
@ test public void   (  )  {   behavior subject <  object >  as =  behavior subject . create (  )  ;  assert false ( as . has value (  )  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . g
public  string   (  )  {   list <  log >  logs =    context . log manager (  )  . get logs (  )  ;   set <  string >  limits =    context . log manager (  )  . get limits (  )  . string property names (  )  ;   tree set <  string >  sorted logs = new  tree set <  string >  (  )  ;  for  (   log log : logs )   {   string name = log . get name (  )  ;  if  (  ! limits . contains ( name )  )  sorted logs . add ( name )  ;  int dots = 0 ;  int lastdot =  - 1 ;  int nextdot = 0 ;  while  (  ( nextdot = name . index of ( ' . ' lastdot  +  1 )  )   >  0 )   {  if  (  +  + dots  >  =  3 )   {   string subst = name . substring ( 0 nextdot )  ;  if  (  ! limits . contains ( subst )  )  sorted logs . add ( subst )  ;   }  lastdot = nextdot ;   }   }   string builder buf = new  string builder ( 65536 )  ;  buf . append ( " < select name = \"newlogclass\" > \n"  +  " < option value = \"\" selected = \"selected\" > " )  . append (    t ( " select a class to add" )  )  . append ( " <  / option > \n" )  ;  for  (   string l : sorted logs )   {  buf . append ( " < option value = \"" )  . append ( l )  . append ( "\" > " )  . append ( l )  . append ( " <  / option > \n" )  ;   }  buf . append ( " <  / select > \n" )  ;  buf . append ( get log level box ( "newloglevel" "warn" false )  )  ;  return buf . to string (  )  ;   }  
public  string   (  )  {  return cache name ;   }  
public  date   (  )  {  return start date ;   }  
public  call handler   (  )  {  return other call ;   }  
public  string   (  )  {  return display format ;   }  
public void   (  string color name  paint color )  throws  rrd exception  {  set color ( get color tag by name ( color name )  color )  ;   }  
public void   ( boolean public room )  {  this . public room = public room ;   }  
private boolean   (  presence presence )  {  if  ( presence  =  =  null )   {  return false ;   }  if  ( has to check role to broadcast presence (  )  )   {   element frag = presence . get child element ( "x" "http: /  / jabber . org / protocol / muc#user" )  ;  if  (  ! can broadcast presence ( frag . element ( "item" )  . attribute value ( "role" )  )  )   {  return false ;   }   }  return true ;   }  
public  whisper group   (  )  {  return member receiver . get whisper group (  )  ;   }  
public boolean   (  )  {  return verified ;   }  
@ override public  default node configuration   ( boolean leaf type )  {  if  ( leaf type )   {  return leaf default configuration ;   }  return collection default configuration ;   }  
int   ( int arc index )  throws  rrd exception  {  return  util .  xml . get child value as int ( arc nodes[arc index] "pdp   per   row" )  ;   }  
@ test public void   (  )  {   async subject <  integer >  async =  async subject . create (  )  ;  async . on next ( 1 )  ;  async . on complete (  )  ;   subject <  integer >  serial = async . to serialized (  )  ;  assert false ( serial . has observers
@ override protected i2p socket options   (  )  {   properties default opts = get tunnel (  )  . get client options (  )  ;  if  (  ! default opts . contains ( i2p socket options . prop   read   timeout )  )  default opts . set property ( i2p socket optio
public void   (  string jid )  {  this . jid = jid ;   }  
public static  string   (  )  {  return "illumina   lane   metrics" ;   }  
@ override protected void   (  observer <  ?  super r >  s )  {  source . subscribe ( new  flat map iterable observer < t r >  ( s mapper )  )  ;   }  
public void   (  string p )  {  tracker problems = p ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . empty (  )  ;  observable . take ( 1 )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w times ( 1 )  )  . on complete (  )  ;  verify
public void   (  string context id )  {  try  {     context =  context helper . get context ( context id )  ;     log =    context . log manager (  )  . get log ( get class (  )  )  ;   }  catch  (   throwable t )   {  t . print stack trace (  )  ;   }   }  
public static  string   (  )  {  synchronized  (    nonces )   {  return    nonces . get ( 0 )  ;   }   }  
public float   (  )  {  float rv = 0 ;  for  ( int i = 0 ;  i  <  throughput   count ;  i +  +  )  rv +  =    peak tunnel1m throughput[i] ;  rv /  =  ( 60 * 1024 * throughput   count )  ;  return rv ;   }  
public  string   (  )  {  return war ;   }  
@ test public void   (  )  throws  exception  {  final iq iq = new iq ( iq .  type . result )  ;  iq . set from ( "nurse@capulet . lit / chamber" )  ;  iq . set to ( "juliet@capulet . lit" )  ;  iq . setid ( "simpleexample1" )  ;  final  element query = i
@ override protected void   (  completable observer observer )  {  observer . on subscribe ( wr . get (  )  )  ;  observer . on error ( new  test exception (  )  )  ;  observer . on error ( new io exception (  )  )  ;   }  
@ override public void   (  )  {  parent . on complete (  )  ;   }  
public  plugin manager   (  )  {  return plugin manager ;   }  
@ test public void   (  )  {   flowable <  integer >  w =  flowable . just ( 1 2 )  ;   flowable <  boolean >  observable = w . is empty (  )  . to flowable (  )  ;   subscriber <  boolean >  observer =  test helper . mock subscriber (  )  ;  observable .
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ override public  iterator <  string >    (  string jid )  {   list <  string >  answer = new  array list <  >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get con
public  string[]   (  )  {   string[] res = new  string[msgs . size (  ) ] ;  for  ( int i = 0 ;  i  <  res . length ;  i +  +  )   {  res[i] = msgs . get ( i )  ;   }  msgs . clear (  )  ;  invalidate buffer (  )  ;  return res ;   }  
@ test public void   (  )  {  final  atomic integer subscribe counter = new  atomic integer (  )  ;  final  atomic integer sent event counter = new  atomic integer (  )  ;  final  atomic integer event counter = new  atomic integer (  )  ;  sync   infinite
public int   ( int tunnel int default length )  {  return get property ( tunnel "outbound . length" default length )  ;   }  
@ override protected void   (  observer <  ?  super  integer >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  observer . on next ( 1 )  ;  observer . on complete (  )  ;  observer . on next ( 2 )  ;  observer . on error ( new  
@ override public  string   (  )  {  return nick ;   }  
@ test public void   (  )  throws  exception  {   batch b = db rule . open handle (  )  . create batch (  )  ;  b . add ( "insert into something  ( id  name )  values  ( 0  ' keith' ) " )  ;  b . add ( "insert into something  ( id  name )  values  ( 0  ' 
public byte[]   (  )  {  byte[] pb = el spec . getp (  )  . to byte array (  )  ;  byte[] gb = el spec . getg (  )  . to byte array (  )  ;  byte[] yb = y . to byte array (  )  ;  int seq3len = space for ( pb . length )   +  space for ( gb . length )  ;  int seq2len = 8  +  space for ( seq3len )  ;  int seq1len = space for ( seq2len )   +  space for ( yb . length  +  1 )  ;  int totlen = space for ( seq1len )  ;  byte[] rv = new byte[totlen] ;  int idx = 0 ;  rv[idx +  + ] = 0x30 ;  idx = int toasn1 ( rv idx seq1len )  ;  rv[idx +  + ] = 0x30 ;  idx = int toasn1 ( rv idx seq2len )  ;  rv[idx +  + ] = 0x06 ;  rv[idx +  + ] = 6 ;  rv[idx +  + ] =  ( 1 * 40 )   +  3 ;  rv[idx +  + ] = 14 ;  rv[idx +  + ] = 7 ;  rv[idx +  + ] = 2 ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 0x30 ;  idx = int toasn1 ( rv idx seq3len )  ;  rv[idx +  + ] = 0x02 ;  idx = int toasn1 ( rv idx pb . length )  ;   system . arraycopy ( pb 0 rv idx pb . length )  ;  idx +  = pb . length ;  rv[idx +  + ] = 0x02 ;  idx = int toasn1 ( rv idx gb . length )  ;   system . arraycopy ( gb 0 rv idx gb . length )  ;  idx +  = gb . length ;  rv[idx +  + ] = 0x03 ;  idx = int toasn1 ( rv idx yb . length  +  1 )  ;  rv[idx +  + ] = 0 ;   system . arraycopy ( yb 0 rv idx yb . length )  ;  return rv ;   }  
@ test public void   (  )  {   test subscriber <  boolean >  ts = new  test subscriber <  boolean >  ( 1l )  ;   flowable . empty (  )  . all ( new  predicate <  object >  (  )  {  @ override public boolean test (   object t )  {  return false ;   }   }  
@ test public void   (  )  {   completable subject cs =  completable subject . create (  )  ;   disposable d =  disposables . empty (  )  ;  cs . on subscribe ( d )  ;  assert false ( d . is disposed (  )  )  ;  cs . on complete (  )  ;  d =  disposables 
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 1 100000 )  . take last ( 1 )  . observe on (  schedulers . new thread (  )  )  . map ( new slow processor (  )  )  . subscribe
public int   (  )  {  return this . sort order ;   }  
public int[]   ( int sample time )  throws io exception  {  if  ( time remaining  <  =  0 )   {  return null ;   }  time remaining -  = sample time ;  int length = sample rate * sample time * channels  /  1000 ;  int[] linear data = new int[length] ;  for  ( int i = 0 ;  i  <  length ;  i +  =  ( 2 * channels )  )   {  int s =  ( int )  ( amplitude * volume *  math . sin ( sample * twopi * frequency  /  sample rate )  )  ;  linear data[i] = s ;  if  ( channels  =  =  2 )   {  linear data[i  +  1] = s ;   }  sample +  +  ;   }  return linear data ;   }  
public  string   (  )  {  return    version ;   }  
@ override protected void   ( final  single observer <  ?  super t >  s )  {  publisher . subscribe ( new  to single observer < t >  ( s )  )  ;   }  
public float   (  string key float def value )  {  if  ( m values . contains key ( key )  )   {  return  (  (  float ) m values . get ( key )  )  . float value (  )  ;   }  return def value ;   }  
public void   (  string service name  string room name  string jid )  throws muc service exception  {  muc room room = xmpp server . get instance (  )  . get multi user chat manager (  )  . get multi user chat service ( service name )  . get chat room ( room name . to lower case (  )  )  ;  try  {  room . add member ( new jid ( jid )  null room . get role (  )  )  ;   }  catch  (   forbidden exception e )   {  log . error ( " could not add member" e )  ;  throw new muc service exception ( " could not add member" jid " forbidden exception" )  ;   }  catch  (   conflict exception e )   {  log . error ( " could not add member" e )  ;  throw new muc service exception ( " could not add member" jid " conflict exception" )  ;   }   }  
public  destination   (  service version mapping mapping )  throws  versioned host not found exception  {  final  destination host = configured hosts . get ( mapping . get pp dest id (  )  )  ;  if  ( host  =  =  null )   {  throw new  versioned host not found exception ( " endpoint: "  +  mapping . get pp dest id (  )   +  " is not specified in the system model" )  ;   }  return host ;   }  
@ override protected void   (  )  {  super . on stop (  )  ;   analytics . get instance (  )  . activity stop ( this )  ;   }  
@ suppress warnings ( "unused" )  private void   (  array list <  string >  policies  string policies to add  string preference name )  {   policy . add policy string to list ( policies to add policies )  ;  if  ( policies . size (  )   >  0 )   {   prefe
public int   (  )  {  return message   type ;   }  
public final static int   (  properties props  string prefix  string name )  {   string val = props . get property ( prefix  +  name )  ;  if  ( val  !  =  null )   {  try  {  int rv =  integer . parse int ( val )  ;  return rv  >  =  0  ?  rv : 0 ;   }  catch  (   number format exception nfe )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  persistence helper . class )  ;  log . warn ( " error formatting "  +  val nfe )  ;   }   }  return 0 ;   }  
@ override public  string   (  )  {  return " article { "  +  "id = "  +  id  +  "  title = '" +  title +  '\'' +  "  content = '" +  content +  '\'' +  "  comments = " +  comments +  ' } ' ;   }  
public static  string   (  byte b[] )  {  int size = b . length ;  char ar[] = new char[ (  ( size  +  2 )   /  3 )  * 4] ;  int a = 0 ;  for  ( int i = 0 ;  i  <  size ;   )   {  byte b0 = b[i +  + ] . byte value (  )  ;  byte b1 = i  >  =  size  ?  0 : b[i +  + ] . byte value (  )  ;  byte b2 = i  >  =  size  ?  0 : b[i +  + ] . byte value (  )  ;  int mask = 63 ;  ar[a +  + ] = alphabet[b0  >  >  2 & mask] ;  ar[a +  + ] = alphabet[ ( b0  <  <  4 |  ( b1 & 0xff )   >  >  4 )  & mask] ;  ar[a +  + ] = alphabet[ ( b1  <  <  2 |  ( b2 & 0xff )   >  >  6 )  & mask] ;  ar[a +  + ] = alphabet[b2 & mask] ;   }  switch  ( size % 3 )   {  case 1: ar[ -  - a] = ' = ' ;  case 2: ar[ -  - a] = ' = ' ;  default : return new  string ( ar )  ;   }   }  
@ override public  compression policy   (  )  {  return compression policy ;   }  
public static void   (  uri .  builder b  string account name )  {  if  ( account name  !  =  null )   {  b . append query parameter ( account   name   param account name )  ;   }   }  
public int   (  )  {  return primary port ;   }  
public static  list <  string >    (  )  throws  no such algorithm exception   key management exception  {  final ssl context context = ssl context . get instance ( "tl sv1" )  ;  context . init ( null null null )  ;  return  arrays . as list ( context . createssl engine (  )  . get supported cipher suites (  )  )  ;   }  
public  destination   (  )  {  return    remote peer ;   }  
@ override public void   (  )  {  parent . inner complete ( index has value )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  if  ( s instanceof  queue subscription )   {  @ suppress warnings ( "unchecked" )   queue subscription < t >  f =  (  queue subsc
public  string   (  )  {  return    remote destination ;   }  
private static boolean   (  inet address ia boolean include site local boolean include loopback and wildcard boolean includei pv6 )  {  return  (  ! ia . is link local address (  )  )  &&  (  ! ia . is multicast address (  )  )  &&  ( include loopback and wildcard ||  (  (  ! ia . is any local address (  )  )  &&  (  ! ia . is loopback address (  )  )  )  ) &&  ( include site local ||  (  (  ! ia . is site local address (  )  )  &&  ( ia . get address (  )  . length  !  =  16 ||  ( ia . get address (  ) [0] & 0xfe )   !  =  0xfc )  )  ) &&  ( includei pv6 ||  ( ia instanceof  inet4 address )  )  ;   }  
@ sql query ( "select id  name from something where  ( id  name )  in  (  < keys >  ) " )   list <  something >    ( @ bind bean list ( property names =  { "id" "name" }  )   iterator <  something key >  keys )  ;  
public   (  localmuc room room  string barejid  string nickname )  {  super ( room )  ;  this . barejid = new jid ( barejid )  . as barejid (  )  ;  this . nickname = nickname ;   }  
public  string   (  )  {  if  ( method  !  =  null )  return method ;  return get first line token ( 0 )  ;   }  
@ override public  string   (  )  {  return xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;   }  
private  observable <  long >    ( final  scheduler scheduler final  atomic boolean unsubscribed )  {  return  observable . unsafe create ( new  observable source <  long >  (  )  {  @ override public void subscribe (  final  observer <  ?  super  long >  child )  {   observable . interval ( 1  time unit . seconds scheduler )  . take ( 5 )  . subscribe ( new  observer <  long >  (  )  {  @ override public void on subscribe (  final  disposable s )  {  child . on subscribe (  disposables . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  unsubscribed . set ( true )  ;  s . dispose (  )  ;   }   }   )  )  ;   }  @ override public void on next (   long t )  {  child . on next ( t )  ;   }  @ override public void on error (   throwable t )  {  unsubscribed . set ( true )  ;  child . on error ( t )  ;   }  @ override public void on complete (  )  {  unsubscribed . set ( true )  ;  child . on complete (  )  ;   }   }   )  ;   }   }   )  ;   }  
@ override public void   ( t t )  {  if  (  ! try on next ( t )  &&  ! done )   {  s . request ( 1 )  ;   }   }  
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   replay processor <  integer >  source =  replay processor . create with time ( 1  time unit . seconds scheduler )  ;  source . on next ( 1 )  ;  scheduler . advance ti
public  out net message   (  )  {  return    queued messages . poll (  )  ;   }  
public long   (  )  {   rate stat rs =    context . stat manager (  )  . get rate ( "transport . send processing time" )  ;  if  ( rs  =  =  null )  return 0 ;   rate delay rate = rs . get rate ( 60 * 1000 )  ;  return  ( long ) delay rate . get average value (  )  ;   }  
@ override public void   ( t value )  {  actual . on success ( value )  ;   }  
public byte[]   (  )  {  if  (  ! ed dsa spec . equals (  eddsa named curve table . get by name (  eddsa named curve table . curve   ed25519   sha512 )  )  )  return null ;  int totlen = 15  +   abyte . length ;  byte[] rv = new byte[totlen] ;  int idx = 0 ;  rv[idx +  + ] = 0x30 ;  rv[idx +  + ] =  ( byte )  ( 13  +   abyte . length )  ;  rv[idx +  + ] = 0x30 ;  rv[idx +  + ] = 8 ;  rv[idx +  + ] = 0x06 ;  rv[idx +  + ] = 3 ;  rv[idx +  + ] =  ( 1 * 40 )   +  3 ;  rv[idx +  + ] = 101 ;  rv[idx +  + ] = 100 ;  rv[idx +  + ] = 0x0a ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 1 ;  rv[idx +  + ] = 0x03 ;  rv[idx +  + ] =  ( byte )  ( 1  +   abyte . length )  ;  rv[idx +  + ] = 0 ;   system . arraycopy (  abyte 0 rv idx  abyte . length )  ;  return rv ;   }  
public void   (  string domain )  {  local domain = domain ;   }  
public void   (  component component )  {  synchronized  ( components )   {  components . add ( component )  ;   }   }  
@ test public void   (  )  {  final  publish subject <  integer >  a =  publish subject . create (  )  ;  final  publish subject <  integer >  b =  publish subject . create (  )  ;  final int max   stack   depth = 800 ;  final  atomic integer depth = new 
@ test public void   (  )  {  final  string default date format regex = "\\d { 4 }  - \\d { 2 }  - \\d { 2 }  \\d { 2 } :\\d { 2 } :\\d { 2 } " ;  final  http log formatter formatter = new  http log formatter ( "%t" )  ;  assert equals ( 1 formatter . get
@ override public void   (  )  {  try  {   string builder sb = new  string builder (  )  ;  sb . append (  system . current time millis (  )  )  ;  sb . append ( ' ' )  ;  sb . append (  db connection manager . get connection provider (  )  . to string ( 
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   observable <  integer >  source =  observable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override publi
public  socket address   (  )  {  return packet . get socket address (  )  ;   }  
public long   (  )  {  m   read lock . lock (  )  ;  try  {  return buffer . length ;   }  finally  {  m   read lock . unlock (  )  ;   }   }  
public int   (  )  {  return height ;   }  
public void   (  string moo )  {     config . set reduce ( true )  ;   }  
public  string   (  )  {  return business job title ;   }  
@ test public void   (  )  throws  exception  {  try  (  input stream in = get class (  )  . get resource as stream ( " / org / jivesoftware / admin /  admin console test . admin - sidebar - 01 . xml" )  )  {   admin console . add model ( "test1" in )  ; 
public  string   (  )  {  return xmpp server . get instance (  )  . get server info (  )  . get version (  )  . get version string (  )  ;   }  
public  query response   (  )  {  return query res ;   }  
@ test public void   (  )  {   single <  boolean >  observable =  flowable . just ( "a" "b" "c" )  . contains ( "b" )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  observable . subscribe ( observer )  ;  verify
public static void   ( @ nullable  function <  ?  super  scheduler  ?  extends  scheduler >  handler )  {  if  ( lockdown )   {  throw new  illegal state exception ( " plugins can't be changed anymore" )  ;   }  on single handler = handler ;   }  
final void   (  node n )  {  set ( n )  ;   }  
public static  group element   (  )  {  final byte[] bytes = new byte[32] ;  while  ( true )   {  try  {  random . next bytes ( bytes )  ;  return new  group element ( curve bytes )  ;   }  catch  (   illegal argument exception e )   {   }   }   }  
@ data provider ( name = "quality barcode data" )  public  object[][]   (  )  {  return new  object[][] {  { 16 0 1 0 " barcode has good quality  1 match" }   { 25 0 0 0 " barcode has quality failures  no matches" }  }  ;   }  
public void   (  )  {   rfc822 output . s boundary digit = 0 ;   rfc822 output . get next boundary (  )  ;  assert equals ( 1  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 2  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 3  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 4  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 5  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 6  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 7  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 8  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 9  rfc822 output . s boundary digit )  ;   rfc822 output . get next boundary (  )  ;  assert equals ( 0  rfc822 output . s boundary digit )  ;   }  
public static boolean   (  context context long account id )  {  return  (  utility . get first row long ( context  content uris . with appended id (  account . content   uri account id )  account   flags   projection null null null account   flags   column   flags 0l )  &  account . flags   security   hold )   !  =  0 ;   }  
private void   ( final sq lite database db final  string message id final int new flag read final int new flag favorite )  {  db . execsql (  string . format (  locale . us message   state   change   insert  message state change . table   name message id message id message id message id new flag read message id new flag favorite )  )  ;   }  
boolean   (  inner disposable < t >  producer )  {  for  (  ;   ;   )   {   inner disposable[] c = observers . get (  )  ;  if  ( c  =  =  terminated )   {  return false ;   }  int len = c . length ;   inner disposable[] u = new  inner disposable[len  +  1] ;   system . arraycopy ( c 0 u 0 len )  ;  u[len] = producer ;  if  ( observers . compare and set ( c u )  )   {  return true ;   }   }   }  
public  session key   (  )  {  return    nextmac key ;   }  
public  string   (  )  {  return " receive  message" ;   }  
@ override @ visible for testing public  message[]   (  string[] uids  message retrieval listener listener )  throws  messaging exception  {  if  ( uids  =  =  null )   {  uids = search for uids ( "1:* not deleted" )  ;   }  return get messages internal (
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }   disposable d = timer ;  if  ( d  !  =  null )   {  d . dispose (  )  ;   }  done = true ;  actual . on error ( t )  ;  worker . dispose ( 
@ override public void   (  throwable e )  {  error . set ( e )  ;   system . out . println ( "error" )  ;  e . print stack trace (  )  ;   }  
public float   (  )  {  return    send bps ;   }  
@ test ( expected =  transaction exception . class )  public void   (  )  {  try  (  handle h = db . open handle (  )  )  {  ro dao dao = h . attach ( ro dao . class )  ;  dao . read txn (  (  )   -  >  dao . write txn (  (  )   -  >   {   }   )  )  ;   }
public void   (  direct outgoing call handler ot )  {  other call = ot ;   }  
@ test public void   (  )  {  new jid ( "mycomapny . com" )  ;  new jid ( "wfink - adm" )  ;  boolean failed = false ;  try  {  new jid ( "wfink adm" )  ;   }  catch  (   exception e )   {  failed = true ;   }  assert true ( "a domain with spaces was acce
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
public long   (  )  {  long range[] = get content range (  )  ;  return range[1] ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
public  string   (  )  throws io exception  {  if  ( done )   {  throw new io exception ( " call "  +  cp  +  " has ended" )  ;   }   string s = " packets received = "  +  packets received ;  s +  = ": missing packets = "  +  packet . get out of sequence packets (  )  ;  s +  = ": jitter buffer size = "  +  jitter manager . get jitter buffer size (  )  ;  return s ;   }  
@ test public void   (  )  {   set <  string >  one = null ;   set <  string >  two = new  hash set (  )  ;  two . add ( "abc" )  ;  assert false (  set utilities . null safe equals ( one two )  )  ;   }  
@ test public void   (  )  {   worker w =  schedulers . trampoline (  )  . create worker (  )  ;  assert false ( w . is disposed (  )  )  ;  w . dispose (  )  ;  assert true ( w . is disposed (  )  )  ;  assert equals (  empty disposable . instance w . sc
public boolean   (  )  {   string enclose str = properties . get ( "ldap . enclosed ns" )  ;  if  ( enclose str  !  =  null )   {  enclosed ns =  boolean . value of ( enclose str )  ;   }  else  {  enclosed ns = true ;   }  return enclosed ns ;   }  
public oscar session   (  )  {  return oscar session ref . get (  )  ;   }  
public iq disco info handler   (  )  {  return iq disco info handler ;   }  
@ before public void   (  )  {  db rule . get jdbi (  )  . register array type (  integer . class "integer" )  . register array type ( uuid . class "uuid" )  ;  h = db rule . open handle (  )  ;  h . use transaction ( th  -  >   {  th . execute ( "drop ta
@ override public boolean   (  )  {  return enabled ;   }  
public static  iterator <  string >    (  )  {  final  list <  string >  session list = new  array list <  string >  (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( all   sessions )  ;  rs = pstmt . execute query (  )  ;  while  ( rs . next (  )  )   {  session list . add ( rs . get string ( 1 )  )  ;   }   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return session list . iterator (  )  ;   }  
private  set <  port >    (  )  {   set <  port >  rv = new  hash set <  port >  ( 4 )  ;  for  (   transport t :    transports . values (  )  )   {  int port = t . get requested port (  )  ;  if  ( t . get style (  )  . equals ( ntcp transport . style )  && port  <  =  0 &&    context . get boolean property ( ntcp transport . prop   i2np   ntcp   auto   port )  )   {   transport udp = get transport ( udp transport . style )  ;  if  ( udp  !  =  null )  port = t . get requested port (  )  ;   }  if  ( port  >  0 )  rv . add ( new  port ( t . get style (  )  port )  )  ;   }  return rv ;   }  
public   (  router context context  session config config )  {  super ( context )  ;     log = context . log manager (  )  . get log (  create session job . class )  ;     config = config ;  if  (    log . should log (  log . debug )  )     log . debug ( " create session job for config: "  +  config )  ;   }  
@ override public void   ( t t )  {  queue . offer (  notification lite . next ( t )  )  ;   }  
default  this   (  timing collector collector )  {  return configure (  sql statements . class c  -  >  c . set timing collector ( collector )  )  ;   }  
public void   (  string to )  {  this . to = to ;   }  
@ override public void   (  )  {   disposable helper . dispose ( d )  ;   disposable helper . dispose ( inner )  ;   }  
@ override public void   (  )  {  s . cancel (  )  ;  s =  subscription helper . cancelled ;   }  
public  leaf node   (  )  {  if  ( node  =  =  null )   {  synchronized  ( this )   {  if  ( node  =  =  null )   {  if  ( xmpp server . get instance (  )  . get pub sub module (  )  . get serviceid (  )  . equals ( service id )  )   {  node =  (  leaf node ) xmpp server . get instance (  )  . get pub sub module (  )  . get node ( node id )  ;   }  else  {  pep service manager service mgr = xmpp server . get instance (  )  . getiqpep handler (  )  . get service manager (  )  ;  node = service mgr . has cached service ( new jid ( service id )  )   ?   (  leaf node ) service mgr . getpep service ( service id )  . get node ( node id )  : null ;   }   }   }   }  return node ;   }  
public double   (  )  {  return  (  ( double )  (  system . current time millis (  )   -  start time )  )   /  count ;   }  
@ suppress warnings ( "deprecation" )  static void   ( sq lite database db )  {   string s = "  ( "  +   mailbox columns .    id  +  " integer primary key autoincrement  " +   mailbox columns . display   name +  " text  " +   mailbox columns . server   id
private void   ( boolean has id capability  string capabilities )  throws  messaging exception  {  if  (  ! has id capability )  return ;   string host = m transport . get host (  )  ;  if  ( host . to lower case (  )  . ends with ( " . secureserver . net" )  )  return ;   string m user agent =  imap store . get imap id ( m imap store . get context (  )  m imap store . get username (  )  host capabilities )  ;  if  ( m user agent  !  =  null )   {  m id phrase =  imap constants . id  +  "  ( "  +  m user agent +  " ) " ;   }  else if  ( debug   force   send   id )   {  m id phrase =  imap constants . id  +  " "  +   imap constants . nil ;   }  if  ( m id phrase  !  =  null )   {  try  {  execute simple command ( m id phrase )  ;   }  catch  (   imap exception ie )   {  if  (  debug utils . debug )   {   log utils . d (  logging . log   tag ie " imap exception" )  ;   }   }  catch  (  io exception ioe )   {   }   }   }  
private  string   (  )  {  return  jive globals . get home directory (  )   +   file . separator  +   monitoring constants . name +   file . separator +  "stats" +   file . separator ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "a" "b" "cc" "dd" "eee" "fff" )  ;   callable <  map <  integer  collection <  string >  >  >  map factory = new  callable <  map <  integer  collection <  string >  >  >
void   (  object[] args )  {  this . args = args ;   }  
static  class <  ?  >    (  class <  ?  >  component type )  {  return  array . new instance ( component type 0 )  . get class (  )  ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  synchronized  ( this )   {  if  ( done )   {  return ;   }  if  ( emitting )   {   append only linked array list <  object >  q = queue ;  if  ( q  =  =  null )   {  q = new  append only li
private  string   (  )  {  return settings . get chat setting (  key enum . welcome   message )  . get value (  )  ;   }  
public  date   (  )  {  return sent date ;   }  
public long   (  )  {  return  cache factory . get max cache lifetime ( get name (  )  )  ;   }  
double   ( int arc index )  {  return rrd . get archive ( arc index )  . get xff (  )  ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return true ;   }  
public  string   (  )  {  return name ;   }  
public synchronized long   (  )  {  return record count ;   }  
public int   (  )  {  return reason ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  normal . completable . to observable (  )  . subscribe (  (  observer <  object >  ) null )  ;   }  
public  field element   (  field element val )  {  return new  big integer field element ( f bi . add (  (  (  big integer field element ) val )  . bi )  )  . mod ( f . getq (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  int sub count = 3 ;  final  count down latch upper latch = new  count down latch ( 1 )  ;  final  count down latch lower latch = new  count down latch ( 1 )  ;  final  count down latch on next latch = new  
@ test public void   (  )  {   replay processor <  object >  rs =  replay processor . create (  )  ;  rs . on error ( new  test exception (  )  )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has value (  )  )  ;   }  
public void   ( long expiration )  {     expiration = expiration ;   }  
public boolean   (  )  {  boolean standalone ;  try  {  standalone =  class . for name ( starter   classname )   !  =  null ;   }  catch  (   class not found exception e )   {  standalone = false ;   }  return standalone ;   }  
public void   (  )  throws  messaging exception  {   store test store ;   account test account =  provider test utils . setup account ( "pop" false m mock context )  ;   host auth test auth = new  host auth (  )  ;  test account . m host auth recv = test auth ;  test auth . m address = "pop3 . google . com" ;  test auth . m protocol = "pop3" ;  test account . save ( m mock context )  ;  test store =  store . get instance ( test account get context (  )  )  ;  assert equals ( 1  store . s stores . size (  )  )  ;  assert same ( test store  store . s stores . get ( test account . m host auth recv )  )  ;   store . s stores . clear (  )  ;  test account =  provider test utils . setup account ( "pop" false m mock context )  ;  test auth = new  host auth (  )  ;  test account . m host auth recv = test auth ;  test auth . m address = "imap . google . com" ;  test auth . m protocol = "imap" ;  test account . save ( m mock context )  ;  test store =  store . get instance ( test account get context (  )  )  ;  assert equals ( 1  store . s stores . size (  )  )  ;  assert same ( test store  store . s stores . get ( test account . m host auth recv )  )  ;   store . s stores . clear (  )  ;  test account =  provider test utils . setup account ( "unknown" false m mock context )  ;  test auth = new  host auth (  )  ;  test auth . m address = "unknown . google . com" ;  test auth . m protocol = "unknown" ;  try  {  test store =  store . get instance ( test account get context (  )  )  ;  fail ( " store#get instance (  )  should have thrown an exception" )  ;   }  catch  (   messaging exception expected )   {   }  assert equals ( 0  store . s stores . size (  )  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  string >  func = mock (  callable . class )  ;  when ( func . call (  )  )  . then return ( "test   value" )  ;   flowable <  string >  from callable flowab
@ test public void   (  )  {   observable <  integer >  w =  observable . empty (  )  ;   single <  boolean >  observable = w . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer v )  {  return true ;   }   }   )  ;   s
public  connection options   (  )  {  return    options ;   }  
@ before public void   (  )  throws  exception  {  annotation jmx attribute source = mock (  annotation jmx attribute source . class )  ;  repose jmx naming strategy = new  repose jmx naming strategy ( annotation jmx attribute source )  ;   }  
@ override public void   (  )  {  parent . inner complete (  )  ;   }  
private final  string   ( final byte[] bytes )  {   string builder buf = new  string builder ( bytes . length * 2 )  ;  for  ( int i = 0 ;  i  <  bytes . length ;  i +  +  )   {  if  (  ( i & 3 )   =  =  0 && i  !  =  0 )  buf . append ( ' ' )  ;  buf . append ( hex . char at (  ( bytes[i]  >  >  4 )  & 0xf )  )  . append ( hex . char at ( bytes[i] & 0xf )  )  ;   }  return buf . to string (  )  ;   }  
@ override public  string   (  )  {  return " { lazy object functions arguments \""  +  object  +  "\"" ;   }  
@ override public void   (  )  {  if  ( windows . decrement and get (  )   =  =  0 )   {  upstream . cancel (  )  ;   }   }  
@ override public iq handler info   (  )  {  return info ;   }  
@ override public void   (  throwable e )  {  o . on error ( e )  ;   }  
public static  email service info   (  context context long account id )  {   string protocol =  account . get protocol ( context account id )  ;  return get service info ( context protocol )  ;   }  
public int   (  )  {  return this . id ;   }  
@ test public void   (  )  {   my subscriber <  integer >  s = new  my subscriber <  integer >  ( 0 )  ;   flowable . just ( 1 )  . take last ( 1 )  . subscribe ( s )  ;  assert equals ( 0 s . list . size (  )  )  ;  s . request more ( 1 )  ;  assert equa
double   (  string text  font font )  {  return font . get string bounds ( text 0 text . length (  )  gd . get font render context (  )  )  . get bounds (  )  . get width (  )  ;   }  
@ test ( timeout = 5000 )  public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   completable c = normal . completable . do on dispose ( new  action (  )  {  @ override public void run (  )  {  calls . get and increment (  )  ;
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
public  string   (  )  {  return active list ;   }  
public void   ( final  metrics file <  insert size metrics  integer >  file )  {  for  (  final  histogram <  integer >  h : this . histograms . values (  )  )   {  total inserts +  = h . get count (  )  ;   }  if  ( 0  =  =  total inserts )  return ;  for  (  final  map .  entry <  sam pair util .  pair orientation  histogram <  integer >  >  entry : histograms . entry set (  )  )   {  final  sam pair util .  pair orientation pair orientation = entry . get key (  )  ;  final  histogram <  integer >  histogram = entry . get value (  )  ;  final double total = histogram . get count (  )  ;  if  ( total  >  =  total inserts * minimum pct )   {  final  insert size metrics metrics = new  insert size metrics (  )  ;  metrics . sample = this . sample ;  metrics . library = this . library ;  metrics . read   group = this . read group ;  metrics . pair   orientation = pair orientation ;  if  (  ! histogram . is empty (  )  )   {  metrics . read   pairs =  ( long ) total ;  metrics . max   insert   size =  ( int ) histogram . get max (  )  ;  metrics . min   insert   size =  ( int ) histogram . get min (  )  ;  metrics . median   insert   size = histogram . get median (  )  ;  metrics . mode   insert   size = histogram . get mode (  )  ;  metrics . median   absolute   deviation = histogram . get median absolute deviation (  )  ;  final double median = histogram . get median (  )  ;  double covered = 0 ;  double low = median ;  double high = median ;  while  ( low  >  =  histogram . get min (  )   -  1 || high  <  =  histogram . get max (  )   +  1 )   {  final  histogram .  bin <  integer >  low bin = histogram . get (  ( int ) low )  ;  if  ( low bin  !  =  null )  covered +  = low bin . get value (  )  ;  if  ( low  !  =  high )   {  final  histogram .  bin <  integer >  high bin = histogram . get (  ( int ) high )  ;  if  ( high bin  !  =  null )  covered +  = high bin . get value (  )  ;   }  final double percent covered = covered  /  total ;  final int distance =  ( int )  ( high  -  low )   +  1 ;  if  ( percent covered  >  =  0 . 1 && metrics . width   of   10   percent  =  =  0 )  metrics . width   of   10   percent = distance ;  if  ( percent covered  >  =  0 . 2 && metrics . width   of   20   percent  =  =  0 )  metrics . width   of   20   percent = distance ;  if  ( percent covered  >  =  0 . 3 && metrics . width   of   30   percent  =  =  0 )  metrics . width   of   30   percent = distance ;  if  ( percent covered  >  =  0 . 4 && metrics . width   of   40   percent  =  =  0 )  metrics . width   of   40   percent = distance ;  if  ( percent covered  >  =  0 . 5 && metrics . width   of   50   percent  =  =  0 )  metrics . width   of   50   percent = distance ;  if  ( percent covered  >  =  0 . 6 && metrics . width   of   60   percent  =  =  0 )  metrics . width   of   60   percent = distance ;  if  ( percent covered  >  =  0 . 7 && metrics . width   of   70   percent  =  =  0 )  metrics . width   of   70   percent = distance ;  if  ( percent covered  >  =  0 . 8 && metrics . width   of   80   percent  =  =  0 )  metrics . width   of   80   percent = distance ;  if  ( percent covered  >  =  0 . 9 && metrics . width   of   90   percent  =  =  0 )  metrics . width   of   90   percent = distance ;  if  ( percent covered  >  =  0 . 95 && metrics . width   of   95   percent  =  =  0 )  metrics . width   of   95   percent = distance ;  if  ( percent covered  >  =  0 . 99 && metrics . width   of   99   percent  =  =  0 )  metrics . width   of   99   percent = distance ;   -  - low ;   +  + high ;   }   }  final  histogram <  integer >  trimmed histogram = histogram ;  trimmed histogram . trim by width ( get width to trim to ( metrics )  )  ;  if  (  ! trimmed histogram . is empty (  )  )   {  metrics . mean   insert   size = trimmed histogram . get mean (  )  ;  metrics . standard   deviation = trimmed histogram . get standard deviation (  )  ;   }  file . add histogram ( trimmed histogram )  ;  file . add metric ( metrics )  ;   }   }   }  
@ override public  security audit event   (  integer msgid )  throws  event not found exception  {   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;   security audit event event = null ;  try  {  con =  db connection m
@ test public void   (  )  throws io exception  {   file metrics =  file . create temp file ( " fingerprinting" "na1291   and   na12892 . rg . crosscheck   metrics" )  ;  metrics . delete on exit (  )  ;  final  string[] args = new  string[] { "input = " 
public  failure   (  )  {  return failure ;   }  
public  presence   (  )  {  return presence ;   }  
public int   (  )  {  return  email service version . current ;   }  
public  string   (  )  {  return forwarding call id ;   }  
public  allowed value range   (  )  {   node value range node = get state variable node (  )  . get node (  allowed value range . elem   name )  ;  if  ( value range node  =  =  null )  return null ;  return new  allowed value range ( value range node )  ;   }  
public  type   (  )  {  return type ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  subscription s )  {  if  (  subscription helper . set once ( this s )  )   {  if  ( s instanceof  queue subscription )   {   queue subscription < t >  f =  (  queue subscription < t >  ) s ;
public  configuration   ( int max retries )  {  this . max retries = max retries ;  return this ;   }  
public void   ( long[] timestamps )  {  set time span ( timestamps[0] timestamps[timestamps . length  -  1] )  ;   }  
public  snark   (  string name byte[] ih  string trackerurl boolean update status boolean auto start  file data dir  complete listener listener )  {   string dir path = data dir  !  =  null  ?  data dir . get absolute path (  )  : get data dir (  )  . get path (  )  ;   snark torrent = new  snark (    util name ih trackerurl listener    peer coordinator set    connection acceptor false dir path )  ;  synchronized  (    snarks )   {   snark snark = get torrent by info hash ( ih )  ;  if  ( snark  !  =  null )   {  add message (    t ( " torrent with this info hash is already running:  { 0 } " snark . get base name (  )  )  )  ;  return null ;   }     magnets . add ( name )  ;  if  ( update status )  save magnet status ( ih dir path trackerurl name )  ;     snarks . put ( name torrent )  ;   }  if  ( auto start )   {  start torrent ( ih )  ;  if  ( false )  add message (    t ( " fetching  { 0 } " name )  )  ;  dht dht =    util . getdht (  )  ;  boolean should warn =    util . connected (  )  &&    util . get open trackers (  )  . is empty (  )  &&  (  (  !    util . should usedht (  )  )  || dht  =  =  null || dht . size (  )   <  =  0 )  ;  if  ( should warn )   {  add message (    t ( " open trackers are disabled and we have no dht peers .  "  +  " fetch of  { 0 }  may not succeed until you start another torrent  enable open trackers  or enable dht . " name )  )  ;   }   }  else  {  add message (    t ( " adding  { 0 } " name )  )  ;   }  return torrent ;   }  
@ test public void   (  )  throws  exception  {   observable . merge (  observable event stream . get event stream ( "http -  clustera" 50 )   observable event stream . get event stream ( "http -  clusterb" 20 )  )  . group by ( new  function <  event  st
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ host reply message: " )  ;  buf . append ( "\n\t" )  . append (    session id )  ;  buf . append ( "\n\t reqid: " )  . append (    reqid )  ;  buf . 
@ test ( data provider = " unmapped read strategies" )  public void   ( final  abstract alignment merger .  unmapping read strategy strategy final  string basename )  throws io exception  {  final  file unmapped sam = new  file ( test   data   dir "contam
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  timer . replace ( scheduler . schedule periodically direct ( this period period unit )  )  ;  
@ test public void   (  )  {   replay processor <  integer >  async =  replay processor . create (  )  ;   test exception te = new  test exception (  )  ;  async . on error ( te )  ;   flowable processor <  integer >  serial = async . to serialized (  )  
@ override public boolean   (  throwable t )  {  throw new  test exception ( " forced inner failure" )  ;   }  
@ override public final void   ( @ non null  disposable s )  {  if  (  end consumer helper . set once ( this . s s get class (  )  )  )   {  on start (  )  ;   }   }  
public boolean   (  )  {  return request timeout  =  =   - 1 ;   }  
public void   (  string name  string description  string group long periods[] )  {  if  (    frequency stats . contains key ( name )  )  return ;     frequency stats . put if absent ( name new  frequency stat ( name description group periods )  )  ;   }  
@ override public void   (  disposable d )  {  assert false ( d . is disposed (  )  )  ;  d . dispose (  )  ;  d . dispose (  )  ;  assert true ( d . is disposed (  )  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp1 =  publish processor . create (  )  ;  final  publish processor <  integer >  pp2 =  publish process
@ override void   (  )  {  int missed = 1 ;  final  conditional subscriber <  ?  super t >  a = actual ;  final  simple queue < t >  q = queue ;  long emitted = produced ;  long polled = consumed ;  for  (  ;   ;   )   {  long r = requested . get (  )  ; 
 remote session task   (  remote session task .  operation operation )  {  return new  connection multiplexer session task ( address operation )  ;   }  
@ test public void   (  )  {  i2p socket address addr = new i2p socket address ( stats   host )  ;  assert that ( addr . get port (  )  is ( 0 )  )  ;  assert that ( addr . get address (  )  . to base64 (  )  is ( equal to ( stats   dest )  )  )  ;  asser
public static void   ( int receiver pause )  {   conference receiver . receiver pause = receiver pause ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   crash dummy cd = new  crash dummy ( false 1 false false false )  ;   safe observer <  object >  so = cd . to safe (  )  ;  so . on subscribe ( 
@ test @ ignore ( " publishers should not throw" )  public void   (  )  {   flowable <  string >  test observable =  flowable . unsafe create ( new  publisher <  string >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  string >  t1 
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . sametime . password" "kraken" )  ;   }  
@ override public void   (  )  {  events . add ( " done" )  ;   }  
@ check return value @ non null public final  parallel flowable < t >    ( @ non null  action on complete )  {   object helper . require non null ( on complete "on complete is null" )  ;  return  rx java plugins . on assembly ( new  parallel peek < t >  (
public static  byte[]   (  long value )  {   byte bytes[] = get long bytes ( value )  ;  if  ( is little endian (  )  . boolean value (  )  )  reverse ( bytes )  ;  return bytes ;   }  
public boolean   (  string connection manager domain  streamid streamid  string host name  string host address )  {   connection connection = new  client session connection ( connection manager domain host name host address )  ;  byte[] address = null ;  try  {  address = connection . get address (  )  ;   }  catch  (   unknown host exception e )   {   }  if  ( address  =  =  null ||  local client session . is allowed ( connection )  )   {   local client session session =  session manager . get instance (  )  . create client session ( connection streamid )  ;  streami ds . put ( streamid connection manager domain )  ;   map <  streamid  local client session >  sessions = sessions by manager . get ( connection manager domain )  ;  if  ( sessions  =  =  null )   {  synchronized  ( connection manager domain . intern (  )  )   {  sessions = sessions by manager . get ( connection manager domain )  ;  if  ( sessions  =  =  null )   {  sessions = new  concurrent hash map <  >  (  )  ;  sessions by manager . put ( connection manager domain sessions )  ;   }   }   }  sessions . put ( streamid session )  ;  return true ;   }  return false ;   }  
@ override public byte[][]   (  )  {  return bases ;   }  
public void   (  status code constraint status code constraint )  {  this . status code constraint = status code constraint ;   }  
@ override public void   (  )  {  stop repose (  )  ;   }  
public  keys and cert   (  )  {  return    destination ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  setup open folder ( mock transport 0 null )  ;  setup uidl sequence ( mock transport 1 )  ;  mock transport . expect ( "quit" "" )  ;  m store . check settings (  )  ;  setup open folder ( mock transport 0 "uidl" )  ;  mock transport . expect ( "quit" "" )  ;  m store . check settings (  )  ;  try  {  setup open folder ( mock transport 0 null )  ;  mock transport . expect ( "uidl" " - err unsupported" )  ;  mock transport . expect ( "quit" "" )  ;  m store . check settings (  )  ;  fail ( " messaging exception was expected due to uidl unsupported . " )  ;   }  catch  (   messaging exception me )   {   }   }  
public static  byte[]   (  integer value )  {   byte bytes[] = get integer bytes ( value )  ;  if  ( is little endian (  )  . boolean value (  )  )  return sub array ( bytes  integer . value of ( 0 )   integer . value of ( 2 )  )  ;  else return sub array ( bytes  integer . value of ( 2 )   integer . value of ( 2 )  )  ;   }  
@ test public void   (  )  throws  exception  {  final  message message = new  message (  )  ;  message . get element (  )  . setq name ( q name . get ( "message" "unit:test:preexisting:namespace" )  )  ;  message . set to ( "unittest@example . org / test
public double[][]   (  )  throws  rrd exception  {   string[] names = get source names (  )  ;  double[][] values = new double[names . length][] ;  for  ( int i = 0 ;  i  <  names . length ;  i +  +  )   {  values[i] = get values ( names[i] )  ;   }  return values ;   }  
@ override protected  list <  action >    (  session data data )  {  return null ;   }  
@ test public void   (  )  {  assert that ( zero . is non zero (  )  is ( equal to ( false )  )  )  ;   }  
@ override public void   (  string username  date modification date )  throws  user not found exception  {  logger . finest ( "set modification date" )  ;   }  
  (  subscription s )  {  this . s = s ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  functions . empty consumer (  )   functions . empty consumer (  )  null )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  actual . on error ( t )  ;   }  
private static  collection <  string >    (  string parent  collection <  string >  properties )  {   list <  string >  results = new  array list <  string >  (  )  ;  for  (   string name : properties )   {  if  ( name . starts with ( parent )  &&  ! name . equals ( parent )  )   {  results . add ( name )  ;   }   }  return results ;   }  
@ before public void   (  )  {  handle = db rule . get shared handle (  )  ;   }  
@ test public void   (  )  {  final  interval list interval list = new  interval list ( header )  ;  interval list . add ( new  interval ( "12" 68921962 68921962 )  )  ;  final vcf file reader reader = get reader ( ceu   trios   indels   vcf )  ;  final  
@ override protected void   (  completable observer s )  {   disposable d =  disposables . empty (  )  ;  s . on subscribe ( d )  ;  try  {  run . run (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  if  (  ! d . is dispos
public static  email service   (  )  {  return instance ;   }  
@ override public void   (  )  {  dispose after (  )  ;  s . dispose (  )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
@ override protected void   (  maybe observer <  ?  super t >  observer )  {  source . subscribe ( new  observe on maybe observer < t >  ( observer scheduler )  )  ;   }  
public  permission   (  )  {  return permission ;   }  
public static void   ( int sender threads )  {  if  ( sender threads  <  1 )   {  sender threads = 1 ;   }  else if  ( sender threads  >   runtime . get runtime (  )  . available processors (  )  )   {  sender threads =  runtime . get runtime (  )  . available processors (  )  ;   }   conference sender . sender threads = sender threads ;   }  
@ before public void   (  )  {  h = db rule . get shared handle (  )  ;  h . execute ( "create table user  ( "  +  "uid integer not null "  +  "name varchar not null" +  " ) " )  ;  h . execute ( "create table article  ( "  +  "aid integer not null "  +  
public void   (  )  {   string old str = "create index message   "  +   message columns . timestamp  +  " on " +   message . table   name +  "  ( " +   message columns . timestamp +  " )  ; " ;   string new str = db helper . create index (  message . table   name  message columns . timestamp )  ;  assert equals ( new str old str )  ;   }  
public  string   (  )  {  return conference display name ;   }  
public boolean   (  )  {  return shutting down ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to ( null )  ;   }  
public void   ( byte[] iv )  {  if  ( iv . length  !  =  reply   iv   length )  throw new  illegal argument exception (  )  ;     replyiv = iv ;   }  
@ override public  string   (  )  {  return get class (  )  . get simple name (  )  ;   }  
public void   (  string parameter name double x )  throws sql exception  {  cstmt . set double ( parameter name x )  ;   }  
public static void   (  string conference id  string display name )  {  try  {   conference manager conference manager = find conference manager ( conference id )  ;  conference manager . set display name ( display name )  ;   }  catch  (   parse exception e )   {   }   }  
public  data structure   (  )  throws  data format exception  {   session id id = new  session id (  )  ;  id . set session id ( 7 )  ;  return id ;   }  
@ test public void   (  )  {  final  test observable <  string >  w1 = new  test observable <  string >  ( "one" "two" "three" )  ;  final  test observable <  string >  w2 = new  test observable <  string >  ( "hello"  integer . max   value )  ;   observe
public void   (  )  {  synchronized  ( lock )   {  if  ( i treatment  !  =  null )   {  if  ( i treatment . get treatment manager (  )   !  =  null )   {  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " stopping previous input treatment "  +  i treatment . get treatment manager (  )  . get id (  )  )  ;   }  i treatment . done (  )  ;   }  else  {  try  {  synchronized  ( i treatment )   {  i treatment . wait (  )  ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " stopping previous input treatment after waiting "  +  i treatment . get treatment manager (  )  . get id (  )  )  ;   }  i treatment . done (  )  ;   }  catch  (   interrupted exception e )   {   }   }   }  i treatment = this ;   }   logger . println ( " trying to create treatment manager for "  +  treatment )  ;  try  {  treatment manager = new  treatment manager ( treatment repeat count sample rate channels )  ;   }  catch  (  io exception e )   {   logger . println ( " member receiver:  invalid input treatment "  +  treatment  +  ": " +  e . get message (  )  )  ;  call handler . cancel request ( " invalid input treatment "  +  treatment  +  ": " +  e . get message (  )  )  ;  synchronized  ( this )   {  notify all (  )  ;   }  return ;   }  treatment manager . add treatment done listener ( treatment done listener )  ;  if  ( whisper group  !  =  null )   {  synchronized  ( whisper group )   {  input treatment = treatment manager ;   }   }  else  {  input treatment = treatment manager ;   }  if  (  logger . log level  >  =   logger . log   info )   {   logger . println ( " created treatment manager for "  +  treatment manager . get id (  )  )  ;   }  synchronized  ( this )   {  notify all (  )  ;   }   }  
public  string   (  )  {  return    connection error ;   }  
public  group   (  string name boolean force lookup )  throws  group not found exception  {   group group = null ;  if  ( force lookup )   {  group cache . remove ( name )  ;   }  else  {  group = group cache . get ( name )  ;   }  if  ( group  =  =  null )   {  synchronized  ( name . intern (  )  )   {  group = group cache . get ( name )  ;  if  ( group  =  =  null )   {  group = provider . get group ( name )  ;  group cache . put ( name group )  ;   }   }   }  return group ;   }  
@ override public  meter   (  )  {  return across all meter ;   }  
public boolean   (  )  {  return get (  )   =  =   exception helper . terminated ;   }  
public synchronized double   (  )  {  if  (  (    last total value  !  =  0 )  &&  (    extreme total value  !  =  0 )  )  return    last total value  /     extreme total value ;  return 0 . 0d ;   }  
public void   (  string component  string type  string from  string to )  {  if  ( logbuffer . size (  )   <  20 )  logbuffer . add ( new  log entry ( from to type  system . current time millis (  )  component )  )  ;  else  {  synchronized  ( logbuffer )   {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  for  (   log entry log : logbuffer )   {  pstmt = con . prepare statement ( add   new   log )  ;  pstmt . set long ( 1 log . get date (  )  )  ;  pstmt . set string ( 2 log . get type (  )  )  ;  pstmt . set string ( 3 log . get from (  )  )  ;  pstmt . set string ( 4 log . get to (  )  )  ;  pstmt . set string ( 5 log . get component (  )  )  ;  pstmt . add batch (  )  ;   }  pstmt . execute batch (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;  logbuffer . clear (  )  ;   }   }   }   }  
public boolean   (  )  {  return    log latency ;   }  
@ override public void   (  )  {  if  (  ! terminate )   {  terminate = true ;  actual . on complete (  )  ;   }   }  
public int   (  string ds name )  throws  rrd exception  io exception  {  for  ( int i = 0 ;  i  <  datasources . length ;  i +  +  )   {  if  ( datasources[i] . get ds name (  )  . equals ( ds name )  )   {  return i ;   }   }  throw new  rrd exception ( " unknown datasource name: "  +  ds name )  ;   }  
@ override public void   (  throwable t )  {  cs . on error ( t )  ;   }  
@ override public boolean   (  integer v )  throws  exception  {  throw new  test exception (  )  ;   }  
@ test public void   (  )  {   async subject <  string >  subject =  async subject . create (  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . on next ( "one" )  ;  subject . on next ( "two" )  ;  subject . on next 
@ override public  string   (  )  {  return name ;   }  
@ test public void   (  )  {   observable <  integer >  w =  observable . just ( 1 2 3 )  ;   observable <  integer >  take = w . take while ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer input )  {  return input  <  3 
@ override public void   (  throwable e )  {  o . on error ( e )  ;   }  
public static  collection <  authorization policy >    (  )  {  return authorization policies ;   }  
public org . xmpp . packet .  roster   (  )  {  org . xmpp . packet .  roster roster = new org . xmpp . packet .  roster (  )  ;  for  (   roster item item : roster items . values (  )  )   {  if  ( item . is only shared (  )  && item . get sub status (  )   =  =   roster item . sub   from )   {  continue ;   }  org . xmpp . packet .  roster .  ask ask = get ask status ( item . get ask status (  )  )  ;  org . xmpp . packet .  roster .  subscription sub = org . xmpp . packet .  roster .  subscription . value of ( item . get sub status (  )  . get name (  )  )  ;   list <  string >  groups = new  array list <  >  ( item . get groups (  )  )  ;  if  ( groups . contains ( null )  )   {   log . warn ( "a group is null in roster item: "  +  item . get jid (  )   +  " of user: " +  get username (  )  )  ;   }  for  (   group shared group : item . get shared groups (  )  )   {   string display name = shared group . get properties (  )  . get ( "shared roster . display name" )  ;  if  ( display name  !  =  null )   {  groups . add ( display name )  ;   }  else  {   log . warn ( " found shared group: "  +  shared group . get name (  )   +  " with no display name" )  ;   }   }  if  ( item . get sub status (  )   !  =   roster item . sub   none || item . get recv status (  )   !  =   roster item . recv   subscribe &&  ! is subscription rejected ( item )  )   {  roster . add item ( item . get jid (  )  item . get nickname (  )  ask sub groups )  ;   }   }  return roster ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ test public void   (  )  {   subscriber <  long >  observer =  test helper . mock subscriber (  )  ;   flowable . range long ( 2 3 )  . subscribe ( observer )  ;  verify ( observer times ( 1 )  )  . on next ( 2l )  ;  verify ( observer times ( 1 )  )  .
@ override public int   (  )  {  return localmuc room manager . get number chat rooms (  )  ;   }  
private  string   (  )  {  return settings . get chat setting (  key enum . send   email   question )  . get value (  )  ;   }  
@ override public  string   (  )  {  return "hello world" ;   }  
public void   ( long id )  {  this . id = id ;   }  
public  properties   (  )  throws sql exception  {  return connection . get client info (  )  ;   }  
@ test public void   (  )  {   iterable <  string >  it = new  iterable <  string >  (  )  {  @ override public  iterator <  string >  iterator (  )  {  return new  iterator <  string >  (  )  {  int i ;  @ override public boolean has next (  )  {  return
@ test public void   (  )  {  assert false (  rx java plugins . is bug ( new  runtime exception (  )  )  )  ;  assert false (  rx java plugins . is bug ( new io exception (  )  )  )  ;  assert false (  rx java plugins . is bug ( new  interrupted exception
public  string   (  )  {  return this . name ;   }  
@ override public boolean   (  )  {  return once . get (  )  ;   }  
public boolean   (  )  {  return filter  !  =  null ;   }  
public void   (  agent agent )  {  if  (  ! agents . contains ( agent )  )   {  boolean added = add agent to db ( agent . getid (  )   boolean . false )  ;  if  ( added )   {  agents . add ( agent )  ;  agent . send agent added to all agents ( this )  ;   }   }   }  
protected static void   ( boolean preferi pv4 stack )  {  sip config . preferi pv4 stack = preferi pv4 stack ;   }  
public long   (  )  {  return timestamps[1]  -  timestamps[0] ;   }  
public void   (  string whisper group id )  {  this . whisper group id = whisper group id ;   }  
public  event dispatcher   (  )  {  return this ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  complete ( true )  ;   }  
public  identity store   (  )  {  return identity store ;   }  
public  string   (  )  {  return pageid ;   }  
@ test public void   (  )  throws  interrupted exception  {  try out schedulers (  )  ;   system . out . println ( "test start idempotence  >  >  giving some time" )  ;   thread . sleep ( 500 )  ;   set <  thread >  rx threads before = new  hash set <  th
@ override public void   (  throwable e )  {   rx java plugins . on error ( e )  ;   }  
@ suppress warnings (  { "unchecked" "rawtypes" }  )  public boolean   (  fetch mode mode )  {  if  ( mode  =  =   fetch mode . cache   only )  throw new  illegal argument exception (  )  ;  if  ( mailbox  =  =  null )   {  if  (    log . should debug (  
public int   (  )  throws sql exception  {  return stmt . get result set holdability (  )  ;   }  
@ test public void   (  )  {   replay subject <  object >  rs =  replay subject . create with size ( 1 )  ;  assert equals ( 0 rs . size (  )  )  ;  assert false ( rs . has value (  )  )  ;  for  ( int i = 0 ;  i  <  1000 ;  i +  +  )   {  rs . on next ( 
@ test public void   (  )  {   publish processor <  integer >  subject =  publish processor . create (  )  ;  final  atomic integer count = new  atomic integer ( 0 )  ;   disposable sub = subject . retry (  )  . subscribe ( new  consumer <  integer >  (  
private static  string   (  context context  xml resource parser xml  string name )  {  int res id = xml . get attribute resource value ( null name 0 )  ;  if  ( res id  =  =  0 )   {  return xml . get attribute value ( null name )  ;   }  else  {  return context . get string ( res id )  ;   }   }  
public void   ( uri resolver resolver )  {  resolvers . add ( resolver )  ;   }  
public static void   ( int lone receiver port )  throws  parse exception  {  if  (  conference manager . lone receiver port  =  =  lone receiver port )   {  return ;   }  if  ( total members  !  =  0 )   {   logger . println ( " can't change lone receiver port while conferences are in progress" )  ;  throw new  parse exception ( " can't change lone receiver port while conferences are in progress" 0 )  ;   }   conference manager . lone receiver port = lone receiver port ;   }  
@ override public  time   (  string column label  calendar cal )  throws sql exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  {  final  list <  string >  list = new  array list <  string >  (  )  ;  final  list <  list <  string >  >  lists = new  array list <  list <  string >  >  (  )  ;   observable <  string >  source =  observable . unsafe create 
@ test public void   (  )  throws  exception  {  run standard test ( 1 "dual barcode . " "barcode   double . params" 2 "151t8b8b151t" test   data   dir   with   cbcls dual   cbcl   test   data   dir )  ;   }  
public void   ( boolean send item subscribe )  {  this . send item subscribe = send item subscribe ;   }  
public synchronized  router identity   (  )  {  if  (  !    verification attempted )   {  verify identity (  )  ;     verification attempted = true ;   }  return    received confirmed identity ;   }  
public void   (  )  {  s s = state ;  if  ( cancelled )   {  state = null ;  dispose ( s )  ;  return ;   }  final  bi function < s  ?  super  emitter < t >  s >  f = generator ;  for  (  ;   ;   )   {  if  ( cancelled )   {  state = null ;  dispose ( s )  ;  return ;   }  has next = false ;  try  {  s = f . apply ( s this )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  state = null ;  cancelled = true ;  on error ( ex )  ;  dispose ( s )  ;  return ;   }  if  ( terminate )   {  cancelled = true ;  state = null ;  dispose ( s )  ;  return ;   }   }   }  
private static boolean   ( char c )  {  return  ( c  <  32 &&  ! is white space ( c )  )  || c  >  =  127 ;   }  
@ xml element public  string   (  )  {  return subject ;   }  
@ test public void   (  )  {  assert null (  observable . just ( 1 2 3 )  . ignore elements (  )  . blocking get (  )  )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . range ( 1 5 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  . on backpressure latest (  )  . sub
public void   (  )  {   thread . current thread (  )  . set name ( " out"  +     runner num )  ;     running time = test outbound throttle (    num bytes 8 * 1024 )  ;   }  
static boolean   (  boolean supplier cancelled )  {  try  {  return cancelled . get as boolean (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;  return true ;   }   }  
private static void   ( final sq lite database db )  {  db . execsql ( "create table "  +   message move . table   name  +  "  ( " +  message   change   log   columns +   message move . src   folder   key +  " integer  " +   message move . dst   folder   key +  " integer  " +   message move . src   folder   server   id +  " text  " +   message move . dst   folder   server   id +  " text )  ; " )  ;  create message change log table indices ( db  message move . table   name )  ;  create message change log table triggers ( db  message move . table   name )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  atomic integer subs count = new  atomic integer ( 0 )  ;  final  test subscriber <  string >  ts = new  test subscriber <  string >  (  )  ;   publisher <  string >  on subscribe = new  p
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . subscription s )  )   {  this . subscription = s ;  actual . on subscribe ( this )  ;   }   }  
@ test public void   (  )  {  final  object[] event =  { null }  ;   single . just ( 1 )  . do on success ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  throws  exception  {  event[0] = e ;   }   }   )  . test (  )  
private double   (  )  {  return get font char width ( fonttag   legend )  ;   }  
public void   (  conference member member )  {  if  ( members . contains ( member )   =  =  true )   {   logger . println ( member  +  " is already in whisper group "  +  id )  ;  return ;   }  members . add ( member )  ;   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . execute ( find sql on classpath ( "insert - eric - with - comments" )  )  ;  assert that ( h . select ( "select name from something" )  . map to (  string . cl
public  read structure   (  )  {  final  list <  read descriptor >  descriptors = new  array list <  read descriptor >  ( num descriptors )  ;  for  (  final  read descriptor rd : this )   {  descriptors . add ( rd )  ;   }  return new  read structure ( descriptors )  ;   }  
@ test public void   (  )  throws  exception  {  run standard test ( 1 "multiplexed barcode . " "barcode . params" 1 "25t8b4m21t" basecalls   dir test   data   dir   with   4m   index )  ;   }  
protected int   (  )  {  for  (  final  file target interval : target   intervals )  io util . assert file is readable ( target interval )  ;  io util . assert file is readable ( input )  ;  io util . assert file is writable ( output )  ;  if  ( per   target   coverage  !  =  null )  io util . assert file is writable ( per   target   coverage )  ;  final  sam reader reader =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . open ( input )  ;  final  interval list target intervals =  interval list . from files ( target   intervals )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  target intervals . get header (  )  . get sequence dictionary (  )  )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  get probe intervals (  )  . get header (  )  . get sequence dictionary (  )  )  ;   reference sequence file ref = null ;  if  ( reference   sequence  !  =  null )   {  io util . assert file is readable ( reference   sequence )  ;  ref =  reference sequence file factory . get reference sequence file ( reference   sequence )  ;   sequence util . assert sequence dictionaries equal ( reader . get file header (  )  . get sequence dictionary (  )  ref . get sequence dictionary (  )  input reference   sequence )  ;   }  final collector collector = make collector ( metric   accumulation   level reader . get file header (  )  . get read groups (  )  ref per   target   coverage per   base   coverage target intervals get probe intervals (  )  get probe set name (  )  near   distance )  ;  final  progress logger progress = new  progress logger ( log )  ;  for  (  final sam record record : reader )   {  collector . accept record ( record null )  ;  progress . record ( record )  ;   }  final  metrics file < metric  integer >  metrics = get metrics file (  )  ;  collector . finish (  )  ;  collector . add all levels to file ( metrics )  ;  metrics . write ( output )  ;   closer util . close ( reader )  ;  return 0 ;   }  
public void   ( int quantity )  {     backup quantity = quantity ;   }  
public void   (  )  throws  exception  {  setup copy messages ( false )  ;  m copy mock . expect ( get copy messages pattern (  )  new  string[] { get next tag ( true )   +  " ok uid copy completed" }  )  ;  int save tag = reset tag (  )  ;  expect login ( m copy mock new  string[] { "* id nil" "ok" }  false )  ;  expect select ( m copy mock "& ze vnl iqe - " "read - write" )  ;  m copy mock . expect ( get search messages pattern ( " < 4d8978ae . 0000005d@m58 . foo . com > " )  new  string[] { get next tag ( true )   +  "  bad search failed" }  )  ;  m copy mock . expect ( get search messages pattern ( " < 549373104msosi1:145osims@bar . com > " )  new  string[] { get next tag ( true )   +  "  bad search failed" }  )  ;  reset tag ( save tag )  ;  expect select ( m copy mock folder   encoded "read - write" )  ;   message update callback counter cb = new  message update callback counter (  )  ;  m folder . copy messages ( m copy messages m copy to folder cb )  ;  assert equals ( 0 cb . message not found called )  ;  assert equals ( 0 cb . message uid change called )  ;   }  
public void   (  agent session agent session )  {  pending sessions . add ( agent session )  ;  offer time = new  date (  )  ;   }  
public  string   (  )  throws io exception  {  return signature . get (  )  ;   }  
@ override public  string   (  )  {  return "ntcp bid @ "  +  get latency ms (  )  ;   }  
public void   (  string subject )  {  this . subject = subject ;   }  
public  user entity   (  string username )  throws  service exception  {  return  user utils . convert user to user entity ( get and check user ( username )  )  ;   }  
public void   ( int offset )  {     offset = offset ;   }  
@ override public  iterator <  string >    (  )  {  return  collections . singleton ( namespace )  . iterator (  )  ;   }  
public void   ( int msgs )  {  if  ( msgs  >   connection . max   window   size )     max window size =  connection . max   window   size ;  else if  ( msgs  <  1 )     max window size = 1 ;  else    max window size = msgs ;   }  
public void   (  string voice mail number )  {  this . voice mail number = voice mail number ;   }  
@ test public void   (  )  {   flowable <  boolean >  observable =  flowable . sequence equal (  flowable . just ( "one" "two" "three" "four" )   flowable . just ( "one" "two" "three" )  )  . to flowable (  )  ;  verify result ( observable false )  ;   } 
public void   (  string image info )  {  this . image info = image info ;   }  
@ test public void   (  )  throws  exception  {  h . create update ( "insert into something  ( id  name )  values  ( 1  'eric' ) " )  . execute (  )  ;  h . create update ( "insert into something  ( id  name )  values  ( 2  'brian' ) " )  . execute (  )  
public void   (  string affiliation )  {  this . affiliation = affiliation ;   }  
@ override public void   (  notification < t >  args )  {  boolean was not available = value . get and set ( args )   =  =  null ;  if  ( was not available )   {  notify . release (  )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  normal . completable . do on error ( null )  ;   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
private static  string   (  database type type )  {  switch  ( type )   {  case postgresql: return purge   for   size   postgresql ;  case mysql: return purge   for   size   mysql ;  case hsqldb: return purge   for   size   hsqldb ;  default : return purge   for   size ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  atomic reference <  disposable >  d = new  atomic reference <  disposable >  (  )  ;   runnable r = new  runnable (  )  {  @ override pu
void   (  )  {   throwable ex = new  null pointer exception ( " subscription not set ! " )  ;  try  {  actual . on subscribe (  empty subscription . instance )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( new  composite exception ( ex e )  )  ;  return ;   }  try  {  actual . on error ( ex )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;   rx java plugins . on error ( new  composite exception ( ex e )  )  ;   }   }  
public  string   (  )  {  return    name ;   }  
@ override public void   (  subscriber <  ?  super r > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )  final  subscriber < t > [] parents = new  subscriber[n
public synchronized double   (  )  {  return    extreme total value ;   }  
public long   (  )  {  return timestamps[timestamps . length  -  1] ;   }  
public static  cursor   ( final  content resolver cr final long account id )  {  return cr . query (  mailbox . content   uri  mailbox . id   projection outbox   plus   syncing   and   account   selection new  string[] {  long . to string ( account id )  }   mailbox columns . type  +  " asc" )  ;   }  
public  inet socket address   (  )  {  return addressb ;   }  
@ suppress warnings ( "unchecked" )  @ override public  publisher <  long >    ( long elements )  {  return  flowable . amb (  arrays . as list (  flowable . from iterable ( iterate ( elements )  )   flowable .  <  long > never (  )  )  )  ;   }  
static private boolean   ( final  variant context vc )  {  return  ! vc . is variant (  )  || vc . get genotypes (  )  . stream (  )  . all match (  genotype::is hom ref )  ;   }  
@ override public void   (  disposable s )  {   disposable helper . set once ( this s )  ;   }  
public  string   (  )  {  return description ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  s =  subscription helper . cancelled ;  actual . on success ( u )  ;   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  final  imap connection con1 = m store . get connection (  )  ;  assert not null ( con1 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert false ( con1 . is transport open for test (  )  )  ;  expect login ( mock )  ;  con1 . open (  )  ;  assert true ( con1 . is transport open for test (  )  )  ;  final  imap connection con2 = m store . get connection (  )  ;  assert not null ( con2 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert false ( con2 . is transport open for test (  )  )  ;  assert not same ( con1 con2 )  ;  int save tag = reset tag (  )  ;  expect login ( mock )  ;  con2 . open (  )  ;  assert true ( con1 . is transport open for test (  )  )  ;  m store . pool connection ( con1 )  ;  assert equals ( 1 m store . get connection pool for test (  )  . size (  )  )  ;  save tag = reset tag ( save tag )  ;  mock . expect ( get next tag ( false )   +  " noop" new  string[] { get next tag ( true )   +  " ok success" }  )  ;  final  imap connection con1b = m store . get connection (  )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert same ( con1 con1b )  ;  assert true ( con1 . is transport open for test (  )  )  ;  m store . pool connection ( con2 )  ;  assert equals ( 1 m store . get connection pool for test (  )  . size (  )  )  ;  reset tag ( save tag )  ;  mock . expect ( get next tag ( false )   +  " noop" new  string[] { get next tag ( true )   +  "* bye bye" }  )  ;  final  imap connection con3 = m store . get connection (  )  ;  assert not null ( con3 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert not same ( con1 con3 )  ;  assert not same ( con2 con3 )  ;   }  
public void   ( final  string type final byte[] data )  {  this . pending avatar = data ;  try  {  final  message digest digest =  message digest . get instance ( "md5" )  ;  digest . update ( data )  ;  final  extra info data eid = new  extra info data (  extra info data . flag   hash   present  byte block . wrap ( digest . digest (  )  )  )  ;  final  ssi command request ;  final  icon item new icon item ;  if  ( icon  !  =  null )   {  new icon item = new  icon item ( icon )  ;  new icon item . set icon info ( eid )  ;  request = new  modify items cmd ( new icon item . to ssi item (  )  )  ;   }  else  {  new icon item = new  icon item (  icon item . name   default this . get next buddy id (  ssi item . group   root )  eid )  ;  request = new  create items cmd ( new icon item . to ssi item (  )  )  ;   }  request ( new  pre mod cmd (  )  )  ;  request ( request )  ;  request ( new  post mod cmd (  )  )  ;  this . icon = new icon item ;   }  catch  (   no such algorithm exception e )   {   log . error ( " no algorithm found for md5 checksum ?  ? " )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  100 ;  i +  +  )   {  test with backpressure all at once ( i )  ;   }   }  
@ test public void   (  )  throws  data format exception  {   key certificate cert = new  key certificate ( p521   payload )  ;  assert that ( cert . get sig type code (  )  is ( equal to (  sig type . ecdsa   sha512   p521 . get code (  )  )  )  )  ;  as
public  string   (  )  {  return    context . get property ( prop   i2np   ntcp   hostname "" )  ;   }  
@ ignore ( "v2 components should not throw" )  @ test public void   (  )  {  try  {   observable . error ( new  illegal argument exception ( "original exception" )  )  . subscribe ( new  observer <  object >  (  )  {  @ override public void on subscribe (
@ test public void   (  )  {   test helper . check disposed maybe ( new  function <  maybe <  object >   maybe source <  object >  >  (  )  {  @ override public  maybe source <  object >  apply (   maybe <  object >  m )  throws  exception  {  return m . 
@ override public void   (  throwable t )  {  parent . inner close error ( t )  ;   }  
@ override public  user   (  string username  string password  string name  string email )  throws  user already exists exception  {  for  (  final  user provider provider : get user providers (  )  )   {  if  ( provider . is read only (  )  )   {  contin
@ override public void   (  disposable d )  {  this . u = d ;   }  
public  service   (  string uuid )  {   device list dev list = get device list (  )  ;  int dev cnt = dev list . size (  )  ;  for  ( int n = 0 ;  n  <  dev cnt ;  n +  +  )   {   device dev = dev list . get device ( n )  ;   service service = dev . get subscriber service ( uuid )  ;  if  ( service  !  =  null )  return service ;   }  return null ;   }  
public void   ( int tunnel depth )  {     tunnel depth = tunnel depth ;   }  
@ test public void   (  )  {  filter . set patterns ( "fox dog" )  ;  filter . set mask ( "**" )  ;   message message = new  message (  )  ;  message . set body ( "the quick brown fox jumped over the lazy dog" )  ;  boolean matched = filter . filter ( mes
private static  string   (  hash hash )  {   string b64 = hash . to base64 (  )  ;  return routerinfo   prefix  +  b64  +  routerinfo   suffix ;   }  
public void   (  outgoing call handler call handler )  {  this . call handler = call handler ;   }  
public void   ( boolean val )  {  if  ( val )     boolean options . add ( i2p tunnelhttp client . prop   user   agent )  ;  else    boolean options . remove ( i2p tunnelhttp client . prop   user   agent )  ;   }  
@ override public  boolean   (  )  {  return true ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ get bandwidth limits message]" )  ;  return buf . to string (  )  ;   }  
public static  string   (  )  {  return override ip ;   }  
public void   (  )  {   string result1 =  mime utility . fold and encode2 ( short   unicode 10 )  ;  assert equals ( short   unicode   encoded result1 )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   burst . item ( 1 )  . create (  )  . collect ( callable list creator (  )  bi consumer throws ( e )  )  . test (  )  . assert error ( e )  . assert not complete ( 
@ override public final boolean   (  )  {  return m position  =  =   ( get count (  )   -  1 )  ;   }  
@ override public  boolean   (  string username )  {  return true ;   }  
@ deprecated public  properties   (  )  {  return    options ;   }  
public void   (  properties options )  {     options = options ;   }  
@ override public void   (  disposable d )  {  disposables . replace ( d )  ;   }  
@ test public void   (  )  throws io exception  {  final  byte buffer internal buffer = new  cyclic byte buffer (  )  ;  internal buffer . put ( "hello there" . get bytes (  )  )  ;  final  servlet output stream output stream = new  byte buffer servlet ou
@ override public int   (  session data data )  {  return 1 ;   }  
@ override public boolean   (  )  {  return cancelled ;   }  
private long   (  cache info cache info )  {   string size prop = cache info . get params (  )  . get ( "back - size - low" )  ;  if  ( size prop  !  =  null )   {  if  ( "0" . equals ( size prop )  )   {  return  - 1l ;   }  try  {  return  integer . parse int ( size prop )  ;   }  catch  (   number format exception nfe )   {   log . warn ( " unable to parse back - size - low for cache: "  +  cache info . get cache name (  )  )  ;   }   }  return  cache factory . default   max   cache   size ;   }  
@ test public void   (  )  {  final  observable <  string >  o1 =  observable . unsafe create ( new  test error observable ( "four" null "six" )  )  ;  final  observable <  string >  o2 =  observable . unsafe create ( new  test error observable ( "one" "t
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  object >  func = mock (  callable . class )  ;  when ( func . call (  )  )  . then return ( new  object (  )  )  ;   observable <  object >  from callable o
public boolean   (  )  {  return offer timeout  =  =   - 1 ;   }  
@ override public  set <  string >    (  )  throws  unsupported operation exception  {  return  collections . unmodifiable set ( search fields . key set (  )  )  ;   }  
@ test public void   (  )  {  final  list <  string >  events = new  array list <  string >  (  )  ;  final  callable <  resource >  resource factory = create resource factory ( events )  ;  final  consumer <  throwable >  on error = create on error actio
public synchronized  signature   (  )  {  return    sent signature ;   }  
public void   (  string key )  {  if  ( key  !  =  null )     key = key . trim (  )  ;   }  
public  collection <  string >    (  )  {  return  collections . unmodifiable collection ( validated domains )  ;   }  
@ override public  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type  method method )  {  return create for type ( annotation sql object type )  ;   }  
public static void   (  set <  string >  allowed )  {  if  ( allowed  =  =  null )   {  throw new  null pointer exception (  )  ;   }  allowedi ps = allowed ;  if  ( allowedi ps . is empty (  )  )   {   jive globals . delete property (  connection settings .  client . login   allowed )  ;   }  else  {   string builder buf = new  string builder (  )  ;   iterator <  string >  iter = allowedi ps . iterator (  )  ;  if  ( iter . has next (  )  )   {  buf . append ( iter . next (  )  )  ;   }  while  ( iter . has next (  )  )   {  buf . append ( "  " )  . append ( iter . next (  )  )  ;   }   jive globals . set property (  connection settings .  client . login   allowed buf . to string (  )  )  ;   }   }  
public boolean   (  )  {  return  ! shared groups . is empty (  )  ||  ! invisible shared groups . is empty (  )  ;   }  
@ override public muc role   (  string nickname )  throws  user not found exception  {  if  ( nickname  =  =  null )   {  throw new  user not found exception (  )  ;   }   list < muc role >  roles = get occupants by nickname ( nickname )  ;  if  ( roles  
@ override public void   (  )  {  try  {   system . out . println ( "running  test observable thread" )  ;  for  (   string s : values )   {  if  ( "fail" . equals ( s )  )   {  throw new  runtime exception ( " forced  failure" )  ;   }   system . out . p
public void   ( boolean enable )  throws sql exception  {  cstmt . set escape processing ( enable )  ;   }  
public  sig type   (  )  {  return  sig type . get by code ( get sig type code (  )  )  ;   }  
@ override public void   (  string name )  {  throw new  unsupported operation exception (  )  ;   }  
@ override public int   (  session data data )  {  return 1 ;   }  
@ override public  string   (  string username )  throws  user not found exception  {  final  auth provider provider = mapper . get auth provider ( username )  ;  if  ( provider  =  =  null )   {  throw new  user not found exception (  )  ;   }  return pr
@ test public void   (  )  {   flowable <  long >  source =  flowable . interval ( 1l  time unit . seconds scheduler )  . take ( 3 )  ;   flowable <  long >  delayed = source . delay ( 500l  time unit . milliseconds scheduler )  ;  delayed . subscribe ( o
public boolean   (  conversation conversation )  {  return false ;   }  
public void   (  cleanable cleanable )  {  cleanables . add ( cleanable )  ;   }  
@ override public  set <  auth provider >    (  )  {  final  set <  auth provider >  result = new  linked hash set <  >  (  )  ;  result . add ( admin provider )  ;  result . add ( user provider )  ;  return result ;   }  
public void   (  string s )  {  if  ( s  !  =  null )   {  try  {     config . set limit day (  integer . parse int ( s . trim (  )  )  )  ;   }  catch  (   number format exception nfe )   {   }   }   }  
public  string   (  )  {  return name ;   }  
public void   (  hash router ident hash )  {     us = router ident hash ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  completable   ( final  action on terminate )  {  return do on lifecycle (  functions . empty consumer (  )   functions . empty consumer (  )   functions . empty   action
@ test public void   (  )  {   string name = "id: testid" ;   string exp result = "json: testid" ;   string result =  base element . get qname ( name )  ;  assert equals ( exp result result )  ;   }  
@ override protected  properties   (  )  {   properties p = new  properties (  )  ;  return p ;   }  
@ override public void   (  )  {  if  ( output fused )   {  drain fused (  )  ;   }  else  {  drain normal (  )  ;   }   }  
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;  h . create update ( find sql on classpath ( "insert - id - name" )  )  . bind ( "id" 1 )  . bind ( "name" " tip" )  . execute (  )  ;  assert that ( h . select ( "
public static boolean   (  )  {  return fail non blocking scheduler ;   }  
@ override public void   (  throwable t )  {  if  ( value  =  =  null )   {  error = t ;   }  count down (  )  ;   }  
@ override public  connection   (  )  throws sql exception  {  final  connection real = super . get connection (  )  ;  return  (  connection )  proxy . new proxy instance ( real . get class (  )  . get class loader (  )  new  class <  ?  > [] {  connecti
public  multicast socket   (  )  {  return ssdp multi sock ;   }  
@ override protected void   (  subscriber <  ?  super t >  s )  {  source . subscribe ( new  on backpressure buffer strategy subscriber < t >  ( s on overflow strategy buffer size )  )  ;   }  
public static  list <  string >    (  )  throws  no such algorithm exception   key management exception  {  final ssl context context = ssl context . get instance ( "tl sv1" )  ;  context . init ( null null null )  ;  return  arrays . as list ( context . createssl engine (  )  . get enabled cipher suites (  )  )  ;   }  
public  string   (  )  {  return this . ssdp multicasti pv4 ;   }  
@ override protected void   (  single observer <  ?  super t >  subscriber )  {  source . subscribe ( new  hide single observer < t >  ( subscriber )  )  ;   }  
@ test @ ignore ( " observers can't throw" )  public void   (  )  {   observer <  string >  o = observer   success (  )  ;  try  {  o . on subscribe ( throwing   disposable )  ;  new  safe observer <  string >  ( o )  . on complete (  )  ;  fail ( "expect
@ test public void   (  )  {   flowable <  integer >  oi =  flowable . from iterable (  arrays . as list ( 1 2 )  )  ;   subscriber <  integer >  mock observer =  test helper . mock subscriber (  )  ;  oi . subscribe ( new  test subscriber <  integer >  (
public  string   (  )  {  return proxy service name  +  " . "  +  xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;  final  publish subject <  integer >  boundary =  publish subject . create (  )  ;   callable <  observable <  integer >  >  boundary func = new  calla
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . to map ( new  function <  integer  object >  (  )  {  @ override public  object apply (   integer v )  {  return v ;   }   }   null )  ;   }  
public void   ( boolean is locked )  {  this . is locked = is locked ;   }  
public void   (  string password )  {  this . password = password ;   }  
@ override public void   (  object t )  {  if  (  ! has value )   {  has value = true ;   }  parent . inner next ( index t )  ;   }  
@ test public void   (  )  throws  exception  {  exception . expect (  unsupported operation exception . class )  ;  handle . create query ( select   by   name )  . bind ( "name"  optional . of ( new  name ( "eric" )  )  )  . map to bean (  something . cl
public long   (  )  {  return    context . clock (  )  . now (  )   -     created ;   }  
@ override public  iterable <  network interface >    (  )  throws  socket exception  {  return new  enumeration iterable <  >  (  network interface . get network interfaces (  )  )  ;   }  
private void   ( jid jid  element storage element )  {  final  collection <  bookmark >  bookmarks =  bookmark manager . get bookmarks (  )  ;  for  (   bookmark bookmark : bookmarks )   {  boolean add bookmark for user = bookmark . is global bookmark (  )  || is bookmark forjid ( jid bookmark )  ;  if  ( add bookmark for user )   {  add bookmark element ( jid bookmark storage element )  ;   }   }   }  
public void   (  tunnel pool pool )  {  if  ( pool  !  =  null )   {     pool = pool ;   }  else  {   log log =    context . log manager (  )  . get log ( get class (  )  )  ;  log . error ( " null tunnel pool ? " new  exception ( "foo" )  )  ;   }   }  
@ override public void   (  config registry registry )  {  this . registry = registry ;   }  
@ test ( data provider = "substructure to read structure negative data" expected exceptions =  illegal argument exception . class )  public void   ( final  read structure .  substructure substructure )  {  substructure . to read structure (  )  . to strin
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  emit (  )  ;   }  
@ override public void   ( final  disposable d )  {  observer . on subscribe ( d )  ;   }  
public boolean   (  )  {  return  jive globals . get boolean property ( "xmpp . server . session . allowmultiple" true )  ;   }  
public  long[]   (  )  {  return    synchronization and contributing sources ;   }  
@ test public void   (  )  {   observable <  integer >  xs =  observable . range ( 0  flowable . buffer size (  )  * 2 )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   connectable observable <  integer >  xsp = xs . publi
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  actual . on complete (  )  ;   }  
protected boolean   (  string action name )  {  for  (   ad hoc command .  action action : allowed actions )   {  if  ( action name . equals ( action . name (  )  )  )   {  return true ;   }   }  return false ;   }  
public void   (  )  {  assert null ( "null header check"  mime utility . get header parameter ( null "name" )  )  ;  assert equals ( "null name first param per code" "header"  mime utility . get header parameter ( header   multi   parameter null )  )  ;  assert equals ( "null name full header" header   no   parameter  mime utility . get header parameter ( header   no   parameter null )  )  ;  assert equals ( "get 1st param" " param1 value"  mime utility . get header parameter ( header   multi   parameter " param1 name" )  )  ;  assert equals ( "get 2nd param" " param2 value"  mime utility . get header parameter ( header   multi   parameter " param2 name" )  )  ;  assert equals ( "get missing param" null  mime utility . get header parameter ( header   multi   parameter " param3 name" )  )  ;  assert equals ( "get 2nd param all lc" " param2 value"  mime utility . get header parameter ( header   multi   parameter "param2name" )  )  ;  assert equals ( "get 2nd param all uc" " param2 value"  mime utility . get header parameter ( header   multi   parameter "param2name" )  )  ;  assert equals ( "get 1st param" " param1 value"  mime utility . get header parameter ( header   quoted   multi   parameter " param1 name" )  )  ;  assert equals ( "get 2nd param" " param2 value"  mime utility . get header parameter ( header   quoted   multi   parameter " param2 name" )  )  ;  assert equals ( "malformed filename param" null  mime utility . get header parameter ( header   malformed   parameter "filename" )  )  ;   }  
@ override public void   (  )  {  if  ( done )   {  return ;   }  try  {  on complete . run (  )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  on error ( e )  ;  return ;   }  done = true ;  actual . on complete (  )  ;  try
public static void   (  array list array  object elements[] )  {   object arr$[] = elements ;  int len$ = arr$ . length ;  for  ( int i$ = 0 ;  i$  <  len$ ;  i$ +  +  )   {   object element = arr$[i$] ;  array . add ( element )  ;   }   }  
@ override public  string   (  )  {  return  string . format ( " { %d byte literal ( memory )  } " m data . length )  ;   }  
public  collection < b >    (  )  {  return buddies . values (  )  ;   }  
double   (  font font )  {   line metrics lm = font . get line metrics ( dummy   text gd . get font render context (  )  )  ;  return lm . get ascent (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  inner observer )  {  inner observer . on subscr
@ override public void   (  )  {  try  {  observer . on error ( new  error ( "failure" )  )  ;   }  catch  (   throwable e )   {  exception . set ( e )  ;   }  latch . count down (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  throws  exception  {   callable <  object >  func = mock (  callable . class )  ;   throwable throwable = new  illegal state exception ( " test exception" )  ;  when ( func . call (  )  )  . 
public void   (  string treatment )  {  conference join treatment = treatment ;   }  
@ override public void   (  )  {  int missed = 1 ;  int c = consumed ;   spsc array queue < t >  q = queue ;   conditional subscriber <  ?  super t >  a = actual ;  int lim = limit ;  for  (  ;   ;   )   {  long r = requested . get (  )  ;  long e = 0l ; 
@ test public void   (  )  {   mime type media type =  mime type . get matching mime type ( "application / vnd . rackspace . services . a - v1 . 0 + xml" )  ;   media type one media range = new  media type ( "application / vnd . rackspace . services . a -
public void   (  )  {  assert equals ( "alert text" build response ( "tag" false new  imap simple string ( "ok" )  build list ( new  imap simple string ( "alert" )  )  new  imap simple string ( "alert text" )  )  . get alert text or empty (  )  . get string (  )  )  ;  assert equals ( "" build response ( "tag" false new  imap simple string ( "ok" )  build list ( new  imap simple string ( "x" )  )  new  imap simple string ( "alert text" )  )  . get alert text or empty (  )  . get string (  )  )  ;   }  
final  test subscriber < t >    ( int mode )  {  this . initial fusion mode = mode ;  return this ;   }  
@ override public void   (  )  {  for  (   scheduled thread pool executor e : new  array list <  scheduled thread pool executor >  ( pools . key set (  )  )  )   {  if  ( e . is shutdown (  )  )   {  pools . remove ( e )  ;   }  else  {  e . purge (  )  ;
public boolean   (  )  {  return m shared preferences . get boolean ( enable   exchange   file   logging false )  ;   }  
public  string   (  )  {  return get header value ( http . location )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  normal . completable . subscribe (  (  completable observer ) null )  ;   }  
public  string   (  )  {  return get allowed value range node (  )  . get node value ( step )  ;   }  
public void   (  string rule id )  {  this . rule id = rule id ;   }  
@ override protected void   (  maybe observer <  ?  super  object >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  assert false (  (  (  disposable ) observer )  . is disposed (  )  )  ;  ts . dispose (  )  ;  assert true (  ( 
private static  email async task <  void  void  void >    (  executor executor final  runnable runnable )  {   email async task <  void  void  void >  task = new  email async task <  void  void  void >  ( null )  {  @ override protected  void do in background (   void .  .  .  params )  {  runnable . run (  )  ;  return null ;   }   }   ;  return task . execute internal ( executor false  (  void[] ) null )  ;   }  
@ test public void   (  )  throws io exception  {   input stream actual = instance . read ( cr )  ;  verify ( cr times ( 1 )  )  . new input stream (  )  ;  assert that ( " should get input stream" actual same instance ( stream )  )  ;   }  
@ override public void   (  )  {  o . on complete (  )  ;  cdl . count down (  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  (  consumer <  integer >  ) null )  ;   }  
public boolean   (  )  {  return is pentiumm compatible ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . from iterable (  arrays . as list ( 1 2 3 4 5 )  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  o . subscribe ( to )  ;  to . assert values ( 1 2 
public void   ( boolean secure )  {  this . secure = secure ;   }  
public  string   (  string url string )  {   string baseurl str = null ;   string locationurl str = null ;   device root dev = get root device (  )  ;  if  ( root dev  !  =  null )   {  baseurl str = root dev . geturl base (  )  ;  locationurl str = root dev . get location (  )  ;   }  return get absoluteurl ( url string baseurl str locationurl str )  ;   }  
@ test public void   (  )  {   observable <  string >  o1 =  observable . just ( "one" "two" )  ;   observable <  string >  o2 =  observable . just ( "three" "four" )  ;   list <  string >  values =  observable . concat ( o1 o2 )  . to list (  )  . blocki
public  file   (  )  {  return filename to file ( get priv key file (  )  )  ;   }  
@ override public boolean   (  )  {  return get (  )   !  =  no   request ;   }  
@ override protected void   (  observer <  ?  super t >  observer )  {  state . subscribe ( observer )  ;   }  
@ override public  data form   (  string name  string node jid senderjid )  {  if  ( name  !  =  null && node  =  =  null )   {  muc room room = get chat room ( name )  ;  if  ( room  !  =  null )   {  final  data form data form = new  data form (  type .
@ override @ nullable public  throwable   (  )  {   object o = value . get (  )  ;  if  (  notification lite . is error ( o )  )   {  return  notification lite . get error ( o )  ;   }  return null ;   }  
@ override public void   (  garlic config config )  {  throw new  unsupported operation exception (  )  ;   }  
public  plugin metadata   (  string canonical name )  {  return this . plugin metadata . get ( canonical name )  ;   }  
@ override public boolean   (  string hostname  destination d  properties options )  {  if  (  !    is version4 )  return put if absent ( hostname d options )  ;   list <  properties >  stored options = new  array list <  properties >  ( 4 )  ;  synchroni
@ override public void   (  )  {  disposed = true ;   }  
public int   (  string name )  {  int index =  - 1 ;  for  (  iterator <  node >  i = node list . iterator (  )  ;  i . has next (  )  ;   )   {  index +  +  ;   node n = i . next (  )  ;  if  ( n . get name (  )  . equals ( name )  )  return index ;   }  return index ;   }  
@ test public void   (  )  {   flowable . merge (  flowable event stream . get event stream ( "http -  clustera" 50 )   flowable event stream . get event stream ( "http -  clusterb" 20 )  )  . group by ( new  function <  event  object >  (  )  {  @ overri
public static  string   ( i2p app context ctx )  {   string url = ctx . get property (  config update handler . prop   news   url )  ;  if  ( url  !  =  null &&  ! url . equals (  config update handler . old   default   news   url )  &&  ! url . equals (  config update handler . default   news   url )  &&  ! url . equals (  config update handler . old   default   news   url   su3 )  )  return url ;  else return  config update handler . default   news   url   su3 ;   }  
public  string   (  )  {  return name ;   }  
public void   (  )  {  while  (  ! done )   {  try  {   thread . sleep ( 5000 )  ;   }  catch  (   exception e )   {   }  int count = packet count . get and set ( 0 )  ;   system . out . println ( " packets per second: "  +   ( count  /  5 )  )  ;   }   }  
public void   (  string deliveryurl )  {  this . deliveryurl = deliveryurl ;  try  {  url url = new url ( deliveryurl )  ;  delivery host = url . get host (  )  ;  delivery path = url . get path (  )  ;  delivery port = url . get port (  )  ;   }  catch  (   exception e )   {   }   }  
private boolean   ( final byte[] ref bases final byte[] read bases final byte[] read qualities final int index )  {  return isc ( ref bases[index] read bases[index] )  &&  sequence util . bases equal ( ref bases[index  +  1] read bases[index  +  1] )  && is above cyto qc threshold ( read qualities index )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe (  functions . empty consumer (  )   functions . empty consumer (  )   functions . empty   action null )  ;   }  
@ test ( data provider = "search duplicates data provider" )  public void   (  elc duplicates finder duplicates finder  histogram <  integer >  duplication histo  histogram <  integer >  optical histo  array list <  paired read sequence >  dupes int dup h
@ override public void   (  )  {  so . on complete (  )  ;   }  
public int   ( int tunnel )  {   tunnel controller tun = get controller ( tunnel )  ;  if  ( tun  =  =  null )  return not   running ;  if  ( tun . get is running (  )  )   {  if  ( tun . is client (  )  && tun . get is standby (  )  )  return standby ;  else return running ;   }  else if  ( tun . get is starting (  )  )  return starting ;  else return not   running ;   }  
public long   (  )  {  return    total time . get (  )  ;   }  
public  string   (  )  {  return uri ;   }  
public int   (  )  {  return ds names . length ;   }  
public long   (  )  {  return    enqueue time ;   }  
public  string   (  )  {   string s ;  switch  ( event )   {  case conference   started: s = "conference   started ( "  +  event  +  " ) " +  "  conference id " +  conference id ;  break ;  case conference   ended: s = "conference   ended ( "  +  event  +  " ) " +  "  conference id " +  conference id ;  break ;  case member   joined: s = "member   joined ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  count " +  member count +  "  member address " +  member address ;  break ;  case member   left: s = "member   left ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  count " +  member count +  "  member address " +  member address ;  break ;  default : s = "unknown  conference eevent ( "  +  event  +  " ) " +  "  conference id " +  conference id +  "  call id " +  call id +  "  member address " +  member address ;  break ;   }  return s ;   }  
@ override public  properties   (  )  {   properties rv = super . get properties (  )  ;  if  (    router  !  =  null )  rv . put all (    router . get config map (  )  )  ;  return rv ;   }  
public void   ( int bob port )  {     bob port = bob port ;   }  
@ test public void   (  )  {  s1 . on next ( "a" )  ;  s1 . on next ( "b" )  ;  s1 . on complete (  )  ;  s2 . on next ( "1" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s2 . on next ( "2" )  ;  in order . verify ( observer
@ override public void   (  string username  date creation date )  throws  user not found exception  {  logger . finest ( "set creation date" )  ;   }  
private  group   (  )  {  while  ( current index  +  1  <  elements . length )   {  current index +  +  ;   group element = null ;  try  {  element =  group manager . get instance (  )  . get group ( elements[current index] )  ;   }  catch  (   group not found exception unfe )   {   }  if  ( element  !  =  null )   {  return element ;   }   }  return null ;   }  
@ test public void   (  )  {   observable <  string >  obs =  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (   observer <  ?  super  string >  observer )  {  observer . on subscribe (  disposab
@ override public void   (  throwable t )  {  actual . on error ( t )  ;  run finally (  )  ;   }  
@ override public void   (  throwable e )  {  errors . add ( e )  ;  dispose (  )  ;   }  
@ test public void   (  )  throws  exception  {  assert bytes written ( 0 )  ;  stats out . write ( 0 )  ;  assert bytes written ( 1 )  ;  stats out . write ( new byte[10] )  ;  assert bytes written ( 11 )  ;  stats out . write ( new byte[10] 0 5 )  ;  as
public  collection <  string >    (  )  {  return presence states ;   }  
public static  map <  string  string >    (  object bean )  {   map <  string  string >  properties = new  hash map <  >  (  )  ;  try  {   bean info bean info =  introspector . get bean info ( bean . get class (  )  )  ;   property descriptor[] descriptors = bean info . get property descriptors (  )  ;   string[] names = new  string[descriptors . length] ;  for  ( int i = 0 ;  i  <  names . length ;  i +  +  )   {   string name = descriptors[i] . get name (  )  ;   object value = descriptors[i] . get read method (  )  . invoke ( bean  ( java . lang .  object[] ) null )  ;  properties . put ( name encode ( value )  )  ;   }   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  return properties ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
@ override public void   (  )  {   observer <  ?  super t >  a = actual ;  for  (  ;   ;   )   {  if  ( cancelled )   {  return ;   }  t v = poll (  )  ;  if  ( v  =  =  null )   {  if  (  ! cancelled )   {  a . on complete (  )  ;   }  return ;   }  a . 
@ override public long   (  )  {  return end time  -  start time ;   }  
public int   (  )  {  return get integer value ( http   timeout 5000 )  ;   }  
public static boolean   (  )  {  return    one dot six ;   }  
public  string   (  )  {  return this . location ;   }  
public void   (  file web root )  {  this . web root = web root ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts =  observable . range ( 1 5 )  . to flowable (  backpressure strategy . latest )  . test ( 0 )  ;  ts . request ( 1 )  ;  ts . assert result ( 5 )  ;   }  
@ override public  string   (  )  {  return "http: /  / jabber . org / protocol / admin#update - group" ;   }  
public long   (  )  {  return msgid ;   }  
@ override public  string   (  )  {  return  ( " internal server socket on port "  +     port )  ;   }  
@ override public void   (  object t )  {  ts . on next ( t )  ;   }  
public  certificate store configuration   (  connection type type )  throws io exception  {  final  string key store type = get key store type ( type )  ;  final  string password = get trust store password ( type )  ;  final  string location = get trust store location ( type )  ;  final  file file = canonicalize ( location )  ;  return new  certificate store configuration ( key store type file password . to char array (  )  )  ;   }  
@ override public void   (  subscriber <  ?  super r > [] subscribers )  {  if  (  ! validate ( subscribers )  )   {  return ;   }  int n = subscribers . length ;  @ suppress warnings ( "unchecked" )   subscriber <  ?  super t > [] parents = new  subscrib
public  destination   (  sig type type )  throws i2p exception  io exception   data format exception  {  if  (  ! this . file . exists (  )  )   {   output stream out = null ;  try  {  out = new  secure file output stream ( this . file )  ;  if  ( this . client  !  =  null )  this . client . create destination ( out type )  ;  else write (  )  ;   }  finally  {  if  ( out  !  =  null )   {  try  {  out . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }   }  return get destination (  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  throws  exception  {  mock columns ( "long field" "value type field" )  ;  when ( result set . get long ( 1 )  )  . then return ( 123l )  ;  when ( result set . get object ( 2 
@ override public void   (  throwable t )  {  if  ( remaining  >  0l )   {  remaining = 0l ;  actual . on error ( t )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   }  
@ check return value @ experimental @ non null public final  parallel flowable < t >    ( @ non null  consumer <  ?  super t >  on next @ non null  bi function <  ?  super  long  ?  super  throwable  parallel failure handling >  error handler )  {   objec
@ override public void   (  disposable d )  {  disposables . replace ( d )  ;   }  
@ test public void   (  )  throws  throwable  {   callable <  flowable <  string >  >  factory = mock (  callable . class )  ;   flowable <  string >  first observable =  flowable . just ( "one" "two" )  ;   flowable <  string >  second observable =  flow
public  iterator <  object[] >    (  )  {  return transfer list . iterator (  )  ;   }  
default  sql statement customizer   (  annotation annotation  class <  ?  >  sql object type )  {  throw new  unsupported operation exception ( " not supported for type" )  ;   }  
private boolean   (  )  {  if  (  user manager . get user provider (  )  . is read only (  )  )   {  return false ;   }  try  {   user manager . get instance (  )  . create user ( "demo" "demo" " fastpath  demo  account" "demo@fastpath . com" )  ;  return true ;   }  catch  (   exception e )   {   log . error ( e . get message (  )  e )  ;   }  return false ;   }  
public synchronized org . jivesoftware . openfire . user .  user   (  )  {  if  ( openfire user  =  =  null )   {  openfire user = new org . jivesoftware . openfire . user .  user ( name display name email new  date (  )  new  date (  )  )  ;   }  return openfire user ;   }  
public  eddsa parameter spec   (  )  {  return ed dsa spec ;   }  
@ test public void   (  )  {   test scheduler s = new  test scheduler (  )  ;   observable <  long >  interval =  observable . interval ( 100  time unit . milliseconds s )  . publish (  )  . ref count (  )  ;  final  list <  long >  list1 = new  array lis
public  string   (  )  {  return " net db process dsrm" ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   flowable . just ( 1 )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  throws  exception  {  throw e ;
public int   (  )  {  return message   type ;   }  
public  string   (  )  {  return subject ;   }  
public  string   (  )  {  return    context . log manager (  )  . get date format pattern (  )  ;   }  
@ suppress warnings ( "unchecked" )  @ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;   flowable <  integer >  source =  flowable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public vo
@ test public void   (  )  {   publish processor <  object >  as =  publish processor . create (  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . get throwable (  )  )  ;  as . on complet
public long   (  )  {  return    last participating expiration ;   }  
void   ( int count )  {     total comments sent = count ;   }  
@ test public void   (  )  throws  malformed object name exception   attribute not found exception  m bean exception   reflection exception   instance not found exception  {  metrics service . set enabled ( false )  ;  assert false ( metrics service . is 
private void   ( muc room room )  {   conference conference = new  conference (  )  ;  conference . id = room . get name (  )  ;  conference . pin = room . get password (  )  ;  if  ( conference . pin  !  =  null && conference . pin . length (  )   =  =  0 )  conference . pin = null ;  conference . exten = room . get description (  )  ;  int pos = conference . exten . index of ( ":" )  ;  if  ( pos  >  0 )  conference . exten = conference . exten . substring ( 0 pos )  ;  else conference . exten = null ;  if  ( conference . exten  !  =  null && conference . exten . length (  )   >  0 )   {  conf extensions . put ( conference . exten conference )  ;   }  conferences . put ( conference . id conference )  ;   log . info (  string . format ( " voice bridge create conference: %s with pin %s extension %s" conference . id conference . pin conference . exten )  )  ;   }  
@ check return value @ non null public static  < t >  single subject < t >    (  )  {  return new  single subject < t >  (  )  ;   }  
private void   ( long date long )  {  date = new  date ( date long )  ;  synchronized  ( date formatter )   {  formatted date = date formatter . format ( date )  ;  local formatted date = local date formatter . format ( date )  ;  quoted date = long local date formatter . format ( date )  ;   }   }  
@ deprecated public void   (  set <  session tag >  tags )  {  if  ( tags  !  =  null &&  ! tags . is empty (  )  )     log . error ( " who is sending tags thru the streaming lib ?  "  +  tags . size (  )  )  ;   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  this . value = null ;  actual . on error ( t )  ;   }  
private boolean   (  string protocol int port  string description  forward port fp )  {   service service ;  synchronized  ( lock )   {  if  ( is disabled ||  ! isnat present (  )  ||    router  =  =  null )   {     log . error ( " can't add mapping: "  +  is disabled  +  " " +  isnat present (  )  +  " " +     router )  ;  return false ;   }  service =    service ;   }   action add = service . get action ( " add port mapping" )  ;  if  ( add  =  =  null )   {  if  (    service lacksapm )   {  if  (    log . should log (  log . warn )  )     log . warn ( " couldn't find  add port mapping action ! " )  ;   }  else  {     service lacksapm = true ;     log . log always (  log . warn "u pnp device does not support port forwarding" )  ;   }  return false ;   }  add . set argument value ( " new remote host" "" )  ;  add . set argument value ( " new external port" port )  ;   string intf =    router . get interface address (  )  ;   string us = get our address ( intf )  ;  if  (    log . should log (  log . warn )  &&  ! us . equals ( intf )  )     log . warn ( " requesting port forward to "  +  us  +  ':' +  port +  " when cybergarage wanted " +  intf )  ;  add . set argument value ( " new internal client" us )  ;  add . set argument value ( " new internal port" port )  ;  add . set argument value ( " new protocol" protocol )  ;  add . set argument value ( " new port mapping description" description )  ;  add . set argument value ( " new enabled" "1" )  ;  add . set argument value ( " new lease duration" 0 )  ;  boolean rv = add . post control action (  )  ;  if  ( rv )   {  synchronized  ( lock )   {  ports forwarded . add ( fp )  ;   }   }  int level = rv  ?   log . info :  log . warn ;  if  (    log . should log ( level )  )   {   string builder buf = new  string builder (  )  ;  buf . append ( " add port mapping result for " )  . append ( protocol )  . append ( " port " )  . append ( port )  ;  u pnp status status = add . get status (  )  ;  if  ( status  !  =  null )  buf . append ( "  status: " )  . append ( status . get code (  )  )  . append ( ' ' )  . append ( status . get description (  )  )  ;  status = add . get control status (  )  ;  if  ( status  !  =  null )  buf . append ( "  control status: " )  . append ( status . get code (  )  )  . append ( ' ' )  . append ( status . get description (  )  )  ;     log . log ( level buf . to string (  )  )  ;   }  return rv ;   }  
public boolean   ( int tunnel )  {  return get boolean property ( tunnel i2p tunnelhttp client . prop   user   agent )  ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable .  <  integer > empty (  )  . single element (  )  ;   maybe observer <  integer >  observer =  test helper . mock maybe observer (  )  ;  o . subscribe ( observer )  ;   in order in order
public  string   (  string name )  {  return    config . get ( name )  ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   safe observer <  integer >  so = new  safe observer <  integer >  ( to )  ;   disposable d =  disposables . empty (  )  ;  so . on subscribe ( d )  
@ override public void   ( t value )  {  bh . consume ( value )  ;  cdl . count down (  )  ;   }  
@ test ( expected =  arithmetic exception . class )  public void   (  )  {   flowable . range ( 1 1 )  . last element (  )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer i )  {  return i  /  0 ;   }   }
protected  task scheduler   (  )  {  return new  scheduler dead ( context )  ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
@ override protected  ad hoc command .  action   (  session data data )  {  return  ad hoc command .  action . complete ;   }  
@ test public void   (  )  {  final  list <  long >  requests = new  array list <  long >  (  )  ;   flowable . just ( 1 )  . do on request ( new  long consumer (  )  {  @ override public void accept (  long n )  {  requests . add ( n )  ;   }   }   )  . 
@ test ( expected =  illegal state exception . class )  public void   (  )  throws  exception  {  try  (  handle h = db rule . open handle (  )  )  {  final  prepared batch b = h . prepare batch ( "insert into something  ( id  name )  values  (  ?    ?  )
public  collection <  chat setting >    (  )  {  return settings list . values (  )  ;   }  
private  string   ( final  reference sequence ref final int context start index final int context full length )  {  if  ( current ref index  !  =  ref . get contig index (  )  )   {  current ref string = new  string ( ref . get bases (  )  )  . to upper case (  )  ;  current ref index = ref . get contig index (  )  ;   }  return current ref string . substring ( context start index context start index  +  context full length )  ;   }  
public boolean   (  )  {  return  session manager . get instance (  )  . is anonymous route ( get address (  )  )  ;   }  
@ test public void   (  )  throws  versioned host not found exception  {   http servlet request wrapper request = mock (  http servlet request wrapper . class )  ;  when ( request . get requesturi (  )  )  . then return ( " / service / rs" )  ;  when ( re
@ test public void   (  )  {  in . close (  )  ;  assert true ( in . is locally closed (  )  )  ;  assert false ( in . can accept ( 2 1 )  )  ;   }  
public static boolean   (  )  {  if  ( clustered cache factory strategy  =  =  null )   {  try  {  clustered cache factory strategy =  (  cache factory strategy )  class . for name ( clustered cache factory class true get clustered cache strategy class loader (  )  )  . new instance (  )  ;   }  catch  (   no class def found error| exception e )   {  log . warn ( " clustered cache factory strategy "  +  clustered cache factory class  +  " not found" )  ;   }   }  return  ( clustered cache factory strategy  !  =  null )  ;   }  
@ override public void   (  )  {   disposable helper . dispose ( this )  ;   }  
public double   ( final  genotype concordance scheme scheme final  truth state[] truth state array )  {  double numerator = 0 . 0 ;  double denominator = 0 . 0 ;  scheme . validate scheme (  )  ;  for  (  final  truth state truth state : truth state array )   {  for  (  final  call state call state :  call state . values (  )  )   {  final  truth and call states truth and call states = new  truth and call states ( truth state call state )  ;  final long count = get count ( truth and call states )  ;  for  (  final  contingency state contingency state : scheme . get concordance state array ( truth and call states )  )   {  if  (  contingency state . tp  =  =  contingency state )   {  numerator +  = count ;  denominator +  = count ;   }  else if  (  contingency state . fn  =  =  contingency state )   {  denominator +  = count ;   }   }   }   }  return  ( numerator  /  denominator )  ;   }  
@ override public boolean   (  )  {  return get (  )   =  =   disposable helper . disposed ;   }  
public int   (  )  {  return hash len ;   }  
public final void   ( @ non null  disposable resource )  {   object helper . require non null ( resource "resource is null" )  ;  resources . add ( resource )  ;   }  
@ test public void   (  )  {  for  ( int i = 1 ;  i  >  0 ;  i* = 2 )   {  assert true (  pow2 . is power of two ( i )  )  ;   }  assert false (  pow2 . is power of two ( 3 )  )  ;  assert false (  pow2 . is power of two ( 5 )  )  ;  assert false (  pow2 
public void   ( udp packet packet )  {  if  ( packet  =  =  null ||  !    keep running )  return ;  int psz = packet . get packet (  )  . get length (  )  ;  if  ( psz  >   peer state . max   mtu )   {     log . error ( " dropping large udp packet "  +  psz  +  " bytes: " +  packet )  ;  return ;   }  if  (    dummy )   {  packet . release (  )  ;  return ;   }  packet . request outbound bandwidth (  )  ;  try  {     outbound queue . put ( packet )  ;   }  catch  (   interrupted exception ie )   {  packet . release (  )  ;  return ;   }  if  (    log . should log (  log . debug )  )   {     log . debug ( " added the packet onto the queue with a lifetime of "  +  packet . get lifetime (  )  )  ;   }   }  
public void   (  )  {   token list list = new  token list ( " name" )  ;   cache token token1a = list . add ( "1" )  ;  assert true ( token1a . is valid (  )  )  ;  assert equals ( "1" token1a . get id (  )  )  ;  assert equals ( 1 list . size (  )  )  ;   cache token token1b = list . add ( "1" )  ;  assert true ( token1b . is valid (  )  )  ;  assert equals ( "1" token1b . get id (  )  )  ;  assert true ( token1a . equals ( token1b )  )  ;  assert equals ( 2 list . size (  )  )  ;   cache token token2 = list . add ( "2" )  ;  assert false ( token1a . equals ( token2 )  )  ;  assert equals ( 3 list . size (  )  )  ;  assert equals ( 2 list . invalidate tokens ( "1" )  )  ;  assert false ( token1a . is valid (  )  )  ;  assert false ( token1b . is valid (  )  )  ;  assert true ( token2 . is valid (  )  )  ;  assert equals ( 1 list . size (  )  )  ;  assert equals ( token2 list . get ( 0 )  )  ;   cache token token3a = list . add ( "3" )  ;   cache token token3b = list . add ( "3" )  ;   cache token token3c = list . add ( "3" )  ;  assert true ( list . remove ( token3a )  )  ;  assert true ( list . remove ( token3b )  )  ;  assert true ( token3a . is valid (  )  )  ;  assert true ( token3b . is valid (  )  )  ;  assert true ( token3c . is valid (  )  )  ;  assert equals ( 2 list . size (  )  )  ;   }  
public final static double   (  properties props  string prefix  string name )  {   string val = props . get property ( prefix  +  name )  ;  if  ( val  !  =  null )   {  try  {  return  double . parse double ( val )  ;   }  catch  (   number format exception nfe )   {   log log = i2p app context . get global context (  )  . log manager (  )  . get log (  persistence helper . class )  ;  log . warn ( " error formatting "  +  val nfe )  ;   }   }  return 0 ;   }  
public long   (  )  {  try  {  return inf . get bytes written (  )  ;   }  catch  (   runtime exception e )   {  return 0 ;   }   }  
@get @ path ( " /  { property key } " )  @ produces (  {  media type . application   xml  media type . application   json }  )  public  system property   ( @ path param ( "property key" )   string property key )  throws  service exception  {  return plugi
private  sorted map <  query interval  list <  allele >  >    ( final  file vcf )  {  final  map <  string  integer >  contig index map = new  hash map <  >  (  )  ;  final vcf file reader vcf reader = new vcf file reader ( vcf false )  ;  final  compound filter compound filter = new  compound filter ( true )  ;  compound filter . add ( new  snp filter (  )  )  ;  compound filter . add ( new  passing variant filter (  )  )  ;  compound filter . add ( new  genotype quality filter ( minimum   gq sample )  )  ;  compound filter . add ( new  heterozygosity filter ( true sample )  )  ;  final  iterator <  variant context >  het iterator = new  filtering variant context iterator ( vcf reader . iterator (  )  compound filter )  ;  for  (  final vcf contig header line vcf contig : vcf reader . get file header (  )  . get contig lines (  )  )   {  contig index map . put ( vcf contig . getid (  )  vcf contig . get contig index (  )  )  ;   }  final  sorted map <  query interval  list <  allele >  >  map = new  tree map <  >  (  )  ;  while  ( het iterator . has next (  )  )   {  final  variant context vc = het iterator . next (  )  ;  map . put ( new  query interval ( contig index map . get ( vc . get contig (  )  )  vc . get start (  )  vc . get end (  )  )  vc . get genotype ( sample )  . get alleles (  )  )  ;   }  vcf reader . close (  )  ;  return map ;   }  
@ override public void   (  )  throws  exception  {  b[0] = true ;   }  
@ override public  string   (  )  {  if  (  ! is complete (  )  )   {  throw new  illegal state exception ( " authentication exchange not completed . " )  ;   }  return null ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public boolean   (  )  {  return false ;   }  
public void   (  list <  string >  owners )  {  this . owners = owners ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( "[ host lookup message: " )  ;  buf . append ( "\n\t" )  . append (    session id )  ;  buf . append ( "\n\t reqid: " )  . append (    reqid )  ;  buf .
@ override public  string   (  )  {  return "whitelist" ;   }  
@ override public void   ( t value )  {  complete ( value )  ;   }  
protected int   (  )  {  int def =  math . min ( default   maximum   fast   peers  ( 6 *    context . client manager (  )  . list clients (  )  . size (  )  )   +  default   minimum   fast   peers  -  2 )  ;  return    context . get property ( prop   minimum   fast   peers def )  ;   }  
public void   (  )  throws  exception  {  try  {  setup copy messages ( true )  ;  m copy mock . expect ( get copy messages pattern (  )  new  string[] { "* bad failed for some reason" get next tag ( true )   +  "  ok copy completed" }  )  ;  m folder . copy messages ( m copy messages m copy to folder null )  ;  fail ( " messaging exception expected . " )  ;   }  catch  (   messaging exception expected )   {   }   }  
@ override public  map <  string  map <  string  string >  >    (  )  {  return bare presences ;   }  
public  collection   (  )  {  if  ( breadcrumbs  =  =  null )   {  breadcrumbs = new  array list (  )  ;   }  return breadcrumbs ;   }  
@ override public void   (  throwable e )  {  d =  disposable helper . disposed ;  actual . on error ( e )  ;   }  
 string   (  )  {  if  ( credentials  =  =  null )   {  return null ;   }  return credentials . get password (  )  ;   }  
@ override public  string   (  )  {  return " number of  active  users" ;   }  
public  string   (  )  {   file f =  config service handler . wrapper log file (    context )  ;   string str ;  if  (    context . has wrapper (  )  )   {  str = read text file ( f 250 )  ;   }  else  {  str =  file util . read text file ( f . get absolute path (  )  250 false )  ;   }  if  ( str  =  =  null )   {  return " < p > "  +     t ( " file not found" )   +  ":  < b >  < code > " +  f . get absolute path (  )  +  " <  / code >  <  / b >  <  / p > " ;   }  else  {  str = str . replace ( "&" "&amp ; " )  . replace ( " < " "&lt ; " )  . replace ( " > " "&gt ; " )  ;  return " < p > "  +     t ( " file location" )   +  ":  < a href = \" / wrapper . log\" target = \"   blank\" > " +  f . get absolute path (  )  +  " <  / a >  <  / p >  <  / td >  <  / tr > \n < tr >  < td >  < pre id = \"servicelogs\" > " +  str +  " <  / pre > " ;   }   }  
public void   (  string moo )  {     upnp = true ;   }  
@ test public void   (  )  {  repose info logic . process request size ( 105l )  ;  assert equals ( 105l repose info logic . get accumulated request size (  )  )  ;   }  
private static long   ( final  string file path final  input stream input stream )  {  final byte[] header = new byte[header   size] ;  try  {  final int header bytes read = input stream . read ( header )  ;  if  ( header bytes read  !  =  header   size )   {  throw new  picard exception ( " malformed file  expected header of size "  +  header   size  +  " but received " +  header bytes read )  ;   }   }  catch  (  final io exception ioe )   {  throw new  picard exception ( " unable to read header for file  ( "  +  file path  +  " ) " ioe )  ;   }  final  byte buffer header buf =  byte buffer . wrap ( header )  ;  header buf . order (  byte order . little   endian )  ;  return  unsigned type util . u int to long ( header buf . get int (  )  )  ;   }  
@ override public void   (  )  {  latch . count down (  )  ;   }  
public byte[]   (  )  {  return bytes ;   }  
public  string   (  )  {  return search ;   }  
public static  encryptor   (  )  {  if  ( security properties  =  =  null )   {  load security properties (  )  ;   }  if  ( property encryptor  =  =  null )   {   string algorithm = security properties . get property ( encryption   algorithm )  ;  if  ( encryption   algorithm   aes . equals ignore case ( algorithm )  )   {  property encryptor = new  aes encryptor ( current key )  ;   }  else  {  property encryptor = new  blowfish ( current key )  ;   }   }  return property encryptor ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "one" "two" "three" "four" "five" "six" )  ;   observable <  grouped observable <  integer  string >  >  grouped = source . group by ( length )  ;   map <  integer  colle
@ test public void   (  )  {   observable <  integer >  w =  observable . just ( 1 )  ;   single <  boolean >  observable = w . is empty (  )  ;   single observer <  boolean >  observer =  test helper . mock single observer (  )  ;  observable . subscribe
@ override public long   ( int percent to include )  {   vector <  long >  skews =    manager . get clock skews (  )  ;  if  ( skews  =  =  null || skews . is empty (  )  ||  ( skews . size (  )   <  5 &&    context . clock (  )  . get updated successfull
boolean   (  )  {  return type  =  =   type . group || type  =  =   type . subscription ;   }  
private  observable <  string >    ( final  string[] values final long interval final  throwable e )  {  return  observable . unsafe create ( new  observable source <  string >  (  )  {  @ override public void subscribe (  final  observer <  ?  super  string >  observer )  {   composite disposable parent subscription = new  composite disposable (  )  ;  observer . on subscribe ( parent subscription )  ;  long delay = interval ;  for  (  final  string value : values )   {  parent subscription . add ( inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  observer . on next ( value )  ;   }   }   delay  time unit . milliseconds )  )  ;  delay +  = interval ;   }  parent subscription . add ( inner scheduler . schedule ( new  runnable (  )  {  @ override public void run (  )  {  if  ( e  =  =  null )   {  observer . on complete (  )  ;   }  else  {  observer . on error ( e )  ;   }   }   }   delay  time unit . milliseconds )  )  ;   }   }   )  ;   }  
@ data provider public  object[][]   (  )  {  return new  object[][] {  { "seq   dict   test . dictionary . bad" }   { "seq   dict   test . dictionary . bad . vcf" }  }  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp =  publish process
public  tunnel id   (  )  {  return    tunnel id ;   }  
@ test public void   (  )  throws io exception  {  byte[] serialized = serializer . write object ( target )  ;  assert not null ( serialized )  ;   }  
@ override public  hash   (  )  {  return  hash . fake   hash ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . just ( 1 )  . amb with (  observable . just ( 2 )  )  . subscribe ( to )  ;  to . assert value ( 1 )  ;   }  
@ override public  string   (  )  {   string column = get column ( key   column   tuple   index )  ;  if  ( column  =  =  null )   {  return this . registry . get (  map entry mappers . class )  . get key column (  )  ;   }  return column ;   }  
public  file transfer progress   (  )  {  return progress ;   }  
void   (  string hash attribute )  {  this . hash attribute = hash attribute ;   }  
@ override protected void   (  single observer <  ?  super  boolean >  s )  {  source . subscribe ( new  any subscriber < t >  ( s predicate )  )  ;   }  
@ test public void   (  )  {   observable <  integer >  source =  observable . never (  )  ;   observer <  list <  integer >  >  o =  test helper . mock observer (  )  ;   test observer <  list <  integer >  >  to = new  test observer <  list <  integer >
public boolean   (  )  {  return is successful ( get status code (  )  )  ;   }  
public void   (  boolean value )  {     lost packet id plus6 = value ;   }  
public int   ( int tunnel )  {  return    helper . get limit minute ( tunnel )  ;   }  
public  data structure   (  )  throws  data format exception  {   send message message msg = new  send message message (  )  ;  msg . set destination (  (  destination )  ( new  destination test (  )  )  . create data structure (  )  )  ;  msg . set payload (  (  payload )  ( new  payload test (  )  )  . create data structure (  )  )  ;  msg . set session id (  (  session id )  ( new  session id test (  )  )  . create data structure (  )  )  ;  msg . set nonce ( 1 )  ;  return msg ;   }  
@ override public void   (  subscriber <  ?  super t >  s )  {   subscription arbiter sa = new  subscription arbiter (  )  ;  s . on subscribe ( sa )  ;   retry subscriber < t >  rs = new  retry subscriber < t >  ( s count predicate sa source )  ;  rs . s
@ deprecated public  input stream   (  )  {  return    error stream ;   }  
@ override protected boolean   (  )  {  return false ;   }  
private static  string   (  string str int size )  {   string builder buf = new  string builder (  )  ;  if  ( str  =  =  null )  str = "" ;  if  ( str . length (  )   >  size )  str = str . substring ( str . length (  )   -  size )  ;  buf . append ( str )  ;  while  ( buf . length (  )   <  size )  buf . append ( ' ' )  ;  return buf . to string (  )  ;   }  
public static long   (  string workgroup name  date start date  date end date )  {   workgroup workgroup = null ;  try  {  workgroup =  workgroup manager . get instance (  )  . get workgroup ( new jid ( workgroup name )  )  ;   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  if  ( workgroup  =  =  null )   {  return 0 ;   }  int wait time = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( workgroup   wait   time )  ;  pstmt . set long ( 1 workgroup . getid (  )  )  ;  pstmt . set int ( 2 1 )  ;  pstmt . set string ( 2  string utils . date to millis ( start date )  )  ;  pstmt . set string ( 3  string utils . date to millis ( end date )  )  ;  rs = pstmt . execute query (  )  ;  rs . next (  )  ;  wait time = rs . get int ( 1 )  ;   }  catch  (   exception ex )   {   log . error ( ex . get message (  )  ex )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return wait time ;   }  
public static  string   (  string name  workgroup form .  form enum answer type  list <  string >  items )  {  final  string builder builder = new  string builder (  )  ;  if  (  workgroup form .  form enum . textfield  =  =  answer type )   {  builder . append ( " < input type = \"text\" size = \"30\" name = \"" )  . append ( name )  . append ( "\" > " )  ;   }  else if  (  workgroup form .  form enum . textarea  =  =  answer type )   {  builder . append ( " < textarea name = \"" )  . append ( name )  . append ( "\" cols = \"30\" rows = \"3\" > " )  ;  builder . append ( " <  / textarea > " )  ;   }  else if  (  workgroup form .  form enum . dropdown   box  =  =  answer type )   {  builder . append ( " < select name = \"" )  . append ( name )  . append ( "\" > " )  ;  if  ( items  !  =  null )   {  for  (   string item : items )   {  builder . append ( " < option value = \"" )  . append ( item )  . append ( "\" > " )  . append ( item )  . append ( " <  / option > " )  ;   }   }  builder . append ( " <  / select > " )  ;   }  else if  (  workgroup form .  form enum . checkbox  =  =  answer type )   {  if  ( items  =  =  null )   {  return null ;   }  int counter = 0 ;  for  (   string value : items )   {  builder . append ( " < input type = \"checkbox\" value = \"" )  . append ( value )  . append ( "\" name = \"" )  . append ( name )  . append ( counter )  . append ( "\" > " )  ;  builder . append ( "&nbsp ; " )  ;  builder . append ( value )  ;  builder . append ( " < br /  > " )  ;  counter +  +  ;   }   }  else if  (  workgroup form .  form enum . radio   button  =  =  answer type )   {  if  ( items  =  =  null )   {  return null ;   }  for  (   string value : items )   {  builder . append ( " < input type = \"radio\" value = \"" )  . append ( value )  . append ( "\" name = \"" )  . append ( name )  . append ( "\" > " )  ;  builder . append ( "&nbsp ; " )  ;  builder . append ( value )  ;  builder . append ( " < br /  > " )  ;   }   }  return builder . to string (  )  ;   }  
public  string   (  )  {  return    description ;   }  
public  string   (  )  {  return  split vcfs . class . get simple name (  )  ;   }  
public void   (  )  {   mock vendor policy . inject ( get context (  )  )  ;   vendor policy loader pl =  vendor policy loader . get instance ( get context (  )  )  ;   bundle result = new  bundle (  )  ;  result . put int ( "ret" 1 )  ;   mock vendor policy . mock result = result ;   bundle args = new  bundle (  )  ;  args . put string ( "arg1" "a" )  ;   bundle actual result = pl . get policy ( "policy1" args )  ;  assert equals ( "policy" "policy1"  mock vendor policy . passed policy )  ;  assert equals ( "arg" "a"  mock vendor policy . passed bundle . get string ( "arg1" )  )  ;  assert equals ( "result" 1 actual result . get int ( "ret" )  )  ;   }  
public void   ( int p )  {  tracker seen peers = p ;   }  
public void   ( final sam record rec )  {  supplemental second of pair . add ( rec )  ;   }  
@ override public synchronized boolean   (  )  {  return    os  =  =  null ;   }  
public static  big integer   (  )  {  return group order ;   }  
public void   ( int min )  {  if  ( min  =  =  min chats )   {  return ;   }  min chats = min ;  update workgroup (  )  ;   }  
@ override protected boolean   (  )  {  return false ;   }  
public static  byte[]   (  short value )  {  byte bytes[] = new byte[2] ;   byte buffer . wrap ( bytes )  . put short ( value . short value (  )  )  ;  return bytes to array ( bytes )  ;   }  
@ override public boolean   (  )  {  return  disposable helper . is disposed ( get (  )  )  ;   }  
@ override protected  command line program   (  )  {  return new  simple mark duplicates with mate cigar (  )  ;   }  
@ test public void   (  )  {  assert that ( in . get nacks (  )  is ( null value (  )  )  )  ;  in . message received ( 0 new  byte array (  )  )  ;  assert that ( in . get nacks (  )  is ( null value (  )  )  )  ;  in . message received ( 2 new  byte arr
@ test public void   (  )  {   test helper . check disposed (  publish subject . create (  )  . take ( 2 )  )  ;   }  
public boolean   (  )  {  return    is failing ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable observable <  integer >  co =  observable . range ( 1 3 )  . replay (  )  ;  final  test observer <  integer >  to1 = new  t
public void   (  inet socket address send address )  {  if  ( member address  =  =  null || member address . equals ( send address )  )   {  return ;   }   logger . println ( " call "  +  cp  +  " member address changed from " +  member address +  " to " +  send address )  ;  member address = send address ;   }  
 string   (  )  {  return name ;   }  
public void   ( long now )  {  last seen = now ;   }  
public  properties   (  )  {  return    options ;   }  
public  set <  hash >    ( char capability )  {  if  (    manager  =  =  null )  return  collections . empty set (  )  ;  return    manager . get peers by capability ( capability )  ;   }  
public  input stream   (  )  throws io exception  {  final  input stream result ;  switch  (  body content media type . get media type ( content type . get mime type (  )  . get name (  )  )  )   {  case xml: result = input ;  break ;  case json: result = json preprocessing  ?  get json processor (  )  . process ( input )  : input ;  break ;  default : result = get unknown content processor (  )  . process ( input )  ;  break ;   }  return result ;   }  
public static  encryption mode   (  string crypto suite )  {   string    var0 = crypto suite ;  if  (    var0  !  =  null  ?     var0 . equals ( getaescm128hmacsha180 (  )  )  :    var0  =  =  getaescm128hmacsha180 (  )  )  return  encryption mode .  default ;   string    var1 = crypto suite ;  if  (    var1  !  =  null  ?     var1 . equals ( getaescm128hmacsha132 (  )  )  :    var1  =  =  getaescm128hmacsha132 (  )  )  return  encryption mode . aes128 weak ;   string    var2 = crypto suite ;  if  (    var2  !  =  null  ?     var2 . equals ( getnullhmacsha180 (  )  )  :    var2  =  =  getnullhmacsha180 (  )  )  return  encryption mode .  null strong ;   string    var3 = crypto suite ;  if  (    var3  !  =  null  ?     var3 . equals ( getnullhmacsha132 (  )  )  :    var3  =  =  getnullhmacsha132 (  )  )  return  encryption mode .  null weak ;  else return  encryption mode .  null ;   }  
private  http client   (  )  {   http client container client response = null ;  try  {  client response = http client service . get client ( connection pool id )  ;  return client response . get http client (  )  ;   }  finally  {  if  ( client response  !  =  null )   {  http client service . release client ( client response )  ;   }   }   }  
@ deprecated public int   (  )  {  return get port (  connection type . connection   manager true )  ;   }  
public  client app   (  string name )  {  return    registered . get ( name )  ;   }  
public static  < t k >  grouped unicast < k t >    ( k key int buffer size  group by subscriber <  ?  k t >  parent boolean delay error )  {   state < t k >  state = new  state < t k >  ( buffer size parent key delay error )  ;  return new  grouped unicast < k t >  ( key state )  ;   }  
public void   (  )  throws uri syntax exception  {   intent i = get test intent ( "imap: /  / user:password@server . com:999" )  ;  set activity intent ( i )  ;  get activity and fields (  )  ;  assert true ( is next button enabled (  )  )  ;   }  
static  string   (  )  {  final  string builder boundary = new  string builder (  )  ;  boundary . append ( " -  -    com . android . email   " )  . append (  system . nano time (  )  )  ;  synchronized  (  rfc822 output . class )   {  boundary . append ( s boundary digit )  ;  s boundary digit =  ( byte )  (  ( s boundary digit  +  1 )  % 10 )  ;   }  return boundary . to string (  )  ;   }  
@ override protected void   (  http servlet request req  http servlet response resp )  throws  servlet exception  io exception  {  resp . set character encoding ( "utf - 8" )  ;  resp . set header ( "x -  content -  type -  options" "nosniff" )  ;  resp .
@ override public void   ( t value )  {   completable source cs ;  try  {  cs =  object helper . require non null ( mapper . apply ( value )  " the mapper returned a null  completable source" )  ;   }  catch  (   throwable ex )   {   exceptions . throw if
@ test public void   (  )  {   test scheduler scheduler = new  test scheduler (  )  ;   publish subject <  integer >  source =  publish subject . create (  )  ;   observable <  integer >  result = source . skip ( 1  time unit . seconds scheduler )  ;   ob
@ override public  string   (  )  {  return list . to string (  )  ;   }  
@ override public  string   (  )  {  return  locale utils . get localized string ( "gateway . yahoo . username" "kraken" )  ;   }  
public  incoming server session   ( byte[] nodeid  streamid streamid )  {  return new  remote incoming server session ( nodeid streamid )  ;   }  
@ test public void   (  )  {  final  atomic boolean r = new  atomic boolean (  )  ;   flowable .  <  string > error ( new  test exception (  )  )  . do on terminate ( new  action (  )  {  @ override public void run (  )  {  r . set ( true )  ;   }   }   )
public int[]   ( int sample time )  throws io exception  {  if  ( linear offset  >  =  linear data . length )   {  return null ;   }  int byte len = sample rate * sample time * channels* 2  /  1000 ;  int[] data = new int[byte len  /  2] ;  int data offset = 0 ;  for  ( int i = 0 ;  i  <  byte len ;  i +  = 2 )   {  if  ( linear offset  >  =  linear data . length )   {  break ;   }  data[data offset +  + ] = linear data[linear offset +  + ] ;   }  return data ;   }  
public  physical location for mate cigar set   (  )  {  return this . location set ;   }  
@ override public void   (  )  {   action a = get and set ( null )  ;  if  ( a  !  =  null )   {  try  {  a . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }  d . dispose ( 
public static  key store   (  file ks file  string password )  throws  general security exception  io exception  {  boolean exists = ks file  !  =  null && ks file . exists (  )  ;  char[] pwchars = password  !  =  null  ?  password . to char array (  )  : null ;   key store ks =  key store . get instance (  key store . get default type (  )  )  ;  if  ( exists )   {   input stream fis = null ;  try  {  fis = new  file input stream ( ks file )  ;  ks . load ( fis pwchars )  ;   }  finally  {  if  ( fis  !  =  null )  try  {  fis . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  if  ( ks file  !  =  null &&  ! exists )   {   output stream fos = null ;  try  {  ks . load ( null default   keystore   password . to char array (  )  )  ;  fos = new  secure file output stream ( ks file )  ;  ks . store ( fos pwchars )  ;   }  finally  {  if  ( fos  !  =  null )  try  {  fos . close (  )  ;   }  catch  (  io exception ioe )   {   }   }   }  return ks ;   }  
@ test public void   (  )  {   test completable tc = new  test completable (  )  ;  tc . dispose (  )  ;  assert true ( tc . is disposed (  )  )  ;   disposable d =  disposables . empty (  )  ;  tc . on subscribe ( d )  ;  assert true ( d . is disposed ( 
public static  encoding   (  string name )  {  return name  !  =  null && name . length (  )   >  0  ?  encodings . get ( name )  : null ;   }  
@ override public void   ( t t )  {  actual . on next ( t )  ;   }  
@ override public void   (  )  {  if  ( subscription count . increment and get (  )   >  max concurrent )   {  failed = true ;   }  t1 . on next ( "one" )  ;  t1 . on next ( "two" )  ;  t1 . on next ( "three" )  ;  t1 . on next ( "four" )  ;  t1 . on next
public  rate stat   (  )  {  return    db introduction ;   }  
public  string   (  string meeting id  string phone no )  {   string pin = null ;  if  ( conf extensions . contains key ( phone no )  )   {   conference conf = conf extensions . get ( phone no )  ;  pin = conf . pin ;   }  else if  ( conferences . contains key ( meeting id )  )   {   conference conf = conferences . get ( meeting id )  ;  pin = conf . pin ;   }  return pin ;   }  
@ test public void   (  )  {   test scheduler s = new  test scheduler (  )  ;   flowable <  integer >  source =  flowable . just ( 1 2 3 )  . concat with (  flowable .  <  integer > error ( new  test exception (  )  )  )  ;   test subscriber <  integer > 
public  collection <  group >    (  string user name )  {   collection <  string >  group names =  (  collection <  string >  ) group meta cache . get ( user name )  ;  if  ( group names  =  =  null )   {  synchronized  ( user name . intern (  )  )   {  group names =  (  collection <  string >  ) group meta cache . get ( user name )  ;  if  ( group names  =  =  null )   {  group names = provider . get shared group names ( new jid ( user name xmpp server . get instance (  )  . get server info (  )  . getxmpp domain (  )  null )  )  ;  group meta cache . put ( user name group names )  ;   }   }   }  return new  group collection ( group names )  ;   }  
@ xml element public  string   (  )  {  return presence status ;   }  
public i2p socket   ( i2psocks tunnel t )  throws socks exception  {  setup server (  )  ;  if  ( conn host name  =  =  null )   {     log . error ( "bug: destination host name has not been initialized ! " )  ;  throw new socks exception ( "bug !   see the logs ! " )  ;   }  if  ( conn port  =  =  0 )   {     log . error ( "bug: destination port has not been initialized ! " )  ;  throw new socks exception ( "bug !   see the logs ! " )  ;   }   data output stream out ;  try  {  out = new  data output stream ( client sock . get output stream (  )  )  ;   }  catch  (  io exception e )   {  throw new socks exception ( " connection error" e )  ;   }  i2p socket dest sock ;  try  {  if  ( conn host name . to lower case (  locale . us )  . ends with ( " . i2p" )  )   {   destination dest =    context . naming service (  )  . lookup ( conn host name )  ;  if  ( dest  =  =  null )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( " host not found" )  ;   }  if  (    log . should debug (  )  )     log . debug ( "connecting to "  +  conn host name  +  " .  .  . " )  ;   properties overrides = new  properties (  )  ;  i2p socket options skt opts = t . build options ( overrides )  ;  skt opts . set port ( conn port )  ;  dest sock = t . createi2p socket ( dest skt opts )  ;   }  else if  ( "localhost" . equals ( conn host name )  || "127 . 0 . 0 . 1" . equals ( conn host name )  )   {   string err = " no localhost accesses allowed through the  socks  proxy" ;     log . error ( err )  ;  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( err )  ;   }  else  {   outproxy outproxy = get outproxy plugin (  )  ;  if  ( outproxy  !  =  null )   {  try  {  dest sock = new  socket wrapper ( outproxy . connect ( conn host name conn port )  )  ;   }  catch  (  io exception ioe )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe2 )   {   }  throw new socks exception ( "connect failed via outproxy plugin" ioe )  ;   }   }  else  {   list <  string >  proxies = t . get proxies ( conn port )  ;  if  ( proxies  =  =  null || proxies . is empty (  )  )   {   string err = " no outproxy configured for port "  +  conn port  +  " and no default configured either  -  host: " +  conn host name ;     log . error ( err )  ;  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( err )  ;   }  int p =    context . random (  )  . next int ( proxies . size (  )  )  ;   string proxy = proxies . get ( p )  ;   destination dest =    context . naming service (  )  . lookup ( proxy )  ;  if  ( dest  =  =  null )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( " outproxy not found" )  ;   }  if  (    log . should debug (  )  )     log . debug ( "connecting to port "  +  conn port  +  " proxy " +  proxy +  " for " +  conn host name +  " .  .  . " )  ;  dest sock = t . createi2p socket ( dest )  ;   }   }  confirm connection (  )  ;     log . debug ( "connection confirmed  -  exchanging data .  .  . " )  ;   }  catch  (   data format exception e )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( " error in destination format" e )  ;   }  catch  (  io exception e )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( " error connecting" e )  ;   }  catch  (  i2p exception e )   {  try  {  send request reply (  reply . connection   refused  inet address . get by name ( "127 . 0 . 0 . 1" )  0 out )  ;   }  catch  (  io exception ioe )   {   }  throw new socks exception ( " error connecting" e )  ;   }  return dest sock ;   }  
public boolean   ( jid jid )  {  return jid  !  =  null &&  ! jid . get domain (  )  . equals ( xmpp server info . getxmpp domain (  )  )  &&  ! component manager . has component ( jid )  ;   }  
public  session entities   (  )  throws  service exception  {   collection <  client session >  client sessions =  session manager . get instance (  )  . get sessions (  )  ;   session entities session entities = convert to session entities ( client sessions )  ;  return session entities ;   }  
@ test public void   (  )  throws io exception  {  byte[] byte val =  { 1 2 }  ;  int off = 3 ;  int len = 7 ;  buffer . put ( byte val off len )  ;  verify ( b )  . put ( eq ( byte val )  eq ( off )  eq ( len )  )  ;   }  
public void   (  )  throws  exception  {  final  imap response parser p = generate parser ( 100000 "* bye  autologout timer ;  idle for too long\r\n" )  ;  try  {  p . read response (  )  ;  fail ( " didn't throw  bye exception" )  ;   }  catch  (   bye exception ok )   {   }   }  
@ override public void   (  )  {   subscription helper . cancel ( this )  ;   }  
public void   ( long requestid )  {  this . requestid = requestid ;   }  
@ override public boolean   (  )  {  return false ;   }  
public  node   (  )  {  if  ( node  =  =  null )  node = xmpp server . get instance (  )  . get pub sub module (  )  . get node ( node id )  ;  return node ;   }  
public  email service utils .  email service info   (  context context )  {  if  ( m incoming service info  =  =  null )   {  m incoming service info =  email service utils . get service info ( context get incoming protocol ( context )  )  ;   }  return m incoming service info ;   }  
@ override public  boolean   (  )  {  return false ;   }  
@ test public void   (  )  throws sql exception  {  assert that ( new  simple argument factory (  )  . build (  integer . class null config )  )  . is empty (  )  ;   }  
@ suppress warnings ( "unchecked" )  public static boolean   ( iq iq )  {  if  ( iq  =  =  null )   {  throw new  illegal argument exception ( " argument 'iq' cannot be null . " )  ;   }  if  ( iq . get type (  )   !  =  iq .  type . set )   {  return fal
@ override public void   (  throwable t )  {  if  ( get (  )   !  =   subscription helper . cancelled )   {  lazy set (  subscription helper . cancelled )  ;  parent . boundary error ( this t )  ;   }  else  {   rx java plugins . on error ( t )  ;   }   }
@ test ( data provider = "  data provider" )  public void test indexed run lane1 ( final boolean use barcodes dir )  throws  exception  {  final  file barcodes dir =  ( use barcodes dir )   ?  new  file ( root test dir " / 25t8b25t / barcodes   dir" )  : 
public  node   (  )  {   node env node = get envelope node (  )  ;  if  ( env node  =  =  null )  return null ;  if  ( env node . has nodes (  )   =  =  false )  return null ;  return env node . get node ( 0 )  ;   }  
@ test public void   (  )  {  final  atomic boolean atomic boolean = new  atomic boolean (  )  ;  assert false ( atomic boolean . get (  )  )  ;   completable . complete (  )  . do on dispose ( new  action (  )  {  @ override public void run (  )  throws 
@ test public void   (  )  {   maybe . just ( 1 )  . do on subscribe ( new  consumer <  disposable >  (  )  {  @ override public void accept (   disposable v )  throws  exception  {  throw new  test exception (  )  ;   }   }   )  . test (  )  . assert fai
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  actual . on next ( u )  ;  actual . on complete (  )  ;   }  
public  string   (  string phone no )  {   string id = null ;  if  ( conferences . contains key ( phone no )  )   {   conference conf = conferences . get ( phone no )  ;  id = conf . id ;   }  else if  ( conf extensions . contains key ( phone no )  )   {   conference conf = conf extensions . get ( phone no )  ;  id = conf . id ;   }  return id ;   }  
@ override public  void   (  )  {  return null ;   }  
public  session config   (  )  {  return    session config ;   }  
public long   (  )  {  return mina . get msg written (  )  ;   }  
public  packet queue   (  )  {  return    outbound queue ;   }  
public  string   (  )  {  return baz ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   list <  throwable >  errors =  test helper . track plugin errors (  )  ;  try  {  final  publish subject <  integer >  ps1 =  publish subject 
public void   ( int max users )  {  this . max users = max users ;   }  
@ test public void   (  )  throws  exception  {  final  file output =  file . create temp file ( "merge test" " . sam" )  ;  output . delete on exit (  )  ;  do merge alignment ( unmapped bam  arrays . as list ( one half aligned bam other half aligned bam
@ override public void   (  )  {  request ( 1 )  ;   }  
@ override public void   (  string label )  {  this . label = label ;   }  
@ test public void   (  )  {  final  flowable <  string >  o1 =  flowable . unsafe create ( new  test error flowable ( "four" null "six" )  )  ;  final  flowable <  string >  o2 =  flowable . unsafe create ( new  test error flowable ( "one" "two" "three" 
public  update   (  string plugin name  version current version )  {  for  (   update update : plugin updates )   {  if  ( update . get component name (  )  . equals ( plugin name )  )   {  if  ( new  version ( update . get latest version (  )  )  . is newer than ( current version )  )   {  return update ;   }   }   }  return null ;   }  
@ override public void   ( t value )  {  lazy set (  disposable helper . disposed )  ;  try  {  on success . accept ( value )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }   }  
@ test public void   (  )  {   observable . range ( 1 2 )  . concat map eager ( new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   integer t )  {  return  observable . range ( 1 1000 )  . s
@ test public void   (  )  {   observable . range ( 1  integer . max   value )  ;   }  
@ test public void   (  )  {   async processor <  integer >  async =  async processor . create (  )  ;  async . on next ( 1 )  ;  async . on complete (  )  ;   flowable processor <  integer >  serial = async . to serialized (  )  ;  assert false ( serial 
@ override public int   ( long account id )  {  return  resource helper . get instance ( m context )  . get account color ( account id )  ;   }  
@ override public  string   (  )  {  return super . to string (  )   +  " started "  +   data helper . format duration (  ( get context (  )  . clock (  )  . now (  )   -     started on )  )  +  " ago" ;   }  
@ override public void   ( final  throwable e )  {  actual . on error ( e )  ;   }  
static void   (  connection type type  string key store type )  {   jive globals . set property ( type . get prefix (  )   +  "store type" key store type )  ;  final  string old key store type = get key store type ( type )  ;  if  ( old key store type . equals ( key store type )  )   {   log . debug ( " ignoring  key store type change request  ( to ' {  } ' ) : listener already in this state . " key store type )  ;  return ;   }   log . debug ( " changing  key store type from ' {  } ' to ' {  } ' . " old key store type key store type )  ;   }  
@ test public void   (  )  throws  transformer exception  {   source resource = resolver . resolve (  class path uri resolver . classpath   prefix  +  " / blah . xsl" "" )  ;  assert null ( " should return null for non - existent resource" resource )  ;  
public void   (  writer writer )  {  this . writer = writer ;  this . auto flush = false ;   }  
@ override public boolean   (  )  {  return size (  )   =  =  0 ;   }  
private void   ( final  string[] args final  file metrics final int expected ret val final int expectedn metrics final  crosscheck metric .  data type expected type final boolean expect all match )  throws io exception   no such field exception  {  final  crosscheck read group fingerprints cross checker = new  crosscheck read group fingerprints (  )  ;   assert . assert equals ( cross checker . instance main ( args )  expected ret val )  ;  final  metrics file <  crosscheck metric  comparable <  ?  >  >  metrics output = new  metrics file <  >  (  )  ;  metrics output . read ( new  file reader ( metrics )  )  ;   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . data   type  =  =  expected type )  )  ;   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . lod   score   normal   tumor  !  =  null )  )  ;   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . lod   score  !  =  null )  )  ;   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . lod   score   tumor   normal  !  =  null )  )  ;  if  ( expect all match )   {   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . result  =  =   crosscheck metric .  fingerprint result . inconclusive || m . result . is match (  )   =  =  m . left   sample . equals ( m . right   sample )  )  )  ;   }  else if  ( expected ret val  =  =  0 )   {   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >  m . result  =  =   crosscheck metric .  fingerprint result . inconclusive || m . result . is expected (  )  )  )  ;   }  else  {   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . any match ( m  -  >   ! m . result . is expected (  )  )  )  ;   }   assert . assert equals ( metrics output . get metrics (  )  . size (  )  expectedn metrics )  ;  if  (  ! metrics output . get metrics (  )  . is empty (  )  && expected type  !  =   crosscheck metric .  data type . readgroup )   {   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . any match ( m  -  >  m . result  !  =   crosscheck metric .  fingerprint result . inconclusive )  )  ;   }  for  (  final  string field name : lookup map . get ( expected type )  )   {  final  field field =  crosscheck metric . class . get field ( field name )  ;   assert . assert true ( metrics output . get metrics (  )  . stream (  )  . all match ( m  -  >   {  try  {  return field . get ( m )   !  =  multiple values string && field . get ( m )   !  =  null ;   }  catch  (   illegal access exception e )   {  e . print stack trace (  )  ;  return false ;   }   }   )  )  ;   }   }  
public  audio format   (  )  {  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( "get audio format" )  ;   }  return this . audio format ;   }  
@ override public  string   (  )  {  return "http: /  / jabber . org / protocol / admin#get - online - users - num" ;   }  
@ test public final void   (  )  throws  interrupted exception  {  final  scheduler scheduler = get scheduler (  )  ;  final  atomic integer count = new  atomic integer (  )  ;   flowable <  integer >  o1 =  flowable .  <  integer > just ( 1 2 3 4 5 )  ; 
@ override public  group   (  string group name )  throws  group not found exception  {   ldap context ctx = null ;  try  {   string groupdn = manager . find groupdn ( group name )  ;  ctx = manager . get context ( manager . get groups basedn ( group name
public  field element   (  )  {  return qm5d8 ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish subject . create (  )  . single or error (  )  . hide (  )  )  ;   }  
@ override public void   (  throwable e )  {  inner error ( this e )  ;   }  
public  string   (  )  {  return get state variable data (  )  . get value (  )  ;   }  
public void   (  user request request )  {  this . request = request ;   }  
public void   (  name name )  {  this . name = name ;   }  
public void   ( int port )  {     port = port ;   }  
public long   (  )  {  return total msg read . get (  )  ;   }  
private  string   (  string xsl path )  {  return  ! xsl path . contains ( ": /  / " )   ?   string utils . join ( "file: /  / " config root " / " xsl path )  : xsl path ;   }  
@ test ( expected exceptions =  illegal state exception . class )  public void   (  )  {  final  test mergeable metric illegal illegal1 = new  test mergeable metric illegal (  )   illegal2 = new  test mergeable metric illegal (  )  ;  illegal1 . merge ( i
public void   ( final int lane )  {  this . lane = lane ;   }  
public  integer   ( final  string column label )  {  if  ( fields[column label indices . get ( column label ) ]  =  =  null )  return null ;  return  integer . parse int ( fields[column label indices . get ( column label ) ] )  ;   }  
protected int   (  )  {  return lane ;   }  
public  skip span < k v >    ( k key int[] search )  {  if  ( n keys  =  =  0 )   {  search[0] =  - 1 ;  return this ;   }  if  ( keys[n keys  -  1] . compare to ( key )   <  0 )   {  if  ( next  =  =  null )   {  search[0] =  (  - 1 *  ( n keys  -  1 )  )   -  1 ;  return this ;   }  return next . get span ( key search )  ;   }  search[0] = binary search ( key )  ;  return this ;   }  
@ test public void   (  )  {   subscriber <  string >  w =  test helper . mock subscriber (  )  ;   publish processor <  string >  w1 =  publish processor . create (  )  ;   publish processor <  string >  w2 =  publish processor . create (  )  ;   publish
public  comment set   (  snark snark )  {   file com = comment file (    config dir snark . get info hash (  )  )  ;  if  ( com . exists (  )  )   {  try  {  return new  comment set ( com )  ;   }  catch  (  io exception ioe )   {  if  (    log . should log (  log . warn )  )     log . warn ( " comment load error" ioe )  ;   }   }  return null ;   }  
@ override public boolean   (  node child )  {  if  ( is child node ( child )  )   {  return true ;   }  for  (   node node : get nodes (  )  )   {  if  ( node . is descendant node ( child )  )   {  return true ;   }   }  return false ;   }  
@ override protected void   (  single observer <  ?  super  object >  observer )  {  observer . on subscribe (  disposables . empty (  )  )  ;  assert false (  (  (  disposable ) observer )  . is disposed (  )  )  ;  ts . dispose (  )  ;  assert true (  (
public  iterator <  offer >    (  workgroup result filter filter )  {  return filter . filter ( offers . iterator (  )  )  ;   }  
@ override public  string   (  string s )  {  return null ;   }  
public int   (  )  {  synchronized  ( this )   {  return packet list . size (  )  ;   }   }  
@ test public void   (  )  {  for  (   backpressure strategy m :  backpressure strategy . values (  )  )   {  final  throwable[] error =  { null }  ;   flowable . create ( new  flowable on subscribe <  integer >  (  )  {  @ override public void subscribe 
public  string   (  )  {  if  (    data  =  =  null )  return null ;  return  base32 . encode (    data )   +  " . b32 . i2p" ;   }  
@ override public void   ( t t )  {  if  ( done )   {  return ;   }  actual . on next ( t )  ;   }  
@ test public void   (  )  {  assert equals ( 0  flowable . empty (  )  . count (  )  . to flowable (  )  . filter ( new  predicate <  long >  (  )  {  @ override public boolean test (   long v )  {  return false ;   }   }   )  . to list (  )  . blocking 
@ deprecated public void   (  date expiration )  {  if  ( expiration  !  =  null )     expiration = expiration . get date (  )  ;  else    expiration = 0 ;   }  
public void   (  )  {   file config file = new  file ( get context (  )  . router (  )  . get config filename (  )  )  ;  if  ( should reread ( config file )  )   {  get context (  )  . router (  )  . read config (  )  ;     last read = get context (  )  . clock (  )  . now (  )  ;   log log = get context (  )  . log manager (  )  . get log (  read config job . class )  ;  if  ( log . should debug (  )  )  log . debug ( " reloaded "  +  config file )  ;   }  requeue ( delay )  ;   }  
public  tunnel pool settings   (  hash client )  {  return null ;   }  
@ override protected boolean   (  io session session  io buffer in  protocol decoder output out )  throws  exception  {  xml lightweight parser parser =  ( xml lightweight parser ) session . get attribute (  connection handler . xml   parser )  ;  parser 
@ test public void   (  )  {   observable <  integer >  o =  observable . just ( 1 )  . first element (  )  . to observable (  )  ;   observer <  integer >  observer =  test helper . mock observer (  )  ;  o . subscribe ( observer )  ;   in order in order
@ test public void   (  )  throws sql exception  {   handle handle = db rule . get shared handle (  )  ;  handle . configure (  tuple mappers . class c  -  >  c . set column ( 1 "integer value" )  . set column ( 2 "int value" )  . set column ( 3 "id" )  )
@ test public void   (  )  {   publish subject <  object >  s =  publish subject . create (  )  ;   subject <  object >  s1 = s . to serialized (  )  ;   subject <  object >  s2 = s1 . to serialized (  )  ;  assert same ( s1 s2 )  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;   flowable do after next test . this . values . add ( t )  ;   }  
public static boolean   (  string hostname )  {  boolean result = false ;  try  {  final  inet address host address = network   name   resolver . lookup name ( hostname )  ;  result = network   interface   provider . has interface for ( host address )  ;   }  catch  (   unknown host exception uhe )   {  log . error ( " unable to look up network host name .   reason: "  +  uhe . get message (  )  uhe )  ;   }  catch  (   socket exception socket exception )   {  log . error ( socket exception . get message (  )  socket exception )  ;   }  return result ;   }  
public double   (  string parameter name )  throws sql exception  {  return cstmt . get double ( parameter name )  ;   }  
public long   (  )  throws io exception  {  return file . length (  )  ;   }  
public void   ( int quantity )  {     quantity = quantity ;   }  
@ test public void   (  )  {   flowable <  integer >  observable =  flowable . just ( 1 3 5 7 9 7 5 3 1 )  ;  observable . filter ( is   even )  . take ( 1 )  . subscribe ( w )  ;  verify ( w never (  )  )  . on next ( any int (  )  )  ;  verify ( w times
@ override public void   (  )  throws io exception  {   log . trace ( " data can be written to ["  +  remote address  +  "]" )  ;   servlet output stream servlet output stream = context . get response (  )  . get output stream (  )  ;  while  ( servlet ou
@ test ( timeout = 5000 )  public void   (  )  throws  exception  {   list <  flowable <  integer >  >  source list = new  array list <  flowable <  integer >  >  ( 3 )  ;  source list . add (  flowable . range ( 0 100000 )  . subscribe on (  schedulers .
@ override public  content values   (  )  {   content values values = new  content values (  )  ;  values . put (  account columns . display   name m display name )  ;  values . put (  account columns . email   address m email address )  ;  values . put (
@ override public void   (  )  {  if  ( m username view  !  =  null )   {  m username view . remove text changed listener ( m validation text watcher )  ;   }  m username view = null ;  m server label view = null ;  if  ( m server view  !  =  null )   {  
@ test @ ignore ( "subscribe (  )  can't throw" )  public void   (  )  {  perform test using with observable factory error in on subscribe ( true )  ;   }  
@ override public void   (  )  {  if  ( acceptor  !  =  null )  acceptor . halt (  )  ;  if  ( trackerclient  !  =  null )  trackerclient . halt ( true )  ;  if  ( coordinator  !  =  null )  coordinator . halt (  )  ;  if  ( storage  !  =  null )   {  try
@ test public void   (  )  throws  exception  {  handle . register argument ( new  name argument factory (  )  )  ;  handle . create query ( select   by   name )  . bind by type ( "name"  optional . of ( new  name ( "eric" )  )  new  generic type <  optio
public  dispatcher info   (  workgroup workgroup long queueid )  throws  not found exception  {   basic dispatcher info user info = null ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( load   dispatcher   by   id )  ;  pstmt . set long ( 1 queueid )  ;  rs = pstmt . execute query (  )  ;  if  (  ! rs . next (  )  )   {  throw new  not found exception (  )  ;   }  user info = new  basic dispatcher info ( workgroup queueid rs . get string ( 1 )  rs . get string ( 2 )  rs . get int ( 3 )  rs . get int ( 4 )  )  ;   }  catch  (  sql exception e )   {  throw new  not found exception ( " failed to read dispatcher "  +  queueid  +  " from database .  " +  e . get message (  )  )  ;   }  catch  (   number format exception nfe )   {   log . error ( "warning:  there was an error parsing the dates "  +  "returned from the database .   ensure that they're being stored "  +  "correctly . " )  ;  throw new  not found exception ( " dispatcher with id "  +  queueid  +  " could not be loaded from the database . " )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return user info ;   }  
@ override public void   (  )  {  throw new  test exception ( "dispose" )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ test public void   (  )  throws io exception  {  final  file output file =  file . create temp file ( "test" " . oxo   g   metrics" test   data   dir )  ;  output file . delete on exit (  )  ;  final  string[] args = new  string[] { "input = "  +  sam  
public void   (  source dest type source type )  {  this . source type = source type ;   }  
public void   (  string name )  {  deletion marks . add last (  data helper . striphtml ( name )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   flowable . error ( new  test exception (  )  )  . on error resume next ( new  function <  throwable  publisher <  object >  >  (  )  {  @ override public  publisher <  object >
protected int   (  )  {  try  {  input url = new url ( input )  ;   }  catch  (  java . net .  malformedurl exception e )   {  input file = new  file ( input )  ;   }  if  ( output  =  =  null )   {  final  string base file name ;  if  ( input url  !  =  null )   {  final  string path = input url . get path (  )  ;  final int last slash = path . last index of ( ' / ' )  ;  base file name = path . substring ( last slash  +  1 path . length (  )  )  ;   }  else  {  base file name = input file . get absolute path (  )  ;   }  if  ( base file name . ends with (  bam file io utils . bam   file   extension )  )   {  final int index = base file name . last index of ( ' . ' )  ;  output = new  file ( base file name . substring ( 0 index )   +  bam index . bam index suffix )  ;   }  else  {  output = new  file ( base file name  +  bam index . bam index suffix )  ;   }   }  io util . assert file is writable ( output )  ;  final  sam reader bam ;  if  ( input url  !  =  null )   {  bam =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . disable (  sam reader factory .  option . eagerly   decode )  . enable (  sam reader factory .  option . include   source   in   records )  . open (  sam input resource . of ( input url )  )  ;   }  else  {  io util . assert file is readable ( input file )  ;  bam =  sam reader factory . make default (  )  . reference sequence ( reference   sequence )  . enable (  sam reader factory .  option . include   source   in   records )  . open ( input file )  ;   }  if  ( bam . type (  )   !  =   sam reader .  type . bam   type )   {  throw new sam exception ( " input file must be bam file  not sam file . " )  ;   }  if  (  ! bam . get file header (  )  . get sort order (  )  . equals ( sam file header .  sort order . coordinate )  )   {  throw new sam exception ( " input bam file must be sorted by coordinate" )  ;   }  bam indexer . create index ( bam output )  ;  log . info ( " successfully wrote bam index file "  +  output )  ;   closer util . close ( bam )  ;  return 0 ;   }  
@ override protected  runnable   ( i2p app context ctx i2p session session )  {  return new  client runner ( ctx session )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  publish processor . create (  )  . single element (  )  . on error return item ( 1 )  )  ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . subscribe ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer e )  {   }   }   new  consumer <  throwable >  (  )  {  @ override public void
@ test public void   (  )  {  for  ( int i = 0 ;  i  <  100 ;  i +  +  )   {   list <  flowable <  string >  >  os = new  array list <  flowable <  string >  >  (  )  ;  os . add (  flowable . just ( "one" "two" "three" "four" "five" )  . subscribe on (  
public boolean   (  )  {  return    may disconnect ;   }  
@ override public  summing meter factory   (  string name )  {  return new  summing meter factory ( metric registry name ( name prefix name )  summing meter supplier )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  open =  publish subject . create (  )  ;  final  publish subject <  integer >  close =  publish subject . create (  )  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  subject <  integer >  s =  publish subject .  <  integer > create (  )  . to serialized (  )  ;   test observer <  integer >  to = s . t
@ test public void   (  )  throws  exception  {  final  file input sam = new  file ( "testdata / picard / sam / viewsam   intervals   test . sam" )  ;  final  file input intervals file = new  file ( "testdata / picard / sam / viewsam   intervals   test . 
public boolean   (  )  {  if  ( anonymous  =  =  null )   {  anonymous = username  =  =  null ||  !  user manager . get instance (  )  . is registered user ( username )  ;   }  return anonymous ;   }  
@ override public void   (  )  {  done = true ;  drain (  )  ;   }  
public  string   (  )  {  return "jabber:x:data" ;   }  
@ override public  set <  string >    (  properties options )  {   set <  string >  rv = new  hash set <  string >  (  )  ;  for  (   naming service ns :    services )   {  rv . add all ( ns . get names ( options )  )  ;   }  return rv ;   }  
public void   (  )  {  last seen =  clock . get instance (  )  . now (  )  ;  fails = 0 ;   }  
@ test public void   (  )  throws  exception  {   signing public key public key = new  signing public key (  )  ;  byte data[] = new byte[ signing public key . keysize   bytes] ;  for  ( int i = 0 ;  i  <  data . length ;  i +  +  )  data[i] =  ( byte )  
public  string   (  )  {  return resource ;   }  
public  string   (  )  {  return proxy ;   }  
@ override public  string   (  )  {  return " parsed sql { "  +  "sql = '"  +  sql  +  '\'' +  "  parameters = " +  parameters +  ' } ' ;   }  
@ test public void   (  )  {   string before = "ou =  jive  software\\   inc dc = support dc = jive dc = com" ;   string after = "ou = \" jive  software   inc\" dc = \"support\" dc = \"jive\" dc = \"com\"" ;   string converted =  ldap manager . get enclos
@ check return value @ backpressure support (  backpressure kind . pass   through )  @ scheduler support (  scheduler support . none )  public final  flowable < t >    (  long consumer on request )  {  return do on lifecycle (  functions . empty consumer 
@ override public long   (  )  {  return cache . get max cache size (  )  ;   }  
@ override public void   (  )  {  list . add ( 100 )  ;   }  
public int   (  )  {  int size = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( select   size   all   offline )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  size = rs . get int ( 1 )  ;   }   }  catch  (   exception e )   {   log . error (  locale utils . get localized string ( "admin . error" )  e )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return size ;   }  
public static  in exporter   ( boolean xep227 support )  {  if  ( xep227 support )   {  return new  xep227 exporter (  )  ;   }  else  {  return new  openfire exporter (  )  ;   }   }  
public  string[]   (  )  {   string[] themes ;  if  (    context . is router context (  )  )   {   file dir = new  file (    context . get base dir (  )  "docs / themes / snark" )  ;   file filter file filter = new  file filter (  )  {  public boolean accept (   file file )  {  return file . is directory (  )  ;   }   }   ;   file[] dirnames = dir . list files ( file filter )  ;  if  ( dirnames  !  =  null )   {  themes = new  string[dirnames . length] ;  for  ( int i = 0 ;  i  <  dirnames . length ;  i +  +  )   {  themes[i] = dirnames[i] . get name (  )  ;   }   }  else  {  themes = new  string[0] ;   }   }  else  {  themes = new  string[] { "classic" "dark" "light" "midnight" "ubergine" "vanilla" }  ;   }  return themes ;   }  
@ override public  string   (  )  {  return "x form field impl "  +   integer . to hex string ( hash code (  )  )   +  " " +  get variable (  )  +  " > " +  values +  " o: " +   ( options . is empty (  )   ?  "no options" : options . to string (  )  )  ; 
public muc transport session < b >    (  string roomname )  throws  not found exception  {  muc transport session < b >  session = active sessions . get ( roomname . to lower case (  )  )  ;  if  ( session  =  =  null )   {  throw new  not found exception ( " could not find session requested . " )  ;   }  return session ;   }  
@ test @ ignore ( "s should be considered cancelled upon executing on error and not expect downstream to call cancel" )  public void   (  )  throws  interrupted exception  {  final  subscription s = mock (  subscription . class )  ;   flowable <  string >
@ override public void   (  observable emitter <  boolean >  emitter )  throws  exception  {  emitter . on next (  thread . interrupted (  )  )  ;  emitter . on complete (  )  ;   }  
public void   (  string my address )  {  this . my address = my address ;   }  
@ test ( data provider = "  testcases" )  public void test scatter ( final  interval list scatterer test .  testcase tc )  throws io exception  {  final  file il out dir = io util . create temp dir ( " interval list tools" "lists" )  ;  dirs to delete . a
@ test public void   (  )  {  final  atomic long request = new  atomic long (  )  ;  try  {   flowable . empty (  )  . do on request ( new  long consumer (  )  {  @ override public void accept (  long n )  {  request . add and get ( n )  ;   }   }   )  . 
@ override public void   (  observer <  ?  super  integer >  sub )  {  sub . on subscribe (  disposables . empty (  )  )  ;  counter . increment and get (  )  ;  sub . on next ( 1 )  ;  sub . on next ( 2 )  ;  sub . on complete (  )  ;   }  
private void   (  )  {  base64mode = false ;  bits read = 0 ;  temp char = 0 ;   }  
public  node   (  )  {  return argument node ;   }  
public int   (  )  {  return  ( int )  ( max time  /   jive constants . minute )  ;   }  
@ test ( timeout = 10000 )  public void   (  )  throws  interrupted exception  {  final  replay subject <  object >  rs =  replay subject . create (  )  ;  final  cyclic barrier cb = new  cyclic barrier ( 2 )  ;   thread t = new  thread ( new  runnable ( 
@ test public void   (  )  {  assert true ( resource pool . use ( new  resource context <  target  boolean >  (  )  {  @ override public  boolean perform (   target resource )  {  return true ;   }   }   )  )  ;   }  
@ override public void   (  string username  string password )  throws  user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
public static boolean   (  file ks  string kspw  string alias  string cname  set <  string >  alt names  string ou int valid days  string key alg int key size  string keypw )  {  boolean use keytool = i2p app context . get global context (  )  . get boolean property ( "crypto . use external keytool" )  ;  if  ( use keytool )   {  if  ( alt names  !  =  null )  throw new  illegal argument exception ( "can't do san in keytool" )  ;  return create keyscli ( ks kspw alias cname ou valid days key alg key size keypw )  ;   }  else  {  try  {  create keys andcrl ( ks kspw alias cname alt names ou valid days key alg key size keypw )  ;  return true ;   }  catch  (   general security exception gse )   {  error ( " create keys error" gse )  ;  return false ;   }  catch  (  io exception ioe )   {  error ( " create keys error" ioe )  ;  return false ;   }   }   }  
public boolean   (  )  {  return namespace  !  =  null ;   }  
@ test public void   (  )  throws  exception  {   router identity ident = new  router identity (  )  ;  assert false ( ident . equals ( null )  )  ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  observable < t >    (  consumer <  ?  super  disposable >  on subscribe )  {  return do on lifecycle ( on subscribe  functions . empty   action )  ;   }  
@ test public void   (  )  {   observable <  observable <  string >  >  source =  observable . unsafe create ( new  observable source <  observable <  string >  >  (  )  {  @ override public void subscribe (   observer <  ?  super  observable <  string > 
public  collection <  string >    (  )  {   collection <  group >  groups =  group manager . get instance (  )  . get groups (  )  ;   collection <  string >  group names = new  array list <  string >  (  )  ;  for  (   group group : groups )   {  group names . add ( group . get name (  )  )  ;   }  return group names ;   }  
@ test public void   (  )  {   set <  string >  one = new  hash set (  )  ;  one . add ( "abc" )  ;   set <  string >  two = new  hash set (  )  ;  two . add ( "abc" )  ;  assert true (  set utilities . null safe equals ( one two )  )  ;   }  
public boolean   (  )  {  return  jive globals . get boolean property ( "xmpp . proxy . transfer . required" true )  ;   }  
public void   (  integer first index )  {  this . first index = first index ;   }  
public void   ( int progress )  {  m shared preferences . edit (  )  . put int ( one   time   initialization   progress progress )  . apply (  )  ;   }  
public  boolean   (  )  {  return auto accept suggestions ;   }  
protected final sam message sess   (  )  {  return raw session ;   }  
private static boolean   (  string content encoding )  {  return no   encoding . equals ( content encoding )  || factory   map . contains key ( content encoding )  ;   }  
@ test ( timeout = 4000 )  public void   (  )  throws  interrupted exception  {  final  replay processor <  long >  replay =  replay processor . create (  )  ;   thread source = new  thread ( new  runnable (  )  {  @ override public void run (  )  {   flo
@ test public void   (  )  {   flowable <  integer >  source =  flowable . range ( 50 100 )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 0l )  ;  ts . request ( 150 )  ;  source . subscribe ( ts )  ;   list <  integer >  li
@ override public  string   (  )  {   string builder sb = new  string builder ( " protocol: " )  ;  sb . append ( protocol )  ;  sb . append ( "  " )  ;  sb . append ( klass  !  =  null  ?  " local" : " remote" )  ;  sb . append ( "    account  type: " ) 
@ test ( timeout = 5000 expected =  test exception . class )  public void   (  )  {  error . completable . to single ( new  callable <  object >  (  )  {  @ override public  object call (  )  {  return 1 ;   }   }   )  . blocking get (  )  ;   }  
@ override public boolean   (  throwable e )  throws  exception  {  return true ;   }  
public int   (  )  {   local map stats stats = map . get local map stats (  )  ;  return  ( int )  ( stats . get owned entry memory cost (  )   +  stats . get backup entry memory cost (  )  )  ;   }  
public long   (  )  {  return heartbeat ;   }  
@ override public void   (  )  {  pp . on complete (  )  ;   }  
public void   (  string data )  {  set content ( data true )  ;   }  
public static  console update manager   (  )  {   client app manager cmgr = i2p app context . get global context (  )  . client app manager (  )  ;  if  ( cmgr  =  =  null )  return null ;  return  (  console update manager ) cmgr . get registered app ( app   name )  ;   }  
public void   ( int local sessions )  {  this . local sessions = local sessions ;   }  
@ override public void   ( t t )  {  if  ( not skipping )   {  actual . on next ( t )  ;   }  else  {  boolean b ;  try  {  b = predicate . test ( t )  ;   }  catch  (   throwable e )   {   exceptions . throw if fatal ( e )  ;  s . dispose (  )  ;  actual
boolean   (  hash peer )  {  for  (   transport t :    transports . values (  )  )   {  if  ( t . is established ( peer )  )  return true ;   }  return false ;   }  
public boolean   (  )  {  return    should processdsrm ;   }  
@ test public void   (  )  {  assert equals ( date instance . get next available time (  )  )  ;   }  
private static  string   ( final  class <  ?  >  type )  {  return "argument must be one of the following:  iterable  or an array / varargs  ( primitive or complex type )  ;  was "  +  type . get name (  )   +  " instead" ;   }  
@ override public  service client response   (  string base uri  string extra uri  map <  string  string >  headers  string conn pool id )  {  return get (  string uri utilities . append path ( base uri extra uri )  headers conn pool id )  ;   }  
@ override public  list <  router address >    (  )  {   list <  router address >  addresses = new  array list <  router address >  (    manager . get addresses (  )  )  ;  if  (    log . should log (  log . info )  )     log . info ( " creating addresses
@ override public boolean   (  )  {  return get (  )   =  =  0 ;   }  
@ test public void   (  )  {   flowable <  flowable <  integer >  >  source =  flowable . range ( 1 10 )  . window ( 3 )  ;  final  list <  integer >  list = new  array list <  integer >  (  )  ;  final  subscriber <  integer >  o =  test helper . mock su
@ override public  shared preferences   (  string name int mode )  {  return new  mock shared preferences (  )  ;   }  
public  array list <  string >    (  )  {  return registrars ;   }  
@ override public  bundle   (  account authenticator response response  string account type  string auth token type  string[] required features  bundle options )  throws  network error exception  {  if  ( options  !  =  null && options . contains key ( op
public boolean   (  )  {  return is distributed bridge ;   }  
private int   ( y lab thisy lab )  {  double scaledrange = this . get scaled range (  )  ;  return  ( int )  ( im . ysize  /   ( scaledrange  /  thisy lab . grid )  )  ;   }  
public  list <  string >    (  string page )  {   string config ;  if  ( "home" . equals ( page )  )   {  config =    context . get property ( prop   summarybar  +  page is advanced (  )   ?  default   minimal   advanced : default   minimal )  ;   }  else  {  config =    context . get property ( prop   summarybar  +  page )  ;  if  ( config  =  =  null )  config =    context . get property ( prop   summarybar  +  "default" is advanced (  )   ?  default   full   advanced : default   full )  ;   }  return  arrays . as list (  data helper . split ( config ss )  )  ;   }  
@ override public void   (  )  {  if  ( windows . decrement and get (  )   =  =  0 )   {   subscription helper . cancel ( upstream )  ;   }   }  
public  string   (  )  {  return public host ;   }  
@ override public void   (  )  {  p . on error ( ex )  ;   }  
@ test public void   (  )  {   observable . just ( 1 2 3 )  . last element (  )  ;   }  
public static  queued tasks manager   (  )  {  return instance ;   }  
public  tunnel id   ( int hop )  {  return    config[hop] . get send tunnel (  )  ;   }  
@ test @ ignore ( " null values no longer allowed" )  public void   (  )  {   flowable <  string >  src =  flowable . just ( "a" "b" null "c" )  ;  src . distinct ( to   upper   with   exception )  . subscribe ( w )  ;   in order in order = in order ( w )
@ non null public  list <  throwable >    (  )  {  return exceptions ;   }  
@ override public  socket address   (  )  {  return new i2p socket address (    socket . get this destination (  )     socket . get local port (  )  )  ;   }  
public  collection <  group >    (  )  {   collection <  string >  group names =  (  collection <  string >  ) group meta cache . get ( public   groups )  ;  if  ( group names  =  =  null )   {  synchronized  ( public   groups . intern (  )  )   {  group names =  (  collection <  string >  ) group meta cache . get ( public   groups )  ;  if  ( group names  =  =  null )   {  group names = provider . get public shared group names (  )  ;  group meta cache . put ( public   groups group names )  ;   }   }   }  return new  group collection ( group names )  ;   }  
@ test public void   (  )  {   test observer <  boolean >  to = new  test observer <  boolean >  (  )  ;  final  illegal argument exception ex = new  illegal argument exception (  )  ;   observable . just ( " boo ! " )  . all ( new  predicate <  string > 
public byte[]   (  )  {  return bitfield ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock transport = open and inject mock transport (  )  ;  mock transport . expect ( null " - err from the  mock  transport . " )  ;  try  {   pop3 store .  pop3 folder folder = m store . new  pop3 folder ( "inbox" )  ;  folder . open (  open mode . read   write )  ;  fail ( " should have thrown exception" )  ;   }  catch  (   messaging exception me )   {   }  mock transport . expect ( "quit" "" )  ;  mock transport . expect close (  )  ;  setup open folder ( mock transport 0 "uidl" )  ;  mock transport . expect ( "quit" "" )  ;  m store . check settings (  )  ;   }  
@ test public void   (  )  throws sql exception  {   tuple4 <  integer  string  integer  integer >  result = db rule . get shared handle (  )  . create query ( "select * from something where id  =  2" )  . map to ( new  generic type <  tuple4 <  integer  
@ override public void   (  )  {  m pending operations . remove ( this )  ;  m actual rannable . run (  )  ;   }  
public  presence   ( jid sender address jid targetjid boolean is subscribe )  {   presence presence = new  presence (  )  ;  presence . set from ( sender address )  ;  presence . set to ( targetjid )  ;  if  ( is subscribe )   {  presence . set type (  presence .  type . subscribe )  ;   }  else  {  presence . set type (  presence .  type . unsubscribe )  ;   }  return presence ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   observable . from iterable (  arrays . as list ( 1 2 3 )  )  . take ( 1 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   intege
public void   (  user entity user entity )  throws  service exception  {  if  ( user entity  !  =  null &&  ! user entity . get username (  )  . is empty (  )  )   {  if  ( user entity . get password (  )   =  =  null )   {  throw new  service exception ( " could not create new user  because password is null" user entity . get username (  )  " password is null"  response .  status . bad   request )  ;   }  try  {  user manager . create user ( user entity . get username (  )  user entity . get password (  )  user entity . get name (  )  user entity . get email (  )  )  ;   }  catch  (   user already exists exception e )   {  throw new  service exception ( " could not create new user" user entity . get username (  )   exception type . user   already   exists   exception  response .  status . conflict )  ;   }  add properties ( user entity . get username (  )  user entity . get properties (  )  )  ;   }  else  {  throw new  service exception ( " could not create new user" "users"  exception type . illegal   argument   exception  response .  status . bad   request )  ;   }   }  
private static  string   ( final  string name final  string def )  {  return  system . get property ( "picard . cmdline . "  +  name def )  ;   }  
@ override public void   ( boolean persistent )  {  this . persistent = persistent ;   }  
@ override public  open mode   (  )  {  return m mode ;   }  
private  naming service   (  )  {   naming service root =    context . naming service (  )  ;   naming service rv = search naming service ( root get file name (  )  )  ;  return rv  !  =  null  ?  rv : root ;   }  
private  user info   (  string username boolean recurse )  throws  unsupported operation exception   user not found exception  {  if  (  ! is scram supported (  )  )   {  throw new  unsupported operation exception (  )  ;   }   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( test   password )  ;  pstmt . set string ( 1 username )  ;  rs = pstmt . execute query (  )  ;  if  (  ! rs . next (  )  )   {  throw new  user not found exception ( username )  ;   }   user info user info = new  user info (  )  ;  user info . plain text = rs . get string ( 1 )  ;  user info . encrypted = rs . get string ( 2 )  ;  user info . iterations = rs . get int ( 3 )  ;  user info . salt = rs . get string ( 4 )  ;  user info . stored key = rs . get string ( 5 )  ;  user info . server key = rs . get string ( 6 )  ;  if  ( user info . encrypted  !  =  null )   {  try  {  user info . plain text =  auth factory . decrypt password ( user info . encrypted )  ;   }  catch  (   unsupported operation exception uoe )   {   }   }  if  (  ! recurse )   {  if  ( user info . plain text  !  =  null )   {  boolean scram only =  jive globals . get boolean property ( "user . scram hashed password only" )  ;  if  ( scram only || user info . salt  =  =  null )   {  set password ( username user info . plain text )  ;  return get user info ( username true )  ;   }   }   }  return user info ;   }  catch  (  sql exception sqle )   {   log . error ( " user sql failure:" sqle )  ;  throw new  user not found exception ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . on backpressure drop ( null )  ;   }  
@ xml element public  string   (  )  {  return description ;   }  
@ test public void   (  )  throws  exception  {  when ( request . get input stream (  )  )  . then return ( new  servlet input stream wrapper ( new  byte array input stream ( new byte[] {  }  )  )  )  ;   argument captor <  input stream entity >  request 
public  collection <  group >    (  )  {  return  collections . unmodifiable collection ( get group objects (  )  )  ;   }  
@ override public  string   (  )  {  return get version string (  )  ;   }  
@ test public void   (  )  {   test helper . check disposed maybe ( new  function <  maybe <  object >   maybe <  object >  >  (  )  {  @ override public  maybe <  object >  apply (   maybe <  object >  m )  throws  exception  {  return m . of type (  obj
void   ( int interval )  {  csecs delay = interval ;   }  
public long   (  )  {  return    last changed ;   }  
private  fingerprint id details   ( final  path sam file final sam record rec )  {  final  picard exception e = new  picard exception ( " found read with no readgroup: "  +  rec . get read name (  )   +  " in file: " +  sam file )  ;  if  ( validation stringency  !  =   validation stringency . strict )   {  final sam read group record read group record = new sam read group record ( " < unknown > :::"  +  sam file . to uri (  )  . to string (  )  )  ;  read group record . set library ( " < unknown > " )  ;  read group record . set sample ( " < unknown > " )  ;  read group record . set platform unit ( " < unknown >  . 0 . zzz" )  ;  if  ( validation stringency  =  =   validation stringency . lenient )   {  log . warn ( e )  ;  log . warn ( "further messages from this file will be suppressed" )  ;   }  return new  fingerprint id details ( read group record sam file . to uri (  )  . to string (  )  )  ;   }  else  {  log . error ( e )  ;  throw e ;   }   }  
@ override public void   (  )  {  parent . inner complete (  )  ;   }  
public long   (  )  {  return    last failed send ;   }  
public void   (  string moo )  {     config . set reject user agents ( true )  ;   }  
public  local client session   (  connection conn  streamid id  locale language )  {  if  ( server name  =  =  null )   {  throw new  illegal state exception ( " server not initialized" )  ;   }   local client session session = new  local client session ( server name conn id language )  ;  conn . init ( session )  ;  conn . register close listener ( client session listener session )  ;  local session manager . get pre authenticated sessions (  )  . put ( session . get address (  )  . get resource (  )  session )  ;  connections counter . increment and get (  )  ;  return session ;   }  
public  long   (  )  {  return before ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . just ( "cc" "cc" "eee" "eee" )  ;   function <  integer  collection <  string >  >  collection factory = new  function <  integer  collection <  string >  >  (  )  {  @ override
public  string   (  )  {  return  jive globals . get property ( "plugin . email . listener . password" )  ;   }  
@ override public void   (  )  {  try  {  process packets (  )  ;   }  catch  (   throwable e )   {   log . error (  locale utils . get localized string ( "admin . error" )  e )  ;   }   }  
@ test public void   (  )  {   behavior subject <  string >  subject =  behavior subject . create default ( "default" )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  subject . subscribe ( observer )  ;  subject . on next ( "o
public static  < t >  consumer < t >    ( final  list < t >  list )  {  return new  consumer < t >  (  )  {  @ override public void accept (  t t )  {  list . add ( t )  ;   }   }   ;   }  
@ test ( timeout = 5000 )  public void   (  )  {   completable c = error . completable . do on error ( new  consumer <  throwable >  (  )  {  @ override public void accept (   throwable e )  {  throw new  illegal state exception (  )  ;   }   }   )  ;  tr
@ override public void   (  subscriber <  ?  super  integer >  o )  {  o . on subscribe ( new  boolean subscription (  )  )  ;  for  ( int i = 0 ;  i  <   flowable . buffer size (  )   +  10 ;  i +  +  )   {  o . on next ( i )  ;   }  latch . count down (
@ override public void   (  string username  string password )  throws  user not found exception   unsupported operation exception  {  if  ( primary overrides . contains ( username . to lower case (  )  )  )   {  primary provider . set password ( username
@get @ path ( " { id :  . * } " )  public  response   ( @ context  http servlet request request )  {  return provider . get end service ( request )  ;   }  
@ test ( timeout = 30000 )  public void   (  )  {  long t =  system . current time millis (  )  ;  for  ( int i = 2 ;  i  <  50 ;  i +  +  )   {  if  (  system . current time millis (  )   -  t  >   time unit . seconds . to millis ( 9 )  )   {  break ;   
@ test public void   (  )  {   observable <  string >  o =  observable . from iterable (  arrays .  <  string > as list ( "one" "two" "three" )  )  ;   observer <  string >  observer =  test helper . mock observer (  )  ;  o . subscribe ( observer )  ;  v
@ before public void   (  )  throws  exception  {  datastore = mock (  datastore . class )  ;  rate limit cache = new  managed rate limit cache ( datastore )  ;  default config . set uri ( " . *" )  ;  default config . set uri regex ( " . *" )  ;  default
public boolean   (  )  {  return man . is discover ( getman (  )  )  ;   }  
public void   (  join confirmation listener listener )  {  synchronized  ( join confirmation listeners )   {  join confirmation listeners . add ( listener )  ;   }   }  
public void   (  collection <  string >  rooms archived )  {  this . rooms archived = rooms archived ;   jive globals . set property ( "conversation . rooms archived"  string utils . collection to string ( rooms archived )  )  ;   }  
public  hash   (  )  {  if  (       calculated hash  !  =  null )  return       calculated hash ;  byte ident bytes[] ;  try  {   byte array output stream baos = new  byte array output stream ( 400 )  ;  write bytes ( baos )  ;  ident bytes = baos . to byte array (  )  ;   }  catch  (  io exception ioe )   {  throw new  illegal state exception ( "kac hash error" ioe )  ;   }  catch  (   data format exception dfe )   {  throw new  illegal state exception ( "kac hash error" dfe )  ;   }        calculated hash = sha256 generator . get instance (  )  . calculate hash ( ident bytes )  ;  return       calculated hash ;   }  
@ override public  sql array types   (  )  {  return new  sql array types ( this )  ;   }  
@ test public void   (  )  {  s2 . on next ( "a" )  ;  s1 . on error ( new  runtime exception ( " forced failure" )  )  ;  in order . verify ( observer times ( 1 )  )  . on error ( any (  runtime exception . class )  )  ;  s2 . on next ( "b" )  ;  s1 . on
@ override public boolean   (  )  {   context context = get context (  )  ;   email content . init ( context )  ;  init ( context )  ;   debug utils . init ( context )  ;  set services enabled async ( context )  ;  reconcile accounts async ( context )  ; 
public void   (  )  throws  exception  {   locale saved locale =  locale . get default (  )  ;  try  {   locale . set default (  locale . us )  ;  check get date or null on different locales (  )  ;   locale . set default (  locale . japan )  ;  check get date or null on different locales (  )  ;   }  finally  {   locale . set default ( saved locale )  ;   }   }  
public boolean   (  )  {  return  jive globals . get boolean property ( "xmpp . pep . enabled" true )  ;   }  
public int   (  )  {  sample threads (  )  ;  return states . get (  thread .  state . timed   waiting )  ;   }  
public  response   (  service exception exception )  {   error response error response = new  error response (  )  ;  error response . set resource ( exception . get resource (  )  )  ;  error response . set message ( exception . get message (  )  )  ;  error response . set exception ( exception . get exception (  )  )  ;  log . error ( exception . get exception (  )   +  ": "  +  exception . get message (  )  +  " with resource " +  exception . get resource (  )  exception . get exception (  )  )  ;  return  response . status ( exception . get status (  )  )  . entity ( error response )  . type (  media type . application   xml )  . build (  )  ;   }  
@ override public void   (  disposable d )  {  if  (  disposable helper . validate ( this . d d )  )   {  this . d = d ;  actual . on subscribe ( this )  ;   }   }  
@ visible for testing static void   (  hash map <  string  imap folder >  mailboxes )  {   set <  string >  pathnames = mailboxes . key set (  )  ;  for  (   string path : pathnames )   {  final  imap folder folder = mailboxes . get ( path )  ;  final  ma
private iq   ( iq packet jid from  string list name )  {  iq result = iq . create resultiq ( packet )  ;   element child element = packet . get child element (  )  . create copy (  )  ;  result . set child element ( child element )  ;   privacy list list = manager . get privacy list ( from . get node (  )  list name )  ;  if  ( list  !  =  null )   {   client session session = session manager . get session ( from )  ;  if  ( session  !  =  null )   {  session . set active list ( list )  ;   }   }  else  {  result . set error (  packet error .  condition . item   not   found )  ;   }  return result ;   }  
private boolean   (  )  {  return  !  (    context . router (  )  . is hidden (  )  ||  (    transport . isi pv4 firewalled (  )  &&    transport . isi pv6 firewalled (  )  )  )  ;   }  
@ override public  string   (  )  {  return "gzfb "  +     file ;   }  
@ override protected void   (  input stream in int size )  throws i2cp message exception  io exception  {  try  {  for  ( int i = 0 ;  i  <  limits ;  i +  +  )   {  data[i] =  ( int )  data helper . read long ( in 4 )  ;   }   }  catch  (   data format e
public boolean   (  )  {  return    is inbound ;   }  
public void   (  )  throws  exception  {   byte array output stream out = new  byte array output stream (  )  ;  i2p client client = i2p client factory . create client (  )  ;   destination d = client . create destination ( out )  ;  i2p session session = client . create session ( new  byte array input stream ( out . to byte array (  )  )  null )  ;  dsa engine dsa eng = dsa engine . get instance (  )  ;   byte array output stream dout = new  byte array output stream (  )  ;  d . write bytes ( dout )  ;  dsa eng . sign (  hash . fake   hash . to byte array (  )  session . get private key (  )  )  . write bytes ( dout )  ;  dout . write (  data helper . getascii ( "blah" )  )  ;  byte[] data = dout . to byte array (  )  ;  i2p datagram dissector dd = new i2p datagram dissector (  )  ;  dd . loadi2p datagram ( data )  ;  boolean error = false ;  try  {  dd . get payload (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;  error = false ;  try  {  dd . get sender (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;  error = false ;  try  {  dd . get hash (  )  ;   }  catch  (  i2p invalid datagram exception i2pide )   {  error = true ;   }  assert true ( error )  ;   }  
protected  object pool <  transformer >    (  )  {  return xslt resource pool ;   }  
public static  message controller   (  )  {  return instance ;   }  
@ small test public void   (  )  throws  exception  {  final  file directory = new  isolated context ( new  mock content resolver (  )  get context (  )  )  . get files dir (  )  ;  final  file created1 =  utility . create unique file internal ( get count
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  maybe < t >    (  function <  ?  super  throwable  ?  extends  maybe source <  ?  extends t >  >  resume function )  {   object helper . require non null ( resume functi
@ override public void   ( int max cache size )  {  this . max cache size = max cache size ;   cache factory . set max size property ( name max cache size )  ;  cull cache (  )  ;   }  
@ test public void   (  )  {   subscriber <  string >  w =  test helper . mock subscriber (  )  ;   publish processor <  string >  w1 =  publish processor . create (  )  ;   publish processor <  string >  w2 =  publish processor . create (  )  ;   publish
@ test public void   (  )  {  final  atomic integer count = new  atomic integer (  )  ;  final int    multiple = 99 ;   flowable . range ( 1 100000 )  . map ( new  function <  integer  integer >  (  )  {  @ override public  integer apply (   integer t1 ) 
public static  delivery instructions   ( byte[] data int offset )  throws  data format exception  {  if  ( data[offset]  =  =  0 )  return local ;   delivery instructions rv = new  delivery instructions (  )  ;  rv . read bytes ( data offset )  ;  return rv ;   }  
protected  string   (  )  {   string builder buf = new  string builder (  )  ;  buf . append ( '[' )  ;  buf . append (    state . to string (  )  )  . append ( ' ' )  ;   string s =    options . get property ( "inbound . nickname" )  ;  if  ( s  !  =  null )  buf . append ( s )  ;  else buf . append ( get class (  )  . get simple name (  )  )  ;   session id id =    session id ;  if  ( id  !  =  null )  buf . append ( " #" )  . append ( id . get session id (  )  )  ;  buf . append ( "]: " )  ;  return buf . to string (  )  ;   }  
public int   (  )  {  if  (  ! is initialized )  throw new  illegal argument exception ( "not initialized" )  ;  return meta size ;   }  
public static void   ( int type int block size )  {  if  ( managers . contains key ( type )  )   {  managers . get ( type )  . block size = block size ;   }  else  {  new  sequence manager ( type block size )  ;   }   }  
@ override public  loader <  cursor >    ( final int id final  bundle args )  {  return new  cursor loader (  account setup final . this  mail app provider . get accounts uri (  )  new  string[] { ui provider .  account columns . account   manager   name 
private static void   (  external component configuration configuration )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( add   configuration )  ;  pstmt . set string ( 1 configuration . get subdomain (  )   +   ( configuration . is wildcard (  )   ?  "%" : "" )  )  ;  pstmt . set int ( 2 configuration . is wildcard (  )   ?  1 : 0 )  ;  pstmt . set string ( 3 configuration . get secret (  )  )  ;  pstmt . set string ( 4 configuration . get permission (  )  . to string (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public void   (  string user name  string password )  {  if  (    should proxy )   {  if  (    auth state  !  =  null )  throw new  illegal state exception (  )  ;     auth state = new  auth state ( user name password )  ;   }   }  
@ override public  node   (  string nodeid )  {  return nodes . get ( nodeid )  ;   }  
@ test public void   (  )  {  final  header value first = new  header value impl ( "" 0 . 8 )   second = new  header value impl ( "" 0 . 2 )  ;  assert equals ( " matching quality factors and values must return 0" 0 first . compare to ( first )  )  ;  ass
@ test public void   (  )  {   flowable <  integer >  o1 =  flowable . just ( 1 2 3 )  ;   flowable <  integer >  o2 =  flowable . just ( 4 5 6 )  ;  final  atomic boolean completed = new  atomic boolean ( false )  ;  o1 . concat with ( o2 )  . subscribe 
public sam record   ( final int i )  {  if  ( i  >  =  second of pair . size (  )  )   {  return null ;   }  else  {  return second of pair . get ( i )  ;   }   }  
@ test public void   (  )  {   observer <  string >  observer =  test helper . mock observer (  )  ;  final  string[] o =  { "1" "3" "5" "7" }  ;  final  string[] e =  { "2" "4" "6" }  ;  final  observable <  string >  odds =  observable . from array ( o 
public  result   (  )  {  return result ;   }  
public void   (  long value[] )  {     extension = value ;   }  
public  handle   (  statement builder builder )  {  this . statement builder = builder ;  return this ;   }  
public  icon   (  string uri )  {   icon list icon list = get icon list (  )  ;  if  ( icon list . size (  )   <  =  0 )  return null ;  int n icon = icon list . size (  )  ;  for  ( int n = 0 ;  n  <  n icon ;  n +  +  )   {   icon icon = icon list . get icon ( n )  ;  if  ( icon . isurl ( uri )  )  return icon ;   }  return null ;   }  
@ test public void   (  )  {  int num =  ( int )  (  flowable . buffer size (  )  * 2 . 1 )  ;   atomic integer c = new  atomic integer (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  incrementing integers ( c )  .
 session id   (  hash h )  {   session params sp =    sessions . get ( h )  ;  if  ( sp  =  =  null )  return null ;  return sp . session id ;   }  
private static  input stream   (  string resource name )  {   file file = new  file (  jive globals . get home directory (  )   +   file . separator  +  "resources" +   file . separator +  "spank" +   file . separator +  "scripts" resource name )  ;  try  {  return new  file input stream ( file )  ;   }  catch  (   file not found exception e )   {  return null ;   }   }  
@ test ( timeout = 3000 )  public void   (  )  {  final  list <  integer >  concat base = new  array list <  integer >  (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;   flowable . just ( 1 2 )  . repeat ( 5 )  . co
public  string   (  )  {  return    config filename ;   }  
@ deprecated public  list <  server identities provider >    (  )  {   list <  server identities provider >  answer = new  array list <  >  (  )  ;  for  (   module module : modules . values (  )  )   {  if  ( module instanceof  server identities provider
  (  function <  ?  super k  ?  extends  collection <  ?  super v >  >  collection factory  function <  ?  super t  ?  extends v >  value selector  function <  ?  super t  ?  extends k >  key selector )  {  this . collection factory = collection factory ;  this . value selector = value selector ;  this . key selector = key selector ;   }  
@ override public void   ( int size )  {  max file size = size ;  auditor . set max values ( max total size max file size max days )  ;   jive globals . set property ( "xmpp . audit . filesize"  integer . to string ( size )  )  ;   }  
private void   (  )  {   log utils . i (  logging . log   tag " system accounts updated . " )  ;  reconcile and start services (  )  ;   notification action utils . resend notifications ( get application context (  )  null null )  ;   }  
public void   ( int inter arrival jitter )  {  rtcp data[20] =  ( byte )  (  ( inter arrival jitter  >  >  24 )  & 0xff )  ;  rtcp data[21] =  ( byte )  (  ( inter arrival jitter  >  >  16 )  & 0xff )  ;  rtcp data[22] =  ( byte )  (  ( inter arrival jitter  >  >  8 )  & 0xff )  ;  rtcp data[23] =  ( byte )  ( inter arrival jitter & 0xff )  ;   }  
private  lease set   ( boolean force )  {   lease set newls = get context (  )  . net db (  )  . lookup lease set locally (    from . calculate hash (  )  )  ;  if  ( newls  =  =  null )  return null ;   lease set ls =    cache . lease set cache . put (    hash pair newls )  ;  if  (  ! force )   {  if  ( ls  !  =  null )   {  if  ( ls . equals ( newls )  )   {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  found in cache  -  not including reply leaseset for "  +     to string )  ;  return null ;   }  else  {  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  expired from cache  -  reply leaseset for "  +     to string )  ;   }   }   }  if  (    log . should log (  log . info )  )     log . info ( get job id (  )   +  ":  added to cache  -  reply leaseset for "  +     to string )  ;  return newls ;   }  
@ override public void   (  flowable emitter <  object >  s )  throws  exception  {  for  ( int i = 0 ;  i  <  10 ;  i +  +  )   {  s . on next ( i )  ;   }   }  
public  file   (  string sequence )  throws  exception  {  final  string[] ref flat fields = new  string[ ref flat columns . values (  )  . length] ;  ref flat fields[ ref flat columns . gene   name . ordinal (  ) ] = "my gene" ;  ref flat fields[ ref flat columns . transcript   name . ordinal (  ) ] = "my transcript" ;  ref flat fields[ ref flat columns . chromosome . ordinal (  ) ] = sequence ;  ref flat fields[ ref flat columns . strand . ordinal (  ) ] = " + " ;  ref flat fields[ ref flat columns . tx   start . ordinal (  ) ] = "49" ;  ref flat fields[ ref flat columns . tx   end . ordinal (  ) ] = "500" ;  ref flat fields[ ref flat columns . cds   start . ordinal (  ) ] = "74" ;  ref flat fields[ ref flat columns . cds   end . ordinal (  ) ] = "400" ;  ref flat fields[ ref flat columns . exon   count . ordinal (  ) ] = "2" ;  ref flat fields[ ref flat columns . exon   starts . ordinal (  ) ] = "49 249" ;  ref flat fields[ ref flat columns . exon   ends . ordinal (  ) ] = "200 500" ;  final  file ref flat file =  file . create temp file ( "tmp . " " . ref flat" )  ;  ref flat file . delete on exit (  )  ;  final  print stream ref flat stream = new  print stream ( ref flat file )  ;  ref flat stream . println (  string util . join ( "\t" ref flat fields )  )  ;  ref flat stream . close (  )  ;  return ref flat file ;   }  
protected static  list <  string >    (  )  {  final  list <  string >  package list = new  array list <  string >  (  )  ;  package list . add ( "picard" )  ;  return package list ;   }  
void   ( boolean send item subscribe )  {  this . send item subscribe = send item subscribe ;   }  
@ xml element public  string   (  )  {  return password ;   }  
public void   (  )  {   string security sync key = "key" ;   account account =  provider test utils . setup account ( "acct" true m mock context )  ;  assert equals ( 0 account . m policy key )  ;  assert equals ( 0  email content . count ( m mock context  policy . content   uri )  )  ;   policy policy = new  policy (  )  ;   security policy . set account policy ( m mock context account policy security sync key )  ;  account . refresh ( m mock context )  ;  assert true ( account . m policy key  >  0 )  ;   policy db policy =  policy . restore policy with id ( m mock context account . m policy key )  ;  assert not null ( db policy )  ;  assert equals ( policy db policy )  ;  assert equals ( security sync key account . m security sync key )  ;   security policy . clear account policy ( m mock context account )  ;  account . refresh ( m mock context )  ;  assert equals ( 0 account . m policy key )  ;  assert equals ( 0  email content . count ( m mock context  policy . content   uri )  )  ;  account . refresh ( m mock context )  ;  assert null ( account . m security sync key )  ;   }  
@ test public void   (  )  {   observable <  integer >  o =  observable . from array ( 1 3 5 6 )  ;   observable <  boolean >  any even = o . any ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer i )  {  return i % 2  =  =
@ override public  cursor window   (  )  {  return  (  (  cross process cursor ) m cursor )  . get window (  )  ;   }  
public void   (  string value )  {  version = value ;   }  
@ override public void   (  integer integer )  {  request ( 1 )  ;   }  
@ override public  throwable   (  )  {  return subscribers . get (  )   =  =  terminated  ?  error : null ;   }  
@ nullable public static  language data   (  context context @ nullable  string language code )  {  if  (  text utils . is empty ( language code )  )   {  language code =  display settings . get shows language ( context )  ;   }   string[] language codes 
public long   (  )  {  long when =  - 1 ;  for  (   job queue runner runner :    queue runners . values (  )  )   {  long cur = runner . get last end (  )  ;  if  ( cur  >  when )  cur = when ;   }  return when ;   }  
@ override public  transport   (  )  {  return real one . get transport (  )  ;   }  
@ override public  map serializer < k v >    (  )  {  return serializer ;   }  
protected  < a extends  enum < a >  >  enum path < a >    (  string property  class < a >  type )  {  return add ( new  enum path < a >  ( type for property ( property )  )  )  ;   }  
private boolean   ( int value int flag )  {  return  ( value & flag )   !  =  0 ;   }  
private boolean   (  )  {  final  connection manager impl connection manager =  (  (  connection manager impl ) xmpp server . get instance (  )  . get connection manager (  )  )  ;  final  connection configuration configuration = connection manager . get listener (  connection type . bosh   c2s true )  . generate connection configuration (  )  ;  return configuration . get compression policy (  )   =  =  null || configuration . get compression policy (  )  . equals (  connection .  compression policy . optional )  ;   }  
private static boolean   (  tree statement  lambda expression tree lambda tree )  {  return statement . is (  tree .  kind . return   statement )  && is method invocation (  (  (  return statement tree ) statement )  . expression (  )  lambda tree )  ;   }  
public void   (  string naming strategy class )  {  this . naming strategy class = naming strategy class ;   }  
@ override public void   (  class <  ?  extends  event listener >  a class )  {  proxy . add listener ( a class )  ;   }  
@ override public  collection <  string >    (  )  {  return await ( factory . new get counter names operation (  )  . execute (  )  )  ;   }  
 optional <  string >    (  )  {  return  optional . of ( "" )  ;   }  
@ test public void   (  )  {   observable . timer ( 100  time unit . milliseconds scheduler )  . subscribe ( observer )  ;  scheduler . advance time by ( 100  time unit . milliseconds )  ;  verify ( observer times ( 1 )  )  . on next ( 0l )  ;  verify ( o
public  string   (  )  {  return local ;   }  
@ override public  object   (  invocation context ctx  read only key command command )  throws  throwable  {  if  (  ! ctx . is origin local (  )  || command . has any flag (  flag bit sets . skip   statistics )  )  return invoke next ( ctx command )  ;  
public  multipart request handler   (  )  {  return multipart request handler ;   }  
static  set <  router address >    ( int num )  {   set <  router address >  addresses = new  hash set <  router address >  (  )  ;   router address addr = createtcp address ( num )  ;  if  ( addr  !  =  null )  addresses . add ( addr )  ;  return addresses ;   }  
@ test public void   (  )  {  byte[] zero =  utils . hex to bytes ( "0000000000000000000000000000000000000000000000000000000000000000" )  ;  byte[] one =  utils . hex to bytes ( "0100000000000000000000000000000000000000000000000000000000000000" )  ;  byte
public void   ( @ nullable  annotation annotation )  {  if  ( annotation  !  =  null )   {  annotations . put ( annotation . annotation type (  )  annotation )  ;   }   }  
public  collection <  string >    (  )  {   list <  string >  rv = new  array list <  string >  ( to delete )  ;  return rv ;   }  
@ override public  tls details   (  )  {  return session . get tls details (  )  ;   }  
@ override public boolean   (  global transaction global transaction )  {  return false ;   }  
public void   (  out net message msg )  {  if  (  !    queued messages . contains ( msg )  )     queued messages . offer ( msg )  ;  else if  (    log . should log (  log . warn )  )     log . warn ( "attempt to add duplicate msg to queue: "  +  msg )  ;   }  
@ test public void   (  )  {   java check verifier . verify ( "src / test / files / checks /  silly bit operation check . java" new  silly bit operation check (  )  )  ;   }  
@ test public void   (  )  {   publish subject <  integer >  source =  publish subject . create (  )  ;   publish subject <  integer >  until =  publish subject . create (  )  ;   test observer <  integer >  to = new  test observer <  integer >  (  )  ;  
private boolean   (  operations factory of )  throws  exception  {   field field = null ;  try  {  field =  operations factory . class . get declared field ( "force return value" )  ;   }  catch  (   no such field exception e )   {  throw new  exception ( " could not access force return value field" e )  ;   }  field . set accessible ( true )  ;  boolean field value = false ;  try  {  field value = field . get boolean ( of )  ;   }  catch  (   illegal access exception e )   {  throw new  exception ( " could not access force return value field" e )  ;   }  return field value ;   }  
@ test public void   (  )  throws  exception  {  final  classic http request req 1  = new  basic classic http request ( "get" " / " )  ;  origin response . set header ( " cache -  control" "max - age =  3  6 00" )  ;  origin response . set header ( "e tag
@ override public boolean   (  search work creator context context )  {  return true ;   }  
@ managed operation ( description = "k - th percentile of remote read - only transactions execution time" display name = "k - th  percentile  remote  read -  only  transactions" )  public double   ( @ parameter ( name = "percentile" )  int percentile )  {
public  binding   (  )  {  return binding ;   }  
@ override public  set <  service name >    (  )  {  return this . target . get dependencies (  )  ;   }  
@ test public void   (  )  {   single <  boolean >  observable =  flowable . sequence equal (  flowable . just ( "one" "two" "three" )   flowable . concat (  flowable . just ( "one" )   flowable .  <  string > error ( new  test exception (  )  )  )  )  ; 
public boolean   (  )  {  return this . variable   names  !  =  null ;   }  
public void   (  string style class )  {  this . style class = style class ;   }  
@ override public  cache event filter <  integer  string >    ( final  object[] params )  {  return new  static cache event filter (  )  ;   }  
public int   (  )  {  return topology id ;   }  
@ override public void   (  tree tree )  {   symbol sym ;   arguments args ;   tree method name ;  if  ( tree . is (  tree .  kind . new   class )  )   {   new class tree nct =  (  new class tree ) tree ;  sym = nct . constructor symbol (  )  ;  args = nc
public void   (  )  throws  execution exception   interrupted exception  {  take site offline (  )  ;  final  object key = new  magic key ( cache ( nyc  1  )  )  ;  final  discard handler handler =  discard handler . replace on ( cache ( nyc  1  )  )  ;  final  counter backup receiver repository counter repository =  counter backup receiver repository . replace on ( cache ( nyc 0 )  . get cache manager (  )  )  ;  cache ( lon 0 )  . put ( key value )  ;  start state transfer (  )  ;  assert online ( lon nyc )  ;  eventually (  (  )   -  >  handler . discarded )  ;  trigger topology change ( nyc  1  )  . get (  )  ;  awaitx site state sent ( lon )  ;  assert eventually no state transfer in receiving site ( null )  ;  assert equals (  1  counter repository . counter . get (  )  )  ;  assert in site ( nyc cache  -  >  assert equals ( value cache . get ( key )  )  )  ;   }  
public void   (  )  throws  interrupted exception  {  take site offline ( lon nyc )  ;  assert offline ( lon nyc )  ;  assert no state transfer in receiving site (  )  ;  assert no state transfer in sending site (  )  ;  final int amount of data = chunk size ( lon )  *  4  ;  for  ( int i = 0 ;  i  <  amount of data ;   +  + i )   {  cache ( lon 0 )  . put ( key ( i )  value ( i )  )  ;   }  assert in site ( nyc cache  -  >  assert true ( cache . is empty (  )  )  )  ;  assert in site ( nyc cache  -  >  assert true ( cache . is empty (  )  )  )  ;  start state transfer ( lon nyc )  ;  eventually (  (  )   -  >  extract component ( cache ( lon 0 )  x site admin operations . class )  . get running state transfer (  )  . is empty (  )   time unit . seconds . to millis (  3 0 )  )  ;  assert online ( lon nyc )  ;  assert in site ( nyc cache  -  >   {  for  ( int i = 0 ;  i  <  amount of data ;   +  + i )   {  assert equals ( value ( i )  cache . get ( key ( i )  )  )  ;   }   }   )  ;  assert in site ( nyc cache  -  >   {  for  ( int i = 0 ;  i  <  amount of data ;   +  + i )   {  assert equals ( value ( i )  cache . get ( key ( i )  )  )  ;   }   }   )  ;  assert no state transfer in receiving site (  )  ;  assert no state transfer in sending site (  )  ;   }  
public static void   (  offline message listener listener )  {  listeners . remove ( listener )  ;   }  
public void   (  string hash )  {  photo hash = hash ;   }  
@ test ( expected =  malformed cookie exception . class )  public void   (  )  throws  exception  {  final  basic client cookie cookie = new  basic client cookie ( "name" "value" )  ;  final  cookie attribute handler h = new  lax expires handler (  )  ;  
public  cache mode   (  )  {  switch  ( this )   {  case repl   sync: return repl   async ;  case invalidation   sync: return invalidation   async ;  case dist   sync: return dist   async ;  case scattered   sync: throw new  illegal argument exception ( " scattered mode does not have asynchronous mode . " )  ;  default : return this ;   }   }  
@ test public void   (  )  {   weakssl context check check = new  weakssl context check (  )  ;   string filename = "src / test / files / checks /  weakssl context check . java" ;   java check verifier . verify ( filename check )  ;   java check verifier 
public  object   (  object session  object key )  throws  cache exception  {  if  (  ! check valid (  )  )   {  return null ;   }   object result = null ;   map map = transaction context . get ( session )  ;  if  ( map  !  =  null )   {  result = map . get ( key )  ;   }  if  ( result  =  =  null )   {  result = get cache . get ( key )  ;   }  return result ;   }  
@ check for null private static  type tree   (  tree expression  tree .  kind[] kinds )  {  if  ( expression . is ( kinds )  )   {   type tree locator visitor = new  type tree locator ( kinds )  ;  expression . accept ( visitor )  ;  return visitor . type
@ test public void   (  )  throws  exception  {   multimap <  user  article >  joined =  hash multimap . create (  )  ;  h . create query ( "select * from user natural join author natural join article" )  . map (  join row mapper . for types (  user . cla
public  agent session   ( jid agentjid )  throws  agent not found exception  {  return get agent ( agentjid )  . get agent session (  )  ;   }  
private void   ( java . io .  object output stream out )  throws java . io . io exception  {  try  {  write ( new org . apache . thrift . protocol . t compact protocol ( new org . apache . thrift . transport . tio stream transport ( out )  )  )  ;   }  catch  (  org . apache . thrift . t exception te )   {  throw new java . io . io exception ( te )  ;   }   }  
private  color   (  color color )  {  return new  color ( color . getrgb (  )  ^ 0x00ffffff )  ;   }  
@ non null protected  recycler view .  view holder   (  view group view group  item click listener item click listener )  {   view v =  layout inflater . from ( view group . get context (  )  )  . inflate ( r . layout . item   history view group false )  
public int   ( jid jid )  {  int message count = 0 ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( user   message   count )  ;  pstmt . set string ( 1 jid . to barejid (  )  )  ;  pstmt . set string ( 2 jid . get node (  )  )  ;  rs = pstmt . execute query (  )  ;  if  ( rs . next (  )  )   {  message count = rs . get int ( 1 )  ;   }   }  catch  (  sql exception sqle )   {  log . error ( sqle . get message (  )  sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return message count ;   }  
@ override public byte   (  )  {  return command   id ;   }  
@ override public void   (  tree tree )  {   assignment expression tree ae tree =  (  assignment expression tree ) tree ;   syntax token operator token = ae tree . operator token (  )  ;   syntax token expression first token = ae tree . expression (  )  .
private static boolean   (  type type )  {  return type . is subtype of ( "java . io .  serializable" )  ;   }  
@ override public  object   (  tx invocation context ctx  prepare command cmd )  throws  throwable  {  try  {  return invoke next interceptor ( ctx cmd )  ;   }  finally  {  if  (  ! ctx . is origin local (  )  || watch local )   {  log command ( cmd )  ;
@ deprecated private static iv validator   (  )  {  return new  hash setiv validator (  )  ;   }  
public void   (  )  throws  exception  {  test (  read after lost data test::put map true true )  ;   }  
public void   (  signature sig )  {  set flag ( flag   signature   included sig  !  =  null )  ;     option signature = sig ;   }  
@ test public void   (  )  throws  exception  {   program state program state = execute ( new  instruction (  opcodes . iconst   0 )  )  ;  assert stack ( program state new  constraint[][] {  {  division by zero check .  zero constraint . zero  boolean co
@ override public void   (  char stream input stream )  {  throw new  unsupported operation exception (  )  ;   }  
public void   (  byte buffer key  column path column   path long timestamp  consistency level consistency   level )  throws  invalid request exception   unavailable exception   timed out exception  {  if  ( start session if requested (  )  )   {   map <  string  string >  trace parameters =  immutable map . of ( "key"  byte buffer util . bytes to hex ( key )  "column   path" column   path . to string (  )  "timestamp" timestamp  +  "" "consistency   level" consistency   level . name (  )  )  ;   tracing . instance . begin ( "remove" trace parameters )  ;   }  else  {  logger . debug ( "remove" )  ;   }  try  {  internal   remove ( key column   path timestamp consistency   level false )  ;   }  catch  (   request validation exception e )   {  throw  thrift conversion . to thrift ( e )  ;   }  finally  {   tracing . instance . stop session (  )  ;   }   }  
boolean   (  inner subscriber < t u >  inner )  {  for  (  ;   ;   )   {   inner subscriber <  ?   ?  > [] a = subscribers . get (  )  ;  if  ( a  =  =  cancelled )   {  inner . dispose (  )  ;  return false ;   }  int n = a . length ;   inner subscriber <  ?   ?  > [] b = new  inner subscriber[n  +  1] ;   system . arraycopy ( a 0 b 0 n )  ;  b[n] = inner ;  if  ( subscribers . compare and set ( a b )  )   {  return true ;   }   }   }  
public void   (  string exception )  {  this . exception = exception ;   }  
public  message out <  range slice command >    (  )  {  return new  message out <  >  (  messaging service .  verb . range   slice this serializer )  ;   }  
public double   (  )  throws io exception  {  double d = source . read double (  )  ;  bytes read +  =  8  ;  return d ;   }  
@ test ( data provider = "data test haplotype probabilities from contaminator sequence add to probs" )  public void   ( final  haplotype probabilities from contaminator sequence hp final  snp snp final int n alt final int n total )  throws  exception  {  
public static boolean   (  context context long current time )  {  long previous update time =  preference manager . get default shared preferences ( context )  . get long ( key   last   full   episode   sync current time )  ;  return  ( current time  -  previous update time )   >  full   sync   interval   millis ;   }  
@ override public  integer   (  )  {  return  ids . admin   flag ;   }  
@ test public void   (  )  throws  exception  {  with tx ( tm (  )  new  callable <  void >  (  )  {  @ override public  void call (  )  throws  exception  {  cache . remove ( " 1 " )  ;   query query = create query builder (  )  . keyword (  )  . on fiel
public void   (  view v )  {  add header view ( v null true )  ;   }  
public static  string   (  string lang code  string dflt i2p app context ctx )  {  return  translate . get display language ( lang code dflt ctx bundle   name )  ;   }  
@ check return value @ scheduler support (  scheduler support . none )  public final  single <  boolean >    (  )  {  return  rx java plugins . on assembly ( new  maybe is empty single < t >  ( this )  )  ;   }  
private  string   (  string shard id )  {  return index name . substring ( 0 index name . last index of ( ' . ' )   +   1  )   +  shard id ;   }  
@ deployment ( name = joining   node managed = false )  @ targets container ( joining   node )  public static  web archive   (  )  {  return  deployments . create node auth krb test deployment ( joining   node   jgrousp   config   krb )  ;   }  
@ override @ before method public void   (  )  throws  throwable  {  super . create before method (  )  ;  this . ro =  read only map impl . create ( fmapd 1  )  ;  this . sro =  read only map impl . create ( fmaps 1  )  ;  this . lro =  read only map imp
@ test public void   (  )  {   observable <  long >  w =  observable . interval ( 1  time unit . seconds scheduler )  ;   test observer <  long >  to1 = new  test observer <  long >  (  )  ;  w . subscribe ( to1 )  ;  to1 . assert no errors (  )  ;  sched
@ nullable @ override public  offset time   (  result set rs int start index )  throws sql exception  {   time time = rs . get time ( start index utc (  )  )  ;  return time  !  =  null  ?   offset time . of instant (  instant . of epoch milli ( time . ge
@ override public  string   (  )  {   string builder b = new  string builder (  )  ;  b . append ( " metadata collection impl { " )  ;  b . append ( "version = " )  ;  b . append ( version )  ;  b . append ( "  created = " )  ;  b . append ( created )  ; 
public void   (  )  {   configuration builder c = new  configuration builder (  )  ;  c . memory (  )  . storage type (  storage type . binary )  ;   configuration builder builder = new  configuration builder (  )  . read ( c . build (  )  )  ;   configuration clone = builder . build (  )  ;  assert equals (  storage type . binary clone . memory (  )  . storage type (  )  )  ;   }  
@ test public void   (  )  throws  exception  {   search manager search manager =  search . get search manager ( cache )  ;  cache . put (  1  2  3  4 0 5  new  bond ( new  date (  system . current time millis (  )  )   4  5 0l )  )  ;  assert efficient i
public void   (  )  throws  system exception   not supported exception  {  for  ( int i =  1  ;  i  <  size ;   +  + i )   {  cache ( 0 )  . put ( i i )  ;   }  assert interceptor count (  )  ;   transaction manager tm = cache ( 0 )  . get advanced cache (  )  . get transaction manager (  )  ;  tm . begin (  )  ;  cache ( 0 )  . put ( 0 0 )  ;  tm . rollback (  )  ;  assert interceptor count (  )  ;  assert null ( cache ( 0 )  . get ( 0 )  )  ;  cache ( 0 )  . put ( size  +   1  size  +   1  )  ;  assert interceptor count (  )  ;  try  {  cache ( 0 )  . put (  -  1   -  1  )  ;  fail ( " should have thrown an exception ! " )  ;   }  catch  (   throwable t )   {   exceptions . assert exception (  container full exception . class get most nested suppressed throwable ( t )  )  ;   }  assert interceptor count (  )  ;   }  
void   (  )  {   string param = null ;  if  (  !  string utils . is blank ( param )  )   {  param . to string (  )  ;   }   }  
@ override public  string   (  )  {  return " read write snapshot view { "  +  "key = "  +  key  +  "  value = " +  value +  "  metadata = " +  metadata +  ' } ' ;   }  
private void   ( jid workgroupjid  key enum key  chat settings .  setting type type final  string value )  {   chat setting setting = new  chat setting ( key )  ;  setting . set workgroup node ( workgroupjid . get node (  )  )  ;  setting . set type ( type )  ;  setting . set value ( value )  ;  setting . set default value ( "" )  ;   string label = label map . get ( key )  ;  if  (  !  model util . has length ( label )  )   {  label = "" ;   }   string description = descriptions . get ( label )  ;  if  (  !  model util . has length ( description )  )   {  description = descriptions . get ( key . to string (  )  )  ;   }  if  (  !  model util . has length ( description )  )   {  description = "" ;   }  setting . set description ( description )  ;  setting . set label ( label )  ;  chat settings manager . add chat setting ( setting )  ;   }  
public void   (  boolean archiving enabled )  {  this . archiving enabled = archiving enabled ;   }  
public  string   (  )  {  return  jive globals . get property ( recaptcha   private   key )  ;   }  
protected  cache stream < r >    ( boolean parallel )  {   closeable spliterator < r >  closeable spliterator = spliterator (  )  ;   cache stream < r >  stream = new  local cache stream <  >  ( supplier (  )  parallel cache . get advanced cache (  )  . get component registry (  )  )  ;  stream . on close ( closeable spliterator::close )  ;  return stream ;   }  
@ override public  string   (  )  {  return " global tx:"  +   objects . to string ( addr "local" )   +  ":" +  id ;   }  
public  list <  string >    (  )  {  return  lists . new array list ( result builder . to string (  )  . split ( eol )  )  ;   }  
@ override public void   (  object t )  {  bh . consume ( t )  ;   }  
@ override public  string   ( final int index )  {  return stream reader . get namespace prefix ( index )  ;   }  
private int   ( long mailbox id )  {  return  utility . get first row int ( m mock context  content uris . with appended id (  mailbox . content   uri mailbox id )  new  string[] {  mailbox columns . message   count }  null null null 0 )  ;   }  
public void   (  method m )  throws  interrupted exception  {  client (  )  . assert put ( m )  ;   test response resp = client (  )  . replace ( k ( m )  0  1  v ( m "v 1  - " )  )  ;  assert status ( resp  success )  ;   thread . sleep (  1  1 00 )  ;  assert key does not exist ( client (  )  . assert get ( m )  )  ;   }  
boolean   (  )  {  return  text utils . is empty ( m path separator )  &&  !  text utils . is empty ( m path prefix )  ;   }  
public  collection <  media proxy session >    (  )  {  return sessions . values (  )  ;   }  
public void   (  )  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . having ( "name" )  . gt ( "a" )  . and (  )  . having ( "name" )  . lte ( "a" )  . build (  )  ;   list <  user >  list = q . list (  )  ;  assert true ( list . is empty (  )  )  ;   }  
private static void   (  address origin  response response  map <  address  object >  values )  {  if  ( response  =  =   cache not found response . instance )   {  return ;   }  else if  (  ! response . is successful (  )  )   {   throwable cause = response instanceof  exception response  ?   (  (  exception response ) response )  . get exception (  )  : null ;  throw new  cache exception ( format ( " unsuccessful response received from node '%s': %s" origin response )  cause )  ;   }  values . put ( origin  (  (  successful response ) response )  . get response value (  )  )  ;   }  
public void   (  type type )  {  this . type = type ;   }  
public  rsp code   (  )  {  return code ;   }  
@ test public void   (  )  {  attributes . put ( " " "hello" )  ;  assert that thrown by (  (  )   -  >  template engine . render ( " { 0 }  bar" ctx )  )  . is instance of (  illegal argument exception . class )  . has message containing ( "\" \"" )  ;  
@ test public void   (  )  throws  exception  {  final os gi http route planner planner = new os gi http route planner ( singleton list ( pc 2  )  )  ;   http host proxy = planner . determine proxy ( new  http host ( " 1  2  .  3  4  .  3  4  .  2 "  4  5
private  string   (  )  {  return settings . get chat setting (  key enum . position   message )  . get value (  )  ;   }  
public  certificate store configuration   (  connection type type )  throws io exception  {  final  string key store type = get key store type ( type )  ;  final  string password = get identity store password ( type )  ;  final  string location = get identity store location ( type )  ;  final  file file = canonicalize ( location )  ;  return new  certificate store configuration ( key store type file password . to char array (  )  )  ;   }  
@ test public void   (  )  throws t exception  {   column parent cp = new  column parent ( " standard 1 " )  ;   byte buffer key =  byte buffer . wrap ( "overlap   reversed" . get bytes (  )  )  ;  add the alphabet to row ( key cp )  ;   multi slice reque
@ test public void   (  )  {   column mapper big integer mapper = new  column mapper big integer (  8  )  ;   string parsed = mapper . index value ( "test" " -  1 " )  ;   assert . assert equals ( "0 1 njchq" parsed )  ;   }  
private boolean   (  assignment expression tree tree )  {   expression tree variable = tree . variable (  )  ;  if  ( variable . is (  kind . member   select )  )   {   member select expression tree member select expression tree =  (  member select expression tree ) variable ;  if  (  ! is this ( member select expression tree . expression (  )  )  )   {  return false ;   }  variable = member select expression tree . identifier (  )  ;   }  if  ( variable . is (  kind . identifier )  )   {   symbol variable symbol =  (  (  identifier tree ) variable )  . symbol (  )  ;  return variable symbol . owner (  )  . is type symbol (  )  ;   }  return false ;   }  
public boolean   (     fields field )  {  if  ( field  =  =  null )   {  throw new  illegal argument exception (  )  ;   }  switch  ( field )   {  case key: return is set key (  )  ;  case count: return is set count (  )  ;   }  throw new  illegal state exception (  )  ;   }  
@ check for null private  constraints by domain   ( int index  list <  type >  invocation types )  {  if  (  ! behavior . is method var args (  )  || applicable on var args ( index invocation types )  )   {  return parameters constraints . get ( index )  
@ test public void   (  )  throws  exception  {  cache invalidator was called (  )  ;  request policy allows caching ( false )  ;  mock impl methods ( call   backend )  ;  impl expects any request and return ( mock backend response )  ;  request is fatall
@ override public  list <  string >    (  )  {  return options ;   }  
@ test ( expected =  client protocol exception . class )  public void   (  )  throws  exception  {  this . server . register handler ( "*" new  circular redirect service (  )  )  ;  final  http host target = start (  )  ;  final  request config config =  
@ test public void   (  )  throws  exception  {  final  string entity text = " hello  this is some plain text coming back . " ;  this . server . register handler ( "*" create deflate encoding request handler ( entity text true )  )  ;  final  http host ta
@ override public v   ( long timeout  time unit unit )  throws  interrupted exception   execution exception   timeout exception  {  set latch . await ( timeout unit )  ;  if  ( exception  !  =  null )  throw new  execution exception ( exception )  ;  retu
private  replicable command   (  object input input )  throws io exception  {  byte type = input . read byte (  )  ;  short method id = input . read short (  )  ;  return cmd factory . from stream (  ( byte ) method id type )  ;   }  
@ override public void   (  proto stream writer writer  phone number phone number )  throws io exception  {  writer . write string ( "number" phone number . get number (  )  )  ;   }  
@ override public int   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ override public boolean   (  java version version )  {  return version . is java 8  compatible (  )  ;   }  
public static  map <  string  string >    ( i2p app context ctx )  {   map <  string  string >  rv = new  hash map <  string  string >  (  )  ;   list <  string >  names = get plugins (  )  ;  for  (   string name : names )   {   properties props = plugin properties ( ctx name )  ;   string pubkey = props . get property ( "key" )  ;   string signer = props . get property ( "signer" )  ;  if  ( pubkey  !  =  null && signer  !  =  null && pubkey . length (  )   =  =  172 && signer . length (  )   >  0 )  rv . put ( pubkey signer )  ;   }  return rv ;   }  
public static  < d extends  comparable >  date expression < d >    (  date expression < d >  date int months )  {  return  expressions . date operation ( date . get type (  )   ops .  date time ops . add   months date  constant impl . create ( months )  )  ;   }  
public static  < t >  service controller < t >    (  service registry registry  service name name )  {  return  (  service controller < t >  ) registry . get required service ( name )  ;   }  
public boolean   (  )  {  return this . finish  !  =  null ;   }  
public  collection <  string >    (  )  {   collection <  group >  groups =  group manager . get instance (  )  . get groups (  )  ;   collection <  string >  group names = new  array list <  string >  (  )  ;  for  (   group group : groups )   {  group names . add ( group . get name (  )  )  ;   }  return group names ;   }  
public boolean   (  menu item item )  {  int item id = item . get item id (  )  ;  if  ( item id  =  =  android . r . id . home )   {  on back pressed (  )  ;  return true ;   }  if  ( item id  =  =  r . id . menu   action   help   open   browser )   {  open in browser (  )  ;  return true ;   }  if  ( item id  =  =  r . id . menu   action   help   send   feedback )   {  create feedback email (  )  ;   utils . track action ( this tag " feedback" )  ;  return true ;   }  return super . on options item selected ( item )  ;   }  
private j free chart   (  string title xy plot plot )  {  j free chart chart = new j free chart ( title j free chart . default   title   font plot false )  ;  chart . set background paint (  color . white )  ;  return chart ;   }  
public t resolved   (  )  throws  read timeout exception   digest mismatch exception  {  if  (  ! await ( command . get timeout (  )   time unit . milliseconds )  )   {   read timeout exception ex = new  read timeout exception ( consistency level received blockfor resolver . is data present (  )  )  ;  if  ( logger . is debug enabled (  )  )  logger . debug ( " read timeout:  {  } " ex . to string (  )  )  ;  throw ex ;   }  return blockfor  =  =   1   ?  resolver . get data (  )  : resolver . resolve (  )  ;   }  
private  optional <  destination >    (  optional <  repose cluster >  cluster )  {   optional <  destination >  dest =  optional . empty (  )  ;  if  ( cluster . is present (  )  )   {   list <  destination >  destinations = new  array list <  >  (  )  ;  destinations . add all ( cluster . get (  )  . get destinations (  )  . get endpoint (  )  )  ;  destinations . add all ( cluster . get (  )  . get destinations (  )  . get target (  )  )  ;  for  (   destination destination : destinations )   {  if  ( destination . is default (  )  )   {  dest =  optional . of ( destination )  ;   }   }   }  return dest ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {  just1 . do on terminate ( null )  ;   }  
public void   (  list <  group entity >  groups )  {  this . groups = groups ;   }  
@ override public v   (  object key )  {   versioned value < v >  versioned = get versioned (  ( k ) key )  ;  return versioned  !  =  null  ?  versioned . get value (  )  : null ;   }  
@ test public void   (  )  {   string test = "" ;   encryptor encryptor = new  aes encryptor (  )  ;   string b64 encrypted = encryptor . encrypt ( test )  ;  assert false ( test . equals ( b64 encrypted )  )  ;  assert equals ( test encryptor . decrypt (
@ override public void   (  shared preferences shared preferences  string key )  {  if  ( key . equals (  advanced settings . key   upcoming   limit )  )   {  get loader manager (  )  . restart loader (  shows activity . shows   loader   id null  shows fr
@ subscribe ( thread mode =  thread mode . main )  public void   (  extensions adapter .  extension disable request event event )  {  enabled names . remove ( event . position )  ;  save extensions (  )  ;   utils . track action ( get activity (  )  tag "
@ override public void   (  )  {  has unsure response = true ;   }  
protected  string   (  string prop )  {  if  (    context . get boolean property ( prop )  )  return checked ;  return "" ;   }  
@ test public void   (  )  {  final  group element t = new  group element ( curve  group element .  representation . p3 zero one one zero )  ;  assert that ( t . curve is ( equal to ( curve )  )  )  ;  assert that ( t . repr is (  group element .  represe
public boolean   (  )  {  return  ( presence . get type (  )   =  =  null && presence . get show (  )   !  =   presence .  show . dnd && presence . get show (  )   !  =   presence .  show . xa && presence . get show (  )   !  =   presence .  show . away )  ;   }  
@ override public  object[]   (  )  {  return args ;   }  
@ override public  object   (  invocation context ctx  read write key command command )  throws  throwable  {  return handle functional command ( ctx command )  ;   }  
public  string   (  )  {  return number ;   }  
@ override public  object   (  invocation context ctx  put key value command command )  throws  throwable  {  return handle ( ctx command  (  )   -  >  put failed = true )  ;   }  
void   (  disposable d )  {   disposable helper . replace ( this d )  ;   }  
@ test public void   (  )  {   domain type domain type =  alias . alias (  domain type . class )  ;  assert equals (  domain type . class  alias . get any ( domain type )  . get type (  )  )  ;  assert equals (  string . class  alias . get any ( domain ty
@ override @ cache put ( value = "books" key = "#book . id" cache manager = "cache manager" )  public  book   (  book book )  {  return base dao . create book ( book )  ;   }  
public void   (  document document  columns columns )  {  for  (   column column : columns )   {   string name = column . get name (  )  ;   column mapper column mapper = get mapper ( name )  ;  if  ( column mapper  !  =  null )   {  for  (   indexable field field : column mapper . fields ( column )  )   {  document . add ( field )  ;   }   }   }   }  
@ test public void   (  )  {  expect parser success ( "from example .  inner inn where inn . id . bkey is not null and inn . back out . id . master . id . sup . id . akey  >  'a'" )  ;   }  
@ override public boolean   (  )  throws  exception  {  return true ;   }  
public  string   (  )  {  return  ( this . command )  ;   }  
@ test public void   (  )  {   java check verifier . verify ( "src / test / files / checks /  fixme tag presence check . java" new  fixme tag presence check (  )  )  ;   }  
public void   (  string name )  throws  exception  {  ops . remove if exists (  address . subsystem ( "datagrid - infinispan - endpoint" )  . and ( "rest - connector" name )  )  ;   }  
private static void   ( byte[] payload int p )  {  payload[proto   byte] =  ( byte )  ( p & 0xff )  ;   }  
@ override public int[]   (  )  {  return get acceptable tokens (  )  ;   }  
public boolean   (  )  {  return    log server ;   }  
@ test public void   (  )  {   attribute definition <  properties >  def =  attribute definition . builder ( "props" null  properties . class )  . initializer ( new  attribute initializer <  properties >  (  )  {  @ override public  properties initialize 
public void   (  string s )  {  if  ( s  !  =  null && s . length (  )   >  0 )     new log class = s ;   }  
@ test public void   (  )  {  final  string key to filter out = "filter - me" ;  test expiration filter ( key to filter out  5 0l new  magic key ( cache (  1  cache   name )  cache (  2  cache   name )  )   1 000l new  key value filter as cache event filt
@ test public void   (  )  {   observable . range ( 1 2 )  . concat map eager ( new  function <  integer  observable <  integer >  >  (  )  {  @ override public  observable <  integer >  apply (   integer t )  {  return  observable . range ( 1 1000 )  . s
public  map <  address  response >    (  )  {  return response map ;   }  
public void   (  )  throws  exception  {   consistent hash mock old hash = mock (  consistent hash . class )  ;   consistent hash mock new hash = mock (  consistent hash . class )  ;   consistent hash mock union hash = mock (  consistent hash . class )  ;  cache 1  notifier . notify data rehashed ( mock old hash mock new hash mock union hash 0 true )  ;   observer assertion . assert that ( cache observer  cache 1  . class )  . has data rehash event ( mock new hash )  ;   }  
public void   (  object output out )  throws io exception  {  super . write external ( out )  ;   externalizable util . get instance (  )  . write serializable ( out address )  ;   }  
 throwable   (  throwable t )  {   throwable cause ;  while  (  ( cause = t . get cause (  )  )   !  =  null )   {  t = cause ;   }  return t ;   }  
private void   ( java . io .  object output stream out )  throws java . io . io exception  {  try  {  write ( new org . apache . thrift . protocol . t compact protocol ( new org . apache . thrift . transport . tio stream transport ( out )  )  )  ;   }  catch  (  org . apache . thrift . t exception te )   {  throw new java . io . io exception ( te )  ;   }   }  
public  closeable   (  string my file )  {  return new  file input stream ( my file )  ;   }  
@ override public final void   ( boolean removed )  {  set flag ( removed removed )  ;   }  
public void   (  )  {  add metadata ( first name  column metadata . named ( "first   name" )  )  ;  add metadata ( last name  column metadata . named ( "last   name" )  )  ;  add metadata ( id  column metadata . named ( "id" )  )  ;   }  
public void   (  method m )  {  client (  )  . assert put ( m )  ;   test error response resp = client (  )  . execute partial ( 0xa0  ( byte ) 0x0 3  cache name k ( m )  0 0 v ( m )  0 )  ;  assert null ( resp )  ;  client (  )  . assert put fail ( m )  ;  shutdown client (  )  ;   hot rod client new client = connect client (  )  ;  try  {  new client . assert put ( m )  ;   }  finally  {  shutdown client (  )  ;   }   }  
public  string   (  )  {  return delivery host ;   }  
@ override public long   (  )  {  return    alias of . get lifetime processed (  )  ;   }  
private int   (  cache <  ?   ?  >  cache  string cache store method )  {   dummy in memory store cs =  testing util . get first writer ( cache )  ;  return cs . stats (  )  . get ( cache store method )  ;   }  
public void   (  string name )  {  this . name = name ;   }  
private boolean   (  string reference )  {  for  (   string str : exclude packages )   {  if  (  ! str . is empty (  )  && reference . starts with ( str )  )   {  return true ;   }   }  return false ;   }  
@ test public void   (  )  {   flowable <  integer >  source =  flowable . range ( 1 10 )  ;   callable <  flowable <  string >  >  boundary = new  callable <  flowable <  string >  >  (  )  {  @ override public  flowable <  string >  call (  )  {  return
public  string   (  )  {  return site name ;   }  
@ test public void   (  )  throws  exception  {  h . create script ( find sql on classpath ( "default - data" )  )  . execute (  )  ;   result iterable <  something >  ri = h . create query ( "select id  name from something order by id" )  . set fetch siz
public void   (  method m )  {   test response resp = clients (  )  . get ( 0 )  . put ( k ( m )  0 0 v ( m )  )  ;  assert status ( resp  success )  ;   }  
private  query parameters   (  )  {  return params  !  =  null  ?  params : get producer (  )  . get request parameters (  )  ;   }  
@ override protected void   (  )  {  super . remove invalidations finished (  )  ;  remove counter . increment and get (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  list <  name value pair >  parameters = new  array list <  >  (  )  ;  parameters . add ( new  basic name value pair ( mime . field   param   name "test" )  )  ;  parameters . add ( new  basic name v
public  string   (  )  {  return  jive globals . get property ( subscription   type disabled )  ;   }  
protected void   (  account result )  {  final  intent intent ;  if  ( m incoming )   {  intent =  account server settings activity . get intent for incoming ( m context result )  ;   }  else  {  intent =  account server settings activity . get intent for outgoing ( m context result )  ;   }  intent . set flags (  intent . flag   activity   new   task )  ;  m context . start activity ( intent )  ;  finish (  )  ;   }  
private  cursor   ( long mailbox id  string[] projection )  {   matrix cursor mc = new  matrix cursor with cached columns ( projection 1 )  ;  mc . add row ( get virtual mailbox row ( get virtual mailbox account id ( mailbox id )  get virtual mailbox type ( mailbox id )  projection )  )  ;  return mc ;   }  
public boolean   (  )  {  return this . xhtml ;   }  
@ override public  type mirror   (  variable element field )  {  return get real element type ( field )  ;   }  
boolean   (  class <  ?  extends  annotation >  annotation type )  {  return annotation map . contains key ( annotation type )  ;   }  
public  lease set   (  )  {  return    lease set ;   }  
 object[]   (  )  {  return args ;   }  
@ override public final  expression <  ?  >    ( int i )  {  return args . get ( i )  ;   }  
@ override public  string   (  )  {  return sync counter . get name (  )  ;   }  
public void   (  )  throws  exception  {   script metadata metadata =  script metadata parser . parse ( "test . scala" " /  /  name = \"te st\" language = scala" )  ;  assert equals ( "te st" metadata . name (  )  )  ;  assert equals ( "scala" metadata . language (  )  . get (  )  )  ;   }  
public void   (  )  throws  exception  {  remote (  )  . put ( "k" "v" )  ;   versioned value versioned 1  = remote (  )  . get versioned ( "k" )  ;   completable future <  boolean >  f = remote (  )  . replace with version async ( "k" "v 2 " versioned 1  . get version (  )  )  ;  test future with listener ( f true )  ;   versioned value versioned 2  = remote (  )  . get versioned ( "k" )  ;  assert not equals ( versioned 1  . get version (  )  versioned 2  . get version (  )  )  ;  assert equals ( versioned 2  . get value (  )  "v 2 " )  ;  f = remote (  )  . replace with version async ( "k" "v 3 " versioned 1  . get version (  )  )  ;  test future with listener ( f false )  ;  testk ( "v 2 " )  ;   }  
@ override public boolean   (  string[] property path )  {  return false ;   }  
public void   (  )  throws  exception  {  final  string key = " 2 " ;  assert equals ( null cache factory . get embedded cache (  )  . put ( key "v 1 " )  )  ;  assert equals ( "v 1 " cache factory . get memcached client (  )  . get ( key )  )  ;   http method get = new  get method ( cache factory . get rest url (  )   +  " / "  +  key )  ;  get . set request header ( " accept" "text / plain" )  ;  cache factory . get rest client (  )  . execute method ( get )  ;  assert equals (  http status . sc   ok get . get status code (  )  )  ;  assert equals ( "v 1 " get . get response body as string (  )  )  ;  assert equals ( "v 1 " cache factory . get hot rod cache (  )  . get ( key )  )  ;   }  
protected static  archive <  ?  >    (  )  {  return  shrink wrap . create (  java archive . class "converter . jar" )  . add classes (  static cache event converter factory . class  dynamic cache event converter factory . class  custom pojo event converter factory . class  person . class  custom event . class )  . add as service provider (  cache event converter factory . class  static cache event converter factory . class  dynamic cache event converter factory . class  custom pojo event converter factory . class )  ;   }  
@ test public void   (  )  {   flowable <  integer >  source =  flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public void subscribe (   subscriber <  ?  super  integer >  t1 )  {  t1 . on subscribe ( new  boolean subscription
@ test public void   (  )  {  assert equals (  integer[] . class get java type ( "   integer" )  )  ;  assert equals (  integer[] . class get java type ( "integer[]" )  )  ;  assert equals (  integer[] . class get java type ( "integer array" )  )  ;   }  
@ override public ssl engine result .  handshake status   (  )  {  return engine . get handshake status (  )  ;   }  
public void   (  )  {  final  global configuration builder builder = default global configuration builder ( false )  ;   counter manager configuration builder counter builder = builder . add module (  counter manager configuration builder . class )  ;  counter builder . reliability (  reliability . available )  ;  builder . build (  )  ;  counter builder . reliability (  reliability . consistent )  ;  builder . build (  )  ;  counter builder . reliability ( null )  ;  assert counter configuration exception ( builder )  ;   }  
@ override public  object   (  )  {  return global tx ;   }  
@ override public boolean   (  )  throws io exception  {  if  ( exists (  )  )  return false ;  if  (  ! check parent dirs ( get absolute path (  )  false )  )  throw new io exception ( " cannot create file "  +  get absolute path (  )   +  "  ( parent di
@ test public void   (  )  {  assert that ( repose local cache mock . remove groups ( tenant id token )  is ( instance of (  boolean . class )  )  )  ;   }  
public k   (  )  {  return key ;   }  
@ override public void   (  method method )  throws  interrupted exception  {  strategy . test listener add and remove ( method )  ;   }  
public void   (  )  throws  exception  {   object keys[] =  key generator . get instance (  )  . generatepki keypair (  )  ;   public key pub key =  (  public key ) keys[0] ;   private key priv key =  (  private key ) keys[1] ;   session key manager skm = new  transient session key manager (    context )  ;   session key cur key = skm . create session ( pub key )  ;   session key next key =  key generator . get instance (  )  . generate session key (  )  ;   session tag tag1 = new  session tag ( true )  ;   session tag tag2 = new  session tag ( true )  ;   session tag tag3 = new  session tag ( true )  ;   session tag tag4 = new  session tag ( true )  ;   hash set <  session tag >  first tags = new  hash set <  session tag >  (  )  ;  first tags . add ( tag1 )  ;  first tags . add ( tag2 )  ;   hash set <  session tag >  second tags = new  hash set <  session tag >  (  )  ;  second tags . add ( tag3 )  ;  second tags . add ( tag4 )  ;  byte[] msg1 =  data helper . getascii ( "msg 1" )  ;  byte[] msg2 =  data helper . getascii ( "msg 2" )  ;  byte[] msg3 =  data helper . getascii ( "msg 3" )  ;  byte[] msg4 =  data helper . getascii ( "msg 4" )  ;  byte[] msg5 =  data helper . getascii ( "msg 5" )  ;  byte emsg1[] =    context . el gamalaes engine (  )  . encrypt ( msg1 pub key cur key first tags null 64 )  ;  byte dmsg1[] =    context . el gamalaes engine (  )  . decrypt ( emsg1 priv key skm )  ;  assert true (  data helper . eq ( dmsg1 msg1 )  )  ;   tag set handle tsh = skm . tags delivered ( pub key cur key first tags )  ;  skm . tags acked ( pub key cur key tsh )  ;  cur key = skm . get current key ( pub key )  ;   session tag cur tag = skm . consume next available tag ( pub key cur key )  ;  assert not null ( cur tag )  ;  byte emsg2[] =    context . el gamalaes engine (  )  . encrypt ( msg2 pub key cur key null cur tag 64 )  ;  byte dmsg2[] =    context . el gamalaes engine (  )  . decrypt ( emsg2 priv key skm )  ;  assert true (  data helper . eq ( dmsg2 msg2 )  )  ;  cur key = skm . get current key ( pub key )  ;  cur tag = skm . consume next available tag ( pub key cur key )  ;  assert not null ( cur tag )  ;  assert not null ( cur key )  ;  byte emsg3[] =    context . el gamalaes engine (  )  . encrypt ( msg3 pub key cur key second tags cur tag next key 64 )  ;  byte dmsg3[] =    context . el gamalaes engine (  )  . decrypt ( emsg3 priv key skm )  ;  assert true (  data helper . eq ( dmsg3 msg3 )  )  ;  tsh = skm . tags delivered ( pub key next key second tags )  ;  skm . tags acked ( pub key next key tsh )  ;  cur key = skm . get current key ( pub key )  ;  cur tag = skm . consume next available tag ( pub key cur key )  ;  assert not null ( cur tag )  ;  assert not null ( cur key )  ;  byte emsg4[] =    context . el gamalaes engine (  )  . encrypt ( msg4 pub key cur key null cur tag 64 )  ;  byte dmsg4[] =    context . el gamalaes engine (  )  . decrypt ( emsg4 priv key skm )  ;  assert true (  data helper . eq ( dmsg4 msg4 )  )  ;  cur key = skm . get current key ( pub key )  ;  cur tag = skm . consume next available tag ( pub key cur key )  ;  assert not null ( cur tag )  ;  assert not null ( cur key )  ;  byte emsg5[] =    context . el gamalaes engine (  )  . encrypt ( msg5 pub key cur key null cur tag 64 )  ;  byte dmsg5[] =    context . el gamalaes engine (  )  . decrypt ( emsg5 priv key skm )  ;  assert true (  data helper . eq ( dmsg5 msg5 )  )  ;   }  
@ override public void   (  )  {  assert no events ( locall 2  super::test local read write gets empty )  ;   }  
public static  configuration builder   (  )  {   configuration builder builder =  test cache manager factory . get default cache configuration ( true )  ;  builder . clustering (  )  . cache mode (  cache mode . local )  . transaction (  )  . transaction mode (  transaction mode . non   transactional )  . locking (  )  . lock acquisition timeout (  1 0000 )  . invocation batching (  )  . disable (  )  . deadlock detection (  )  . disable (  )  . jmx statistics (  )  . disable (  )  ;  return builder ;   }  
public void   (  line line )  {  lines . add ( line )  ;   }  
@ override public long   (  )  {  return archiver . restore point in time ;   }  
@ override public  map   (  object input input )  throws io exception   class not found exception  {  int magic number = input . read unsigned byte (  )  ;  switch  ( magic number )   {  case hashmap: return  marshall util . unmarshall map ( input  hash m
public void   (  connection .  compression policy policy )  {  final  connection .  compression policy old policy = get compression policy (  )  ;  if  ( old policy . equals ( policy )  )   {   log . debug ( " ignoring  compression  policy change request  ( to ' {  } ' ) : listener already in this state . " policy )  ;  return ;   }   log . debug ( " changing  compression  policy from ' {  } ' to ' {  } ' . " old policy policy )  ;   jive globals . set property ( compression policy property name policy . to string (  )  )  ;  restart (  )  ;   }  
@ test public void   (  )  {  request = new  basic http request ( "get" " / " )  ;  request . set header ( " authorization" " basic dx nlcjpwyx nzd 2 q = " )  ;  response . set header ( " cache -  control" "max - age =  3  6 00" )  ;   assert . assert fal
private static  cassandra .  client   (  string host int port  string user  string passwd i transport factory transport factory )  throws  exception  {  t transport trans = transport factory . open transport ( host port )  ;  t protocol protocol = new t binary protocol ( trans )  ;   cassandra .  client client = new  cassandra .  client ( protocol )  ;  if  ( user  !  =  null && passwd  !  =  null )   {   map <  string  string >  credentials = new  hash map <  >  (  )  ;  credentials . put ( i authenticator . username   key user )  ;  credentials . put ( i authenticator . password   key passwd )  ;   authentication request authentication request = new  authentication request ( credentials )  ;  client . login ( authentication request )  ;   }  return client ;   }  
@ test public void   (  )  {  expect parser success ( "select bar from example .  bar bar where bar . baz . string date map['big bang']  <  bar . baz . string date map['now'] and bar . baz . string date map['now'] is not null" )  ;   }  
@ test public void   (  )  throws  exception  {  test (  simple cache keys factory . short   name  name . class . get simple name (  )  )  ;   }  
@ before @ override public void   (  )  throws  exception  {   test resource tracker . test thread started ( this )  ;  super . set up (  )  ;   }  
public  string[]   (  )  {  return projections ;   }  
public  page context   (  )  {  return page context ;   }  
@ test public void   (  )  {  final  list <  pattern >  patterns = new  array list <  >  (  )  ;  for  (  int i :  arrays . as list ( 1 2 3 )  )   {  patterns . add (  pattern . compile ( " . * ;  ?  ( param"  +  i  +  " = " +  i +  " )  ;  ?  . *" )  )  
@ override public void   (  )  {  if  ( done )   {  return ;   }  done = true ;  actual . on next ( u )  ;  actual . on complete (  )  ;   }  
public static  context   (  context context )  throws  exception  {   mock content resolver resolver = new  mock content resolver (  )  ;  final  string filename prefix = "test . " ;   renaming delegating context target context wrapper = new  renaming delegating context ( new  mock context2 ( context )  context filename prefix )  ;  final  context provider context = new  my isolated context ( resolver target context wrapper context )  ;  provider context . get content resolver (  )  ;  final  email provider ep = new  email provider (  )  ;  ep . attach info ( provider context null )  ;  resolver . add provider (  email content . authority ep )  ;  final  attachment provider ap = new  attachment provider (  )  ;  ap . attach info ( provider context null )  ;  resolver . add provider (  attachment . attachment   provider   legacy   uri   prefix ap )  ;   content cache . invalidate all caches (  )  ;  return provider context ;   }  
@ test public void   (  )  {  assert equals ( 0  flowable . from array ( 1 2 )  . element at ( 2 0 )  . blocking get (  )  . int value (  )  )  ;   }  
public void   (  string factory )  {  if  ( configured )   {  throw new  illegal state exception ( " configuration is frozen" )  ;   }  this . factory = factory ;   }  
@ override protected final boolean   (  cache cache  object key )  {  return true ;   }  
@ override public void   (  string s )  throws io exception  {  throw new  unsupported operation exception (  )  ;   }  
public int   (  )  {  return 0 ;   }  
public  object   (     fields field )  {  switch  ( field )   {  case acknowledged   by: return  integer . value of ( get acknowledged   by (  )  )  ;  case acknowledged   by   batchlog: return  boolean . value of ( is acknowledged   by   batchlog (  )  )  ;  case paxos   in   progress: return  boolean . value of ( is paxos   in   progress (  )  )  ;   }  throw new  illegal state exception (  )  ;   }  
@ test public void   (  )  {  final  something by iterable s = handle . attach (  something by iterable . class )  ;  final  list <  something >  out = s . get (  (  )   -  >   arrays . as list ( new  something key ( 1 "1" )  new  something key ( 2 "2" ) 
public static  to array long function   (  )  {  return operation ;   }  
@ after method ( always run = true )  public void   (  )  {   util . recursive file remove ( persistent   folder )  ;   }  
@ override public  presence   (  presence .  type presence type )  throws  unauthorized exception  {   presence presence = new  presence (  )  ;  presence . set type ( presence type )  ;  presence . set from ( role . get role address (  )  )  ;  return pr
@ override public iq handler info   (  )  {  return info ;   }  
public int   (  )  throws  jsp exception  {  int i = super . do end tag (  )  ;  set name ( original name )  ;  set property ( original property )  ;  return i ;   }  
@ override public boolean   (  )  throws sql exception  {  return rs . is before first (  )  ;   }  
@ test public void   (  )  {   in order in order = in order ( observer )  ;  observable . subscribe ( observer )  ;  test scheduler . advance time by ( 1000 time   unit )  ;  subject . on next ( 1 )  ;  test scheduler . advance time by ( 2000 time   unit 
public   (  boolean authenticated )  {  this . authenticated = authenticated ;   }  
public void   (  string store code )  {  this . store code = store code ;   }  
private void   (  string key )  throws  exception  {  writer . delete ( key )  ;  assert null ( loader . load ( key )  )  ;   }  
@ override public void   (  member select expression tree tree )  {  scan ( tree . expression (  )  )  ;   }  
@ test ( timeout = 10000 )  public void   (  )  {  long start time =  system . current time millis (  )  ;   observable <  integer >  src =  observable . just ( 1 )  . subscribe on (  schedulers . computation (  )  )  ;  int i = 0 ;  while  (  system . cu
@ override public void   (  tree tree )  {   method tree method tree =  (  method tree ) tree ;  if  ( has semantic (  )  && is finalize declaration ( method tree )  )   {  method tree . accept ( new  assignment visitor (  )  )  ;   }   }  
public void   (  method method )  {  final  string counter name = method . get name (  )  ;  assert key distribution in all managers ( counter name )  ;  kill member (  1  )  ;  wait for counter caches (  )  ;  assert key distribution in all managers ( counter name )  ;   }  
private static int   (  byte buffer buffer )  {  if  ( buffer . remaining (  )   <  3 )   {  throw new  invalid database exception ( " unexpected end of data record when reading metro area" )  ;   }  int metroarea combo = 0 ;  for  ( int j = 0 ;  j  <  3 ;  j +  +  )   {  metroarea combo +  = unsigned byte to int ( buffer . get (  )  )   <  <   ( j * 8 )  ;   }  return metroarea combo ;   }  
@ test public void   (  )  throws  interrupted exception   execution exception  {   flowable <  string >  obs =  flowable . just ( "one" "two" "three" )  ;   future <  list <  string >  >  f = obs . to list (  )  . to future (  )  ;  assert equals ( "one"
private  string   (  string class name )  {   string key = class name ;  if  (  string utils . is not empty ( current package )  )   {  key = current package  +  " / "  +  class name ;   }  if  ( "" . equals ( class name )  ||  ( parent . peek (  )   !  =  null && parent . peek (  )  . is (  tree .  kind . method )  )  )   {  int count = anonymous inner class counter . pop (  )   +   1  ;  key = current class key . peek (  )   +  "$"  +  count +  class name ;  anonymous inner class counter . push ( count )  ;   }  else if  ( current class key . peek (  )   !  =  null )   {  key = current class key . peek (  )   +  "$"  +  class name ;   }  return key ;   }  
public boolean   (  )  {  return positional ;   }  
@ override public void   (  )  {  o . on complete (  )  ;   }  
private long   (  set < ss table reader >  actually compact )  {  long min repaired at =  long . max   value ;  for  (  ss table reader sstable : actually compact )  min repaired at =  math . min ( min repaired at sstable . getss table metadata (  )  . repaired at )  ;  if  ( min repaired at  =  =   long . max   value )  return  active repair service . unrepaired   sstable ;  return min repaired at ;   }  
public void   (  string parameter name  date x  calendar cal )  throws sql exception  {  cstmt . set date ( parameter name x cal )  ;   }  
@ override public  string   (  integer segment )  {  return  string . value of ( segment )  ;   }  
@ test public void   (  )  {  byte[] val = dummy ;   range <  token >  range = new  range <  >  ( tok (  -  1  )  tok (  -  1  )  )  ;  assert null ( mt . hash ( range )  )  ;  mt . get ( tok (  -  1  )  )  . hash ( val )  ;  assert hash equals ( val mt .
public synchronized  set <  string >    (  )  {  return this . get barcode records (  )  . key set (  )  ;   }  
 cookie   (  )  {  return null ;   }  
@ override public void   ( int n )  {  method . set parameter invocation count ( n )  ;   }  
public uri   ( final int index )  {  return this . all . get ( index )  ;   }  
@ test public void   (  )  throws  exception  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . having ( "creation date" )  . eq (  instant . parse ( " 2 0 1  1  -  1  2  - 0 
@ override public byte   ( int offset )  {  return bytes[offset] ;   }  
public void   (  http servlet response response )  {  this . response = response ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
public void   (  )  {  load data (  )  ;  double center latitude =  2  4  ;  double center longitude =  3  1  .  5  ;   query query =  search . get search manager ( cache )  . build query builder for class (  city spatial . class )  . get (  )  . spatial (  )  . on field ( "city   location" )  . within (  5 0  unit . km )  . of latitude ( center latitude )  . and longitude ( center longitude )  . create query (  )  ;   cache query <  ?  >  cache query =  search . get search manager ( cache )  . get query ( query )  ;   list <  ?  >  found = cache query . list (  )  ;  assert equals ( 0 found . size (  )  )  ;  query =  search . get search manager ( cache )  . build query builder for class (  city spatial . class )  . get (  )  . spatial (  )  . on field ( "city   location" )  . within (  5  1   unit . km )  . of latitude ( center latitude )  . and longitude ( center longitude )  . create query (  )  ;  cache query =  search . get search manager ( cache )  . get query ( query )  ;  found = cache query . list (  )  ;  assert equals (  1  found . size (  )  )  ;   }  
@ override public  set <  class <  ?  extends  read function >  >    (  )  {  return  collections . singleton (  read function . class )  ;   }  
public int   (  )  {  return porta ;   }  
public int   (  )  {  return  ( this . columns  =  =  null )   ?  0 : this . columns . size (  )  ;   }  
@ override public  map <  string  string >    (  data input in )  throws io exception  {  return  collections . empty map (  )  ;   }  
public boolean   (  )  {  return shutting down && shutdown . is signaled (  )  ;   }  
@ override public  string   (  )  throws  unknown host exception  {  final  socket address remote address = io session . get remote address (  )  ;  if  ( remote address  =  =  null )  throw new  unknown host exception (  )  ;  final  inet socket address 
public  string   (  )  {  return body ;   }  
@ override public void   (  )  {   action listener action listener = listener ;  if  ( is ready (  )  && action listener  !  =  null && notify . compare and set ( false true )  )   {  action listener . on complete (  )  ;   }   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  cs . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
@ override public void   (  )  {  int idle time = get session detach time (  )  ;  if  ( idle time  =  =   - 1 )   {  return ;   }  final long deadline =  system . current time millis (  )   -  idle time ;  for  (   local session session : detached sessio
@ override public void   ( int rows )  throws sql exception  {  rs . set fetch size ( rows )  ;   }  
@ test public void   (  )  throws  exception  {  final  classic http request req 1  = new  basic classic http request ( "get" " / " )  ;  final  classic http request req 2  = new  basic classic http request ( "get" " / " )  ;  final  date now = new  date 
public void   ( boolean value )  {  if  (  ! value )   {  this . consistency = null ;   }   }  
@ override public void   (  )  {  super . on destroy (  )  ;  if  ( is hexagon setup running (  )  )   {  hexagon setup task . cancel ( true )  ;   }  hexagon setup task = null ;   }  
@ override public  runnable   (  )  {  return runnable ;   }  
public static  string   (  )  {  return conf . saved   caches   directory ;   }  
@ override protected void   (  http servlet request req  http servlet response resp )  throws  servlet exception  io exception  {  resp . set character encoding ( "utf - 8" )  ;  resp . set header ( "x -  content -  type -  options" "nosniff" )  ;  resp .
@ override public v   ( v value )  {  v old = this . value ;  this . value = value ;  return old ;   }  
public void   (  )  {  final  string key 1  = " 1 "  value 1  = "one"  key 2  = " 2 "  value 2  = "two"  key 3  = " 3 "  value 3  = "three" ;   map <  string  string >  m = new  hash map <  >  (  )  ;  m . put ( key 1  value 1  )  ;  m . put ( key 2  value 2  )  ;  m . put ( key 3  value 3  )  ;  cache ( 0 "repl sync" )  . put all ( m )  ;   set <  object >  keys = cache ( 0 "repl sync" )  . key set (  )  ;   collection <  object >  values = cache ( 0 "repl sync" )  . values (  )  ;   collection <  object > [] collections = new  collection[] { keys values }  ;   object new obj = "foo" ;   list <  object >  new obj col = new  array list <  >  (  )  ;  new obj col . add ( new obj )  ;  for  (   collection <  object >  col : collections )   {   exceptions . expect exception (  unsupported operation exception . class  (  )   -  >  col . add ( new obj )  )  ;   exceptions . expect exception (  unsupported operation exception . class  (  )   -  >  col . add all ( new obj col )  )  ;   }   }  
protected  random access reader   (  )  {  return  random access reader . open ( new  file ( path )  length this )  ;   }  
@ override protected int   (  )  {  return rest   port 2  ;   }  
@ test ( expected exceptions =  illegal argument exception . class )  public void   (  )  throws  parse exception  {  load testing data (  )  ;  query parser = create query parser ( "blurb" )  ;   query lucene query = query parser . parse ( " eats" )  ;  
@ test public void   (  )  {   collect wgs metrics collect wgs metrics = new  collect wgs metrics (  )  ;  collect wgs metrics . include   bq   histogram = true ;   fast wgs metrics collector collector = new  fast wgs metrics collector ( collect wgs metri
void   (  )  {  if  ( compare and set ( 0 1 )  )   {  try  {  on finally . run (  )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plugins . on error ( ex )  ;   }   }   }  
public static  long   (  )  {  return date time tontp (  date extensions . get utc now (  )  )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  async =  publish processor . create (  )  ;   test exception te = new  test exception (  )  ;  async . on error ( te )  ;   flowable processor <  integer >  serial = async . to serialized (  )
public  handset provider   (  )  {  return handset provider ;   }  
@ override public int   (  )  {  return stream reader . get event type (  )  ;   }  
public  certificate   ( int effort )  {   certificate c = set cert type (  certificate . certificate   type   hashcash )  ;  long begin =  system . current time millis (  )  ;   system . out . println ( " starting hashcash generation now .  .  . " )  ;   string resource = this . dest . get public key (  )  . to base64 (  )   +  this . dest . get signing public key (  )  . to base64 (  )  ;   hash cash hc ;  try  {  hc =  hash cash . mint cash ( resource effort )  ;   }  catch  (   no such algorithm exception e )   {  return null ;   }   system . out . println ( " generation took: "  +   data helper . format duration (  system . current time millis (  )   -  begin )  )  ;   system . out . println ( " full  hashcash is: "  +  hc )  ;   string hcs = hc . to string (  )  ;  int end1 = 0 ;  for  ( int i = 0 ;  i  <  3 ;  i +  +  )   {  end1 = 1  +  hcs . index of ( ':' end1 )  ;  if  ( end1  <  0 )   {   system . out . println ( " bad hashcash" )  ;  return null ;   }   }  int start2 = hcs . index of ( ':' end1 )  ;  if  ( start2  <  0 )   {   system . out . println ( " bad hashcash" )  ;  return null ;   }  hcs = hcs . substring ( 0 end1 )   +  hcs . substring ( start2 )  ;   system . out . println ( " short  hashcash is: "  +  hcs )  ;  c . set payload (  data helper . getutf8 ( hcs )  )  ;  return c ;   }  
public  iterator <  range tombstone >    ( final  column family source )  {  if  (  ! source . deletion info (  )  . has ranges (  )  )  return  iterators .  <  range tombstone > empty iterator (  )  ;  return new  abstract iterator <  range tombstone >  (  )  {  private final  iterator <  cell name >  names = columns . iterator (  )  ;  private  range tombstone last find range ;  protected  range tombstone compute next (  )  {  while  ( names . has next (  )  )   {   cell name next = names . next (  )  ;  if  ( last find range  !  =  null && last find range . includes ( source . get comparator (  )  next )  )  return last find range ;  last find range = source . deletion info (  )  . range covering ( next )  ;  if  ( last find range  !  =  null )  return last find range ;   }  return end of data (  )  ;   }   }   ;   }  
@ override public void   ( final  http connection connection final int stream id final  raw frame frame )  {  if  ( frame log . is debug enabled (  )  )   {  log frame info ( id  +  "  >  > " frame )  ;   }  if  ( frame payload log . is debug enabled (  )
public void   (  )  throws io exception  {   file file = fs . get file ( "file . txt" )  ;  assert equals ( file . get parent (  )  null )  ;  file = fs . get file ( " / parentdir / file . txt" )  ;  assert equals ( file . get parent (  )  " / parentdir" )  ;  file = fs . get file ( " / parentdir / subdir / file . txt" )  ;  assert equals ( file . get parent (  )  " / parentdir / subdir" )  ;   }  
public void   (  )  {   string url = null ;  try  {  url =  request utils . serverurl ( request )  . to string (  )  ;   }  catch  (   malformedurl exception e )   {  fail ( " threw  malformedurl exception: "  +  e )  ;   }  assert not null ( "serverurl is present" url )  ;  assert equals ( "serverurl value" "http: /  / localhost: 8 0 8 0" url )  ;   }  
public  function <  ?  super i  ?  extends  double stream >    (  )  {  return function ;   }  
private void   ( int move pos  view move item boolean force invalidate )  {  m block layout requests = true ;  update float view (  )  ;  int old first exp pos = m first exp pos ;  int old second exp pos = m second exp pos ;  boolean updated = update positions (  )  ;  if  ( updated )   {  adjust all items (  )  ;  int scroll = adjust scroll ( move pos move item old first exp pos old second exp pos )  ;  set selection from top ( move pos move item . get top (  )   +  scroll  -  get padding top (  )  )  ;  layout children (  )  ;   }  if  ( updated || force invalidate )   {  invalidate (  )  ;   }  m block layout requests = false ;   }  
@ test public void   (  )  throws  exception  {  origin response = new  basic classic http response (  http status . sc   ok "ok" )  ;  origin response . set version ( new  protocol version ( "http"  1   2  )  )  ;  origin response . set header ( " date" 
@ test public void   (  )  {  final  group element t =  group element . p1p1 ( curve zero one one one )  ;  assert that ( t . curve is ( equal to ( curve )  )  )  ;  assert that ( t . repr is (  group element .  representation . p1p1 )  )  ;  assert that 
private static boolean   (  expression tree tree )  {  return get floating zero or one ( tree )   !  =  null ;   }  
@ override public  object   (  invocation context ctx  compute if absent command command )  throws  throwable  {  return invoke next then apply ( ctx command handle data write return )  ;   }  
public void   (  )  throws  exception  {   userhs user = new  userhs (  )  ;  user . set id (  1  )  ;  user . set name ( " john" )  ;  cache . put ( "user   "  +  user . get id (  )  user )  ;   query cache query cache =  component registry utils . get query cache ( cache )  ;  query cache . clear (  )  ;   cache <  ?   ?  >  internal cache =  (  cache )  testing util . extract field (  query cache . class query cache "lazy cache" )  ;   string query string = "from org . infinispan . query . dsl . embedded . testdomain . hsearch .  userhs u where u . name  =  ' john'" ;  int invoked[] =  { 0 }  ;   ickle parsing result created = query cache . get ( query string null  ickle parsing result . class  ( qs acc )   -  >   {  invoked[0] +  +  ;  return null ;   }   )  ;  assert equals (  1  invoked[0] )  ;  assert null ( created )  ;  assert equals ( 0 internal cache . size (  )  )  ;   query query =  search . get query factory ( cache )  . create ( query string )  ;  query . list (  )  ;  assert equals (  2  internal cache . size (  )  )  ;   set <  class <  ?  >  >  cache value classes = internal cache . entry set (  )  . stream (  )  . map ( e  -  >  e . get value (  )  . get class (  )  )  . collect (  collectors . to set (  )  )  ;   set <  class <  ?  >  >  expected cached value classes =  sets . new linked hash set (  ickle parsing result . class  lucene query parsing result . class )  ;  assert equals ( expected cached value classes cache value classes )  ;   ickle parsing result cached = query cache . get ( query string null  ickle parsing result . class  ( qs acc )   -  >   {  throw new  assertion error ( " query creator should not be invoked now" )  ;   }   )  ;  assert not null ( cached )  ;   }  
@ test public void   (  )  {   string name = "my   byte   array" ;  assert equals ( name byte array configuration resource . name (  )  )  ;   }  
public  presence manager   (  )  {  return  (  presence manager ) modules . get (  presence manager impl . class )  ;   }  
@ test public void   (  )  {   flowable <  boolean >  observable =  flowable . sequence equal (  flowable . just ( "one" "two" "three" )   flowable . concat (  flowable . just ( "one" )   flowable .  <  string > error ( new  test exception (  )  )  )  )  
void   (  )  {  new  test < a >  (  )  .  < a > foo ( new a (  )  )  ;  new  test < a >  (  )  .  < b > foo ( new b (  )  )  ;  new  test < a >  (  )  . foo ( new a (  )  )  ;  new  test < a >  (  )  . foo ( new b (  )  )  ;  new  test < a >  (  )  .  < a > bar ( new a (  )  )  ;  new  test < a >  (  )  .  < b > bar ( new b (  )  )  ;  new  test < a >  (  )  . bar ( new a (  )  )  ;  new  test < a >  (  )  . bar ( new b (  )  )  ;   }  
public t[]   ( t[] array )  {  t v = get value (  )  ;  if  ( v  =  =  null )   {  if  ( array . length  !  =  0 )   {  array[0] = null ;   }  return array ;   }  if  ( array . length  =  =  0 )   {  array =  arrays . copy of ( array 1 )  ;   }  array[0] = v ;  if  ( array . length  !  =  1 )   {  array[1] = null ;   }  return array ;   }  
public void   (  attribute other attr )  {  set name ( other attr . get name (  )  )  ;  set value ( other attr . get value (  )  )  ;   }  
@ test public void   (  )  throws io exception  sax exception  {  mock request . set content ( content remove me )  ;  mock request . add header ( accept "application / other" )  ;  mock response . set content type ( "application / other" )  ;  http servl
public byte[]   (  )  {  if  ( packet bytes  !  =  null )  return packet bytes ;   datagram packet packet = get datagram packet (  )  ;  int packet len = packet . get length (  )  ;   string packet data = new  string ( packet . get data (  )  0 packet len )  ;  packet bytes = packet data . get bytes (  )  ;  return packet bytes ;   }  
@ override public boolean   (  string fqn  flag .  .  .  flags )  {  return remove node ( cache . with flags ( flags )   fqn . from string ( fqn )  )  ;   }  
public void   (  method m )  throws  interrupted exception   execution exception   timeout exception  {  add and get ( m )  ;   operation future <  boolean >  f = client . prepend ( 0 k ( m )  v ( m "v 1  - " )  )  ;  assert true ( f . get ( timeout  time unit . seconds )  )  ;   string expected = v ( m "v 1  - " )   +  v ( m )  ;  assert equals ( client . get ( k ( m )  )  expected )  ;   }  
@ override public void   (  integer t )  {  super . on next ( t )  ;  request more ( 1 )  ;   }  
@ override protected  embedded cache manager   (  )  throws  exception  {   configuration builder cfg = new  configuration builder (  )  ;  cfg . memory (  )  . storage type (  storage type . binary )  . eviction type (  eviction type . memory )  . size (
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
@ test ( data provider = " " )  public void test default min group count ( final  string test name final int num duplicates final int num read pairs examined )  throws io exception  {  final  file input = new  file ( test   data   dir test name )  ;  fina
public void   (  string key  action messages messages )  {  if  ( messages  =  =  null )   {  return ;   }   action messages request messages =  (  action messages ) this . get ( key )  ;  if  ( request messages  =  =  null )   {  request messages = new  action messages (  )  ;   }  request messages . add ( messages )  ;  this . remove ( key )  ;  this . save action messages ( key request messages )  ;   }  
public  < p > q   (  param expression < p >  param p value )  {  return query mixin . set ( param value )  ;   }  
public void   (  )  throws  exception  {   mock transport mock = open and inject mock transport (  )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  final  imap connection con1 = m store . get connection (  )  ;  assert not null ( con1 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert false ( con1 . is transport open for test (  )  )  ;  expect login ( mock )  ;  con1 . open (  )  ;  assert true ( con1 . is transport open for test (  )  )  ;  final  imap connection con2 = m store . get connection (  )  ;  assert not null ( con2 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert false ( con2 . is transport open for test (  )  )  ;  assert not same ( con1 con2 )  ;  int save tag = reset tag (  )  ;  expect login ( mock )  ;  con2 . open (  )  ;  assert true ( con1 . is transport open for test (  )  )  ;  m store . pool connection ( con1 )  ;  assert equals ( 1 m store . get connection pool for test (  )  . size (  )  )  ;  save tag = reset tag ( save tag )  ;  mock . expect ( get next tag ( false )   +  " noop" new  string[] { get next tag ( true )   +  " ok success" }  )  ;  final  imap connection con1b = m store . get connection (  )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert same ( con1 con1b )  ;  assert true ( con1 . is transport open for test (  )  )  ;  m store . pool connection ( con2 )  ;  assert equals ( 1 m store . get connection pool for test (  )  . size (  )  )  ;  reset tag ( save tag )  ;  mock . expect ( get next tag ( false )   +  " noop" new  string[] { get next tag ( true )   +  "* bye bye" }  )  ;  final  imap connection con3 = m store . get connection (  )  ;  assert not null ( con3 )  ;  assert equals ( 0 m store . get connection pool for test (  )  . size (  )  )  ;  assert not same ( con1 con3 )  ;  assert not same ( con2 con3 )  ;   }  
public static  subscription   (  object o )  {  return  (  (  subscription notification ) o )  . s ;   }  
public static  task engine   (  )  {  return instance ;   }  
public byte[]   (  )  {  return serialized key ;   }  
private void   (  method invocation tree tree )  {  for  (   method matcher matcher : matches . key set (  )  )   {  if  ( matcher . matches ( tree )  )   {  count match ( matcher )  ;   }   }   }  
@ test ( expected exceptions =  illegal state exception . class )  public void   (  )  {  final  test mergeable metric metric1 = new  test mergeable metric (  )   metric2 = new  test mergeable metric (  )  ;  metric1 . must be equal unboxed boolean = true
@ test public void   (  )  throws  exception  {  final  string s = "some kind of text" ;  final byte[] input = s . get bytes (  standard charsets . us   ascii )  ;  final byte[] compressed = new byte[input . length *  2 ] ;  final  deflater compresser = n
@ override public  string expression   (  )  {  return lower (  )  ;   }  
@ test public void   (  )  {   column mapper double mapper = new  column mapper double (  1 f )  ;   double parsed = mapper . index value ( "test"  3 f )  ;   assert . assert equals (  double . value of (  3  )  parsed )  ;   }  
@ override public void   (  )  {  reset state from current fragment (  )  ;   }  
public int   (  )  {  return foo ;   }  
@ group public  string   (  )  {  return  string . value of ( key )  ;   }  
@ in transaction mode (  transaction mode . transactional )  public void   (  )  throws  exception  {   cache <  string  string >  cache 1  = cache ( 0 cache   name )  ;   cache <  string  string >  cache 2  = cache (  1  cache   name )  ;   transaction m
public static long   (  )  {  return lock wait time ;   }  
public  string   (  )  {  return name ;   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
public void   (  for each statement for each tree  symbol variable  symbol map symbol )  {  this . variable = variable ;  result = false ;  this . map symbol = map symbol ;  scan ( for each tree . statement (  )  )  ;  if  ( result )   {  report issue ( for each tree . for keyword (  )  " iterate over the \"entry set\" instead of the \"key set\" . " )  ;   }   }  
static  string   ( final  string input )  {  if  ( input . ends with ( " . sam" )  )   {  return " . sam" ;   }  if  ( input . ends with ( " . cram" )  )   {  return " . cram" ;   }  return " . bam" ;   }  
private  memcached operation   (  string command name  boolean end of op  byte buf buffer )  throws  unknown operation exception  {  if  ( is trace )  log . tracef ( " operation: '%s'" command name )  ;  switch  ( command name )   {  case "get": return  memcached operation .  get request ;  case "set": return  memcached operation .  put request ;  case "add": return  memcached operation .  put if absent request ;  case "delete": return  memcached operation .  remove request ;  case "replace": return  memcached operation .  replace request ;  case "cas": return  memcached operation .  replace if unmodified request ;  case "append": return  memcached operation .  append request ;  case "prepend": return  memcached operation .  prepend request ;  case "gets": return  memcached operation .  get with version request ;  case "incr": return  memcached operation .  increment request ;  case "decr": return  memcached operation .  decrement request ;  case "flush   all": return  memcached operation .  flush all request ;  case "version": return  memcached operation .  version request ;  case "stats": return  memcached operation .  stats request ;  case "verbosity": return  memcached operation .  verbosity request ;  case "quit": return  memcached operation .  quit request ;  default : if  (  ! end of op )   {   string line = read discarded line ( buffer )  ;  log . debugf ( " unexpected operation '%s'  rest of line contains: %s" command name line )  ;   }  throw new  unknown operation exception ( " unknown operation: "  +  command name )  ;   }   }  
@ override public void   (  subscription s )  {  if  (  subscription helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;  s . request (  long . max   value )  ;   }   }  
@ override boolean   (  string namespace  string server name  xml pull parser xpp  connection connection )  throws  xml pull parser exception  {  if  ( get namespace (  )  . equals ( namespace )  )   {  session =  local connection multiplexer session . cr
public  byte buffer   (  byte buffer serialized list int index )  {  try  {   byte buffer input = serialized list . duplicate (  )  ;  int n = read collection size ( input  server . version    3  )  ;  if  ( n  <  =  index )  return null ;  for  ( int i = 0 ;  i  <  index ;  i +  +  )   {  int length = input . get int (  )  ;  input . position ( input . position (  )   +  length )  ;   }  return read value ( input  server . version    3  )  ;   }  catch  (   buffer underflow exception e )   {  throw new  marshal exception ( " not enough bytes to read a list" )  ;   }   }  
@ override public void   (  object output output  ickle cache event filter converter object )  throws io exception  {  output . write object ( object . filter and converter )  ;   }  
@ test public void   (  )  throws  exception  {   configuration builder builder = new  security configuration helper (  )  . with default ssl (  )  . with sni ( "sni" )  ;   string hostname = ispn server . get hotrod endpoint (  )  . get inet address (  )
@ override protected  closeable http response   ( final  http host target final  classic http request request final  http context context )  throws io exception  {  return null ;   }  
@ test ( expected exceptions =  hot rod client exception . class expected exceptions message reg exp = "org . infinispan . objectfilter .  parsing exception: ispn0 2  8  5  2  1 :  . *unless the property is indexed and analyzed . *" )  @ override public v
@ override public  string   (  )  {  return "infinispan - core - tests - component - metadata . dat" ;   }  
@ test public void   (  )  {   publish processor <  object >  as =  publish processor . create (  )  ;  assert false ( as . has throwable (  )  )  ;  assert false ( as . has complete (  )  )  ;  assert null ( as . get throwable (  )  )  ;  as . on error (
@ override protected  cache mode   (  )  {  return  cache mode . repl   sync ;   }  
@ test public void   (  )  {   observable <  string >  src =  observable . just ( "a" "b" "c" "c" "c" "b" "b" "a" "e" )  ;  src . distinct until changed ( to   upper   with   exception )  . subscribe ( w )  ;   in order in order = in order ( w )  ;  in or
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . range ( 0  ( int ) elements )  . subscribe on (  schedulers . single (  )  )  ;   }  
public  string   (  )  {  return mime type ;   }  
@ override public void   (  throwable e )  {  actual . on error ( e )  ;   }  
public static boolean   (  string data )  {  return data  =  =  null  ?  false :  base32 hex . is in alphabet ( data . to upper case (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  final int management port server 1  =  9  9  9 0 ;  m bean server connection provider provider 1  ;  final int management port server 2  =  1 00 9 0 ;  m bean server connection provider provider 2  ;  try  
@ override public v   (  object key )  {  return cache implementation . get ( key flags read context (  1  )  )  ;   }  
public boolean   (  )  {  synchronized  ( member list )   {  if  ( is first member  =  =  false )   {  return false ;   }  is first member = false ;  return member list . is empty (  )  ;   }   }  
public void   ( i2p session muxed listener l int proto int port )  {  i2p session listener old =    listeners . put ( key ( proto port )  l )  ;  if  ( old  !  =  null &&    log . should log (  log . warn )  )     log . warn ( " listener "  +  l  +  " replaces " +  old +  " for proto: " +  proto +  " port: " +  port )  ;   }  
@ test public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;  final  publish processor <  integer >  sdelay =  publish processor . create (  )  ;  final  publish processor <  integer >  delay =  publish proce
public static  string   (  context context )  {  if  (  build config . debug )   {  return context . get string ( r . string . format   version   debug get version ( context )   series guide database . database   version  build config . version   code )  ;   }  else  {  return context . get string ( r . string . format   version get version ( context )   series guide database . database   version )  ;   }   }  
@ override public  input stream   ( long pos long length )  throws sql exception  {  return null ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  prepared statement st int start index t value )  throws sql exception  {  if  ( convert primitives )   {  int length = java . lang . reflect .  array . get length ( value )  ;   object value
@ override protected void   (  method invocation tree mit )  {   string method name = mit . symbol (  )  . name (  )  ;  report issue (  expression utils . method name ( mit )  " replace this with a call to the \"to file (  )  . "  +  message param . get 
@ test public void   (  )  throws  exception  {  assert that ( service )  . is not null (  )  ;   }  
@ override public long   (  )  {  try  {  return out . get file pointer (  )  ;   }  catch  (  io exception e )   {  throw new fs read error ( e get path (  )  )  ;   }   }  
public void   (  )  {  for  ( int i = 0 ;  i  <  25 ;  i +  +  )   {  byte[] message = new byte[256] ;     context . random (  )  . next bytes ( message )  ;   object[] keys =  key generator . get instance (  )  . generate signing keypair (  )  ;   signing public key pubkey =  (  signing public key ) keys[0] ;   signing private key privkey =  (  signing private key ) keys[1] ;   signature s = dsa engine . get instance (  )  . sign ( message privkey )  ;   signature s1 = dsa engine . get instance (  )  . sign ( new  byte array input stream ( message )  privkey )  ;  assert true ( dsa engine . get instance (  )  . verify signature ( s message pubkey )  )  ;  assert true ( dsa engine . get instance (  )  . verify signature ( s1 new  byte array input stream ( message )  pubkey )  )  ;  assert true ( dsa engine . get instance (  )  . verify signature ( s1 message pubkey )  )  ;  assert true ( dsa engine . get instance (  )  . verify signature ( s new  byte array input stream ( message )  pubkey )  )  ;   }   }  
@ test public void   (  )  {  final  atomic boolean error occurred = new  atomic boolean ( false )  ;   test subscriber <  integer >  ts =  test subscriber . create ( 1 )  ;   flowable <  integer >  source =  flowable . just ( 1 )  . do on error ( new  co
private static boolean   (  lambda expression tree lambda tree )  {   tree lambda body = lambda tree . body (  )  ;  if  ( is block with one statement ( lambda body )  )   {   tree statement =  (  (  block tree ) lambda body )  . body (  )  . get ( 0 )  ;  return is expression statement invoking method ( statement lambda tree )  || is return statement invoking method ( statement lambda tree )  ;   }  return false ;   }  
@ test ( timeout = 2000 )  public void   (  )  {   observer <  object >  o =  test helper . mock observer (  )  ;   observable . just ( 1 )  . repeat ( 0 )  . subscribe ( o )  ;  verify ( o )  . on complete (  )  ;  verify ( o never (  )  )  . on next ( a
protected  security configuration builder   (  )  {  return security builder ;   }  
@ managed attribute ( description = " average local commit duration time  (  2 nd phase only )   ( in microseconds ) " display name = " average  commit  time" )  public double   (  )  {  return get attribute ( commit   execution   time )  ;   }  
public  map <  object  object >    (  )  {  return  collections . unmodifiable map (    options )  ;   }  
public  string   (  )  {  return data . get absolute path (  )  ;   }  
private static boolean   (  string class name )  {  return white list classes . stream (  )  . any match ( class name::contains )  ;   }  
public int   (  string component @ suppress warnings ( "rawtypes" )   class packet class int minutes )  {   string classname = packet class . get name (  )  ;   connection con = null ;   prepared statement pstmt = null ;   result set rs = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( count   packages   odler )  ;  pstmt . set string ( 1 "%"  +  classname  +  "" )  ;  pstmt . set string ( 2 component )  ;  pstmt . set long ( 3  system . current time millis (  )   -  minutes * 60 * 1000 )  ;  rs = pstmt . execute query (  )  ;  rs . next (  )  ;  return rs . get int ( 1 )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( rs pstmt con )  ;   }  return  - 1 ;   }  
private void   ( boolean use commit )  throws  exception  {   cache cache 1  = cache ( 0 "testcache" )  ;   cache cache 2  = cache (  1  "testcache" )  ;  assert cluster size ( " should only be  2  caches in the cluster !  !  ! "  2  )  ;  assert null ( " should be null" cache 1  . get ( k )  )  ;  assert null ( " should be null" cache 2  . get ( k )  )  ;   string name = " infinispan" ;   transaction manager mgr =  testing util . get transaction manager ( cache 1  )  ;  mgr . begin (  )  ;  cache 1  . put ( k name )  ;  assert key locked correctly ( k "testcache" )  ;   string key 2  = "name" ;  cache 1  . put ( key 2  " vladimir" )  ;  assert key locked correctly ( key 2  "testcache" )  ;   string key 3  = "product" ;   string key 4  = "org" ;   map <  string  string >  new map = new  hash map <  string  string >  (  )  ;  new map . put ( key 3  " infinispan" )  ;  new map . put ( key 4  "j boss" )  ;  cache 1  . put all ( new map )  ;  assert locked ( get lock owner ( key 3  "testcache" )  key 3  )  ;  assert locked ( get lock owner ( key 4  "testcache" )  key 4  )  ;  if  ( use commit )  mgr . commit (  )  ;  else mgr . rollback (  )  ;  if  ( use commit )   {  assert equals ( name cache 1  . get ( k )  )  ;  assert equals ( " should have replicated" name cache 2  . get ( k )  )  ;   }  else  {  assert equals ( null cache 1  . get ( k )  )  ;  assert equals ( " should not have replicated" null cache 2  . get ( k )  )  ;   }  cache 2  . remove ( k )  ;  cache 2  . remove ( key 2  )  ;  cache 2  . remove ( key 3  )  ;  cache 2  . remove ( key 4  )  ;   }  
public void   (  )  throws io exception  {   string key = generate random string (  3 00 )  ;   string command = "add "  +  key  +  " 0 0  1 \r\nget a\r\n" ;   list <  string >  responses = send multi ( command  2  true )  ;  assert equals ( responses . size (  )   2  )  ;  assert true ( responses . get ( 0 )  . contains ( "client   error" )  )  ;  assert equals ( responses . get (  1  )  "end" )  ;   }  
private  file   ( final int tile )  {  return new  file ( output   dir "s   "  +  lane  +  "   " +  tile number formatter . format ( tile )  +  "   barcode . txt" +   ( compress   outputs  ?  " . gz" : "" )  )  ;   }  
public void   (  )  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . start offset ( 0 )  . max results (  2  )  . build (  )  ;   list <  user >  list = q . list (  )  ;  assert equals (  3  q . get result size (  )  )  ;  assert equals (  2  list . size (  )  )  ;   }  
@ override public void   (  )  {  if  ( is ready (  )  )   {  notifier . complete ( null )  ;   }   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {   test helper . track plugin errors (  )  ;  try  {  final  publish processor <  integer >  pp1 =  publish processor . create (  )  ;  final  pu
@ override @ suppress warnings ( "unchecked" )  public  < t > t[]   ( t[] array )  {  int size = collection . size (  )  ;  if  ( array . length  <  size )  array =  ( t[] )  array . new instance ( array . get class (  )  . get component type (  )  size )
@ test @ ignore ( " subscribers should not throw" )  public void   (  )  {   observable <  integer >  source =  observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   observer <  ?  super  integer >
@ override public  internal cache value < v >    (  )  {  return new  core immutables .  immutable internal cache value ( this )  ;   }  
@ test public void   (  )  {   test subscriber <  integer >  ts = new  test subscriber <  integer >  ( 3 )  ;  final  atomic long requested = new  atomic long (  )  ;   flowable . unsafe create ( new  publisher <  integer >  (  )  {  @ override public voi
public  string   (  )  {  return user name ;   }  
 memtable cleaner thread <  ?  >    (  runnable cleaner )  {  return cleaner  =  =  null  ?  null : new  memtable cleaner thread <  >  ( this cleaner )  ;   }  
private void   (  partition descriptor p0  partition descriptor p 1  )  throws  exception  {   object k0 = new  magic key ( cache ( p0 . node ( 0 )  )  cache ( p0 . node (  1  )  )  )  ;  cache ( 0 )  . put ( k0 0 )  ;   object k 1  = new  magic key ( cache ( p0 . node (  1  )  )  cache ( p 1  . node ( 0 )  )  )  ;  cache (  1  )  . put ( k 1   1  )  ;   object k 2  = new  magic key ( cache ( p 1  . node ( 0 )  )  cache ( p 1  . node (  1  )  )  )  ;  cache (  2  )  . put ( k 2   2  )  ;   object k 3  = new  magic key ( cache ( p 1  . node (  1  )  )  cache ( p0 . node ( 0 )  )  )  ;  cache (  3  )  . put ( k 3   3  )  ;   list <  address >  all members = advanced cache ( 0 )  . get rpc manager (  )  . get members (  )  ;  assert equals ( new  hash set <  >  ( partition handling manager ( 0 )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  1  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  2  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  3  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  eventually (  (  )   -  >   {  for  ( int i = 0 ;  i  <  num members in cluster ;  i +  +  )   {  if  ( partition handling manager ( i )  . get availability mode (  )   !  =   availability mode . available )   {  return false ;   }   }  return true ;   }   )  ;  split cluster ( p0 . get nodes (  )  p 1  . get nodes (  )  )  ;  partition ( 0 )  . assert degraded mode (  )  ;  partition (  1  )  . assert degraded mode (  )  ;  assert equals ( partition handling manager ( 0 )  . get last stable topology (  )  . get members (  )  all members )  ;  assert equals ( partition handling manager (  1  )  . get last stable topology (  )  . get members (  )  all members )  ;  assert equals ( partition handling manager (  2  )  . get last stable topology (  )  . get members (  )  all members )  ;  assert equals ( partition handling manager (  3  )  . get last stable topology (  )  . get members (  )  all members )  ;  partition ( 0 )  . assert key available for read ( k0 0 )  ;  partition (  1  )  . assert key available for read ( k 2   2  )  ;  if  ( partition handling  =  =   partition handling . deny   read   writes )   {  partition ( 0 )  . assert keys not available for read ( k 1  k 2  k 3  )  ;  partition (  1  )  . assert keys not available for read ( k0 k 1  k 3  )  ;   }  else  {   int stream . range ( 0  2  )  . for each ( i  -  >   {  partition ( i )  . assert key available for read ( k 1   1  )  ;  partition ( i )  . assert key available for read ( k 3   3  )  ;   }   )  ;  partition ( 0 )  . assert key not available for read ( k 2  )  ;  partition (  1  )  . assert key not available for read ( k0 )  ;   }  assert true ( data container ( p0 . node ( 0 )  )  . contains key ( k0 )  )  ;  assert false ( data container ( p0 . node ( 0 )  )  . contains key ( k 1  )  )  ;  assert false ( data container ( p0 . node ( 0 )  )  . contains key ( k 2  )  )  ;  assert true ( data container ( p0 . node ( 0 )  )  . contains key ( k 3  )  )  ;  assert true ( data container ( p0 . node (  1  )  )  . contains key ( k0 )  )  ;  assert true ( data container ( p0 . node (  1  )  )  . contains key ( k 1  )  )  ;  assert false ( data container ( p0 . node (  1  )  )  . contains key ( k 2  )  )  ;  assert false ( data container ( p0 . node (  1  )  )  . contains key ( k 3  )  )  ;  assert false ( data container ( p 1  . node ( 0 )  )  . contains key ( k0 )  )  ;  assert true ( data container ( p 1  . node ( 0 )  )  . contains key ( k 1  )  )  ;  assert true ( data container ( p 1  . node ( 0 )  )  . contains key ( k 2  )  )  ;  assert false ( data container ( p 1  . node ( 0 )  )  . contains key ( k 3  )  )  ;  assert false ( data container ( p 1  . node (  1  )  )  . contains key ( k0 )  )  ;  assert false ( data container ( p 1  . node (  1  )  )  . contains key ( k 1  )  )  ;  assert true ( data container ( p 1  . node (  1  )  )  . contains key ( k 2  )  )  ;  assert true ( data container ( p 1  . node (  1  )  )  . contains key ( k 3  )  )  ;  partition ( 0 )  . assert key available for write ( k0  -  1  )  ;  partition ( 0 )  . assert key not available for write ( k 1  )  ;  partition ( 0 )  . assert key not available for write ( k 2  )  ;  partition ( 0 )  . assert key not available for write ( k 3  )  ;  partition (  1  )  . assert key available for write ( k 2   -  1  )  ;  partition (  1  )  . assert key not available for write ( k0 )  ;  partition (  1  )  . assert key not available for write ( k 1  )  ;  partition (  1  )  . assert key not available for write ( k 3  )  ;  partition ( 0 )  . merge ( partition (  1  )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager ( 0 )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  1  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  2  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  assert equals ( new  hash set <  >  ( partition handling manager (  3  )  . get last stable topology (  )  . get members (  )  )  new  hash set <  >  ( all members )  )  ;  partition ( 0 )  . assert availability mode (  availability mode . available )  ;  assert expected value (  -  1  k0 )  ;  assert expected value (  1  k 1  )  ;  assert expected value (  -  1  k 2  )  ;  assert expected value (  3  k 3  )  ;  assert true ( data container ( p0 . node ( 0 )  )  . contains key ( k0 )  )  ;  assert false ( data container ( p0 . node ( 0 )  )  . contains key ( k 1  )  )  ;  assert false ( data container ( p0 . node ( 0 )  )  . contains key ( k 2  )  )  ;  assert true ( data container ( p0 . node ( 0 )  )  . contains key ( k 3  )  )  ;  assert true ( data container ( p0 . node (  1  )  )  . contains key ( k0 )  )  ;  assert true ( data container ( p0 . node (  1  )  )  . contains key ( k 1  )  )  ;  assert false ( data container ( p0 . node (  1  )  )  . contains key ( k 2  )  )  ;  assert false ( data container ( p0 . node (  1  )  )  . contains key ( k 3  )  )  ;  assert false ( data container ( p 1  . node ( 0 )  )  . contains key ( k0 )  )  ;  assert true ( data container ( p 1  . node ( 0 )  )  . contains key ( k 1  )  )  ;  assert true ( data container ( p 1  . node ( 0 )  )  . contains key ( k 2  )  )  ;  assert false ( data container ( p 1  . node ( 0 )  )  . contains key ( k 3  )  )  ;  assert false ( data container ( p 1  . node (  1  )  )  . contains key ( k0 )  )  ;  assert false ( data container ( p 1  . node (  1  )  )  . contains key ( k 1  )  )  ;  assert true ( data container ( p 1  . node (  1  )  )  . contains key ( k 2  )  )  ;  assert true ( data container ( p 1  . node (  1  )  )  . contains key ( k 3  )  )  ;  cache ( 0 )  . put ( k0  1 0 )  ;  cache (  1  )  . put ( k 1   1 00 )  ;  cache (  2  )  . put ( k 2   1 000 )  ;  cache (  3  )  . put ( k 3   1 0000 )  ;  assert expected value (  1 0 k0 )  ;  assert expected value (  1 00 k 1  )  ;  assert expected value (  1 000 k 2  )  ;  assert expected value (  1 0000 k 3  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  connectable flowable <  integer >  cf =  flowable .  <  integer > empty (  )  . publish (  )  ;  final  test subscriber <  integer >  ts
@ override public  config registry   (  )  {  return handle . get config (  )  ;   }  
@ test public void   (  )  throws  throwable  {  create table ( "create table %s  ( a int  b int  c int  primary key  ( a  b )  ) " )  ;  execute ( "create trigger if not exists trigger    1  on %s using '"  +   test trigger . class . get name (  )   +  "
public  string   (  string part name )  {   string result = null ;  if  ( is multi part request )   {  try  {   part p = http request . get part ( part name )  ;  if  ( p  !  =  null )  result = p . get content type (  )  ;   }  catch  (  io exception ioe )   {  log ( ioe )  ;   }  catch  (   servlet exception se )   {  log ( se )  ;   }  catch  (   illegal state exception ise )   {  log ( ise )  ;  throw ise ;   }   }  return result ;   }  
@ test ( expected =  null pointer exception . class )  public void   (  )  {   completable . complete (  )  . do on subscribe ( null )  ;   }  
@ override public boolean   (  )  {  return delegate . is created (  )  ;   }  
@ test public void   (  )  {   observable <  string >  source =  observable . empty (  )  ;   observable <  list <  string >  >  buffered = source . buffer ( 3 3 )  ;  buffered . subscribe ( observer )  ;   mockito . verify ( observer  mockito . never (  
@ test public void   (  )  {   string test group name = " test  group  ( 1 ) " ;   string test domain name = "localhost" ;   string test base32 group name =  string utils . encode base32 ( test group name )  ;  jid test jid = new jid ( test base32 group n
@ test public void   (  )  {  assert equals ( message instance . get message (  )  )  ;   }  
public static  http client context   (  )  {  return new  http client context ( new  basic http context (  )  )  ;   }  
@ override protected  < e >  cache stream < e >    (  cache collection < e >  entries )  {  return entries . stream (  )  . sequential distribution (  )  . disable rehash aware (  )  ;   }  
private  tunnel info   (  )  {  return get context (  )  . tunnel manager (  )  . select outbound tunnel (  )  ;   }  
@ override public void   (  )  {  assert true (  exception helper . add throwable ( error ex )  )  ;   }  
public void   (  session session  string presence text )  {   connection con = null ;   prepared statement pstmt = null ;  try  {  con = get connection (  )  ;  pstmt = con . prepare statement ( set   presence )  ;  pstmt . set string ( 1 presence text )  ;  pstmt . set string ( 2 session . get address (  )  . get node (  )  )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception e )   {   log . error ( " unable to update presence for "  +  session . get address (  )  e )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
private static boolean   (  method tree tree )  {  return  modifiers utils . has modifier ( tree . modifiers (  )   modifier . static )  ;   }  
@ override public  optional <  string >    (  )  {  return  optional . empty (  )  ;   }  
public static  string   (  )  {  return  system . get property ( "file . separator" )  ;   }  
@ override public  local tx invocation context   (  local transaction local transaction )  {  throw exception (  )  ;   }  
@ test public void   (  )  {  expect parser success ( "select foo . string  foo . component  foo . id from example .  bar foo" )  ;   }  
@ test ( expected exceptions =  cache configuration exception . class expected exceptions message reg exp = "ispn000 4  8  5 : . *" )  public void   (  )  throws io exception  {   string config =  testing util . wrapxml with schema ( " < cache - container
private static  string   (  class <  ?  >  clazz )  {  if  ( clazz . get annotation (  experimental feature . class )   !  =  null )   {  return experimental   prefix ;   }  if  ( clazz . get annotation (  beta feature . class )   !  =  null )   {  return beta   prefix ;   }  return "" ;   }  
@ override public  string   (  )  {  return address . get host address (  )  ;   }  
@ override protected void   (  stats update event event )  {  set value ( event )  ;   }  
public  annotated type builder < x >    (  class <  ?  extends  annotation >  annotation type )  {  type annotations . remove ( annotation type )  ;  return this ;   }  
public void   (  )  throws  exception  {  tm . begin (  )  ;  cache . remove ( "does not exist" )  ;  tm . commit (  )  ;  expect transaction boundaries ( true )  ;   }  
public boolean   (  )  {  return this . column   family  !  =  null ;   }  
public void   ( int parameter index  input stream x )  throws sql exception  {  pstmt . set ascii stream ( parameter index x )  ;   }  
@ override public  memory configuration   (  )  {  return new  memory configuration ( attributes . protect (  )  )  ;   }  
@ override public void   (  )  {   system . out . println ( "end" )  ;   }  
public double   (  )  {  return sstable metadata . compression ratio ;   }  
@ override public long   (  http response response  http context context )  {  long duration = super . get keep alive duration ( response context )  ;  if  ( duration  >  0 )   {  return duration ;   }  return timeout  =  =  0  ?   - 1 : timeout ;   }  
public int   (  )  {  return ec codewords per block * get num blocks (  )  ;   }  
public  set serializer < t >    (  )  {  return serializer ;   }  
public void   (  string index id )  {  this . index id = index id ;   }  
@ override public  socket binding   (  )  {  return  ( this . diagnostics socket binding  !  =  null )   ?  this . diagnostics socket binding . get value (  )  : null ;   }  
@ test public void   (  )  {  final  atomic integer calls = new  atomic integer (  )  ;   runnable task = new  runnable (  )  {  @ override public void run (  )  {  calls . get and increment (  )  ;   }   }   ;   test executor exec = new  test executor ( 
public static  string   ( @ nullable  string release date time )  {  if  ( release date time  =  =  null || release date time . length (  )   =  =  0 )   {  return null ;   }   instant instant ;  try  {  instant =  instant . parse ( release date time )  ;   }  catch  (   date time parse exception ignored )   {  try  {  instant =  local date . parse ( release date time )  . at start of day (  )  . to instant (  zone offset . utc )  ;   }  catch  (   date time parse exception e )   {  return null ;   }   }  return new  simple date format ( "yyyy"  locale . get default (  )  )  . format ( new  date ( instant . to epoch milli (  )  )  )  ;   }  
public int   (  string username )  {  return routing table . get routes ( new jid ( username server name null true )  null )  . size (  )  ;   }  
@ override public void   (  http servlet request request  http servlet response response )  throws  servlet exception  io exception  {   string image name = request . get parameter ( "image name" )  ;   string workgroup name =  (  string ) request . get s
@ override public void   (  disposable s )  {  if  (  disposable helper . validate ( this . s s )  )   {  this . s = s ;  actual . on subscribe ( this )  ;   }   }  
@ override public int   (  data input in  map <  string  set <  string >  >  map )  throws io exception  {  return 0 ;   }  
public static  < t > t   ( final  subject subject final java . security .  privileged exception action < t >  action )  throws java . security .  privileged action exception  {   stack <  subject >  stack = subject . get (  )  ;  if  ( stack  =  =  null )   {  stack = new  stack <  subject >  (  )  ;  subject . set ( stack )  ;   }  stack . push ( subject )  ;  try  {  return action . run (  )  ;   }  catch  (   exception e )   {  throw new  privileged action exception ( e )  ;   }  finally  {  stack . pop (  )  ;  if  ( stack . is empty (  )  )   {  subject . remove (  )  ;   }   }   }  
@ override public void   (  object output output  replace conditionally object )  throws io exception  {  output . write object ( object . old value )  ;   }  
@ suppress warnings ( "unchecked" )  @ override public void   (  throwable e )  {   object helper . require non null ( e "on error called with null .   null values are generally not allowed in 2 . x operators and sources . " )  ;  if  ( once . compare and
@ test public void   (  )  throws  exception  {   target host info target host info = new  target host info ( target host )  ;  assert equals ( " returned uri was not the expected uri" new uri ( target host )  target host info . get proxied host uri (  ) 
public  string   (  )  {  return result ;   }  
@ deprecated public static void   ( byte data[] int offset  boolean value )  {  if  ( value  =  =  null )  data[offset] = boolean   unknown ;  else data[offset] =  ( value . boolean value (  )   ?  boolean   true : boolean   false )  ;   }  
public void   ( byte data[] int offset int data size int type )  throws i2np message exception  {  if  ( type  !  =  message   type )  throw new i2np message exception ( " message type is incorrect for this message" )  ;  int cur index = offset ;     key =  hash . create ( data cur index )  ;  cur index +  =  hash . hash   length ;     from hash =  hash . create ( data cur index )  ;  cur index +  =  hash . hash   length ;  boolean tunnel specified =  ( data[cur index] & flag   tunnel )   !  =  0 ;  boolean reply key specified =  ( data[cur index] & flag   encrypt )   !  =  0 ;  switch  ( data[cur index] & flag   type   mask )   {  case flag   type   ls:    type =  type . ls ;  break ;  case flag   type   ri:    type =  type . ri ;  break ;  case flag   type   expl:    type =  type . expl ;  break ;  case flag   type   any: default :    type =  type . any ;  break ;   }  cur index +  +  ;  if  ( tunnel specified )   {     reply tunnel = new  tunnel id (  data helper . from long ( data cur index 4 )  )  ;  cur index +  = 4 ;   }  int num peers =  ( int )  data helper . from long ( data cur index 2 )  ;  cur index +  = 2 ;  if  (  ( num peers  <  0 )  ||  ( num peers  >  max   num   peers )  )  throw new i2np message exception ( " invalid number of peers  -  "  +  num peers )  ;   list <  hash >  peers = num peers  >  0  ?  new  array list <  hash >  ( num peers )  : null ;  for  ( int i = 0 ;  i  <  num peers ;  i +  +  )   {   hash p =  hash . create ( data cur index )  ;  cur index +  =  hash . hash   length ;  peers . add ( p )  ;   }     dont include peers = peers ;  if  ( reply key specified )   {  byte[] rk = new byte[ session key . keysize   bytes] ;   system . arraycopy ( data cur index rk 0  session key . keysize   bytes )  ;     reply key = new  session key ( rk )  ;  cur index +  =  session key . keysize   bytes ;  cur index +  +  ;  byte[] rt = new byte[ session tag . byte   length] ;   system . arraycopy ( data cur index rt 0  session tag . byte   length )  ;     reply tag = new  session tag ( rt )  ;   }   }  
public  connection manager   (  )  {  return  (  connection manager ) modules . get (  connection manager impl . class )  ;   }  
@ override public boolean   (  )  {  check readable bytes (  1  )  ;  return buffer . read boolean (  )  ;   }  
@ override public void   (  )  {  to . cancel (  )  ;   }  
@ test public void   (  )  {   list <  throwable >  list =  test helper . track plugin errors (  )  ;  try  {   crash dummy cd = new  crash dummy ( true 1 false false false false )  ;   safe subscriber <  object >  so = cd . to safe (  )  ;  so . on next 
@ test public void   (  )  {   connectable flowable <  integer >  cf =  flowable . just ( 1 )  . do on next ( new  consumer <  integer >  (  )  {  @ override public void accept (   integer v )  throws  exception  {  throw new  test exception ( " first" ) 
public void   ( int member count )  {  this . member count = member count ;   }  
public long   (  )  throws io exception  {  return record . file channel . size (  )  ;   }  
@ override public  string   (  )  {  return path ;   }  
public  date   (  )  {  return offer time ;   }  
@ override public  counter state   (  )  {  return old state ;   }  
public   (  entity region impl region  access delegate delegate )  {  super ( delegate )  ;  this . region = region ;   }  
@ override public  connection pool configuration   (  )  {  return new  connection pool configuration ( exhausted action lifo max active max total max wait max idle min idle num tests per eviction run time between eviction runs min evictable idle time tes
public int   (  )  {  return response ;   }  
@ override public final void   ( int b )  {  int newcount = count  +   1  ;  if  ( newcount  >  buf . length )   {  byte newbuf[] = new byte[get new buffer size ( buf . length newcount ) ] ;   system . arraycopy ( buf 0 newbuf 0 count )  ;  buf = newbuf ;
@ override public void   (  object output output  memcached metadata object )  throws io exception  {  output . write long ( object . flags )  ;  output . write object ( object . version )  ;  int number = numbers . get ( object . get class (  )   -  1  )
@ override public  byte buf   ( boolean value )  {  throw reject (  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish processor <  integer >  pp =  publish processor . create (  )  ;  final  test subscriber <  list <  integer >  >  ts = pp . to l
public void   ( long start time )  {  this . start time = start time ;   }  
public  string   (  )  {  return three prime ;   }  
public final void   (  )  throws  exception  {  test stats (  write operation . put  4   5   4   6   3  false false )  ;   }  
public void   (  string author )  {  this . author = author ;   }  
@ override public byte[]   (  data input in )  throws io exception  {  return new byte[0] ;   }  
private static boolean   (  parsed command line parsed command line  string name int index )  {  int size = parsed command line . get other properties (  )  . size (  )  ;   string last property = parsed command line . get last parsed property value (  )  ;  return  ( size  =  =  index && last property  =  =  null )  ||  ( size  =  =  index  +   1  && last property  !  =  null && name . starts with ( last property )  )  ;   }  
@ override public  path metadata   (  )  {  return path mixin . get metadata (  )  ;   }  
public void   (  string value )  {  params . add ( value )  ;  types . add (  types . varchar )  ;   }  
@ before public void   (  )  throws  exception  {  services = create kernel services builder ( new  infinispan subsystem dependencies initialization (  )  )  . set subsystem xml ( get subsystem xml (  )  )  . build (  )  ;   }  
public void   (  )  throws  exception  {  test (  1   1  )  ;   }  
public static  relay channel   ( final  string host final int min port final int max port )  throws io exception  {  int range = max port  -  min port ;  io exception be = null ;  for  ( int t = 0 ;  t  <  50 ;  t +  +  )   {  try  {  int a =  math . round (  ( int )  (  math . random (  )  * range )  )   +  min port ;  a = a % 2  =  =  0  ?  a : a  +  1 ;  return new  relay channel ( host a )  ;   }  catch  (   bind exception e )   {  be = e ;   }  catch  (  io exception e )   {  be = e ;   }   }  throw be ;   }  
@ override protected  configuration builder   ( long dist sync timeout )  {  if  ( delay  >  0 )  try  {   thread . sleep ( delay )  ;   }  catch  (   interrupted exception e )   {  throw new  cache exception ( e )  ;   }  return super . create topology c
@ override public int   (  session data data )  {  return 1 ;   }  
@ test public void   (  )  {   keyspace keyspace =  keyspace . open ( " keyspace 1 " )  ;   column family store cf store = keyspace . get column family store ( " standard long 1 " )  ;   mutation rm ;   decorated key key =  util . dk ( "key0" )  ;  rm = n
public void   (  )  throws  exception  {  remote (  )  . put ( "k" "v" )  ;  testk ( "v" )  ;   future <  string >  f = remote (  )  . get async ( "k" )  ;  test future ( f "v" )  ;  testk ( "v" )  ;   }  
protected void   (  string username )  {   user manager user manager =  user manager . get instance (  )  ;  try  {  user manager . get user ( username )  ;   }  catch  (   user not found exception unfe )   {  try  {   log . debug ( "jdbc auth provider:  automatically creating new user account for "  +  username )  ;   user manager . get user provider (  )  . create user ( username  string utils . random string ( 8 )  null null )  ;   }  catch  (   user already exists exception uaee )   {   }   }   }  
private void   ( final  mendelian violation detector .  result result )  {  if  ( vcf   dir  !  =  null )   {  log . info (  string . format ( " writing family violation vc fs to %s / " vcf   dir . get absolute path (  )  )  )  ;  final  variant context comparator vc comparator = new  variant context comparator ( input header . get (  )  . get contig lines (  )  )  ;  final  set < vcf header line >  header lines = new  linked hash set <  >  ( input header . get (  )  . get meta data in input order (  )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . mendelian   violation   key 1 vcf header line type .  string " type of mendelian violation . " )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   ac vcf header line count . a vcf header line type .  integer " original ac" )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   af vcf header line count . a vcf header line type .  float " original af" )  )  ;  header lines . add ( new vcf info header line (  mendelian violation detector . original   an 1 vcf header line type .  integer " original an" )  )  ;  for  (  final  ped file .  ped trio trio : ped file . get (  )  . values (  )  )   {  final  file output file = new  file ( vcf   dir io util . make file name safe ( trio . get family id (  )   +  io util . vcf   file   extension )  )  ;  log . info (  string . format ( " writing %s violation vcf to %s" trio . get family id (  )  output file . get absolute path (  )  )  )  ;  final  variant context writer out = new  variant context writer builder (  )  . set output file ( output file )  . unset option ( index   on   the   fly )  . build (  )  ;  final vcf header new header = new vcf header ( header lines  collection util . make list ( trio . get maternal id (  )  trio . get paternal id (  )  trio . get individual id (  )  )  )  ;  final  tree set <  variant context >  ordered violations = new  tree set <  >  ( vc comparator )  ;  ordered violations . add all ( result . violations (  )  . get ( trio . get family id (  )  )  )  ;  out . write header ( new header )  ;  ordered violations . for each ( out::add )  ;  out . close (  )  ;   }   }   }  
public long   (  )  {  return file size ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ override public  string   (  )  {  return " version request { "  +  "key = "  +  key  +  "  postpone = " +  postpone +  ' } ' ;   }  
@ test public void   (  )  throws  exception  {   query factory qf = get query factory (  )  ;   list <  integer >  ids =  arrays . as list (  1   3  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . having ( "id" )  . 
@ test ( expected =  protocol exception . class )  public void   (  )  throws  exception  {  final  http request request 1  = new  basic http request ( "get" " / " )  ;  request 1  . set authority ( new uri authority ( "host" )  )  ;   routing support . d
@ override public long   (  )  {  return    lastri publish time ;   }  
@ override public void   (  integer value )  {  assert false ( qd . is empty (  )  )  ;  qd . clear (  )  ;  assert true ( qd . is empty (  )  )  ;  qd . dispose (  )  ;   }  
@ override public  integer   (  )  {  return  ids . counter   configuration ;   }  
public void   (  datagram listener listener )  {  this . datagram listener = listener ;   }  
@ override public void   (  )  {  parent . inner close ( is left this )  ;   }  
@ test ( expected =  no such element exception . class )  public void   (  )  throws  throwable  {   observable <  string >  obs =  observable . empty (  )  ;   future <  string >  f = obs . to future (  )  ;  try  {  f . get (  )  ;   }  catch  (   execu
@ override public void   ( int id )  {  this . id = id ;   }  
@ override public  list   (  )  {  return  immutable list . of (  java debugging plugin rules definition . class  java debugging plugin check registrar . class )  ;   }  
@ override public  servlet context   (  )  {  return servlet context ;   }  
public  rate stat   (  )  {  return    invalid reply rate ;   }  
public void   ( double v )  throws io exception  {  delegate . write double ( v )  ;   }  
@ test public void   (  )  {   async subject <  object >  p =  async subject . create (  )  ;  final  test observer <  object >  to2 = new  test observer <  object >  (  )  ;   test observer <  object >  to1 = new  test observer <  object >  (  )  {  @ ov
@ override protected void   (  session data data  element command )  {   data form form = new  data form (  data form .  type . form )  ;  form . set title ( " delete workgroup" )  ;  form . add instruction ( " fill out this form to delete a workgroup . "
final void   ( final byte[] b )  throws io exception  {  assert b . length  =  =  byte count : " invalid number of bytes supplied to  rrd primitive . write method" ;  backend . write ( pointer b )  ;   }  
int   ( int arc index int ds index )  throws  rrd exception  {   node cdp node =  util .  xml . get first child node ( arc nodes[arc index] "cdp   prep" )  ;   node[] ds nodes =  util .  xml . get child nodes ( cdp node "ds" )  ;  return  util .  xml . get child value as int ( ds nodes[ds index] "unknown   datapoints" )  ;   }  
@ override public long   (  )  {  return body  !  =  null  ?  body . length : 0 ;   }  
public  string   (  )  {  return cp . to string (  )  ;   }  
public  list <  string >    (  )  {  return exceptions ;   }  
public void   (  )  {  test get descriptor base ( "int property"  integer . type )  ;   }  
public void   ( final  file file )  {  try  {  final  buffered writer out = new  buffered writer ( new  output stream writer ( io util . open file for writing ( file )  )  )  ;  final  format util format = new  format util (  )  ;  if  ( this . header  !  =  null )   {  final sam text header codec codec = new sam text header codec (  )  ;  codec . encode ( out this . header )  ;   }  out . write ( "#chromosome\tposition\tname\tmajor   allele\tminor   allele\tmaf\tanchor   snp\tpanels" )  ;  out . new line (  )  ;  final  list <  haplotype map file entry >  entries = new  array list <  >  (  )  ;  for  (  final  haplotype block block : this . get haplotypes (  )  )   {   string anchor = null ;  final  sorted set <  snp >  snps = new  tree set <  >  ( block . get snps (  )  )  ;  for  (  final  snp snp : snps )   {  entries . add ( new  haplotype map file entry ( snp . get chrom (  )  snp . get pos (  )  snp . get name (  )  snp . get allele1 (  )  snp . get allele2 (  )  snp . get maf (  )  anchor snp . get fingerprint panels (  )  )  )  ;  if  ( anchor  =  =  null )   {  anchor = snp . get name (  )  ;   }   }   }   collections . sort ( entries )  ;  for  (  final  haplotype map file entry entry : entries )   {  out . write ( entry . chromosome  +  "\t" )  ;  out . write ( format . format ( entry . position )   +  "\t" )  ;  out . write ( entry . snp name  +  "\t" )  ;  out . write (  ( char ) entry . major allele  +  "\t" )  ;  out . write (  ( char ) entry . minor allele  +  "\t" )  ;  out . write ( format . format ( entry . minor allele frequency )   +  "\t" )  ;  if  ( entry . anchor snp  !  =  null )   {  out . write ( entry . anchor snp )  ;   }  out . write ( "\t" )  ;  if  ( entry . get panels (  )   !  =  null )   {  out . write ( entry . get panels (  )  )  ;   }  out . new line (  )  ;   }  out . flush (  )  ;  out . close (  )  ;   }  catch  (  io exception ioe )   {  throw new  picard exception ( " error writing out haplotype map to file: "  +  file . get absolute path (  )  ioe )  ;   }   }  
private int   ( byte[] b int off int len )  {  if  ( is end reached (  )  )  return  -  1  ;  int remaining = get bytes remaining in chunk (  )  ;  if  ( remaining  =  =  0 )   {  get chunk (  )  ;  remaining = get bytes remaining in chunk (  )  ;   }  int bytes to read =  math . min ( len remaining )  ;   system . arraycopy ( current buffer local index b off bytes to read )  ;  local index +  = bytes to read ;  index +  = bytes to read ;  return bytes to read ;   }  
@ override public void   ( boolean checked )  {   view child = get child at ( 0 )  ;  if  ( child instanceof  checkable )   (  (  checkable ) child )  . set checked ( checked )  ;   }  
private static  string   ( boolean spring injection annotated  type least specific type )  {  if  ( spring injection annotated && least specific type . is ( "java . lang .  iterable" )  )   {  return "java . util .  collection" ;   }  return least specific type . fully qualified name (  )  . replace ( '$' ' . ' )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  array list <  string >  results = new  array list <  string >  (  )  ;   observable . unsafe create ( new  observable source <  integer >  (  )  {  @ override public void subscribe (   ob
public void   ( final  string name )  {  this . name = name ;   }  
public  byte buffer   (  byte buffer serialized map  byte buffer serialized key  abstract type key type )  {  try  {   byte buffer input = serialized map . duplicate (  )  ;  int n = read collection size ( input  server . version    3  )  ;  for  ( int i = 0 ;  i  <  n ;  i +  +  )   {   byte buffer kbb = read value ( input  server . version    3  )  ;   byte buffer vbb = read value ( input  server . version    3  )  ;  int comparison = key type . compare ( kbb serialized key )  ;  if  ( comparison  =  =  0 )  return vbb ;  else if  ( comparison  >  0 )  return null ;   }  return null ;   }  catch  (   buffer underflow exception e )   {  throw new  marshal exception ( " not enough bytes to read a map" )  ;   }   }  
@ test public void   (  )  throws  exception  {  request . set header ( " user -  agent" "my - agent /  1  . 0" )  ;  origin response . set header ( " cache -  control" "public  max - age =  3  6 00" )  ;  origin response . set header ( " vary" " user -  
public int   (  )  {  return    lookup type ;   }  
private static boolean   (  tree tree )  {  if  (  ! tree . is (  tree .  kind . variable )  )   {  return false ;   }   variable tree var =  (  variable tree ) tree ;  return is string ( var . type (  )  . symbol type (  )  )  ;   }  
@ override public void   ( int index t element )  {  list . add ( index element )  ;  lazy set ( list . size (  )  )  ;   }  
public  session config   (  destination    dest )  {  return null ;   }  
@ override public void   (  tree tree )  {  if  ( has semantic (  )  )   {  if  ( tree . is (  kind . throw   statement )  )   {   expression tree expression tree =  (  (  throw statement tree ) tree )  . expression (  )  ;  raise issue on npe ( expressio
private void   ( boolean commit )  {  assert recovery ops ( 0 )  . show in doubt transactions (  )  . is empty (  )  ;   transaction table tt0 = cache ( 0 )  . get advanced cache (  )  . get component registry (  )  . get component (  transaction table . class )  ;   embedded transaction dummy transaction = begin and suspend tx ( cache ( 0 )  )  ;  prepare transaction ( dummy transaction )  ;  assert tt0 . get local tx count (  )   =  =   1  ;  try  {  if  ( commit )   {  commit transaction ( dummy transaction )  ;   }  else  {  rollback transaction ( dummy transaction )  ;   }  assert false : "exception expected" ;   }  catch  (   exception e )   {   }  assert equals ( tt0 . get local tx count (  )   1  )  ;  assert equals ( count in doubt tx ( recovery ops ( 0 )  . show in doubt transactions (  )  )   1  )  ;  assert equals ( count in doubt tx ( recovery ops (  1  )  . show in doubt transactions (  )  )   1  )  ;   }  
@ override public long   (  token token )  {  return empty   size  +   object sizes . size of array (  (  (  bytes token ) token )  . token )  ;   }  
public boolean   (  object key )  {  return this . key  =  =  key || this . key . equals ( key )  ;   }  
@ before public void   (  )  {  impl = new  response protocol compliance (  )  ;   }  
public int   (  )  throws  jsp exception  {  original name = get name (  )  ;  original property = get property (  )  ;   http servlet request request =  (  http servlet request ) page context . get request (  )  ;   nested property helper . set nested properties ( request this )  ;  return super . do start tag (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  http host target = new  http host ( "somehost"  8 0 )  ;  final  http route route = new  http route ( target )  ;   mockito . when ( conn factory . create connection (  mockito .  <  socket > any (  
@ override public  string   (  )  {  return "bob" ;   }  
@ test public void   (  )  {  assert equals (  date path . class q temporal test    my entity . my entity . date . get class (  )  )  ;  assert equals (  time path . class q temporal test    my entity . my entity . time . get class (  )  )  ;   }  
protected final void   ( long offset byte b )  {  check position ( offset  1  )  ;   memory util . set byte ( peer  +  offset b )  ;   }  
public void   (  )  throws  exception  {   interpreter interpreter = get interpreter (  )  ;   string session id = " 1  2  3 " ;   map <  string  string >  response = interpreter . execute ( session id "put 'a' 'a' ; " )  ;  assert true ( response . contains key (  result keys . error . to string (  )  )  )  ;   }  
@ transient public boolean   (  )  {  return  ( parent  =  =  null )  ;   }  
private  input stream   (  )  {  return streams[index] ;   }  
public void   (  date creation date )  {  this . creation date = new  date ( creation date . get time (  )  )  ;   }  
  (  default subscriber <  string >  observer int num strings to send )  {  this . observer = observer ;  this . num strings to send = num strings to send ;   }  
@ override public  object   (  invocation context ctx  put key value command command )  throws  throwable  {  if  (  ! command . has flag (  flag . put   for   external   read )  )   {  begin invalidating ( ctx command . get key (  )  )  ;   }  return inv
@ test cache permission (  authorization permission . bulk   read )  public void   (  secure cache <  string  string >  cache )  {  cache . get all (  collections . empty set (  )  )  ;   }  
@ override public  string   (  )  throws io exception  {  return object input . read line (  )  ;   }  
@ override public boolean   (  principal user )  {  throw new  unsupported operation exception (  )  ;   }  
public void   (  string exception stack )  {  this . exception stack = exception stack ;   }  
public static  string   ( byte buf[] int len )  {  if  ( buf  =  =  null )  buf = empty   buffer ;   string builder out = new  string builder (  )  ;  if  ( len  >  buf . length )   {  for  ( int i = 0 ;  i  <  len  -  buf . length ;  i +  +  )  out . append ( "00" )  ;   }  int min =  math . min ( buf . length len )  ;  for  ( int i = 0 ;  i  <  min ;  i +  +  )   {  int bi = buf[i] & 0xff ;  if  ( bi  <  16 )  out . append ( '0' )  ;  out . append (  integer . to hex string ( bi )  )  ;   }  return out . to string (  )  ;   }  
@ test public void   (  )  throws  exception  {  byte[] temp = null ;   properties orig = new  properties (  )  ;   byte array output stream baos = new  byte array output stream (  )  ;  orig . set property ( "key1" "val1" )  ;  orig . set property ( "key
public void   (  )  {  wait for cluster to form (  )  ;   configuration builder builder = new  configuration builder (  )  ;  builder . clustering (  )  . cache mode (  cache mode . dist   sync )  ;   configuration configuration = builder . build (  )  ;  manager ( 0 )  . administration (  )  . with flags (  cache container admin .  admin flag . permanent )  . create cache ( "a" configuration )  ;  wait for cluster to form ( "a" )  ;  check consistency across cluster ( "a" configuration )  ;  manager (  1  )  . administration (  )  . create cache ( "b" configuration )  ;   testing util . kill cache managers ( this . cache managers )  ;  cache managers . clear (  )  ;  create stateful cache manager ( "a" false )  ;  check consistency across cluster ( "a" configuration )  ;  create stateful cache manager ( "b" true )  ;  check consistency across cluster ( "a" configuration )  ;  check cache existence across cluster ( "b" false )  ;  manager ( 0 )  . administration (  )  . with flags (  cache container admin .  admin flag . permanent )  . create cache ( "c" configuration )  ;  check consistency across cluster ( "c" configuration )  ;  create stateful cache manager ( "c" false )  ;  check consistency across cluster ( "a" configuration )  ;   }  
public  instrumenting cache <  key cache key  row index entry >    (  )  {  return key cache ;   }  
public void   (  )  {   map map = new  hash map (  )  ;  map . put ( "foo 1 " "bar 1 " )  ;  map . put ( "foo 2 " "bar 2 " )  ;  request . set attribute ( "attr" map )  ;  try  {  map = tagutils . compute parameters ( page context null null null null "attr" null "request" false )  ;   }  catch  (   jsp exception e )   {  fail ( " jsp exception: "  +  e )  ;   }  assert not null ( " map is not null" map )  ;  assert equals ( " two parameter in the returned map"  2  map . size (  )  )  ;  assert true ( " parameter foo 1  present" map . contains key ( "foo 1 " )  )  ;  assert equals ( " parameter foo 1  value" "bar 1 "  (  string ) map . get ( "foo 1 " )  )  ;  assert true ( " parameter foo 2  present" map . contains key ( "foo 2 " )  )  ;  assert equals ( " parameter foo 2  value" "bar 2 "  (  string ) map . get ( "foo 2 " )  )  ;   }  
@ test public void   (  )  {  s1 . on next ( "a" )  ;  s1 . on next ( "b" )  ;  s1 . on complete (  )  ;  s2 . on next ( "1" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s2 . on next ( "2" )  ;  in order . verify ( observer
@ override public void   (  integer .  .  .  values )  {  if  ( progress bar  =  =  null )   {  return ;   }  progress bar . set indeterminate ( values[0] . equals ( values[ 1 ] )  )  ;  progress bar . set max ( values[0] )  ;  progress bar . set progress
private static  list <  field >    (  class clazz )  {  final  list <  field >  fields = new  array list <  >  (  )  ;  fields . add all (  arrays . as list ( clazz . get declared fields (  )  )  )  ;  final  class super class = clazz . get superclass (  )  ;  if  ( super class  !  =  null )  fields . add all ( get all fields ( super class )  )  ;  return fields ;   }  
 data store   (  )  {  return    ds ;   }  
public boolean   (  )  {  return upsert disabled ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   column mapper big integer mapper = new  column mapper big integer (  8  )  ;  mapper . index value ( "test" 0 . 0f )  ;   }  
public static  array list   (  )  {  return conference list ;   }  
@ override public  header   ( final  string name )  {  if  ( request   method   header   name . equals ignore case ( name )  )   {  return null ;   }  return response headers . get first header ( name )  ;   }  
public void   (  )  {   string actual ;  actual =  rfc822 output . get html body ( html   full   body )  ;  assert equals ( html   full   result actual )  ;  actual =  rfc822 output . get html body ( html   body   body )  ;  assert equals ( html   body   result actual )  ;  actual =  rfc822 output . get html body ( html   no   body   body )  ;  assert equals ( html   no   body   result actual )  ;   }  
public static int   (  )  {  return conf . inter   dc   stream   throughput   outbound   megabits   per   sec ;   }  
@ test public void   (  )  throws  exception  {  save some citizens (  )  ;  cleanup cache (  )  ;  time   service . advance (  1  )  ;  with tx session ( s  -  >   {   state france =  read write test . this . get state ( s " ile de  france" )  ;   criter
public x509 certificate[]   (  )  {  return new x509 certificate[0] ;   }  
@ override public  string   (  )  {  return    context . get property (  geoip . prop   ip   country )  ;   }  
public  string   (  inet address endpoint )  {   string[] info = get endpoint info ( endpoint )  ;  assert info  !  =  null : " no location defined for endpoint "  +  endpoint ;  return info[0] ;   }  
protected  abstract type   (  )  {  return base cfs . get comparator (  )  . as abstract type (  )  ;   }  
public  audit manager   (  )  {  return  (  audit manager ) modules . get (  audit manager impl . class )  ;   }  
public boolean   (  string hostname  destination d  properties options )  {   destination old = lookup ( hostname options null )  ;  if  (  ! d . equals ( old )  )  return false ;  return remove ( hostname options )  ;   }  
public  string   (  )  {  return  ( this . type )  ;   }  
private  memcached client   (  string k )  {  return get cache that ( k true )  ;   }  
public void   (  )  {  final  attachment service .  download queue dq = new  attachment service .  download queue (  )  ;  final  attachment service .  download request dr = new  attachment service .  download request (  attachment service . priority   foreground 1 )  ;  boolean result = dq . add request ( dr )  ;  assert true ( result )  ;  assert equals ( 1 dq . get size (  )  )  ;  assert false ( dq . is empty (  )  )  ;  result = dq . add request ( dr )  ;  assert true ( result )  ;  assert equals ( 1 dq . get size (  )  )  ;  assert false ( dq . is empty (  )  )  ;   }  
@ override protected void   (  method invocation tree mit )  {  if  ( is in catch ( mit )  )   {  report issue ( mit " remove this failure assertion and simply add the exception type to the method signature . " )  ;   }   }  
public  input stream   (  file file )  throws  file not found exception  {  return file  !  =  null  ?  get input ( file . get path (  )  )  : null ;   }  
public void   (  )  throws  exception  {  do test (  test write operation . replace   exact )  ;   }  
private void   ( int i  composite start  composite end long marked at int del time )  {  if  ( starts[i]  !  =  null )  boundary heap size -  = starts[i] . unshared heap size (  )   +  ends[i] . unshared heap size (  )  ;  starts[i] = start ;  ends[i] = end ;  marked ats[i] = marked at ;  del times[i] = del time ;  boundary heap size +  = start . unshared heap size (  )   +  end . unshared heap size (  )  ;   }  
@ override protected void   (  )  throws  throwable  {   configuration builder builder =  abstract cache test . get default clustered cache config (  cache mode . dist   sync false )  ;  create clustered caches ( ncaches builder )  ;   }  
boolean   (  )  {  return    is shutdown ;   }  
@ override public void   (  object output output )  throws io exception  {   marshall util . marshall string ( cache name output )  ;   marshall util . marshall enum ( type output )  ;  switch  ( type )   {  case join: output . write object ( sender )  ; 
@ test public void   (  )  throws  exception  {  final  string header name = " accept -  ranges" ;  origin response . set header ( header name "bytes" )  ;  test does not modify header on responses ( header name )  ;   }  
public void   (  set <  category >  child categories )  {  this . child categories = child categories ;   }  
protected void   ( long total requests )  {  this . total requests = total requests ;   }  
@ override protected  string   (  )  {  return joining   node   jgrousp   config   krb   fail ;   }  
@ override public void   (  )  {  if  ( windows . decrement and get (  )   =  =  0 )   {   disposable helper . dispose ( upstream )  ;   }   }  
  ( boolean functional  performer action )  {  this . functional = functional ;  this . action = action ;   }  
public void   ( boolean export direct foreign keys )  {  this . export direct foreign keys = export direct foreign keys ;   }  
@ override public  serializer   (  )  {  return module . get (  entity serializer . class )  ;   }  
public  string   (  )  {  return value ;   }  
@ override public boolean   (  )  {  return false ;   }  
public void   (  string node id )  throws  hibernate exception  {  if  ( node id  =  =  null )   {  throw new  hibernate exception ( "node id not configured" )  ;   }  this . node id = node id ;   }  
public int   (  public key target  session key key )  {  return 0 ;   }  
public void   (  query response query result )  {  try  {  byte[] bytes = mapper . writer with default pretty printer (  )  . write value as bytes ( query result )  ;  content as bytes ( bytes )  ;   }  catch  (  io exception e )   {  throw new  cache exception ( " invalid query result" )  ;   }   }  
public  byte buffer   (  )  {  return    read bufs . poll (  )  ;   }  
public   ( final uri scheme scheme )  {  super ( scheme )  ;   }  
public  list <  name value pair >    (  )  {  return this . parameters ;   }  
@ test public void   (  )  throws  exception  {   model node op = get operation ( "get - proto - schema - names" )  ;   model node result = controller . execute ( op )  ;  assert equals ( success result . get ( outcome )  . as string (  )  )  ;  op = get 
@ test public void   (  )  {   bad type parameter name check check = new  bad type parameter name check (  )  ;  check . format = "^[a - za - z0 -  9    ]*$" ;   java check verifier . verify no issue ( "src / test / files / checks / naming /  bad generic 
public  list <  range <  token >  >    (  string keyspace name  inet address endpoint )  {   list <  range <  token >  >  ranges = new  array list <  range <  token >  >  (  )  ;  for  (   map .  entry <  range <  token >   inet address >  entry : get pending rangesmm ( keyspace name )  . entries (  )  )   {  if  ( entry . get value (  )  . equals ( endpoint )  )   {  ranges . add ( entry . get key (  )  )  ;   }   }  return ranges ;   }  
public  string   (  )  {  return code ;   }  
public void   (  )  throws  exception  {   cache <  magic key  object >  cache 1  = cache ( 0 "atomic" )  ;   magic key key = new  magic key ( "key" cache 1  )  ;  get atomic map ( cache 1  key )  ;  expect exception (  illegal state exception . class  (  )   -  >  get fine grained atomic map ( cache 1  key )  )  ;   }  
public void   (  string gadu email address )  {  this . gadu email address = gadu email address ;   }  
public void   (  offline message strategy .  type type )  {  if  ( type  =  =  null )   {  throw new  illegal argument exception (  )  ;   }   offline message strategy . type = type ;   jive globals . set property ( "xmpp . offline . type" type . to string (  )  )  ;   }  
@ override protected  comparator <  comparable[] >    (  )  {  return create filter (  )  . get object filter (  )  . get comparator (  )  ;   }  
@ override public void   (  )  {     primary . set reduced (  )  ;   }  
private static boolean   ( @ nullable  object default value  tree value set )  {  if  ( value set . is (  tree .  kind . string   literal )  )   {  return  literal utils . trim quotes (  (  (  literal tree ) value set )  . value (  )  )  . equals ( default value )  ;   }  else if  ( value set . is (  tree .  kind . int   literal )  )   {   integer int literal value =  literal utils . int literal value (  (  literal tree ) value set )  ;  return int literal value  !  =  null && int literal value . equals ( default value )  ;   }  return false ;   }  
@ test ( expected =  parse exception . class )  public void   (  )  throws  exception  {  final  char array buffer buffer = new  char array buffer (  6  4  )  ;  buffer . append ( " this  =  that" )  ;  final  parser cursor cursor = new  parser cursor ( 0
public  media type   (  rate limit list active rate limits  media type media type  output stream output stream )  {  try  {  final  limits limits = new  limits (  )  ;  limits . set rates ( active rate limits )  ;  final  byte array output stream bos = new  byte array output stream (  )  ;  response   transformer . entity as xml ( limits bos )  ;  final  limits response mime type writer response writer = new  limits response mime type writer ( response   transformer )  ;  return response writer . write limits response ( bos . to byte array (  )  media type output stream )  ;   }  catch  (   exception ex )   {  log . error ( " failed to serialize limits upon user request .   reason: "  +  ex . get message (  )  ex )  ;  throw new  rate limiting serialization exception ( " failed to serialize limits upon user request .   reason: "  +  ex . get message (  )  ex )  ;   }   }  
public int   (  )  {  return id ;   }  
public void   (  string nickname )  {  this . nickname = nickname ;  if  ( disconnected mode )   {  return ;   }   connection con = null ;   prepared statement pstmt = null ;  try  {  con =  db connection manager . get connection (  )  ;  pstmt = con . prepare statement ( set   nickname )  ;  if  ( nickname  !  =  null )   {  pstmt . set string ( 1 nickname )  ;   }  else  {  pstmt . set null ( 1  types . varchar )  ;   }  pstmt . set long ( 2 registrationid )  ;  pstmt . execute update (  )  ;   }  catch  (  sql exception sqle )   {   log . error ( sqle )  ;   }  finally  {   db connection manager . close connection ( pstmt con )  ;   }   }  
public void   (  string anchor )  {  this . anchor = anchor ;   }  
public  illumina lane tile code   (  )  {  return lane tile code ;   }  
public void   ( final  font small font )  throws  rrd exception  {  this . set font ( fonttag   default small font )  ;   }  
@ managed attribute ( description = " retrieves the x - site view . " display name = " cross site  ( x - site )  view" data type =  data type . trait )  public  string   (  )  {   set <  string >  sites view = t . get sites view (  )  ;  return sites view
@ test public void   (  )  {   exception exception = new  exception ( "test" )  ;   observable <  integer >  o =  observable . error ( exception )  ;   observable <  integer >  dematerialize = o . materialize (  )  . dematerialize (  )  ;   observer <  in
@ override public  remote store configuration   (  )  {   list <  remote server configuration >  remote servers = new  array list <  remote server configuration >  (  )  ;  for  (   remote server configuration builder server : servers )   {  remote server
public static void   (  string default record directory )  throws  parse exception  {  check permission ( default record directory true )  ;   recorder . default record directory = default record directory ;   logger . println ( " default recording directory set to "  +  default record directory )  ;   }  
@ test public void   (  )  {   type substitution substitution = new  type substitution (  )  ;  assert that ( substitution . size (  )  )  . is equal to ( 0 )  ;  assert that ( substitution . substitution entries (  )  )  . is empty (  )  ;  assert that (
@ override public  string   (  )  {  return get name (  )   +  " { "  +  this . state +  " " +  challenge +  ' } ' ;   }  
public void   (  )  throws  exception  {  do topology change afterx site state transfer (  topology event . leave )  ;   }  
@ override public void   (  string cache name  availability mode availability mode )  throws  exception  {   cache topology control command .  type type =  cache topology control command .  type . availability   mode   change ;   replicable command comman
private  router address   ( boolean isi pv6 )  {  synchronized  (    rebuild lock )   {  return isi pv6  ?     current ourv6 address :    current ourv4 address ;   }   }  
public  property path <  type descriptor >    (  )  {  return property path ;   }  
public static int   (  )  {  return conf . concurrent   writes ;   }  
public static  datastore access control   (  distributed datastore configuration config  list <  inet address >  cluster members )  {   list <  inet address >  host access list = new  linked list <  >  (  )  ;  boolean allow all = config . get allowed hosts (  )  . is allow all (  )  ;  host access list . add all ( cluster members )  ;  if  (  ! allow all )   {  host access list . add all ( get configured allowed hosts ( config )  )  ;   }  if  ( allow all )   {  log . info ( " the distributed datastore component is configured in allow - all mode meaning that any host can access  store and delete cached objects . " )  ;   }  else  {  log . info ( " the distributed datastore component has access controls configured meaning that only the configured hosts and cluster members "  +  "can access  store and delete cached objects . " )  ;   }  log . debug ( " allowed  hosts: "  +  host access list . to string (  )  )  ;  return new  datastore access control ( host access list allow all )  ;   }  
@ test public void   (  )  throws  exception  {   remote cache <  integer  string >  remote cache = clients . get ( 0 )  . get cache (  )  ;  populate cache ( cache   size i  -  >  "value" remote cache )  ;   set <  map .  entry <  object  object >  >  en
@ deprecated public boolean   (  )  {  return    delay requested ;   }  
public  string   (  )  {  return description ;   }  
public void   (  )  {  assert ordered events ( local 2  super::test local empty get then put create ( "one" )  )  ;   }  
public void   (  map parameter map )  {  this . parameter map = parameter map ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  publish subject <  integer >  ps =  publish subject . create (  )  ;  final  test observer <  boolean >  to =  observable . sequence equ
protected  class <  ?  extends  region factory >    (  )  {  return  test infinispan region factory . class ;   }  
public static  string   ( final  http message r final  string name )  {  if  ( is single header ( name )  )   {  final  header h = r . get first header ( name )  ;  return  ( h  !  =  null )   ?  h . get value (  )  : null ;   }  final  string builder buf = new  string builder (  )  ;  boolean first = true ;  for  (  final  header h : r . get headers ( name )  )   {  if  (  ! first )   {  buf . append ( "  " )  ;   }  buf . append ( h . get value (  )  . trim (  )  )  ;  first = false ;   }  return buf . to string (  )  ;   }  
public  map <  string  object >    (  )  {  return value ;   }  
private static void   (  node <  ?   ?  >  node int depth  string builder sb boolean details )  {  for  (   node <  ?   ?  >  child : node . get children (  )  )   {  for  ( int i = 0 ;  i  <  depth ;  i +  +  )  sb . append ( " " )  ;  sb . append ( " +  " )  ;  sb . append ( child . get fqn (  )  . get last element as string (  )  )  . append (  fqn . separator )  ;  if  ( details )  sb . append ( " " )  . append ( child . get data (  )  )  ;  sb . append ( "\n" )  ;  add children ( child depth  +   1  sb details )  ;   }   }  
public  string   (  )  {  return  ( servlet path )  ;   }  
public  string   (  )  {  return cache name string ;   }  
protected  writer   (  output stream out stream  string encoding )  throws  unsupported encoding exception  {  return new  buffered writer ( new  output stream writer ( out stream encoding )  )  ;   }  
@ test public void   (  )  {  final  runtime exception e = new  runtime exception (  )  ;   flowable . just ( 1 2 3 )  . scan with ( throwing callable ( e )  sum )  . test (  )  . assert error ( e )  . assert no values (  )  ;   }  
@ override public  map < k v >    (  set <  ?  >  keys )  {  return cache . get all ( keys )  ;   }  
@ test public void   (  )  throws  interrupted exception  {  final  count down latch latch = new  count down latch ( 1 )  ;  final  count down latch unsubscribe latch = new  count down latch ( 1 )  ;  final  atomic integer counter = new  atomic integer ( 
@ override public  builder <  ?  >    (  custom store configuration template )  {  super . read ( template )  ;  return this ;   }  
@ override public boolean   (  )  {  return d . is disposed (  )  ;   }  
public static boolean   (  configuration conf )  {  return  boolean . parse boolean ( conf . get ( output   local   dc   only "false" )  )  ;   }  
@ before public void   (  )  throws  exception  {  rest = new rest helper (  )  ;  rest . add server ( server . getrest endpoint (  )  . get inet address (  )  . get host name (  )  server . getrest endpoint (  )  . get context path (  )  )  ;   }  
public void   (  address address )  {  this . addr = address ;   }  
public  auth cache   (  )  {  return get attribute ( auth   cache  auth cache . class )  ;   }  
@ override public  class <  ?  >    ( int index )  {  return parameter types[index] ;   }  
@ override public void   (  if statement tree tree )  {   expression visitor expression visitor = new  expression visitor ( parameter symbol )  ;  tree . condition (  )  . accept ( expression visitor )  ;  if  ( expression visitor . type checked )   {  ty
@ override public void   (  object output output  byte buffer impl b )  throws io exception  {   unsigned numeric . write unsigned int ( output b . length )  ;  output . write ( b . buf b . offset b . length )  ;   }  
static  rpc manager   ( final  advanced cache <  ?   ?  >  cache )  {   get cache rpc manager action action = new  get cache rpc manager action ( cache )  ;  return do privileged ( action )  ;   }  
@ test ( expected =  unsupported operation exception . class )  public void   (  )  {   observable . never (  )  . blocking latest (  )  . iterator (  )  . remove (  )  ;   }  
public void   (  iterable <  cache entry event <  ?  extends k  ?  extends v >  >  events )  throws  cache entry listener exception  {  for  (   cache entry event <  ?  extends k  ?  extends v >  event : events )   {  assert equals (  event type . created event . get event type (  )  )  ;  this . created . increment and get (  )  ;   }   }  
private static  projection map   (  )  {  if  ( s attachment map  =  =  null )   {  s attachment map =  projection map . builder (  )  . add ( ui provider .  attachment columns . name  attachment columns . filename )  . add ( ui provider .  attachment columns . size  attachment columns . size )  . add ( ui provider .  attachment columns . uri uri with id ( "uiattachment" )  )  . add ( ui provider .  attachment columns . content   type  attachment columns . mime   type )  . add ( ui provider .  attachment columns . state  attachment columns . ui   state )  . add ( ui provider .  attachment columns . destination  attachment columns . ui   destination )  . add ( ui provider .  attachment columns . downloaded   size  attachment columns . ui   downloaded   size )  . add ( ui provider .  attachment columns . content   uri  attachment columns . content   uri )  . add ( ui provider .  attachment columns . flags  attachment columns . flags )  . build (  )  ;   }  return s attachment map ;   }  
public void   ( int bonus )  {     integration bonus = bonus ;   }  
@ test public void   (  )  {   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  final  string[] o =  { "1" "3" "5" "7" }  ;  final  string[] e =  { "2" "4" "6" }  ;  final  flowable <  string >  odds =  flowable . from array ( o 
public boolean   (  )  {  return this . serial   consistency   level  !  =  null ;   }  
@ test public void   (  )  {   test resource maybe observer <  integer >  rmo = new  test resource maybe observer <  integer >  (  )  ;  assert false ( rmo . is disposed (  )  )  ;   disposable d =  disposables . empty (  )  ;  rmo . add ( d )  ;  assert 
@ before method public void   (  )  {  n = new  cache notifier impl (  )  ;  mock cache = mock (  encoder cache . class returns   deep   stubs )  ;  when ( mock cache . get advanced cache (  )  . get key data conversion (  )  )  . then return (  data conv
@ override public int   (  )  throws xa exception  {  if  ( trace )  log . trace ( "start called" )  ;  return tx timeout ;   }  
public  metadata collector   (  byte buffer key )  {  long hashed =  murmur hash . hash 2     6  4  ( key key . position (  )  key . remaining (  )  0 )  ;  cardinality . offer hashed ( hashed )  ;  return this ;   }  
public  string   (  )  {  return name ;   }  
@ override public  string   (  )  {  return new  string builder (  )  . append ( " cache invocation parameter impl { " )  . append ( "parameter meta data = " )  . append ( parameter meta data )  . append ( "  parameter value = " )  . append ( parameter va
public void   ( int price 1  )  {  assert price 1   >  =  0 && price 1   <  =   1 0000 ;   }  
private static boolean   (  variable tree variable tree )  {  return variable tree . type (  )  . is (  tree .  kind . array   type )  || is date or collection ( variable tree )  ;   }  
@ override public  boolean   (  string username )  {  if  ( get type (  )   =  =   transport type . icq )   {  return username . matches ( "\\d + " )  ;   }  else  {  return username . trim (  )  . length (  )   >  0 ;   }   }  
public  string   (  )  {  return null ;   }  
private static int   (  )  {  return get max record data size ( " keyspace 1 " bytes ( "k" )  " standard 1 "  util . cellname ( "c 1 " )  )  ;   }  
@ test public void   (  )  {  for  ( int i = 0 ;  i  <   test helper . race   default   loops ;  i +  +  )   {  final  flowable processor <  integer >  s =  publish processor .  <  integer > create (  )  . to serialized (  )  ;   test subscriber <  intege
public void   (  string name  string value )  {  cf props . add property ( name value )  ;   }  
@ override public  strong counter   (  string name )  {   strong counter c =  (  strong counter ) counters . get ( name )  ;  if  ( c  =  =  null )   {   counter configuration config = get configuration ( name )  ;  if  ( config  =  =  null || config . ty
public int   (  )  {  return  database descriptor . get compaction throughput mb per sec (  )  ;   }  
@ override public  transaction coordinator builder   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public byte[]   (  )  {  return    payload ;   }  
public  string   (  )  {  return  ( this . name )  ;   }  
public  string   (  )  {  return path ;   }  
@ test public void   (  )  throws io exception  {  final  file db snp file = new  file ( test   data   dir "mini . dbsnp . vcf" )  ;  final  file vcf file = new  file ( test   data   dir "all hom ref . vcf" )  ;  final  file indexed vcf file =  vcf test u
public  string   (  )  {  return code ;   }  
protected void   (  builder builder )  {   list <  address >  untested nodes = new  array list <  address >  ( builder . get members (  )  )  ;  while  (  ! untested nodes . is empty (  )  )   {  boolean owner removed = false ;   address worst node = find worst backup owner ( builder untested nodes )  ;  for  ( int segment = builder . get num segments (  )   -   1  ;  segment  >  =  0 ;  segment -  -  )   {   list <  address >  owners = builder . get owners ( segment )  ;  if  ( owners . size (  )   <  =  builder . get actual num owners (  )  )  continue ;  int owner idx = owners . index of ( worst node )  ;  if  ( owner idx  >  0 )   {  builder . remove owner ( segment worst node )  ;  owner removed = true ;  untested nodes = new  array list <  address >  ( builder . get members (  )  )  ;  worst node = find worst backup owner ( builder untested nodes )  ;   }   }  if  (  ! owner removed )   {  untested nodes . remove ( worst node )  ;   }   }   }  
public void   (  string property )  {  this . property = property ;   }  
@ override public  metadata transient mortal cache value   (  object input input )  throws io exception   class not found exception  {   object v = input . read object (  )  ;   metadata metadata =  (  metadata ) input . read object (  )  ;  long created 
private  server task registry   (  task context context )  {   cache <  ?   ?  >  cache = context . get cache (  )  . get (  )  ;  return cache . get cache manager (  )  . get global component registry (  )  . get component (  server task registry . class )  ;   }  
public static byte[]   ( byte[] salt  string password int iters )  throws  sasl exception  {   mac mac = create sha1 hmac ( password . get bytes (  standard charsets . utf   8 )  )  ;  mac . update ( salt )  ;  mac . update ( new byte[] { 0 0 0 1 }  )  ;  byte[] result = mac . do final (  )  ;  byte[] previous = null ;  for  ( int i = 1 ;  i  <  iters ;  i +  +  )   {  mac . update ( previous  !  =  null  ?  previous : result )  ;  previous = mac . do final (  )  ;  for  ( int x = 0 ;  x  <  result . length ;  x +  +  )   {  result[x]^ = previous[x] ;   }   }  return result ;   }  
public boolean   ( byte[] audio data int offset int size )  {  byte[] b = new byte[bytes played  +  audio data . length] ;  for  ( int i = 0 ;  i  <  bytes played ;  i +  +  )   {  b[i] = byte linear data[i] ;   }  for  ( int i = 0 ;  i  <  size ;  i +  +  )   {  b[i  +  bytes played] = audio data[i  +  offset] ;   }  byte linear data = b ;  bytes played +  = size ;  if  (  logger . log level  >  =   logger . log   detail )   {   logger . println ( "bytes played "  +  bytes played )  ;   }  return true ;   }  
public byte[]   (  )  throws ntlm engine exception  {  if  ( secondary key  =  =  null )   {  secondary key = make secondary key ( random )  ;   }  return secondary key ;   }  
public synchronized  key manager[]   (  )  throws  unrecoverable key exception   no such algorithm exception   key store exception  {  try  {  if  ( key manager factory  =  =  null )   {  try  {  key manager factory =  key manager factory . get instance ( " new sunx509" )  ;   }  catch  (   no such algorithm exception e )   {   log . info ( " unable to load the ' new sunx509'  key manager implementation .   will fall back to the default . " )  ;  key manager factory =  key manager factory . get instance (  key manager factory . get default algorithm (  )  )  ;   }  key manager factory . init ( configuration . get identity store (  )  . get store (  )  configuration . get identity store configuration (  )  . get password (  )  )  ;   }  return key manager factory . get key managers (  )  ;   }  catch  (   unrecoverable key exception| no such algorithm exception| key store exception| runtime exception ex )   {  key manager factory = null ;  throw ex ;   }   }  
public  collection <  ?  >    (  )  {  return remote lock intention ;   }  
@ subscribe ( thread mode =  thread mode . main )  public void   (  base nav drawer activity .  service completed event event )  {  set episode buttons enabled ( true )  ;   }  
@ override public  string   (  )  {  return description ;   }  
@ override public  annotation[]   (  )  {  return annotations . values (  )  . to array ( new  annotation[annotations . values (  )  . size (  ) ] )  ;   }  
public boolean   (  string cache name )  {  return ignored caches . contains ( cache name )  ;   }  
public static double   (  type type )  {  long time  count ;  switch  ( type )   {  case select: count = select count ;  time = total select time ;  break ;  case update: count = update count ;  time = total update time ;  break ;  case insert: count = insert count ;  time = total insert time ;  break ;  case delete: count = delete count ;  time = total delete time ;  break ;  default : throw new  illegal argument exception ( " invalid type" )  ;   }  if  ( count  !  =  0 )   {  return time  /   ( double ) count ;   }  else  {  return 0 . 0 ;   }   }  
@ override public void   (  http servlet request request  http servlet response response )  throws io exception  {  response . set header ( "e tag"  string . value of ( output . hash code (  )  )  )  ;  response . get writer (  )  . print ( output )  ;   
public final boolean   (  )  {  return is cas ;   }  
public void   (  string remote media info )  {  this . remote media info = remote media info ;   }  
public void   (  )  {   address a = mock (  address . class )  ;   list <  address >  addresses =  collections . empty list (  )  ;  n . notify view change ( addresses addresses a  1 00 )  ;  assert cl . invocation count  =  =   1  ;  assert  (  (  view changed event ) cl . get event (  )  )  . get local address (  )   =  =  a ;  assert  (  (  view changed event ) cl . get event (  )  )  . get new members (  )   =  =  addresses ;  assert  (  (  view changed event ) cl . get event (  )  )  . get view id (  )   =  =   1 00 ;  assert cl . get event (  )  . get type (  )   =  =   event .  type . view   changed ;   }  
public static  list <  string >    (  )  throws  no such algorithm exception   key management exception  {  final ssl context context = ssl context . get instance ( "tl sv1" )  ;  context . init ( null null null )  ;  return  arrays . as list ( context . createssl engine (  )  . get supported cipher suites (  )  )  ;   }  
@ override public  global component registry   (  )  {  return cache . get cache manager (  )  . get global component registry (  )  ;   }  
@ test public void   (  )  {   flowable <  list <  integer >  >  o =  flowable . range ( 1 10 )  . collect ( new  callable <  list <  integer >  >  (  )  {  @ override public  list <  integer >  call (  )  {  return new  array list <  integer >  (  )  ;  
@ override public void   (  class tree tree )  {   symbol .  type symbol symbol = tree . symbol (  )  ;  if  (  ! tree . is (  tree .  kind . class )  )   {  return ;   }  outer classes . push ( symbol )  ;  at least one reference . push (  boolean . fals
@ override public void   (  object output output  embedded metadata object )  throws io exception  {  int number = numbers . get ( object . get class (  )   -  1  )  ;  output . write ( number )  ;  switch  ( number )   {  case expirable: output . write l
@ override public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write serializable ( out  (  default element ) presence . get element (  )  )  ;   externalizable util . get instance (  )  . write boolea
private long   (  )  {  return  jive globals . get int property ( "xmpp . live . rejection . timeout" 20000 )  ;   }  
private void   (  string s )  {  int h 1  =  murmur hash 3  old . get instance (  )  . hash ( s )  ;  int h 2  =  murmur hash 3  . get instance (  )  . hash ( s )  ;   assert . assert equals ( h 1  h 2  )  ;   }  
@ override public boolean   (  preference preference  object new value )  {  final  string key = preference . get key (  )  ;  final  content values cv = new  content values ( 1 )  ;  if  ( key . equals ( preference   description )  )   {   string summary
public void   (  )  {  assert mapper . is supported type (  byte . class )  ;  assert assert works (  ( byte )  2  )  ;   }  
public  collection < jid >    (  )  {  return new  member collection ( administrators true )  ;   }  
public void   (  )  throws  exception  {   semaphore completion service <  string >  completion service = new  semaphore completion service <  >  ( new  within thread executor (  )   1  )  ;   future <  string >  future 1  = completion service . submit ( new  dummy task (  )  )  ;   future <  string >  future 2  = completion service . poll (  )  ;  assert same ( future 1  future 2  )  ;  assert not null ( future 2  )  ;  assert equals ( "bla" future 2  . get (  )  )  ;   }  
@ test public void   (  )  {  s2 . on next ( "1" )  ;  s2 . on next ( "2" )  ;  s1 . on next ( "a" )  ;  in order . verify ( observer times ( 1 )  )  . on next ( "a - 1" )  ;  s1 . on next ( "b" )  ;  in order . verify ( observer times ( 1 )  )  . on next
@ override public  string   (  )  {  return task . get name (  )  ;   }  
@ nullable public static  function <  ?  super  scheduler  ?  extends  scheduler >    (  )  {  return on single handler ;   }  
public static boolean   (  atomic reference <  subscription >  field  subscription s )  {  for  (  ;   ;   )   {   subscription current = field . get (  )  ;  if  ( current  =  =  cancelled )   {  if  ( s  !  =  null )   {  s . cancel (  )  ;   }  return false ;   }  if  ( field . compare and set ( current s )  )   {  if  ( current  !  =  null )   {  current . cancel (  )  ;   }  return true ;   }   }   }  
@ override public int   (  session data data )  {  return 0 ;   }  
@ override public void   (  )  {  pp2 . on complete (  )  ;   }  
public boolean   (  )  {  return    is inbound ;   }  
@ override public void   ( t o )  {  if  ( o  !  =  null )   {  list . add ( o )  ;   }   }  
@ override public  boolean   (  )  {  return true ;   }  
public void   ( int int flags )  {  this . flags map . set ( int flags )  ;   }  
@ override public int   (  )  {  return 0 ;   }  
public  serialization context   (  )  {  return serialization context ;   }  
public  map   (  )  {   map map = new  hash map ( parameters )  ;  map . put all ( get request (  )  . get parameter map (  )  )  ;  return map ;   }  
private static  list <  hash >    (  )  {   list <  hash >  functions = new  linked list <  hash >  (  )  ;  functions . add (  murmur hash 3  . get instance (  )  )  ;  functions . add ( new  super fast hash (  )  )  ;  return functions ;   }  
@ override protected  validation configuration   (  )  {  return new  validation configuration (  )  ;   }  
public  cql row   (  list <  column >  columns )  {  this . columns = columns ;  return this ;   }  
@ test public void   (  )  throws  exception  {  final  string lm =  date utils . format date ( new  date (  system . current time millis (  )   -   1 0 *  1 000l )  )  ;  test does not modify header from origin on cache hit ( " last -  modified" lm )  ; 
@ test public void   (  )  {   method complexity check check = new  method complexity check (  )  ;  check . set max (  1  )  ;   java check verifier . verify ( "src / test / files / checks /  method complexity noncompliant . java" check )  ;   }  
public void   (  )  {  if  (    facade . floodfill enabled (  )  )   {  requeue ( 30 * rerun   delay   ms )  ;  return ;   }   collection <  hash >  to explore = select keys to explore (  )  ;     log . info ( " filling the explorer pool with: "  +  to explore )  ;  if  ( to explore  !  =  null )     facade . queue for exploration ( to explore )  ;  requeue ( rerun   delay   ms )  ;   }  
@ override public void   (  assignment expression tree tree )  {  if  (  ! is identifier with same name ( tree . variable (  )  )  )   {  scan ( tree . variable (  )  )  ;   }  scan ( tree . expression (  )  )  ;   }  
public static void   (  embedded cache manager cache manager  string cache name )  {   global component registry global component registry = cache manager . get global component registry (  )  ;   component registry cache component registry = global component registry . get named component registry ( cache name )  ;  if  ( cache component registry  !  =  null )   {  cache component registry . get component (  persistence manager . class )  . set clear on stop ( true )  ;  cache component registry . get component (  cache jmx registration . class )  . set unregister cachem bean ( true )  ;  cache component registry . get component (  passivation manager . class )  . skip passivation on stop ( true )  ;   cache <  ?   ?  >  cache = cache manager . get cache ( cache name false )  ;  if  ( cache  !  =  null )   {  cache . stop (  )  ;   }   }  global component registry . remove cache ( cache name )  ;  global component registry . get component (  configuration manager . class )  . remove configuration ( cache name )  ;  global component registry . get component (  dependency graph . class cache   dependency   graph )  . remove ( cache name )  ;   }  
@ override public  view   ( int position  view convert view  view group parent )  {  return m delegate . get header view ( m headers[position] . get ref position (  )  convert view parent )  ;   }  
public int   (  )  {  return  ( int )  ( targets  -  latch . get count (  )  )  ;   }  
public void   (  http servlet request request  http servlet response response )  throws io exception   servlet exception  {   string ip = request . get remote addr (  )  ;   inet address addr =  inet address . get by name ( ip )  ;  try  {   inet address addr =  inet address . get by name ( ip )  ;   }  catch  (   illegal argument exception e )   {  throw e ;   }  catch  (   exception e )   {  throw e ;   }  static method (  )  ;   }  
@ test ( data provider = "shard data provider" )  public void   ( final  list <  file >  inputs )  throws io exception  {  final  file merged file prefix = new  file ( test   data   dir  +  "merge test" )  ;  final  file merged summary file = new  file ( 
@ test public void   (  )  throws  configuration exception  {  final  trusted hosts configuration configuration = get trusted hosts configuration (  )  ;  final  string string = configuration . to string (  )  ;  assert that ( string contains string ( "en
protected final  ickle filter and converter   (  string query string  map <  string  object >  named parameters )  {   ickle filter and converter filter = create filter ( query string named parameters )  ;   security actions . get cache component registry ( cache )  . wire dependencies ( filter )  ;  return filter ;   }  
public  string   (  )  {  return isbn ;   }  
public  string   (  )  {  return new nick ;   }  
public void   (  string property )  {  this . property = property ;   }  
 set <  integer >    (  )  {  return max ;   }  
public void   ( int alice port )  {     alice port = alice port ;   }  
@ override public void   ( final  metrics file < metric   type  integer >  hs metrics comparable metrics file )  {  hs metrics comparable metrics file . add metric ( convert metric ( this . metrics )  )  ;  hs metrics comparable metrics file . add histogr
@ override public  command handler   (  command context ctx )  {  return new  replace command handler (  cli command buffer . instance )  ;   }  
public  string   (  )  {  return " report  abuse" ;   }  
@ test ( expected exceptions =  parsing exception . class expected exceptions message reg exp = "ispn0 2  8  5  2  1 :  full - text queries cannot be applied to property 'long description' in type org . infinispan . query . dsl . embedded . testdomain . h
@ override protected void   (  )  throws  throwable  {   configuration builder cfg =  test cache manager factory . get default cache configuration ( true )  ;  cfg . transaction (  )  . transaction mode (  transaction mode . transactional )  . indexing ( 
public void   ( long lifespan )  {  this . lifespan = lifespan ;   }  
public long   (  )  {  return    context . clock (  )  . now (  )   -     created ;   }  
public void   ( final long last update time )  throws io exception  {  this . last update time . set ( last update time )  ;   }  
@ test ( expected =  illegal state exception . class )  public void   (  )  throws  exception  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . not ( qf . having ( "name" )  
public  genotype concordance counts   (  )  {  return snp counter ;   }  
@ override public  jdbc string based store configuration   (  )  {  return new  jdbc string based store configuration ( attributes . protect (  )  async . create (  )  singleton store . create (  )  connection factory  !  =  null  ?  connection factory . 
public void   (  method m )  {  final  string jmx domain = "jmx   "  +  m . get name (  )  ;  with cache manager ( new  cache manager callable (  test cache manager factory . create cache manager enforce jmx domain ( jmx domain false false true )  )  {  @ override public void call (  )  throws  exception  {  cm . get cache (  )  ;   object name cache object name = get cache object name ( jmx domain )  ;  assert true ( cache object name  +  " should be registered" server . is registered ( cache object name )  )  ;   testing util . kill cache managers ( cm )  ;  assert false ( cache object name  +  " should not be registered" server . is registered ( cache object name )  )  ;   }   }   )  ;   }  
@ override public void   (  object output output  id via both obj object )  throws io exception  {  output . write int ( object . age )  ;   }  
private static double   (  node probe probe )  {  long off heap mem used in bytes = 0 ;   iterator <  map .  entry <  string  column family storem bean >  >  cfamilies = probe . get column family storem bean proxies (  )  ;  while  ( cfamilies . has next (  )  )   {   entry <  string  column family storem bean >  entry = cfamilies . next (  )  ;   string keyspace name = entry . get key (  )  ;   string cf name = entry . get value (  )  . get column family name (  )  ;  off heap mem used in bytes +  =  (  long ) probe . get column family metric ( keyspace name cf name " memtable off heap size" )  ;  off heap mem used in bytes +  =  (  long ) probe . get column family metric ( keyspace name cf name " bloom filter off heap memory used" )  ;  off heap mem used in bytes +  =  (  long ) probe . get column family metric ( keyspace name cf name " index summary off heap memory used" )  ;  off heap mem used in bytes +  =  (  long ) probe . get column family metric ( keyspace name cf name " compression metadata off heap memory used" )  ;   }  return off heap mem used in bytes  /   (  1 0 2  4 d *  1 0 2  4  )  ;   }  
@ test public void   (  )  {   test helper . check disposed (  single subject . create (  )  . timeout ( 1  time unit . days )  )  ;   }  
@ override public  list <  address >    (  )  {  return addresses ;   }  
@ override public  string   (  )  {  return " configuration [async executor factory = "  +  async executor factory  +  "  balancing strategy factory =  (  )  -  > " +  balancing strategy factory . get (  )  +  " class loader = " +  class loader +  "  clie
public  type serializer <  big integer >    (  )  {  return  integer serializer . instance ;   }  
public void   (  )  {  log . trace ( " test keys for cache 2  . " )  ;  for  ( int i = 0 ;  i  <  key   queue   size ;  i +  +  )   {   object key for address = key affinity service 2  . get key for address ( manager 2  . get address (  )  )  ;  assert true ( cache 1  . get distribution manager (  )  . locate ( key for address )  . contains ( manager 2  . get address (  )  )  )  ;   }  log . trace ( " test keys for cache 1  . " )  ;  for  ( int i = 0 ;  i  <  key   queue   size ;  i +  +  )   {   object key for address = key affinity service 1  . get key for address ( manager 1  . get address (  )  )  ;   list <  address >  locate = cache 1  . get distribution manager (  )  . locate ( key for address )  ;  assert true ( " for key "  +  key for address  +  "  locate " +  locate +  " should contain " +  manager 1  . get address (  )  locate . contains ( manager 1  . get address (  )  )  )  ;   }   }  
@ test public void   (  )  {  final  atomic integer counter = new  atomic integer (  )  ;   composite disposable s = new  composite disposable (  )  ;  s . add (  disposables . from runnable ( new  runnable (  )  {  @ override public void run (  )  {  thr
@ override public  string   (  )  {  return "infinispan - server - infinispan - component - metadata . dat" ;   }  
@ test public void   (  )  {   assert . assert equals (  directory loader adaptor . figure chunks number ( "" 0  1  )  0 )  ;   assert . assert equals (  directory loader adaptor . figure chunks number ( ""  1   1  )   1  )  ;   assert . assert equals (  
public boolean   (  )  {  return    log latency ;   }  
public void   ( int port )  {  final long old port = get port (  )  ;  if  ( port  =  =  old port )   {   log . debug ( " ignoring port change request  ( to ' {  } ' ) : listener already in this state . " port )  ;  return ;   }   log . debug ( " changing port from ' {  } ' to ' {  } ' . " old port port )  ;  if  ( tcp port property name  !  =  null )   {   jive globals . set property ( tcp port property name  string . value of ( port )  )  ;   }  restart (  )  ;   }  
@ override public void   (  for each statement tree )  {  scan ( tree . statement (  )  )  ;   }  
@ override public  integer   (  )  {  return  ids . metadata   transient   entry ;   }  
public void   (  )  {  request . set path elements ( " / myapp" " /  2  / static . do" null null )  ;   action mapping mapping =  (  action mapping ) module config 2  . find action config ( " / static" )  ;  assert not null ( " found  / static mapping" mapping )  ;  assert not null ( " mapping has non - null name" mapping . get name (  )  )  ;  assert equals ( " mapping has correct name" "static" mapping . get name (  )  )  ;  assert not null ( " app config has form bean "  +  mapping . get name (  )  module config . find form bean config ( mapping . get name (  )  )  )  ;   action form form =  request utils . create action form ( request mapping module config 2  null )  ;  assert not null ( " action form returned" form )  ;  assert true ( " action form of correct type" form instanceof  mock form bean )  ;   }  
public void   (  )  {  while  (    alive )   {  try  {  do pass (  )  ;   }  catch  (   runtime exception re )   {     log . log (  log . crit " error in the establisher" re )  ;   }   }     inbound states . clear (  )  ;     outbound states . clear (  )  ;     queued outbound . clear (  )  ;     outbound by claimed address . clear (  )  ;     outbound by hash . clear (  )  ;   }  
public void   (  )  throws  execution exception   interrupted exception  {   default lock manager lock manager = new  default lock manager (  )  ;   per key lock container lock container = new  per key lock container (  )  ;  lock container . inject ( common pool (  )   abstract cache test . time   service )  ;   testing util . inject ( lock manager lock container mock executor )  ;  do single counter test ( lock manager )  ;   }  
@ override public  list <  cluster node info >    (  )  {  return cluster listener  =  =  null  ?   collections .  <  cluster node info > empty list (  )  : cluster listener . get cluster nodes info (  )  ;   }  
public void   (  object output out )  throws io exception  {   externalizable util . get instance (  )  . write externalizable collection ( out events )  ;   }  
@ test public void   (  )  throws  exception  {  assert true ( stats in . mark supported (  )  )  ;  stats in . mark ( 40 )  ;  stats in . skip ( 50 )  ;  assert bytes read ( 50 )  ;  try  {  stats in . reset (  )  ;   }  catch  (  io exception expected e
public  deletion   (  )  {  return this . deletion ;   }  
@ override public void   (  tree tree )  {  if  (  ! has semantic (  )  )   {  return ;   }   method tree method tree =  (  method tree ) tree ;  if  ( allowed   methods . any match ( method tree )  )   {  return ;   }  if  ( is single statement method ( 
@ override public void   (  throwable t )  {  actual . on error ( t )  ;   }  
@ override protected void   (  )  throws  throwable  {  create clustered caches (  3  amend configuration ( create configuration builder ( transactional )  )  )  ;  define configuration on all managers ( persistence   cache amend configuration ( create co
@ override public boolean   (  )  {  return false ;   }  
boolean   (  multicast subscription < t >  s )  {  for  (  ;   ;   )   {   multicast subscription < t > [] current = subscribers . get (  )  ;  if  ( current  =  =  terminated )   {  return false ;   }  int n = current . length ;  @ suppress warnings ( "unchecked" )   multicast subscription < t > [] next = new  multicast subscription[n  +  1] ;   system . arraycopy ( current 0 next 0 n )  ;  next[n] = s ;  if  ( subscribers . compare and set ( current next )  )   {  return true ;   }   }   }  
@ test public void   (  )  throws  exception  {  final  http host host = new  http host ( "somehost"  8 0 )  ;  final  http response response = new  basic http response (  http status . sc   unauthorized "unauthorized" )  ;  final  default authentication 
@ override public tls policy   (  )  {  return tls policy ;   }  
@ test public void   (  )  throws  exception  {   assert . assert that ( impl . parse ( "cn = \"blah  blah\"  ou = yada  o = booh" )   core matchers . equal to (  arrays .  <  name value pair > as list ( new  basic name value pair ( "cn" "blah  blah" )  n
public  list <  string >    (  )  {  return declared exceptions ;   }  
@ override public void   (  disposable d )  {   disposable helper . set once ( this d )  ;   }  
@ managed attribute ( description = " average number of milliseconds for a read operation on the cache" display name = " average read time" units =  units . milliseconds display type =  display type . summary )  public long   (  )  {  long total = hits . 
public long   (  )  {  return    session id ;   }  
public  enumeration   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public static boolean   ( final  object obj )  {  if  ( obj  =  =  null )   {  throw new  illegal argument exception ( "cannot determine emptiness of null" )  ;   }  if  ( obj instanceof  collection )   {  return  (  (  collection <  ?  >  ) obj )  . is empty (  )  ;   }  if  ( obj instanceof  iterable )   {  return  !  (  (  iterable <  ?  >  ) obj )  . iterator (  )  . has next (  )  ;   }  if  ( obj . get class (  )  . is array (  )  )   {  return  array . get length ( obj )   =  =  0 ;   }  throw new  illegal argument exception ( get type warning ( obj . get class (  )  )  )  ;   }  
@ test public void   (  )  {   list <  type >  element types = declared types ( "class  test < t >   { "  +  "  < s extends t >  void foo ( s s )   {  } "  +  " void test (  )   { " +  " new  test < a >  (  )  .  < a > foo ( new a (  )  )  ; " +  " new  t
protected void   (  string type int code )  {  add type name to code ( type code false )  ;   }  
@ override public  object   (  annotation annotation )  {  return  (  (  temporal ) annotation )  . value (  )  ;   }  
public  map <  string  object >    (  )  {  return named parameters ;   }  
public void   (  string href )  {  this . href = href ;   }  
public void   ( boolean value )  {  if  (  ! value )   {  this . consistency   level = null ;   }   }  
@ override public  cancellable   ( final  http host host final  http request request final  future callback <  http cache entry >  callback )  {  if  ( log . is debug enabled (  )  )   {  log . debug ( " get cache entry: "  +  host  +  " ;  " +  new  requ
@ test public void   (  )  {  log tester . set level (  logger level . info )  ;  assert that (  xml parser . parsexml ( new  file ( "src / test / files / xml / parsing - issue . xml" )  )  )  . is null (  )  ;   string filename =  filename utils . separa
@ test ( expected exceptions =  hot rod client exception . class expected exceptions message reg exp = "java . lang .  illegal state exception:  the cache must be indexed in order to use full - text queries . " )  @ override public void   (  )  {  super .
public void   (  )  {  with cache manager ( new  cache manager callable ( create source cache manager (  )  )  {  @ override public void call (  )  {   cache <  integer  string >  source cache = cm . get cache (  )  ;  source cache . put (  1  "v 1 " )  ;  source cache . put (  2  "v 2 " )  ;  source cache . put (  3  "v 3 " )  ;  with cache manager ( new  cache manager callable ( create target cache manager (  )  )  {  @ override public void call (  )  {   cache <  object  object >  target cache = cm . get cache (  )  ;  assert equals ( "v 1 " target cache . get (  1  )  )  ;  assert equals ( "v 2 " target cache . get (  2  )  )  ;  assert equals ( "v 3 " target cache . get (  3  )  )  ;   }   }   )  ;   }   }   )  ;   }  
@ override public void   (  proto stream writer writer  userpb user )  throws io exception  {  writer . write int ( "id" user . get id (  )  )  ;  writer . write collection ( "account ids" user . get account ids (  )   integer . class )  ;  writer . write
@ test public void   (  )  {   object n =  notification lite . next ( " hello" )  ;   object c =  notification lite . complete (  )  ;  assert true (  notification lite . is complete ( c )  )  ;  assert false (  notification lite . is complete ( n )  )  ;
@ override public boolean   (  )  {  return endpoint ref . get (  )   !  =  null ;   }  
  (  observer <  ?  super t >  observer )  {  this . observer = observer ;   }  
@ override public void   (  assignment expression tree tree )  {  if  ( tree . variable (  )  . is (  kind . identifier )  )   {   tree declaration =  (  (  identifier tree ) tree . variable (  )  )  . symbol (  )  . declaration (  )  ;  if  ( declaration
public  el gamal parameter spec   (  )  {  return el spec ;   }  
public  consistent hash   (  )  {  return pendingch ;   }  
@ override public void   (  prepared statement st int start index t value )  throws sql exception  {  st . set object ( start index value . name (  )   types . other )  ;   }  
public void   (  method m )  throws  interrupted exception   execution exception   timeout exception  {   string key = "\u 4 f 6 0\u 5  9  7 d - " ;   operation future <  boolean >  f = client . set ( k ( m key )  0 v ( m )  )  ;  assert true ( f . get ( timeout  time unit . seconds )  )  ;  assert equals ( v ( m )  client . get ( k ( m key )  )  )  ;   }  
@ override public void   (  read entry view < k v >  created )  {  assert equals ( "created" created . get (  )  )  ;  latch count and launder (  )  ;   }  
@ override public void   (  enum constant tree tree )  {  int flags =  flags . public |  flags . static |  flags . final|  flags . enum ;  if  ( has deprecated annotation ( tree . modifiers (  )  . annotations (  )  )  )   {  flags| =  flags . deprecated 
public static boolean   (  )  {  return fail non blocking scheduler ;   }  
public  string   (  )  {  return rack id ;   }  
public short   (  )  {  return    thrift id ;   }  
public boolean   (  )  {  return    expandeddb ;   }  
public void   (  account holder holder  integer id  integer opening balance  string branch )  throws  exception  {  with tx session ( use jta session factory session  -  >   {  log . debug ( " creating account "  +  id )  ;   account account = new  account (  )  ;  account . set id ( id )  ;  account . set account holder ( holder )  ;  account . set balance ( opening balance )  ;  log . debug ( " set branch "  +  branch )  ;  account . set branch ( branch )  ;  session . persist ( account )  ;  log . debug ( " created account "  +  id )  ;   }   )  ;   }  
public void   (  string site  throwable t )  {  if  ( site  !  =  null && t  !  =  null )   {  if  ( failures  =  =  null )  failures = new  hash map <  >  (  3  )  ;  failures . put ( site t )  ;   }   }  
@ test public void   (  )  throws  execution exception   interrupted exception  {   keyspace keyspace =  keyspace . open ( keyspace 1  )  ;   column family store cfs = keyspace . get column family store ( " super 1 " )  ;  cfs . disable auto compaction ( 
@ before test public void   (  )  throws io exception  {  global temp output dir = io util . create temp dir ( "artifact metrics . " " . tmp" )  ;   }  
@ override public void   (  case group tree tree )  {  check statements ( tree . body (  )  )  ;  super . visit case group ( tree )  ;   }  
protected  string   (  )  {  return  string . format ( "drop index %s on %s" get index name ( true )  get table name (  )  )  ;   }  
@ override public  configuration   (  string name )  {   configuration configuration = configuration manager . get configuration ( name true )  ;  if  ( configuration  =  =  null && cache exists ( name )  )   {  return get default cache configuration (  )
@ override protected void   (  )  {   configuration builder builder = get default clustered cache config (  cache mode . repl   sync true true )  ;  builder . transaction (  )  . transaction mode (  transaction mode . transactional )  . locking mode (  lo
public  comparator <  ?  super s >    (  )  {  return comparator ;   }  
@ test ( expected exceptions =  illegal state exception . class )  public void   (  )  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get user impl class (  )  )  . having ( "name" )  . eq ( " john" )  .
public boolean   ( i2np message message )  {  if  ( message  =  =  null )  return false ;  if  ( message instanceof  database store message )   {   database store message dsm =  (  database store message ) message ;  if  (    search . get key (  )  . equals ( dsm . get key (  )  )  )   {     search . decrement remaining (  )  ;     match found = true ;  return true ;   }   }  else if  ( message instanceof  database search reply message )   {   database search reply message dsrm =  (  database search reply message ) message ;  if  (    search . get key (  )  . equals ( dsrm . get search key (  )  )  )   {     context . profile manager (  )  . db lookup reply ( dsrm . get from hash (  )  0 dsrm . get num replies (  )  0 0  system . current time millis (  )   -     search . get created (  )  )  ;  if  (    search . should processdsrm (  )  )   {  if  (    log . should log (  log . info )  )     log . info (    search . get job id (  )   +  ":  processing dsrm via  single lookup job  apparently from "  +  dsrm . get from hash (  )  )  ;     context . job queue (  )  . add job ( new  single lookup job (    context dsrm )  )  ;   }  else if  (    log . should log (  log . info )  )   {  int remaining =    search . get lookups remaining (  )  ;     log . info (    search . get job id (  )   +  ": got a dsrm apparently from "  +  dsrm . get from hash (  )  +  " when we were looking for " +     search . get key (  )  +  "  with " +  remaining +  " outstanding searches" )  ;   }  int remaining =    search . decrement remaining ( dsrm . get from hash (  )  )  ;  return remaining  <  =  0 ;   }   }  return false ;   }  
protected  delta aware accessor <  map <  string  string >   string >    (  )  {  return new  delta aware accessor <  map <  string  string >   string >  (  )  {  @ override public  map <  string  string >  create object (   cache cache   string key )  {   map <  string  string >  map =  atomic map lookup . get atomic map ( cache key )  ;  map . put ( "first" "first component of object with key = "  +  key )  ;  map . put ( "second" "second component of object with key = "  +  key )  ;  return map ;   }  @ override public  map <  string  string >  get object (   cache cache   string key )  {  return  atomic map lookup . get atomic map ( cache key false )  ;   }  @ override public void put object (   cache cache   string key   map <  string  string >  da )  {  assert true ( da instanceof  atomic map proxy impl )  ;   }  @ override public  string get first component (   map <  string  string >  da )  {  return da . get ( "first" )  ;   }  @ override public void set first component (   map <  string  string >  da   string value )  {  da . put ( "first" value )  ;   }  @ override public  string get second component (   map <  string  string >  da )  {  return da . get ( "second" )  ;   }  @ override public void set second component (   map <  string  string >  da   string value )  {  da . put ( "second" value )  ;   }  @ override public boolean is fine grained (  )  {  return false ;   }   }   ;   }  
@ override public  string   (  inet address endpoint )  {  int no = endpoint . get address (  ) [ 3 ]  -   1  ;  return "datacenter"  +   ( no  /   3   +   1  )  ;   }  
public boolean   (  )  {  return is successful ( get status code (  )  )  ;   }  
public int   (  )  {  return m timeout ;   }  
private  request dispatcher   (  )  {   request dispatcher dispatcher = null ;  log . debug ( " getting request matcher for  {  } " target )  ;  if  ( target  !  =  null )   {  return new  http request dispatcher ( proxy service target context )  ;   }  return dispatcher ;   }  
@ override public void   (  variable tree tree )  {   string name = tree . simple name (  )  . name (  )  ;  if  ( fields . contains ( tree )  && current class name . equals ignore case ( name )  )   {  context . report issue ( this tree . simple name (  
@ override public boolean   (  )  throws  exception  {  return delegate . is rebalancing enabled (  )  ;   }  
private  map .  entry < k v >    (  object obj )  {  if  ( obj instanceof  map .  entry )   {  return  (  map .  entry ) obj ;   }  else  {  return null ;   }   }  
@ test public void   (  )  throws  exception  {  final  http client context context =  http client context . create (  )  ;   mockito . when ( mgr . lease (  mockito . eq ( route )   mockito .  <  timeout > any (  )   mockito . any (  )  )  )  . then retu
public void   (  )  {  with script ( add script client . get cache ( script   cache )  " / typed - size . js" script name  -  >   {  exec client . get cache ( name )  . clear (  )  ;   string result = exec client . get cache ( name )  . execute ( script name new  hash map <  >  (  )  )  ;  assert equals ( "0" result )  ;   }   )  ;   }  
public sam record   (  )  {  for  (  final sam record rec : first of pair or fragment )   {  if  ( rec  !  =  null )  return rec ;   }  for  (  final sam record rec : second of pair )   {  if  ( rec  !  =  null )  return rec ;   }  throw new  illegal state exception ( " should not be called if num hits  =  =  0" )  ;   }  
public long   (  )  {  return resolution ;   }  
protected final  socket channel   (  )  {  return socket ;   }  
public uuid   (  )  {  return version ;   }  
public void   (  )  {   query factory qf = get query factory (  )  ;   query q = qf . from ( get model factory (  )  . get transaction impl class (  )  )  . select ( sum ( "amount" )  )  . group by ( "account id" )  . having ( sum ( "amount" )  )  . gt (  5 0000 )  . build (  )  ;   list <  object[] >  list = q . list (  )  ;  assert equals ( 0 list . size (  )  )  ;   }  
private void   (  string counter name  handle impl <  ?  >  handle )  {  if  ( trace )   {  log . tracef ( " remove listener for counter '%s'" counter name )  ;   }  client listeners . compute ( counter name  ( name list )   -  >   {  list . remove ( handle )  ;  if  ( list . is empty (  )  )   {   counter event dispatcher dispatcher = this . dispatcher ;  if  ( dispatcher  !  =  null )   {   remove listener operation op = factory . new remove listener operation ( counter name listener id dispatcher . address (  )  )  ;  if  (  ! await ( op . execute (  )  )  )   {  log . debugf ( " failed to remove counter listener %s on server side" counter name )  ;   }   }  return null ;   }  return list ;   }   )  ;   }  
@ override public void   (  string[] strings )  {  engine . set enabled cipher suites ( strings )  ;   }  
@ override public int   (  )  {  throw new  unsupported operation exception (  )  ;   }  
public  set <  category prop >    (  )  {  return properties ;   }  
@ test public void   (  )  {  expect parser success ( "from example .  outer as o left join o . id . master m left join o . id . master . id . sup s where o . bubu is not null" )  ;   }  
@ override public void   (  )  {  ds[0] . dispose (  )  ;   }  
static boolean   (  path <  ?  >  path )  {  if  ( path instanceof  collection path base )   {  return is entity path (  (  path <  ?  >  )  (  (  collection path base ) path )  . any (  )  )  ;   }  else  {  return path instanceof  entity path || path . get type (  )  . is annotation present (  entity . class )  ;   }   }  
@ override public final boolean   (  collection <  ?  >  c )  {  throw new  unsupported operation exception (  )  ;   }  
public v   ( k key )  {  return map . get ( key )  ;   }  
public void   (  string size )  {  set cols ( size )  ;   }  
private static void   ( xml extended stream writer writer  property property )  throws xml stream exception  {  writer . write start element (  element . transport . get local name (  )  )  ;  write protocol attributes ( writer property )  ;   model node transport = property . get value (  )  ;  write attribute ( writer transport  transport resource definition . shared )  ;  write attribute ( writer transport  transport resource definition . diagnostics   socket   binding )  ;  write attribute ( writer transport  transport resource definition . default   executor )  ;  write attribute ( writer transport  transport resource definition . oob   executor )  ;  write attribute ( writer transport  transport resource definition . timer   executor )  ;  write attribute ( writer transport  transport resource definition . thread   factory )  ;  write attribute ( writer transport  transport resource definition . machine )  ;  write attribute ( writer transport  transport resource definition . rack )  ;  write attribute ( writer transport  transport resource definition . site )  ;  write element ( writer transport  protocol resource definition . properties )  ;  if  ( transport . has defined (  thread pool resource definition . wildcard   path . get key (  )  )  )   {  write thread pool elements (  element . default   thread   pool  thread pool resource definition . default writer transport )  ;  if  ( transport . has defined (  thread pool resource definition . oob . name (  )  )  )   {  write thread pool elements (  element . oob   thread   pool  thread pool resource definition . default writer transport )  ;   }  if  ( transport . has defined (  thread pool resource definition . internal . name (  )  )  )   {  write thread pool elements (  element . internal   thread   pool  thread pool resource definition . default writer transport )  ;   }  if  ( transport . has defined (  thread pool resource definition . timer . name (  )  )  )   {  write thread pool elements (  element . timer   thread   pool  thread pool resource definition . default writer transport )  ;   }   }  writer . write end element (  )  ;   }  
@ test public void   (  )  throws io exception  {  cm = new  default cache manager ( "jpa - config . xml" )  ;   cache <  string  key value entity >  specific cache = cm . get cache ( "specific cache" )  ;  validate config ( specific cache )  ;   key valu
@ test @ in sequence ( value =  1  3  )  @ operate on deployment ( "dep . active -  1 " )  public void   (  )  throws  exception  {   list <  member >  members = member registration . spatial search ( cbgb   latitude cbgb   longitude  1 0 )  ;  assert equ
private static  string   ( sm input cursor test case cursor )  throws xml stream exception  {   string classname = test case cursor . get attr value ( "classname" )  ;   string name = test case cursor . get attr value ( "name" )  ;  if  (  string utils . contains ( classname "$" )  )   {  return  string utils . substring after ( classname "$" )   +  " / "  +  name ;   }  return name ;   }  
@ override public  cache <  object  object >    (  )  {  return null ;   }  
public void   ( int sort order )  {  if  (  !  ( sort order  =  =   session result filter . ascending || sort order  =  =   session result filter . descending )  )   {  throw new  illegal argument exception (  )  ;   }  this . sort order = sort order ;   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable <  integer >  cached =  observable . range ( 1 100 )  . replay (  )  . auto connect (  )  ;  cached . take ( 10 )  . subscribe ( to )  ; 
public static  list <  field >    (  class <  ?  >  c  class <  ?  extends  annotation >  annotation type )  {   list <  field >  fields = new  array list <  >  (  4  )  ;  for  (  ;  c  !  =  null &&  ! c . equals (  object . class )  ;  c = c . get superclass (  )  )   {  get annotated field helper ( fields c annotation type )  ;   }  return fields ;   }  
private static boolean   (  string pkg )  {  return pkg . starts with ( "java . " )  || pkg . starts with ( "org . infinispan . " )  || pkg . starts with ( "org . jgroups . " ) || pkg . starts with ( "org . apache" ) || pkg . starts with ( "org . jboss" ) || pkg . starts with ( "com . arjuna" )  ;   }  
protected  prepare command blocker   (  cache <  ?   ?  >  cache )  {   async interceptor chain chain = cache . get advanced cache (  )  . get async interceptor chain (  )  ;   prepare command blocker blocker = chain . find interceptor with class (  prepare command blocker . class )  ;  if  ( blocker  !  =  null )  return blocker ;  blocker = new  prepare command blocker (  )  ;  chain . add interceptor before ( blocker  tx interceptor . class )  ;  return blocker ;   }  
@ override protected void   (  session data data  element command )  {   data form form = new  data form (  data form .  type . form )  ;  form . set title (  locale utils . get localized string ( "pubsub . command . pending - subscriptions . title" )  ) 
@ test public void   (  )  {   flowable <  string >  skip =  flowable . just ( "one" "two" "three" )  . skip ( 0 )  ;   subscriber <  string >  observer =  test helper . mock subscriber (  )  ;  skip . subscribe ( observer )  ;  verify ( observer times ( 
public static  cursor   ( final  content resolver cr final long account id )  {  return cr . query (  mailbox . content   uri  mailbox . content   projection push   mailboxes   for   account   selection new  string[] {  long . to string ( account id )  }  null )  ;   }  
private  configuration   (  )  {   configuration builder config = new  configuration builder (  )  ;  config . add server (  )  . host ( server 1  . get hotrod endpoint (  )  . get inet address (  )  . get host name (  )  )  . port ( server 1  . get hotrod endpoint (  )  . get port (  )  )  ;  return config . build (  )  ;   }  
@ override public void   (  )  {  complete . set ( true )  ;   }  
private  string   (  string prop  list <  string >  values )  {  if  ( values  =  =  null || values . is empty (  )  )   {     config . remove ( prop )  ;  return "" ;   }   string builder buf = new  string builder ( 64 )  ;  for  (   string s : values )   {  if  ( buf . length (  )   >  0 )  buf . append ( ' ' )  ;  buf . append ( s )  ;   }   string rv = buf . to string (  )  ;     config . set property ( prop rv )  ;  return rv ;   }  
public void   ( boolean value )  {        isset   bitfield =  encoding utils . set bit (       isset   bitfield       timestamp   isset   id value )  ;   }  
@ override public  publisher <  integer >    ( long elements )  {  return  flowable . just ( 1 )  . repeat ( elements )  ;   }  
@ test ( expected =  character coding exception . class )  public void   (  )  throws io exception  {   byte buffer bytes =  byte buffer . wrap ( new byte[] {  ( byte ) 0xff  ( byte ) 0xfe }  )  ;   byte buffer util . string ( bytes  standard charsets . u
@ override public void   ( final  object output output final  top field docs top field docs )  throws io exception  {   unsigned numeric . write unsigned int ( output top field docs . total hits )  ;  output . write float ( top field docs . get max score 
public  string   (  )  {  while  ( true )  s = "dollar" ;   }  
public boolean   ( int current )  throws sql exception  {  return stmt . get more results ( current )  ;   }  
@ override public  object   (  tx invocation context ctx  prepare command command )  throws  throwable  {  if  ( ctx . is origin local (  )  )   {  for  (   write command wc : command . get modifications (  )  )   {  for  (   object key : wc . get affecte
@ test ( expected =  illegal argument exception . class )  public void   (  )  {  new  pattern matcher ( "*" )  ;   }  
protected  content response   (  string id  string accept )  throws  exception  {  return client . new request (  string . format ( "http: /  / localhost:%d / rest / %s / %s" pick server (  )  . get port (  )  cache   name id )  )  . header (  http header . accept accept )  . send (  )  ;   }  
@ create kdc server ( primary realm = kerberos   primary   realm kdc principal = "krbtgt / "  +  kerberos   primary   realm  +  "@" +  kerberos   primary   realm search base dn = base   dn transports =  { @ create transport ( protocol = "udp" port = kerbe
@ test ( expected exceptions =  illegal argument exception . class expected exceptions message reg exp = "ispn0 1  4  8  1  2 : param values cannot be null" )  public void   (  )  {   query factory qf = get query factory (  )  ;   query q = qf . from ( ge
protected int   (  )  {  io util . assert file is readable ( fastq )  ;  if  ( fastq2  !  =  null )   {  io util . assert file is readable ( fastq2 )  ;   }  io util . assert file is writable ( output )  ;  final sam file header header = create sam file header (  )  ;  final sam file writer writer = new sam file writer factory (  )  . makesam orbam writer ( header false output )  ;  quality   format =  fastq to sam . determine quality format ( file to fastq reader ( fastq )   ( fastq2  =  =  null )   ?  null : file to fastq reader ( fastq2 )  quality   format )  ;  final  list <  fastq reader >  readers1 = new  array list <  fastq reader >  (  )  ;  final  list <  fastq reader >  readers2 = new  array list <  fastq reader >  (  )  ;  if  ( use   sequential   fastqs )   {  for  (  final  file fastq : get sequential file list ( fastq )  )   {  readers1 . add ( file to fastq reader ( fastq )  )  ;   }  if  ( null  !  =  fastq2 )   {  for  (  final  file fastq : get sequential file list ( fastq2 )  )   {  readers2 . add ( file to fastq reader ( fastq )  )  ;   }  if  ( readers1 . size (  )   !  =  readers2 . size (  )  )   {  throw new  picard exception (  string . format ( " found %d files for fastq and %d files for fastq2 . " readers1 . size (  )  readers2 . size (  )  )  )  ;   }   }   }  else  {  readers1 . add ( file to fastq reader ( fastq )  )  ;  if  ( fastq2  !  =  null )   {  readers2 . add ( file to fastq reader ( fastq2 )  )  ;   }   }  for  ( int idx = 0 ;  idx  <  readers1 . size (  )  ;  idx +  +  )   {  make it so ( readers1 . get ( idx )   ( readers2 . is empty (  )  )   ?  null : readers2 . get ( idx )  writer )  ;   }  for  (  final  fastq reader reader : readers1 )  reader . close (  )  ;  for  (  final  fastq reader reader : readers2 )  reader . close (  )  ;  writer . close (  )  ;  return 0 ;   }  
@ check return value @ non null public static  < t >  single subject < t >    (  )  {  return new  single subject < t >  (  )  ;   }  
@ test public void   (  )  throws io exception  {   string json = " { fields: { age: { type:\"bigdec\"  decimal   digits: 2 0 }  }  } " ;   schema schema =  schema . from json ( json )  ;   column mapper column mapper = schema . get mapper ( "age" )  ;   
@ override public void   (  )  {  active . decrement and get (  )  ;  drain (  )  ;   }  
public void   (  string filename )  {  this . filename = filename ;   }  
public static  list <  string >    ( x509 certificate x509 certificate )  {   list <  string >  names = new  array list <  >  (  )  ;  for  (   certificate identity mapping mapping : server cert mapping )   {   list <  string >  identities = mapping . map identity ( x509 certificate )  ;   log . debug ( " certificate manager: "  +  mapping . name (  )   +  " returned " +  identities . to string (  )  )  ;  if  (  ! identities . is empty (  )  )   {  names . add all ( identities )  ;  break ;   }   }  return names ;   }  
public static boolean   (  string prefix  string property  class <  ?  >  bean )  {  try  {  bean . get method ( prefix  +  capitalize ( property )  )  ;  return true ;   }  catch  (   no such method exception ex )   {  return false ;   }   }  
public void   (  )  throws  exception  {  cm 1  . start caches ( "cache 1 " "cache 2 " )  ;   list memb 1  = cm 1  . get members (  )  ;  assert  1   =  =  memb 1  . size (  )  : " expected  1  member ;  was "  +  memb 1  ;   object coord = memb 1  . get ( 0 )  ;  cm 2  = add cluster enabled cache manager (  )  ;  cm 2  . define configuration ( "cache 1 " cfg . build (  )  )  ;  cm 2  . define configuration ( "cache 2 " cfg . build (  )  )  ;  cm 2  . start caches ( "cache 1 " "cache 2 " )  ;   testing util . block until views received (  5 0000 true cm 1  cm 2  )  ;  memb 1  = cm 1  . get members (  )  ;   list memb 2  = cm 2  . get members (  )  ;  assert  2   =  =  memb 1  . size (  )  ;  assert memb 1  . equals ( memb 2  )  ;  cm 1  . stop (  )  ;   testing util . block until views received (  5 0000 false cm 2  )  ;  memb 2  = cm 2  . get members (  )  ;  assert  1   =  =  memb 2  . size (  )  ;  assert  ! coord . equals ( memb 2  . get ( 0 )  )  ;   }  
boolean   (  )  {  return this . exclusive ;   }  
@ override public  string   (  )  {   string builder buf = new  string builder (  )  ;   properties p = new  properties (  )  ;  write to properties ( p )  ;  buf . append ( " client tunnel settings:\n" )  ;  buf . append ( " =  =  =  =  =  =  =  =  =  = 
public void   (  string name  string value )  {  if  ( properties  =  =  null )   {  load properties from db (  )  ;   }  if  ( properties . contains key ( name )  )   {  if  (  !  ( value . equals ( properties . get ( name )  )  )  )   {  properties . put ( name value )  ;  update property in db ( name value )  ;   }   }  else  {  properties . put ( name value )  ;  insert property into db ( name value )  ;   }   }  
public void   (  control response res )  {  ctrl res = res ;   }  
public void   (  string dm note )  {  this . dm note = dm note ;   }  
public  string   (  )  {  return style id ;   }  
public int   (  )  {  return    status ;   }  
@ override public  hash   (  )  {  return null ;   }  
private static  byte buffer   ( final  file binary file )  {  final  byte buffer buf ;  try  {  final  file input stream is = new  file input stream ( binary file )  ;  final  file channel channel = is . get channel (  )  ;  final long file size = channel . size (  )  ;  buf = channel . map (  file channel .  map mode . read   only 0 file size )  ;  buf . order (  byte order . little   endian )  ;   closer util . close ( channel )  ;   closer util . close ( is )  ;   }  catch  (  io exception e )   {  throw new  picard exception ( "io exception opening cluster binary file "  +  binary file e )  ;   }  return buf ;   }  
@ managed attribute ( description = " cluster wide total number of cache attribute put operations" display name = " cluster wide total number of cache puts" measurement type =  measurement type . trendsup display type =  display type . summary )  @ overri
private  collection <  token >    (  inet address endpoint )  {  try  {  return  token serializer . deserialize ( get partitioner (  )  new  data input stream ( new  byte array input stream ( get application state value ( endpoint  application state . tokens )  )  )  )  ;   }  catch  (  io exception e )   {  throw new  runtime exception ( e )  ;   }   }  
@ override public void   ( final xml extended stream reader reader final  configuration builder holder holder )  throws xml stream exception  {   configuration builder builder = holder . get current configuration builder (  )  ;   element element =  eleme
@ test public void   (  )  {  assert that thrown by (  (  )   -  >  db rule . get shared handle (  )  . create query ( "select int value  name from something" )  . collect into ( new  generic type <  hash map <  string  integer >  >  (  )  {   }   )  )  .
private  event type   (  event impl < k v >  event )  {  switch  ( event . get type (  )  )   {  case cache   entry   activated: case cache   entry   created: case cache   entry   invalidated: case cache   entry   loaded: case cache   entry   modified: case cache   entry   passivated: case cache   entry   removed: case cache   entry   visited: case cache   entry   expired: return new  event type ( event . is command retried (  )  event . is pre (  )  event . get type (  )  )  ;  default : return null ;   }   }  
@ test public void   (  )  {   test observer <  integer >  to = new  test observer <  integer >  (  )  ;   observable . range ( 0 100000 )  . on exception resume next (  observable . just ( 1 )  )  . observe on (  schedulers . computation (  )  )  . map (
 collection <  range <  token >  >    (  string keyspace name  inet address ep )  {  return  keyspace . open ( keyspace name )  . get replication strategy (  )  . get address ranges (  )  . get ( ep )  ;   }  
public static int   ( int flags )  {  int exp =  ( flags & tags   reqd   mask )   >  >  4 ;  return code to val ( exp tags   reqd )  ;   }  
protected  prepared statement   ( boolean with keys )  throws sql exception  {  listeners . pre render ( context )  ;  sql serializer serializer = create serializer (  )  ;  if  ( sub query builder  !  =  null )   {  sub query = sub query builder . select ( values . to array ( new  expression[values . size (  ) ] )  )  . clone (  )  ;  values . clear (  )  ;   }  if  (  ! batches . is empty (  )  && batch to bulk )   {  serializer . serialize insert ( metadata entity batches )  ;   }  else  {  serializer . serialize insert ( metadata entity columns values sub query )  ;   }  context . addsql ( create bindings ( metadata serializer )  )  ;  listeners . rendered ( context )  ;  return prepare statement and set parameters ( serializer with keys )  ;   }  
@ override public boolean   (  integer t1 )  {  return t1  >  0 ;   }  
public static  deflate compressor   (  map <  string  string >  compression options )  {  return instance ;   }  
@ test @ with running server (  { @ running server ( name = "standalone - fcs - local" )  }  )  public void   (  )  throws  exception  {  do put get check path ( create remotes ( "standalone - fcs - local" "local" default   cache   name )  "dc"  -  1  . 0
public static  < k v >  remove < k v >    (  )  {  return instance ;   }  
private static boolean   (  symbol member symbol )  {  return member symbol . is private (  )  && member symbol . is variable symbol (  )  ;   }  
@ test public void   (  )  {   flowable . range long ( 1  long . max   value )  ;   }  
@ override public boolean   (  object o )  {   object v = map . remove ( o )  ;  return v  !  =  null ;   }  
public void   ( long num )  {     sequence num = num ;   }  
public void   (  input stream in )  throws  data format exception  io exception  {     tunnel id =  data helper . read long ( in 4 )  ;   }  
public  string   (  )  {  return group description field ;   }  
@ override public  builder <  ?  >    (  near cache configuration template )  {  mode = template . mode (  )  ;  max entries = template . max entries (  )  ;  return this ;   }  
@ override public  internal cache entry   (  object key  object value  metadata metadata long lifespan long max idle )  {  if  (  ! is store metadata ( metadata null )  )   {  if  ( lifespan  <  0 && max idle  <  0 )  return new  immortal cache entry ( ke
@ override public void   (  throwable e )  {  latch . count down (  )  ;   }  
public void   (  )  {  request . set attribute (  globals . module   key module config 3  )  ;  request . set path elements ( " / myapp" " /  3  / action . do" null null )  ;   }  
@ test public void   (  )  throws  exception  {  h . prepare batch ( "insert into something  ( id  name )  values  (  ?    ?  ) " )  . add ( 1 " brian" )  . add ( 2 " keith" )  . execute (  )  ;   list <  string >  rs = h . create query ( "select name fro
@ override public t   (  )  {  return max ;   }  
@ override public boolean   (  )  {  return true ;   }  
@ test public void   (  )  {   cache <  object  string >  cache0 = cache ( 0 cache   name )  ;   cache <  object  string >  cache 1  = cache (  1  cache   name )  ;   cache <  object  string >  cache 2  = cache (  2  cache   name )  ;  int initial cache0 
@ override public synchronized  transaction manager   (  )  throws  exception  {   transaction manager tm =  (  transaction manager ) manager . invoke ( null )  ;  if  ( log . is info enabled (  )  )  log . retrieving tm ( tm )  ;  return tm ;   }  
public   ( final uri scheme scheme )  {  super ( scheme )  ;   }  
@ before public void   (  )  {  digest = mock (  message digest . class )  ;  when ( digest . digest (  )  )  . then return ( digest bytes )  ;  stream = new  message digester output stream ( digest )  ;   }  
@ override protected  list <  method matcher >    (  )  {  return  collections . singleton list ( threadlocal   constructor )  ;   }  
public  file system   (  )  {  error if not setup (  )  ;  return m   file sys ;   }  
@ override public int   (  string username )  throws  unsupported operation exception   user not found exception  {  throw new  unsupported operation exception (  )  ;   }  
@ test public void   (  )  throws  exception  {  final  date twenty seconds ago = new  date ( now . get time (  )   -   2 0 *  1 000l )  ;  final  string lm date =  date utils . format date ( twenty seconds ago )  ;  final  string etag = "\"etag\"" ;  fin
public void   (  )  throws  exception  {  sequencer = new  state sequencer (  )  ;  sequencer . logical thread ( "tx" "tx:perform   op" "tx:check   locks" "tx:before   commit" "tx:after   commit" )  ;  sequencer . logical thread ( "rebalance" "rebalance:before   get   tx" "rebalance:after   get   tx" "rebalance:before   confirm" "rebalance:end" )  ;  sequencer . order ( "tx:perform   op" "rebalance:before   get   tx" "rebalance:after   get   tx" "tx:check   locks" "rebalance:before   confirm" "rebalance:end" "tx:before   commit" )  ;  start tx with lock (  )  ;  start rebalance (  )  ;  check locks before commit ( false )  ;  wait rebalance end (  )  ;  end tx (  )  ;  check locks after commit (  )  ;   }  
@ override public  executor factory configuration builder   (  executor factory configuration template )  {  attributes . read ( template . attributes (  )  )  ;  return this ;   }  
@ override public void   (  object input input )  throws io exception   class not found exception  {  set origin (  (  address ) input . read object (  )  )  ;  id = input . read object (  )  ;  parallel stream = input . read boolean (  )  ;  type =  mars
@ managed operation ( description = " removes the lock from the cluster .   the lock has to be recreated to access next time . " display name = " remove  clustered  lock" name = remove )  public boolean   (  string name )  {  if  ( trace )   {  log . trac
@ test public void   (  )  {  assert equals ( "object" naming strategy . get default variable name ( entity model )  )  ;   }  
public void   (  method m )  {  hot rod server = new  hotrod server builder (  )  . add sni domain ( "*" default server keystore "secret" default trusted client truststore "secret" )  . build (  )  ;  hot rod client = new  hotrod client builder ( hot rod server )  . use ssl configuration ( default server keystore "secret" default trusted client truststore "secret" )  . build (  )  ;  client (  )  . assert put ( m )  ;  assert success ( client (  )  . assert get ( m )  v ( m )  )  ;   }  
public void   ( ks meta data ksm )  {  replication strategy =  abstract replication strategy . create replication strategy ( ksm . name ksm . strategy class  storage service . instance . get token metadata (  )   database descriptor . get endpoint snitch (  )  ksm . strategy options )  ;   }  
public  peer test reader   (  )  {  return    peer test reader ;   }  
@ override public void   ( t value )  {  this . value = value ;  count down (  )  ;   }  
@ test ( expected =  illegal argument exception . class )  public void   (  )  {   column mapper big decimal mapper = new  column mapper big decimal (  1 00  1 00 )  ;  mapper . index value ( "test" true )  ;   }  
public void   ( boolean can anyone discoverjid )  {  this . can anyone discoverjid = can anyone discoverjid ;   }  
 statement context   (  string raw sql )  {  this . raw sql = raw sql ;  return this ;   }  
public void   (  )  {   cache <  object  object >  cache 1  = get cache (  )  ;   distributed executor service des = createdes ( cache 1  )  ;   address target = cache 1  . get advanced cache (  )  . get rpc manager (  )  . get address (  )  ;  expect exception (  null pointer exception . class  (  )   -  >  des . submit ( target  (  distributed task ) null )  )  ;   }  
public void   ( char[] cbuf int off int len )  throws io exception  {  check and throw (  )  ;   }  
private  iterator <  marshalled entry >    (  )  {  try  {  if  ( rs . next (  )  )   {   input stream input stream = rs . get binary stream (  1  )  ;   map <  object  marshalled entry >  bucket entries = unmarshall bucket entries ( input stream )  ;  number of rows +  = bucket entries . size (  )   -   1  ;  return bucket entries . values (  )  . iterator (  )  ;   }  else  {  close (  )  ;  throw new  no such element exception (  )  ;   }   }  catch  (  sql exception e )   {  throw new  persistence exception ( "sql error while fetching all  stored entries" e )  ;   }   }  
@ override public void   (  throwable t )  {  if  ( done )   {   rx java plugins . on error ( t )  ;  return ;   }  done = true ;  try  {  on error . accept ( t )  ;   }  catch  (   throwable ex )   {   exceptions . throw if fatal ( ex )  ;   rx java plug
@ test public void   (  )  {   test observer <  string >  to = new  test observer <  string >  (  )  ;   observable . just ( "abc" )  . take while ( new  predicate <  string >  (  )  {  @ override public boolean test (   string t1 )  {  throw new  test ex
public void   (  data output out int value )  throws io exception  {  strategy . write int ( out value )  ;   }  
public  object   (  )  {  return  ( this . collection )  ;   }  
@ test public void   (  )  throws  exception  {  final  http host target = new  http host ( "localhost"  -  1  "http" )  ;  final uri requesturi = new uri ( " / ~tim" )  ;  final uri redirect 1  = new uri ( "http: /  / localhost /  people . htm#tim" )  ; 
public  action mapping   (  string path )  {  return null ;   }  
@ override public  reference sequence   (  string contig long start long stop )  {  return null ;   }  
@ override public void   (  throwable e )  {  o . on error ( e )  ;   }  
protected  string   (  )  {  return " submit" ;   }  
public  set <  string >    (  )  {  return attributes to reverse complement ;   }  
public  relay channel   ( jid jid  handset handset )  {   relay channel rc = null ;  try  {  rc =  relay channel . create local relay channel ( bind all interfaces  ?  "0 . 0 . 0 . 0" :  localip resolver . get localip (  )  30000 50000 )  ;  final int id = ids . increment and get (  )  ;  final  string s id = jid . escape node ( jid . to string (  )  )  ;  rc . set attachment ( s id )  ;  rc . set from ( jid component )  ;  rc . set crypto ( handset )  ;  channels . put ( s id rc )  ;   }  catch  (  io exception e )   {   log . error ( " could  not  create  channel . " e )  ;   }  return rc ;   }  
public  transaction   (  )  throws  system exception  {  return current transaction . get (  )  ;   }  
public  prepared statement   (  )  {  return statement ;   }  
@ override public  loader <  cursor >    ( int id  bundle args )  {  return new  cursor loader ( get activity (  )   episodes . build episodes of season with show uri (  string . value of ( get season id (  )  )  )   episodes adapter .  episodes query . p
@ test public void   (  )  {   bad constant name check check = new  bad constant name check (  )  ;  check . format = "^[a - za - z0 -  9    ]*$" ;   java check verifier . verify no issue ( "src / test / files / checks / naming /  bad constant name . java
private  set <  class <  ?  super t >  >    (  )  {  final  set <  class <  ?  >  >  builder = new  linked hash set <  >  (  )  ;  new  type visitor (  )  {  @ override void visit type variable (   type variable <  ?  >  t )  {  visit ( t . get bounds (  )  )  ;   }  @ override void visit wildcard type (   wildcard type t )  {  visit ( t . get upper bounds (  )  )  ;   }  @ override void visit parameterized type (   parameterized type t )  {  builder . add (  (  class <  ?  >  ) t . get raw type (  )  )  ;   }  @ override void visit class (   class <  ?  >  t )  {  builder . add ( t )  ;   }  @ override void visit generic array type (   generic array type t )  {  builder . add (  types . get array class ( of ( t . get generic component type (  )  )  . get raw type (  )  )  )  ;   }   }   . visit ( runtime type )  ;  @ suppress warnings (  { "unchecked" "rawtypes" }  )   set <  class <  ?  super t >  >  result =  (  set )  collections . unmodifiable set ( builder )  ;  return result ;   }  
@ test ( expected =  http exception . class )  public void   (  )  throws  exception  {  final  classic http request request = new  basic classic http request (  standard methods . get . name (  )  host " / " )  ;  final  classic http response response = 
public void   (  method m )  {   test response resp = clients (  )  . get ( 0 )  . put ( k ( m )  0 0 v ( m )  )  ;  assert status ( resp  success )  ;  assert success ( clients (  )  . get (  1  )  . get ( k ( m )  0 )  v ( m )  )  ;   }  
private void   ( int c 1  int c 2  int a 1  int a 2  boolean merge in split order )  throws  exception  {   object[] keys =  int stream . range ( 0 num members in cluster )  . map to obj ( node  -  >   {   magic key key = new  magic key ( cache ( node )  )  ;  cache ( node )  . put ( key "v0" )  ;  return key ;   }   )  . to array (  magic key[]::new )  ;   state sequencer ss = new  state sequencer (  )  . logical thread ( "main" "st   begin" "check" "new   topology" "degraded" )  ;  discard discard 1  =  testing util . get discard for cache ( cache ( c 1  )  )  ;  discard discard 2  =  testing util . get discard for cache ( cache ( c 2  )  )  ;   cache coordinator = c 1   =  =  0  ?  cache (  1  )  : cache ( 0 )  ;  old transport coord = advance on global component method ( ss coordinator . get cache manager (  )   transport . class match method call ( "invoke remotely" )  . with matcher (  1  new  cache topology control command matcher (  cache topology control command .  type . rebalance   start )  )  . match count ( 0 )  . build (  )  )  . after ( "st   begin" )  . get original component (  )  ;  old transporta 1  = advance on global component method ( ss cache ( a 1  )  . get cache manager (  )   transport . class match method call ( "invoke remotely" )  . with matcher (  1  new  cache topology control command matcher (  cache topology control command .  type . ch   update )  )  . after state ( ss "check" )  . match count ( 0 )  . build (  )  )  . before ( "new   topology" )  . get original component (  )  ;  bctm =  blocking cluster topology manager . replace ( coordinator . get cache manager (  )  )  ;   blocking cluster topology manager .  handle <  integer >  blockingste = bctm . start blocking topology confirmations ( topology id  -  >  true )  ;   function <  embedded cache manager j channel >  channel retriever = ecm  -  >   {  if  ( ecm  =  =  manager ( 0 )  && c 1   !  =  0 )   {  return  (  ( j groups transport ) old transport coord )  . get channel (  )  ;   }  else if  ( ecm  =  =  manager (  1  )  && c 1   =  =  0 )   {  return  (  ( j groups transport ) old transport coord )  . get channel (  )  ;   }  else if  ( ecm  =  =  manager ( a 1  )  )   {  return  (  ( j groups transport ) old transporta 1  )  . get channel (  )  ;   }  else  {  return  (  ( j groups transport ) ecm . get transport (  )  )  . get channel (  )  ;   }   }   ;  discard 1  . set discard all ( true )  ;   stream <  address >  new members 1  = manager ( c 2  )  . get transport (  )  . get members (  )  . stream (  )  . filter ( n  -  >   ! n . equals ( manager ( c 1  )  . get address (  )  )  )  ;   testing util . install new view ( new members 1  channel retriever manager ( c 2  )  manager ( a 1  )  manager ( a 2  )  )  ;   testing util . install new view ( channel retriever manager ( c 1  )  )  ;  ss . enter ( "check" )  ;  assert keys available for read ( cache ( c 2  )  keys )  ;  assert keys available for read ( cache ( a 1  )  keys )  ;  assert keys available for read ( cache ( a 2  )  keys )  ;  eventually degraded ( cache ( c 1  )  )  ;  assert keys not available for read ( cache ( c 1  )  keys )  ;  ss . exit ( "check" )  ;  discard 2  . set discard all ( true )  ;   stream <  address >  new members 2  = manager ( a 1  )  . get transport (  )  . get members (  )  . stream (  )  . filter ( n  -  >   ! n . equals ( manager ( c 2  )  . get address (  )  )  )  ;   testing util . install new view ( new members 2  channel retriever manager ( a 1  )  manager ( a 2  )  )  ;   testing util . install new view ( channel retriever manager ( c 2  )  )  ;  ss . advance ( "degraded" )  ;  eventually degraded ( cache ( a 1  )  )  ;  eventually degraded ( cache ( a 2  )  )  ;  eventually degraded ( cache ( c 2  )  )  ;  blockingste . stop blocking (  )  ;  assert keys not available for read ( cache ( a 1  )  keys )  ;  assert keys not available for read ( cache ( a 2  )  keys )  ;  assert keys not available for read ( cache ( c 1  )  keys )  ;  assert keys not available for read ( cache ( c 2  )  keys )  ;  int m 1  = merge in split order  ?  c 1  : c 2  ;  int m 2  = merge in split order  ?  c 2  : c 1  ;   ( merge in split order  ?  discard 1  : discard 2  )  . set discard all ( false )  ;   testing util . install new view ( channel retriever manager ( a 1  )  manager ( a 2  )  manager ( m 1  )  )  ;  eventually available ( cache ( a 1  )  )  ;  eventually available ( cache ( a 2  )  )  ;  eventually available ( cache ( m 1  )  )  ;  eventually degraded ( cache ( m 2  )  )  ;  assert keys available for read ( cache ( m 1  )  keys )  ;  assert keys available for read ( cache ( a 1  )  keys )  ;  assert keys available for read ( cache ( a 2  )  keys )  ;  assert keys not available for read ( cache ( m 2  )  keys )  ;   ( merge in split order  ?  discard 2  : discard 1  )  . set discard all ( false )  ;   testing util . install new view ( channel retriever manager ( a 1  )  manager ( a 2  )  manager ( m 1  )  manager ( m 2  )  )  ;  eventually available ( cache ( m 2  )  )  ;  assert keys available for read ( cache ( m 2  )  keys )  ;  assert keys available for read ( cache ( m 1  )  keys )  ;  assert keys available for read ( cache ( a 1  )  keys )  ;  assert keys available for read ( cache ( a 2  )  keys )  ;   }  
@ override public  expiry policy   (  )  {  return new  expiry policy (  )  {  @ override public  duration get expiry for creation (  )  {  return new  duration (  time unit . milliseconds lifespan )  ;   }  @ override public  duration get expiry for acce
private static boolean   (  method tree method tree )  {   expression tree call to super = null ;   statement tree statement tree = method tree . block (  )  . body (  )  . get ( 0 )  ;  if  ( returns void ( method tree )  && statement tree . is (  tree .  kind . expression   statement )  )   {  call to super =  (  (  expression statement tree ) statement tree )  . expression (  )  ;   }  else if  ( statement tree . is (  tree .  kind . return   statement )  )   {  call to super =  (  (  return statement tree ) statement tree )  . expression (  )  ;   }  return call to super  !  =  null && is call to super ( method tree call to super )  && same visibility ( method tree . symbol (  )   (  (  method invocation tree ) call to super )  . symbol (  )  )  ;   }  
@ test public void   (  )  {  assert null (  observable . from array ( 1 2 )  . element at ( 2 )  . blocking get (  )  )  ;   }  
public  string   (  )  {  return name ;   }  
@ test public void   (  )  {   maybe <  integer >  o =  observable . just ( 1 )  . filter ( new  predicate <  integer >  (  )  {  @ override public boolean test (   integer t1 )  {  return t1 % 2  =  =  0 ;   }   }   )  . last element (  )  ;   maybe obse
@ override public  object   (  constant <  ?  >  expr  void context )  {   object value = super . visit ( expr context )  ;  return morphia . get mapper (  )  . to mongo object ( null null value )  ;   }  
private static boolean   (  variable tree variable tree )  {   type super class = variable tree . symbol (  )  . enclosing class (  )  . super class (  )  ;  return super class  !  =  null && super class . is subtype of ( struts   action   superclass )  && excluded   struts   action   parameter   types . contains ( variable tree . symbol (  )  . type (  )  . fully qualified name (  )  )  ;   }  
@ test public void   (  )  throws  exception  {  final  test yaml file network topology snitch snitch = new  test yaml file network topology snitch ( "cassandra - topology . yaml" )  ;  check endpoint ( snitch fb utilities . get broadcast address (  )  . 
@ override public  store configuration   (  )  {  return configuration ;   }  
private void   (  )  {  header = create linked node (  )  ;  header . before = header ;  header . after = header ;   }  
protected void   (  )  {  add metadata ( id  column metadata . named ( "id" )  )  ;  add metadata ( firstname  column metadata . named ( "firstname" )  )  ;  add metadata ( lastname  column metadata . named ( "lastname" )  )  ;  add metadata ( salary  column metadata . named ( "salary" )  )  ;  add metadata ( datefield  column metadata . named ( "datefield" )  )  ;  add metadata ( timefield  column metadata . named ( "timefield" )  )  ;  add metadata ( superior id  column metadata . named ( "superior   id" )  )  ;   }  
public  person   (  )  {  return person 2  ;   }  
public void   (  )  throws  exception  {  do timeout test ( false false )  ;   }  
@ override public boolean   (  )  {  return true ;   }  
public boolean   (  string state name )  {  lock . lock (  )  ;  try  {   state state = state map . get ( state name )  ;  if  ( state . signalled )  return true ;   logical thread logical thread = logical threads . get ( state . thread name )  ;  return state name . equals ( logical thread . current state )  ;   }  finally  {  lock . unlock (  )  ;   }   }  
public boolean   ( final long date )  {  return date  >  =  valid from &&  ( is active now (  )  || date  <  =  valid to )  ;   }  
@ override public void   (  object session  object key )  throws  cache exception  {   transaction coordinator access transaction coordinator = session   access . get transaction coordinator ( session )  ;   removal synchronization sync = new  removal syn
@ override public void   (  )  {  threads running . increment and get (  )  ;  try  {  if  ( s  =  =  null )   {   system . out . println ( " test multi threaded observable on next: null" )  ;  throw npe ;   }  else  {   system . out . println ( " test mu
@ override @ nullable public  throwable   (  )  {   object o = value . get (  )  ;  if  (  notification lite . is error ( o )  )   {  return  notification lite . get error ( o )  ;   }  return null ;   }  
@ override public  object   (  invocation context ctx  read write many command command )  throws  throwable  {  return handle write many command ( ctx command )  ;   }  
@ test public void   (  )  {  final  warning value impl = new  warning value ( " 1  1 0 fred \"stale\"" )  ;   assert . assert equals (  1  1 0 impl . get warn code (  )  )  ;   assert . assert equals ( "fred" impl . get warn agent (  )  )  ;   assert . a
public  channel   (  )  {  return channel ;   }  
@ test @ in sequence ( value =  8  )  @ operate on deployment ( "dep . active -  2 " )  public void   (  )  throws  exception  {   list <  document >  search = member registration . index search ( " totally invented name" )  ;  assert not null ( " search 
@ test public void   (  )  throws  exception  {   handle h = db rule . open handle (  )  ;   something original = new  something ( 0 " keith" )  ;  assert that ( h . create update ( "insert into something  ( id  name )  values  ( :id  :name ) " )  . bind 
public void   (  object constant )  {  append ( templates . as literal ( constant )  )  ;   }  
public int   (  )  {  return batch size ;   }  
@ test public void   (  )  throws  exception  {   global configuration builder overridden configuration = new  global configuration builder (  )  ;  overridden configuration . transport (  )  . rack id ( "r 2 " )  ;  object under test =  spring embedded c
 list <  peer state >    (  remote host id host info )  {   list <  peer state >  rv = new  array list <  peer state >  ( 4 )  ;  byte[] ip = host info . getip (  )  ;  if  ( ip  !  =  null && ip . length  =  =  4 )   {  for  (   peer state ps :    peers by ident . values (  )  )   {  if  (  data helper . eq ( ip ps . get remoteip (  )  )  )  rv . add ( ps )  ;   }   }  return rv ;   }  
@ override public void   (  disposable d )  {  sd . replace ( d )  ;   }  
public get   multi   slice   args   (  multi slice request request )  {  this . request = request ;  return this ;   }  
public static boolean   (  string type )  {  return type   std   client . equals ( type )  || type   http   client . equals ( type )  || type   socks . equals ( type ) || type   socks   irc . equals ( type ) || type   connect . equals ( type ) || type   streamr   client . equals ( type ) || type   irc   client . equals ( type )  ;   }  
public boolean   (  )  {  return use local encoding ;   }  
public void   (  string value )  {  this . value = value ;   }  
public double   (  )  {  return badness   threshold ;   }  
@ override public  statement context   (  )  {  return ctx ;   }  
public  string   (  )  {  return nickname ;   }  
@ override public void   ( byte[] b int off int len )  throws io exception  {  throw new  unsupported operation exception (  )  ;   }  
public void   (  )  {   remote cache <  integer  string >  cache0 = client ( 0 )  . get cache (  )  ;  cache0 . put (  6  "v 1 " )  ;   req . replace . execute ( cache0  6  "v0" )  ;  expect cached then expired ( cache0  6  "v0" )  ;   }  
public int   (  )  {  return message   type ;   }  
@ test public void   (  )  {   java check verifier . verify ( "src / test / files / checks /  public static field should be final check . java" new  public static field should be final check (  )  )  ;   }  
public void   ( i2p session session )  {     session . remove subsession ( session )  ;  boolean removed =    subsessions . remove ( session )  ;  if  ( removed )   {  if  (    log . should log (  log . warn )  )     log . warn ( " removeed subsession "  +  session )  ;   }  else  {  if  (    log . should log (  log . warn )  )     log . warn ( " subsession not found to remove "  +  session )  ;   }   }  
@ override public boolean   (  )  {  return times . decrement and get (  )   =  =  0 ;   }  
public void   (  )  throws  messaging exception  {   mock transport mock = open and inject mock transport (  )  ;  setup open folder ( mock )  ;  m folder . open (  open mode . read   write )  ;   message message1 = m folder . create message ( "1" )  ;  assert false ( message1 . is set (  flag . seen )  )  ;   fetch profile fp = new  fetch profile (  )  ;  fp . clear (  )  ;  fp . add (  fetch profile .  item . flags )  ;  mock . expect ( get next tag ( false )   +  " uid fetch 1 \\ ( uid flags\\ ) " new  string[] { "* 1 fetch  ( uid 1 flags  ( \\ seen )  ) " "* 2 fetch  ( flags  ( \\ seen )  ) " get next tag ( true )   +  " ok success" }  )  ;  m folder . fetch ( new  message[] { message1 }  fp null )  ;  assert true ( message1 . is set (  flag . seen )  )  ;   }  
@ test public void   (  )  throws  exception  {   cache <  affinity key  string >  cache = cache managers . get ( 0 )  . get cache (  )  ;   int stream . range ( 0  1 0 )  . boxed (  )  . for each ( num  -  >  cache . put ( new  affinity key ( num )  "val
public static  json object   (  )  {  return new  json object ( new  hash map <  string  object >  (  )  )  ;   }  
@ override public  string   (  )  {  return null ;   }  
@ override public  metadata   (  )  {  return new  embedded metadata .  builder (  )  . lifespan ( lifespan )  . max idle ( max idle )  . build (  )  ;   }  
private static  immutable map <  expression <  ?  >   integer >    (  list <  expression <  ?  >  >  exprs )  {   map <  expression <  ?  >   integer >  map =  maps . new hash map (  )  ;  for  ( int i = 0 ;  i  <  exprs . size (  )  ;  i +  +  )   {   expression <  ?  >  e = exprs . get ( i )  ;  if  ( e instanceof  operation &&  (  (  operation <  ?  >  ) e )  . get operator (  )   =  =   ops . alias )   {  map . put (  (  (  operation <  ?  >  ) e )  . get arg (  1  )  i )  ;   }  map . put ( e i )  ;   }  return  immutable map . copy of ( map )  ;   }  
@ test public void   (  )  throws  exception  {   kernel services servicesa = create kernel services builder ( null )  . set subsystem xml ( get subsystem xml (  )  )  . build (  )  ;   model node modela = servicesa . read whole model (  )  ;   string mar
@ test public void   (  )  throws  exception  {  registered put test ( true )  ;   }  
private void   (  )  throws  push state exception  {  if  ( push state future  =  =  null || push state future . is done (  )  )   {   callable <  ?  >  task = create push state task (  )  ;  push state future = executor . submit ( task )  ;  try  {  wait for task to finish ( push state future singleton configuration . push state timeout (  )   time unit . milliseconds )  ;   }  catch  (   exception e )   {  throw new  push state exception ( "unable to complete in memory state push to cache loader" e )  ;   }   }  else  {  await for push to finish ( push state future singleton configuration . push state timeout (  )   time unit . milliseconds )  ;   }   }  
public  header   ( final  string name )  {  return headergroup  !  =  null  ?  headergroup . get first header ( name )  : null ;   }  
@ override public  worker   (  )  {  return new  worker (  )  {  @ override public  disposable schedule (   runnable run  long delay   time unit unit )  {   scheduler runnable introspection outer wrapper =  (  scheduler runnable introspection ) run ;   sc
public  string   (  )  {  return description ;   }  
@ test public void   (  )  throws io exception  {  final int expected = 32 ;  buffer . put ( new byte[64] )  ;  assert equals ( " byte buffer should fill given array and return the amount read" expected buffer . get ( new byte[32] )  )  ;   }  
@ data provider ( name = "clip test data" )  public  object[][]   (  )  {  final  string forward =  illumina adapter pair . paired   end . get3 prime adapter (  )  ;  final  string se   forward =  illumina adapter pair . single   end . get3 prime adapter 
public void   (  string page )  {  this . page = page ;   }  
@ override public v   ( k key v value )  {  return await ( read write . eval ( key value set value return prev or null (  )  )  )  ;   }  
public void   (  )  throws  exception  {   state sequencer sequencer = new  state sequencer (  )  ;  sequencer . logical thread ( "main" "main:start" "main:check" )  ;  sequencer . logical thread ( "primary" "primary:block   prepare" "primary:after   rollback" "primary:resume   prepare" "primary:after   prepare" )  ;  sequencer . logical thread ( "backup" "backup:block   prepare" "backup:after   rollback" "backup:resume   prepare" "backup:after   prepare" )  ;  sequencer . order ( "main:start" "primary:block   prepare" "primary:after   prepare" "main:check" )  ;  sequencer . order ( "main:start" "backup:block   prepare" "backup:after   prepare" "main:check" )  ;  advance on interceptor ( sequencer cache (  1  )   state transfer interceptor . class match command (  versioned prepare command . class )  . match count ( 0 )  . build (  )  )  . before ( "primary:block   prepare" "primary:resume   prepare" )  . after ( "primary:after   prepare" )  ;  advance on interceptor ( sequencer cache (  1  )   state transfer interceptor . class match command (  rollback command . class )  . build (  )  )  . after ( "primary:after   rollback" )  ;  advance on interceptor ( sequencer cache (  2  )   state transfer interceptor . class match command (  versioned prepare command . class )  . match count ( 0 )  . build (  )  )  . before ( "backup:block   prepare" "backup:resume   prepare" )  . after ( "backup:after   prepare" )  ;  advance on interceptor ( sequencer cache (  2  )   state transfer interceptor . class match command (  rollback command . class )  . build (  )  )  . after ( "backup:after   rollback" )  ;  assert equals (  arrays . as list ( address (  1  )  address (  2  )  )  advanced cache ( 0 )  . get distribution manager (  )  . locate ( test   key )  )  ;  sequencer . advance ( "main:start" )  ;  tm ( 0 )  . begin (  )  ;  cache ( 0 )  . put ( test   key tx 1    value )  ;  try  {  tm ( 0 )  . commit (  )  ;  fail ( " exception expected during commit" )  ;   }  catch  (   exception e )   {   }  tm ( 0 )  . begin (  )  ;  cache ( 0 )  . put ( test   key tx 2    value )  ;   global transaction gtx 1  = transaction table ( 0 )  . get local transaction ( tm ( 0 )  . get transaction (  )  )  . get global transaction (  )  ;  tm ( 0 )  . commit (  )  ;   thread . sleep ( completed   tx   timeout  +   1 000 )  ;  assert true ( transaction table (  1  )  . is transaction completed ( gtx 1  )  )  ;  assert true ( transaction table (  2  )  . is transaction completed ( gtx 1  )  )  ;  sequencer . advance ( "main:check" )  ;   lock manager lock manager 1  =  testing util . extract lock manager ( cache (  1  )  )  ;  assert false ( lock manager 1  . is locked ( test   key )  )  ;  assert false ( transaction table (  1  )  . contain remote tx ( gtx 1  )  )  ;  assert false ( transaction table (  2  )  . contain remote tx ( gtx 1  )  )  ;  for  (   cache cache : caches (  )  )   {  assert equals ( tx 2    value cache . get ( test   key )  )  ;   }   }  
public boolean   (  )  {  return connections per host  =  =  0 ;   }  
@ override protected  embedded cache manager   (  )  throws  exception  {  return  test cache manager factory . create cache manager (  )  ;   }  
@ test @ ignore ( "scan seed no longer emits without upstream signal" )  public void   (  )  {   publish processor <  integer >  source =  publish processor . create (  )  ;   test subscriber <  integer >  ts = new  test subscriber <  integer >  (  )  ;  
@ override public t   ( long timeout  time unit unit )  throws  interrupted exception   execution exception   timeout exception  {  if  ( get count (  )   !  =  0 )   {   blocking helper . verify non blocking (  )  ;  if  (  ! await ( timeout unit )  )   
public void   (  )  throws  throwable  {  final  cache <  string  string >  cache = cache ( 0 "timestamps" )  ;  cache . put ( "k" "v" )  ;   count down latch will timeout latch = new  count down latch (  1  )  ;   count down latch lock aquired signal = new  count down latch (  1  )  ;   delaying listener dl = new  delaying listener ( lock aquired signal will timeout latch )  ;  cache . add listener ( dl )  ;  final  list <  throwable >  throwables = new  linked list <  >  (  )  ;   future <  ?  >  future = fork (  (  )   -  >   {  try  {  cache . put ( "k" "v 3 " )  ;   }  catch  (   throwable th )   {  throwables . add ( th )  ;   }   }   )  ;  lock aquired signal . await (  )  ;  dl . wait latch . count down (  )  ;  future . get (  1 0 seconds )  ;  assert throwables . size (  )   =  =   1  ;  assert throwables . get ( 0 )  instanceof  cache exception ;   }  
@ override public  integer   (  )  {  return id ;   }  
public void   (  type type  block catch block )  {  if  ( type . is ( "java . lang .  exception" )  || type . is ( "java . lang .  throwable" )  || type . is subtype of ( "java . lang .  error" ) || type . is subtype of ( "java . lang .  runtime exception" ) ||  ! type . is subtype of ( "java . lang .  exception" )  )   {  runtime catches . add ( catch block )  ;   }  catches . put ( type catch block )  ;   }  
@ override public void   (  compilation unit tree tree )  {  scan ( tree . package declaration (  )  )  ;  scan ( tree . imports (  )  )  ;  scan ( tree . types (  )  )  ;  scan ( tree . module declaration (  )  )  ;   }  
@ override public void   (  cache < k v >  cache  set < k >  input keys )  {  this . cache = cache ;   }  